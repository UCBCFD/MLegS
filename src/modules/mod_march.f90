MODULE MOD_MARCH ! LEVEL 4 MODULE
  USE omp_lib
  USE MPI
  USE MOD_MISC, ONLY : P4,P8,PI,IU,SPY,MSAVE,MLOAD,CFL               ! LEVEL 0
!XUSE USE MOD_FD                                                         ! LEVEL 1
  USE MOD_EIG                                                        ! LEVEL 1
!XUSE USE MOD_LIN_LEGENDRE                                               ! LEVEL 1
!XUSE USE MOD_BANDMAT                                                    ! LEVEL 1
  USE MOD_SCALAR3                                                    ! LEVEL 2
  USE MOD_FFT                                                        ! LEVEL 2.5
  USE MOD_LEGOPS                                                     ! LEVEL 3
!XUSE USE MOD_LAYOUT                                                     ! LEVEL 3
  IMPLICIT NONE
  PRIVATE
!=======================================================================
!============================ PARAMETERS ===============================
!=======================================================================
  !1> TIME ADVANCEMENT INFORMATION
  PUBLIC:: TIMEDATA
  TYPE TIMEDATA
    REAL(P8):: DT,T,LIMIT
    INTEGER:: N
    INTEGER:: SCHEME
  ENDTYPE TIMEDATA
  TYPE(TIMEDATA),PUBLIC:: TIM

  !2> FREESTREAM VELOCITY FIELD INFORMATION
  PUBLIC:: IMPOSED_FIELD
  TYPE IMPOSED_FIELD
    INTEGER:: SW, INT  
    REAL(P8):: UX,UY,UZ
    REAL(P8):: X,Y
    REAL(P8):: T0,X0,Y0,T1,X1,Y1
  ENDTYPE IMPOSED_FIELD
  TYPE(IMPOSED_FIELD),PUBLIC:: ADV

  !3> VORTEX REMOVAL
  PUBLIC:: REMOVAL
  TYPE REMOVAL
    INTEGER:: SW,INT
  ENDTYPE REMOVAL
  TYPE(REMOVAL),PUBLIC:: RMV

  !4> VISCOSITY ADJUSTMENT
  PUBLIC:: VISCOSITY
  TYPE VISCOSITY
    INTEGER:: SW,P,ADJSW,ADJINT
    REAL(P8):: NU,NUP
  ENDTYPE VISCOSITY
  TYPE(VISCOSITY),PUBLIC:: VISC

  !5> FILE INOUT
  PUBLIC:: IOFILES
  TYPE IOFILES
    CHARACTER(LEN=72):: SAVEDIR 
    CHARACTER(LEN=72):: PSI0,CHI0
    CHARACTER(LEN=72):: PSII,CHII
    REAL(P8),DIMENSION(:),POINTER:: T
    CHARACTER(LEN=72),DIMENSION(:),POINTER:: PSI,CHI
    INTEGER:: N,NE
  ENDTYPE IOFILES
  TYPE(IOFILES),PUBLIC:: FILES

  !6> DIAGNOSTIC INFOMRATION STORAGE
  PUBLIC:: DIAGDATA
  TYPE DIAGDATA
    INTEGER:: IT1,IT2,INIFLAG
    REAL(P8):: VORI,ZMOMI,ENEI,ANGI,HELI,XCEN,YCEN
  ENDTYPE DIAGDATA
  TYPE(DIAGDATA),PUBLIC:: DIAGV

  !7> LINEAR DATA INFORMATION STORAGE
  PUBLIC:: LINEARDATA
  TYPE LINEARDATA
    INTEGER:: MM,KK
  ENDTYPE LINEARDATA
  TYPE(LINEARDATA),PUBLIC:: LIN

  !8> POSTPROCESS KIT
  PUBLIC:: POSTPROCESSKIT
  TYPE POSTPROCESSKIT
    INTEGER :: START, FINISH, JOB, SLICEINT
  ENDTYPE POSTPROCESSKIT
  TYPE(POSTPROCESSKIT),PUBLIC:: POSTPROCESS

  !9> EIGENVALUE MONITOR KIT
  PUBLIC:: MONITOREIGENVALUESKIT
  TYPE MONITOREIGENVALUESKIT
    INTEGER :: START, INTERVAL
  ENDTYPE MONITOREIGENVALUESKIT
  TYPE(MONITOREIGENVALUESKIT),PUBLIC:: MONITORDATA

  REAL(P8):: SUMMO,SUMKO,NUPB                                        ! USED IN THE HYPADJ SUBROUTINE
  INTEGER:: FIRST=0                                                  ! USED IN THE HYPADJ SUBROUTINE
!=======================================================================
!======================== PUBLIC DECLARATION ===========================
!=======================================================================
  ! TIME ADVANCEMENT SCHEMES (ADAMS-BASHFORTH, RICHARDSON, EULER)
  PUBLIC:: ADAMSB, RICH, EULER
  ! VISCOSITY & HYPERVISCOSITY IMPOSITION
  PUBLIC:: VISC1,VISC2,HYPERV
  ! DIAGNOSIS OF FIELD
  PUBLIC:: DIAGNOST
  ! ADJUST FREESTREAM VELOCITY
  PUBLIC:: FREEADJ
  ! KILL VORTEX AWAY FROM THE COMPUTATIONAL DOMAIN
  PUBLIC:: REMOVE
  ! COMPUTE INTEGRATION OF TWO FUNCTION FOR EACH AZIMUTHAL/AXIAL WVN
  PUBLIC:: PRODCTM, PRODCTK
  ! COMPUTE ENERGY FOR EACH AZIMUTHAL/AXIAL WAVENUMBER
  PUBLIC:: ENEMON
  ! HYPERVISCOSITY ADJUSTMENT
  PUBLIC:: HYPADJ
! ============================== MOD_FD ================================
! ! SMOOTHING BY CONVOLUTION
! PUBLIC:: SMOOTH
! ! UNUSED FUNCTIONS
! PUBLIC:: DC,DDC,OPER
  
CONTAINS
!=======================================================================
!============================ SUBROUTINES ==============================
!=======================================================================
  SUBROUTINE ADAMSB(PSI,CHI,PSINO,CHINO)
!=======================================================================
! [USAGE]: 
! UPDATE POLOIDAL-TOROIDAL TERMS OF THE VELOCITY FIELD BY 1 TIME STEP
! USING ADAMS-BASHFORTH METHOD
! [PARAMETERS]:
! PSI >> TOROIDAL TERM IN A SCALAR-TYPE VARIABLE
! CHI >> POLOIDAL TERM IN A SCALAR-TYPE VARIABLE
! PSINO >> NONLINEAR COMPONENT OF THE TOROIDAL TERM IN THE PREVIOUS STEP
! CHINO >> NONLINEAR COMPONENT OF THE POLOIDAL TERM IN THE PREVIOUS STEP
! [DEPENDENCIES]:
! 1. (DE)ALLOCATE(~) @ MOD_SCALAR3
! 2. NONLIN(~) @ MOD_LEGOPS
! 3. VISC2(~) @ MOD_MARCH
! 4. HYPERV(~) @ MOD_MARCH
! [UPDATES]:
! RE-CODED BY SANGJOON LEE @ NOV 20 2020
!=======================================================================
  IMPLICIT NONE
  TYPE(SCALAR):: PSI,CHI,PSINO,CHINO
  TYPE(SCALAR):: PSIN,CHIN

  TYPE(SCALAR):: PSI0,CHI0
  REAL(P8):: DT

  DT = TIM%DT
  TIM%T = TIM%T + DT
  TIM%N = TIM%N + 1
  ADV%X = ADV%X + ADV%UX*DT
  ADV%Y = ADV%Y + ADV%UY*DT

  CALL ALLOCATE( PSIN )
  CALL ALLOCATE( CHIN )

  CALL NONLIN(PSI,CHI,PSIN,CHIN)

  CALL ALLOCATE( PSI0 )
  CALL ALLOCATE( CHI0 )

  PSI0 = PSI
  CHI0 = CHI

  PSI%E = PSI%E +DT*(1.5D0*PSIN%E -0.5D0*PSINO%E)
  CHI%E = CHI%E +DT*(1.5D0*CHIN%E -0.5D0*CHINO%E)

  PSINO=PSIN
  CHINO=CHIN

  CALL DEALLOCATE( PSIN )
  CALL DEALLOCATE( CHIN )

  CALL VISC2(PSI,CHI,PSI0,CHI0)
  CALL HYPERV(PSI,CHI,DT)

  CALL DEALLOCATE( PSI0 )
  CALL DEALLOCATE( CHI0 )

  RETURN
  END SUBROUTINE ADAMSB
!=======================================================================
  SUBROUTINE RICH(PSI,CHI,PSIN,CHIN)
!=======================================================================
! [USAGE]: 
! UPDATE POLOIDAL-TOROIDAL TERMS OF THE VELOCITY FIELD BY 1 TIME STEP
! USING RICHARDSON EXTRAPOLATION
! [PARAMETERS]:
! PSI >> TOROIDAL TERM IN A SCALAR-TYPE VARIABLE
! CHI >> POLOIDAL TERM IN A SCALAR-TYPE VARIABLE
! PSIN >> NONLINEAR COMPONENT OF THE TOROIDAL TERM
! CHIN >> NONLINEAR COMPONENT OF THE POLOIDAL TERM
! [DEPENDENCIES]:
! 1. (DE)ALLOCATE(~) @ MOD_SCALAR3
! 2. NONLIN(~) @ MOD_LEGOPS
! 3. VISC1(~) @ MOD_MARCH
! 4. HYPERV(~) @ MOD_MARCH
! [UPDATES]:
! RE-CODED BY SANGJOON LEE @ NOV 20 2020
!=======================================================================
  IMPLICIT NONE
  TYPE(SCALAR):: PSI,CHI,PSIN,CHIN

  TYPE(SCALAR):: PSI2,CHI2
  TYPE(SCALAR):: PN,CN
  REAL(P8):: DT, HDT

  DT = TIM%DT
  HDT = DT*0.5D0
  TIM%T = TIM%T + DT
  TIM%N = TIM%N + 1
  ADV%X = ADV%X + ADV%UX*DT
  ADV%Y = ADV%Y + ADV%UY*DT

  CALL ALLOCATE(PSI2)
  CALL ALLOCATE(CHI2)

  CALL ALLOCATE( PN )
  CALL ALLOCATE( CN )

  ! FIRST HALF-STEP
  CALL NONLIN(PSI,CHI,PSIN,CHIN)
  PSI2%E =PSI%E + (HDT*PSIN%E)
  CHI2%E =CHI%E + (HDT*CHIN%E)
  CALL VISC1(PSI2,CHI2,HDT)
  CALL HYPERV(PSI2,CHI2,HDT)

  ! SECOND HALF-STEP
  CALL NONLIN(PSI2,CHI2,PN,CN)

  PSI2%E =PSI2%E + (HDT*PN%E)
  CHI2%E =CHI2%E + (HDT*CN%E)
  CALL VISC1(PSI2,CHI2,HDT)
  CALL HYPERV(PSI2,CHI2,HDT)

  ! FULL STEP
  PSI%E =PSI%E +(DT)*PSIN%E
  CHI%E =CHI%E +(DT)*CHIN%E

  CALL VISC1(PSI,CHI,DT)
  CALL HYPERV(PSI,CHI,DT)

  PSI%E =(2.0D0*PSI2%E)-PSI%E
  CHI%E =(2.0D0*CHI2%E)-CHI%E

  CALL DEALLOCATE( PSI2 )
  CALL DEALLOCATE( CHI2 )
  CALL DEALLOCATE( PN )
  CALL DEALLOCATE( CN )

  RETURN
  END SUBROUTINE RICH
!=======================================================================

  SUBROUTINE EULER(PSI,CHI,PSIN,CHIN)
!=======================================================================
! [USAGE]: 
! UPDATE POLOIDAL-TOROIDAL TERMS OF THE VELOCITY FIELD BY 1 TIME STEP
! USING FORWARD EULER METHOD
! [PARAMETERS]:
! PSI >> TOROIDAL TERM IN A SCALAR-TYPE VARIABLE
! CHI >> POLOIDAL TERM IN A SCALAR-TYPE VARIABLE
! PSIN >> NONLINEAR COMPONENT OF THE TOROIDAL TERM
! CHIN >> NONLINEAR COMPONENT OF THE POLOIDAL TERM
! [DEPENDENCIES]:
! 1. (DE)ALLOCATE(~) @ MOD_SCALAR3
! 2. NONLIN(~) @ MOD_LEGOPS
! 3. VISC1(~) @ MOD_MARCH
! 4. HYPERV(~) @ MOD_MARCH
! [UPDATES]:
! RE-CODED BY SANGJOON LEE @ NOV 20 2020
!=======================================================================
  IMPLICIT NONE
  TYPE(SCALAR):: PSI,CHI,PSIN,CHIN

  REAL(P8):: DT

  DT = TIM%DT
  TIM%T = TIM%T + DT
  TIM%N = TIM%N + 1
  ADV%X = ADV%X + ADV%UX*DT
  ADV%Y = ADV%Y + ADV%UY*DT

  CALL NONLIN(PSI,CHI,PSIN,CHIN)

  PSI%E =PSI%E + (DT*PSIN%E)
  CHI%E =CHI%E + (DT*CHIN%E)

  CALL VISC1(PSI,CHI,DT)
  CALL HYPERV(PSI,CHI,DT)

  RETURN
  END SUBROUTINE EULER
!=======================================================================
  SUBROUTINE VISC1(PSI,CHI,DT)
!=======================================================================
! [USAGE]: 
! UPDATE TOROIDAL TERMS OF THE VELOCITY FIELD WITH REGARD TO VISCOSITY
! USING BACKWARD (IMPLICIT) EULER METHOD
! [PARAMETERS]:
! PSI >> TOROIDAL TERM IN A SCALAR-TYPE VARIABLE
! CHI >> POLOIDAL TERM IN A SCALAR-TYPE VARIABLE
! DT >> TIMESTEP
! [DEPENDENCIES]:
! 1. (DE)ALLOCATE(~) @ MOD_SCALAR3
! 2. IHELM(~) @ MOD_LEGOPS
! [NOTES]:
! THE FOLLOWING FORMULA IS UTILIZED TO UPDATE PSI.
!     PSI(1)-PSI(0)
!     ------------- = VISCNU(DEL2)(PSI(1))
!           DT
! [UPDATES]:
! RE-CODED BY SANGJOON LEE @ NOV 20 2020
!=======================================================================
  IMPLICIT NONE
  TYPE(SCALAR):: PSI,CHI
  REAL(P8):: DT

  TYPE(SCALAR):: WK1
  REAL(P8):: ALP

  IF(VISC%SW.NE.1) RETURN

  IF(VISC%NU.EQ.0.0) THEN
    IF (MPI_RANK.EQ.0) WRITE(*,*) 'VISC: VISC%NU CAN''T BE ZERO'
    STOP
  ENDIF

  CALL ALLOCATE( WK1,FFF_SPACE )
  ALP=1/(VISC%NU*DT)

  IF ((PSI%INTH.EQ.0).AND.(PSI%INX.EQ.0)) WK1%LN=-ALP*PSI%LN
  WK1%E =-ALP*PSI%E
  CALL IHELM(WK1,PSI,ALP)

  IF ((CHI%INTH.EQ.0).AND.(CHI%INX.EQ.0)) WK1%LN=-ALP*CHI%LN
  WK1%E =-ALP*CHI%E
  CALL IHELM(WK1,CHI,ALP)

  CALL DEALLOCATE( WK1 )

  RETURN
  END SUBROUTINE VISC1
!=======================================================================
  SUBROUTINE VISC2(PSI,CHI,PSIO,CHIO)
!=======================================================================
! [USAGE]: 
! UPDATE TOROIDAL TERMS OF THE VELOCITY FIELD WITH REGARD TO VISCOSITY
! USING CRANK-NICHOLSON (IMPLICIT) METHOD
! [PARAMETERS]:
! PSI >> TOROIDAL TERM IN A SCALAR-TYPE VARIABLE
! CHI >> POLOIDAL TERM IN A SCALAR-TYPE VARIABLE
! PSIO >> TOROIDAL TERM IN A SCALAR-TYPE VARIABLE IN A PREVIOUS STEP
! CHIO >> POLOIDAL TERM IN A SCALAR-TYPE VARIABLE IN A PREVIOUS STEP
! [DEPENDENCIES]:
! 1. (DE)ALLOCATE(~) @ MOD_SCALAR3
! 2. CHOPSET(~) @ MOD_SCALAR3
! 3. CHOPDO(~) @ MOD_SCALAR3
! 4. DEL2(~) @ MOD_LEGOPS
! 5. IHELM(~) @ MOD_LEGOPS
! [NOTES]:
! THE FOLLOWING FORMULA IS UTILIZED TO UPDATE PSI.
!    PSI(1)-PSI(1/2)               PSI(1)+PSI(0)
!    ------------- = VISCNU(DEL2)(--------------)
!          DT                            2
! [UPDATES]:
! RE-CODED BY SANGJOON LEE @ NOV 20 2020
!=======================================================================
  IMPLICIT NONE
  TYPE(SCALAR):: PSI,CHI,PSIO,CHIO

  TYPE(SCALAR):: WK1
  REAL(P8):: ALP

  IF(VISC%SW.NE.1) RETURN

  IF(VISC%NU.EQ.0.0) THEN
    IF (MPI_RANK.EQ.0) WRITE(*,*) 'VISC: VISC%NU CANNOT BE ZERO'
    STOP
  ENDIF

  CALL ALLOCATE( WK1 )

  ALP=2/VISC%NU/TIM%DT

  CALL CHOPSET(2)
  CALL DEL2(PSIO,WK1)
  CALL CHOPSET(-2)
  CALL CHOPDO(WK1)

  WK1%E = -WK1%E-ALP*PSI%E
  IF ((PSI%INTH.EQ.0).AND.(PSI%INX.EQ.0)) WK1%LN= -ALP*PSI%LN
  CALL IHELM(WK1,PSI,ALP)

  CALL CHOPSET(2)
  CALL DEL2(CHIO,WK1)
  CALL CHOPSET(-2)
  CALL CHOPDO(WK1)

  WK1%E = -WK1%E-ALP*CHI%E
  IF ((CHI%INTH.EQ.0).AND.(CHI%INX.EQ.0)) WK1%LN= -ALP*CHI%LN
  CALL IHELM(WK1,CHI,ALP)

  CALL DEALLOCATE( WK1 )

  RETURN
  END SUBROUTINE VISC2
!=======================================================================
  SUBROUTINE HYPERV(PSI,CHI,DT)
!=======================================================================
! [USAGE]: 
! APPLYING BOTH VISCOSITY AND HYPERVISOCISTY USING FORWARD-EURLER METHOD
! OPERATES ONLY WHEN VISC%SW = 2
! [PARAMETERS]:
! PSI >> TOROIDAL TERM IN A SCALAR-TYPE VARIABLE
! CHI >> POLOIDAL TERM IN A SCALAR-TYPE VARIABLE
! DT >> TIMESTEP
! [NOTES]:
! THE FOLLOWING FORMULA IS UTILIZED TO UPDATE PSI.
!    PSI(1)-PSI(0)
!    ------------- = [NU*DEL2 - (-1)^(P/2)NUP*DELP] * PSI(1)
!          DT
! TO APPLY ONLY HYPERV, SET VISCOSITY'S NU TO ZERO !
! [DEPENDENCIES]:
! 1. (DE)ALLOCATE(~) @ MOD_SCALAR3
! 2. IHELMP(~) @ MOD_LEGOPS
! [UPDATES]:
! RE-CODED BY SANGJOON LEE @ NOV 20 2020
!=======================================================================
  IMPLICIT NONE
  TYPE(SCALAR):: PSI,CHI
  REAL(P8):: DT
  
  TYPE(SCALAR):: W
  REAL(P8):: ALP,BET
  INTEGER:: PH

  IF(VISC%SW.EQ.0) THEN
    IF ((MPI_RANK.EQ.0).AND.(MOD(tim%n,diagv%it1).eq.0)) WRITE(6,*) 'HYPERV: WARNING: NO DISSIPATION AT ALL.'
  ELSEIF(VISC%SW.EQ.2) THEN
    CALL ALLOCATE( W )
    PH = VISC%P/2
    ALP = 1/DT/VISC%NUP *(-1)**PH
    BET = -(-1)**PH*VISC%NU/VISC%NUP

    W%E = ALP*PSI%E
    IF ((PSI%INTH.EQ.0).AND.(PSI%INX.EQ.0)) W%LN = ALP*PSI%LN
    CALL IHELMP(VISC%P,W,PSI,-ALP,BET)
    
    W%E = ALP*CHI%E
    IF ((CHI%INTH.EQ.0).AND.(CHI%INX.EQ.0)) W%LN = ALP*CHI%LN
    CALL IHELMP(VISC%P,W,CHI,-ALP,BET)
    CALL DEALLOCATE( W )
  ENDIF

  RETURN
  END SUBROUTINE HYPERV
!=======================================================================
  SUBROUTINE DIAGNOST(PSI,CHI)
!=======================================================================
! [USAGE]: 
! PERFORM DIAGNOSIS ON THE POLOIDAL-TOROIDAL TERMS PSI AND CHI
! NOTE THAT BOTH PSI AND CHI MUST BE IN FFF SPACE
! [PARAMETERS]:
! PSI >> TOROIDAL TERM IN A SCALAR-TYPE VARIABLE
! CHI >> POLOIDAL TERM IN A SCALAR-TYPE VARIABLE
! [DEPENDENCIES]:
! 1. (DE)ALLOCATE(~) @ MOD_SCALAR3
! 2. CHOPSET(~) @ MOD_SCALAR3
! 3. INTEG(~)   @ MOD_SCALAR3
! 4. RTRAN(~)   @ MOD_SCALAR3
! 5. PC2VEL(~)  @ MOD_LEGOPS
! 6. PC2VOR(~)  @ MOD_LEGOPS
! 7. XXDX(~)    @ MOD_LEGOPS
! 8. DELSQH(~)  @ MOD_LEGOPS
! 9. DEL2(~)    @ MOD_LEGOPS
! 10. MULXM(~)  @ MOD_LEGOPS
! 11. CALCXY(~) @ MOD_MARCH
! [UPDATES]:
! RE-CODED BY SANGJOON LEE @ NOV 20 2020
!=======================================================================
  IMPLICIT NONE
  TYPE(SCALAR):: PSI,CHI

  TYPE(SCALAR):: RUR,RUP,UZH
  TYPE(SCALAR):: ROR,ROP,OZH
  ! COMPLEX(P8),DIMENSION(NXCHOPDIM):: PSIAT1,CHIAT1
  COMPLEX(P8),DIMENSION(:),ALLOCATABLE:: PSIAT1,CHIAT1
  REAL(P8):: ENE1,ENE2,VALVOR,VALZMO,VALANG,VALENE,HEL1,VALHEL,PSI_CHECK
  REAL(P8):: PAT1MAX,PAT1MIN,CAT1MAX,CAT1MIN
  INTEGER:: NN,MM,KK

  ! --------------------
  ! CHECK INITIALIZATION
  ! --------------------
  ! THIS SUBROUTINE MUST BE CALLED ONCE WHILE TIM%N = 0        
  !                                                             
  ! TIM IS OF "TIMEDATA" DATA-TYPE, WHERE N IS AN INTEGER.
  ! DIAGV IS OF "DIAGDATA" DATA-TYPE; INIFLAG IS AN INT.

  IF(TIM%N.NE.0 .AND. DIAGV%INIFLAG.NE.100) THEN
    IF (MPI_RANK.EQ.0) WRITE(*,*) 'DIAG: WARNING:INITIALIZE INCOMPLETE !!'
  ENDIF

  ! ----------
  ! NORM CHECK
  ! ----------
  ! THE FOLLOWINGS ARE DONE BELOW:
  !
  ! THE M=0, K=0 MODES ARE TAKEN TO SEE WHAT THEIR IMAGINARY PART IS.
  ! THE ARRAYS START AT 1 (NOT 0: NDIMR-1), 
  ! HENCE (*,1,1) CORRESPONDS TO THE M=0 K=0 DATA.
  ! HOWEVER THE FIRST PIECE OF THE LEGENDRE POLYNOMIAL SERIES IS A CONSTANT
  ! HENCE IT IS CHECKED TO SEE IF THE PSI AND CHI ARE REAL FOR THE 
  ! SECOND PIECE IN THE R-SERIES ... HENCE (2,1,1)

  IF ((PSI%INTH.EQ.0).AND.(PSI%INX.EQ.0)) THEN
    IF(ABS(AIMAG(PSI%E(2,1,1))+AIMAG(CHI%E(2,1,1))).GT.1E-18) THEN
      WRITE(6,*) '### DIAG: NORM INCOMPLETE !!!'
      WRITE(6,*) '### PSI%E(2,1,1)=',PSI%E(2,1,1)
      WRITE(6,*) '### CHI%E(2,1,1)=',CHI%E(2,1,1)
      WRITE(6,*) '###'
    ENDIF
  ENDIF

  ! ----------------
  ! DEALIASING CHECK
  ! ----------------

  IF(MOD(TIM%N,1000).EQ.20) THEN
    PSI_CHECK = 0.0
    IF (PSI%INTH.EQ.0) THEN
      IF (SIZE(PSI%E,2).GE.2) THEN
        PSI_CHECK = MAXVAL(REAL(PSI%E(NRCHOPS(1)+1:,1,:))) + &
                      MAXVAL(REAL(PSI%E(NRCHOPS(2)+1:,2,:)))
      ELSE
        PSI_CHECK = MAXVAL(REAL(PSI%E(NRCHOPS(1)+1:,1,:)))
      ENDIF
    ELSEIF (PSI%INTH.EQ.1) THEN
      PSI_CHECK = MAXVAL(REAL(PSI%E(NRCHOPS(2)+1:,1,:)))
    ENDIF
    CALL MPI_ALLREDUCE(MPI_IN_PLACE, PSI_CHECK, 1, MPI_DOUBLE_PRECISION, &
        MPI_MAX, MPI_COMM_IVP, IERR)
    IF ((MPI_RANK.EQ.0).AND.(PSI_CHECK.NE.0.0)) THEN
      WRITE(*,*) 'DIAG:DEALIASING INCOMPLETE'
      CALL SPY(PSI%E(:,1,:))
      !STOP
      CALL MPI_ABORT(MPI_COMM_IVP,1,IERR) 
    ENDIF
  ENDIF

  ! ----------------------------
  ! CALCULATION DIVERGENCE CHECK
  ! ----------------------------

  PSI_CHECK = 0.0
  IF ((PSI%INTH.LE.6).AND.(PSI%INX.LE.5)) THEN
    DO KK=1,MIN(5-PSI%INX,SIZE(PSI%E,3)) !NXCHOPDIM)
      DO MM=2,MIN(6-PSI%INTH,SIZE(PSI%E,2)) !NTCHOP)
        DO NN=1,MIN(5,NRCHOP)
          IF(ABS(PSI%E(NN,MM,KK)).GT.100.) THEN
            PSI_CHECK = 1.0
            WRITE(6,*) '### CALCULATION DIVERGING !!!'
            WRITE(6,60) TIM%T,TIM%N
            WRITE(6,*) '(NN,MM,KK,PSI)=',NN,MM+PSI%INTH,KK+PSI%INX,PSI%E(NN,MM,KK)
            ! CALL MSAVE(PSI,FILES%PSI(FILES%N))
            ! CALL MSAVE(CHI,FILES%CHI(FILES%N))
            ! STOP
          ENDIF
        ENDDO
      ENDDO
    ENDDO
  ENDIF
  CALL MPI_ALLREDUCE(MPI_IN_PLACE, PSI_CHECK, 1, MPI_DOUBLE_PRECISION, &
        MPI_MAX, MPI_COMM_IVP, IERR)
  IF ((MPI_RANK.EQ.0).AND.(PSI_CHECK.NE.0.0)) CALL MPI_ABORT(MPI_COMM_IVP,1,IERR) 

  ! --------------
  ! MAIN DIAGNOSIS 
  ! --------------

  IF(MOD(TIM%N,DIAGV%IT1).EQ.0) THEN
    CALL ALLOCATE( RUR )
    CALL ALLOCATE( RUP )
    CALL ALLOCATE( UZH )
    CALL ALLOCATE( ROR )
    CALL ALLOCATE( ROP )
    CALL ALLOCATE( OZH )

    CALL CHOPSET(3)

    CALL PC2VEL(PSI,CHI,RUR,RUP,UZH,'H')
    CALL PC2VOR(PSI,CHI,ROR,ROP,OZH,'H')

    !> VORTICITY 
    VALVOR= INTEG(OZH)

    !> Z-DIRECTION MOMENTUM 
    VALZMO= INTEG(UZH)

    !> ANGULAR MOMENTUM 
    RUR=PSI
    RUR%LN=0
    CALL XXDX(RUR,RUP)
    VALANG = -INTEG(RUP)

    !> ENERGY P157
    RUP=PSI
    IF ((RUP%INTH.EQ.0).AND.(RUP%INX.EQ.0)) RUP%LN=2*RUP%LN
    CALL DELSQH(RUP,RUR) ! RUR = DELSQH(PSI)/(1-X)^2
    CALL RTRAN(RUR,1)
    RUP=PSI

    RUP%LN=0
    CALL RTRAN(RUP,1)
    ENE1= PRODCT(RUR,RUP) ! PRODCT(A,B) CALCULATES THE PRODUCT OF A*B*(1-X)^2 AND INTEGRATES OVER THE DOMAIN

    CALL DEL2(CHI,RUP)
    CALL RTRAN(RUP,1)
    CALL DELSQH(CHI,RUR)
    CALL RTRAN(RUR,1)
    ENE2= PRODCT(RUR,RUP)
    VALENE = -ENE1+ENE2 ! PRODCT uses MPI_ALLREDUCE

    !> HELICITY P157
    CALL DELSQH(PSI,RUR)
    CALL RTRAN(RUR,1)
    HEL1 =PRODCT(RUR,RUP)
    VALHEL = 2*HEL1
    CALL DEALLOCATE( RUR )
    CALL DEALLOCATE( RUP )
    CALL DEALLOCATE( UZH )

    !> STORE THE INITIAL VALUES
    IF(TIM%N .EQ.0) THEN
      DIAGV%INIFLAG = 100
      DIAGV%VORI = VALVOR 
      DIAGV%ZMOMI = VALZMO
      DIAGV%ENEI = VALENE
      DIAGV%HELI = VALHEL
      DIAGV%ANGI = VALANG
    ENDIF

    IF (MPI_RANK.EQ.0) THEN
      WRITE(*,*) '<<< DIAGNOSTICS >>>'
      WRITE(6,60) TIM%T,TIM%N
60     FORMAT('TIM%T=',E13.4,' TIM%N=',I8)
      WRITE(6,62) ADV%X,ADV%Y
62     FORMAT('ADV%X=',E13.5,'  ADV%Y=',E13.5)
70     FORMAT(A12,'=',E23.15, '  FRACTIONAL CHANGE=',E23.15)
    ENDIF

    IF (PSI%INTH.EQ.0) THEN ! PROCS WITH M=0 MODES
      ALLOCATE(PSIAT1(SIZE(PSI%E,3)),CHIAT1(SIZE(CHI%E,3)))
      PSIAT1= CALCAT1(PSI)
      CHIAT1= CALCAT1(CHI)
      PAT1MAX = MAXVAL(ABS(PSIAT1))
      PAT1MIN = MINVAL(ABS(PSIAT1))
      CAT1MAX = MAXVAL(ABS(CHIAT1))
      CAT1MIN = MINVAL(ABS(CHIAT1))
      CALL MPI_ALLREDUCE(MPI_IN_PLACE,PAT1MAX,1,MPI_DOUBLE_PRECISION,MPI_MAX,SUBCOMM_1,IERR)
      CALL MPI_ALLREDUCE(MPI_IN_PLACE,PAT1MIN,1,MPI_DOUBLE_PRECISION,MPI_MIN,SUBCOMM_1,IERR)
      CALL MPI_ALLREDUCE(MPI_IN_PLACE,CAT1MAX,1,MPI_DOUBLE_PRECISION,MPI_MAX,SUBCOMM_1,IERR)
      CALL MPI_ALLREDUCE(MPI_IN_PLACE,CAT1MIN,1,MPI_DOUBLE_PRECISION,MPI_MIN,SUBCOMM_1,IERR)

      IF (PSI%INX.EQ.0) THEN ! PROC WITH M=0, K=0 MODE
        IF (PAT1MAX-PAT1MIN.GT.1.0E-10 .OR. &
          CAT1MAX-CAT1MIN.GT.1.0E-10) THEN
          WRITE(6,81) 'PSIAT1(KK=1)=',ABS(PSIAT1(1)),PAT1MAX-PAT1MIN
          WRITE(6,81) 'CHIAT1(KK=1)=',ABS(CHIAT1(1)),CAT1MAX-CAT1MIN
81      FORMAT(A,E18.9, ' MAXMIN=',E18.9)              
        ENDIF
      ENDIF
      DEALLOCATE(PSIAT1,CHIAT1)
    ENDIF

    IF (MPI_RANK.EQ.0) THEN
      WRITE(6,*) 'CFL#=',CFL*TIM%DT

      IF(DIAGV%VORI.NE.0.0) THEN
        WRITE(6,70) 'VORTICITY',VALVOR,(VALVOR-DIAGV%VORI)&
                                      /DIAGV%VORI
      ELSE
        WRITE(6,70) 'VORTICITY',VALVOR
      ENDIF

      IF(DIAGV%ZMOMI.NE.0.0) THEN
        WRITE(6,70) 'Z-MOMENTUM',VALZMO,(VALZMO-DIAGV%ZMOMI)&
                                        /DIAGV%ZMOMI
      ELSE
        WRITE(6,70) 'Z-MOMENTUM',VALZMO
      ENDIF

      WRITE(6,70) 'ENERGY',VALENE,-(DIAGV%ENEI-VALENE)/DIAGV%ENEI

      IF(DIAGV%HELI.NE.0.0) THEN
        WRITE(6,70) 'HELICITY',VALHEL,-(DIAGV%HELI-VALHEL)&
                                      /DIAGV%HELI
      ELSE
        WRITE(6,70) 'HELICITY',VALHEL
      ENDIF

      IF(DIAGV%ANGI.NE.0.0) THEN
      WRITE(6,70) 'INTEG_ANGMOM ',VALANG,-(DIAGV%ANGI-VALANG)&
                                          /DIAGV%ANGI
      ELSE
        WRITE(6,70) 'INTEG_ANGMOM ',VALANG
      ENDIF
    ENDIF

    CALL ALLOCATE(RUR)
    CALL MULXM(OZH,RUR)
    CALL MULXM(RUR,OZH)
    CALL DEALLOCATE(RUR)
    CALL CALCXY(ROR,ROP,OZH)
    CALL CHOPSET(-3)
    CALL DEALLOCATE( ROR )
    CALL DEALLOCATE( ROP )
    CALL DEALLOCATE( OZH )
  ENDIF

  RETURN
  END SUBROUTINE DIAGNOST
!=======================================================================
  SUBROUTINE CALCXY(ROR,ROP,OZH)
!=======================================================================
! [USAGE]: 
! COMPUTE THE LOCATION OF THE VORTEX (<X>,<Y>) BY WEIGHTING X AND Y
! WITH ENSTROPHY. THIS ROUTINE IS FOR MONITORING PURPOSE AND DOES NOT
! AFFECT THE NONLINEAR COMPUTATION. 
! [PARAMETERS]:
! ROR >> R*OMEGA_R TERM IN A SCALAR-TYPE VARIABLE IN A PPP SPACE
! ROP >> R*OMEGA_P TERM IN A SCALAR-TYPE VARIABLE IN A PPP SPACE
! OZH >> OMEGA_Z TERM IN A SCALAR-TYPE VARIABLE IN A PPP SPACE
! [DEPENDENCIES]:
! 1. TOFP(~)      @ MOD_SCALAR3
! 2. TOFF(~)      @ MOD_SCALAR3
! 3. INTEG(~)     @ MOD_SCALAR3
! 4. ABSVEC2(~)   @ MOD_MARCH
! 5. MULRCOSTH(~) @ MOD_MARCH
! 6. MULRSINTH(~) @ MOD_MARCH
! 7. MULR2(~)     @ MOD_MARCH
! [NOTE]:
! THIS ROUTINE IS INSERTED HERE TO SAVE THE TIME FOR TRANSFORMS THAT
! WOULD HAPPEN IF THIS ROUTINE WERE CALLED FROM SUBROUTINE DIAG.
! [UPDATES]:
! RE-CODED BY SANGJOON LEE @ NOV 20 2020
! MPI-ED BY JINGE WANG @ SEP 29 2021
!=======================================================================
  IMPLICIT NONE
  TYPE(SCALAR):: ROR,ROP,OZH

  REAL(P8):: VALENS,VALX,VALY,VALR

  IF (MPI_RANK.EQ.0) OPEN(UNIT=14,FILE='coresize.dat',POSITION='APPEND')

  CALL TOFP(ROR)
  CALL TOFP(ROP)
  CALL TOFP(OZH)
  CALL ABSVEC2(ROR,ROP,OZH,OZH)

  ROR=OZH
  CALL TOFF(ROR)
  VALENS=INTEG(ROR)

  ROR=OZH
  CALL MULRCOSTH(ROR)
  CALL TOFF(ROR)
  VALX=INTEG(ROR)/VALENS

  ROR=OZH
  CALL MULRSINTH(ROR)
  CALL TOFF(ROR)
  VALY=INTEG(ROR)/VALENS

  ROR=OZH
  CALL MULR2(ROR)
  CALL TOFF(ROR)
  VALR=SQRT(INTEG(ROR)/VALENS)

  IF (MPI_RANK.EQ.0) THEN
    WRITE(6,60) TIM%T,VALX,VALY,VALR
    WRITE(14,'(4E14.6)') TIM%T,VALX,VALY,VALR
    CLOSE(14)
60   FORMAT('T= ',E10.3,' <X>= ',E10.3,' <Y>= ',E10.3,' <R>= ',E10.3)
  ENDIF

  IF(TIM%N.EQ.0) THEN
    ADV%T0=TIM%T-TIM%DT
    ADV%X0=VALX
    ADV%Y0=VALY
    ADV%T1=TIM%T
    ADV%X1=ADV%X0
    ADV%Y1=ADV%Y0
  ELSE
    ADV%T0=ADV%T1
    ADV%X0=ADV%X1
    ADV%Y0=ADV%Y1
    ADV%T1=TIM%T
    ADV%X1=VALX
    ADV%Y1=VALY
  ENDIF

  RETURN
  END SUBROUTINE CALCXY
!=======================================================================
  SUBROUTINE ABSVEC2(U,V,W,A)
!=======================================================================
! [USAGE]: 
! COMPUTE THE LOCATION OF THE VORTEX (<X>,<Y>) BY WEIGHTING X AND Y
! WITH ENSTROPHY. THIS ROUTINE IS FOR MONITORING PURPOSE AND DOES NOT
! AFFECT THE NONLINEAR COMPUTATION. 
! [PARAMETERS]:
! U >> R*U_R TERM IN A SCALAR-TYPE VARIABLE IN A PPP SPACE
! V >> R*U_PHI TERM IN A SCALAR-TYPE VARIABLE IN A PPP SPACE
! W >> U_Z TERM IN A SCALAR-TYPE VARIABLE IN A PPP SPACE
! A >> ON ENTRY, STORES THE ADVECTIVE VELOCITY INFORMATION
!      DIVIDED BY (1-X)**2.
!      PREFERABLY CHOOSE ONE OF U, V, AND W
! [NOTE]:
! THIS IS A CUSTOM ROUTINE FOR CALCXY.
! [UPDATES]:
! RE-CODED BY SANGJOON LEE @ NOV 20 2020
! MPI-ED BY JINGE WANG @ SEP 29 2021
!=======================================================================
  IMPLICIT NONE
  TYPE(SCALAR):: U,V,W,A
  INTEGER:: I,MM,KK
  REAL(P8):: AAA,BBB
  REAL(P8):: RUR,RVR,WR
  REAL(P8):: RUI,RVI,WI,R,F

  DO KK=1,SIZE(U%E,3) !NX
    DO MM=1,NTH
      DO I=1,SIZE(U%E,1) !NR
        R  = TFM%R(I+U%INR)
        F = (1-TFM%X(I+U%INR))**2
        RUR=REAL(U%E(I,MM,KK))
        RUI=AIMAG(U%E(I,MM,KK))
        RVR=REAL(V%E(I,MM,KK))
        RVI=AIMAG(V%E(I,MM,KK))
        WR=REAL(W%E(I,MM,KK))
        WI=AIMAG(W%E(I,MM,KK))
        AAA = ( (RUR**2+RVR**2)/R**2 + WR**2)
        BBB = ( (RUI**2+RVI**2)/R**2 + WI**2)
        A%E(I,MM,KK) = CMPLX(AAA,BBB,P8)/F
      ENDDO
    ENDDO
  ENDDO

  RETURN
  END SUBROUTINE ABSVEC2
!=======================================================================
  SUBROUTINE MULRCOSTH(A)
!=======================================================================
! [USAGE]: 
! MULTIPLY R*COS(TH) TO A FIELD A; 
! [PARAMETERS]:
! A >> A SCALAR-TYPE VARIABLE. ON EXIT, MULTIPLIED BY R*COS(TH)
! [NOTE]:
! THIS IS A CUSTOM ROUTINE FOR CALCXY.
! [UPDATES]:
! RE-CODED BY SANGJOON LEE @ NOV 20 2020
! MPI-ED BY JINGE WANG @ SEP 29 2021
!=======================================================================
  IMPLICIT NONE
  TYPE(SCALAR):: A
  
  REAL(P8):: R,Z,THR,THI,AAA,BBB
  INTEGER:: KK,NN,MM
  
  CALL TOFP(A)

  DO KK=1,SIZE(A%E,3) !NX
    DO MM=1,NTH
      DO NN=1,SIZE(A%E,1) !NR
        !Z  = TFM%Z(KK+A%INX)
        R  = TFM%R(NN+A%INR)
        THR = TFM%THR(MM)
        THI = TFM%THI(MM)
        AAA = R*COS(THR)*REAL(A%E(NN,MM,KK))
        BBB = R*COS(THI)*AIMAG(A%E(NN,MM,KK))
        A%E(NN,MM,KK)= CMPLX(AAA,BBB,P8)
      ENDDO
    ENDDO
  ENDDO

  RETURN
  END SUBROUTINE MULRCOSTH
!=======================================================================
  SUBROUTINE MULRSINTH(A)
!=======================================================================
! [USAGE]: 
! MULTIPLY R*SIN(TH) TO A FIELD A IN PPP-SPACE
! [PARAMETERS]:
! A >> A SCALAR-TYPE VARIABLE. ON EXIT, MULTIPLIED BY R*SIN(TH)
! [NOTE]:
! THIS IS A CUSTOM ROUTINE FOR CALCXY.
! [UPDATES]:
! RE-CODED BY SANGJOON LEE @ NOV 20 2020
! MPI-ED BY JINGE WANG @ SEP 29 2021
!=======================================================================
  IMPLICIT NONE
  TYPE(SCALAR):: A

  REAL(P8):: R,Z,THR,THI,AAA,BBB
  INTEGER:: KK,NN,MM

  CALL TOFP(A)

  DO KK=1,SIZE(A%E,3) !NX
    DO MM=1,NTH
      DO NN=1,SIZE(A%E,1) !NR
        !Z  = TFM%Z(KK+A%INX)
        R  = TFM%R(NN+A%INR)
        THR = TFM%THR(MM)
        THI = TFM%THI(MM)
        AAA = R*SIN(THR)*REAL(A%E(NN,MM,KK))
        BBB = R*SIN(THI)*AIMAG(A%E(NN,MM,KK))
        A%E(NN,MM,KK)= CMPLX(AAA,BBB,P8)
      ENDDO
    ENDDO
  ENDDO

  RETURN
  END SUBROUTINE MULRSINTH
!=======================================================================
  SUBROUTINE MULR2(A)
!=======================================================================
! [USAGE]: 
! MULTIPLY R**2 TO A FIELD A
! [PARAMETERS]:
! A >> A SCALAR-TYPE VARIABLE. ON EXIT, MULTIPLIED BY R**2
! [NOTE]:
! THIS IS A CUSTOM ROUTINE FOR CALCXY.
! [UPDATES]:
! RE-CODED BY SANGJOON LEE @ NOV 20 2020
! MPI-ED BY JINGE WANG @ SEP 29 2021
!=======================================================================
  IMPLICIT NONE
  TYPE(SCALAR):: A

  REAL(P8):: R,Z,THR,THI,AAA,BBB
  INTEGER:: KK,NN,MM

  CALL TOFP(A)

  DO KK=1,SIZE(A%E,3) !NX
    DO MM=1,NTH
      DO NN=1,SIZE(A%E,1) !NR
        !Z  = TFM%Z(KK+A%INX)
        R  = TFM%R(NN+A%INR)
        !THR = TFM%THR(MM)
        !THI = TFM%THI(MM)
        AAA = R**2*REAL(A%E(NN,MM,KK))
        BBB = R**2*AIMAG(A%E(NN,MM,KK))
        A%E(NN,MM,KK)= CMPLX(AAA,BBB,P8)
      ENDDO
    ENDDO
  ENDDO

  RETURN
  END SUBROUTINE MULR2
!=======================================================================
  SUBROUTINE FREEADJ()
!=======================================================================
! [USAGE]: 
! ADJUST FREESTREAM VELOCITY SUCH THAT THE CENTER OF VORTICITY
! DISTRIBUTION IS AT THE CENTER OF THE COMPUTATIONAL DOMAIN.
! [PARAMETERS]:
! N/A
! [UPDATES]:
! RE-CODED BY SANGJOON LEE @ NOV 20 2020
! MPI-ED BY JINGE WANG @ SEP 29 2021
!=======================================================================
  REAL(P8):: FREEDT,VX,VY

  FREEDT = ADV%INT*TIM%DT
  VX = (ADV%X1-ADV%X0)/(ADV%T1-ADV%T0) ! VELOCITY OF THE CENTER OF VORTEX
  VY = (ADV%Y1-ADV%Y0)/(ADV%T1-ADV%T0)
  ADV%UX = ADV%UX - ADV%X1/FREEDT - VX ! CANCEL OUT THE MOTION OF THE VORTEX CENTER
  ADV%UY = ADV%UY - ADV%Y1/FREEDT - VY
  
  NADD%U = SQRT(ADV%UX**2+ADV%UY**2) ! ADVECTIVE VELOCITY IN R-THETA PLANE
  
  IF(NADD%U.EQ.0.0) THEN
    NADD%ANG = 0.0
  ELSE
    IF(ADV%UY >= 0) THEN
      NADD%ANG = ACOS(ADV%UX/NADD%U)
    ELSE 
      NADD%ANG = -1.0*ACOS(ADV%UX/NADD%U)
    ENDIF
  ENDIF

  IF (MPI_RANK.EQ.0) THEN
    WRITE(6,60) TIM%N,TIM%T
60   FORMAT('FREEADJ: TIM%N=',I5,' TIM%T=',F10.6)
    WRITE(6,61) ADV%UX,ADV%UY,ADV%UZ
61   FORMAT('FREEADJ: ADV%UX=',E18.10,'  UY=',E18.10,' UZ=',E18.10)
    WRITE(6,62) NADD%U,NADD%ANG
62   FORMAT('FREEADJ: NADD%U=',E18.10,' ANG=',E18.10)
  ENDIF

  RETURN
  END SUBROUTINE FREEADJ
!=======================================================================
  SUBROUTINE REMOVE(PSI,CHI)
!=======================================================================
! [USAGE]: 
! KILL THE VORTICES WHICH MOVES AWAY FROM THE COMPUTATIONAL DOMAIN
! [PARAMETERS]:
! PSI >> TOROIDAL TERM IN A SCALAR-TYPE VARIABLE IN A FFF SPACE
! CHI >> POLOIDAL TERM IN A SCALAR-TYPE VARIABLE IN A FFF SPACE
! [DEPENDENCIES]:
! 1. (DE)ALLOCATE(~) @ MOD_SCALAR3
! 2. RTRAN(~)        @ MOD_SCALAR3
! 3. CHOPSET(~)      @ MOD_SCALAR3
! 4. DELSQH(~)       @ MOD_LEGOPS
! 5. IDELSQH(~)      @ MOD_LEGOPS
! 6. DEL2(~)         @ MOD_LEGOPS
! 7. IDEL2(~)        @ MOD_LEGOPS
! [UPDATES]:
! RE-CODED BY SANGJOON LEE @ NOV 20 2020
!=======================================================================
  IMPLICIT NONE
  TYPE(SCALAR):: PSI,CHI

  TYPE(SCALAR):: WK
  INTEGER:: NS,NS0,MM,KK,I
  REAL(P8):: LN

  IF(RMV%SW.EQ.1) THEN
    CALL ALLOCATE( WK )
    NS = NR*2/3 ! THE OUTSIDE 1/3 OF THE RADIAL COLLOCATION PTS ARE TOO FAR ARWAY
    NS0 = MIN(NS+4,NR)

    CALL DELSQH(PSI,WK)
    CALL RTRAN(WK,1) ! WK IN PFF SPACE

    ! WK%E(NS0:NR,2:NTCHOP,1:NX)=0
    ! IF (NX>1) WK%E(NS0:NR,1,2:NX)=0
    IF (WK%INTH.EQ.0) THEN
      WK%E(NS0:NR,2:,:)=0
      IF (NX>1) THEN
        ! IF (WK%INX.EQ.0) THEN
        !   WK%E(NS0:NR,1,2:)=0
        ! ELSE
        !   WK%E(NS0:NR,1,:)=0
        ! ENDIF
        WK%E(NS0:NR,1,MAX(2-WK%INX,1):)=0
      ENDIF
    ELSE
      WK%E(NS0:NR,:,:)=0
    ENDIF

    DO KK=1,SIZE(WK%E,3) !NX (old code's PFF contains NX pts in x-dir)
      DO MM=1,SIZE(WK%E,2) !NTCHOP
        ! IF(KK.GT.NXCHOP .AND. KK.LT.NXCHOPH) CYCLE
        WK%E(NS:NR,MM,KK)= WK%E(NS:NR,MM,KK)*TFM%W(NS:NR)
        DO I=1,5
          WK%E(NS:NR,MM,KK)=SMOOTH(WK%E(NS:NR,MM,KK))
        ENDDO
        WK%E(NS:NR,MM,KK)= WK%E(NS:NR,MM,KK)/TFM%W(NS:NR)
      ENDDO
    ENDDO

    CALL RTRAN(WK,-1)
    CALL IDELSQH(WK,PSI)

    CALL CHOPSET(2)
    CALL DEL2(CHI,WK)
    CALL RTRAN(WK,1)

    IF (WK%INTH.EQ.0) THEN
      WK%E(NS0:NR,2:,:)=0
      IF (NX>1) WK%E(NS0:NR,1,MAX(2-WK%INX,1):)=0
    ELSE
      WK%E(NS0:NR,:,:)=0
    ENDIF

    DO KK=1,SIZE(WK%E,3) !NX
      DO MM=1,SIZE(WK%E,2) !NTCHOP
        ! IF(KK.GT.NXCHOP .AND. KK.LT.NXCHOPH) CYCLE
        WK%E(NS:NR,MM,KK)= WK%E(NS:NR,MM,KK)*TFM%W(NS:NR) &
                                            /(1-TFM%X(NS:NR))**2
        DO I=1,5
          WK%E(NS:NR,MM,KK)=SMOOTH(WK%E(NS:NR,MM,KK))
        ENDDO
        WK%E(NS:NR,MM,KK)= WK%E(NS:NR,MM,KK)/TFM%W(NS:NR) &
                                            *(1-TFM%X(NS:NR))**2
      ENDDO
    ENDDO
    CALL CHOPSET(-2)
    CALL RTRAN(WK,-1)
    LN=CHI%LN
    CALL IDEL2(WK,CHI,LN)

    IF (MPI_RANK.EQ.0) WRITE(6,60) TIM%N,TFM%R(NS)
60     FORMAT('REMOVE: TIM%N=',I5,'  R >=',F6.2)

  CALL DEALLOCATE( WK )
  ELSE
    IF (MPI_RANK.EQ.0) WRITE(*,*) 'REMOVE: RMV%SW IS SET TO 0.'
  ENDIF

  RETURN
  END SUBROUTINE REMOVE
!=======================================================================
  SUBROUTINE ENEMON(PSI,CHI,EM,EK)
!=======================================================================
! [USAGE]: 
! COMPUTE ENERGY FOR EACH AZIMUTHAL AND AXIAL WAVE NUMBER
! [PARAMETERS]:
! PSI >> TOROIDAL TERM IN A SCALAR-TYPE VARIABLE IN A FFF SPACE
! CHI >> POLOIDAL TERM IN A SCALAR-TYPE VARIABLE IN A FFF SPACE
! EM >> ENERGY FOR EACH M (AZIMUTHAL WAVENUMBER)
! EK >> ENERGY FOR EACH K (AXIAL WAVENUMBER)
! [DEPENDENCIES]:
! 1. (DE)ALLOCATE(~) @ MOD_SCALAR3
! 2. RTRAN(~)        @ MOD_SCALAR3
! 3. DELSQH(~)       @ MOD_LEGOPS
! 4. DEL2(~)         @ MOD_LEGOPS
! 5. PRODCTM(~)      @ MOD_MARCH
! 6. PRODCTK(~)      @ MOD_MARCH
! [UPDATES]:
! RE-CODED BY SANGJOON LEE @ NOV 20 2020
!=======================================================================
  IMPLICIT NONE
  TYPE(SCALAR):: PSI,CHI, W1,W2
  REAL(P8):: EM(NTCHOP)
  REAL(P8),OPTIONAL:: EK(NXCHOP)

  CALL ALLOCATE(W1)
  CALL ALLOCATE(W2)

  !> ENERGY P157
  W1=PSI
  IF ((PSI%INTH.EQ.0).AND.(PSI%INX.EQ.0)) W1%LN=2*PSI%LN
  CALL DELSQH(W1,W2)
  CALL RTRAN(W2,1)
  W1=PSI
  W1%LN=0
  CALL RTRAN(W1,1)
  EM= PRODCTM(W2,W1)
  IF (PRESENT(EK)) THEN
  EK= PRODCTK(W2,W1)
  END IF
  
  CALL DEL2(CHI,W1)
  CALL RTRAN(W1,1)
  CALL DELSQH(CHI,W2)
  CALL RTRAN(W2,1)
  EM= -EM+PRODCTM(W2,W1)
  IF (PRESENT(EK)) THEN
  EK= -EK+PRODCTK(W2,W1)
  END IF

  CALL DEALLOCATE(W1)
  CALL DEALLOCATE(W2)

  RETURN
  END SUBROUTINE ENEMON
!=======================================================================
  SUBROUTINE HYPADJ(PSI,CHI,NUP)
!=======================================================================
! [USAGE]: 
! ADJUST HYPERVISCOSITY FROM M(AZIMUTHAL)-ENERGY SPECTRUM
! [PARAMETERS]:
! PSI >> TOROIDAL TERM IN A SCALAR-TYPE VARIABLE IN A FFF SPACE
! CHI >> POLOIDAL TERM IN A SCALAR-TYPE VARIABLE IN A FFF SPACE
! NUP >> HYPERVISCOSITY TO CONFINE THE EFFECT OF DISSIPATION
! [DEPENDENCIES]:
! 1. CHOPSET(~) @ MOD_SCALAR3
! 2. ENEMON(~) @ MOD_MARCH
! [UPDATES]:
! RE-CODED BY SANGJOON LEE @ NOV 20 2020
!=======================================================================
  IMPLICIT NONE
  TYPE(SCALAR):: PSI,CHI
  REAL(P8):: NUP

  REAL(P8),DIMENSION(:),ALLOCATABLE:: EM,EK
  REAL(P8),DIMENSION(:),ALLOCATABLE:: SPM,SPK

  REAL(P8):: SUMM,SUMK,FAC,DX,X,SUM,SUMO
  INTEGER:: IS,IE,NM,NK,I

  ALLOCATE( EM(NTCHOP), EK(NXCHOP) )

  CALL CHOPSET(2)
  CALL ENEMON(PSI,CHI,EM,EK)
  CALL CHOPSET(-2)

  IS = SIZE(EM)/3
  IE = SIZE(EM)-2
  NM = IE-IS+1

  ALLOCATE(SPM(NM))

  SPM = LOG10(EM(IS:IE))
  SUMM = 0
  IS = SIZE(EK)/3
  IE = SIZE(EK)
  NK = IE-IS+1

  ALLOCATE(SPK(NK))

  SPK = LOG10(EK(IS:IE))
  SUMK = 0

  DX = 2.0D0/(NM-1)                                                  ! DOT PRODUCT WITH LEGENDRE POLYNOMIAL P_2(X)
  
  DO I=1,NM
    X  = -1+2.0D0*(I-1)/(NM-1)
    FAC = 1
    IF(I.EQ.1 .OR. I.EQ.NM) FAC=0.5D0
    SUMM=SUMM+ FAC*SPM(I)*DX*SQRT(5.0D0/8)*(3*X**2-1)
  ENDDO

  DX = 2.0D0/(NK-1)

  DO I=1,NK
    X  = -1+2.0D0*(I-1)/(NK-1)
    FAC = 1
    IF(I.EQ.1 .OR. I.EQ.NK) FAC=0.5D0
    SUMK=SUMK+ FAC*SPK(I)*DX*SQRT(5.0D0/8)*(3*X**2-1)
  ENDDO

  IF(FIRST.EQ.0) THEN
    FIRST=1
    SUMMO=SUMM
    SUMKO=SUMK
    NUPB = 0.2/(1.5D0*NRCHOP**2/ELL**2)**(VISC%P/2)
  ENDIF

  IF(SUMM.GT.SUMK) THEN
    SUMO = (3*SUMMO+SUMKO)/4
    SUM  = (3*SUMM+SUMK)/4
  ELSE
    SUMO = (SUMMO+3*SUMKO)/4
    SUM  = (SUMM+3*SUMK)/4
  ENDIF

  SUM = 2*(SUM-SUMO) +SUM + 0.2
  SUM = MIN(3.0D0,MAX(-0.5D0,1.5*SUM))
  NUP = (1+SUM)*NUP
  IF(NUP.LT.NUPB) NUP=NUPB

  IF (MPI_RANK.EQ.0) WRITE(6,60) TIM%T,NUP,SUMM,SUMK
60   FORMAT('HYPADJ:T= ',1PE10.3,' NUP= ',1PE10.3,' SUMM= ', &
            1PE10.3, ' SUMK= ',1PE10.3)
  SUMMO=SUMM
  SUMKO=SUMK

  DEALLOCATE( EM, EK, SPM, SPK )

  RETURN
  END SUBROUTINE HYPADJ
! ======================================================================

!=======================================================================
!============================= FUNCTIONS ===============================
!=======================================================================
  FUNCTION PRODCTM(A,B)
!=======================================================================
! [USAGE]: 
! CALCULATE THE PRODUCT AND INTEGRATE OVER THE DOMAIN
! FOR EACH AZIMUTHAL WAVENUMBER.
! CALL IN R-PHYSICAL / PHI,Z-FOURIER SPACE (PFF SPACE)
! WHAT'S INTEGRATED IS F=A*B*(1-MU)^2
! [PARAMETERS]:
! A >> SCALAR-TYPE VARIABLE IN A PFF SPACE
! B >> SCALAR-TYPE VARIABLE IN A PFF SPACE
! [UPDATES]:
! RE-CODED BY SANGJOON LEE @ NOV 20 2020
!=======================================================================
  IMPLICIT NONE
  TYPE(SCALAR):: A,B

  COMPLEX(P8),DIMENSION(:,:),ALLOCATABLE:: PROD !(NR,NTCHOP)
  REAL(P8),DIMENSION(NTCHOP):: PRODCTM
  INTEGER:: MM,KK

  IF(A%SPACE.NE.PFF_SPACE .OR. B%SPACE.NE.PFF_SPACE) THEN
    IF (MPI_RANK.EQ.0) THEN
      WRITE(*,*) 'PRODCT:NOT IN PFF_SPACE'
      WRITE(*,*) 'A%SPACE,B%SPACE=',A%SPACE,B%SPACE
    ENDIF
    STOP
  ENDIF

  IF(A%LN.NE.0.0 .OR. B%LN.NE.0.0) THEN
    IF (MPI_RANK.EQ.0) WRITE(*,*) 'PRODCT:LOGTERM NOT ZERO'
  ENDIF

  ALLOCATE(PROD(NR,SIZE(A%E,2)))
  PROD=0

  DO KK = 1,SIZE(A%E,3) !NX
    !IF(KK.GT.NXCHOP .AND. KK.LT.NXCHOPH) CYCLE
    DO MM = 1,SIZE(A%E,2) !NTCHOP
      ! M = 0
      IF (MM+A%INTH.EQ.1) THEN
        PROD(:,1) = PROD(:,1)+A%E(:NR,1,KK)*CONJG(B%E(:NR,1,KK))
      ! M > 0
      ELSE
      PROD(:,MM) = PROD(:,MM)+2*(REAL(A%E(:NR,MM,KK)) &
                                *REAL(B%E(:NR,MM,KK)) &
                                +AIMAG(A%E(:NR,MM,KK))&
                                *AIMAG(B%E(:NR,MM,KK)))
      ENDIF
    ENDDO
  ENDDO

  PRODCTM = 0.D0
  DO MM=1,SIZE(A%E,2) !NTCHOP
    PRODCTM(MM+A%INTH) = SUM((PROD(:,MM)*TFM%W)*TFM%PF(1,1,1))
    PRODCTM(MM+A%INTH) = 4*PI*ZLEN0*ELL2*PRODCTM(MM+A%INTH)*TFM%NORM(1,1)
  ENDDO
  CALL MPI_ALLREDUCE(MPI_IN_PLACE,PRODCTM,NTCHOP,MPI_DOUBLE_PRECISION, &
                  MPI_SUM, MPI_COMM_IVP, IERR)

  DEALLOCATE(PROD)
  RETURN
  END FUNCTION PRODCTM
!=======================================================================
  FUNCTION PRODCTK(A,B)
!=======================================================================
! [USAGE]: 
! CALCULATE THE PRODUCT AND INTEGRATE OVER THE DOMAIN
! FOR EACH AXIAL WAVENUMBER.
! CALL IN R-PHYSICAL / PHI,Z-FOURIER SPACE (PFF SPACE)
! WHAT'S INTEGRATED IS F=A*B*(1-MU)^2
! [PARAMETERS]:
! A >> SCALAR-TYPE VARIABLE IN A PFF SPACE
! B >> SCALAR-TYPE VARIABLE IN A PFF SPACE
! [UPDATES]:
! RE-CODED BY SANGJOON LEE @ NOV 20 2020
!=======================================================================
  IMPLICIT NONE
  TYPE(SCALAR):: A,B

  ! COMPLEX(P8),DIMENSION(:,:),ALLOCATABLE:: PROD !(NR,NXCHOP)
  REAL(P8),DIMENSION(:,:),ALLOCATABLE:: PROD !(NR,NXCHOP)
  REAL(P8),DIMENSION(NXCHOPDIM):: PRODCTK_TEMP
  REAL(P8),DIMENSION(NXCHOP):: PRODCTK
  INTEGER:: MM,KK,KH,CK,CM

  IF(A%SPACE.NE.PFF_SPACE .OR. B%SPACE.NE.PFF_SPACE) THEN
    IF (MPI_RANK.EQ.0) THEN
      WRITE(*,*) 'PRODCT:NOT IN PFF_SPACE'
      WRITE(*,*) 'A%SPACE,B%SPACE=',A%SPACE,B%SPACE
    ENDIF
    STOP
  ENDIF

  IF(A%LN.NE.0.0 .OR. B%LN.NE.0.0) THEN
    IF (MPI_RANK.EQ.0) WRITE(*,*) 'PRODCT:LOGTERM NOT ZERO'
  ENDIF

  ALLOCATE(PROD(NR,SIZE(A%E,3)))
  PROD=0

  DO KK = 1,SIZE(A%E,3) !NXCHOP
    IF(KK+A%INX.EQ.1) THEN
      CK=2
      KH=1
    ELSE
      CK=1
      !KH=NX-KK+2
    ENDIF

    DO MM = 1,SIZE(A%E,2) !NTCHOP
      CM=1
      IF(MM+A%INTH.EQ.1) CM=2
      ! PROD(:,KK)=PROD(:,KK)+1.0D0/CK/CM* & 
      !            2*REAL(A%E(:NR,MM,KK)*CONJG(B%E(:NR,MM,KK)) &
      !                   +B%E(:NR,MM,KH)*CONJG(A%E(:NR,MM,KH)))
      PROD(:,KK)=PROD(:,KK)+1.0D0/CK/CM* & 
                  2*REAL(A%E(:NR,MM,KK)*CONJG(B%E(:NR,MM,KK))) 
                        !+B%E(:NR,MM,KH)*CONJG(A%E(:NR,MM,KH)))
    ENDDO
  ENDDO

  PRODCTK_TEMP = 0.D0
  DO KK=1,SIZE(A%E,3) !NXCHOP
    PRODCTK_TEMP(KK+A%INX) = SUM((PROD(:,KK)*TFM%W)*TFM%PF(1,1,1))
    PRODCTK_TEMP(KK+A%INX) = 4*PI*ZLEN0*ELL2*PRODCTK_TEMP(KK+A%INX)*TFM%NORM(1,1)
  ENDDO
  CALL MPI_ALLREDUCE(MPI_IN_PLACE,PRODCTK_TEMP,NXCHOPDIM,MPI_DOUBLE_PRECISION, &
                  MPI_SUM, MPI_COMM_IVP, IERR)

  DO KK = 1,NXCHOP
    KH = NXCHOPDIM - KK + 2
    IF (KK.EQ.1) KH = 1
    PRODCTK(KK) = PRODCTK_TEMP(KK) + PRODCTK_TEMP(KH)
  ENDDO

  DEALLOCATE(PROD)
  RETURN
  END FUNCTION PRODCTK
!=======================================================================
!=======================================================================
  FUNCTION SMOOTH(A)
!=======================================================================
! [USAGE]: 
! SMOOTHING A SEQUENCE A BY CONVOLUTION
! [INPUTS]:
! A >> A SEQUENCE CONTAINING NOISES
! [OUTPUTS]:
! SMOOTH >> SMOOTHENED SEQUENCE USING CONVOLUTION
! [UPDATES]:
! RE-CODED BY SANGJOON LEE @ NOV 20 2020
!=======================================================================
  IMPLICIT NONE
  COMPLEX(P8),DIMENSION(:):: A
  COMPLEX(P8),DIMENSION(SIZE(A)):: SMOOTH

  REAL(P8),DIMENSION(3):: FAE=(/ 0.2D0, 0.3D0, 0.5D0 /)
  REAL(P8):: F
  INTEGER:: NI,I,NB,NE

  NI=SIZE(A)

  IF(NI.LT.3) THEN
    WRITE(*,*) 'SMOOTH: SIZE TOO SMALL'
    STOP
  ENDIF

  SMOOTH=0
  SMOOTH(1)=A(1)
  SMOOTH(NI-2:NI)= SMOOTH(NI-2:NI) +A(NI)*FAE

  DO I=2,NI-1
    F = (1+((NI-I)/(NI-1.0D0)))*0.5D0
    SMOOTH(I-1)= SMOOTH(I-1)+A(I)*(1-F)/2
    SMOOTH(I  )= SMOOTH(I  )+A(I)*F
    SMOOTH(I+1)= SMOOTH(I+1)+A(I)*(1-F)/2
  ENDDO

  RETURN
  END FUNCTION SMOOTH
!=======================================================================
  FUNCTION DDC(R)
!=======================================================================
! [USAGE]: 
! SMOOTHING A SEQUENCE A BY CONVOLUTION
! [INPUTS]:
! A >> A SEQUENCE CONTAINING NOISES
! [OUTPUTS]:
! SMOOTH >> SMOOTHENED SEQUENCE USING CONVOLUTION
! [UPDATES]:
! RE-CODED BY SANGJOON LEE @ NOV 20 2020
!=======================================================================
  REAL(P8),DIMENSION(:):: R
  REAL(P8),DIMENSION(SIZE(R),3):: DDC
  REAL(P8):: X0,X1,X2
  INTEGER:: NI,I
  NI = SIZE(R)
  DDC(1,:)=0
  DDC(NI,:)=0
  DO I=2,NI-1
  X0=R(I-1)
  X1=R(I  )
  X2=R(I+1)
  DDC(I,1) = 2/(X0-X1)/(X0-X2)
  DDC(I,2) = 2/(X1-X0)/(X1-X2)
  DDC(I,3) = 2/(X2-X0)/(X2-X1)
  ENDDO

  RETURN
  END FUNCTION DDC
! ======================================================================

! ========================= UNUSED FUNCTIONS ===========================
! !=======================================================================
!       FUNCTION DC(R)
! !=======================================================================
!       REAL(P8),DIMENSION(:):: R
!       REAL(P8),DIMENSION(SIZE(R),3):: DC
!
!       REAL(P8):: X0,X1,X2
!       INTEGER:: NI,I
!
!       NI = SIZE(R)
!       DC(1,:)=0
!       DC(NI,:)=0
!
!       DO I=2,NI-1
!         X0=R(I-1)
!         X1=R(I  )
!         X2=R(I+1)
!         DC(I,1) = (X1-X2)/(X0-X1)/(X0-X2)
!         DC(I,2) = (2*X1-X0-X2)/(X1-X0)/(X1-X2)
!         DC(I,3) = (X1-X0)/(X2-X0)/(X2-X1)
!       ENDDO
!
!       RETURN
!       END FUNCTION DC
! !=======================================================================
!       FUNCTION OPER(OP,F)
! !=======================================================================
!       REAL(P8),DIMENSION(:):: F
!       REAL(P8),DIMENSION(:,:):: OP
!       REAL(P8),DIMENSION(SIZE(F)):: OPER
!
!       INTEGER:: NI,I
!
!       NI = SIZE(F)
!
!       OPER(1)=0
!       OPER(NI)=0
!
!       OPER(2:NI-1) = OP(2:NI-1,1)*F(1:NI-2)  &
!       + OP(2:NI-1,2)*F(2:NI-1)  &
!       + OP(2:NI-1,3)*F(3:NI  )
!
!       RETURN
!       END FUNCTION OPER
! !=======================================================================
END MODULE MOD_MARCH
