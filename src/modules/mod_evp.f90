MODULE MOD_EVP

    USE omp_lib
    USE MPI
    USE MOD_MISC
    USE MOD_BANDMAT
    USE MOD_EIG
    USE MOD_FD
    USE MOD_LIN_LEGENDRE
    USE MOD_SCALAR3
    USE MOD_FFT
    USE MOD_LAYOUT
    USE MOD_LEGOPS
    USE MOD_MARCH, only: VISC, ENEMON
    USE MOD_DIAGNOSTICS, only: ENERGY_SPEC, ENERGY_SPEC_MODIFIED
    !USE MOD_INIT
    IMPLICIT NONE
    PRIVATE

! ======================================================================
! ======================== PUBLIC DECLARIATION =========================
! ======================================================================
    PUBLIC :: XXDX_MK, MULXM_MK
    PUBLIC :: DELSQH_MK, DEL2_MK, IDEL2_MK, HELMP_MK
    PUBLIC :: PC2VOR_MK, PC2VEL_MK, VPROD_MK, PROJECT_MK
    PUBLIC :: RTRAN_MK, ENERGY_MK, ENSTROPHY_MK, ENSTROPHY_MK_MOD, NONLIN_MK, PROD_MK
    PUBLIC :: INIT_LOOP
    PUBLIC :: EIG_MATRIX, EIGENDECOMPOSE, EIGRES!, EIG_MATRIX_SERIAL
    PUBLIC :: EIG2VELVOR, EIG2VEL, EIG2NORMED, EIG2PT
    PUBLIC :: SAVE_VEL, SAVE_PERTURB, SAVE_VEC, SAVE_PSICHI
    PUBLIC :: SAVE_MODE, READ_MODE
    PUBLIC :: MESHGRID

    INTEGER, PUBLIC:: MPI_GLB_PROCS, MPI_GLB_RANK, newcomm
    REAL(P8), DIMENSION(:), ALLOCATABLE, PUBLIC:: RUR0, RUP0, UZ0, ROR0, ROP0, OZ0

    INTERFACE EIGRES
        MODULE PROCEDURE EIGRES1
        MODULE PROCEDURE EIGRESM
    END INTERFACE

    INTERFACE MESHGRID
        MODULE PROCEDURE RESMASK
        MODULE PROCEDURE DIFF2D
    END INTERFACE

! ======================================================================
    CONTAINS
! ======================================================================
! XXDX
! ======================================================================
SUBROUTINE XXDX_MK(A,B)
!=======================================================================
COMPLEX(P8),DIMENSION(:),INTENT(IN):: A
COMPLEX(P8),DIMENSION(:),INTENT(INOUT):: B

INTEGER:: NN
REAL(P8),DIMENSION(:,:),ALLOCATABLE:: XXDXOP

! For PSI & CHI, {0,0} mode needs to consider the log term
IF ((M(2).EQ.0).AND.(AK(2,2).EQ.0.D0)) THEN
    IF (MPI_RANK.EQ.0) WRITE(*,*) 'XXDX_MK: M&AK CANNOT BOTH EQUAL 0'
    RETURN
ENDIF
B = 0.D0

ALLOCATE( XXDXOP(NRCHOP,3) )

NN = NRCHOPS(2)
XXDXOP(:NN,:) = BAND_LOGLEG_XXDX(NN,M(2),TFM%LOGNORM(:,2))
B(:NN)=BANMUL(XXDXOP(:NN,:),2,A(:NN))

DEALLOCATE( XXDXOP )

RETURN
END SUBROUTINE XXDX_MK
! ======================================================================

! MULXM
SUBROUTINE MULXM_MK(A,B)
!=======================================================================
COMPLEX(P8),DIMENSION(:),INTENT(IN):: A
COMPLEX(P8),DIMENSION(:),INTENT(INOUT):: B

INTEGER:: NN
REAL(P8),DIMENSION(:,:),ALLOCATABLE:: XM

IF ((M(2).EQ.0).AND.(AK(2,2).EQ.0.D0)) THEN
    IF (MPI_RANK.EQ.0) WRITE(*,*) 'MULXM_MK: M&AK CANNOT BOTH EQUAL 0'
    RETURN
ENDIF

B = 0.D0

ALLOCATE( XM(NRCHOP,3) )

NN = NRCHOPS(2)
XM(:NN,:) = BAND_LOGLEG_XM(NN,M(2),TFM%LOGNORM(:,2))
B(:NN)=BANMUL(XM(:NN,:),2,A(:NN))

DEALLOCATE( XM )

RETURN
END SUBROUTINE MULXM_MK
! ======================================================================

! DESLQH
SUBROUTINE DELSQH_MK(A,B)
!=======================================================================
IMPLICIT NONE
COMPLEX(P8),DIMENSION(:),INTENT(IN):: A
COMPLEX(P8),DIMENSION(:),INTENT(INOUT):: B

INTEGER:: NN,N

IF ((M(2).EQ.0).AND.(AK(2,2).EQ.0.D0)) THEN
    IF (MPI_RANK.EQ.0) WRITE(*,*) 'DELSQH_MK: M&AK CANNOT BOTH EQUAL 0'
    RETURN
ENDIF

B = 0.D0

!$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(N)
DO NN=1,NRCHOPS(2)
    N = M(2) + (NN-1)
    B(NN) = -A(NN)*(N*(N+1)/ELL2)
ENDDO
!$OMP END PARALLEL DO

RETURN
END SUBROUTINE DELSQH_MK
! ======================================================================

! DEL2
SUBROUTINE DEL2_MK(A,B)
!=======================================================================
IMPLICIT NONE
COMPLEX(P8),DIMENSION(:),INTENT(IN):: A
COMPLEX(P8),DIMENSION(:),INTENT(INOUT):: B

INTEGER:: NN
REAL(P8),DIMENSION(:,:),ALLOCATABLE:: DEL2OP

IF ((M(2).EQ.0).AND.(AK(2,2).EQ.0)) THEN
    IF (MPI_RANK.EQ.0) WRITE(*,*) 'DEL2_MK: M&AK CANNOT BOTH EQUAL 0'
    RETURN
ENDIF

B = 0.D0

ALLOCATE( DEL2OP(NRCHOP,5) )

NN = NRCHOPS(2)
DEL2OP(:NN,:) = BAND_LOGLEG_RAT_DEL2H(NN,M(2),ELL,TFM%LOGNORM(:,2))
B(:NN)=BANMUL(DEL2OP(:NN,:),3,A(:NN))
B(:NN)=B(:NN)-(AK(2,2)**2)*A(:NN)

DEALLOCATE( DEL2OP )

RETURN
END SUBROUTINE DEL2_MK
! ======================================================================

! IDEL2
SUBROUTINE IDEL2_MK(B,A)
!=======================================================================
IMPLICIT NONE
COMPLEX(P8),DIMENSION(:),INTENT(IN):: B
COMPLEX(P8),DIMENSION(:),INTENT(INOUT):: A
REAL(P8),DIMENSION(:,:,:),ALLOCATABLE :: DEL2OP
REAL(P8),DIMENSION(:,:),ALLOCATABLE :: DEL2OP_0

INTEGER::KK,NN,MM,KV,NP,NM

IF ((M(2).EQ.0).AND.(AK(2,2).EQ.0)) THEN
    IF (MPI_RANK.EQ.0) WRITE(*,*) 'IDEL2_MK: M&AK CANNOT BOTH EQUAL 0'
    RETURN
ENDIF

A = 0.D0

A = B

IF (M(2).EQ.0) THEN
    !> M .EQ. 0
    NN=NRCHOPS(2)
    NP=NN+1

    ALLOCATE( DEL2OP_0(NP,7) )
    ALLOCATE( DEL2OP(NP,7,1) )  !NXCHOPDIM) )

    DEL2OP_0(:NP,2:6)  = BAND_LOGLEG_RAT_DEL2H(NP,M(2),ELL,TFM%LOGNORM(:,2))
    DEL2OP(:NP,2:3,1)=DEL2OP_0(:NP,2:3)
    DEL2OP(:NP,4  ,1)=DEL2OP_0(:NP,4  )-AK(2,2)**2.
    DEL2OP(:NP,5:6,1)=DEL2OP_0(:NP,5:6)
    DEL2OP(:NP,1  ,1)=0
    DEL2OP(:NP,7  ,1)=0

    ! M = 0, all K
    CALL LUB(DEL2OP(:NN,:,1),4)
    CALL SOLVEB(DEL2OP(:NN,:,1),4,A(:NN))

    DEALLOCATE( DEL2OP, DEL2OP_0 )
    A(NRCHOPS(2)+1:) = CMPLX(0.D0,0.D0)
    A(1) = A(1)-SUM(TFM%AT1(:NRCHOP)*A(:NRCHOP))/TFM%AT1(1)

ELSE
    !> ALL M .NE. 0
    ALLOCATE( DEL2OP_0(NRCHOP,5))
    ALLOCATE( DEL2OP(NRCHOP,5,1) )  !NXCHOPDIM) )

    ! each M, all K
    NN=NRCHOPS(2)
    DEL2OP_0(:NN,1:5) = BAND_LOGLEG_RAT_DEL2H(NN,M(2),ELL,TFM%LOGNORM(:,2))
    DEL2OP(:NN,1:2,1)=DEL2OP_0(:NN,1:2)
    DEL2OP(:NN,3  ,1)=DEL2OP_0(:NN,3  )-AK(2,2)**2
    DEL2OP(:NN,4:5,1)=DEL2OP_0(:NN,4:5)

    CALL LUB(DEL2OP(:NN,1:5,1),3)
    CALL SOLVEB(DEL2OP(:NN,1:5,1),3,A(:NN))

    DEALLOCATE( DEL2OP, DEL2OP_0 )
    A(NRCHOPS(2)+1:) = CMPLX(0.D0,0.D0)
ENDIF

RETURN
END SUBROUTINE IDEL2_MK
! ======================================================================
        
! HELMP
SUBROUTINE HELMP_MK(P,A,B,ALP,NU)
!=======================================================================
IMPLICIT NONE
INTEGER:: P
COMPLEX(P8),DIMENSION(:),INTENT(IN):: A
COMPLEX(P8),DIMENSION(:),INTENT(INOUT):: B
REAL(P8),INTENT(IN):: ALP
REAL(P8),OPTIONAL:: NU

COMPLEX(P8),DIMENSION(:),ALLOCATABLE:: W,D2
INTEGER:: IP

ALLOCATE(W(SIZE(A)),D2(SIZE(A)))
CALL DEL2_MK(A,D2)

B=D2

DO IP=4,P,2
CALL DEL2_MK(B,W)
B=W
ENDDO

B = B-ALP*A

IF(PRESENT(NU)) THEN
B = B+NU*D2
ENDIF

DEALLOCATE(W,D2)

RETURN
END SUBROUTINE HELMP_MK
! ======================================================================

! PC2VOR
SUBROUTINE PC2VOR_MK(PSI,CHI,ROR,ROP,OZ,C)
!=======================================================================
IMPLICIT NONE
COMPLEX(P8),DIMENSION(:):: PSI,CHI,ROR,ROP,OZ
INTEGER:: NN,MV
REAL(P8):: KV
COMPLEX(P8),DIMENSION(:),ALLOCATABLE:: W
CHARACTER(LEN=1),OPTIONAL:: C

CALL DEL2_MK(CHI,OZ)                                                  ! OZ NOW HAS (DEL^2)(CHI)
CALL XXDX_MK(PSI,ROR)                                                 ! ROR NOW HAS (1-X^2)D/DX(PSI) = R*D/DR(PSI)
CALL XXDX_MK(OZ,ROP)                                                  ! ROP NOW HAS (1-X^2)D/DX((DEL^2)(CHI)) = R*D/DR((DEL^2)(CHI))

NN=NRCHOPS(2)
MV=M(2)
KV=AK(2,2)
ROR(:NN)=-IU*MV*OZ(:NN)+IU*KV*ROR(:NN)                                ! ROR = -D/DPHI(DEL^2(CHI))+ R*D/DR(D/DZ(PSI))
ROP(:NN)=    ROP(:NN)-(KV*MV)*PSI(:NN)                                ! ROP = R*D/DR(DEL^2(CHI))+ D/DPHI(D/DZ(PSI))

CALL DELSQH_MK(PSI,OZ)                                                ! OZ/(1-X)**2 = - DELSQH(PSI) (MINUS SIGN ASSIGNED AT THE END)

IF(.NOT.PRESENT(C)) THEN
ALLOCATE(W(SIZE(PSI)))
CALL MULXM_MK(OZ,W)                                                   ! W <- (1-X)*[OZ/(1-X)**2] = OZ/(1-X)
CALL MULXM_MK(W,OZ)                                                   ! OZ <- (1-X)*[W] = (1-X)*[OZ/(1-X)]= OZ
DEALLOCATE(W)
ENDIF
OZ = -OZ

RETURN
END SUBROUTINE PC2VOR_MK
! ======================================================================

! PC2VEL
SUBROUTINE PC2VEL_MK(PSI,CHI,RUR,RUP,UZ,C)
!=======================================================================
IMPLICIT NONE
COMPLEX(P8),DIMENSION(:):: PSI,CHI,RUR,RUP,UZ
INTEGER:: NN,MV
REAL(P8):: KV
COMPLEX(P8),DIMENSION(:),ALLOCATABLE:: W
CHARACTER(LEN=1),OPTIONAL:: C

CALL XXDX_MK(CHI,RUR)                                                 ! RUR NOW HAS (1-X^2)D/DX(CHI) = R*D/DR(CHI)
CALL XXDX_MK(PSI,RUP)                                                 ! RUP NOW HAS (1-X^2)D/DX(PSI) = R*D/DR(PSI)

NN=NRCHOPS(2)
MV=M(2)
KV=AK(2,2)
RUR(:NN)=IU*MV*PSI(:NN)+(IU*KV)*RUR(:NN)                              ! RUR = D/DPHI(PSI)+ R*D/DR(D/DZ(CHI))
RUP(:NN)=     -RUP(:NN)-(MV*KV)*CHI(:NN)                              ! RUP =-R*D/DR(PSI)+ D/DPHI(D/DZ(CHI))

CALL DELSQH_MK(CHI,UZ)                                                ! UZ/(1-X)**2 = - DELSQH(CHI) (MINUS SIGN ASSIGNED AT THE END)
IF(.NOT.PRESENT(C)) THEN
    ALLOCATE(W(SIZE(PSI)))
    CALL MULXM_MK(UZ,W)                                               ! W <- (1-X)*[UZ/(1-X)**2] = UZ/(1-X)
    CALL MULXM_MK(W,UZ)                                               ! UZ <- (1-X)*[W] = (1-X)*[UZ/(1-X)]= UZ
    DEALLOCATE(W)
ENDIF
UZ = -UZ

RETURN
END SUBROUTINE PC2VEL_MK
! ======================================================================

! VPROD
SUBROUTINE VPROD_MK(RUR_0,RUP_0,UZ_0,ROR_U,ROP_U,OZ_U)
!=======================================================================
IMPLICIT NONE
REAL(P8),DIMENSION(:),INTENT(IN):: RUR_0,RUP_0,UZ_0
COMPLEX(P8),DIMENSION(:),INTENT(INOUT):: ROR_U,ROP_U,OZ_U

INTEGER:: NN
REAL(P8):: A1,A2,A3,C1,C2,C3,B1,B2,B3,D1,D2,D3

!> DIMENSION CHECK
IF(SIZE(RUR_0).NE.NR) STOP 'VPROD_MK: RUR_0 HAS IMPROPER DIMENSION'
IF(SIZE(RUP_0).NE.NR) STOP 'VPROD_MK: RUP_0 HAS IMPROPER DIMENSION'
IF(SIZE(UZ_0 ).NE.NR) STOP 'VPROD_MK: UZ_0 HAS IMPROPER DIMENSION'
IF(SIZE(ROR_U ).NE.NDIMR) STOP 'VPROD_MK: UZ_0 HAS IMPROPER DIMENSION'
IF(SIZE(ROP_U ).NE.NDIMR) STOP 'VPROD_MK: UZ_0 HAS IMPROPER DIMENSION'
IF(SIZE(OZ_U ).NE.NDIMR) STOP 'VPROD_MK: UZ_0 HAS IMPROPER DIMENSION'

!$OMP PARALLEL DO DEFAULT(SHARED) &
!$OMP& PRIVATE(A1,A2,A3,C1,C2,C3,B1,B2,B3,D1,D2,D3)
DO NN=1,NR
    A1=RUR_0(NN)
    A2=RUP_0(NN)
    A3=UZ_0 (NN)
    C1=RUR_0(NN)
    C2=RUP_0(NN)
    C3=UZ_0 (NN)
    B1=REAL (ROR_U(NN))
    B2=REAL (ROP_U(NN))
    B3=REAL (OZ_U(NN))
    D1=AIMAG(ROR_U(NN))
    D2=AIMAG(ROP_U(NN))
    D3=AIMAG(OZ_U(NN))
    ROR_U(NN)=CMPLX(A2*B3-A3*B2, C2*D3-C3*D2,P8)
    ROP_U(NN)=CMPLX(A3*B1-A1*B3, C3*D1-C1*D3,P8)
     OZ_U(NN)=CMPLX(A1*B2-A2*B1, C1*D2-C2*D1,P8)&
                /TFM%R(NN)**2.D0
ENDDO
!$OMP END PARALLEL DO

RETURN
END SUBROUTINE VPROD_MK
! ======================================================================

! ENERGY
FUNCTION ENERGY_MK(PSI,CHI)
! ======================================================================
    COMPLEX(P8),DIMENSION(:):: PSI,CHI
    COMPLEX(P8),DIMENSION(:),ALLOCATABLE:: W1,W2
    REAL(P8):: ENERGY_MK

    ALLOCATE(W1(SIZE(PSI)), W2(SIZE(PSI)))

    CALL CHOPSET(3)
    W1 = PSI
    CALL DELSQH_MK(W1,W2)
    CALL RTRAN_MK(W1,1)
    CALL RTRAN_MK(W2,1)
    ENERGY_MK = -PROD_MK(W1,W2)

    CALL DEL2_MK(CHI,W1)
    CALL DELSQH_MK(CHI,W2)
    CALL RTRAN_MK(W1,1)
    CALL RTRAN_MK(W2,1)
    ENERGY_MK = ENERGY_MK + PROD_MK(W1,W2)
    CALL CHOPSET(-3)
    DEALLOCATE(W1,W2)

END FUNCTION
! ======================================================================

! ENSTROPHY
FUNCTION ENSTROPHY_MK(PSI,CHI)
! ======================================================================
    COMPLEX(P8),DIMENSION(:),INTENT(IN):: PSI,CHI
    COMPLEX(P8),DIMENSION(:),ALLOCATABLE:: ROR,ROP,OZ,PSI_TEMP,CHI_TEMP,DEL2CHI_TEMP
    REAL(P8):: ENSTROPHY_MK

    ALLOCATE(ROR(SIZE(PSI)), ROP(SIZE(PSI)), OZ(SIZE(PSI)))
    ALLOCATE(PSI_TEMP(SIZE(PSI)), CHI_TEMP(SIZE(PSI)), DEL2CHI_TEMP(SIZE(PSI)))

    CALL CHOPSET(3)
    CALL PC2VOR_MK(PSI,CHI,ROR,ROP,OZ)
    CALL RTRAN_MK(ROR, 1)
    CALL RTRAN_MK(ROP, 1)
    CALL RTRAN_MK(OZ, 1)
    CALL PROJECT_MK(ROR,ROP,OZ,PSI_TEMP,DEL2CHI_TEMP)
    CALL IDEL2_MK(DEL2CHI_TEMP,CHI_TEMP)
    CALL CHOPSET(-3)

    ENSTROPHY_MK = ENERGY_MK(PSI_TEMP,CHI_TEMP)
    
    DEALLOCATE(ROR,ROP,OZ,PSI_TEMP,DEL2CHI_TEMP,CHI_TEMP)

END FUNCTION
! ======================================================================

FUNCTION ENSTROPHY_MK_MOD(ROR,ROP,OZ)
! ======================================================================
! This enstrophy calculation is indepedent from the wavenumbers.
! The calculation for (0,0) mode needs to be divided by 2.
! ======================================================================
    IMPLICIT NONE
    COMPLEX(P8):: ROR(:), ROP(:), OZ(:)
    COMPLEX(P8):: OR(NR), OP(NR), OZ2(NR)
    REAL(P8):: ENSTROPHY_MK_MOD

    OR = ROR(1:NR)/(1-TFM%X)**2/(TFM%R)**2
    OP = ROP(1:NR)/(1-TFM%X)**2/(TFM%R)**2
    OZ2 = OZ(1:NR)/(1-TFM%X)**2

    ENSTROPHY_MK_MOD = PROD_MK(ROR,OR)+PROD_MK(ROP,OP)+PROD_MK(OZ,OZ2)

    ! DEBUG:
    ! write(*,*) 'M,K = ',M(2),AK(2,2)
    ! write(*,*) 'ENS = ',ENS,MAXVAL(ABS(OZ))
    
END FUNCTION
! ======================================================================

! PRODCT
FUNCTION PROD_MK(A,B)
! ======================================================================
    REAL(P8):: PROD_MK
    COMPLEX(P8),DIMENSION(:):: A,B
    COMPLEX(P8):: W1(NR)

    W1 = REAL( A(:NR)*CONJG(B(:NR)) )
    ! NEEDS DOUBLE CHECK
    PROD_MK = 4.0_P8*PI*ZLEN0*ELL2*DOT_PRODUCT(W1,TFM%W)
    IF ((M(2).EQ.0).AND.(AK(2,2).EQ.0.D0)) PROD_MK = PROD_MK/2.D0
    ! PROD_MK = 2*4.0_P8*PI**2*ELL2*DOT_PRODUCT(W1,TFM%W)
END FUNCTION
! ======================================================================


! PROJECT
SUBROUTINE PROJECT_MK(RUR,RUP,UZ,PSI,CHI)
!=======================================================================
! [USAGE]: 
! PROJECT A VECTOR (RUR,RUP,UZ) IN PPP SPACE OR PFF SPACE
! TO A POLOIDAL-TOROIDAL FIELD (PSI, DEL^2(CHI))
!=======================================================================
COMPLEX(P8),DIMENSION(:),INTENT(IN):: RUR,RUP,UZ
COMPLEX(P8),DIMENSION(:),INTENT(INOUT):: PSI,CHI

REAL(P8),DIMENSION(:,:),ALLOCATABLE:: V,D,T,PFD
COMPLEX(P8),DIMENSION(:),ALLOCATABLE:: W1,W2

INTEGER:: KK,MM,NN,MV,N,I
REAL(P8)::KV
REAL(P8),DIMENSION(NRH):: FFF

ALLOCATE( V(NRCHOP,NRH) )
ALLOCATE( D(NRCHOP,NRH) )
ALLOCATE( T(NRCHOP,NRH) )
ALLOCATE( PFD(NRH,NRCHOP+1) )
ALLOCATE( W1(NRCHOP), W2(NRCHOP) )

W1=0
FFF=(1-TFM%X(:NRH)**2)/TFM%W(:NRH)

MV=M(2)
NN=NRCHOPS(2)
PFD(:NRH,:NN+1)=BANMUL( TFM%PF(:NRH,:NN+1,2), &
        BAND_LOGLEG_XXDX(NN+1,MV,TFM%LOGNORM(:,2)),2 )

!$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I,N)
DO I=1,NN
    N=MAX(1,MV+I-1)
    V(I,:NRH)= TFM%PF(:NRH,I,2)/(N*(N+1)*FFF)
    D(I,:NRH)= PFD(:NRH,I)/(N*(N+1)*FFF)
    T(I,:NRH)= TFM%PF(:NRH,I,2)*TFM%W(:NRH)   
ENDDO
!$OMP END PARALLEL DO

IF(MV.NE.0) CALL EOMUL_MK(V(:NN,:),RUR(:NR),W1(:NN))
CALL OEMUL_MK(D(:NN,:),RUP(:NR),W2(:NN))

PSI(:NN) = -(IU*MV)*W1(:NN)-W2(:NN)
!if (MPI_GLB_RANK.eq.0) call mcat(W2)
CALL OEMUL_MK(D(:NN,:),RUR(:NR),W1(:NN))

IF(MV.NE.0) CALL EOMUL_MK(V(:NN,:),RUP(:NR),W2(:NN))
CALL EOMUL_MK(T(:NN,:),UZ(:NR),CHI(:NN))

KV=AK(2,2)
CHI(:NN)=(IU*KV)*W1(:NN)+MV*KV*W2(:NN)-CHI(:NN)

DEALLOCATE( V,D,T,PFD )
DEALLOCATE( W1,W2 )

PSI(NRCHOPS(2)+1:) = CMPLX(0.D0,0.D0)
CHI(NRCHOPS(2)+1:) = CMPLX(0.D0,0.D0)

IF (M(2).EQ.0) THEN
    PSI(1)=PSI(1)-SUM(PSI(:NRCHOP)*TFM%AT1(:NRCHOP))/TFM%PF(1,1,1)
ENDIF

RETURN
END SUBROUTINE PROJECT_MK
!=======================================================================
SUBROUTINE EOMUL_MK(A,B,C)
!=======================================================================
REAL(P8),DIMENSION(:,:):: A
COMPLEX(P8),DIMENSION(:):: B,C

COMPLEX(P8),DIMENSION(:),ALLOCATABLE:: BE,BO
INTEGER:: NI,NJ,NJH

NI  = SIZE(A,1)
NJH = SIZE(A,2)
NJ  = SIZE(B,1)

IF(NJH*2 .NE. NJ) THEN
IF (MPI_RANK.EQ.0) THEN
    WRITE(*,*) 'EOMUL: SIZE MISMATCH.'
    WRITE(*,*) 'NJ=',NJ,' NJH=',NJH
ENDIF
STOP
ENDIF

ALLOCATE( BE(NJH) )
ALLOCATE( BO(NJH) )

BE = ( B(1:NJH) + B(NJ:NJH+1:-1) )
BO = ( B(1:NJH) - B(NJ:NJH+1:-1) )

    C(1::2)= A(1::2,:) .MUL. BE

IF (NI .GT. 1) THEN
    C(2::2)= A(2::2,:) .MUL. BO
ENDIF

DEALLOCATE( BE,BO )

RETURN
END SUBROUTINE EOMUL_MK
!=======================================================================
SUBROUTINE OEMUL_MK(A,B,C)
!=======================================================================
REAL(P8),DIMENSION(:,:):: A
COMPLEX(P8),DIMENSION(:):: B,C

COMPLEX(P8),DIMENSION(:),ALLOCATABLE:: BE,BO
INTEGER:: NI,NJ,NJH

NI  = SIZE(A,1)
NJH = SIZE(A,2)
NJ  = SIZE(B,1)

IF(NJH*2 .NE. NJ) THEN
IF (MPI_RANK.EQ.0) THEN
    WRITE(*,*) 'OEMUL: SIZE MISMATCH.'
    WRITE(*,*) 'NJ=',NJ,' NJH=',NJH
ENDIF
STOP
ENDIF

ALLOCATE( BE(NJH), BO(NJH) )

BE = ( B(1:NJH) + B(NJ:NJH+1:-1) )
BO = ( B(1:NJH) - B(NJ:NJH+1:-1) )

    C(1::2)= A(1::2,:) .MUL. BO

    C(2::2)= A(2::2,:) .MUL. BE

DEALLOCATE( BE,BO )

RETURN
END SUBROUTINE OEMUL_MK
! ======================================================================

! RTRAN
SUBROUTINE RTRAN_MK(A,IS)
!=======================================================================
IMPLICIT NONE
COMPLEX(P8),DIMENSION(:),ALLOCATABLE:: A
INTEGER,INTENT(IN):: IS

COMPLEX(P8),DIMENSION(:),ALLOCATABLE:: B,BE,BO
INTEGER:: NN,I,MM

! PHYSICAL TO MAPPED LEGENDRE SPACE:
IF(IS.EQ.-1) THEN                                                  

ALLOCATE(B(NRCHOPDIM))
B = 0.D0

ALLOCATE( BE(NRH) )
ALLOCATE( BO(NRH) )

DO I=1,NRH
    BE(I) = (A(I)+A(NR-I+1))*TFM%W(I)
    BO(I) = (A(I)-A(NR-I+1))*TFM%W(I)
ENDDO

NN = NRCHOPS(2)

! TFM%PF(RadialCollocPts, RadialModes, AzimuthalModes)
IF (NN.GE.1) THEN
B(1:NN:2)=TRANSPOSE(TFM%PF(:NRH,1:NN:2,2)) .MUL. BE
ENDIF

IF (NN.GE.2) THEN
B(2:NN:2)=TRANSPOSE(TFM%PF(:NRH,2:NN:2,2)) .MUL. BO
ENDIF

DEALLOCATE(A)
ALLOCATE(A(NRCHOPDIM))
A = B
DEALLOCATE( BE,BO,B )

! MAPPED LEGENDRE SPACE TO PHYSICAL:
ELSE                                                               

ALLOCATE(B(NDIMR))
B = 0.D0

ALLOCATE( BE(NRH) ) !NXCHOPDIM) )
ALLOCATE( BO(NRH) ) !NXCHOPDIM) )

NN = NRCHOPS(2)

IF(NN.GE.1) THEN
BE= TFM%PF(:NRH,1:NN:2,2) .MUL. A(1:NN:2)!NXCHOPDIM)
ELSE
BE=0
ENDIF

IF(NN.GE.2) THEN
BO= TFM%PF(:NRH,2:NN:2,2) .MUL. A(2:NN:2)!NXCHOPDIM)
ELSE
BO=0
ENDIF

B(1:NRH)= BE(:)+BO(:)
B(NR:NRH+1:-1)= BE(:)-BO(:)

B(NR+1:) = CMPLX(0.D0,0.D0)

DEALLOCATE(A)
ALLOCATE(A(NDIMR))
A = B
DEALLOCATE( BE,BO,B )
ENDIF

RETURN
END SUBROUTINE RTRAN_MK
! ======================================================================
SUBROUTINE NONLIN_MK(MREAD,AKREAD,RUR_0,RUP_0,UZ_0,ROR_0,ROP_0,OZ_0,RUR,RUP,UZ,ROR,ROP,OZ,VEC_R,comm_grp)
! ======================================================================
! note: ROR, ROP, OZ HAVE BEEN MODIFIED!
! ======================================================================
IMPLICIT NONE
INTEGER,INTENT(IN)    :: MREAD, comm_grp
REAL(P8),INTENT(IN):: AKREAD
COMPLEX(P8),DIMENSION(:),INTENT(IN):: RUR_0,RUP_0,UZ_0,ROR_0,ROP_0,OZ_0
COMPLEX(P8),DIMENSION(:),INTENT(IN):: RUR,RUP,UZ
COMPLEX(P8),DIMENSION(:),INTENT(INOUT):: ROR,ROP,OZ
COMPLEX(P8),DIMENSION(:),ALLOCATABLE,INTENT(INOUT),OPTIONAL:: VEC_R

LOGICAL:: flip_switch
INTEGER:: NN,NR_MK,M_ACTUAL
REAL(P8):: AK_ACTUAL
REAL(P8):: A1,A2,A3,C1,C2,C3,B1,B2,B3,D1,D2,D3
COMPLEX(P8),DIMENSION(NRCHOPDIM):: PSI,DEL2CHI

!$OMP PARALLEL DO DEFAULT(SHARED) &
!$OMP& PRIVATE(A1,A2,A3,C1,C2,C3,B1,B2,B3,D1,D2,D3)
DO NN=1,NR

    ! U_BAR X W'
    A1=REAL(RUR_0(NN))
    A2=REAL(RUP_0(NN))
    A3=REAL(UZ_0 (NN))
    C1=AIMAG(RUR_0(NN))
    C2=AIMAG(RUP_0(NN))
    C3=AIMAG(UZ_0 (NN))
    B1=REAL  (ROR(NN))
    B2=REAL  (ROP(NN))
    B3=REAL  (OZ (NN))
    D1=AIMAG (ROR(NN))
    D2=AIMAG (ROP(NN))
    D3=AIMAG (OZ (NN))
    ROR(NN)=CMPLX(A2*B3-A3*B2+C3*D2-C2*D3,B3*C2-B2*C3+A2*D3-A3*D2,P8)
    ROP(NN)=CMPLX(A3*B1-A1*B3+C1*D3-C3*D1,B1*C3-B3*C1+A3*D1-A1*D3,P8)
        OZ(NN)=CMPLX(A1*B2-A2*B1+C2*D1-C1*D2,B2*C1-B1*C2+A1*D2-A2*D1,P8)&
                /TFM%R(NN)**2.D0

    ! W_BAR X U'
    A1=REAL(ROR_0(NN))
    A2=REAL(ROP_0(NN))
    A3=REAL(OZ_0 (NN))
    C1=AIMAG(ROR_0(NN))
    C2=AIMAG(ROP_0(NN))
    C3=AIMAG(OZ_0 (NN))
    B1=REAL  (RUR(NN))
    B2=REAL  (RUP(NN))
    B3=REAL  (UZ (NN))
    D1=AIMAG (RUR(NN))
    D2=AIMAG (RUP(NN))
    D3=AIMAG (UZ (NN))
    ROR(NN)=ROR(NN)-CMPLX(A2*B3-A3*B2+C3*D2-C2*D3,B3*C2-B2*C3+A2*D3-A3*D2,P8)
    ROP(NN)=ROP(NN)-CMPLX(A3*B1-A1*B3+C1*D3-C3*D1,B1*C3-B3*C1+A3*D1-A1*D3,P8)
        OZ(NN)= OZ(NN)-(CMPLX(A1*B2-A2*B1+C2*D1-C1*D2,B2*C1-B1*C2+A1*D2-A2*D1,P8)&
                /TFM%R(NN)**2.D0)
    ! ROR(NN)=ROR(NN) - (ROP_0(NN)* UZ(NN)- OZ_0(NN)*RUP(NN))
    ! ROP(NN)=ROP(NN) - ( OZ_0(NN)*RUR(NN)-ROR_0(NN)* UZ(NN))
    !  OZ(NN)= OZ(NN) -((ROR_0(NN)*RUP(NN)-ROP_0(NN)*RUR(NN))/TFM%R(NN)**2.D0)
ENDDO
!$OMP END PARALLEL DO
ROR(NR+1:) = 0.D0
ROP(NR+1:) = 0.D0
    OZ(NR+1:) = 0.D0

IF (PRESENT(VEC_R)) THEN
    IF (MREAD.LT.0) THEN
        flip_switch = .TRUE.
        M_ACTUAL = -MREAD
        AK_ACTUAL = -AKREAD
    ELSE
        flip_switch = .FALSE.
        M_ACTUAL = MREAD
        AK_ACTUAL = AKREAD
    ENDIF

    IF ((M(2).NE.M_ACTUAL).OR.(ABS(ZLEN-2*PI/AK_ACTUAL).GE.1.0E-13)) THEN
        WRITE(*,*) 'NONLIN_MK: SET NEW M AND AK'
        ZLEN = 2*PI/AK_ACTUAL
        NTH = 2
        NX = 4
        NTCHOP = 2 ! M = 0, M = M_ACTUAL
        NXCHOP = 2 ! K = 0, K = AK_ACTUAL
        CALL LEGINIT(comm_grp,M_ACTUAL)
    ENDIF

    NR_MK = NRCHOPS(2)
    IF (flip_switch) THEN
        CALL PROJECT_MK(CONJG(ROR),CONJG(ROP),CONJG(OZ),PSI,DEL2CHI) ! <- flip ror, rop, oz
    ELSE
        CALL PROJECT_MK(ROR,ROP,OZ,PSI,DEL2CHI) 
    ENDIF

    ALLOCATE(VEC_R(2*NR_MK))
    VEC_R(:NR_MK) = PSI(:NR_MK)
    VEC_R(NR_MK+1:) = DEL2CHI(:NR_MK)

    IF (flip_switch) VEC_R = CONJG(VEC_R)
ENDIF

END SUBROUTINE NONLIN_MK
! ======================================================================

! INIT
SUBROUTINE INIT_LOOP(RUR_0,RUP_0,UZ_0,ROR_0,ROP_0,OZ_0)
! ======================================================================
IMPLICIT NONE
REAL(P8),DIMENSION(:):: RUR_0,RUP_0,UZ_0,ROR_0,ROP_0,OZ_0
TYPE(SCALAR):: A, B, C   ! EXTRA SCALAR-TYPE VARIABLES
TYPE(SCALAR):: D, E, F   ! EXTRA SCALAR-TYPE VARIABLES
INTEGER     :: I, J, K   ! EXTRA INTEGER VARIABLES (FOR ITER.)
REAL(P8)    :: X, Y, Z   ! EXTRA REAL(P8) VARIABLES
REAL(P8):: EM(NTCHOP), EK(NXCHOP), EMK(NTCHOP,NXCHOP), EMK2(NTCHOP,NXCHOPDIM), E00
COMPLEX(P8),DIMENSION(:),ALLOCATABLE:: PSICHI

! DEALLOCATE(NRCHOPS)
! DEALLOCATE(NTCHOPS)
! DEALLOCATE(AK)
! DEALLOCATE(M)
! DEALLOCATE(TFM%R,TFM%W,TFM%X, &
! TFM%LN,TFM%NORM,TFM%LOGNORM,TFM%PF,TFM%AT0,TFM%AT1, &
! TFM%Z,TFM%THR,TFM%THI,TFM%TH)

! CALL LEGINIT()

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!! STAGE 1. GENERATE PSI0 !!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
CALL ALLOCATE(A,PPP_SPACE)

! INITIALIZE
A%E = 0.D0

DO I=1,QPAIR%N
    ! INPUT OMEGA_Z (=2Q*EXP(-R**2)) INTO GAUSDATA
    ! IN ORDER TO OBTAIN PSI0, WE USE THE FORMULA
    ! OMEGA_Z = - DELSQH PSI0      <-->
    ! PSI0    = DELSQH^(-1)(-OMEGA_Z).
    GAUSDATA%XC = QPAIR%X(I)
    GAUSDATA%YC = QPAIR%Y(I)
    GAUSDATA%Q  = QPAIR%Q(I)*2.
    GAUSDATA%B  = 1.D0
    GAUSDATA%DX = QPAIR%DX(I)
    GAUSDATA%DY = QPAIR%DY(I)
    GAUSDATA%K  = QPAIR%K(I)
    GAUSDATA%DP = QPAIR%DP(I)
    GAUSDATA%R  = QPAIR%R(I)
    GAUSDATA%DR = QPAIR%DR(I)
    GAUSDATA%RK = QPAIR%RK(I)
    GAUSDATA%RP = QPAIR%RP(I)
    
    ! CREATE A GAUSSIAN VORTEX MULTIPLIED BY (1-X)^(-2)
    ! NOW A%E HAS THE FIELD F(R,T,Z) = 2Q*EXP(-B*R**2)*(1-X)^(-2)
    ! WHERE X = (R^2-ELL^2)/(R^2+ELL^2)
    CALL LAY(A,GAUS,2)
    
    ! CHECK WHETHER THE GAUSSIAN IS ACTUALLY GAUSSIAN
    ! FOR DEBUGGIN PURPOSES. TURN IT OFF IN PRACTICE
    ! CALL CHECKGAUSSIAN(A,GAUSDATA%XC,GAUSDATA%YC,2)
ENDDO

! (1-X)^(-2)*OMEGA_Z (PPP) --> (1-X)^(-2)*OMEGA_Z (FFF)
! THE FUNCTION IS TRUNCATED INTO THE FINITE BASIS FUNCTION SET,
! CAUSING THE INFORMATION LOSS DUE TO APPROXIMATION, WHICH IS
! INEVITABLE UNLESS WE USE THE INFINITE-SIZE FULL BASIS SET
! STILL, THE TRANSFORMED COEFFICIENT MATRIX IN FFF SPACE
! IS THE BEST APPROXIMATION OF THE INPUT FIELD IN PPP SPACE.
CALL TOFF(A)

! (1-X)^(-2)*OMEGA_Z (FFF) --> -(1-X)^(-2)*OMEGA_Z (FFF)
A%E=-A%E

! MUTE A LOGTERM
A%LN=0

! ADD RANDOM NOISE IF THE NOISE OPTION IS ON
IF(QPAIR%NOISE .EQ. 1) THEN
    CALL ALLOCATE(B)
    B=A
    CALL NOISE(A,0.02_P8)
    CALL TOFP(A)
    CALL TOFP(B)
    CALL FLATTEN(A,B)
    CALL TOFF(A)
    CALL DEALLOCATE(B)
ENDIF

! -(1-X)^(-2)*OMEGA_Z (FFF) -> DELSQH^(-1)(-OMEGA_Z) = PSI0 (FFF)
! NOTE: IDELSQH = ((1-X)^(-2) DELSQH)^(-1) = DELSQH^(-1)*((1-X)^(-2))^(-1)
! CREATES INVERSE HORIZONTAL DEL-SQUARE OPERATOR WITH EXTRA (1-X)^2
! B NOW HAS A LOG TERM ASSOCIATED WITH THE R-DERIVATIVE 
! IN THE INVERSE DEL SQ.
CALL ALLOCATE(B)
CALL IDELSQH(A,B)

CALL DEALLOCATE(A)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!! STAGE 2. GENERATE CHI0 !!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
CALL ALLOCATE(A,PPP_SPACE)

! INITIALIZE
A%E=0

DO I=1,QPAIR%N
    ! INPUT V_Z (=H*EXP(-B*R**2)) INTO GAUSDATA
    ! IN ORDER TO OBTAIN CHI0, WE USE THE FORMULA
    ! V_Z = - DELSQH CHI0      <-->
    ! CHI0    = DELSQH^(-1)(-V_Z).
    GAUSDATA%XC = QPAIR%X(I)
    GAUSDATA%YC = QPAIR%Y(I)
    GAUSDATA%Q  = QPAIR%H(I)
    GAUSDATA%B  = QPAIR%B(I)
    GAUSDATA%DX = QPAIR%DX(I)
    GAUSDATA%DY = QPAIR%DY(I)
    GAUSDATA%K  = QPAIR%K(I)
    GAUSDATA%DP = QPAIR%DP(I)
    GAUSDATA%R  = QPAIR%R(I)
    GAUSDATA%DR = QPAIR%DR(I)
    GAUSDATA%RK = QPAIR%RK(I)
    GAUSDATA%RP = QPAIR%RP(I)

    ! CREATE A GAUSSIAN VORTEX MULTIPLIED BY (1-X)^(-2)
    ! NOW A%E HAS THE FIELD F(R,T,Z) = B*EXP(-R**2)*(1-X)^(-2)
    ! WHERE X = (R^2-ELL^2)/(R^2+ELL^2)
    CALL LAY(A,GAUS,2)

    ! CHECK WHETHER THE GAUSSIAN IS ACTUALLY GAUSSIAN
    ! FOR DEBUGGIN PURPOSES. TURN IT OFF IN PRACTICE
    ! CALL CHECKGAUSSIAN(A,GAUSDATA%XC,GAUSDATA%YC,2)
ENDDO

! (1-X)^(-2)*V_Z (PPP) --> (1-X)^(-2)*V_Z (FFF)
! THE FUNCTION IS TRUNCATED INTO THE FINITE BASIS FUNCTION SET,
! CAUSING THE INFORMATION LOSS DUE TO APPROXIMATION, WHICH IS
! INEVITABLE UNLESS WE USE THE INFINITE-SIZE FULL BASIS SET
! STILL, THE TRANSFORMED COEFFICIENT MATRIX IN FFF SPACE
! IS THE BEST APPROXIMATION OF THE INPUT FIELD IN PPP SPACE.
CALL TOFF(A)

! (1-X)^(-2)*V_Z (FFF) --> -(1-X)^(-2)*V_Z (FFF)
A%E=-A%E

! MUTE A LOGTERM
A%LN=0

! ADD RANDOM NOISE IF THE NOISE OPTION IS ON
IF(QPAIR%NOISE.EQ.1) THEN
    CALL ALLOCATE(C)
    C=A
    CALL NOISE(A,0.02_P8)
    CALL TOFP(A)
    CALL TOFP(C)
    CALL FLATTEN(A,C)
    CALL TOFF(A)
    CALL DEALLOCATE(C)
ENDIF

! -(1-X)^(-2)*V_Z (FFF) -> DELSQH^(-1)(-V_Z) = CHI0 (FFF)
! NOTE: IDELSQH = ((1-X)^(-2) DELSQH)^(-1) = DELSQH^(-1)*((1-X)^(-2))^(-1)
! CREATES INVERSE HORIZONTAL DEL-SQUARE OPERATOR WITH EXTRA (1-X)^2
! B NOW HAS A LOG TERM ASSOCIATED WITH THE R-DERIVATIVE 
! IN THE INVERSE DEL SQ.
CALL ALLOCATE(C)
CALL IDELSQH(A,C)

CALL DEALLOCATE(A)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!! STAGE 3.  TO VEL & VOR !!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! B: PSI0
! C: CHI0
ALLOCATE(PSICHI(2*NRCHOPDIM))
PSICHI(1:NRCHOPDIM) = B%E(1:NRCHOPDIM,1,1)
PSICHI(NRCHOPDIM+1:) = C%E(1:NRCHOPDIM,1,1)
CALL SAVE_PSICHI(PSICHI,  './converg/check2/PC_o_MK_'//ITOA3(0)//'_'//' 0.00' &
        //'_IND_'//ITOA3(0)//'_NRCHOP_'//ITOA3(NRCHOP)//'.output')
DEALLOCATE(PSICHI)

CALL ALLOCATE(D)
CALL ALLOCATE(E)
CALL ALLOCATE(F)

CALL PC2VEL(B,C,D,E,F)
CALL RTRAN(D,1)
CALL RTRAN(E,1)
CALL RTRAN(F,1)
RUR_0(1:NR) = D%E(:NR,1,1)
RUP_0(1:NR) = E%E(:NR,1,1)
 UZ_0(1:NR) = F%E(:NR,1,1)

CALL DEALLOCATE(D)
CALL DEALLOCATE(E)
CALL DEALLOCATE(F)

CALL ALLOCATE(D)
CALL ALLOCATE(E)
CALL ALLOCATE(F)

CALL PC2VOR(B,C,D,E,F)
CALL RTRAN(D,1)
CALL RTRAN(E,1)
CALL RTRAN(F,1)
ROR_0(1:NR) = D%E(:NR,1,1)
ROP_0(1:NR) = E%E(:NR,1,1)
 OZ_0(1:NR) = F%E(:NR,1,1)

! ! NORMALIZATION:
! CALL PROJECT(D,E,F,B,C)
! CALL ALLOCATE(A)
! CALL IDEL2(C,A)
! CALL ENEMON(B,A,EM)
! ! CALL ENEMON(B,A,EM,EK)
! ! EMK = ENERGY_SPEC(B,A)
! ! EMK2 = ENERGY_SPEC_MODIFIED(B,A)
! ! IF (MPI_RANK.EQ.0) THEN
! !     WRITE(*,*) 'EM(0,0)', EM(1)
! !     WRITE(*,*) 'EK(0,0)', EK(1)
! !     WRITE(*,*) 'EMK(0,0)', EMK(1,1)
! !     WRITE(*,*) 'EMK2(0,0)', EMK2(1,1)
! ! ENDIF
! E00 = EM(1)
! ! IF (MPI_RANK.EQ.0) write(*,*) E00, 2*PI*ZLEN0
! ! CALL MPI_ABORT(MPI_COMM_WORLD,1,IERR)
! ! D%E = D%E/E00**0.5
! ! E%E = E%E/E00**0.5
! ! F%E = F%E/E00**0.5
! ! RUR_0(1:NR) = RUR_0(1:NR)/E00**0.5
! ! RUP_0(1:NR) = RUP_0(1:NR)/E00**0.5
! !  UZ_0(1:NR) =  UZ_0(1:NR)/E00**0.5
! ! ROR_0(1:NR) = ROR_0(1:NR)/E00**0.5
! ! ROP_0(1:NR) = ROP_0(1:NR)/E00**0.5
! !  OZ_0(1:NR) =  OZ_0(1:NR)/E00**0.5
! ! QPAIR%Q(1) = QPAIR%Q(1)/E00**0.5
! ! QPAIR%H(1) = QPAIR%H(1)/E00**0.5

! ! F%E(:,2,2) = F%E(:,1,1)
! ! CALL CHOPDO(F)
! CALL PROJECT(D,E,F,B,C)
! CALL IDEL2(C,A)
! EMK = ENERGY_SPEC(B,A)
! ! IF (MPI_RANK.EQ.0) THEN
! !     WRITE(*,*) 'EMK(0,0):', EMK(1,1),ZLEN0,ZLEN!,EMK(2,2),M(2),AK(2,2)
! !     WRITE(*,*) 'Q:', QPAIR%Q(1)
! ! ENDIF

CALL DEALLOCATE(D)
CALL DEALLOCATE(E)
CALL DEALLOCATE(F)

! CALL DEALLOCATE(A)
CALL DEALLOCATE(B)
CALL DEALLOCATE(C)

RETURN
END SUBROUTINE INIT_LOOP
! ======================================================================

SUBROUTINE EIGENDECOMPOSE(A,EV,ER,EL)
!=======================================================================
! [USAGE]:                                   
! CALCULATE THE EIGENDECOMPOSITION OF A GIVEN SQUARE MATRIX A (A=RDR^-1)
! IN ADDITION TO THE CALCULATION OF THE RIGHT EIGENVECTOR MATRIX R,
! THE LEFT EIGENVECTOR MATRIX L S.T. L*A = DL* CAN BE COMPUTED OPTINALLY
! [PARAMETERS]:                
! A >> N X N COMPLEX NON-HERMITIAN (GENERAL) MATRIX
! EV >> N COMPLEX EIGENVALUES IN N-VECTOR
! ER >> RIGHT EIGENVECTOR MATRIX SATISFYING AR = R X DIAG(EV)
! EL >> (OPTIONAL) LEFT EIGENVECTOR MATRIX SATISFYING L*A = DIAG(EV)X L* 
!                  NORMALIZATION IS PERFORMED TO SATISFY EL* X ER = I_N 
! [DEPENDENCIES]:
! 1. ZGGEV(~) @ LAPACK (OR MKL IF USING INTEL COMPILER)
! [UPDATES]:
! CODED BY SANGJOON LEE @ APR 24 2021
!=======================================================================
IMPLICIT NONE
COMPLEX(P8), DIMENSION(:,:), INTENT(IN) :: A
COMPLEX(P8), DIMENSION(:), INTENT(INOUT) :: EV
COMPLEX(P8), DIMENSION(:,:), INTENT(INOUT), OPTIONAL :: ER
COMPLEX(P8), DIMENSION(:,:), INTENT(INOUT), OPTIONAL :: EL

COMPLEX(P8), DIMENSION(SIZE(A,1),SIZE(A,2)) :: W1,W2

COMPLEX(P8), DIMENSION(SIZE(A,1)):: AEIG,BEIG
COMPLEX(P8), DIMENSION(SIZE(A,1),SIZE(A,2)):: VV,VV2
COMPLEX(P8), DIMENSION(2*SIZE(A,1)):: WK
REAL(P8)   , DIMENSION(8*SIZE(A,1)):: RWK

INTEGER(P4) :: I,NI,LW,INFO
REAL(P8):: ANG
COMPLEX(P8):: PHASE_FACTOR

IF(SIZE(A,1).NE.SIZE(A,2)) THEN
WRITE (*,*) 'EIGENDECOMPOSE: MATRIX NOT SQUARE'
WRITE (*,*) SIZE(A,1),'X',SIZE(A,2)
STOP
ENDIF

IF(SIZE(A,1).GT.SIZE(EV)) THEN
WRITE (*,*) 'EIGENDECOMPOSE: EV VECTOR SIZE IS TOO SMALL'
WRITE (*,*) SIZE(A,1),', BUT SIZE(EV) = ',SIZE(EV)
STOP
ENDIF

NI=SIZE(A,1)

W1=A
W2=EYE(NI)

LW = SIZE(WK)
IF ( PRESENT(ER) ) ER = CMPLX(0.D0,0.D0,P8)
IF ( PRESENT(EL) ) EL = CMPLX(0.D0,0.D0,P8)

IF ( PRESENT(EL).and.PRESENT(ER) ) THEN ! BOTH ER&EL, EV
    CALL ZGGEV('V','V',NI,W1,NI,W2,NI,AEIG,BEIG, &
                            EL,NI,ER,NI,WK,LW,RWK,INFO)

    !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I)
    DO I = 1, NI
        ANG = ATAN2(IMAG(ER(1,I)),REAL(ER(1,I)))
        PHASE_FACTOR = EXP(-IU*ANG)
        ER(:,I) = ER(:,I)*PHASE_FACTOR
        ! EL(:,I) = EL(:,I)/CONJG(DOT_PRODUCT(EL(:,I),ER(:,I)))/PHASE_FACTOR
        EL(:,I) = EL(:,I)/CONJG(DOT_PRODUCT(EL(:,I),ER(:,I)))
    ENDDO
    !$OMP END PARALLEL DO

ELSEIF (PRESENT(ER)) THEN ! ONLY ER, EV
    CALL ZGGEV('N','V',NI,W1,NI,W2,NI,AEIG,BEIG, &
                            VV,NI,ER,NI,WK,LW,RWK,INFO)
    ! DO I = 1, NI
    !     ANG = ATAN2(IMAG(ER(1,I)),REAL(ER(1,I)))
    !     PHASE_FACTOR = EXP(-IU*ANG)
    !     ER(:,I) = ER(:,I)*PHASE_FACTOR
    ! ENDDO
ELSE ! ONLY EV
    CALL ZGGEV('N','N',NI,W1,NI,W2,NI,AEIG,BEIG, &
                            VV,NI,VV2,NI,WK,LW,RWK,INFO)
ENDIF

IF (INFO .NE. 0) THEN
WRITE (*,*) 'EIGVEC2: EIGENVECTOR GENERATION FAILURE.'
STOP
ENDIF

DO I = 1, NI
IF(ABS(BEIG(I)).EQ.0.D0) THEN
    EV(I) = HUGE(0.D0)                                             ! ASSIGN INFINITY TO AVOID THE DIVISION-BY-ZERO ERROR
ELSE
    EV(I) = AEIG(I)/BEIG(I)
ENDIF
ENDDO

RETURN
END SUBROUTINE EIGENDECOMPOSE
! ======================================================================

! SUBROUTINE EIG_MATRIX_SERIAL(MREAD, AKREAD, H, EIG_VAL, EIG_VEC_R, EIG_VEC_L, comm_grp, switch)
! ! ======================================================================
! IMPLICIT NONE
! INTEGER, INTENT(IN)    :: MREAD, comm_grp
! REAL(P8), INTENT(IN)   :: AKREAD
! COMPLEX(P8), DIMENSION(:, :), ALLOCATABLE, INTENT(INOUT)            :: H
! COMPLEX(P8), DIMENSION(:), ALLOCATABLE, INTENT(INOUT), OPTIONAL     :: EIG_VAL
! COMPLEX(P8), DIMENSION(:, :), ALLOCATABLE, INTENT(INOUT), OPTIONAL  :: EIG_VEC_R, EIG_VEC_L
! LOGICAL, OPTIONAL:: switch

! LOGICAL     :: flip_switch =.FALSE.
! INTEGER     :: NR_MK, I, M_ACTUAL, IS
! REAL(P8)    :: REI, AK_ACTUAL
! INTEGER     :: MPI_NR_SIZE, MPI_NR_INDEX
! ! REAL(P8),DIMENSION(:),ALLOCATABLE:: RUR0,RUP0,UZ0,ROR0,ROP0,OZ0
! COMPLEX(P8), DIMENSION(:), ALLOCATABLE:: RURU, RUPU, UZU, RORU, ROPU, OZU
! COMPLEX(P8), DIMENSION(:), ALLOCATABLE:: PSIU, CHIU, PSI1, CHI1, PSI2, CHI2, PSI3, CHI3
! CHARACTER(len=6) :: K_WRITTEN
! ! INIT
! NTH = 2
! NX = 4
! NTCHOP = 2 ! M = 0, M = MREAD
! NXCHOP = 2 ! K = 0, K = AKREAD
! IF (.NOT. ALLOCATED(RUR0)) THEN
!     ZLEN = 1.D0; CALL LEGINIT(comm_grp)
!     ALLOCATE (RUR0(NR), RUP0(NR), UZ0(NR), ROR0(NR), ROP0(NR), OZ0(NR))
!     CALL INIT_LOOP(RUR0, RUP0, UZ0, ROR0, ROP0, OZ0) ! ALL IN PFF space
! END IF    

! ! IF MREAD IS NEGATIVE, CALCULATE ITS C.C MODE
! IF (MREAD.LT.0) THEN
!     flip_switch = .TRUE.
!     M_ACTUAL = -MREAD
!     AK_ACTUAL = -AKREAD
! ELSE
!     flip_switch = .FALSE.
!     M_ACTUAL = MREAD
!     AK_ACTUAL = AKREAD
! ENDIF

! ZLEN = 2*PI/AK_ACTUAL
! CALL LEGINIT(comm_grp, M_ACTUAL)
! ! write(*,*) 'M,AK:',M(2),AK(2,2),ZLEN

! ! SPLIT NRCHOPDIM
! NR_MK = NRCHOPS(2)
! IF (ALLOCATED(H) .AND. (SIZE(H, 1) .NE. NR_MK)) THEN
!     DEALLOCATE (H)
!     ALLOCATE (H(2*NR_MK, 2*NR_MK))
! ELSEIF (.NOT. (ALLOCATED(H))) THEN
!     ALLOCATE (H(2*NR_MK, 2*NR_MK))
! END IF
! H = CMPLX(0.D0, 0.D0, P8)

! ! MAIN JOB
! ALLOCATE (PSIU(NRCHOPDIM), CHIU(NRCHOPDIM))
! ALLOCATE (PSI1(NRCHOPDIM), CHI1(NRCHOPDIM))
! ALLOCATE (PSI2(NRCHOPDIM), CHI2(NRCHOPDIM))
! ALLOCATE (PSI3(NRCHOPDIM), CHI3(NRCHOPDIM))
! ALLOCATE (RURU(NRCHOPDIM), RUPU(NRCHOPDIM), UZU(NRCHOPDIM))
! ALLOCATE (RORU(NRCHOPDIM), ROPU(NRCHOPDIM), OZU(NRCHOPDIM))

! DO I = 1, NR_MK
! ! ================================ PSI =================================
!     PSIU = 0.D0
!     CHIU = 0.D0
!     PSIU(I) = 1.D0

! ! VISCOSITY/HYPERV
!     CALL CHOPSET(2)
!     IF (VISC%SW .EQ. 1) THEN
!         CALL DEL2_MK(PSIU, PSI3)
!         PSI3 = PSI3*VISC%NU
!     ELSE IF (VISC%SW .EQ. 2) THEN
!         CALL CHOPSET(-2 + VISC%P)
!         CALL HELMP_MK(VISC%P, PSIU, PSI3, 0.D0)
!         IF (MOD(VISC%P/2, 2) .EQ. 0) PSI3 = -PSI3
!         PSI3 = PSI3*VISC%NUP
!         CALL CHOPSET(2 - VISC%P)
!     ELSE
!         PSI3 = 0.D0
!     END IF
!     CHI3 = 0.D0
!     CALL CHOPSET(-2)

!     CALL CHOPSET(3)
! ! NONLINEAR TERM: W0 X U'
!     CALL PC2VEL_MK(PSIU, CHIU, RURU, RUPU, UZU)
!     CALL RTRAN_MK(RURU, 1)
!     CALL RTRAN_MK(RUPU, 1)
!     CALL RTRAN_MK(UZU, 1)
!     CALL VPROD_MK(ROR0, ROP0, OZ0, RURU, RUPU, UZU)
!     CALL PROJECT_MK(RURU, RUPU, UZU, PSI1, CHI1)

! ! NONLINEAR TERM: W' X U0
!     CALL PC2VOR_MK(PSIU, CHIU, RORU, ROPU, OZU)
!     CALL RTRAN_MK(RORU, 1)
!     CALL RTRAN_MK(ROPU, 1)
!     CALL RTRAN_MK(OZU, 1)
!     CALL VPROD_MK(RUR0, RUP0, UZ0, RORU, ROPU, OZU)
!     CALL PROJECT_MK(RORU, ROPU, OZU, PSI2, CHI2)
!     CALL CHOPSET(-3)
! ! IF (I.EQ.2) THEN
! !     CALL XXDX_MK(PSIU,RURU)
! !     CALL MCAT(ROP0)
! ! ENDIF

!     PSI1 = -PSI1 + PSI2 + PSI3
!     CHI1 = -CHI1 + CHI2 + CHI3
!     PSI1(NRCHOPS(2) + 1:) = 0.D0
!     CHI1(NRCHOPS(2) + 1:) = 0.D0

!     H(:NR_MK, I) = PSI1(:NR_MK)
!     H(NR_MK + 1:, I) = CHI1(:NR_MK)

! ! ================================ CHI =================================
!     PSIU = 0.D0
!     CHIU = 0.D0
!     CHIU(I) = 1.D0

!     CALL IDEL2_MK(CHIU, CHI1)
!     CHIU = CHI1
!     CHI1 = 0.D0

!     IF (VISC%SW .NE. 0) THEN
!         CHI3 = PSI3
!     ELSE
!         CHI3 = 0.D0
!     END IF
!     PSI3 = 0.D0

!     CALL CHOPSET(3)
! ! NONLINEAR TERM: W0 X U'
!     CALL PC2VEL_MK(PSIU, CHIU, RURU, RUPU, UZU)
!     CALL RTRAN_MK(RURU, 1)
!     CALL RTRAN_MK(RUPU, 1)
!     CALL RTRAN_MK(UZU, 1)
!     CALL VPROD_MK(ROR0, ROP0, OZ0, RURU, RUPU, UZU)
!     CALL PROJECT_MK(RURU, RUPU, UZU, PSI1, CHI1)

! ! NONLINEAR TERM: W' X U0
!     CALL PC2VOR_MK(PSIU, CHIU, RORU, ROPU, OZU)
!     CALL RTRAN_MK(RORU, 1)
!     CALL RTRAN_MK(ROPU, 1)
!     CALL RTRAN_MK(OZU, 1)
!     CALL VPROD_MK(RUR0, RUP0, UZ0, RORU, ROPU, OZU)
!     CALL PROJECT_MK(RORU, ROPU, OZU, PSI2, CHI2)
!     CALL CHOPSET(-3)

!     PSI1 = -PSI1 + PSI2 + PSI3
!     CHI1 = -CHI1 + CHI2 + CHI3
!     PSI1(NRCHOPS(2) + 1:) = 0.D0
!     CHI1(NRCHOPS(2) + 1:) = 0.D0

!     H(:NR_MK, I + NR_MK) = PSI1(:NR_MK)
!     H(NR_MK + 1:, I + NR_MK) = CHI1(:NR_MK)
! END DO
! ! DEALLOCATE( RUR0,RUP0,UZ0,ROR0,ROP0,OZ0 )
! DEALLOCATE (RURU, RUPU, UZU, RORU, ROPU, OZU)
! DEALLOCATE (PSIU, CHIU, PSI1, CHI1, PSI2, CHI2, PSI3, CHI3)

! ! OUTPUT:
! !WRITE OUT THE 3D MATRIX IN THE SCALAR USING UNFORMATTED MODE
! IF (flip_switch) THEN
!     H = CONJG(H)
! ENDIF

! IF (PRESENT(EIG_VAL)) THEN
!     IF (ALLOCATED(EIG_VAL)) DEALLOCATE (EIG_VAL)
!     ALLOCATE (EIG_VAL(2*NR_MK))

!     IF (PRESENT(EIG_VEC_L)) THEN
!         IF (ALLOCATED(EIG_VEC_R)) DEALLOCATE (EIG_VEC_R)
!         IF (ALLOCATED(EIG_VEC_L)) DEALLOCATE (EIG_VEC_L)
!         ALLOCATE (EIG_VEC_R(2*NR_MK, 2*NR_MK), EIG_VEC_L(2*NR_MK, 2*NR_MK))
!         CALL EIGENDECOMPOSE(H, EIG_VAL, ER=EIG_VEC_R, EL=EIG_VEC_L)
!     ELSEIF (PRESENT(EIG_VEC_R)) THEN
!         IF (ALLOCATED(EIG_VEC_R)) DEALLOCATE (EIG_VEC_R)
!         ALLOCATE (EIG_VEC_R(2*NR_MK, 2*NR_MK))
!         CALL EIGENDECOMPOSE(H, EIG_VAL, ER=EIG_VEC_R)
!     ELSE
!         CALL EIGENDECOMPOSE(H, EIG_VAL)
!     END IF
! END IF

! IF (PRESENT(switch)) THEN
!     WRITE(K_WRITTEN,'(F06.2)') AKREAD
!     open (10, FILE='./converg/eigM_MK_'//ITOA3(MREAD)//'_'//K_WRITTEN &
!             //'.output', STATUS='unknown', ACTION='WRITE', IOSTAT=IS)
!     if (IS .ne. 0) then
!         print *, 'ERROR: EIG_MATRIX -- Could not creat new file'
!         RETURN
!     end if
!     DO I = 1, 2*NR_MK
!         WRITE (10, *) H(I, 1:20)
!     END DO
!     close (10)
!     write (*, *) 'EVP MAT: max element = ', maxval(abs(H))
!     write (*, *) 'EVP MAT: maxUR = ', maxval(abs(RUR0(1:NR)/TFM%R))
!     write (*, *) 'EVP MAT: maxUP = ', maxval(abs(RUP0(1:NR)/TFM%R))
!     write (*, *) 'EVP MAT: maxUZ = ', maxval(abs( UZ0(1:NR)))
!     write (*, *) 'EVP MAT: maxOR = ', maxval(abs(ROR0(1:NR)/TFM%R))
!     write (*, *) 'EVP MAT: maxOP = ', maxval(abs(ROP0(1:NR)/TFM%R))
!     write (*, *) 'EVP MAT: maxOZ = ', maxval(abs( OZ0(1:NR)))
! END IF

! RETURN

! END SUBROUTINE EIG_MATRIX_SERIAL
! ! ======================================================================

SUBROUTINE EIG_MATRIX(MREAD, AKREAD, H, EIG_VAL, EIG_VEC_R, EIG_VEC_L, comm_grp, print_switch, serial_switch)
! ======================================================================
IMPLICIT NONE
INTEGER, INTENT(IN)    :: MREAD, comm_grp
REAL(P8), INTENT(IN)   :: AKREAD
COMPLEX(P8), DIMENSION(:, :), ALLOCATABLE, INTENT(INOUT)            :: H
COMPLEX(P8), DIMENSION(:), ALLOCATABLE, INTENT(INOUT), OPTIONAL     :: EIG_VAL
COMPLEX(P8), DIMENSION(:, :), ALLOCATABLE, INTENT(INOUT), OPTIONAL  :: EIG_VEC_R, EIG_VEC_L
LOGICAL, OPTIONAL:: print_switch, serial_switch

LOGICAL     :: flip_switch =.FALSE., isserial
INTEGER     :: NR_MK, I, M_ACTUAL, IS
REAL(P8)    :: REI, AK_ACTUAL
INTEGER     :: MPI_NR_SIZE, MPI_NR_INDEX
! REAL(P8),DIMENSION(:),ALLOCATABLE:: RUR0,RUP0,UZ0,ROR0,ROP0,OZ0
COMPLEX(P8), DIMENSION(:), ALLOCATABLE:: RURU, RUPU, UZU, RORU, ROPU, OZU
COMPLEX(P8), DIMENSION(:), ALLOCATABLE:: PSIU, CHIU, PSI1, CHI1, PSI2, CHI2, PSI3, CHI3
CHARACTER(len=6) :: K_WRITTEN

! INIT
NTH = 2
NX = 4
NTCHOP = 2 ! M = 0, M = MREAD
NXCHOP = 2 ! K = 0, K = AKREAD
IF (.NOT. ALLOCATED(RUR0)) THEN
    ZLEN = 1.D0; CALL LEGINIT(comm_grp)
    ALLOCATE (RUR0(NR), RUP0(NR), UZ0(NR), ROR0(NR), ROP0(NR), OZ0(NR))
    CALL INIT_LOOP(RUR0, RUP0, UZ0, ROR0, ROP0, OZ0) ! ALL IN PFF space
END IF

isserial = .FALSE.
IF (PRESENT(serial_switch)) isserial = serial_switch

IF ((MPI_GLB_RANK.EQ.0).OR.(isserial)) THEN
    ! IF MREAD IS NEGATIVE, CALCULATE ITS C.C MODE
    IF (MREAD.LT.0) THEN
        flip_switch = .TRUE.
        M_ACTUAL = -MREAD
        AK_ACTUAL = -AKREAD
    ELSE
        flip_switch = .FALSE.
        M_ACTUAL = MREAD
        AK_ACTUAL = AKREAD
    ENDIF
ENDIF
IF (.NOT.(isserial)) THEN
    CALL MPI_BCAST(M_ACTUAL, 1, MPI_INTEGER, 0, MPI_COMM_WORLD, IERR)
    CALL MPI_BCAST(AK_ACTUAL, 1, MPI_DOUBLE_PRECISION, 0, MPI_COMM_WORLD, IERR)
ENDIF
ZLEN = 2*PI/AK_ACTUAL
CALL LEGINIT(comm_grp, M_ACTUAL)
! write(*,*) 'M,AK:',M(2),AK(2,2),ZLEN

! SPLIT NRCHOPDIM
NR_MK = NRCHOPS(2)
IF (ALLOCATED(H) .AND. (SIZE(H, 1) .NE. NR_MK)) THEN
    DEALLOCATE (H)
    ALLOCATE (H(2*NR_MK, 2*NR_MK))
ELSEIF (.NOT. (ALLOCATED(H))) THEN
    ALLOCATE (H(2*NR_MK, 2*NR_MK))
END IF
H = CMPLX(0.D0, 0.D0, P8)
IF (isserial) THEN
    MPI_NR_INDEX = 0; MPI_NR_SIZE = NR_MK
ELSE
    CALL DECOMPOSE(NR_MK, MPI_GLB_PROCS, MPI_GLB_RANK, MPI_NR_SIZE, MPI_NR_INDEX)
ENDIF

! MAIN JOB
ALLOCATE (PSIU(NRCHOPDIM), CHIU(NRCHOPDIM))
ALLOCATE (PSI1(NRCHOPDIM), CHI1(NRCHOPDIM))
ALLOCATE (PSI2(NRCHOPDIM), CHI2(NRCHOPDIM))
ALLOCATE (PSI3(NRCHOPDIM), CHI3(NRCHOPDIM))
ALLOCATE (RURU(NRCHOPDIM), RUPU(NRCHOPDIM), UZU(NRCHOPDIM))
ALLOCATE (RORU(NRCHOPDIM), ROPU(NRCHOPDIM), OZU(NRCHOPDIM))

DO I = MPI_NR_INDEX + 1, MPI_NR_INDEX + MPI_NR_SIZE
! ================================ PSI =================================
    PSIU = 0.D0
    CHIU = 0.D0
    PSIU(I) = 1.D0

! VISCOSITY/HYPERV
    CALL CHOPSET(2)
    IF (VISC%SW .EQ. 1) THEN
        CALL DEL2_MK(PSIU, PSI3)
        PSI3 = PSI3*VISC%NU
    ELSE IF (VISC%SW .EQ. 2) THEN
        ! to avoid chopset error, increase the nrchopdim (mod_fft) according to visc%p
        CALL CHOPSET(-2 + VISC%P)
        CALL HELMP_MK(VISC%P, PSIU, PSI3, 0.D0)
        IF (MOD(VISC%P/2, 2) .EQ. 0) PSI3 = -PSI3
        PSI3 = PSI3*VISC%NUP
        CALL CHOPSET(2 - VISC%P)
    ELSE
        PSI3 = 0.D0
    END IF
    CHI3 = 0.D0
    CALL CHOPSET(-2)

    CALL CHOPSET(3)
! NONLINEAR TERM: W0 X U'
    CALL PC2VEL_MK(PSIU, CHIU, RURU, RUPU, UZU)
    CALL RTRAN_MK(RURU, 1)
    CALL RTRAN_MK(RUPU, 1)
    CALL RTRAN_MK(UZU, 1)
    CALL VPROD_MK(ROR0, ROP0, OZ0, RURU, RUPU, UZU)
    CALL PROJECT_MK(RURU, RUPU, UZU, PSI1, CHI1)

! NONLINEAR TERM: U0 X W'
    CALL PC2VOR_MK(PSIU, CHIU, RORU, ROPU, OZU)
    CALL RTRAN_MK(RORU, 1)
    CALL RTRAN_MK(ROPU, 1)
    CALL RTRAN_MK(OZU, 1)
    CALL VPROD_MK(RUR0, RUP0, UZ0, RORU, ROPU, OZU)
    CALL PROJECT_MK(RORU, ROPU, OZU, PSI2, CHI2)
    CALL CHOPSET(-3)
! IF (I.EQ.2) THEN
!     CALL XXDX_MK(PSIU,RURU)
!     CALL MCAT(ROP0)
! ENDIF

    PSI1 = -PSI1 + PSI2 + PSI3
    CHI1 = -CHI1 + CHI2 + CHI3
    PSI1(NRCHOPS(2) + 1:) = 0.D0
    CHI1(NRCHOPS(2) + 1:) = 0.D0

    H(:NR_MK, I) = PSI1(:NR_MK)
    H(NR_MK + 1:, I) = CHI1(:NR_MK)

! ================================ CHI =================================
    PSIU = 0.D0
    CHIU = 0.D0
    CHIU(I) = 1.D0

    CALL IDEL2_MK(CHIU, CHI1)
    CHIU = CHI1
    CHI1 = 0.D0

    IF (VISC%SW .NE. 0) THEN
        CHI3 = PSI3
    ELSE
        CHI3 = 0.D0
    END IF
    PSI3 = 0.D0

    CALL CHOPSET(3)
! NONLINEAR TERM: W0 X U'
    CALL PC2VEL_MK(PSIU, CHIU, RURU, RUPU, UZU)
    CALL RTRAN_MK(RURU, 1)
    CALL RTRAN_MK(RUPU, 1)
    CALL RTRAN_MK(UZU, 1)
    CALL VPROD_MK(ROR0, ROP0, OZ0, RURU, RUPU, UZU)
    CALL PROJECT_MK(RURU, RUPU, UZU, PSI1, CHI1)

! NONLINEAR TERM: U0 X W'
    CALL PC2VOR_MK(PSIU, CHIU, RORU, ROPU, OZU)
    CALL RTRAN_MK(RORU, 1)
    CALL RTRAN_MK(ROPU, 1)
    CALL RTRAN_MK(OZU, 1)
    CALL VPROD_MK(RUR0, RUP0, UZ0, RORU, ROPU, OZU)
    CALL PROJECT_MK(RORU, ROPU, OZU, PSI2, CHI2)
    CALL CHOPSET(-3)

    PSI1 = -PSI1 + PSI2 + PSI3
    CHI1 = -CHI1 + CHI2 + CHI3
    PSI1(NRCHOPS(2) + 1:) = 0.D0
    CHI1(NRCHOPS(2) + 1:) = 0.D0

    H(:NR_MK, I + NR_MK) = PSI1(:NR_MK)
    H(NR_MK + 1:, I + NR_MK) = CHI1(:NR_MK)
END DO
! DEALLOCATE( RUR0,RUP0,UZ0,ROR0,ROP0,OZ0 )
DEALLOCATE (RURU, RUPU, UZU, RORU, ROPU, OZU)
DEALLOCATE (PSIU, CHIU, PSI1, CHI1, PSI2, CHI2, PSI3, CHI3)

IF (.NOT.(isserial)) THEN
    CALL MPI_ALLREDUCE(MPI_IN_PLACE, H, SIZE(H), MPI_DOUBLE_COMPLEX, MPI_SUM, &
                    MPI_COMM_WORLD, IERR)
    CALL MPI_BARRIER(MPI_COMM_WORLD, IERR)
ENDIF

! OUTPUT:
IF ((MPI_GLB_RANK.EQ.0).OR.(isserial)) THEN  ! START OF THE SERIAL PART
!WRITE OUT THE 3D MATRIX IN THE SCALAR USING UNFORMATTED MODE

    IF (flip_switch) THEN
        H = CONJG(H)
    ENDIF

    IF (PRESENT(EIG_VAL)) THEN
        IF (ALLOCATED(EIG_VAL)) DEALLOCATE (EIG_VAL)
        ALLOCATE (EIG_VAL(2*NR_MK))

        IF (PRESENT(EIG_VEC_L)) THEN
            IF (ALLOCATED(EIG_VEC_R)) DEALLOCATE (EIG_VEC_R)
            IF (ALLOCATED(EIG_VEC_L)) DEALLOCATE (EIG_VEC_L)
            ALLOCATE (EIG_VEC_R(2*NR_MK, 2*NR_MK), EIG_VEC_L(2*NR_MK, 2*NR_MK))
            CALL EIGENDECOMPOSE(H, EIG_VAL, ER=EIG_VEC_R, EL=EIG_VEC_L)
        ELSEIF (PRESENT(EIG_VEC_R)) THEN
            IF (ALLOCATED(EIG_VEC_R)) DEALLOCATE (EIG_VEC_R)
            ALLOCATE (EIG_VEC_R(2*NR_MK, 2*NR_MK))
            CALL EIGENDECOMPOSE(H, EIG_VAL, ER=EIG_VEC_R)
        ELSE
            CALL EIGENDECOMPOSE(H, EIG_VAL)
        END IF
    END IF

    IF ((PRESENT(print_switch)).AND.(print_switch)) THEN
        WRITE(K_WRITTEN,'(F06.2)') AKREAD
        open (10, FILE='./converg/eigM_MK_'//ITOA3(MREAD)//'_'//K_WRITTEN &
                //'.output', STATUS='unknown', ACTION='WRITE', IOSTAT=IS)
        if (IS .ne. 0) then
            print *, 'ERROR: EIG_MATRIX -- Could not creat new file'
            RETURN
        end if
        DO I = 1, 2*NR_MK
            WRITE (10, *) H(I, 1:20)
        END DO
        close (10)
        write (*, *) 'EVP MAT: max element = ', maxval(abs(H))
        write (*, *) 'EVP MAT: maxUR = ', maxval(abs(RUR0(1:NR)/TFM%R))
        write (*, *) 'EVP MAT: maxUP = ', maxval(abs(RUP0(1:NR)/TFM%R))
        write (*, *) 'EVP MAT: maxUZ = ', maxval(abs( UZ0(1:NR)))
        write (*, *) 'EVP MAT: maxOR = ', maxval(abs(ROR0(1:NR)/TFM%R))
        write (*, *) 'EVP MAT: maxOP = ', maxval(abs(ROP0(1:NR)/TFM%R))
        write (*, *) 'EVP MAT: maxOZ = ', maxval(abs( OZ0(1:NR)))
    END IF
END IF

RETURN

END SUBROUTINE EIG_MATRIX
! ======================================================================

SUBROUTINE EIG2VELVOR(MREAD,AKREAD,EIG_IND,EIG_VEC_R,EIG_VEC_L,RUR,RUP,UZ,ROR,ROP,OZ,VEC_R,VEC_L,comm_grp,print_switch)
!=======================================================================
! [USAGE]: 
! RENORMALIZE THE LEFT AND RIGHT EIGENVECTORS ANS SAVE THE VELOCITY AND
! VORTICITY FIELDS.
! [ON EXIT]:
! EIG_VEC_R(:,EID_IND) >> [PSI,CHI] (NORMALIZED)
! EIG_VEC_L >> [PSI,DEL2CHI] (UNCHANGED!)
! VEC_R >> [PSI,DEL2CHI] (NORMALIZED)
! VEC_L >> [PSI,DEL2CHI] (NORMALIZED)
! RUR~OZ >> VELOCITY/VORTICITY COMPONENTS (NORMALIZED)
! [UPDATES]:
! CODED BY JINGE WANG
! [HISTORY]:
! Ver.0: RENORMALIZE THE LEFT AND RIGHT EIGENVECTORS SUCH THAT UP IS PURELY 
! REAL WITH MAXIMUM MAGNITUDE OF 1.
! Ver.1: RENORMALIZE THE LEFT AND RIGHT EIGENVECTORS SUCH THAT ENSTROPHY
! IS UNITY.
! Ver.2: ENSTROPHY -> ENSTROPHY/UNIT LENGTH
!=======================================================================
IMPLICIT NONE
INTEGER,INTENT(IN)    :: MREAD, EIG_IND, comm_grp
REAL(P8),INTENT(IN)    :: AKREAD
COMPLEX(P8),DIMENSION(:,:),ALLOCATABLE,INTENT(IN):: EIG_VEC_L
COMPLEX(P8),DIMENSION(:,:),ALLOCATABLE,INTENT(INOUT):: EIG_VEC_R
COMPLEX(P8),DIMENSION(:),ALLOCATABLE,INTENT(INOUT):: RUR,RUP,UZ,ROR,ROP,OZ,VEC_R,VEC_L
LOGICAL,OPTIONAL:: print_switch

LOGICAL:: flip_switch = .FALSE.
INTEGER:: NR_MK, M_ACTUAL
REAL(P8):: AK_ACTUAL
COMPLEX(P8),DIMENSION(:),ALLOCATABLE:: PSI,DEL2CHI,CHI
REAL(P8):: ENE_MK

REAL(P8):: ANG
COMPLEX(P8):: PHASE_FACTOR

IF (MREAD.LT.0) THEN
    flip_switch = .TRUE.
    M_ACTUAL = -MREAD
    AK_ACTUAL = -AKREAD
ELSE
    flip_switch = .FALSE.
    M_ACTUAL = MREAD
    AK_ACTUAL = AKREAD
ENDIF

IF ((M(2).NE.M_ACTUAL).OR.(ABS(ZLEN-2*PI/AK_ACTUAL).GE.1.0E-13)) THEN
    IF ((PRESENT(print_switch)).AND.(print_switch)) WRITE(*,*) 'EIG2VELVOR: SET NEW M AND AK'
    ZLEN = 2*PI/AK_ACTUAL
    NTH = 2
    NX = 4
    NTCHOP = 2 ! M = 0, M = M_ACTUAL
    NXCHOP = 2 ! K = 0, K = AK_ACTUAL
    CALL LEGINIT(comm_grp,M_ACTUAL)
ENDIF

NR_MK = SIZE(EIG_VEC_R,1)/2
ALLOCATE(VEC_R(SIZE(EIG_VEC_R,1))); VEC_R(:) = EIG_VEC_R(:,EIG_IND)
ALLOCATE(VEC_L(SIZE(EIG_VEC_R,1))); VEC_L(:) = EIG_VEC_L(:,EIG_IND)

ALLOCATE(PSI(NRCHOPDIM),DEL2CHI(NRCHOPDIM),CHI(NRCHOPDIM))  
ALLOCATE(RUR(NRCHOPDIM),RUP(NRCHOPDIM),UZ(NRCHOPDIM))
ALLOCATE(ROR(NRCHOPDIM),ROP(NRCHOPDIM),OZ(NRCHOPDIM))  

PSI = 0.D0
DEL2CHI = 0.D0
IF (flip_switch) THEN
    PSI(:NR_MK) = CONJG(EIG_VEC_R(:NR_MK,EIG_IND)) !PSI
    DEL2CHI(:NR_MK) = CONJG(EIG_VEC_R(NR_MK+1:,EIG_IND)) !DEL2CHI
ELSE
    PSI(:NR_MK) = EIG_VEC_R(:NR_MK,EIG_IND) !PSI
    DEL2CHI(:NR_MK) = EIG_VEC_R(NR_MK+1:,EIG_IND) !DEL2CHI
ENDIF

CALL IDEL2_MK(DEL2CHI,CHI)

! =========================== NORMALIZATION ============================
! 1). NORMALIZE THE ENERGY =============================================
! ENE_MK = ENERGY_MK(PSI,CHI)
! PSI = PSI/ENE_MK**0.5
! CHI = CHI/ENE_MK**0.5
! ! VEC_L(:) = VEC_L(:)*ENE_MK**0.5 ! ENE_MK IS REAL (NOTE:NORMALIZE AT THE END)
! CALL CHOPSET(3)
! ======================================================================

! 2). NORMALIZE THE MAX UP =============================================
! CALL CHOPSET(3)
! CALL PC2VEL_MK(PSI,CHI,RUR,RUP,UZ)
! ! CALCULATE THE PHASE_FACTOR:
! CALL RTRAN_MK(RUP,1)
! ANG = ATAN2(IMAG(RUP(1)),REAL(RUP(1)))
! PHASE_FACTOR = EXP(-IU*ANG)
! RUP = RUP*PHASE_FACTOR ! RUP NOW PURELY REAL
! RUP = RUP/TFM%R ! RUP -> UP
! PHASE_FACTOR = PHASE_FACTOR/MAXVAL(ABS(RUP(:)))
! ! APPLY THE PHASE_FACTOR:
! PSI = PSI*PHASE_FACTOR
! CHI = CHI*PHASE_FACTOR
! VEC_L(:) = VEC_L(:)/PHASE_FACTOR ! <- this is INCORRECT!!!
! VEC_L(:) = VEC_L(:)/CONJG(PHASE_FACTOR)
! ======================================================================

! 3). NORMALIZE THE ENSTROPHY ==========================================
! ENE_MK = ENSTROPHY_MK(PSI,CHI)
! PSI = PSI/ENE_MK**0.5
! CHI = CHI/ENE_MK**0.5
! CALL CHOPSET(3)
! ======================================================================

! 3.5). NORMALIZE THE ENSTROPHY ========================================
CALL CHOPSET(3)
CALL PC2VOR_MK(PSI,CHI,ROR,ROP,OZ)
CALL RTRAN_MK(ROR,1); CALL RTRAN_MK(ROP,1); CALL RTRAN_MK( OZ,1)
! ENE_MK = ENSTROPHY_MK_MOD(ROR,ROP,OZ)
ENE_MK = ENSTROPHY_MK_MOD(ROR,ROP,OZ)/ZLEN0 ! ENSTROPHY PER UNIT LENGTH
PSI = PSI/ENE_MK**0.5
CHI = CHI/ENE_MK**0.5
! ======================================================================

! 4). NORMALIZE THE MAXIMUM VELOCITY ===================================
! CALL CHOPSET(3)
! CALL PC2VEL_MK(PSI,CHI,RUR,RUP,UZ)
! CALL RTRAN_MK(RUR,1); CALL RTRAN_MK(RUP,1); CALL RTRAN_MK( UZ,1)
! ENE_MK = MAXVAL(RUR**2/TFM%R**2+RUP**2/TFM%R**2+UZ**2)
! PSI = PSI/ENE_MK
! CHI = CHI/ENE_MK
! ======================================================================

RUR = 0.D0; RUP = 0.D0; UZ = 0.D0
ROR = 0.D0; ROP = 0.D0; OZ = 0.D0
CALL PC2VEL_MK(PSI,CHI,RUR,RUP,UZ)    
CALL PC2VOR_MK(PSI,CHI,ROR,ROP,OZ)
CALL RTRAN_MK(RUR,1); CALL RTRAN_MK(RUP,1); CALL RTRAN_MK( UZ,1)
CALL RTRAN_MK(ROR,1); CALL RTRAN_MK(ROP,1); CALL RTRAN_MK( OZ,1)
CALL CHOPSET(-3)

! =========================== NORMALIZATION ============================
! =================== L^H*R = 1 & R = [PSI,DEL2CHI] ====================
CALL DEL2_MK(CHI,DEL2CHI)

IF (flip_switch) THEN
    RUR = CONJG(RUR); RUP = CONJG(RUP); UZ = CONJG( UZ)
    ROR = CONJG(ROR); ROP = CONJG(ROP); OZ = CONJG( OZ)
    PSI = CONJG(PSI)
    CHI = CONJG(CHI)
    DEL2CHI = CONJG(DEL2CHI)
ENDIF
EIG_VEC_R(:NR_MK,EIG_IND) = PSI(:NR_MK) !PSI
EIG_VEC_R(NR_MK+1:,EIG_IND) = DEL2CHI(:NR_MK) !DEL2CHI
VEC_R(:NR_MK) = PSI(:NR_MK)
VEC_R(NR_MK+1:) = DEL2CHI(:NR_MK)

VEC_L(:) = VEC_L(:)/CONJG(DOT_PRODUCT(VEC_L(:),EIG_VEC_R(:,EIG_IND)))
! WRITE(*,*) 'NORMALIZATION CHECK: ',DOT_PRODUCT(VEC_L(:),EIG_VEC_R(:,EIG_IND))
! WRITE(*,*) 'NORMALIZATION CHECK(2): ',DOT_PRODUCT(VEC_L(:),VEC_R(:))
! WRITE(*,*) '    ENSTROPHY CHECK: ',ENSTROPHY_MK(PSI,CHI)
! WRITE(*,*) '    ENSTROPHY CHECK(2): ',ENSTROPHY_MK_MOD(ROR,ROP,OZ)/ZLEN0
! ! WRITE(*,*) 'NORMED ENE:', ENERGY_MK(PSI,CHI)  

! ========================= ADJUST EIG_VEC_R ===========================
! ================= ONLY CHANGE EIG_VEC_R(:,EIG_IND) ===================
! EIG_VEC_R(:NR_MK,EIG_IND) = PSI(:NR_MK) !PSI
EIG_VEC_R(NR_MK+1:,EIG_IND) = CHI(:NR_MK) !CHI

DEALLOCATE(PSI,DEL2CHI,CHI)

END SUBROUTINE EIG2VELVOR
! ======================================================================
SUBROUTINE EIG2VEL(MREAD,AKREAD,EIG_VEC_R,RUR,RUP,UZ,comm_grp,chi_switch,print_switch)
!=======================================================================
! [USAGE]: 
! CONVERT EIG_VEC_R(COLUMN VECTOR) TO RUR, RUP, UZ COMPONENTS IN PFF
! [UPDATES]:
! CODED BY JINGE WANG
!=======================================================================
IMPLICIT NONE
INTEGER,INTENT(IN)    :: MREAD, comm_grp
REAL(P8),INTENT(IN)   :: AKREAD
! COMPLEX(P8),DIMENSION(:),ALLOCATABLE,INTENT(IN):: EIG_VEC_R
COMPLEX(P8),DIMENSION(:),INTENT(IN):: EIG_VEC_R
COMPLEX(P8),DIMENSION(:),ALLOCATABLE,INTENT(INOUT):: RUR,RUP,UZ
LOGICAL,OPTIONAL:: chi_switch, print_switch

INTEGER:: NR_MK, M_ACTUAL
REAL(P8):: AK_ACTUAL
COMPLEX(P8),DIMENSION(:),ALLOCATABLE:: PSI,DEL2CHI,CHI
LOGICAL:: flip_switch = .FALSE.

IF (MREAD.LT.0) THEN
    flip_switch = .TRUE.
    M_ACTUAL = -MREAD
    AK_ACTUAL = -AKREAD
ELSE
    flip_switch = .FALSE.
    M_ACTUAL = MREAD
    AK_ACTUAL = AKREAD
ENDIF

IF ((M(2).NE.M_ACTUAL).OR.(ABS(ZLEN-2*PI/AK_ACTUAL).GE.1.0E-13)) THEN
    IF ((PRESENT(print_switch)).AND.(print_switch)) WRITE(*,*) 'EIG2VEL: SET NEW M AND AK'
    ZLEN = 2*PI/AK_ACTUAL
    NTH = 2
    NX = 4
    NTCHOP = 2 ! M = 0, M = M_ACTUAL
    NXCHOP = 2 ! K = 0, K = AK_ACTUAL
    CALL LEGINIT(comm_grp,M_ACTUAL)
ENDIF

NR_MK = SIZE(EIG_VEC_R,1)/2

ALLOCATE(PSI(NRCHOPDIM),DEL2CHI(NRCHOPDIM),CHI(NRCHOPDIM))  
ALLOCATE(RUR(NRCHOPDIM),RUP(NRCHOPDIM),UZ(NRCHOPDIM))

PSI = 0.D0
DEL2CHI = 0.D0
IF (flip_switch) THEN
    PSI(:NR_MK) = CONJG(EIG_VEC_R(:NR_MK)) !PSI
    DEL2CHI(:NR_MK) = CONJG(EIG_VEC_R(NR_MK+1:)) !DEL2CHI
ELSE
    PSI(:NR_MK) = EIG_VEC_R(:NR_MK) !PSI
    DEL2CHI(:NR_MK) = EIG_VEC_R(NR_MK+1:) !DEL2CHI
ENDIF
if (PRESENT(chi_switch)) then
    CHI = 0.D0; CHI = DEL2CHI
else
    CALL IDEL2_MK(DEL2CHI,CHI)
endif

CALL CHOPSET(3)
CALL PC2VEL_MK(PSI,CHI,RUR,RUP,UZ) 
CALL RTRAN_MK(RUR,1)
CALL RTRAN_MK(RUP,1)
CALL RTRAN_MK( UZ,1)
CALL CHOPSET(-3)

IF (flip_switch) THEN
    RUR = CONJG(RUR)
    RUP = CONJG(RUP)
        UZ = CONJG( UZ)
ENDIF

DEALLOCATE(PSI,DEL2CHI,CHI)

END SUBROUTINE EIG2VEL
! ======================================================================

SUBROUTINE EIG2NORMED(MREAD,AKREAD,EIG_IND,EIG_VEC_R,EIG_VEC_L,comm_grp, switch)
!=======================================================================
! [USAGE]: 

! [ON EXIT]:
! EIG_VEC_R(:,EID_IND) >> [PSI,DEL2CHI] (NORMALIZED)
! VEC_L >> [PSI,DEL2CHI] (NORMALIZED)
! RUR~OZ >> VELOCITY/VORTICITY COMPONENTS (NORMALIZED)
! [UPDATES]:
! CODED BY JINGE WANG
! [HISTORY]:
! Ver.0: RENORMALIZE THE LEFT AND RIGHT EIGENVECTORS SUCH THAT UP IS PURELY 
! REAL WITH MAXIMUM MAGNITUDE OF 1.
! Ver.1: RENORMALIZE THE LEFT AND RIGHT EIGENVECTORS SUCH THAT ENSTROPHY
! IS UNITY.
! Ver.2: ENSTROPHY -> ENSTROPHY/UNIT LENGTH
!=======================================================================
IMPLICIT NONE
INTEGER,INTENT(IN):: MREAD, EIG_IND, comm_grp
REAL(P8),INTENT(INOUT):: AKREAD
COMPLEX(P8),DIMENSION(:,:),ALLOCATABLE,INTENT(INOUT):: EIG_VEC_R,EIG_VEC_L
! COMPLEX(P8),DIMENSION(:),ALLOCATABLE:: RUR,RUP,UZ
COMPLEX(P8),DIMENSION(:),ALLOCATABLE:: ROR,ROP,OZ
logical,OPTIONAL:: switch

INTEGER:: NR_MK, IND, EIG_NUM
COMPLEX(P8),DIMENSION(:),ALLOCATABLE:: PSI,DEL2CHI,CHI

! COMPLEX(P8):: NORM_FACTOR
REAL(P8):: ENS

IF ((M(2).NE.MREAD).OR.(ABS(ZLEN-2*PI/AKREAD).GE.1.0E-13)) THEN
    WRITE(*,*) 'EIG2NORMED: SET NEW M AND AK'
    ZLEN = 2*PI/AKREAD
    NTH = 2
    NX = 4
    NTCHOP = 2 ! M = 0, M = MREAD
    NXCHOP = 2 ! K = 0, K = AKREAD
    CALL LEGINIT(comm_grp,MREAD)
ENDIF

EIG_NUM = SIZE(EIG_VEC_R,1)
NR_MK = EIG_NUM/2
ALLOCATE(PSI(NRCHOPDIM),DEL2CHI(NRCHOPDIM),CHI(NRCHOPDIM))  
! ALLOCATE(RUR(NRCHOPDIM),RUP(NRCHOPDIM),UZ(NRCHOPDIM))
ALLOCATE(ROR(NRCHOPDIM),ROP(NRCHOPDIM),OZ(NRCHOPDIM))

DO IND = 1,EIG_NUM
    IF (IND.EQ.EIG_IND) CYCLE
    PSI = 0.D0
    CHI = 0.D0
    DEL2CHI = 0.D0
    ! RUR = 0.D0; RUP = 0.D0; UZ = 0.D0
    ROR = 0.D0; ROP = 0.D0; OZ = 0.D0
    PSI(:NR_MK) = EIG_VEC_R(:NR_MK,IND) !PSI
    DEL2CHI(:NR_MK) = EIG_VEC_R(NR_MK+1:,IND) !DEL2CHI
    CALL IDEL2_MK(DEL2CHI,CHI)

    ! =========================== NORMALIZATION ============================
    ! 1). NORMALIZE THE ENERGY =============================================
    ! ENE_MK = ENERGY_MK(PSI,CHI)

    ! PSI = PSI/ENE_MK**0.5
    ! CHI = CHI/ENE_MK**0.5
    ! ! VEC_L(:) = VEC_L(:)*ENE_MK**0.5 ! ENE_MK IS REAL (NOTE:NORMALIZE AT THE END)
    ! CALL CHOPSET(3)
    ! ======================================================================

    ! 2). NORMALIZE THE MAX UP =============================================
    ! CALL CHOPSET(3)
    ! CALL PC2VEL_MK(PSI,CHI,RUR,RUP,UZ)
    ! ! CALCULATE THE PHASE_FACTOR:
    ! CALL RTRAN_MK(RUP,1)
    ! RUP = RUP/TFM%R ! RUP -> UP
    ! NORM_FACTOR = 1.D0/MAXVAL(ABS(RUP(:)))
    ! CALL CHOPSET(-3)

    ! EIG_VEC_R(:,IND) = EIG_VEC_R(:,IND)*NORM_FACTOR
    ! EIG_VEC_L(:,IND) = EIG_VEC_L(:,IND)/CONJG(DOT_PRODUCT(EIG_VEC_L(:,IND),EIG_VEC_R(:,IND)))
    ! if (PRESENT(switch)) WRITE(*,1223) IND, DOT_PRODUCT(EIG_VEC_L(:,IND),EIG_VEC_R(:,IND))

    ! 3.5). NORMALIZE THE ENSTROPHY ========================================
    CALL CHOPSET(3)
    CALL PC2VOR_MK(PSI,CHI,ROR,ROP,OZ)
    CALL RTRAN_MK(ROR,1); CALL RTRAN_MK(ROP,1); CALL RTRAN_MK( OZ,1)
    ! ENS = ENSTROPHY_MK_MOD(ROR,ROP,OZ)
    ENS = ENSTROPHY_MK_MOD(ROR,ROP,OZ)/ZLEN0 ! PER UNIT LENGTH
    CALL CHOPSET(-3)

    IF (ENS.EQ.0) ENS = 1.D0
    WRITE(*,*) ENS,IND
    EIG_VEC_R(:,IND) = EIG_VEC_R(:,IND)/ENS**0.5
    EIG_VEC_L(:,IND) = EIG_VEC_L(:,IND)/CONJG(DOT_PRODUCT(EIG_VEC_L(:,IND),EIG_VEC_R(:,IND)))
    if (PRESENT(switch)) WRITE(*,1223) IND, DOT_PRODUCT(EIG_VEC_L(:,IND),EIG_VEC_R(:,IND))

ENDDO

1223 FORMAT('NORMALIZATION CHECK - #',I3,':',(F5.3,SP,F5.3,'i'))

DEALLOCATE(PSI,DEL2CHI,CHI)
! DEALLOCATE(RUR,RUP,UZ)
DEALLOCATE(ROR,ROP,OZ)

END SUBROUTINE EIG2NORMED
! ======================================================================

SUBROUTINE EIG2PT(MREAD,AKREAD,EIG_IND,EIG_VEC_R,VEC_R,comm_grp)
!=======================================================================
! [USAGE]:
! CHECK IF EIG_VEC_R & VEC_R ARE CONSISTENT W/ EACH OTHER
!=======================================================================
IMPLICIT NONE

INTEGER:: NR_MK
INTEGER,INTENT(IN):: MREAD, EIG_IND, comm_grp
REAL(P8),INTENT(INOUT):: AKREAD
COMPLEX(P8),DIMENSION(:,:),ALLOCATABLE,INTENT(IN):: EIG_VEC_R
COMPLEX(P8),DIMENSION(:),ALLOCATABLE,INTENT(IN):: VEC_R
COMPLEX(P8),DIMENSION(:),ALLOCATABLE:: PSI,DEL2CHI,CHI

IF ((M(2).NE.MREAD).OR.(ABS(ZLEN-2*PI/AKREAD).GE.1.0E-13)) THEN
    WRITE(*,*) 'EIG2VELVOR: SET NEW M AND AK'
    ZLEN = 2*PI/AKREAD
    NTH = 2
    NX = 4
    NTCHOP = 2 ! M = 0, M = MREAD
    NXCHOP = 2 ! K = 0, K = AKREAD
    CALL LEGINIT(comm_grp,MREAD)
ENDIF

NR_MK = SIZE(EIG_VEC_R,1)/2
ALLOCATE(PSI(NRCHOPDIM),DEL2CHI(NRCHOPDIM),CHI(NRCHOPDIM))  

PSI = 0.D0
CHI = 0.D0
DEL2CHI = 0.D0
PSI(:NR_MK) = EIG_VEC_R(:NR_MK,EIG_IND) !PSI
CHI(:NR_MK) = EIG_VEC_R(NR_MK+1:,EIG_IND) !CHI
CALL DEL2_MK(CHI,DEL2CHI) !DEL2CHI

WRITE(*,*) 'Check EIG_VEC_R & VEC_R'
WRITE(*,*) 'PSI-part: max difference = ', SUM(ABS(VEC_R(:NR_MK) - PSI(:NR_MK)))
WRITE(*,*) 'CHI-part: max difference = ', SUM(ABS(VEC_R(NR_MK+1:) - DEL2CHI(:NR_MK)))

DEALLOCATE(PSI,DEL2CHI,CHI)

END SUBROUTINE EIG2PT
! ======================================================================

! FUNCTION EIGRES1(EIG_VEC,M_VEC)
! ! ======================================================================
! ! CHECK THE RESOLUTION OF THE EIGVEC (PSI,DEL2CHI)
! ! ======================================================================
! COMPLEX(P8),DIMENSION(:),INTENT(IN):: EIG_VEC
! INTEGER,INTENT(IN):: M_VEC
! LOGICAL:: EIGRES1

! INTEGER:: NR_0, NR_MK, NRCHOP_LIM = 110 ! 120
! REAL(P8):: PSI_SUM, CHI_SUM

! NR_MK = SIZE(EIG_VEC)/2

! PSI_SUM = SUM(ABS(EIG_VEC(NRCHOP_LIM+1:NR_MK)))
! CHI_SUM = SUM(ABS(EIG_VEC(NR_MK+NRCHOP_LIM+1:2*NR_MK)))/(MAX(abs(M(2)),1))**2
! ! WRITE(*,*) PSI_SUM,CHI_SUM

! EIGRES1 = .TRUE.
! IF ((PSI_SUM.GT.5E-2).OR.(CHI_SUM.GT.5E-2)) THEN ! 1e-4
!     EIGRES1 = .FALSE.
!     return
! ENDIF

! NR_0 = 0; IF (M_VEC.EQ.0) NR_0 = 1
! PSI_SUM = SUM(ABS(EIG_VEC(1+NR_0:NRCHOP_LIM)))
! CHI_SUM = SUM(ABS(EIG_VEC(NR_MK+1+NR_0:NR_MK+NRCHOP_LIM)))/(MAX(abs(M(2)),1))**2
! ! WRITE(*,*) PSI_SUM,CHI_SUM
! IF ((PSI_SUM.LT.1E-10).AND.(CHI_SUM.LT.1E-10)) THEN
!     EIGRES1 = .FALSE.
! ENDIF

! END FUNCTION
! ! ======================================================================

FUNCTION EIGRES1(EIG_VEC,M_VEC)
! ======================================================================
! CHECK THE RESOLUTION OF THE EIGVEC (PSI,DEL2CHI)
! ======================================================================
COMPLEX(P8),DIMENSION(:),INTENT(IN):: EIG_VEC
INTEGER,INTENT(IN):: M_VEC
LOGICAL:: EIGRES1,EIGRES1_M(1)

COMPLEX(P8),DIMENSION(SIZE(EIG_VEC),1):: EIG_VEC_M

EIG_VEC_M(:,1) = EIG_VEC
EIGRES1_M = EIGRESM(EIG_VEC_M,M_VEC)
EIGRES1 = EIGRES1_M(1)

END FUNCTION
! ======================================================================

FUNCTION EIGRESM(EIG_VEC_M,M_VEC)
! ======================================================================
! CHECK THE RESOLUTION OF THE EIGVEC (PSI,DEL2CHI)
! ======================================================================
COMPLEX(P8),DIMENSION(:,:),INTENT(IN):: EIG_VEC_M
INTEGER,INTENT(IN):: M_VEC
LOGICAL:: EIGRESM(SIZE(EIG_VEC_M,2))

INTEGER:: NR_0, NR_MK, NRCHOP_LIM = 110 ! 120
REAL(P8):: PSI_SUM(SIZE(EIG_VEC_M,2)), CHI_SUM(SIZE(EIG_VEC_M,2))

NR_MK = SIZE(EIG_VEC_M,1)/2

PSI_SUM = SUM(ABS(EIG_VEC_M(NRCHOP_LIM+1:NR_MK,:)),DIM=1)
CHI_SUM = SUM(ABS(EIG_VEC_M(NR_MK+NRCHOP_LIM+1:2*NR_MK,:)),DIM=1)/(MAX(abs(M_VEC),1))**2
! WRITE(*,*) PSI_SUM,CHI_SUM

EIGRESM = .TRUE.
EIGRESM = ((PSI_SUM.LE.5E-2).AND.(CHI_SUM.LE.5E-2))
! IF ((PSI_SUM.GT.5E-2).OR.(CHI_SUM.GT.5E-2)) THEN ! 1e-4
!     EIGRESM = .FALSE.
!     return
! ENDIF

NR_0 = 0; IF (M_VEC.EQ.0) NR_0 = 1
PSI_SUM = SUM(ABS(EIG_VEC_M(1+NR_0:NRCHOP_LIM,:)),DIM=1)
CHI_SUM = SUM(ABS(EIG_VEC_M(NR_MK+1+NR_0:NR_MK+NRCHOP_LIM,:)),DIM=1)/(MAX(abs(M_VEC),1))**2
! WRITE(*,*) PSI_SUM,CHI_SUM

EIGRESM = EIGRESM.AND.((PSI_SUM.GE.1E-10).AND.(CHI_SUM.GE.1E-10))
! IF ((PSI_SUM.LT.1E-10).AND.(CHI_SUM.LT.1E-10)) THEN
!     EIGRESM = .FALSE.
! ENDIF

END FUNCTION
! ======================================================================

SUBROUTINE SAVE_VEL(RUR,RUP,UZ,VEL_FILENAME)
! ======================================================================
! SAVE R, UR, UP, UZ 
! NOTE: UR = RUR/R, etc.
! ======================================================================
    IMPLICIT NONE

    INTEGER:: VEL_FID=17, I,IS
    CHARACTER(LEN=*):: VEL_FILENAME
    COMPLEX(P8),DIMENSION(:),INTENT(IN):: RUR,RUP,UZ

    open(VEL_FID,FILE=VEL_FILENAME,STATUS='unknown',ACTION='WRITE',IOSTAT=IS)

    DO I = 1,NR
        WRITE(VEL_FID,117) TFM%R(I),REAL(RUR(I))/TFM%R(I),AIMAG(RUR(I))/TFM%R(I) &
                                    ,REAL(RUP(I))/TFM%R(I),AIMAG(RUP(I))/TFM%R(I) &
                                    ,REAL(UZ(I)),AIMAG(UZ(I))
    ENDDO
    
117  FORMAT(7(G20.12,:,','))
    close(VEL_FID)

END SUBROUTINE SAVE_VEL
! ======================================================================

SUBROUTINE SAVE_VEC(VEC_FILENAME,VEC_R,VEC_L,SPACE_FLAG_IN)
! ======================================================================
! SAVE THE RIGHT/LEFT EIGENVECTORS
! PFF: PSI_R, CHI_R, PSI_L, CHI_L
! FFF: VEC_R, VEC_L
! ======================================================================
IMPLICIT NONE

INTEGER:: VEC_FID=17, I,IS,NN,NR_MK, SPACE_FLAG
INTEGER,OPTIONAL:: SPACE_FLAG_IN
CHARACTER(LEN=*):: VEC_FILENAME
COMPLEX(P8),DIMENSION(:),INTENT(IN):: VEC_R
COMPLEX(P8),DIMENSION(:),INTENT(IN),OPTIONAL:: VEC_L
COMPLEX(P8),DIMENSION(:),ALLOCATABLE:: PSI,DEL2CHI,CHI
COMPLEX(P8),DIMENSION(:),ALLOCATABLE:: PSI_L,DEL2CHI_L,CHI_L

IF (.NOT.(PRESENT(SPACE_FLAG_IN))) THEN
    SPACE_FLAG = FFF_SPACE
ELSE
    SPACE_FLAG = SPACE_FLAG_IN
ENDIF

IF (SPACE_FLAG.EQ.PFF_SPACE) THEN
    NR_MK = SIZE(VEC_R)/2
    ALLOCATE(PSI(NRCHOPDIM),DEL2CHI(NRCHOPDIM),CHI(NRCHOPDIM))
    PSI(:NR_MK) = VEC_R(:NR_MK) !PSI
    DEL2CHI(:NR_MK) = VEC_R(NR_MK+1:) !DEL2CHI
    CALL IDEL2_MK(DEL2CHI,CHI)
    CALL RTRAN_MK(PSI,1)
    CALL RTRAN_MK(CHI,1)

    IF (PRESENT(VEC_L)) THEN
        ALLOCATE(PSI_L(NRCHOPDIM),DEL2CHI_L(NRCHOPDIM),CHI_L(NRCHOPDIM))
        PSI_L(:NR_MK) = VEC_L(:NR_MK) !PSI
        DEL2CHI_L(:NR_MK) = VEC_L(NR_MK+1:) !DEL2CHI
        CALL IDEL2_MK(DEL2CHI_L,CHI_L)
        CALL RTRAN_MK(PSI_L,1)
        CALL RTRAN_MK(CHI_L,1)
    ENDIF
ENDIF

open(VEC_FID,FILE=VEC_FILENAME,STATUS='unknown',ACTION='WRITE',IOSTAT=IS)

IF (SPACE_FLAG.EQ.FFF_SPACE) THEN

    NN = SIZE(VEC_R)
    IF (PRESENT(VEC_L)) THEN
        DO I = 1,NN
            WRITE(VEC_FID,117) REAL(VEC_R(I)),AIMAG(VEC_R(I)),REAL(VEC_L(I)),AIMAG(VEC_L(I))
        ENDDO
    ELSE
        DO I = 1,NN
            WRITE(VEC_FID,117) REAL(VEC_R(I)),AIMAG(VEC_R(I))
        ENDDO
    ENDIF

ELSE

    IF (PRESENT(VEC_L)) THEN
        DO I = 1,NR
            WRITE(VEC_FID,117) REAL(PSI(I)),AIMAG(PSI(I)),REAL(CHI(I)),AIMAG(CHI(I)), &
            REAL(PSI_L(I)),AIMAG(PSI_L(I)),REAL(CHI_L(I)),AIMAG(CHI_L(I))
        ENDDO
    ELSE
        DO I = 1,NR
            WRITE(VEC_FID,117) REAL(PSI(I)),AIMAG(PSI(I)),REAL(CHI(I)),AIMAG(CHI(I))
        ENDDO
    ENDIF

    DEALLOCATE(PSI,DEL2CHI,CHI)
    IF (PRESENT(VEC_L)) DEALLOCATE(PSI_L,DEL2CHI_L,CHI_L)

ENDIF

117  FORMAT(8(G20.12,:,','))
close(VEC_FID)
    

END SUBROUTINE SAVE_VEC
! ======================================================================

SUBROUTINE SAVE_PSICHI(PSICHI,SAVE_FILENAME,FFF_SWITCH)
! ======================================================================
! Save the psi and chi components in PFF space
! ======================================================================
IMPLICIT NONE
COMPLEX(P8), DIMENSION(:),INTENT(IN):: PSICHI
COMPLEX(P8), DIMENSION(:), ALLOCATABLE:: PSI, CHI
INTEGER:: SAVE_FID=17, I, NR_MK, IS
CHARACTER(LEN=*):: SAVE_FILENAME
LOGICAL, OPTIONAL:: FFF_SWITCH

ALLOCATE(PSI(NRCHOPDIM),CHI(NRCHOPDIM))
NR_MK = SIZE(PSICHI)/2
PSI = 0.D0; CHI = 0.D0
PSI(1:NR_MK) = PSICHI(1:NR_MK)
CHI(1:NR_MK) = PSICHI(NR_MK+1:)

IF ((PRESENT(FFF_SWITCH)).AND.(FFF_SWITCH .EQ. .TRUE.)) THEN

    open(SAVE_FID,FILE=SAVE_FILENAME,STATUS='unknown',ACTION='WRITE',IOSTAT=IS)
    DO I = 1,NR_MK
        WRITE(SAVE_FID,117) I,REAL(PSI(I)),AIMAG(PSI(I)),REAL(CHI(I)),AIMAG(CHI(I))
    ENDDO

ELSE

CALL RTRAN_MK(PSI,1)
CALL RTRAN_MK(CHI,1)    

open(SAVE_FID,FILE=SAVE_FILENAME,STATUS='unknown',ACTION='WRITE',IOSTAT=IS)
DO I = 1,NR
    WRITE(SAVE_FID,117) TFM%R(I),REAL(PSI(I)),AIMAG(PSI(I)),REAL(CHI(I)),AIMAG(CHI(I))
ENDDO

ENDIF


117  FORMAT(7(G20.12,:,','))
close(SAVE_FID)
DEALLOCATE(PSI,CHI)

END SUBROUTINE
! ======================================================================

SUBROUTINE SAVE_PERTURB(FILENAME,&
    M_1, K_VAL_1, VEC_1, M_eig_1, &
    M_2, K_VAL_2, VEC_2, M_eig_2, &
    M_BAR, K_BAR, VEC_BAR, EIG_BAR, LAMB)
! ======================================================================
! CREATE PERTURBATION FILE
! ======================================================================
IMPLICIT NONE
CHARACTER(LEN=*):: FILENAME                              
COMPLEX(P8),DIMENSION(:):: VEC_1, VEC_2
INTEGER:: M_1, M_2
REAL(P8):: K_VAL_1, K_VAL_2
COMPLEX(P8):: M_eig_1, M_eig_2

COMPLEX(P8),DIMENSION(:),OPTIONAL:: VEC_BAR
INTEGER,OPTIONAL:: M_BAR
REAL(P8),OPTIONAL:: K_BAR, LAMB
COMPLEX(P8),OPTIONAL:: EIG_BAR

INTEGER:: I, IS, NDIM
REAL(P8):: rp1 = 1.D0, ip1 = 0.D0

! open(10,FILE='./converg/new_perturb.input',STATUS='unknown',ACTION='WRITE',IOSTAT=IS)
open(10,FILE=FILENAME,STATUS='unknown',ACTION='WRITE',IOSTAT=IS)

if (IS.ne.0) then
    print *, 'ERROR: createperturb -- Could not creat new file new_perturb.dat'
    RETURN
end if

! Number of perturbation 
IF (present(M_BAR)) then
    I = 3
ELSE
    I = 2
ENDIF
WRITE(10,'(I2)') I
DO IS=1,I
    IF ((PRESENT(LAMB)).AND.(IS.EQ.1)) THEN; WRITE(10,'(F9.7,1X,F9.7)') LAMB, ip1; CYCLE; ENDIF
    WRITE(10,'(F9.7,1X,F9.7)') rp1, ip1
ENDDO

! EIB_BAR
IF (PRESENT(M_BAR)) THEN
    WRITE(10,*) 'eigenfunction'
    WRITE(10,108) 'ndim','m','k'
    NDIM = size(VEC_BAR,1)/2
    WRITE(10,109) NDIM, M_BAR, K_BAR
        ! Below are not actually used:
        WRITE(10,108) 'q','h','b'
        WRITE(10,110) QPAIR%Q(1),QPAIR%H(1),QPAIR%B(1) ! MIGHT NEED TO CHANGE!!!!!! 
        WRITE(10,108) 'nu_pow','nu','lmap'
        WRITE(10,110) VISC%NUP,VISC%NU,ELL
        WRITE(10,'(9X,A9,9X,A9)') 're(sigma)','im(sigma)'
        WRITE(10,113) REAL(EIG_BAR),AIMAG(EIG_BAR)
        WRITE(10,*) 'radial spectral coefficients'
        WRITE(10,111) 're(psi)','im(psi)','re(chi)','im(chi)'
    DO I = 1,NDIM
        WRITE(10,112) REAL(VEC_BAR(I)),AIMAG(VEC_BAR(I)),REAL(VEC_BAR(NDIM+I)),AIMAG(VEC_BAR(NDIM+I))
    ENDDO
ENDIF

! EIG_1
WRITE(10,*) 'eigenfunction'
WRITE(10,108) 'ndim','m','k'
NDIM = size(VEC_1,1)/2
WRITE(10,109) NDIM, M_1, K_VAL_1
    ! Below are not actually used:
    WRITE(10,108) 'q','h','b'
    WRITE(10,110) QPAIR%Q(1),QPAIR%H(1),QPAIR%B(1) ! MIGHT NEED TO CHANGE!!!!!! 
    WRITE(10,108) 'nu_pow','nu','lmap'
    WRITE(10,110) VISC%NUP,VISC%NU,ELL
    WRITE(10,'(9X,A9,9X,A9)') 're(sigma)','im(sigma)'
    WRITE(10,113) REAL(M_eig_1),AIMAG(M_eig_1)
    WRITE(10,*) 'radial spectral coefficients'
    WRITE(10,111) 're(psi)','im(psi)','re(chi)','im(chi)'
DO I = 1,NDIM
    WRITE(10,112) REAL(VEC_1(I)),AIMAG(VEC_1(I)),REAL(VEC_1(NDIM+I)),AIMAG(VEC_1(NDIM+I))
ENDDO

! EIG_2
WRITE(10,*) 'eigenfunction'
WRITE(10,108) 'ndim','m','k'
NDIM = size(VEC_2,1)/2
WRITE(10,109) NDIM, M_2, K_VAL_2
    ! Below are not actually used:
    WRITE(10,108) 'q','h','b'
    WRITE(10,110) QPAIR%Q(1),QPAIR%H(1),QPAIR%B(1) ! MIGHT NEED TO CHANGE!!!!!! 
    WRITE(10,108) 'nu_pow','nu','lmap'
    WRITE(10,110) VISC%NUP,VISC%NU,ELL
    WRITE(10,'(9X,A9,9X,A9)') 're(sigma)','im(sigma)'
    WRITE(10,113) REAL(M_eig_2),AIMAG(M_eig_2)
    WRITE(10,*) 'radial spectral coefficients'
    WRITE(10,111) 're(psi)','im(psi)','re(chi)','im(chi)'
DO I = 1,NDIM
    WRITE(10,112) REAL(VEC_2(I)),AIMAG(VEC_2(I)),REAL(VEC_2(NDIM+I)),AIMAG(VEC_2(NDIM+I))
ENDDO

108  FORMAT(3(12X,A12))
109  FORMAT(2(12X,I12),12X,F12.8)
110  FORMAT(3(12X,F12.8))
111  FORMAT(4(12X,A12))
112  FORMAT(4(G24.16,:,''))
113  FORMAT(12X,F12.8,12X,F12.8)
! 108  FORMAT(3(9X,A9))
! 109  FORMAT(2(9X,I9),9X,F9.5)
! 110  FORMAT(3(9X,F9.5))
! 111  FORMAT(4(9X,A9))
! 112  FORMAT(4(G20.12,:,''))
! 113  FORMAT(9X,F9.5,9X,F9.5)

close(10)

END SUBROUTINE SAVE_PERTURB
! ======================================================================

SUBROUTINE SAVE_MODE(MREAD, AKREAD, EIG_MAT, EIG_VAL, EIG_VEC_R, EIG_VEC_L)
! ======================================================================
! SAVE 2-bit UNOFRMATTED MODE DATA:
! 1. M, AK, #ofEIGs
! 2. EIG_MAT
! 3. EIG_VAL, EIG_VEC_R, EIG_VEC_L
! SAVE TO './DATA/EIG_M_AK.DAT'
! ======================================================================
IMPLICIT NONE
INTEGER:: MREAD, STATUS
REAL(P8):: AKREAD
COMPLEX(P8),DIMENSION(:):: EIG_VAL 
COMPLEX(P8),DIMENSION(:,:):: EIG_MAT, EIG_VEC_R, EIG_VEC_L

CHARACTER(LEN=72):: FN ! MODE'S FILE NAME
CHARACTER(LEN=6) :: K_VAL

IF (MPI_GLB_RANK.NE.0) THEN
    WRITE(*,*) 'SAVE_MODE: CAN ONLY BE CALLED BY MASTER RANK'
    RETURN
ENDIF

WRITE(K_VAL,'(F0.2)') AKREAD
FN = 'EIG_'//ITOA4(MREAD)//'_'//TRIM(K_VAL)//'.dat'
OPEN(UNIT=7,FILE='./data/'//TRIM(FN),STATUS='UNKNOWN',FORM='UNFORMATTED',IOSTAT=STATUS)
! OPEN(UNIT=7,FILE='/run/media/jinge/One Touch/AircraftWakeVortex/220915/data/'//TRIM(FN),STATUS='UNKNOWN',FORM='UNFORMATTED',IOSTAT=STATUS)

IF(STATUS.NE.0) THEN
    WRITE(*,*) 'SAVE_MODE: FAILED TO OPEN ',TRIM(FN)
    STOP
ENDIF

WRITE(7) MREAD,AKREAD,SIZE(EIG_VAL)
WRITE(7) EIG_MAT(:,:)
WRITE(7) EIG_VAL(:)
WRITE(7) EIG_VEC_R(:,:)
WRITE(7) EIG_VEC_L(:,:)

CLOSE(7)

WRITE(*,*) 'SAVE_MODE: SAVED TO ',TRIM(FN)

END SUBROUTINE SAVE_MODE
! ======================================================================

SUBROUTINE READ_MODE(MREAD, AKREAD, EIG_MAT, EIG_VAL, EIG_VEC_R, EIG_VEC_L)
! ======================================================================
! READ 2-bit UNOFRMATTED MODE DATA:
! 1. M, AK, #ofEIGs
! 2. EIG_MAT
! 3. EIG_VAL, EIG_VEC_R, EIG_VEC_L
! FROM './DATA/EIG_M_AK.DAT'
! ======================================================================
IMPLICIT NONE
INTEGER:: MREAD, STATUS, MFILE, EIGSIZE
REAL(P8):: AKREAD, AKFILE
COMPLEX(P8),DIMENSION(:,:),ALLOCATABLE:: EIG_MAT
COMPLEX(P8),DIMENSION(:),ALLOCATABLE,OPTIONAL:: EIG_VAL
COMPLEX(P8),DIMENSION(:,:),ALLOCATABLE,OPTIONAL:: EIG_VEC_R, EIG_VEC_L

CHARACTER(LEN=72):: FN ! MODE'S FILE NAME
CHARACTER(LEN=6) :: K_VAL

! IF (ABS(AKREAD).LT.1E-4) AKREAD = 0.D0
WRITE(K_VAL,'(F0.2)') AKREAD
FN = 'EIG_'//ITOA4(MREAD)//'_'//TRIM(K_VAL)//'.dat'
OPEN(UNIT=7,FILE='./data/'//TRIM(FN),STATUS='OLD',FORM='UNFORMATTED',ACTION='READ',IOSTAT=STATUS)
! OPEN(UNIT=7,FILE='/run/media/jinge/One Touch/AircraftWakeVortex/220915/data/'//TRIM(FN),STATUS='OLD',FORM='UNFORMATTED',ACTION='READ',IOSTAT=STATUS)

IF(STATUS.NE.0) THEN
    WRITE(*,*) 'READ_MODE: FAILED TO OPEN ',TRIM(FN)
    STOP
ENDIF

READ(7) MFILE,AKFILE,EIGSIZE
! IF ((MFILE.NE.MREAD).OR.(AKFILE.NE.AKREAD)) THEN
IF ((ABS(MFILE-MREAD).GT.1E-12).OR.(ABS(AKFILE-AKREAD).GT.1E-12)) THEN
    WRITE(*,*) 'READ_MODE: {M,AK} DOES NOT MATCH'
    WRITE(*,*) 'FILE:',MFILE,AKFILE
    WRITE(*,*) 'READ:',MREAD,AKREAD
    STOP
ENDIF

IF (ALLOCATED(EIG_MAT)) DEALLOCATE(EIG_MAT)
ALLOCATE(EIG_MAT(EIGSIZE,EIGSIZE))
READ(7) EIG_MAT(:,:)

IF ((PRESENT(EIG_VAL)).AND.(MPI_GLB_RANK.EQ.0)) THEN
    IF (ALLOCATED(EIG_VAL)) DEALLOCATE(EIG_VAL)
    ALLOCATE(EIG_VAL(EIGSIZE))
    READ(7) EIG_VAL(:)

    IF (PRESENT(EIG_VEC_L)) THEN
        IF (ALLOCATED(EIG_VEC_R)) DEALLOCATE(EIG_VEC_R)
        IF (ALLOCATED(EIG_VEC_L)) DEALLOCATE(EIG_VEC_L)
        ALLOCATE(EIG_VEC_R(EIGSIZE,EIGSIZE),EIG_VEC_L(EIGSIZE,EIGSIZE))

        READ(7) EIG_VEC_R(:,:)
        READ(7) EIG_VEC_L(:,:)
    ELSE
        IF (ALLOCATED(EIG_VEC_R)) DEALLOCATE(EIG_VEC_R)
        ALLOCATE(EIG_VEC_R(EIGSIZE,EIGSIZE))

        READ(7) EIG_VEC_R(:,:)
    ENDIF
ENDIF

CLOSE(7)

END SUBROUTINE READ_MODE
! ======================================================================

FUNCTION RESMASK(MASK1,MASK2)
! ======================================================================
! CREATE 2D GRID THAT BLOCKS THE UNRESLVED MODES
! ======================================================================
IMPLICIT NONE
! INTEGER:: N1,N2
LOGICAL:: MASK1(:),MASK2(:)

LOGICAL,DIMENSION(SIZE(MASK1),SIZE(MASK2)):: RESMASK,MASK1_2D,MASK2_2D

RESMASK = .FALSE.

MASK1_2D = SPREAD(MASK1,2,SIZE(MASK2))
MASK2_2D = SPREAD(MASK2,1,SIZE(MASK1))

RESMASK = MASK1_2D .AND. MASK2_2D

END FUNCTION RESMASK
! ======================================================================

FUNCTION DIFF2D(EIG1,EIG2)
! ======================================================================
! CREATE 2D ARRAY A_JK = EIG2(K) - EIG1(J)
! ======================================================================
IMPLICIT NONE
! INTEGER:: N1,N2
COMPLEX(P8):: EIG1(:),EIG2(:)

COMPLEX(P8),DIMENSION(SIZE(EIG1),SIZE(EIG2)):: DIFF2D,EIG1_2D,EIG2_2D

EIG1_2D = SPREAD(EIG1,2,SIZE(EIG2))
EIG2_2D = SPREAD(EIG2,1,SIZE(EIG1))

DIFF2D = EIG2_2D - EIG1_2D

END FUNCTION DIFF2D
! ======================================================================

END MODULE MOD_EVP
