!=======================================================================
!
!     WRITTEN BY SANGJOON (JOON) LEE
!     DEPT. OF MECHANICAL ENGINEERING
!     UNIV. OF CALIFORNIA AT BERKELEY
!     EMAIL: SANGJOONLEE@BERKELEY.EDU
!     
!     UC BERKELEY CFD LAB
!     HTTPS://CFD.ME.BERKELEY.EDU/
!
!     NONCOMMERCIAL USE WITH COPYRIGHTED (C) MARK
!     UNDER DEVELOPMENT FOR RESEARCH PURPOSE 
!
!=======================================================================
PROGRAM INIT
!=======================================================================
! [USAGE]: 
! MAKE AN INITIAL FIELD IN A POLOIDAL-TOROIDAL FORM 
! BASED ON THE INITIAL Q-VORTEX PROFILE, CREATE PSI0 AND CHI0
! [UPDATES]:
! BASED ON TATSU'S ORIGINAL CODE PAIRMAKE
! LAST UPDATE ON NOV 23, 2020
!=======================================================================
USE omp_lib
USE MPI
USE MOD_MISC
USE MOD_BANDMAT
USE MOD_EIG
USE MOD_FD
USE MOD_LIN_LEGENDRE
USE MOD_SCALAR3
USE MOD_FFT
USE MOD_LAYOUT
USE MOD_LEGOPS
USE MOD_MARCH
USE MOD_DIAGNOSTICS
USE MOD_INIT

IMPLICIT NONE
TYPE(SCALAR):: A, B, C   ! EXTRA SCALAR-TYPE VARIABLES
INTEGER     :: I, J, K   ! EXTRA INTEGER VARIABLES (FOR ITER.)
REAL(P8)    :: X, Y, Z   ! EXTRA REAL(P8) VARIABLES

!MPI
INTEGER     :: MPI_PROCS
! DEBUG:
COMPLEX(P8),DIMENSION(:,:,:),ALLOCATABLE:: GLOBAL_ARRAYS

! CALL MPI_INIT(IERR)
CALL MPI_INIT_THREAD(MPI_THREAD_SERIALIZED,MPI_THREAD_MODE,IERR)
IF (MPI_THREAD_MODE.LT.MPI_THREAD_SERIALIZED) THEN
    WRITE(*,*) 'The threading support is lesser than that demanded.'
    CALL MPI_ABORT(MPI_COMM_WORLD,1,IERR)
ENDIF
CALL MPI_COMM_SIZE(MPI_COMM_WORLD, MPI_PROCS, IERR)
CALL MPI_COMM_RANK(MPI_COMM_WORLD, MPI_RANK, IERR)

IF(MPI_RANK.EQ.0) THEN
WRITE(*,*) 'PROGRAM STARTED'
CALL PRINT_REAL_TIME()   ! @ MOD_MISC
ENDIF

! TYPE '%read.input' TO READ THE INPUT VALUES FROM read.input
CALL READCOM('NOECHO')   ! TURN OFF THE ECHO MODE
! ======================================================================
! NOTE:
! ======================================================================
! READIN USE READCOM WHICH IS NOT COMPATIBLE WITH MPI I/O. THEREFORE, AL
! L PROCS ARE READING THE SAME FILE AT THE SAME TIME. ANOTHER WAY IS TO 
! USE THE MASTER PROC TO READ ALL THE INFO AND BROADCAST IT TO THE OTHER
! PROC THE SECOND METHOD USE READ_SYNC AS SEEN IN THE COMMENT BELOW. IN
! MY LOCAL COMPUTER, THE TWO METHODS ARE ABOUT THE SAME SPEED. MUST TEST
! THEM IN THE SUPER COMPUTERS.
! ======================================================================
CALL READIN(5)           ! @ MOD_INIT
CALL LEGINIT()

! ===== USE MPI_BCAST RATHER THAN ALL PROCS READING THE SAME FILE ======
! ===================== TURNS OUT TO BE VERY SLOW ======================
! ========== MUST MUTE MPI_BCAST IN READCOM TO USE READ_SYNC ===========
! CALL READCOM('NOECHO')   ! TURN OFF THE ECHO MODE
! IF (MPI_RANK.EQ.0) CALL READIN(5)
! CALL MPI_BARRIER(MPI_COMM_IVP,IERR)
! CALL READ_SYNC()
! CALL LEGINIT()
! ======================================================================

IF (MPI_RANK.EQ.0) THEN
  CALL COLLOC_INFO()

  ! NR: # OF RADIAL COLLOC. PTS
  ! NTH: # OF AZIMUTHAL COLLOC. PTS
  ! NX: # OF AXIAL COLLOC. PTS
  WRITE(*,*) 'NR,NTH,NX=',NR,NTH,NX

  DO I=1,QPAIR%N
    ! INDICATE THE INITIAL VORTEX POSITIONS AND STRENGTHS
    WRITE(6,61) 'VORTEX:',I
    WRITE(6,60) 'X=',QPAIR%X(I),'Y=',QPAIR%Y(I)
    WRITE(6,60) 'Q=',QPAIR%Q(I),'H=',QPAIR%H(I),'B=',QPAIR%B(I)
    
    ! THESE QUANTITIES ARE FOR PERTURBING THE VORTEX 
    ! K=1, R=1, REST=0 (DEFAULT)
    WRITE(6,60) 'DX=',QPAIR%DX(I),'DY=',QPAIR%DY(I)
    WRITE(6,60) 'K=' ,QPAIR%K(I), 'PHAS=',QPAIR%DP(I)
    WRITE(6,60) 'R=' ,QPAIR%R(I), 'DR=',QPAIR%DR(I)
    WRITE(6,60) 'RK=',QPAIR%RK(I),'PHAS=',QPAIR%RP(I)
  ENDDO
  WRITE(6,61) 'NOISE=',QPAIR%NOISE ! NOISE=0 (DEFAULT)
ENDIF

61   FORMAT(A,I2)
60   FORMAT(A5,1PE13.6,1X,A5,1PE13.6)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!! STAGE 1. GENERATE PSI0 !!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
CALL ALLOCATE(A,PPP_SPACE)

! INITIALIZE
A%E = 0.D0

DO I=1,QPAIR%N
  ! INPUT OMEGA_Z (=2Q*EXP(-R**2)) INTO GAUSDATA
  ! IN ORDER TO OBTAIN PSI0, WE USE THE FORMULA
  ! OMEGA_Z = - DELSQH PSI0      <-->
  ! PSI0    = DELSQH^(-1)(-OMEGA_Z).
  GAUSDATA%XC = QPAIR%X(I)
  GAUSDATA%YC = QPAIR%Y(I)
  GAUSDATA%Q  = QPAIR%Q(I)*2.
  GAUSDATA%B  = 1.D0
  GAUSDATA%DX = QPAIR%DX(I)
  GAUSDATA%DY = QPAIR%DY(I)
  GAUSDATA%K  = QPAIR%K(I)
  GAUSDATA%DP = QPAIR%DP(I)
  GAUSDATA%R  = QPAIR%R(I)
  GAUSDATA%DR = QPAIR%DR(I)
  GAUSDATA%RK = QPAIR%RK(I)
  GAUSDATA%RP = QPAIR%RP(I)
  
  ! CREATE A GAUSSIAN VORTEX MULTIPLIED BY (1-X)^(-2)
  ! NOW A%E HAS THE FIELD F(R,T,Z) = 2Q*EXP(-B*R**2)*(1-X)^(-2)
  ! WHERE X = (R^2-ELL^2)/(R^2+ELL^2)
  CALL LAY(A,GAUS,2)
  ! ! DEBUG:
  ! CALL LAYP(A,COSM)
  
  ! CHECK WHETHER THE GAUSSIAN IS ACTUALLY GAUSSIAN
  ! FOR DEBUGGIN PURPOSES. TURN IT OFF IN PRACTICE
  ! CALL CHECKGAUSSIAN(A,GAUSDATA%XC,GAUSDATA%YC,2)
ENDDO

! (1-X)^(-2)*OMEGA_Z (PPP) --> (1-X)^(-2)*OMEGA_Z (FFF)
! THE FUNCTION IS TRUNCATED INTO THE FINITE BASIS FUNCTION SET,
! CAUSING THE INFORMATION LOSS DUE TO APPROXIMATION, WHICH IS
! INEVITABLE UNLESS WE USE THE INFINITE-SIZE FULL BASIS SET
! STILL, THE TRANSFORMED COEFFICIENT MATRIX IN FFF SPACE
! IS THE BEST APPROXIMATION OF THE INPUT FIELD IN PPP SPACE.
! CALL TOFF(A)

! ======================================================================
CALL HORFFT(A,-1)

CALL VERFFT(A,-1)
! allocate(GLOBAL_ARRAYS(NDIMR,NTCHOPDIM,NXCHOPDIM))
! ! allocate(GLOBAL_ARRAYS(NDIMR, NDIMTH, NDIMX))
! CALL MASSEMBLE(A%E,GLOBAL_ARRAYS,1);
! CALL save_glb(GLOBAL_ARRAYS,"PSI_GLB_PFF")
! deallocate(GLOBAL_ARRAYS)

! CALL RTRAN(A,-1)
CALL rtran_test(A)
! allocate(GLOBAL_ARRAYS(NRCHOPDIM,NTCHOPDIM,NXCHOPDIM))
! ! allocate(GLOBAL_ARRAYS(NDIMR, NDIMTH, NDIMX))
! CALL MASSEMBLE(A%E,GLOBAL_ARRAYS,1);
! CALL save_glb(GLOBAL_ARRAYS,"AAA_GLB_FFF")
! deallocate(GLOBAL_ARRAYS)

! ======================================================================

! (1-X)^(-2)*OMEGA_Z (FFF) --> -(1-X)^(-2)*OMEGA_Z (FFF)
A%E=-A%E

! MUTE A LOGTERM
A%LN=0

! ADD RANDOM NOISE IF THE NOISE OPTION IS ON
IF(QPAIR%NOISE .EQ. 1) THEN
  CALL ALLOCATE(B)
  B=A
  CALL NOISE(A,0.02_P8)
  CALL TOFP(A)
  CALL TOFP(B)
  CALL FLATTEN(A,B)
  CALL TOFF(A)
  CALL DEALLOCATE(B)
ENDIF

! -(1-X)^(-2)*OMEGA_Z (FFF) -> DELSQH^(-1)(-OMEGA_Z) = PSI0 (FFF)
! NOTE: IDELSQH = ((1-X)^(-2) DELSQH)^(-1) = DELSQH^(-1)*((1-X)^(-2))^(-1)
! CREATES INVERSE HORIZONTAL DEL-SQUARE OPERATOR WITH EXTRA (1-X)^2
! B NOW HAS A LOG TERM ASSOCIATED WITH THE R-DERIVATIVE 
! IN THE INVERSE DEL SQ.
CALL ALLOCATE(B)
CALL IDELSQH(A,B)

CALL MSAVE(B, TRIM(ADJUSTL(FILES%SAVEDIR))//FILES%PSI0)

CALL DEALLOCATE(A)
CALL DEALLOCATE(B)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!! STAGE 2. GENERATE CHI0 !!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
CALL ALLOCATE(A,PPP_SPACE)

! INITIALIZE
A%E=0

DO I=1,QPAIR%N
  ! INPUT V_Z (=H*EXP(-B*R**2)) INTO GAUSDATA
  ! IN ORDER TO OBTAIN CHI0, WE USE THE FORMULA
  ! V_Z = - DELSQH CHI0      <-->
  ! CHI0    = DELSQH^(-1)(-V_Z).
  GAUSDATA%XC = QPAIR%X(I)
  GAUSDATA%YC = QPAIR%Y(I)
  GAUSDATA%Q  = QPAIR%H(I)
  GAUSDATA%B  = QPAIR%B(I)
  GAUSDATA%DX = QPAIR%DX(I)
  GAUSDATA%DY = QPAIR%DY(I)
  GAUSDATA%K  = QPAIR%K(I)
  GAUSDATA%DP = QPAIR%DP(I)
  GAUSDATA%R  = QPAIR%R(I)
  GAUSDATA%DR = QPAIR%DR(I)
  GAUSDATA%RK = QPAIR%RK(I)
  GAUSDATA%RP = QPAIR%RP(I)

  ! CREATE A GAUSSIAN VORTEX MULTIPLIED BY (1-X)^(-2)
  ! NOW A%E HAS THE FIELD F(R,T,Z) = B*EXP(-R**2)*(1-X)^(-2)
  ! WHERE X = (R^2-ELL^2)/(R^2+ELL^2)
  CALL LAY(A,GAUS,2)
  ! ! DEBUG:
  ! CALL LAYP(A,COSM)

  ! CHECK WHETHER THE GAUSSIAN IS ACTUALLY GAUSSIAN
  ! FOR DEBUGGIN PURPOSES. TURN IT OFF IN PRACTICE
  ! CALL CHECKGAUSSIAN(A,GAUSDATA%XC,GAUSDATA%YC,2)
ENDDO

! (1-X)^(-2)*V_Z (PPP) --> (1-X)^(-2)*V_Z (FFF)
! THE FUNCTION IS TRUNCATED INTO THE FINITE BASIS FUNCTION SET,
! CAUSING THE INFORMATION LOSS DUE TO APPROXIMATION, WHICH IS
! INEVITABLE UNLESS WE USE THE INFINITE-SIZE FULL BASIS SET
! STILL, THE TRANSFORMED COEFFICIENT MATRIX IN FFF SPACE
! IS THE BEST APPROXIMATION OF THE INPUT FIELD IN PPP SPACE.
CALL TOFF(A)

! (1-X)^(-2)*V_Z (FFF) --> -(1-X)^(-2)*V_Z (FFF)
A%E=-A%E

! MUTE A LOGTERM
A%LN=0

! ADD RANDOM NOISE IF THE NOISE OPTION IS ON
IF(QPAIR%NOISE.EQ.1) THEN
  CALL ALLOCATE(B)
  B=A
  CALL NOISE(A,0.02_P8)
  CALL TOFP(A)
  CALL TOFP(B)
  CALL FLATTEN(A,B)
  CALL TOFF(A)
  CALL DEALLOCATE(B)
ENDIF

! -(1-X)^(-2)*V_Z (FFF) -> DELSQH^(-1)(-V_Z) = CHI0 (FFF)
! NOTE: IDELSQH = ((1-X)^(-2) DELSQH)^(-1) = DELSQH^(-1)*((1-X)^(-2))^(-1)
! CREATES INVERSE HORIZONTAL DEL-SQUARE OPERATOR WITH EXTRA (1-X)^2
! B NOW HAS A LOG TERM ASSOCIATED WITH THE R-DERIVATIVE 
! IN THE INVERSE DEL SQ.
CALL ALLOCATE(B)
CALL IDELSQH(A,B)

CALL MSAVE(B, TRIM(ADJUSTL(FILES%SAVEDIR))//FILES%CHI0)

CALL DEALLOCATE(A)
CALL DEALLOCATE(B)


CALL MPI_BARRIER(MPI_COMM_IVP,IERR)
IF (MPI_RANK.EQ.0) THEN
  !WRITE OUT THE 3D MATRIX IN THE SCALAR USING UNFORMATTED MODE
  WRITE(*,*) ''
  WRITE(*,*) 'PROGRAM FINISHED'
  CALL PRINT_REAL_TIME()  ! @ MOD_MISC
ENDIF

  ! ! DEBUG:
  ! CALL MLOAD(TRIM(ADJUSTL(FILES%SAVEDIR))//FILES%CHI0, B)
  ! ALLOCATE(GLOBAL_ARRAYS(NRCHOPDIM,NTCHOPDIM,NXCHOPDIM))
  ! CALL MASSEMBLE(B%E, GLOBAL_ARRAYS, 1)
  ! IF (MPI_RANK.EQ.0) THEN
  ! CALL MCAT(GLOBAL_ARRAYS(:,1,7))
  ! WRITE(*,*) NRCHOPDIM
  ! WRITE(*,*) NTCHOPDIM
  ! WRITE(*,*) NXCHOPDIM
  ! endif

CALL MPI_FINALIZE(IERR)

!=======================================================================
!=================== PROGRAM-DEPENDENT SUBROUTINES =====================
!=======================================================================
!       SUBROUTINE COLLOC_INFO() ! MOVED TO MOD_DIAGNOSTICS
! ======================================================================
contains

subroutine rtran_test(AA)

IMPLICIT NONE
TYPE(SCALAR),INTENT(INOUT):: AA

TYPE(SCALAR):: BB
COMPLEX(P8),DIMENSION(:,:),ALLOCATABLE:: BE,BO
INTEGER:: NN,IIII,MM
INTEGER:: XSIZE, THSIZE
COMPLEX(P8),DIMENSION(:,:,:),ALLOCATABLE:: GLOBAL_ARRAY
COMPLEX(P8),DIMENSION(:,:),ALLOCATABLE:: BBE


XSIZE = SIZE(A%E,3)
THSIZE = SIZE(A%E,2)

CALL ALLOCATE(BB,FFF_SPACE)
CALL CHOPDO(BB)

ALLOCATE( BE(NRH,XSIZE) )
ALLOCATE( BO(NRH,XSIZE) )
ALLOCATE( BBE(SIZE(BB%E,1),XSIZE) )

IF (MPI_RANK.EQ.0) THEN
  WRITE(*,*) 'TFM%W(1:NRH)'
  CALL MCAT(TFM%W(1:NRH))
  ! WRITE(*,*) 'TFM%PF(:NRH,1:NN,1)'
  ! CALL MCAT(TFM%PF(:NRH,1:NRCHOPS(1),1))
  WRITE(*,*) NRH,NRCHOPS(1)
ENDIF

! CALL save_glb(CMPLX(TFM%PF(1:NRH,1:NRCHOPS(1),1:1)),"PF_GLB_FFF")

!$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(NN,BE,BO,MM,IIII)
  DO MM=1, THSIZE !NTCHOP

      DO IIII=1,NRH
      ! BE(IIII,:NXCHOP) = (AA%E(IIII,MM,:NXCHOP)+AA%E(NR-IIII+1,MM,:NXCHOP))&
      !                 *TFM%W(IIII)
      ! BO(IIII,:NXCHOP) = (AA%E(IIII,MM,:NXCHOP)-AA%E(NR-IIII+1,MM,:NXCHOP))&
      !                 *TFM%W(IIII)

      ! IF(NXCHOP .NE. 1) THEN
      !     BE(IIII,NXCHOP+1:) = (AA%E(IIII,MM,NXCHOPH:NX)+AA%E(NR-IIII+1,MM,&
      !                         NXCHOPH:NX))*TFM%W(IIII)  
      !     BO(IIII,NXCHOP+1:) = (AA%E(IIII,MM,NXCHOPH:NX)-AA%E(NR-IIII+1,MM,&
      !                         NXCHOPH:NX))*TFM%W(IIII)
      ! ENDIF

          ! AA%E: NDIMR, NTCHOPDIM/N2, NXCHOPDIM/N1
          BE(IIII,:) = (AA%E(IIII,MM,:)+AA%E(NR-IIII+1,MM,:))*TFM%W(IIII)
          BO(IIII,:) = (AA%E(IIII,MM,:)-AA%E(NR-IIII+1,MM,:))*TFM%W(IIII)

      ENDDO

      ! NN = NRCHOPS(MM+AA%INTH)
      NN = NRCHOPS(MM+BB%INTH)
      BBE = 0.D0

      ! TFM%PF(RadialCollocPts, RadialModes, AzimuthalModes)
      IF(NN.GE.1) THEN
      ! BB%E(1:NN:2,MM,:)=TRANSPOSE(TFM%PF(:NRH,1:NN:2,MM+AA%INTH)) .MUL. BE
      BB%E(1:NN:2,MM,:)=TRANSPOSE(TFM%PF(:NRH,1:NN:2,MM+BB%INTH)) .MUL. BE
      BBE(1:NN:2,:)=TRANSPOSE(TFM%PF(:NRH,1:NN:2,MM+BB%INTH)) .MUL. BE(:NRH,:)
      ENDIF
      
      IF (NN.GE.2) THEN
      ! BB%E(2:NN:2,MM,:)=TRANSPOSE(TFM%PF(:NRH,2:NN:2,MM+AA%INTH)) .MUL. BO
      BB%E(2:NN:2,MM,:)=TRANSPOSE(TFM%PF(:NRH,2:NN:2,MM+BB%INTH)) .MUL. BO
      BBE(2:NN:2,:)=TRANSPOSE(TFM%PF(:NRH,2:NN:2,MM+BB%INTH)) .MUL. BO(:NRH,:)
      ENDIF

      IF ((MM+AA%INTH.EQ.1).and.(AA%INX.EQ.0)) THEN
        WRITE(*,*) 'NN = ',NN
        WRITE(*,*) 'BE(:,1)'
        CALL MCAT(BE(:,1))
        WRITE(*,*) 'BO(:,1)'
        CALL MCAT(BO(:,1))
        WRITE(*,*) 'TRANSPOSE(TFM%PF(:NRH,NN-1,MM+BB%INTH)) .MUL. BE'
        CALL MCAT(TRANSPOSE(TFM%PF(:NRH,1:NN:2,MM+BB%INTH)) .MUL. BE(:,1:1))
        WRITE(*,*) 'TRANSPOSE(TFM%PF(:NRH,NN,MM+BB%INTH)) .MUL. BO'
        CALL MCAT(TRANSPOSE(TFM%PF(:NRH,NN-14:NN,MM+BB%INTH)) .MUL. BO(:,1:1))
        ! CALL MCAT(TRANSPOSE(TFM%PF(:NRH,2:NN:2,MM+BB%INTH)) .MUL. BO(:,:))
        WRITE(*,*) 'BBE(:,1)'
        ! CALL MCAT(BBE(:,1))
        WRITE(*,*) 'BB(:,1,1)'
        ! CALL MCAT(BB%E(:,1,1))
      ENDIF

  ENDDO
!$OMP END PARALLEL DO

! allocate(GLOBAL_ARRAY(NRCHOPDIM,NTCHOPDIM,NXCHOPDIM))
! CALL MASSEMBLE(BB%E,GLOBAL_ARRAY,1);
! CALL save_glb(GLOBAL_ARRAY,"BB_GLB_FFF")
! if (MPI_RANK.eq.0) write(*,*) size(GLOBAL_ARRAY,1),size(GLOBAL_ARRAY,2),size(GLOBAL_ARRAY,3)
! deallocate(GLOBAL_ARRAY)

CALL DEALLOCATE(AA)

AA%E => BB%E
AA%INR = BB%INR
AA%INTH = BB%INTH
AA%INX = BB%INX
NULLIFY(BB%E)
AA%SPACE=FFF_SPACE

DEALLOCATE( BE,BO )
DEALLOCATE( BBE)

CALL CHOPDO(AA)
end subroutine rtran_test

subroutine save_glb(GLB_DATA,FILENAME)
! ======================================================================
COMPLEX(P8),DIMENSION(:,:,:):: GLB_DATA
character(*):: FILENAME
INTEGER:: IM,IK

if (MPI_RANK.eq.0) then
  open(UNIT=777,FILE='./test2X/'//ADJUSTL(TRIM(FILENAME))//'.dat',&
  &STATUS='UNKNOWN',ACTION='WRITE')

  DO IM = 1,SIZE(GLB_DATA,2)
      DO IK = 1,SIZE(GLB_DATA,3)
        WRITE(777,256) GLB_DATA(:,IM,IK)
      ENDDO
  ENDDO

  close(777)
endif

call mpi_barrier(MPI_COMM_IVP,IERR)
256 FORMAT((S,E24.16E3,SP,E24.16E3,'i'),*(',',S,E24.16E3,SP,E24.16E3,'i'))

end subroutine save_glb
! ======================================================================

!=======================================================================
END PROGRAM INIT
!=======================================================================
