
   module fmvals_parallel
      private aint, ceiling, digits, epsilon, huge, log, max, min, sqrt


!     Version 1.4                        David M. Smith                            2023-12-20

!  This is the thread-safe version of FM.  It can be used with a program that uses coarrays,
!  which is the Fortran-standard way of parallel programming.  It should also be ok to use
!  with other ways of parallel programming (openMP, MPI, etc.).

!  The parallel versions of 4 files from the standard version of FM (fmsave.f95, fm.f95,
!  fmzm90.f95, and FM_Sample_Routines.f95) are included in this one file (FM_parallel.f95)
!  for the parallel version.

!  Because of restrictions imposed by the need to be thread-safe, this version of FM has
!  several limitations compared to the regular version of FM.

!  1.  Global variables defined in modules are not thread-safe if they can be changed
!      while the program runs.  This means the user sets the FM precision level by
!      defining variable fm_significant_digits here in module fmvals_parallel, then
!      compiles this file and links it to their program.  Calling fm_set to set the
!      precision is not available.

!  2.  type(im) integer multi-precision numbers have varying numbers of digits that are
!      indirectly limited by fm_significant_digits.  If type(im) values become too large,
!      in intermediate or final results, the multiple threads may run out of stack space
!      and cause the program to crash.

!  3.  If a user program wants different values for other FM options like rounding mode,
!      screen width for FM output, etc., they must be initialized here in this module
!      and not changed while the program runs.

!  4.  Similarly, FM precision level cannot be changed by the user's program while
!      it runs.

!  5.  The fm_random_number random number generator cannot be used, since it depends
!      on a global saved state to get the next number.

!  6.  Because multi-precision variables are no longer stored in a global module
!      database, the fm_deallocate function is not needed and has been removed.
!      Similarly, the fm_(enter or exit)_user_(function or routine) calls are not
!      needed and those routines have been removed.

!  7.  Saved values like pi, e, euler gamma, etc., are global variables in the standard
!      version of FM.  They have been removed from this thread-safe version, so they are
!      re-computed each time they are needed.  That makes some functions like trig and
!      log/exponential functions slightly slower.

!  8.  The global allocatable database from version 1.3 has been replaced with local fixed-size
!      arrays for the multiple precision numbers.  A few routines like fm_fprime and zm_fprime
!      that relied on raising precision a lot to overcome unstable formulas may now return unknown.
!      Up to 4th or 5th derivatives should usually be ok, but higher derivatives may fail.

!  9.  There are several arrays whose size is proportional to fm_significant_digits that
!      are needed in each thread.  A program can run out of stack space and fail if
!      fm_significant_digits is set too high.


      integer, parameter :: fm_significant_digits = 50

!  Default settings for other FM options:
!  mbase is set to a power of 10, 10**7 for machines with 64-bit double precision.
!  The trace option is set off.
!  The mode for angles in trig functions is set to radians.
!  The rounding mode is set to symmetric rounding (to nearest).
!  Warning error message level is set to 1.
!  Screen width for output is set to 100 columns.
!  The exponent character for FM output is set to 'M'.
!  Debug error checking is set off.
!  kw, the unit number for all FM output, is set to 6.



      real (kind(1.0d0)), parameter :: m_two = 2
      double precision, parameter :: dp_two = 2
      integer, parameter :: i_two = 2
      real, parameter :: r_two = 2

      real (kind(1.0d0)), parameter :: max_representable_m_var =  &
                            ( (m_two ** (min(digits(m_two),digits(dp_two))-1)) - 1 ) * 2 + 1

      real (kind(1.0d0)), parameter :: maxint = max_representable_m_var

      integer, parameter :: intmax = huge(i_two)

      double precision, parameter :: dpmax = huge(dp_two)/5

      real, parameter :: spmax = huge(r_two)/5

      real (kind(1.0d0)), parameter :: max_base = aint(sqrt(max_representable_m_var + 1.0d-9))

      real (kind(1.0d0)), parameter :: mxbase = max_base

      real (kind(1.0d0)), parameter :: m_ten = 10

      real (kind(1.0d0)), parameter :: max_exponent = aint( min(                                  &
                                       max(huge(intmax) / log(max_base+1.0d-9) , 117496405.0d0),  &
                                       max_representable_m_var / 20.0d0) )

      integer, parameter :: lhash1 =   0
      integer, parameter :: lhash2 = 256

      integer, parameter :: ljsums = 100

      integer, parameter :: lmbern = 600

      integer, parameter :: ndig_user = ceiling( (fm_significant_digits+2) /  &
                                                  aint(log(max_base/4.0d0)/log(10.0d0)) ) + 1

      integer, parameter :: lmbuff = max(25*fm_significant_digits+50,550)
      integer, parameter :: lmbufz = max(50*fm_significant_digits+50,1000)

      type multi
         real (kind(1.0d0)), allocatable :: mp(:)
      end type

      type fm
         type(multi) :: mfm
      end type

      type im
         type(multi) :: mim
      end type

      type zm
         type(multi) :: mzm(2)
      end type

      type fm_settings
         integer :: ndig = ndig_user
         integer :: kflag = 0
         integer :: kw = 6
         integer :: ntrace = 0
         integer :: lvltrc = 1
         integer :: ncall = 0
         real (kind(1.0d0)) :: mbase = m_ten ** aint(log(max_base/4.0d0) / log(10.0d0))
         integer :: raise_ndig = 0
         character(9) :: namest(0:50)
         integer :: ndigpi = 0
         real (kind(1.0d0)) :: mbspi = 0
         integer :: ndige = 0
         real (kind(1.0d0)) :: mbse = 0
         integer :: ndiglb = 0
         real (kind(1.0d0)) :: mbslb = 0
         integer :: ndigli = 0
         real (kind(1.0d0)) :: mbsli = 0
         integer :: ndgeul = 0
         real (kind(1.0d0)) :: mbseul = 0
         integer :: ndggam = 0
         real (kind(1.0d0)) :: mbsgam = 0
         integer :: ndg2pi = 0
         real (kind(1.0d0)) :: mbs2pi = 0
         integer :: numbrn = 0
         real (kind(1.0d0)) :: mbsbrn = 0
         real (kind(1.0d0)) :: mxexp = aint( max_exponent / 2.01d0 + 0.5d0 )
         real (kind(1.0d0)) :: mxexp0 = aint( max_exponent / 2.01d0 + 0.5d0 )
         real (kind(1.0d0)) :: mxexp2 = max_exponent
         real (kind(1.0d0)) :: mexpun = aint( -max_exponent * 1.01d0 )
         real (kind(1.0d0)) :: mexpov = aint( max_exponent * 1.01d0 )
         real (kind(1.0d0)) :: munkno = aint( max_exponent * 1.0201d0 )
         real :: runkno = -1.01*(huge(r_two)/3.0)
         integer :: iunkno = -huge(i_two)/18
         integer :: jform1 = 1
         integer :: jform2 = fm_significant_digits
         integer :: krad = 1
         integer :: kwarn = 0
         integer :: kround = 1
         integer :: kround1 = 1
         integer :: kswide = 100
         integer :: keswch = 1
         character :: cmchar = 'M'
         integer :: kdebug = 0
         integer :: kround_retry = 0
         integer :: ksub = 0
         integer :: ksqr = 0
         integer :: krem = 1
         integer :: jrsign = 0
         integer :: lhash = 0
         integer :: khasht(lhash1:lhash2)
         integer :: khashv(lhash1:lhash2)
         integer :: k_stat = 0
         double precision :: dpeps = epsilon(dp_two)
         integer :: in_fact = 0
         real (kind(1.0d0)) :: mblogs = 0
         real :: alogmb = 1.611810e+1
         real :: alogm2 = 2.325350e+1
         real :: alogmx = 3.673680e+1
         real :: alogmt = 7.0e0
         integer :: ngrd21 = 1
         integer :: ngrd52 = 2
         integer :: ngrd22 = 2
         real (kind(1.0d0)) :: mexpab = aint(max_exponent / 5.0d0)
         double precision :: dlogmb = 1.611809565095832d+1
         double precision :: dlogtn = 2.302585092994046d+0
         double precision :: dlogtw = 6.931471805599453d-1
         double precision :: dppi   = 3.141592653589793d+0
         double precision :: dlogtp = 1.837877066409345d+0
         double precision :: dlogpi = 1.144729885849400d+0
         double precision :: dlogeb = 2.236222824932432d+0
         real (kind(1.0d0)) :: mbasel = 0
         real (kind(1.0d0)) :: mbasen = 0
         integer :: ndigl = 0
         integer :: ndign = 0
         integer :: nguarl = 0
         integer :: n21
         integer :: ngrdn
         integer :: jformz = 1
         integer :: jprntz = 1
         type(multi) :: mwa
         type(multi) :: mwd
         type(multi) :: mwe
         type(multi) :: mwi
      end type

   end module fmvals_parallel


      subroutine fmset(nprec, qx)

!  The user cannot change FM settings in the thread-safe version.

      use fmvals_parallel
      implicit none

      integer :: nprec
      intent (in) :: nprec
      type(fm_settings) :: qx

      write (*,"(//a)")  ' The user cannot change FM settings in the thread-safe version.'
      if (nprec >= -31 .or. qx%mbase > -31) then
          write (*,"(/a//)") ' See the comments at the top of file FM_parallel.f95'
      endif
      stop

      end subroutine fmset

      subroutine fmndig(nd, qx)

!  Most of the routines in FM raise precision above the user's level to deal with cancellation
!  error and deliver correctly rounded results.

!  This routine raises the internal value of ndig.

      use fmvals_parallel
      implicit none

      integer :: nd
      intent (in) :: nd
      type(fm_settings) :: qx

      qx%ndig = nd

      end subroutine fmndig

      subroutine fmabs(ma, mb, qx)

!  mb = abs(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      integer :: kwrnsv

      call fmalloc(mb, qx%ndig+2, qx)

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMABS'
      call fmntr_inp1(ma, qx)

      qx%kflag = 0
      kwrnsv = qx%kwarn
      qx%kwarn = 0
      call fmeq(ma, mb, qx)
      mb%mp(1) = 1
      qx%kwarn = kwrnsv
      call fmntr_out1(mb, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmabs

      subroutine fmacos(ma, mb, qx)

!  mb = acos(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(5), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmacos_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmacos_m1(ma, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmacos

      subroutine fmacos_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing acos(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: krndsave

      krndsave = qx%kround
      qx%kround = 1
      call fmequ(ma, mresult, ndsave, qx%ndig, qx)

!             Use acos(x) = atan(sqrt(1-x*x)/x)

      mresult%mp(1) = 1
      call fmi2m(1, mxy(4), qx)
      call fmsub(mxy(4), mresult, mxy(2), qx)
      call fmadd(mxy(4), mresult, mxy(3), qx)
      call fmmpy_r2(mxy(2), mxy(3), qx)
      call fmsqrt_r1(mxy(3), qx)
      call fmdiv(mxy(3), mresult, mxy(5), qx)
      call fmatan(mxy(5), mresult, qx)

      if (ma%mp(1) < 0) then
          if (qx%krad == 1) then
              call fmpi(mxy(4), qx)
              qx%ndigpi = 0
          else
              call fmi2m(180, mxy(4), qx)
          endif
          call fmsub_r2(mxy(4), mresult, qx)
      endif

      qx%kround = krndsave

      return
      end subroutine fmacos_m1

      subroutine fmacos_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = acos(ma).

!  kresult = 1 is returned if a special case gives the value of acos(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      double precision :: xe
      logical, external :: fmcomp

      kresult = 0

      qx%namest(qx%ncall) = 'FMACOS   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, mxy(5), ndsave, qx%ndig, qx)
      call fmovun_xe(mxy(5), xe, qx)
      if (mxy(5)%mp(2) == qx%munkno .and. mxy(5)%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif
      if (mxy(5)%mp(3) == 0) then
          if (qx%krad == 0) then
              call fmi2m(90, mresult, qx)
          else
              call fmpi(mxy(2), qx)
              qx%ndigpi = 0
              call fmdivi(mxy(2), 2, mresult, qx)
          endif
          kresult = 1
          return
      endif
      call fmabs(mxy(5), mxy(1), qx)
      call fmi2m(1, mxy(2), qx)
      if (fmcomp(mxy(1), '==', mxy(2), qx)) then
          if (mxy(5)%mp(1) < 0) then
              if (qx%krad == 0) then
                  call fmi2m(180, mresult, qx)
              else
                  call fmpi(mresult, qx)
                  qx%ndigpi = 0
              endif
          else
              call fmi2m(0, mresult, qx)
          endif
          kresult = 1
          return
      endif
      if (xe >= 1) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      call fmequ(ma, mresult, ndsave, qx%ndig, qx)
      if (qx%kround /= 1 .and. qx%krad /= 1) then
          call fmst2m('0.5', mxy(1), qx)
          call fmsub(mresult, mxy(1), mxy(2), qx)
          if (mxy(2)%mp(3) == 0) then
              call fmst2m('60', mresult, qx)
              return
          endif
          call fmadd(mresult, mxy(1), mxy(2), qx)
          if (mxy(2)%mp(3) == 0) then
              call fmst2m('120', mresult, qx)
              return
          endif
      endif
      if (qx%kround /= 1 .and. xe < -ndsave) then
          if (qx%krad == 0) then
              call fmi2m(180, mxy(1), qx)
              call fmpi(mxy(2), qx)
              qx%ndigpi = 0
              call fmdiv(mxy(1), mxy(2), mxy(3), qx)
              call fmmpy(mxy(3), mxy(5), mxy(2), qx)
              call fmi2m(90, mxy(1), qx)
              call fmsub(mxy(1), mxy(2), mresult, qx)
          else
              call fmndig(qx%ndig + qx%ngrd22, qx)
              call fmequ(mxy(5), mxy(1), qx%ndig-qx%ngrd22, qx%ndig, qx)
              call fmpi(mxy(2), qx)
              qx%ndigpi = 0
              call fmdivi_r1(mxy(2), 2, qx)
              call fmsub(mxy(2), mxy(1), mresult, qx)
              call fmndig(qx%ndig - qx%ngrd22, qx)
              call fmequ_r1(mresult, qx%ndig+qx%ngrd22, qx%ndig, qx)
          endif
          if (qx%kflag > 0) qx%kflag = 0
          kresult = 1
          return
      endif
      if (mxy(5)%mp(2) == qx%mexpun .or. mxy(5)%mp(2) == qx%munkno) then
          if (xe < -ndsave .and. mxy(5)%mp(5) < 0) then
              if (qx%krad == 1) then
                  call fmpi(mxy(1), qx)
                  qx%ndigpi = 0
                  call fmdivi(mxy(1), 2, mresult, qx)
              else
                  call fmi2m(90, mresult, qx)
              endif
              kresult = 1
              return
          endif
      endif

      return
      end subroutine fmacos_sc

      subroutine fmacosh(ma, mb, qx)

!  mb = acosh(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(3), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmacosh_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmacosh_m1(ma, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmacosh

      subroutine fmacosh_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing acosh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(3), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: iextra, krndsave
      double precision :: xe

      krndsave = qx%kround
      qx%kround = 1
      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

      call fmovun_xe(ma, xe, qx)
      if (xe <= 0 .or. mxy(1)%mp(1) < 0) then
          call fmunknown(mresult, qx)
      else if (4.0*(xe-1) > qx%ndig) then
          call fmmpyi(mxy(1), 2, mresult, qx)
          if (mresult%mp(2) == qx%mexpov) then
              call fmln(mxy(1), mresult, qx)
              qx%ndigli = 0
              call fmlni(2, mxy(2), qx)
              qx%ndigli = 0
              call fmadd_r1(mresult, mxy(2), qx)
          else
              call fmi2m(1, mxy(2), qx)
              call fmsqr(mresult, mxy(3), qx)
              call fmdiv_r2(mxy(2), mxy(3), qx)
              call fmln(mresult, mxy(2), qx)
              qx%ndigli = 0
              call fmsub(mxy(2), mxy(3), mresult, qx)
          endif
      else
          iextra = mxy(1)%mp(2)
          if (abs(mxy(1)%mp(2)) >= qx%mexpov) iextra = 0
          if (iextra > 0) then
              call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
              call fmndig(qx%ndig + iextra, qx)
          endif
          call fmi2m(1, mresult, qx)
          call fmsub(mxy(1), mresult, mxy(2), qx)
          call fmadd(mxy(1), mresult, mxy(3), qx)
          call fmmpy_r1(mxy(2), mxy(3), qx)
          call fmsqrt_r1(mxy(2), qx)
          call fmdiv_r1(mxy(2), mxy(1), qx)
          call fmatanh(mxy(2), mresult, qx)
      endif

      qx%kround = krndsave

      return
      end subroutine fmacosh_m1

      subroutine fmacosh_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = acosh(ma).

!  kresult = 1 is returned if a special case gives the value of acosh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(3), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j

      kresult = 0

      qx%namest(qx%ncall) = 'FMACOSH  '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

      if (mxy(1)%mp(2) == qx%munkno .and. mxy(1)%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine fmacosh_sc

      subroutine fmadd(ma, mb, mc, qx)

!  mc = ma + mb

!  This routine performs the trace printing for addition.  fmadd2 is used to do the arithmetic.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: kovun


      qx%ncall = qx%ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == qx%mexpov .or. abs(mb%mp(2)) == qx%mexpov) kovun = 1
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) kovun = 2
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMADD'
          call fmntr_inp2(ma, mb, qx)
      endif

      call fmadd2(ma, mb, mc, qx)

      if ((abs(mc%mp(2)) == qx%mexpov .and. kovun == 0) .or.  &
          (abs(mc%mp(2)) == qx%munkno .and. kovun < 2)) then
          qx%namest(qx%ncall) = 'FMADD'
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) then
          call fmntr_out1(mc, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmadd

      subroutine fmadd2(ma, mb, mc, qx)

!  Internal addition routine.  mc = ma + mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      logical :: retry
      integer :: jsign, kresult

      call fmalloc(mc, qx%ndig+2, qx)
      call fmalloc(qx%mwa, 2*qx%ndig+30, qx)
      call fmadd_sc(ma, mb, mc, kresult, qx)
      if (kresult > 0) then
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      qx%kround_retry = 0
      jsign = 1
      retry = .true.
      do while (retry)
         retry = .false.
         call fmadd_m1(ma, mb, jsign, retry, qx)
      enddo

!             Transfer to mc and fix the sign of the result.

      call fmmove(qx%mwa, mc, qx)
      mc%mp(1) = 1
      if (jsign < 0 .and. mc%mp(3) /= 0) mc%mp(1) = -1

      qx%kround_retry = 0

      return
      end subroutine fmadd2

      subroutine fmadd2_r1(ma, mb, qx)

!  Internal addition routine.  ma = ma + mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: mb
      intent (inout) :: ma
      type(fm_settings) :: qx

      logical :: retry
      integer :: jsign, kresult
      type(multi) :: mxy

      call fmalloc(qx%mwa, 2*qx%ndig+30, qx)
      call fmadd_sc(ma, mb, mxy, kresult, qx)
      if (kresult > 0) then
          call fmeq(mxy, ma, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      qx%kround_retry = 0
      jsign = 1
      retry = .true.
      do while (retry)
         retry = .false.
         call fmadd_m1(ma, mb, jsign, retry, qx)
      enddo

!             Transfer to ma and fix the sign of the result.

      call fmmove(qx%mwa, ma, qx)
      ma%mp(1) = 1
      if (jsign < 0 .and. ma%mp(3) /= 0) ma%mp(1) = -1

      qx%kround_retry = 0

      return
      end subroutine fmadd2_r1

      subroutine fmadd2_r2(ma, mb, qx)

!  Internal addition routine.  mb = ma + mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      logical :: retry
      integer :: jsign, kresult
      type(multi) :: mxy

      call fmalloc(qx%mwa, 2*qx%ndig+30, qx)
      call fmadd_sc(ma, mb, mxy, kresult, qx)
      if (kresult > 0) then
          call fmeq(mxy, mb, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      qx%kround_retry = 0
      jsign = 1
      retry = .true.
      do while (retry)
         retry = .false.
         call fmadd_m1(ma, mb, jsign, retry, qx)
      enddo

!             Transfer to mb and fix the sign of the result.

      call fmmove(qx%mwa, mb, qx)
      mb%mp(1) = 1
      if (jsign < 0 .and. mb%mp(3) /= 0) mb%mp(1) = -1

      qx%kround_retry = 0

      return
      end subroutine fmadd2_r2

      subroutine fmadd_m1(ma, mb, jsign, retry, qx)

!  Internal routine for computing mwa = ma + mb.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: jsign
      logical :: retry
      intent (in) :: ma, mb
      intent (inout) :: jsign, retry
      type(fm_settings) :: qx

      integer :: j, jcomp, nguard
      real (kind(1.0d0)) :: mbs

      qx%kflag = 0

!             nguard is the number of guard digits used.

      if (qx%ncall > 1) then
          nguard = qx%ngrd21
          if (nguard > qx%ndig) nguard = qx%ndig + 1
      else
          nguard = qx%ngrd52
          if (nguard > qx%ndig) nguard = qx%ndig + 1
      endif
      if (qx%kround_retry >= 1) then
          nguard = qx%ndig + 1
      endif

!             jsign is the sign of the result of ma + mb.

      jsign = 1
      mbs = mb%mp(1)
      if (qx%ksub == 1) mbs = -mbs

!             See which one is larger in absolute value.

      jcomp = 2
      if (ma%mp(2) > mb%mp(2)) then
          jcomp = 1
      else if (mb%mp(2) > ma%mp(2)) then
          jcomp = 3
      else
          do j = 3, qx%ndig+2
             if (ma%mp(j) > mb%mp(j)) then
                 jcomp = 1
                 exit
             endif
             if (mb%mp(j) > ma%mp(j)) then
                 jcomp = 3
                 exit
             endif
          enddo
      endif

      if (jcomp < 3) then
          if (ma%mp(1) < 0) jsign = -1
          qx%jrsign = jsign
          if (ma%mp(1)*mbs > 0) then
              call fmaddp(ma, mb, nguard, qx)
          else
              call fmaddn(ma, mb, nguard, qx)
          endif
      else
          if (mbs < 0) jsign = -1
          qx%jrsign = jsign
          if (ma%mp(1)*mbs > 0) then
              call fmaddp(mb, ma, nguard, qx)
          else
              call fmaddn(mb, ma, nguard, qx)
          endif
      endif

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      if (qx%kround_retry == 1 .and. nguard < qx%ndig) then
          qx%kround_retry = 2
          retry = .true.
          return
      endif

      return
      end subroutine fmadd_m1

      subroutine fmadd_r1(ma, mb, qx)

!  ma = ma + mb

!  This routine performs the trace printing for addition.  fmadd2_r1 is used to do the arithmetic.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb
      type(fm_settings) :: qx

      integer :: kovun

      qx%ncall = qx%ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == qx%mexpov .or. abs(mb%mp(2)) == qx%mexpov) kovun = 1
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) kovun = 2
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMADD_R1'
          call fmntr_inp2(ma, mb, qx)
      endif

      call fmadd2_r1(ma, mb, qx)

      if ((abs(ma%mp(2)) == qx%mexpov .and. kovun == 0) .or.  &
          (abs(ma%mp(2)) == qx%munkno .and. kovun < 2)) then
          qx%namest(qx%ncall) = 'FMADD_R1'
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) then
          call fmntr_out1(ma, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmadd_r1

      subroutine fmadd_r2(ma, mb, qx)

!  mb = ma + mb

!  This routine performs the trace printing for addition.  fmadd2_r2 is used to do the arithmetic.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      integer :: kovun

      qx%ncall = qx%ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == qx%mexpov .or. abs(mb%mp(2)) == qx%mexpov) kovun = 1
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) kovun = 2
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMADD_R2'
          call fmntr_inp2(ma, mb, qx)
      endif

      call fmadd2_r2(ma, mb, qx)

      if ((abs(mb%mp(2)) == qx%mexpov .and. kovun == 0) .or.  &
          (abs(mb%mp(2)) == qx%munkno .and. kovun < 2)) then
          qx%namest(qx%ncall) = 'FMADD_R2'
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) then
          call fmntr_out1(mb, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmadd_r2

      subroutine fmadd_sc(ma, mb, mc, kresult, qx)

!  Check for special cases for mc = ma + mb.

!  kresult = 1 is returned if a special case gives the value of mc.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      integer :: kresult
      intent (in) :: ma, mb
      intent (inout) :: mc, kresult
      type(fm_settings) :: qx

      integer :: jrssav

      kresult = 0
      jrssav = qx%jrsign
      if ((ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == qx%munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc, qx)
          kresult = 1
          return
      endif
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) then
          if (qx%ksub == 0) then
              call fmovun_add(ma, mb, mc, qx)
          else
              call fmovun_sub(ma, mb, mc, qx)
          endif
          kresult = 1
          return
      endif
      if (abs(ma%mp(2)) == qx%mexpov .or. abs(mb%mp(2)) == qx%mexpov) then
          if (qx%ksub == 0) then
              call fmovun_add(ma, mb, mc, qx)
          else
              call fmovun_sub(ma, mb, mc, qx)
          endif
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0) then
          call fmeq(mb, mc, qx)
          qx%kflag = 1
          if (qx%ksub == 1) then
              call fmnegate(mc, qx)
              qx%kflag = 0
          endif
          qx%jrsign = jrssav
          kresult = 1
          return
      endif
      if (mb%mp(3) == 0) then
          call fmeq(ma, mc, qx)
          qx%kflag = 1
          qx%jrsign = jrssav
          kresult = 1
          return
      endif
      if (mb%mp(2) <= ma%mp(2)-qx%ndig-1) then
          if (qx%kround == 1) then
              call fmeq(ma, mc, qx)
              qx%kflag = 1
              qx%jrsign = jrssav
              kresult = 1
              return
          endif
      endif
      if (ma%mp(2) <= mb%mp(2)-qx%ndig-1) then
          if (qx%kround == 1) then
              call fmeq(mb, mc, qx)
              qx%kflag = 1
              if (qx%ksub == 1) then
                  call fmnegate(mc, qx)
                  qx%kflag = 0
              endif
              qx%jrsign = jrssav
              kresult = 1
              return
          endif
      endif

      return
      end subroutine fmadd_sc

      subroutine fmaddi(ma, ival, qx)

!  ma = ma + ival

!  Increment ma by one word integer ival.

!  This routine is faster than fmadd when ival is small enough so that it can be added to a single
!  word of ma without often causing a carry.  Otherwise fmi2m and fmadd are used.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (inout) :: ma
      intent (in) :: ival
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: maexp, mksum
      integer :: j, kptma
      type(multi) :: mxy


      qx%ncall = qx%ncall + 1
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMADDI'
          call fmntr_inp1i(ma, ival, qx)
      endif
      qx%kflag = 0

      j = 0
      maexp = ma%mp(2)
      if (maexp > 0 .and. maexp <= qx%ndig) then
          kptma = int(maexp) + 2
          if (ma%mp(1) < 0) then
              mksum = ma%mp(kptma) - ival
          else
              mksum = ma%mp(kptma) + ival
          endif
          if (mksum < qx%mbase .and. mksum >= 0) then
              if (.not. (kptma == 3 .and. mksum == 0)) then
                  ma%mp(kptma) = mksum
                  j = 1
              endif
          endif
      endif

      if (j == 0) then
          call fmi2m(ival, mxy, qx)
          call fmadd2_r1(ma, mxy, qx)
      endif

      if (qx%ntrace /= 0) then
          call fmntr_out1(ma, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmaddi

      subroutine fmaddn(ma, mb, nguard, qx)

!  Internal addition routine.  mwa = ma - mb
!  The arguments are such that ma >= mb >= 0.

!  nguard is the number of guard digits being carried.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: nguard
      intent (in) :: ma, mb, nguard
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mr
      double precision :: err
      integer :: j, kl, ksh, ksh2, n2

      ksh = ma%mp(2) - mb%mp(2)
      ksh2 = ksh
      n2 = min(2+ksh, 2+qx%ndig)
      do j = 1, n2
         qx%mwa%mp(j) = ma%mp(j)
      enddo

!             Subtract.

      if (ksh < qx%ndig) then
          do j = 3+ksh, qx%ndig+2
             qx%mwa%mp(j) = ma%mp(j) - mb%mp(j-ksh)
          enddo
          if (ksh > 0) then
              n2 = min(qx%ndig+2+ksh, qx%ndig+2+nguard)
              do j = qx%ndig+3, n2
                 qx%mwa%mp(j) = -mb%mp(j-ksh)
              enddo
          endif
          if (qx%ndig+2+ksh < qx%ndig+2+nguard) then
              do j = qx%ndig+3+ksh, qx%ndig+2+nguard
                 qx%mwa%mp(j) = 0
              enddo
          endif
      else if (ksh > qx%ndig) then
          if (qx%kround == 1) then
              qx%mwa%mp(qx%ndig+3) = 0
              qx%kflag = 1
              return
          endif
          n2 = min(2+ksh, qx%ndig+2+nguard)
          do j = qx%ndig+3, n2
             qx%mwa%mp(j) = 0
          enddo
          if (3+ksh <= qx%ndig+2+nguard) then
              n2 = min(qx%ndig+2+ksh, qx%ndig+2+nguard)
              do j = 3+ksh, n2
                 qx%mwa%mp(j) = -mb%mp(j-ksh)
              enddo
          endif
          if (qx%ndig+2+ksh < qx%ndig+2+nguard) then
              do j = qx%ndig+2+ksh, qx%ndig+2+nguard
                 qx%mwa%mp(j) = 0
              enddo
          endif
          if (ksh > qx%ndig+3) then
              qx%mwa%mp(qx%ndig+3) = 0
              qx%mwa%mp(qx%ndig+4) = -1
              ksh2 = qx%ndig + 1
          endif
          qx%kflag = 1
      else if (ksh == qx%ndig) then
          n2 = min(qx%ndig+2+ksh, qx%ndig+2+nguard)
          do j = qx%ndig+3, n2
             qx%mwa%mp(j) = -mb%mp(j-ksh)
          enddo
          if (n2 < qx%ndig+2+nguard) then
              do j = n2+1, qx%ndig+2+nguard
                 qx%mwa%mp(j) = 0
              enddo
          endif
      endif

!             Normalize.  Fix the sign of any negative digit.

      do j = qx%ndig+2+nguard, 4, -1
         if (qx%mwa%mp(j) < 0) then
             qx%mwa%mp(j) = qx%mwa%mp(j) + qx%mbase
             qx%mwa%mp(j-1) = qx%mwa%mp(j-1) - 1
         else if (j <= 3+ksh2) then
             exit
         endif
      enddo

!             Shift left if there are any leading zeros in the mantissa.

      ksh = qx%ndig
      do j = 3, qx%ndig+2
         if (qx%mwa%mp(j) > 0) then
             ksh = j - 3
             exit
         endif
      enddo
      if (ksh == qx%ndig+1) then
          qx%mwa%mp(2) = 0
          return
      endif

      if (ksh > 0) then
          kl = qx%ndig + 2 + nguard - ksh
          do j = 3, kl
             qx%mwa%mp(j) = qx%mwa%mp(j+ksh)
          enddo
          do j = kl+1, qx%ndig+2+nguard
             qx%mwa%mp(j) = 0
          enddo
          qx%mwa%mp(2) = qx%mwa%mp(2) - ksh
      endif

!             Round the result.

      if (qx%ncall >= 1) then
          kl = min(nguard, int(3*qx%dlogtn/qx%dlogmb + 2.5))
          err = 0
          do j = kl, 1, -1
             err = (err + qx%mwa%mp(j+qx%ndig+2)) / qx%mbase
          enddo
          if ( (qx%kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
               (qx%kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) qx%kround_retry = qx%kround_retry + 1
      endif
      mr = 2*qx%mwa%mp(qx%ndig+3) + 1
      if (qx%kround == -1 .or. qx%kround == 2) then
          call fmrnd(qx%mwa, qx%ndig, nguard, 0, qx)
      else if (mr >= qx%mbase) then
          if (mr-1 > qx%mbase .and. qx%mwa%mp(qx%ndig+2) < qx%mbase-1) then
              if (qx%kround /= 0) then
                  qx%mwa%mp(qx%ndig+2) = qx%mwa%mp(qx%ndig+2) + 1
                  qx%mwa%mp(qx%ndig+3) = 0
              endif
          else
              call fmrnd(qx%mwa, qx%ndig, nguard, 0, qx)
          endif
      endif

!             See if the result is equal to one of the input arguments.

      if (abs(ma%mp(2)-mb%mp(2)) < qx%ndig) return
      if (abs(ma%mp(2)-mb%mp(2)) > qx%ndig+1) then
          qx%kflag = 1
          return
      endif

      n2 = qx%ndig + 4
      do j = qx%ndig+2, 1, -1
         if (qx%mwa%mp(j) /= ma%mp(j)) return
      enddo
      qx%kflag = 1

      return
      end subroutine fmaddn

      subroutine fmaddp(ma, mb, nguard, qx)

!  Internal addition routine.  mwa = ma + mb
!  The arguments are such that ma >= mb >= 0.

!  nguard is the number of guard digits being carried.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: nguard
      intent (in) :: ma, mb, nguard
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mr
      double precision :: err
      integer :: j, kl, ksh, n2

      ksh = ma%mp(2) - mb%mp(2)
      n2 = min(2+ksh, 2+qx%ndig)
      do j = 1, n2
         qx%mwa%mp(j) = ma%mp(j)
      enddo

!             Add.

      if (ksh < qx%ndig) then
          do j = 3+ksh, qx%ndig+2
             qx%mwa%mp(j) = ma%mp(j) + mb%mp(j-ksh)
          enddo
          if (ksh > 0) then
              n2 = min(qx%ndig+2+ksh, qx%ndig+2+nguard)
              do j = qx%ndig+3, n2
                 qx%mwa%mp(j) = mb%mp(j-ksh)
              enddo
          endif
          if (qx%ndig+2+ksh < qx%ndig+2+nguard) then
              do j = qx%ndig+3+ksh, qx%ndig+2+nguard
                 qx%mwa%mp(j) = 0
              enddo
          endif
      else if (ksh > qx%ndig) then
          if (qx%kround == 1) then
              qx%mwa%mp(qx%ndig+3) = 0
              qx%kflag = 1
              return
          endif
          n2 = min(2+ksh, qx%ndig+2+nguard)
          do j = qx%ndig+3, n2
             qx%mwa%mp(j) = 0
          enddo
          if (3+ksh <= qx%ndig+2+nguard) then
              n2 = min(qx%ndig+2+ksh, qx%ndig+2+nguard)
              do j = 3+ksh, n2
                 qx%mwa%mp(j) = mb%mp(j-ksh)
              enddo
          endif
          if (qx%ndig+2+ksh < qx%ndig+2+nguard) then
              do j = qx%ndig+2+ksh, qx%ndig+2+nguard
                 qx%mwa%mp(j) = 0
              enddo
          endif
          if (ksh > qx%ndig+1) then
              qx%mwa%mp(qx%ndig+3) = 0
              qx%mwa%mp(qx%ndig+4) = 1
          endif
          qx%kflag = 1
      else if (ksh == qx%ndig) then
          n2 = min(qx%ndig+2+ksh, qx%ndig+2+nguard)
          do j = qx%ndig+3, n2
             qx%mwa%mp(j) = mb%mp(j-ksh)
          enddo
          if (n2 < qx%ndig+2+nguard) then
              do j = n2+1, qx%ndig+2+nguard
                 qx%mwa%mp(j) = 0
              enddo
          endif
      endif

!             Normalize any digits >= mbase.

      if (ksh < qx%ndig) then
          do j = qx%ndig+2, 4, -1
             if (qx%mwa%mp(j) >= qx%mbase) then
                 qx%mwa%mp(j) = qx%mwa%mp(j) - qx%mbase
                 qx%mwa%mp(j-1) = qx%mwa%mp(j-1) + 1
             endif
          enddo
      endif

!             If the first digit (mwa%mp(3)) is bigger than mbase, shift right one digit
!             and adjust the exponent.

      if (qx%mwa%mp(3) >= qx%mbase) then
          do j = qx%ndig+2+nguard, 4, -1
             qx%mwa%mp(j) = qx%mwa%mp(j-1)
          enddo
          qx%mwa%mp(4) = qx%mwa%mp(4) - qx%mbase
          qx%mwa%mp(3) = 1
          qx%mwa%mp(2) = qx%mwa%mp(2) + 1
      endif

!             Round the result.

      if (qx%ncall >= 1) then
          kl = min(nguard, int(3*qx%dlogtn/qx%dlogmb + 2.5))
          err = 0
          do j = kl, 1, -1
             err = (err + qx%mwa%mp(j+qx%ndig+2)) / qx%mbase
          enddo
          if ( (qx%kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
               (qx%kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) qx%kround_retry = qx%kround_retry + 1
      endif
      mr = 2*qx%mwa%mp(qx%ndig+3) + 1
      if (qx%kround == -1 .or. qx%kround == 2) then
          call fmrnd(qx%mwa, qx%ndig, nguard, 0, qx)
      else if (mr >= qx%mbase) then
          if (mr-1 > qx%mbase .and. qx%mwa%mp(qx%ndig+2) < qx%mbase-1) then
              if (qx%kround /= 0) then
                  qx%mwa%mp(qx%ndig+2) = qx%mwa%mp(qx%ndig+2) + 1
                  qx%mwa%mp(qx%ndig+3) = 0
              endif
          else
              call fmrnd(qx%mwa, qx%ndig, nguard, 0, qx)
          endif
      endif

!             See if the result is equal to one of the input arguments.

      if (abs(ma%mp(2)-mb%mp(2)) < qx%ndig) return
      if (abs(ma%mp(2)-mb%mp(2)) > qx%ndig+1) then
          qx%kflag = 1
          return
      endif

      n2 = qx%ndig + 4
      do j = qx%ndig+2, 1, -1
         if (qx%mwa%mp(j) /= ma%mp(j)) return
      enddo
      qx%kflag = 1

      return
      end subroutine fmaddp

      subroutine fmalloc(ma, n_size, qx)

!  Allocate ma with size n_size.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: n_size
      intent (in) :: n_size
      intent (inout) :: ma
      type(fm_settings) :: qx

      if (.not. allocated(ma%mp)) then
          allocate(ma%mp(max(n_size, 5)), stat=qx%k_stat)
          if (qx%k_stat /= 0) call fmdefine_error
      else if (size(ma%mp) < max(n_size, 5)) then
          deallocate(ma%mp)
          allocate(ma%mp(max(n_size, 5)), stat=qx%k_stat)
          if (qx%k_stat /= 0) call fmdefine_error
      endif
      if (qx%ndig < 3) then
          qx%kflag = -1
          call fmwarn(qx)
      endif
      if (qx%mbase < 2 .or. qx%mbase > mxbase) then
          qx%kflag = -2
          call fmwarn(qx)
      endif

      return
      end subroutine fmalloc

      subroutine fmasin(ma, mb, qx)

!  mb = asin(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(4), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmasin_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmasin_m1(ma, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmasin

      subroutine fmasin_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing asin(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: krndsave

      krndsave = qx%kround
      qx%kround = 1
      call fmequ(ma, mresult, ndsave, qx%ndig, qx)
      if (qx%kround /= 1 .and. qx%krad /= 1) then
          call fmst2m('0.5', mxy(1), qx)
          call fmsub(mresult, mxy(1), mxy(2), qx)
          if (mxy(2)%mp(3) == 0) then
              call fmst2m('30', mresult, qx)
              return
          endif
          call fmadd(mresult, mxy(1), mxy(2), qx)
          if (mxy(2)%mp(3) == 0) then
              call fmst2m('-30', mresult, qx)
              return
          endif
      endif

!             Use asin(x) = atan(x/sqrt(1-x*x))

      call fmi2m(1, mxy(3), qx)
      call fmsub(mxy(3), mresult, mxy(1), qx)
      call fmadd(mxy(3), mresult, mxy(2), qx)
      call fmmpy_r2(mxy(1), mxy(2), qx)
      call fmsqrt_r1(mxy(2), qx)
      call fmdiv(mresult, mxy(2), mxy(4), qx)
      call fmatan(mxy(4), mresult, qx)

      qx%kround = krndsave

      return
      end subroutine fmasin_m1

      subroutine fmasin_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = asin(ma).

!  kresult = 1 is returned if a special case gives the value of asin(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      double precision :: xe
      logical, external :: fmcomp

      kresult = 0

      qx%namest(qx%ncall) = 'FMASIN   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

      if (mxy(1)%mp(2) == qx%munkno .and. mxy(1)%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif
      if (mxy(1)%mp(3) == 0) then
          call fmi2m(0, mresult, qx)
          kresult = 1
          return
      endif
      call fmabs(mxy(1), mxy(3), qx)
      call fmi2m(1, mxy(2), qx)
      if (fmcomp(mxy(3), '==', mxy(2), qx)) then
          if (mxy(1)%mp(1) > 0) then
              if (qx%krad == 0) then
                  call fmi2m(90, mresult, qx)
              else
                  call fmpi(mresult, qx)
                  qx%ndigpi = 0
                  call fmdivi_r1(mresult, 2, qx)
              endif
          else
              if (qx%krad == 0) then
                  call fmi2m(-90, mresult, qx)
              else
                  call fmpi(mresult, qx)
                  qx%ndigpi = 0
                  call fmdivi_r1(mresult, -2, qx)
              endif
          endif
          kresult = 1
          return
      endif
      call fmovun_xe(mxy(1), xe, qx)
      if (xe >= 1) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif
      if (mxy(1)%mp(2) == qx%munkno .and. mxy(1)%mp(5) < 0) then
          if (2*xe < -ndsave) then
              if (qx%krad == 1) then
                  call fmeq(mxy(1), mresult, qx)
              else
                  call fmmpyi(mxy(1), 180, mxy(3), qx)
                  call fmpi(mxy(2), qx)
                  qx%ndigpi = 0
                  call fmdiv(mxy(3), mxy(2), mresult, qx)
              endif
              kresult = 1
              return
          endif
      endif
      if (mxy(1)%mp(2) == qx%mexpun) then
          call fmeq(mxy(1), mresult, qx)
          if (qx%krad == 0) then
              call fmpi(mxy(1), qx)
              qx%ndigpi = 0
              call fmdiv(mresult, mxy(1), mxy(2), qx)
              call fmmpyi(mxy(2), 180, mresult, qx)
          endif
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (qx%kround /= 1 .and. mxy(1)%mp(2) < -ndsave .and. qx%krad == 1) then
          call fmsqr(mxy(1), mxy(4), qx)
          call fmmpy(mxy(1), mxy(4), mxy(2), qx)
          call fmdivi(mxy(2), 6, mxy(3), qx)
          call fmadd(mxy(1), mxy(3), mresult, qx)
          if (qx%kflag > 0) qx%kflag = 0
          kresult = 1
          return
      endif
      if (mxy(1)%mp(3) == 0) then
          call fmi2m(0, mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine fmasin_sc

      subroutine fmasinh(ma, mb, qx)

!  mb = asinh(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(4), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmasinh_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmasinh_m1(ma, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmasinh

      subroutine fmasinh_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing asinh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: krndsave
      double precision :: xe

      krndsave = qx%kround
      qx%kround = 1
      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

      call fmovun_xe(mxy(1), xe, qx)
      if (mxy(1)%mp(3) == 0) then
          call fmi2m(0, mresult, qx)
      else if (4.0*(xe-1) > qx%ndig) then
          call fmmpyi(mxy(1), 2, mresult, qx)
          if (mresult%mp(2) == qx%mexpov) then
              if (mxy(1)%mp(1) < 0) then
                  call fmabs(mxy(1), mxy(3), qx)
                  call fmln(mxy(3), mresult, qx)
                  qx%ndigli = 0
                  call fmlni(2, mxy(3), qx)
                  qx%ndigli = 0
                  call fmadd_r1(mresult, mxy(3), qx)
                  call fmnegate(mresult, qx)
              else
                  call fmln(mxy(1), mresult, qx)
                  qx%ndigli = 0
                  call fmlni(2, mxy(3), qx)
                  qx%ndigli = 0
                  call fmadd_r1(mresult, mxy(3), qx)
              endif
          else
              if (mxy(1)%mp(1) < 0) then
                  call fmi2m(1, mxy(3), qx)
                  call fmsqr(mresult, mxy(4), qx)
                  call fmdiv_r2(mxy(3), mxy(4), qx)
                  call fmabs(mresult, mxy(3), qx)
                  call fmln(mxy(3), mresult, qx)
                  qx%ndigli = 0
                  call fmadd_r1(mresult, mxy(4), qx)
                  call fmnegate(mresult, qx)
              else
                  call fmi2m(1, mxy(3), qx)
                  call fmsqr(mresult, mxy(4), qx)
                  call fmdiv_r2(mxy(3), mxy(4), qx)
                  call fmln(mresult, mxy(3), qx)
                  qx%ndigli = 0
                  call fmadd(mxy(3), mxy(4), mresult, qx)
              endif
          endif
      else if (xe > 0) then
          if (mxy(1)%mp(1) < 0) then
              call fmsqr(mxy(1), mxy(3), qx)
              call fmi2m(1, mresult, qx)
              call fmadd_r1(mxy(3), mresult, qx)
              call fmsqrt_r1(mxy(3), qx)
              call fmsub_r1(mxy(3), mxy(1), qx)
              call fmln(mxy(3), mresult, qx)
              qx%ndigli = 0
              call fmnegate(mresult, qx)
          else
              call fmsqr(mxy(1), mxy(3), qx)
              call fmi2m(1, mresult, qx)
              call fmadd_r1(mxy(3), mresult, qx)
              call fmsqrt_r1(mxy(3), qx)
              call fmadd_r2(mxy(1), mxy(3), qx)
              call fmln(mxy(3), mresult, qx)
              qx%ndigli = 0
          endif
      else
          call fmsqr(mxy(1), mxy(3), qx)
          call fmi2m(1, mresult, qx)
          call fmadd_r1(mxy(3), mresult, qx)
          call fmsqrt_r1(mxy(3), qx)
          call fmdiv_r2(mxy(1), mxy(3), qx)
          call fmatanh(mxy(3), mresult, qx)
      endif

      qx%kround = krndsave

      return
      end subroutine fmasinh_m1

      subroutine fmasinh_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = asinh(ma).

!  kresult = 1 is returned if a special case gives the value of asinh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      double precision :: xe

      kresult = 0

      qx%namest(qx%ncall) = 'FMASINH  '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

      if (mxy(1)%mp(2) == qx%munkno .and. mxy(1)%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      call fmovun_xe(mxy(1), xe, qx)
      if (4*xe < -ndsave) then
          call fmsqr(mxy(1), mxy(2), qx)
          call fmmpy_r2(mxy(1), mxy(2), qx)
          call fmdivi_r1(mxy(2), 6, qx)
          call fmsub(mxy(1), mxy(2), mresult, qx)
          if (qx%kflag == 1) qx%kflag = 0
          kresult = 1
          return
      endif

      return
      end subroutine fmasinh_sc

      subroutine fmatan(ma, mb, qx)

!  mb = atan(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(5), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmatan_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmatan_m(ma, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmatan

      subroutine fmatan_m(ma, mxy, mresult, ndsave, qx)

!  Method selection for computing mresult = atan(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: maexp, masign
      double precision :: xe
      integer :: krndsave, kradsave, ndsv, nmethd

      qx%ndigpi = 0
      qx%mbspi = 0
      krndsave = qx%kround
      qx%kround = 1
      call fmndig(qx%ndig + qx%ndig/100, qx)
      call fmequ(ma, mxy(3), ndsave, qx%ndig, qx)
      if (qx%kround /= 1 .and. qx%krad /= 1) then
          call fmi2m(1, mxy(1), qx)
          call fmsub(mxy(3), mxy(1), mxy(2), qx)
          if (mxy(2)%mp(3) == 0) then
              call fmst2m('45', mresult, qx)
              qx%kround = krndsave
              return
          endif
          call fmadd(mxy(3), mxy(1), mxy(2), qx)
          if (mxy(2)%mp(3) == 0) then
              call fmst2m('-45', mresult, qx)
              qx%kround = krndsave
              return
          endif
      endif

!             If ma >= 1 work with 1/ma.

      call fmovun_xe(mxy(3), xe, qx)
      maexp = xe
      masign = ma%mp(1)
      mxy(3)%mp(1) = 1
      if (maexp >= 1) then
          call fmi2m(1, mxy(5), qx)
          call fmdiv_r2(mxy(5), mxy(3), qx)
      endif

      kradsave = qx%krad
      qx%krad = 1

!             In case pi has not been computed at the current precision and will be needed here,
!             get it to full precision first to avoid repeated calls at increasing precision during
!             Newton iteration.

      if (maexp >= 1 .or. kradsave == 0) then
          if (qx%mbspi /= qx%mbase .or. qx%ndigpi < qx%ndig) then
              ndsv = qx%ndig
              call fmndig(qx%ndig + 2, qx)
              call fmpi(mxy(5), qx)
              qx%ndigpi = 0
              call fmndig(ndsv, qx)
          endif
      endif

      nmethd = 1
      if (qx%ndig*qx%alogmt > 2000) nmethd = 2
      call fmovun_xe(mxy(3), xe, qx)
      if (xe < -ndsave) nmethd = 1

      if (nmethd == 1) then
          call fmatan_m1(mxy, mresult, qx)
      else
          call fmatan_m2(mxy, mresult, qx)
      endif

!             if ma >= 1 use pi/2 - atan(1/ma)

      if (maexp >= 1) then
          call fmpi(mxy(5), qx)
          qx%ndigpi = 0
          call fmdivi(mxy(5), 2, mxy(4), qx)
          call fmsub_r2(mxy(4), mresult, qx)
      endif

!             Convert to degrees if necessary.

      qx%krad = kradsave
      if (qx%krad == 0) then
          call fmmpyi_r1(mresult, 180, qx)
          call fmpi(mxy(5), qx)
          qx%ndigpi = 0
          call fmdiv_r1(mresult, mxy(5), qx)
      endif
      if (masign < 0) call fmnegate(mresult, qx)

      if (qx%kflag == 1) qx%kflag = 0

      qx%kround = krndsave

      return
      end subroutine fmatan_m

      subroutine fmatan_m1(mxy, mresult, qx)

!  Method 1 for computing atan(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(5), mresult
      type(fm_settings) :: qx

      intent (inout) :: mxy, mresult

      double precision :: x, xe, ye
      real (kind(1.0d0)) :: maxv
      integer :: j, j2, k, k2, kl, ktwo, ndsav1, nterm
      type(multi) :: mjsums(ljsums)

!             Method 1.  Reduce the argument and use the Taylor series.
!                        Atan(x) = x - x**3 / 3 + x**5 / 5 - ...

      k2 = max(2, int(0.67*(qx%ndig*qx%alogmt)**0.3333 + 0.4))
      k2 = max(k2, 3)
      call fmovun_xe(mxy(3), xe, qx)
      if (xe <= -qx%ndig/3) then
          k2 = 0
      else
          if (xe*qx%dlogmb < log(2.0d0**(-k2))) then
              k2 = 0
          else
              call fmm2dp(mxy(3), x, qx)
              k = k2 + 1
              do j = 0, k
                 if (x < 0.375d0/2.0d0**(j)) then
                     k2 = k2 - 1
                     if (k2 <= 0) exit
                 endif
              enddo
          endif
      endif
      call fmeq(mxy(3), mxy(1), qx)
      call fmi2m(1, mxy(4), qx)
      do j = 1, k2
         call fmsqr(mxy(1), mxy(2), qx)
         call fmadd_r2(mxy(4), mxy(2), qx)
         call fmsqrt_r1(mxy(2), qx)
         call fmsub_r1(mxy(2), mxy(4), qx)
         call fmdiv_r2(mxy(2), mxy(1), qx)
      enddo

      j2 = int(0.96*(qx%ndig*qx%alogmt)**0.3333 - 1.7)
      j2 = max(2, min(j2+mod(j2, 2), ljsums))

!             Split into j2 concurrent sums and reduce ndig while computing each term in the sum
!             as the terms get smaller.

      nterm = 1
      do j = 1, j2
         if (nterm > 1) then
             call fmcsdivi(mxy(1), nterm, mjsums(j), qx)
         else
             call fmeq(mxy(1), mjsums(j), qx)
         endif
         nterm = nterm + 2
      enddo
      ndsav1 = qx%ndig
      call fmeq(mxy(1), mxy(4), qx)
      call fmsqr_r1(mxy(1), qx)
      call fmovun_xe(mxy(1), xe, qx)
      if (xe >= -qx%ndig) then
          call fmipwr(mxy(1), j2, mxy(2), qx)
          kl = 1
          do while (kl == 1)
             call fmcsmpy_r1(mxy(4), mxy(2), qx)
             do j = 1, j2
                call fmcsdivi(mxy(4), nterm, mresult, qx)
                call fmndig(ndsav1, qx)
                call fmcsaddnn_r1(mjsums(j), mresult, qx)
                if (qx%kflag /= 0) then
                    kl = 0
                    exit
                endif
                call fmovun_xe(mjsums(j), xe, qx)
                call fmovun_xe(mresult, ye, qx)
                call fmndig(ndsav1 - int(xe-ye), qx)
                if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                nterm = nterm + 2
             enddo
          enddo
      endif

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmcsnsums(j2, mjsums, qx)
      call fmeq(mjsums(j2), mresult, qx)
      call fmnegate(mxy(1), qx)
      do j = 2, j2
         call fmcsmpy_r1(mresult, mxy(1), qx)
         call fmadd_r1(mresult, mjsums(j2-j+1), qx)
      enddo

!             Reverse the argument reduction.

      ktwo = 1
      maxv = mxbase/2
      do j = 1, k2
         ktwo = 2*ktwo
         if (ktwo > maxv) then
             call fmcsmpyi_r1(mresult, ktwo, qx)
             ktwo = 1
         endif
      enddo
      if (ktwo > 1) call fmcsmpyi_r1(mresult, ktwo, qx)

      return
      end subroutine fmatan_m1

      subroutine fmatan_m2(mxy, mresult, qx)

!  Method 2 for computing atan(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(5), mresult
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: x, xe
      integer :: j, kst, nstack(49)

!             Method 2.  Newton iteration.

      call fmi2m(0, mxy(1), qx)
      call fmi2m(0, mxy(2), qx)
      call fmi2m(0, mxy(4), qx)

      call fmovun_xe(mxy(3), xe, qx)
      if (xe*qx%dlogmb < -46) then
          call fmeq(mxy(3), mresult, qx)
      else
          call fmm2dp(mxy(3), x, qx)
          x = atan(x)
          call fmdpm(x, mresult, qx)
      endif
      call fmdig(nstack, kst, qx)

!             Newton iteration.

      do j = 1, kst
         call fmndig(nstack(j), qx)
         call fmsin(mresult, mxy(4), qx)
         call fmovun_xe(mresult, xe, qx)
         if (2*xe <= -qx%ndig) then
             call fmi2m(1, mxy(2), qx)
             call fmsub(mxy(2), mxy(4), mxy(1), qx)
             call fmadd_r1(mxy(2), mxy(4), qx)
             call fmmpy_r1(mxy(1), mxy(2), qx)
             call fmsqrt(mxy(1), mxy(2), qx)
             call fmdiv_r2(mxy(4), mxy(2), qx)
             call fmsub_r1(mxy(2), mxy(3), qx)
             call fmmpy_r2(mxy(1), mxy(2), qx)
             call fmsub_r1(mresult, mxy(2), qx)
         else
             call fmsqr(mxy(4), mxy(1), qx)
             call fmi2m(1, mxy(2), qx)
             call fmsub_r2(mxy(2), mxy(1), qx)
             call fmsqrt(mxy(1), mxy(2), qx)
             call fmdiv_r2(mxy(4), mxy(2), qx)
             call fmsub_r1(mxy(2), mxy(3), qx)
             call fmmpy_r2(mxy(1), mxy(2), qx)
             call fmsub_r1(mresult, mxy(2), qx)
         endif
      enddo

      return
      end subroutine fmatan_m2

      subroutine fmatan_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = atan(ma).

!  kresult = 1 is returned if a special case gives the value of atan(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      double precision :: xe
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMATAN   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      call fmovun_xe(malocal, xe, qx)
      if (2*xe < -ndsave) then
          qx%kflag = 0
          call fmeq(malocal, mxy(1), qx)
          if (qx%krad == 1) then
              call fmeq(mxy(1), mxy(3), qx)
              if (qx%kround /= 1) then
                  call fmipwr(mxy(1), 3, mxy(3), qx)
                  call fmdivi_r1(mxy(3), 6, qx)
                  call fmsub_r2(mxy(1), mxy(3), qx)
              endif
          else
              call fmi2m(180, mxy(2), qx)
              call fmpi(mxy(3), qx)
              qx%ndigpi = 0
              call fmdiv_r2(mxy(2), mxy(3), qx)
              call fmmpy_r2(mxy(1), mxy(3), qx)
          endif
          call fmeq(mxy(3), mresult, qx)
          kresult = 1
          return
      endif

      if (2*xe > qx%ndig) then
          call fmeq(malocal, mxy(1), qx)
          if (qx%krad == 1) then
              call fmi2m(1, mxy(2), qx)
              call fmdiv_r2(mxy(2), mxy(1), qx)
              call fmpi(mxy(2), qx)
              qx%ndigpi = 0
              mxy(2)%mp(1) = malocal%mp(1)
              call fmdivi_r1(mxy(2), 2, qx)
              call fmsub(mxy(2), mxy(1), mxy(3), qx)
          else
              call fmpi(mxy(3), qx)
              qx%ndigpi = 0
              call fmi2m(180, mxy(2), qx)
              call fmdiv_r2(mxy(2), mxy(3), qx)
              call fmdiv_r1(mxy(3), mxy(1), qx)
              call fmi2m(90, mxy(2), qx)
              mxy(2)%mp(1) = malocal%mp(1)
              call fmsub_r2(mxy(2), mxy(3), qx)
          endif
          call fmeq(mxy(3), mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine fmatan_sc

      subroutine fmatan2(ma, mb, mc, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      call fmatn2(ma, mb, mc, qx)

      return
      end subroutine fmatan2

      subroutine fmatanh(ma, mb, qx)

!  mb = atanh(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(4), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmatanh_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmatanh_m(ma, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmatanh

      subroutine fmatanh_m(ma, mxy, mresult, ndsave, qx)

!  Method selection for computing atanh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: x, xe
      integer :: krndsave, nmethd

      krndsave = qx%kround
      qx%kround = 1
      call fmndig(qx%ndig + qx%ndig/100, qx)
      call fmequ(ma, mxy(3), ndsave, qx%ndig, qx)
      mxy(3)%mp(1) = 1

      nmethd = 1
      call fmm2dp(mxy(3), x, qx)
      call fmovun_xe(mxy(3), xe, qx)
      if (xe >= -qx%ndig) then
          if (abs(x) >= 1234.0/(qx%ndig*qx%alogmt)**2) nmethd = 2
      endif

      if (nmethd == 1) then
          call fmatanh_m1(mxy, mresult, qx)
      else
          call fmatanh_m2(mxy, mresult, qx)
      endif

      if (ma%mp(1) < 0) mresult%mp(1) = -1

      qx%kround = krndsave

      return
      end subroutine fmatanh_m

      subroutine fmatanh_m1(mxy, mresult, qx)

!  Method 1 for computing atanh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(4), mresult
      type(fm_settings) :: qx

      intent (inout) :: mxy, mresult

      double precision :: x, xe, ye
      real (kind(1.0d0)) :: maxv
      integer :: j, j2, k, k2, kl, ktwo, ndsav1, nterm
      type(multi) :: mjsums(ljsums)

!             Method 1.  Reduce the argument and use the Taylor series.
!                        Atanh(x) = x + x**3 / 3 + x**5 / 5 + ...

      k2 = max(2, int(0.67*(qx%ndig*qx%alogmt)**0.3333 + 0.4))
      k2 = max(k2, 3)
      call fmm2dp(mxy(3), x, qx)
      call fmovun_xe(mxy(3), xe, qx)
      if (xe <= -qx%ndig/3) then
          k2 = 0
      else
          if (xe*qx%dlogmb < log(2.0d0**(-k2))) then
              k2 = 0
          else
              k = k2 + 1
              do j = 0, k
                 if (x < 0.375d0/2.0d0**(j)) then
                     k2 = k2 - 1
                     if (k2 <= 0) exit
                 endif
              enddo
          endif
      endif
      call fmeq(mxy(3), mxy(1), qx)
      call fmi2m(1, mxy(4), qx)
      do j = 1, k2
         call fmsqr(mxy(1), mxy(2), qx)
         call fmsub_r2(mxy(4), mxy(2), qx)
         call fmsqrt_r1(mxy(2), qx)
         call fmsub_r2(mxy(4), mxy(2), qx)
         call fmdiv_r2(mxy(2), mxy(1), qx)
      enddo

      j2 = int(0.96*(qx%ndig*qx%alogmt)**0.3333 - 1.7)
      j2 = max(1, min(j2, ljsums))

!             Split into j2 concurrent sums and reduce ndig while computing each term in the sum
!             as the terms get smaller.

      nterm = 1
      do j = 1, j2
         if (nterm > 1) then
             call fmcsdivi(mxy(1), nterm, mjsums(j), qx)
         else
             call fmeq(mxy(1), mjsums(j), qx)
         endif
         nterm = nterm + 2
      enddo
      ndsav1 = qx%ndig
      call fmeq(mxy(1), mxy(4), qx)
      call fmsqr_r1(mxy(1), qx)
      call fmovun_xe(mxy(1), xe, qx)
      if (xe >= -qx%ndig) then
          call fmipwr(mxy(1), j2, mxy(2), qx)
          kl = 1
          do while (kl == 1)
             call fmcsmpy_r1(mxy(4), mxy(2), qx)
             do j = 1, j2
                call fmcsdivi(mxy(4), nterm, mresult, qx)
                call fmndig(ndsav1, qx)
                call fmcsaddnn_r1(mjsums(j), mresult, qx)
                if (qx%kflag /= 0) then
                    kl = 0
                    exit
                endif
                call fmovun_xe(mjsums(j), xe, qx)
                call fmovun_xe(mresult, ye, qx)
                call fmndig(ndsav1 - int(xe-ye), qx)
                if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                nterm = nterm + 2
             enddo
          enddo
      endif

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmcsnsums(j2, mjsums, qx)
      call fmeq(mjsums(j2), mresult, qx)
      do j = 2, j2
         call fmcsmpy_r1(mresult, mxy(1), qx)
         call fmadd_r1(mresult, mjsums(j2-j+1), qx)
      enddo

!             Reverse the argument reduction.

      ktwo = 1
      maxv = mxbase/2
      do j = 1, k2
         ktwo = 2*ktwo
         if (ktwo > maxv) then
             call fmcsmpyi_r1(mresult, ktwo, qx)
             ktwo = 1
         endif
      enddo
      if (ktwo > 1) call fmcsmpyi_r1(mresult, ktwo, qx)

      return
      end subroutine fmatanh_m1

      subroutine fmatanh_m2(mxy, mresult, qx)

!  Method 2 for computing atanh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(4), mresult
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: iextra

!             Method 2.  Atanh(x) =  ln( (1+x) / (1-x) ) / 2

      iextra = -mxy(3)%mp(2)
      if (abs(mxy(3)%mp(2)) >= qx%mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(3), qx%ndig, qx%ndig+iextra, qx)
          call fmndig(qx%ndig + iextra, qx)
      endif
      call fmi2m(1, mxy(1), qx)
      call fmadd(mxy(1), mxy(3), mxy(4), qx)
      call fmsub(mxy(1), mxy(3), mresult, qx)
      call fmdiv(mxy(4), mresult, mxy(2), qx)
      call fmln(mxy(2), mresult, qx)
      qx%ndigli = 0
      call fmdivi_r1(mresult, 2, qx)

      return
      end subroutine fmatanh_m2

      subroutine fmatanh_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = atanh(ma).

!  kresult = 1 is returned if a special case gives the value of atanh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      double precision :: xe
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMATANH  '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      call fmovun_xe(malocal, xe, qx)
      if (xe >= 1) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif
      if (malocal%mp(3) == 0) then
          call fmi2m(0, mresult, qx)
          kresult = 1
          return
      endif
      if (2*xe < -ndsave) then
          call fmeq(malocal, mxy(1), qx)
          if (qx%kround /= 1) then
              call fmipwr(mxy(1), 3, mxy(2), qx)
              call fmdivi_r1(mxy(2), 3, qx)
              call fmadd_r1(mxy(1), mxy(2), qx)
          endif
          call fmeq(mxy(1), mresult, qx)
          qx%kflag = 0
          kresult = 1
          return
      endif

      return
      end subroutine fmatanh_sc

      subroutine fmatn2(ma, mb, mc, qx)

!  mc = atan2(ma, mb)

!  mc is returned as the angle between -pi and pi (or -180 and 180 if degree mode is selected) for
!  which tan(mc) = ma/mb.  mc is an angle for the point (mb,ma) in polar coordinates.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(5), mresult

      call fmalloc(mc, qx%ndig+2, qx)
      call fmenter2(ma, mb, kovun, mxsave, ndsave, qx)
      call fmatn2_sc(ma, mb, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mc, kovun, mxsave, ndsave, qx)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmatn2_m1(ma, mb, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mc, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmatn2

      subroutine fmatn2_m1(ma, mb, mxy, mresult, ndsave, qx)

!  Method 1 for computing atan2(ma,mb).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mxy(5), mresult
      integer :: ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: jquad, krndsave

      krndsave = qx%kround
      qx%kround = 1
      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      call fmequ(mb, mxy(2), ndsave, qx%ndig, qx)

!             Determine the quadrant for the result, then use fmatan.

      jquad = 1
      if (ma%mp(1) >= 0 .and. mb%mp(1) < 0) jquad = 2
      if (ma%mp(1)  < 0 .and. mb%mp(1) < 0) jquad = 3
      if (ma%mp(1)  < 0 .and. mb%mp(1) > 0) jquad = 4

      call fmdiv(mxy(1), mxy(2), mxy(4), qx)
      mxy(4)%mp(1) = 1
      call fmatan(mxy(4), mresult, qx)

      if (jquad == 2 .or. jquad == 3) then
          if (qx%krad == 0) then
              call fmi2m(180, mxy(3), qx)
              call fmsub_r2(mxy(3), mresult, qx)
          else
              call fmpi(mxy(3), qx)
              qx%ndigpi = 0
              call fmsub_r2(mxy(3), mresult, qx)
          endif
      endif

      if (jquad == 3 .or. jquad == 4) call fmnegate(mresult, qx)

      qx%kround = krndsave

      return
      end subroutine fmatn2_m1

      subroutine fmatn2_sc(ma, mb, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = atan2(ma,mb).

!  kresult = 1 is returned if a special case gives the value of atan2(ma,mb).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mxy(5), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      type(multi) :: malocal, mblocal
      real (kind(1.0d0)) :: mxexp1
      double precision :: a_xe, b_xe, xe, ye
      integer :: j, kl

      kresult = 0

      qx%namest(qx%ncall) = 'FMATN2   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp2(ma, mb, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)
      call fmequ(mb, mblocal, ndsave, qx%ndig, qx)

      if ((malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) .or.  &
          (mblocal%mp(2) == qx%munkno .and. mblocal%mp(5) >= 0)) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if ((abs(malocal%mp(2)) >= qx%mexpov .or. abs(mblocal%mp(2)) >= qx%mexpov) .and.  &
          mblocal%mp(3) /= 0) then
          call fmovun_xe(malocal, a_xe, qx)
          call fmovun_xe(mblocal, b_xe, qx)
          call fmeq(malocal, mxy(4), qx)
          call fmeq(mblocal, mxy(5), qx)
          call fmdiv(mxy(4), mxy(5), mxy(1), qx)
          if (abs(mxy(1)%mp(2)) >= qx%mexpov) then
              if (a_xe - b_xe > qx%ndig) then
                  call fmi2m(1, mxy(1), qx)
                  mxy(1)%mp(2) = 2*qx%ndig
                  mxy(1)%mp(1) = malocal%mp(1) * mblocal%mp(1)
              else if (b_xe - a_xe > qx%ndig .and. mblocal%mp(1) < 0) then
                  call fmi2m(1, mxy(1), qx)
                  mxy(1)%mp(2) = -2*qx%ndig
                  mxy(1)%mp(1) = malocal%mp(1) * mblocal%mp(1)
              endif
          endif
          call fmatan(mxy(1), mxy(2), qx)
          if (mblocal%mp(1) > 0) then
              call fmeq(mxy(2), mresult, qx)
          else if (malocal%mp(1) > 0) then
              if (qx%krad == 1) then
                  call fmpi(mxy(3), qx)
                  qx%ndigpi = 0
              else
                  call fmi2m(180, mxy(3), qx)
              endif
              call fmadd(mxy(2), mxy(3), mresult, qx)
          else
              if (qx%krad == 1) then
                  call fmpi(mxy(3), qx)
                  qx%ndigpi = 0
              else
                  call fmi2m(180, mxy(3), qx)
              endif
              call fmsub(mxy(2), mxy(3), mresult, qx)
          endif
          if (( mresult%mp(2) /= qx%mexpun .and. mresult%mp(2) < 0 ) .or.  &
              mresult%mp(2) == qx%munkno) then
              if (mresult%mp(2) == qx%munkno .and. mresult%mp(5) <= 0) then
                  qx%kflag = -4
              else
                  qx%kflag = -4
                  call fmunknown(mresult, qx)
              endif
          endif
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (qx%kround /= 1 .and. mblocal%mp(1) >= 0 .and. qx%krad == 1) then
          call fmdiv(malocal, mblocal, mxy(1), qx)
          call fmovun_xe(mxy(1), xe, qx)
          if (xe < -ndsave) then
              if (mxy(1)%mp(2) == qx%mexpun) then
                  call fmeq(mxy(1), mxy(3), qx)
              else
                  call fmsqr(mxy(1), mxy(2), qx)
                  call fmmpy_r1(mxy(2), mxy(1), qx)
                  call fmdivi_r1(mxy(2), 3, qx)
                  if (mxy(2)%mp(2) /= qx%mexpun) then
                      call fmsub(mxy(1), mxy(2), mxy(3), qx)
                  else if (mxy(1)%mp(1) < 0 .and. (qx%kround == 2 .or. qx%kround == 0)) then
                      kl = mxy(1)%mp(2)
                      mxy(1)%mp(2) = 0
                      call fmulp(mxy(1), mxy(2), qx)
                      call fmsub(mxy(1), mxy(2), mxy(4), qx)
                      mxy(4)%mp(2) = kl + mxy(4)%mp(2)
                      call fmeq(mxy(4), mxy(3), qx)
                  else if (mxy(1)%mp(1) >= 0 .and. (qx%kround == -1 .or. qx%kround == 0)) then
                      kl = mxy(1)%mp(2)
                      mxy(1)%mp(2) = 0
                      call fmulp(mxy(1), mxy(2), qx)
                      call fmsub(mxy(1), mxy(2), mxy(4), qx)
                      mxy(4)%mp(2) = kl + mxy(4)%mp(2)
                      call fmeq(mxy(4), mxy(3), qx)
                  else
                      call fmeq(mxy(1), mxy(3), qx)
                  endif
              endif
              qx%kflag = 0
              call fmeq(mxy(3), mresult, qx)
              kresult = 1
              return
          endif
      endif
      if (malocal%mp(2) == qx%munkno .or. mblocal%mp(2) == qx%munkno .or.  &
         (malocal%mp(3) == 0 .and. mblocal%mp(3) == 0)) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif
      if (qx%kround /= 1 .and. qx%krad /= 1) then
          if (malocal%mp(2) == qx%mexpun) then
              call fmtiny(mxy(3), qx)
          else if (malocal%mp(2) == qx%mexpov) then
              call fmbig(mxy(3), qx)
          else
              call fmeq(malocal, mxy(3), qx)
          endif
          mxy(3)%mp(1) = malocal%mp(1)
          if (mblocal%mp(2) == qx%mexpun) then
              call fmtiny(mxy(4), qx)
          else if (mblocal%mp(2) == qx%mexpov) then
              call fmbig(mxy(4), qx)
          else
              call fmeq(mblocal, mxy(4), qx)
          endif
          mxy(4)%mp(1) = mblocal%mp(1)
          call fmovun_xe(mxy(3), xe, qx)
          call fmovun_xe(mxy(4), ye, qx)
          if (xe > ye+qx%ndig) then
              if (malocal%mp(1) > 0) then
                  call fmdiv(mxy(4), mxy(3), mresult, qx)
                  call fmmpyi_r1(mresult, 180, qx)
                  call fmpi(mxy(3), qx)
                  qx%ndigpi = 0
                  call fmdiv(mresult, mxy(3), mxy(4), qx)
                  call fmi2m(90, mxy(3), qx)
                  call fmsub(mxy(3), mxy(4), mresult, qx)
                  kresult = 1
                  return
              endif
              if (malocal%mp(1) < 0) then
                  call fmdiv(mxy(4), mxy(3), mresult, qx)
                  call fmmpyi_r1(mresult, 180, qx)
                  call fmpi(mxy(3), qx)
                  qx%ndigpi = 0
                  call fmdiv(mresult, mxy(3), mxy(4), qx)
                  call fmi2m(-90, mxy(3), qx)
                  call fmsub(mxy(3), mxy(4), mresult, qx)
                  kresult = 1
                  return
              endif
          endif
          if (ye > xe+qx%ndig .and. mblocal%mp(1) < 0) then
              if (malocal%mp(1) > 0) then
                  call fmdiv(mxy(3), mxy(4), mresult, qx)
                  call fmmpyi_r1(mresult, 180, qx)
                  call fmpi(mxy(3), qx)
                  qx%ndigpi = 0
                  call fmdiv(mresult, mxy(3), mxy(4), qx)
                  call fmi2m(180, mxy(3), qx)
                  call fmadd(mxy(3), mxy(4), mresult, qx)
                  kresult = 1
                  return
              endif
              if (malocal%mp(1) < 0) then
                  call fmdiv(mxy(3), mxy(4), mresult, qx)
                  call fmmpyi_r1(mresult, 180, qx)
                  call fmpi(mxy(3), qx)
                  qx%ndigpi = 0
                  call fmdiv(mresult, mxy(3), mxy(4), qx)
                  call fmi2m(-180, mxy(3), qx)
                  call fmadd(mxy(3), mxy(4), mresult, qx)
                  kresult = 1
                  return
              endif
          endif
      endif

      if (mblocal%mp(3) == 0 .and. malocal%mp(1) > 0) then
          if (qx%krad == 0) then
              call fmi2m(90, mresult, qx)
          else
              call fmpi(mresult, qx)
              qx%ndigpi = 0
              call fmdivi_r1(mresult, 2, qx)
          endif
          kresult = 1
          return
      endif

      if (mblocal%mp(3) == 0 .and. malocal%mp(1) < 0) then
          if (qx%krad == 0) then
              call fmi2m(-90, mresult, qx)
          else
              call fmpi(mresult, qx)
              qx%ndigpi = 0
              call fmdivi_r1(mresult, -2, qx)
          endif
          kresult = 1
          return
      endif

      mxexp1 = int(qx%mxexp2/2.01d0)
      call fmovun_xe(mblocal, xe, qx)
      if (malocal%mp(2) == qx%mexpov .and. xe < mxexp1-ndsave-2) then
          if (qx%krad == 0) then
              call fmi2m(90, mresult, qx)
          else
              call fmpi(mresult, qx)
              qx%ndigpi = 0
              call fmdivi_r1(mresult, 2, qx)
          endif
          if (malocal%mp(1) < 0) mresult%mp(1) = -1
          kresult = 1
          return
      endif

      if (malocal%mp(2) == qx%mexpun .and. -xe < mxexp1-ndsave-2 .and.  &
                                 mblocal%mp(1) < 0) then
          if (qx%krad == 0) then
              call fmi2m(180, mresult, qx)
          else
              call fmpi(mresult, qx)
              qx%ndigpi = 0
          endif
          if (malocal%mp(1) < 0) mresult%mp(1) = -1
          kresult = 1
          return
      endif

      call fmovun_xe(malocal, xe, qx)
      if (mblocal%mp(2) == qx%mexpov .and. xe < mxexp1-ndsave-2 .and.  &
                                mblocal%mp(1) < 0) then
          if (qx%krad == 0) then
              call fmi2m(180, mresult, qx)
          else
              call fmpi(mresult, qx)
              qx%ndigpi = 0
          endif
          if (malocal%mp(1) < 0) mresult%mp(1) = -1
          kresult = 1
          return
      endif

      if (mblocal%mp(2) == qx%mexpun .and. malocal%mp(3) == 0) then
          if (mblocal%mp(1) < 0) then
              if (qx%krad == 0) then
                  call fmi2m(180, mresult, qx)
              else
                  call fmpi(mresult, qx)
                  qx%ndigpi = 0
              endif
          else
              call fmi2m(0, mresult, qx)
          endif
          kresult = 1
          return
      endif

      if (mblocal%mp(2) == qx%mexpun .and. -xe < mxexp1-ndsave-2) then
          if (qx%krad == 0) then
              call fmi2m(90, mresult, qx)
          else
              call fmpi(mresult, qx)
              qx%ndigpi = 0
              call fmdivi_r1(mresult, 2, qx)
          endif
          if (malocal%mp(1) < 0) mresult%mp(1) = -1
          kresult = 1
          return
      endif

      return
      end subroutine fmatn2_sc

      subroutine fmber2(n, ma, mb, qx)

!  Internal routine for small Bernoulli numbers.

!  mb = ma*b(n) for n an even integer between 2 and 26.

      use fmvals_parallel
      implicit none

      integer :: n
      type(multi) :: ma, mb
      intent (in) :: n, ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      integer :: n2
      integer :: nbtop(13) = (/  &
              1,   1,  1,   1,  5, -691, 7, -3617, 43867, -174611, 854513, -236364091, 8553103 /)
      integer :: nbbot(13) = (/  &
              6, -30, 42, -30, 66, 2730, 6,   510,   798,     330,    138,       2730,       6 /)

      if (n <= 0) then
          call fmeq(ma, mb, qx)
          return
      else if (n == 1) then
          call fmdivi(ma, -2, mb, qx)
          return
      else if (mod(n, 2) == 1) then
          call fmi2m(0, mb, qx)
          return
      endif

      n2 = n/2

      if (n <= 26) then
          if (nbtop(n2) == 1) then
              call fmdivi(ma, nbbot(n2), mb, qx)
          else
              call fmmpyi(ma, nbtop(n2), mb, qx)
              call fmdivi_r1(mb, nbbot(n2), qx)
          endif
      endif

      return
      end subroutine fmber2

      subroutine fmbern(n, ma, mb, mbern, ndbern, qx)

!  mb = ma*b(n)      b(n) is the nth Bernoulli number.  (Internal routine used by special functions)

      use fmvals_parallel
      implicit none

      type(multi) :: mbern(lmbern)
      integer :: ndbern(lmbern)
      integer :: n
      type(multi) :: ma, mb
      intent (in) :: n, ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(5), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmbern_sc(n, ma, mxy, ndsave, mresult, kresult, mbern, ndbern, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call fmbern_m1(n, ma, mxy, mresult, ndsave, mbern, ndbern, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmbern

      subroutine fmbern_m1(n, ma, mxy, mresult, ndsave, mbern, ndbern, qx)

!  Method 1 for computing ma*b(n).

      use fmvals_parallel
      implicit none

      type(multi) :: mbern(lmbern)
      integer :: ndbern(lmbern)
      type(multi) :: ma, mxy(5), mresult
      integer :: n, ndsave
      intent (in) :: n, ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: u, uj, x, b
      real (kind(1.0d0)) :: mnexp
      integer :: intndg, j, j2, k, l, large, larged, n2, nbot, ndiv, ndp,  &
                 ndsav1, ndsav2, nextd, nextn, nmpy, nstart, ntd, ntn, ntop, nx

      call fmequ(ma, mxy(5), ndsave, qx%ndig, qx)

!             See if b(n) has already been computed with sufficient precision.

      n2 = n/2
      if (qx%mbase == qx%mbsbrn) then
          if (n <= qx%numbrn) then
              if (allocated(mbern(n2)%mp)) then
                  if (size(mbern(n2)%mp) >= qx%ndig+2) then
                      if (ndbern(n2) >= qx%ndig) then
                          call fmmpy(mbern(n2), mxy(5), mresult, qx)
                          return
                      endif
                  endif
              endif
          endif
      else
          do j = 28, qx%numbrn, 2
             ndbern(j/2) = 0
          enddo
          qx%numbrn = 0
      endif

!             Compute more Bernoulli numbers.

      x = 1.0d0
      b = dble(qx%mbase)
      ndp = 0
      do j = 1, 80
         x = x/b
         if ((1.0d0+x) <= 1.0d0) then
             ndp = j-1
             if (qx%ndig <= ndp) x = 4.0d0*qx%dppi*qx%dppi
             exit
         endif
      enddo
      intndg = int(qx%alogmx/qx%alogmb + 1.0)
      nx = int(dble(qx%ndig)*qx%dlogmb/qx%dlogtw + 2.0d0)
      nstart = 28
      if (qx%mbsbrn == qx%mbase .and. qx%numbrn >= 28) then
          nstart = qx%numbrn + 2
          do j = 28, qx%numbrn, 2
             if (size(mbern(j/2)%mp) < qx%ndig+3 .or. ndbern(j/2) < qx%ndig) then
                 nstart = j
                 exit
             endif
          enddo
      endif

      do j = nstart, n, 2

!             Check to see if j is large enough so that the formula
!             b(j) = -b(j-2)*(j-1)*j/(2*pi)**2 can be used.

         if (j >= nx .and. qx%ndig <= ndp .and. j > 28) then
             j2 = j/2
             mnexp = mbern(j2-1)%mp(2)
             mbern(j2-1)%mp(2) = 0
             call fmm2dp(mbern(j2-1), u, qx)
             mbern(j2-1)%mp(2) = mnexp
             uj = j
             u = -u*(uj*uj-uj)/x
             qx%numbrn = j
             qx%mbsbrn = qx%mbase
             call fmdpm(u, mbern(j2), qx)
             mbern(j2)%mp(2) = mbern(j2)%mp(2) + mnexp
             ndbern(j2) = qx%ndig
             cycle
         endif

         if (j >= nx .and. j > 28) then
             large = int(intmax/j)
             j2 = j/2
             qx%numbrn = j
             qx%mbsbrn = qx%mbase
             call fmpi(mxy(2), qx)
             qx%ndigpi = 0
             call fmsqr_r1(mxy(2), qx)
             if (mod(j, 4) == 0 .or. mod(j, 4) == 1) then
                 if (j < large) then
                     l = -(j*j-j)/4
                     call fmcsmpyi(mbern(j2-1), l, mxy(3), qx)
                 else
                     call fmcsmpyi(mbern(j2-1), -j, mxy(3), qx)
                     call fmcsmpyi_r1(mxy(3), j-1, qx)
                     call fmcsdivi_r1(mxy(3), 4, qx)
                 endif
             else
                 if (j < large) then
                     l = -(j*j-j)
                     call fmcsmpyi(mbern(j2-1), l, mxy(3), qx)
                     call fmcsdivi_r1(mxy(3), 4, qx)
                 else
                     call fmcsmpyi(mbern(j2-1), -j, mxy(3), qx)
                     call fmcsmpyi_r1(mxy(3), j-1, qx)
                     call fmcsdivi_r1(mxy(3), 4, qx)
                 endif
             endif
             call fmcsdiv(mxy(3), mxy(2), mbern(j2), qx)
             ndbern(j2) = qx%ndig
             cycle
         endif

!             Use the recurrence involving a sum of binomial coefficients times previous b's.

         ntop = j + 3
         nbot = j - 6
         large = int(intmax/ntop)
         larged = min(large, int(mxbase))
         call fmcmbi(ntop, nbot, mxy(2), qx)
         if (nbot <= 26) then
             call fmber2(nbot, mxy(2), mxy(3), qx)
         else
             call fmmpy(mbern(nbot/2), mxy(2), mxy(3), qx)
         endif
         ndsav1 = qx%ndig
         do nbot = j-12, 0, -6
            ntn = nbot + 6
            ntd = ntop - nbot - 5
            nextn = ntn
            nextd = ntd
            if (nbot >= 6) then
                ndsav2 = qx%ndig
                do k = 1, 5
                   nextn = nextn - 1
                   nextd = nextd + 1
                   nmpy = ntn*nextn
                   ndiv = ntd*nextd
                   if (nmpy <= large .and. ndiv <= larged) then
                       ntn = nmpy
                       ntd = ndiv
                   else
                       call fmgcdi(nmpy, ndiv)
                       if (nmpy <= large .and. ndiv <= larged) then
                           ntn = nmpy
                           ntd = ndiv
                       else
                           call fmndig(max(qx%ngrd22, min(ndsav2, int(mxy(2)%mp(2))+intndg)), qx)
                           call fmndig(max(3, qx%ndig), qx)
                           call fmcsmpyi_r1(mxy(2), ntn, qx)
                           call fmcsdivi_r1(mxy(2), ntd, qx)
                           ntn = nextn
                           ntd = nextd
                       endif
                   endif
                enddo
                call fmndig(max(qx%ngrd22, min(ndsav2, int(mxy(2)%mp(2))+intndg)), qx)
                call fmndig(max(3, qx%ndig), qx)
                call fmcsmpyi_r1(mxy(2), ntn, qx)
                call fmcsdivi_r1(mxy(2), ntd, qx)
                call fmndig(ndsav2, qx)
            else
                call fmcmbi(ntop, nbot, mxy(2), qx)
            endif

!             Now mxy(2) is the combination ntop choose nbot.

            if (nbot <= 26) then
                call fmber2(nbot, mxy(2), mxy(4), qx)
            else
                call fmmpy(mbern(nbot/2), mxy(2), mxy(4), qx)
            endif
            call fmndig(ndsav1, qx)
            call fmcsadd_r1(mxy(3), mxy(4), qx)
            call fmndig(max(qx%ngrd22, ndsav1-int(mxy(3)%mp(2)-mxy(4)%mp(2))), qx)
            call fmndig(max(3, qx%ndig), qx)
         enddo

         call fmndig(ndsav1, qx)
         if (mod(j, 6) == 4) then
             call fmi2m(ntop, mxy(1), qx)
             call fmcsdivi(mxy(1), -6, mxy(4), qx)
             call fmsub_r2(mxy(4), mxy(3), qx)
         else
             call fmi2m(ntop, mxy(1), qx)
             call fmcsdivi(mxy(1), 3, mxy(4), qx)
             call fmsub_r2(mxy(4), mxy(3), qx)
         endif

         j2 = j/2
         qx%numbrn = j
         qx%mbsbrn = qx%mbase

         call fmcsmpyi_r1(mxy(3), 6, qx)
         ntn = ntop*(ntop-1)
         large = int(intmax/ntop)
         if (ntn > mxbase .or. ntop > large) then
             call fmcsdivi_r1(mxy(3), ntop, qx)
             ntn = ntop - 1
             call fmcsdivi_r1(mxy(3), ntn, qx)
             ntn = ntop - 2
             call fmcsdivi(mxy(3), ntn, mbern(j2), qx)
         else if (ntn > mxbase/(ntop-2) .or. ntn > large) then
             call fmcsdivi_r1(mxy(3), ntn, qx)
             ntn = ntop - 2
             call fmcsdivi(mxy(3), ntn, mbern(j2), qx)
         else
             ntn = ntn*(ntop-2)
             call fmcsdivi(mxy(3), ntn, mbern(j2), qx)
         endif
         ndbern(j2) = qx%ndig
      enddo

      call fmmpy(mbern(n2), mxy(5), mresult, qx)

      return
      end subroutine fmbern_m1

      subroutine fmbern_sc(n, ma, mxy, ndsave, mresult, kresult, mbern, ndbern, qx)

!  Check for special cases for mresult = ma*b(n).

!  kresult = 1 is returned if a special case gives the value of ma*b(n).

      use fmvals_parallel
      implicit none

      type(multi) :: mbern(lmbern)
      integer :: ndbern(lmbern)
      type(multi) :: ma, mxy(5), mresult
      integer :: n, kresult, ndsave
      intent (in) :: n, ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal, mr, ms, mt

      kresult = 0

      qx%namest(qx%ncall) = 'FMBERN   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inpi1(n, ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (n >= 2 .and. n <= 26) then
          call fmber2(n, malocal, mresult, qx)
          kresult = 1
          return
      else if (n == 0) then
          call fmeq(malocal, mresult, qx)
          kresult = 1
          return
      else if (n == 1) then
          call fmdivi(malocal, -2, mresult, qx)
          kresult = 1
          return
      else if (malocal%mp(3) == 0) then
          call fmi2m(0, mresult, qx)
          kresult = 1
          return
      else if (mod(n, 2) == 1 .or. n < 0) then
          call fmi2m(0, mresult, qx)
          kresult = 1
          return
      endif

      if (n/2 > lmbern) then
          call fmi2m(1, ms, qx)
          do j = 2, 10000
             call fmi2m(j, mxy(2), qx)
             call fmipwr(mxy(2), -n, mxy(3), qx)
             call fmcsadd_r1(ms, mxy(3), qx)
             if (qx%kflag == 1) exit
          enddo
          call fmi2m(0, mr, qx)
          do j = 2, 2*lmbern, 2
             call fmi2m(n, mxy(3), qx)
             call fmipwr(mxy(3), -(j-1), mt, qx)
             call fmdivi_r1(mt, j, qx)
             call fmdivi_r1(mt, j-1, qx)
             if (j >= 2 .and. j <= 26) then
                 call fmber2(j, mt, mresult, qx)
             else
                 call fmbern_m1(j, mt, mxy, mresult, ndsave, mbern, ndbern, qx)
             endif
             call fmadd_r1(mr, mresult, qx)
             if (qx%kflag == 1 .and. j > 2) exit

             if (j == 2*lmbern) then
                 qx%kflag = -11
                 write (qx%kw,*) ' '
                 write (qx%kw,*) ' Too many Bernoulli numbers were needed in FMBERN.'
                 write (qx%kw,*) ' B(', n, ') was requested, and the current maximum is B(',  &
                              2*lmbern, ').'
                 write (qx%kw,*) ' '
                 write (qx%kw,*) ' Array MBERN is not large enough.'
                 write (qx%kw,*) ' '
                 call fmunknown(mresult, qx)
                 kresult = 1
                 return
             endif
          enddo
          call fmexp(mr, mxy(3), qx)
          qx%ndige = 0
          call fmi2m(-1, mxy(2), qx)
          call fmexp(mxy(2), mxy(4), qx)
          qx%ndige = 0
          call fmmpyi_r1(mxy(4), n, qx)
          call fmipwr(mxy(4), n, mxy(5), qx)
          call fmmpy(mxy(3), mxy(5), mxy(2), qx)
          call fmpi(mxy(3), qx)
          qx%ndigpi = 0
          call fmmpyi_r1(mxy(3), 2, qx)
          call fmmpyi_r1(mxy(3), n, qx)
          call fmsqrt(mxy(3), mxy(4), qx)
          call fmmpy_r1(mxy(2), mxy(4), qx)
          call fmpi(mxy(3), qx)
          qx%ndigpi = 0
          call fmmpyi_r1(mxy(3), 2, qx)
          call fmipwr(mxy(3), n, mxy(5), qx)
          call fmdiv_r2(mxy(2), mxy(5), qx)
          call fmmpy_r2(ms, mxy(5), qx)
          call fmmpyi(mxy(5), 2, mxy(4), qx)
          if (mod(n/2+1, 2) == 1) call fmnegate(mxy(4), qx)

          call fmmpy(mxy(4), malocal, mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine fmbern_sc

      subroutine fmbernoulli(n, ma, mbern, ndbern, qx)

!  ma = b(n)  where b(n) is the nth Bernoulli number.

      use fmvals_parallel
      implicit none

      type(multi) :: mbern(lmbern)
      integer :: ndbern(lmbern)
      integer :: n
      type(multi) :: ma
      intent (in) :: n
      intent (inout) :: ma
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(4), mresult

      call fmalloc(ma, qx%ndig+2, qx)
      call fmenter0(kovun, mxsave, ndsave, qx)
      call fmbernoulli_sc(n, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, ma, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call fmbernoulli_m1(n, mxy, mresult, mbern, ndbern, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, ma, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmbernoulli

      subroutine fmbernoulli_m1(n, mxy, mresult, mbern, ndbern, qx)

!  Method 1 for computing b(n).

      use fmvals_parallel
      implicit none

      type(multi) :: mbern(lmbern)
      integer :: ndbern(lmbern)
      type(multi) :: mxy(4), mresult
      integer :: n
      intent (in) :: n
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: j, k
      double precision :: b

      if (qx%ncall == 1) then
          k = int(5.0/qx%alogmt + 2.0 + (real(qx%ndig)*qx%alogmt)**0.35/qx%alogmt)
          call fmndig(max(qx%ndig+k, 3), qx)
      endif

!             For functions that sum series using Bernoulli numbers, n will normally be numbrn+2
!             here, or possibly 28 when numbrn is zero.  Check to see if this n is much larger than
!             numbrn and can be computed directly from the zeta(n) series without computing
!             and saving the intermediate Bernoulli numbers, otherwise call fmbern.

      b = qx%ndig*log(dble(qx%mbase))/6.91
      if (n > qx%numbrn+100 .and. n > b) then
          call fmi2m(1, mxy(1), qx)
          do j = 2, 10000
             call fmi2m(j, mxy(2), qx)
             call fmipwr(mxy(2), -n, mxy(3), qx)
             call fmcsadd_r1(mxy(1), mxy(3), qx)
             if (qx%kflag == 1) exit
          enddo
          call fmi2m(n, mxy(3), qx)
          call fmfact(mxy(3), mxy(2), qx)
          call fmmpy_r1(mxy(1), mxy(2), qx)
          call fmmpyi_r1(mxy(1), 2*(-1)**(n/2+1), qx)
          call fmpi(mxy(2), qx)
          qx%ndigpi = 0
          call fmmpyi_r1(mxy(2), 2, qx)
          call fmipwr(mxy(2), n, mxy(3), qx)
          call fmdiv(mxy(1), mxy(3), mxy(4), qx)
      else
          call fmi2m(1, mxy(1), qx)
          call fmbern(n, mxy(1), mxy(4), mbern, ndbern, qx)
      endif

      call fmeq(mxy(4), mresult, qx)

      return
      end subroutine fmbernoulli_m1

      subroutine fmbernoulli_sc(n, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = b(n).

!  kresult = 1 is returned if a special case gives the value of b(n).

      use fmvals_parallel
      implicit none

      type(multi) :: mresult
      integer :: n, kresult, ndsave
      intent (in) :: n, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j

      kresult = 0

      qx%namest(qx%ncall) = 'BERNOULLI'
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inpi(n, qx)
      call fmndig(j, qx)

      if ((mod(n, 2) == 1 .and. n > 2) .or. n < 0) then
          call fmi2m(0, mresult, qx)
          kresult = 1
      endif

      return
      end subroutine fmbernoulli_sc

      subroutine fmbesj(n, ma, mb, qx)

!  mb = bessel j(n,ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: n
      intent (in) :: n, ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(17), mresult, mretry

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmbesj_sc(n, ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      n_acc = nint(qx%ndig*qx%alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmbesj_m(n, ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry, qx)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmbesj

      subroutine fmbesj_m(n, ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)

!  Method selection for computing bessel j(n,ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(17), mresult
      integer :: n, ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: n, ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc
      type(fm_settings) :: qx

      double precision :: cbig, cklog, crhs, dbig, dklog, drhs, xe, xf, xlog
      integer :: iextra, j, k, kd, nmethd
      double precision, external :: fmdplg

      retry = .true.

      n_acc = nint(qx%ndig*qx%alogm2)
      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      mxy(1)%mp(1) = 1

!             Check for special cases.

      if (n < 0) then
          call fmunknown(mresult, qx)
          qx%kflag = -4
          retry = .false.
          return
      endif
      if (mxy(1)%mp(3) == 0) then
          if (n == 0) then
              call fmi2m(1, mresult, qx)
          else
              call fmi2m(0, mresult, qx)
          endif
          retry = .false.
          return
      endif
      call fmovun_xexf(mxy(1), xe, xf, qx)
      if (2*xe < -qx%ndig-1) then
          call fmdivi(mxy(1), 2, mxy(12), qx)
          call fmipwr(mxy(12), n, mxy(15), qx)
          call fmfcti(n, mxy(14), qx)
          call fmdiv(mxy(15), mxy(14), mresult, qx)
          if (ma%mp(1) == -1) then
              if (mod(n, 2) == 1) call fmnegate(mresult, qx)
          endif
          return
      endif

!             Determine which method to use.

!             nmethd = 1 means use the convergent series
!                    = 2 means use the asymptotic series

      nmethd = 1
      call fmabs(mxy(1), mxy(15), qx)
      if (mxy(15)%mp(2) == qx%munkno .and. mxy(15)%mp(5) < 0) then
          call fmovun_xexf(mxy(15), xe, xf, qx)
          cklog = xe
          xlog = xf
          xlog = log(xlog) + cklog*qx%dlogmb
      else
          cklog = mxy(15)%mp(2)
          mxy(15)%mp(2) = 0
          call fmm2dp(mxy(15), xlog, qx)
          xlog = log(xlog) + cklog*qx%dlogmb
      endif

!             c(k) is the absolute value of the kth term of the convergent series.
!             The number of terms needed at this precision is roughly the smallest k for which
!             |c(k)/c(0)| < mbase**(-ndig) * 10**(-20).
!             Check log(|c(k)|) < log(|c(0)|) - ndig*log(mbase) - 20*log(10)

      crhs = n*(xlog-qx%dlogtw) - fmdplg(dble(n+1), qx) - qx%ndig*qx%dlogmb - 20*qx%dlogtn

!             d(k) is the absolute value of the kth term of the asymptotic series.
!             The number of terms needed at this precision is roughly the smallest k for which
!             |d(k)/d(0)| < mbase**(-ndig) * 10**(-20).
!             Check log(|d(k)|) < log(|d(0)|) - ndig*log(mbase) - 20*log(10)

      drhs = n
      drhs = min(0.0d0, log(abs(4*drhs*drhs-1))-xlog-3*qx%dlogtw) - qx%ndig*qx%dlogmb - 20*qx%dlogtn - 50

      cbig = n*(xlog-qx%dlogtw) - fmdplg(dble(n+1), qx)
      dbig = 1
      k = 1
      do j = 0, 50
         k = 2*k
         cklog = (2*k+n)*xlog - (2*k+n)*qx%dlogtw - fmdplg(dble(k+1), qx) - fmdplg(dble(n+k+1),qx)
         cbig = max(cbig, cklog)
         if (cklog < crhs) then
             nmethd = 1
             cklog = min(0.0d0, n*xlog - n*qx%dlogtw - fmdplg(dble(n+1), qx))
             iextra = ((cbig-cklog)/qx%dlogmb + 3)*1.2 - 14/qx%alogmt
             call fmndig(qx%ndig+max(0, iextra), qx)
             call fmequ_r1(mxy(1), ndsave, qx%ndig, qx)
             exit
         endif
         kd = k/2
         if (n-2*kd < 0) then
             dklog = fmdplg(dble(2*kd+n+0.5), qx) + fmdplg(dble(2*kd-n+0.5),qx) -  &
                     2*kd*qx%dlogtw - 2*kd*xlog - fmdplg(dble(2*kd+1), qx)
         else
             dklog = fmdplg(dble(2*kd+n+0.5), qx) - fmdplg(dble(n-2*kd+0.5),qx) -  &
                     2*kd*qx%dlogtw - 2*kd*xlog - fmdplg(dble(2*kd+1), qx)
         endif
         dbig = max(dbig, dklog)
         if (dklog < drhs) then
             nmethd = 2
             iextra = (dbig/qx%dlogmb + 3)*1.2 - 14/qx%alogmt
             call fmndig(qx%ndig+max(0, iextra), qx)
             call fmequ_r1(mxy(1), ndsave, qx%ndig, qx)
             exit
         endif
      enddo
      if (numtry <= 0 .and. qx%ncall <= 1 .and. n <= 100) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig-2), qx)
      endif
      n_acc = nint(qx%ndig*qx%alogm2)

      if (nmethd == 1) then
          call fmbesj_m1(n, mxy, mresult, n_acc, qx)
      else if (nmethd == 2) then
          call fmbesj_m2(n, mxy, mresult, qx)
      endif

      if (ma%mp(1) == -1) then
          if (mod(n, 2) == 1) call fmnegate(mresult, qx)
      endif

      return
      end subroutine fmbesj_m

      subroutine fmbesj_m1(n, mxy, mresult, n_acc, qx)

!  Method 1 for computing bessel j(n,ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(17), mresult
      integer :: n, n_acc
      intent (in) :: n
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      integer :: j, j2, k, kl, ndig2, ndsav1, nterm
      double precision :: x, xe, xf
      type(multi) :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 1.  Sum the convergent series.
!                        j(n,x) = sum( (-1)**k (x/2)**(2k+n) / ( k! (n+k)! )

      call fmm2dp(mxy(1), x, qx)
      x = abs(x)
      call fmovun_xexf(mxy(1), xe, xf, qx)
      j2 = 2
      if (qx%kflag == 0 .and. x <= sqrt(huge(x))) then
          j2 = int(0.63*sqrt(fmnterms(x*x/4, 1, 1, n, 1, qx)) - 1)
      else if (xe < 0) then
          j2 = 2
      else if (xe > 0) then
          call fmunknown(mresult, qx)
          return
      endif
      j2 = max(2, min(j2+mod(j2, 2), ljsums))

!             mxy(1) is x
!             mxy(14) is x**2/4
!             mxy(15) is mxy(14)**j2
!             mxy(13) is the current term in the sum
!             mjsums holds the partial sums

      ndsav1 = qx%ndig
      call fmsqr(mxy(1), mxy(14), qx)
      call fmdivi_r1(mxy(14), 4, qx)
      call fmipwr(mxy(14), j2, mxy(15), qx)
      call fmi2m(1, mxy(10), qx)
      call fmfcti(n, mxy(11), qx)
      call fmdiv(mxy(10), mxy(11), mxy(13), qx)
      do j = 1, j2
         nterm = j
         call fmeq(mxy(13), mjsums(j), qx)
         if (j > 1) call fmcsdivi_r1(mxy(13), j, qx)
         call fmcsdivi_r1(mxy(13), n+j, qx)
      enddo

      nterm = j2
      ndig2 = qx%ndig
      kl = 1
      do while (kl == 1)
         call fmcsmpy_r1(mxy(13), mxy(15), qx)
         call fmndig(ndig2, qx)
         do j = 1, j2
            call fmndig(ndsav1, qx)
            call fmcsaddnn_r1(mjsums(j), mxy(13), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            else
                call fmndig(max(qx%ngrd22, ndsav1-int(mjsums(j)%mp(2) - mxy(13)%mp(2))), qx)
                call fmndig(min(ndsav1, qx%ndig), qx)
                if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                nterm = nterm + 1
                call fmcsdivi_r1(mxy(13), nterm, qx)
                call fmcsdivi_r1(mxy(13), n+nterm, qx)
            endif
         enddo
      enddo

!             Put the j2 concurrent sums back together.

      call fmndig(ndsav1, qx)
      call fmcsnsums(j2, mjsums, qx)
      call fmeq(mjsums(1), mxy(11), qx)
      mxy(14)%mp(1) = -1
      if (mxy(11)%mp(1) > 0) then
          call fmeq(mxy(11), mxy(16), qx)
          call fmi2m(0, mxy(17), qx)
      else
          call fmeq(mxy(11), mxy(17), qx)
          call fmi2m(0, mxy(16), qx)
      endif
      call fmeq(mxy(14), mxy(12), qx)
      do j = 1, j2-1
         call fmmpy(mxy(12), mjsums(j+1), mxy(3), qx)
         if (mxy(3)%mp(1) > 0) then
             call fmadd_r1(mxy(16), mxy(3), qx)
         else
             call fmadd_r1(mxy(17), mxy(3), qx)
         endif
         call fmmpy_r1(mxy(12), mxy(14), qx)
      enddo
      call fmadd(mxy(16), mxy(17), mjsums(1), qx)
      call fmcancel(mxy(16), mxy(17), mjsums(1), k, qx)
      n_acc = n_acc - k
      call fmcsdivi(mxy(1), 2, mxy(11), qx)
      call fmipwr(mxy(11), n, mxy(12), qx)
      call fmmpy_r1(mxy(12), mjsums(1), qx)

      call fmeq(mxy(12), mresult, qx)

      return
      end subroutine fmbesj_m1

      subroutine fmbesj_m2(n, mxy, mresult, qx)

!  Method 2 for computing bessel j(n,ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(17), mresult
      integer :: n
      intent (in) :: n
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: j, j2, k, kl, krsave, large, ndsav1, nterm, nterms
      double precision :: x, xe, xf
      type(multi) :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 2.  Sum the asymptotic series.
!                        j(n,x) = sqrt(2/(pi*x)) * (cos(c)*sum(a(k)) - sin(c)*sum(b(k)))
!                        c = x - n*pi/2 - pi/4
!                        a(k) = (-1)**k * gamma(2k+n+0.5) / ((2x)**(2k) * (2k)! * gamma(-2k+n+0.5))
!                        b(k) = (-1)**k * gamma(2k+n+1.5) /
!                               ( (2x)**(2k+1) * (2k+1)! * gamma(-2k+n-0.5) )

!             mxy(1) is x
!             mxy(15) is the current term for the series
!             mxy(14) is 1/x**2
!             mxy(13) is mxy(14)**j2
!             mxy(12) is the sum of the a(k) series
!             mxy(11) is the sum of the b(k) series

      ndsav1 = qx%ndig
      call fmm2dp(mxy(1), x, qx)
      x = abs(x)
      call fmovun_xexf(mxy(1), xe, xf, qx)
      j2 = 2
      if (qx%kflag == 0 .and. x <= sqrt(huge(x))) then
          j2 = nint(0.41*sqrt(fmnterms(2*x, 2, 1, n, 0, qx)) + 0.02)
      else if (xe > 0) then
          j2 = 1
      else if (xe < 0) then
          call fmunknown(mresult, qx)
          return
      endif
      j2 = max(1, min(ljsums, j2))

!             Sum the a(k) series.

      call fmi2m(1, mxy(15), qx)
      call fmsqr(mxy(1), mxy(14), qx)
      call fmdiv_r2(mxy(15), mxy(14), qx)
      call fmipwr(mxy(14), j2, mxy(13), qx)
      large = sqrt(mxbase+1.0d-3)
      nterm = 0
      do j = 1, j2
         nterm = j - 1
         call fmeq(mxy(15), mjsums(j), qx)
         if (3+4*nterm+2*n > large) then
             call fmcsmpyi_r1(mxy(15), 1+4*nterm-2*n, qx)
             call fmcsmpyi_r1(mxy(15), 3+4*nterm-2*n, qx)
             call fmcsmpyi_r1(mxy(15), 1+4*nterm+2*n, qx)
             call fmcsmpyi_r1(mxy(15), 3+4*nterm+2*n, qx)
             call fmcsdivi_r1(mxy(15), -128, qx)
             call fmcsdivi_r1(mxy(15), 1+nterm, qx)
             call fmcsdivi_r1(mxy(15), 1+2*nterm, qx)
         else
             call fmcsmpyi_r1(mxy(15), (1+4*nterm-2*n)*(3+4*nterm-2*n), qx)
             call fmcsmpyi_r1(mxy(15), (1+4*nterm+2*n)*(3+4*nterm+2*n), qx)
             call fmcsdivi_r1(mxy(15), -128, qx)
             call fmcsdivi_r1(mxy(15), (1+nterm)*(1+2*nterm), qx)
         endif
      enddo
      nterms = int(intmax/10)

      kl = 1
      do k = 1, nterms
         call fmcsmpy_r1(mxy(15), mxy(13), qx)
         do j = 1, j2
            call fmndig(ndsav1, qx)
            call fmadd_r1(mjsums(j), mxy(15), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            call fmndig(max(qx%ngrd22, ndsav1-int(mjsums(j)%mp(2) - mxy(15)%mp(2))), qx)
            call fmndig(min(ndsav1, qx%ndig), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
            nterm = nterm + 1
            if (3+4*nterm+2*n > large) then
                call fmcsmpyi_r1(mxy(15), 1+4*nterm-2*n, qx)
                call fmcsmpyi_r1(mxy(15), 3+4*nterm-2*n, qx)
                call fmcsmpyi_r1(mxy(15), 1+4*nterm+2*n, qx)
                call fmcsmpyi_r1(mxy(15), 3+4*nterm+2*n, qx)
                call fmcsdivi_r1(mxy(15), -128, qx)
                call fmcsdivi_r1(mxy(15), 1+nterm, qx)
                call fmcsdivi_r1(mxy(15), 1+2*nterm, qx)
            else
                call fmcsmpyi_r1(mxy(15), (1+4*nterm-2*n)*(3+4*nterm-2*n), qx)
                call fmcsmpyi_r1(mxy(15), (1+4*nterm+2*n)*(3+4*nterm+2*n), qx)
                call fmcsdivi_r1(mxy(15), -128, qx)
                call fmcsdivi_r1(mxy(15), (1+nterm)*(1+2*nterm), qx)
            endif
         enddo
         if (kl == 0) exit
         if (k == nterms) then
             call fmunknown(mresult, qx)
             return
         endif
      enddo

!             Put the j2 concurrent sums back together.

      call fmndig(ndsav1, qx)
      if (j2 > 1) then
          call fmeq(mjsums(j2), mxy(11), qx)
          do j = j2-1, 1, -1
             call fmcsmpy_r1(mxy(11), mxy(14), qx)
             call fmadd_r1(mxy(11), mjsums(j), qx)
          enddo
          call fmeq(mxy(11), mxy(12), qx)
      else
          call fmeq(mjsums(1), mxy(12), qx)
      endif

!             Sum the b(k) series.

      call fmndig(ndsav1, qx)
      if (n < large) then
          call fmi2m(4*n*n-1, mxy(15), qx)
      else
          call fmi2m(n, mxy(15), qx)
          call fmsqr_r1(mxy(15), qx)
          call fmmpyi_r1(mxy(15), 4, qx)
          call fmaddi(mxy(15), -1, qx)
      endif
      call fmcsdivi_r1(mxy(15), 8, qx)
      call fmdiv_r1(mxy(15), mxy(1), qx)
      nterm = 0
      do j = 1, j2
         nterm = j - 1
         call fmeq(mxy(15), mjsums(j), qx)
         if (3+4*nterm+2*n > large) then
             call fmcsmpyi_r1(mxy(15), 3+4*nterm-2*n, qx)
             call fmcsmpyi_r1(mxy(15), 5+4*nterm-2*n, qx)
             call fmcsmpyi_r1(mxy(15), 3+4*nterm+2*n, qx)
             call fmcsmpyi_r1(mxy(15), 5+4*nterm+2*n, qx)
             call fmcsdivi_r1(mxy(15), -128, qx)
             call fmcsdivi_r1(mxy(15), 1+nterm, qx)
             call fmcsdivi_r1(mxy(15), 3+2*nterm, qx)
         else
             call fmcsmpyi_r1(mxy(15), (3+4*nterm-2*n)*(5+4*nterm-2*n), qx)
             call fmcsmpyi_r1(mxy(15), (3+4*nterm+2*n)*(5+4*nterm+2*n), qx)
             call fmcsdivi_r1(mxy(15), -128, qx)
             call fmcsdivi_r1(mxy(15), (1+nterm)*(3+2*nterm), qx)
         endif
      enddo
      nterms = int(intmax/10)

      kl = 1
      do k = 1, nterms
         call fmcsmpy_r1(mxy(15), mxy(13), qx)
         do j = 1, j2
            call fmndig(ndsav1, qx)
            call fmadd_r1(mjsums(j), mxy(15), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            call fmndig(max(qx%ngrd22, ndsav1-int(mjsums(j)%mp(2) - mxy(15)%mp(2))), qx)
            call fmndig(min(ndsav1, qx%ndig), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
            nterm = nterm + 1
            if (3+4*nterm+2*n > large) then
                call fmcsmpyi_r1(mxy(15), 3+4*nterm-2*n, qx)
                call fmcsmpyi_r1(mxy(15), 5+4*nterm-2*n, qx)
                call fmcsmpyi_r1(mxy(15), 3+4*nterm+2*n, qx)
                call fmcsmpyi_r1(mxy(15), 5+4*nterm+2*n, qx)
                call fmcsdivi_r1(mxy(15), -128, qx)
                call fmcsdivi_r1(mxy(15), 1+nterm, qx)
                call fmcsdivi_r1(mxy(15), 3+2*nterm, qx)
            else
                call fmcsmpyi_r1(mxy(15), (3+4*nterm-2*n)*(5+4*nterm-2*n), qx)
                call fmcsmpyi_r1(mxy(15), (3+4*nterm+2*n)*(5+4*nterm+2*n), qx)
                call fmcsdivi_r1(mxy(15), -128, qx)
                call fmcsdivi_r1(mxy(15), (1+nterm)*(3+2*nterm), qx)
            endif
         enddo
         if (kl == 0) exit
         if (k == nterms) then
             call fmunknown(mresult, qx)
             return
         endif
      enddo

!             Put the j2 concurrent sums back together.

      call fmndig(ndsav1, qx)
      if (j2 > 1) then
          call fmeq(mjsums(j2), mxy(11), qx)
          do j = j2-1, 1, -1
             call fmcsmpy_r1(mxy(11), mxy(14), qx)
             call fmadd_r1(mxy(11), mjsums(j), qx)
          enddo
      else
          call fmeq(mjsums(1), mxy(11), qx)
      endif

!             To minimize cancellation error for very large x, with c = x - n*pi/2 - pi/4,
!             then we have
!             cos(c) = (k1*sin(x) + k2*cos(x)) / sqrt(2)
!             sin(c) = (k2*sin(x) - k1*cos(x)) / sqrt(2),  where
!             k1 = cos(n*pi/2) + sin(n*pi/2)
!             k2 = cos(n*pi/2) - sin(n*pi/2)
!             This is equivalent to
!             mod( n, 4 ) =   0   1   2   3
!                      k1 =   1   1  -1  -1
!                      k2 =   1  -1  -1   1

      krsave = qx%krad
      qx%krad = 1
      call fmcssn(mxy(1), mxy(7), mxy(8), qx)
      qx%krad = krsave
      k = mod(n, 4)
      if (k == 0) then
          call fmadd(mxy(8), mxy(7), mxy(9), qx)
          call fmsub(mxy(8), mxy(7), mxy(10), qx)
      else if (k == 1) then
          call fmsub(mxy(8), mxy(7), mxy(9), qx)
          call fmadd(mxy(8), mxy(7), mxy(10), qx)
          call fmnegate(mxy(10), qx)
      else if (k == 2) then
          call fmadd(mxy(8), mxy(7), mxy(9), qx)
          call fmnegate(mxy(9), qx)
          call fmsub(mxy(7), mxy(8), mxy(10), qx)
      else
          call fmsub(mxy(7), mxy(8), mxy(9), qx)
          call fmadd(mxy(8), mxy(7), mxy(10), qx)
      endif
      call fmi2m(2, mxy(5), qx)
      call fmsqrt(mxy(5), mxy(6), qx)
      call fmdiv(mxy(9), mxy(6), mxy(7), qx)
      call fmdiv(mxy(10), mxy(6), mxy(8), qx)

      call fmmpy_r2(mxy(7), mxy(12), qx)
      call fmmpy_r2(mxy(8), mxy(11), qx)
      call fmsub(mxy(12), mxy(11), mxy(9), qx)
      call fmpi(mxy(10), qx)
      qx%ndigpi = 0
      call fmmpy(mxy(10), mxy(1), mxy(8), qx)
      call fmi2m(2, mxy(7), qx)
      call fmdiv(mxy(7), mxy(8), mxy(6), qx)
      call fmsqrt(mxy(6), mxy(7), qx)
      call fmmpy(mxy(7), mxy(9), mxy(12), qx)

      call fmeq(mxy(12), mresult, qx)

      return
      end subroutine fmbesj_m2

      subroutine fmbesj_sc(n, ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = bessel j(n,ma).

!  kresult = 1 is returned if a special case gives the value of bessel j(n,ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(17), mresult
      integer :: n, kresult, ndsave
      intent (in) :: n, ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      double precision :: xe, xf, ye, yf
      integer :: j, k, krsave, nds
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMBESJ   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inpi1(n, ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      call fmovun_xexf(malocal, xe, xf, qx)
      if (qx%kround /= 1 .and. n >= 0 .and. xe < -ndsave) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          krsave = qx%kround
          qx%kround = 1
          nds = qx%ndig
          call fmndig(qx%ndig + qx%ngrd52, qx)
          call fmequ(malocal, mxy(1), nds, qx%ndig, qx)
          call fmdivi(mxy(1), 2, mxy(3), qx)
          call fmipwr(mxy(3), n, mxy(2), qx)
          call fmi2m(n, mxy(4), qx)
          call fmfact(mxy(4), mxy(5), qx)
          call fmdiv(mxy(2), mxy(5), mxy(4), qx)
          call fmmpy(mxy(4), mxy(3), mxy(5), qx)
          call fmmpy(mxy(5), mxy(3), mxy(6), qx)
          call fmdivi(mxy(6), n+1, mxy(5), qx)
          call fmovun_xexf(mxy(4), xe, xf, qx)
          call fmovun_xexf(mxy(5), ye, yf, qx)
          if (xe - ye > ndsave+1 .and. xe < qx%mexpov) then
              call fmequ(mxy(4), mxy(10), qx%ndig, nds, qx)
              call fmequ(mxy(4), mxy(6), qx%ndig, nds, qx)
              call fmequ(mxy(6), mxy(8), nds, qx%ndig, qx)
              call fmsub(mxy(4), mxy(8), mxy(6), qx)
              if (mxy(6)%mp(3) == 0) then
                  call fmequ(mxy(4), mxy(6), qx%ndig, nds, qx)
                  call fmequ(mxy(5), mxy(7), qx%ndig, nds, qx)
                  call fmndig(nds, qx)
                  qx%kround = krsave
                  call fmsub(mxy(6), mxy(7), mresult, qx)
              else
                  qx%kround = krsave
                  call fmequ(mxy(4), mresult, qx%ndig, nds, qx)
              endif
              qx%kflag = 0
              qx%ntrace = j
              qx%kwarn = k
              call fmndig(nds, qx)
              qx%kround = krsave
              kresult = 1
              return
          endif
          qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          call fmndig(nds, qx)
          qx%kround = krsave
      endif

      return
      end subroutine fmbesj_sc

      subroutine fmbesj2(n1, n2, x, array, qx)

!  array = (/  j(n1,x) , ..., j(n2,x)  /)

      use fmvals_parallel
      implicit none

      integer :: n1, n2
      type(multi) :: array(abs(n2-n1)+1), x
      intent (in) :: n1, n2, x
      intent (inout) :: array
      type(fm_settings) :: qx

      integer :: j, k, n, ndsave
      type(multi) :: mxy(4)

      n = abs(n2-n1) + 1
      do j = 1, n
         call fmalloc(array(j), qx%ndig+2, qx)
      enddo
      ndsave = qx%ndig

      if (n1 < 0 .or. n2 < 0) then
          do j = 1, size(array)
             call fmunknown(array(j), qx)
          enddo
          return
      endif

!             The last two entries in the array are done with calls to fmbesj.
!             The rest use this recurrence:

!             j(k-1,x) = 2*k*j(k,x) / x  -  j(k+1,x)

      call fmndig(qx%ndig + qx%ngrd52, qx)
      call fmequ(x, mxy(1), ndsave, qx%ndig, qx)
      k = max(n1, n2)
      call fmbesj(k, mxy(1), mxy(4), qx)
      call fmequ(mxy(4), array(n), qx%ndig, ndsave, qx)
      if (n <= 1) then
          qx%ndig = ndsave
          return
      endif
      call fmbesj(k-1, mxy(1), mxy(3), qx)
      call fmequ(mxy(3), array(n-1), qx%ndig, ndsave, qx)
      if (n <= 2) then
          qx%ndig = ndsave
          return
      endif

      do j = k-2, min(n1, n2), -1
         call fmmpyi(mxy(3), 2*(j+1), mxy(2), qx)
         call fmdiv_r1(mxy(2), mxy(1), qx)
         call fmsub_r1(mxy(2), mxy(4), qx)
         call fmequ(mxy(2), array(j-min(n1, n2)+1), qx%ndig, ndsave, qx)
         if (j == min(n1, n2)) exit
         call fmeq(mxy(3), mxy(4), qx)
         call fmeq(mxy(2), mxy(3), qx)
      enddo

!             Reverse the list if n2 < n1.

      if (n2 < n1) then
          qx%ndig = ndsave
          do j = 1, n/2
             call fmeq(array(j), mxy(4), qx)
             call fmeq(array(n+1-j), array(j), qx)
             call fmeq(mxy(4), array(n+1-j), qx)
          enddo
      endif

      qx%ndig = ndsave

      return
      end subroutine fmbesj2

      subroutine fmbesy(n, ma, mb, qx)

!  mb = bessel y(n,ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: n
      intent (in) :: n, ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(17), mresult, mretry

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmbesy_sc(n, ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      n_acc = nint(qx%ndig*qx%alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmbesy_m(n, ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry, qx)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmbesy

      subroutine fmbesy_m(n, ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)

!  Method selection for computing bessel y(n,ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(17), mresult
      integer :: n, ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: n, ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc
      type(fm_settings) :: qx

      double precision :: cbig, cklog, crhs, dbig, dklog, drhs, xe, xf, xlog
      integer :: iextra, j, k, kd, nmethd
      double precision, external :: fmdplg

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

      call fmovun_xexf(mxy(1), xe, xf, qx)
      if (2*xe <= -qx%ndig) then
          if (n == 0) then
              call fmdivi(mxy(1), 2, mxy(4), qx)
              call fmln(mxy(4), mxy(2), qx)
              qx%ndigli = 0
              call fmeulr(mxy(3), qx)
              qx%ndgeul = 0
              call fmadd_r2(mxy(2), mxy(3), qx)
              call fmmpyi_r1(mxy(3), 2, qx)
              call fmpi(mxy(1), qx)
              qx%ndigpi = 0
              call fmdiv(mxy(3), mxy(1), mresult, qx)
              retry = .false.
              return
          else
              call fmi2m(2, mxy(13), qx)
              call fmdiv(mxy(13), mxy(1), mxy(12), qx)
              call fmipwr(mxy(12), n, mxy(13), qx)
              call fmfcti(n-1, mxy(12), qx)
              call fmmpy(mxy(12), mxy(13), mxy(14), qx)
              call fmpi(mxy(12), qx)
              qx%ndigpi = 0
              call fmdiv(mxy(14), mxy(12), mresult, qx)
              call fmnegate(mresult, qx)
              retry = .false.
              return
          endif
      endif

!             Determine which method to use.

!             nmethd = 1 means use the convergent series
!                    = 2 means use the asymptotic series

      nmethd = 1
      call fmabs(mxy(1), mxy(12), qx)
      if (mxy(12)%mp(2) == qx%munkno .and. mxy(12)%mp(5) < 0) then
          call fmovun_xexf(mxy(12), xe, xf, qx)
          cklog = xe
          xlog = xf
          xlog = log(xlog) + cklog*qx%dlogmb
      else
          cklog = mxy(12)%mp(2)
          mxy(12)%mp(2) = 0
          call fmm2dp(mxy(12), xlog, qx)
          xlog = abs(xlog)
          xlog = log(xlog) + cklog*qx%dlogmb
      endif

!             c(k) is the absolute value of the kth term of the convergent series.  The psi terms
!                  grow logarithmically, so they are ignored for this estimate.
!             The number of terms needed at this precision is roughly the smallest k for which
!             |c(k)/c(0)| < mbase**(-ndig) * 10**(-20).
!             Check Log(|c(k)|) < Log(|c(0)|) - ndig*Log(mbase) - 20*Log(10)

      crhs = n*(xlog-qx%dlogtw) - fmdplg(dble(n+1), qx) - qx%ndig*qx%dlogmb - 20*qx%dlogtn

!             d(k) is the absolute value of the kth term of the asymptotic series.
!             The number of terms needed at this precision is roughly the smallest k for which
!             |d(k)/d(0)| < mbase**(-ndig) * 10**(-20).
!             Check Log(|d(k)|) < Log(|d(0)|) - ndig*Log(mbase) - 20*Log(10)

      drhs = n
      drhs = min(0.0d0, log(abs(4*drhs*drhs-1))-xlog-3*qx%dlogtw) - qx%ndig*qx%dlogmb - 20*qx%dlogtn - 50

      cbig = n*(xlog-qx%dlogtw) - fmdplg(dble(n+1), qx)
      dbig = 1
      k = 1
      do j = 0, 50
         k = 2*k
         cklog = (2*k+n)*xlog - (2*k+n)*qx%dlogtw - fmdplg(dble(k+1), qx) - fmdplg(dble(n+k+1),qx)
         cbig = max(cbig, cklog)
         if (cklog < crhs) then
             nmethd = 1
             cklog = min(0.0d0, n*xlog - n*qx%dlogtw - fmdplg(dble(n+1), qx))
             iextra = ((cbig-cklog)/qx%dlogmb + 3)*1.2 - 14/qx%alogmt
             call fmndig(qx%ndig+max(0, iextra), qx)
             n_acc = nint(qx%ndig*qx%alogm2)
             call fmequ_r1(mxy(1), ndsave, qx%ndig, qx)
             exit
         endif
         kd = k
         if (n-2*kd < 0) then
             dklog = fmdplg(dble(2*kd+n+0.5), qx) + fmdplg(dble(2*kd-n+0.5),qx) -  &
                     2*kd*qx%dlogtw - 2*kd*xlog - fmdplg(dble(2*kd+1), qx)
         else
             dklog = fmdplg(dble(2*kd+n+0.5), qx) - fmdplg(dble(n-2*kd+0.5),qx) -  &
                     2*kd*qx%dlogtw - 2*kd*xlog - fmdplg(dble(2*kd+1), qx)
         endif
         dbig = max(dbig, dklog)
         if (dklog < drhs) then
             nmethd = 2
             iextra = (dbig/qx%dlogmb + 3)*1.2 - 14/qx%alogmt
             call fmndig(qx%ndig+max(0, iextra), qx)
             n_acc = nint(qx%ndig*qx%alogm2)
             call fmequ_r1(mxy(1), ndsave, qx%ndig, qx)
             exit
         endif
      enddo
      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig-2), qx)
      endif
      n_acc = nint(qx%ndig*qx%alogm2)

      if (nmethd == 1) then
          call fmbesy_m1(n, mxy, mresult, n_acc, qx)
      else if (nmethd == 2) then
          call fmbesy_m2(n, mxy, mresult, qx)
      endif

      return
      end subroutine fmbesy_m

      subroutine fmbesy_m1(n, mxy, mresult, n_acc, qx)

!  Method 1 for computing bessel y(n,ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(17), mresult
      integer :: n, n_acc
      intent (in) :: n
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      integer :: j, k, kl
      double precision :: x, xe, xf

!             Method 1.  Sum the convergent series.
!                        y(n,x) = (-1/pi)*
!                        sum( (-1)**k (psi(k+1) + psi(n+k+1)) (x/2)**(2k+n) / ( k! (n+k)! )
!                        - (1/pi)*sum( (n-k-1)! (x/2)**(2k-n) / k! ) + (2/pi)*ln(x/2)*j(n,x)

!                        The first sum above (involving psi) runs from k=0 to infinity, but the
!                        second sum is finite, for k=0 to k=n-1.

      call fmm2dp(mxy(1), x, qx)

!             Sum( (-1)**k (psi(k+1) + psi(n+k+1)) (x/2)**(2k+n) / ( k! (n+k)! )

!             mxy(1) is x
!             mxy(11) is -x**2/4
!             mxy(13) is psi(k+1)
!             mxy(14) is psi(n+k+1)
!             mxy(10) is the current value of (-1)**k (x/2)**(2k+n) / ( k! (n+k)! )
!             mxy(12) holds the partial sum

      call fmeulr(mxy(13), qx)
      qx%ndgeul = 0
      mxy(13)%mp(1) = -1
      if (n < 5000) then
          call fmeq(mxy(13), mxy(14), qx)
          if (n > 0) then
              call fmi2m(1, mxy(7), qx)
              do j = 1, n
                 call fmcsdivi(mxy(7), j, mxy(8), qx)
                 call fmadd_r1(mxy(14), mxy(8), qx)
              enddo
          endif
      else
          call fmi2m(n+1, mxy(12), qx)
          call fmpsi(mxy(12), mxy(14), qx)
      endif
      call fmcsdivi(mxy(1), 2, mxy(8), qx)
      call fmipwr(mxy(8), n, mxy(9), qx)
      call fmsqr(mxy(1), mxy(11), qx)
      call fmcsdivi_r1(mxy(11), 4, qx)
      mxy(11)%mp(1) = -1
      call fmi2m(1, mxy(7), qx)
      call fmfcti(n, mxy(8), qx)
      call fmadd(mxy(13), mxy(14), mxy(6), qx)
      call fmdiv(mxy(6), mxy(8), mxy(2), qx)
      call fmmpy(mxy(2), mxy(9), mxy(3), qx)
      call fmeq(mxy(3), mxy(12), qx)
      if (mxy(12)%mp(1) > 0) then
          call fmeq(mxy(12), mxy(16), qx)
          call fmi2m(0, mxy(17), qx)
      else
          call fmeq(mxy(12), mxy(17), qx)
          call fmi2m(0, mxy(16), qx)
      endif
      call fmovun_xexf(mxy(3), xe, xf, qx)
      kl = 1
      do while (kl == 1)
         kl = 0
         if (xe <= qx%mexpun) then
             call fmeq(mxy(3), mxy(9), qx)
             call fmnegate(mxy(9), qx)
             if (mxy(9)%mp(1) > 0) then
                 call fmeq(mxy(9), mxy(16), qx)
                 call fmi2m(0, mxy(17), qx)
             else
                 call fmadd_r1(mxy(9), mxy(17), qx)
                 call fmi2m(0, mxy(16), qx)
             endif
             exit
         endif
         call fmovun_xexf(mxy(1), xe, xf, qx)
         if (xe < -qx%ndig) then
             call fmpi(mxy(6), qx)
             qx%ndigpi = 0
             mxy(6)%mp(1) = -1
             call fmdiv(mxy(3), mxy(6), mxy(9), qx)
             if (mxy(9)%mp(1) > 0) then
                 call fmeq(mxy(9), mxy(16), qx)
                 call fmi2m(0, mxy(17), qx)
             else
                 call fmadd_r1(mxy(9), mxy(17), qx)
                 call fmi2m(0, mxy(16), qx)
             endif
             exit
         endif
         call fmdiv(mxy(9), mxy(8), mxy(10), qx)
         call fmi2m(1, mxy(4), qx)

         do k = 1, 10**8
            call fmmpy_r1(mxy(10), mxy(11), qx)
            call fmdivi_r1(mxy(10), k, qx)
            call fmdivi_r1(mxy(10), n+k, qx)
            call fmdivi(mxy(4), k, mxy(3), qx)
            call fmadd_r1(mxy(13), mxy(3), qx)
            call fmdivi(mxy(4), n+k, mxy(3), qx)
            call fmadd_r1(mxy(14), mxy(3), qx)
            call fmadd(mxy(13), mxy(14), mxy(3), qx)
            call fmmpy_r1(mxy(3), mxy(10), qx)
            if (mxy(3)%mp(1) > 0) then
                call fmadd_r1(mxy(16), mxy(3), qx)
            else
                call fmadd_r1(mxy(17), mxy(3), qx)
            endif
            call fmadd_r1(mxy(12), mxy(3), qx)
            if (qx%kflag /= 0) exit
         enddo
         call fmpi(mxy(6), qx)
         qx%ndigpi = 0
         mxy(6)%mp(1) = -1
         call fmdiv_r1(mxy(12), mxy(6), qx)
         call fmdiv_r1(mxy(16), mxy(6), qx)
         call fmdiv_r1(mxy(17), mxy(6), qx)
      enddo

!             Sum( (n-k-1)! (x/2)**(2k-n) / k! )

      if (n > 0) then
          mxy(11)%mp(1) = 1
          call fmcsdivi(mxy(1), 2, mxy(6), qx)
          call fmipwr(mxy(6), -n, mxy(7), qx)
          call fmfcti(n-1, mxy(6), qx)
          call fmcsmpy_r1(mxy(7), mxy(6), qx)
          call fmeq(mxy(7), mxy(8), qx)
          if (mxy(8)%mp(2) == qx%mexpov) then
              mxy(8)%mp(1) = -1
          else
              do j = 1, n-1
                 call fmcsmpy_r1(mxy(7), mxy(11), qx)
                 call fmcsdivi_r1(mxy(7), n-j, qx)
                 call fmcsdivi_r1(mxy(7), j, qx)
                 call fmadd_r1(mxy(8), mxy(7), qx)
              enddo
              call fmpi(mxy(6), qx)
              qx%ndigpi = 0
              mxy(6)%mp(1) = -1
              call fmdiv_r1(mxy(8), mxy(6), qx)
          endif

          if (mxy(8)%mp(1) > 0) then
              call fmadd_r1(mxy(16), mxy(8), qx)
          else
              call fmadd_r1(mxy(17), mxy(8), qx)
          endif
      endif

!             Add the j(n,x) term.

      call fmbesj(n, mxy(1), mxy(15), qx)
      if (mxy(15)%mp(2) == qx%mexpun) then
          mxy(15)%mp(1) = -1
      else
          call fmcsdivi(mxy(1), 2, mxy(6), qx)
          call fmln(mxy(6), mxy(7), qx)
          qx%ndigli = 0
          call fmmpy(mxy(15), mxy(7), mxy(8), qx)
          call fmpi(mxy(6), qx)
          qx%ndigpi = 0
          call fmdiv_r1(mxy(8), mxy(6), qx)
          call fmcsmpyi(mxy(8), 2, mxy(15), qx)
      endif

      if (mxy(15)%mp(1) > 0) then
          call fmadd_r1(mxy(16), mxy(15), qx)
      else
          call fmadd_r1(mxy(17), mxy(15), qx)
      endif
      call fmadd(mxy(16), mxy(17), mxy(9), qx)
      call fmcancel(mxy(16), mxy(17), mxy(9), k, qx)
      n_acc = n_acc - k

      call fmeq(mxy(9), mresult, qx)

      return
      end subroutine fmbesy_m1

      subroutine fmbesy_m2(n, mxy, mresult, qx)

!  Method 2 for computing bessel y(n,ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(17), mresult
      integer :: n
      intent (in) :: n
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: j, j2, k, kl, krsave, large, ndsav1, nterm, nterms
      double precision :: x, xe, xf
      type(multi) :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 2.  Sum the asymptotic series.
!                        y(n,x) = sqrt(2/(pi*x))*(sin(c)*sum(a(k)) + cos(c)*sum(b(k)))
!                        c = x - n*pi/2 - pi/4
!                        a(k) = (-1)**k * gamma(2k+n+0.5) / ( (2x)**(2k)*(2k)! * gamma(-2k+n+0.5) )
!                        b(k) = (-1)**k * gamma(2k+n+1.5) /
!                               ( (2x)**(2k+1) * (2k+1)! * gamma(-2k+n-0.5) )

!             mxy(1) is x
!             mxy(12) is the current term for the series
!             mxy(11) is 1/x**2
!             mxy(10) is mxy(11)**j2
!             mxy(9) is the sum of the a(k) series
!             mxy(8) is the sum of the b(k) series

      ndsav1 = qx%ndig
      call fmm2dp(mxy(1), x, qx)
      x = abs(x)
      call fmovun_xexf(mxy(1), xe, xf, qx)
      j2 = 2
      if (qx%kflag == 0 .and. x <= sqrt(huge(x))) then
          j2 = nint(0.41*sqrt(fmnterms(2*x, 2, 1, n, 0, qx)) + 0.02)
      else if (xe > 0) then
          j2 = 1
      else if (xe < 0) then
          call fmunknown(mresult, qx)
          return
      endif
      j2 = max(1, min(ljsums, j2))

!             Sum the a(k) series.

      call fmi2m(1, mxy(12), qx)
      call fmsqr(mxy(1), mxy(11), qx)
      call fmdiv_r2(mxy(12), mxy(11), qx)
      call fmipwr(mxy(11), j2, mxy(10), qx)
      large = sqrt(mxbase+1.0d-3)
      nterm = 0
      do j = 1, j2
         nterm = j - 1
         call fmeq(mxy(12), mjsums(j), qx)
         if (3+4*nterm+2*n > large) then
             call fmcsmpyi_r1(mxy(12), 1+4*nterm-2*n, qx)
             call fmcsmpyi_r1(mxy(12), 3+4*nterm-2*n, qx)
             call fmcsmpyi_r1(mxy(12), 1+4*nterm+2*n, qx)
             call fmcsmpyi_r1(mxy(12), 3+4*nterm+2*n, qx)
             call fmcsdivi_r1(mxy(12), -128, qx)
             call fmcsdivi_r1(mxy(12), 1+nterm, qx)
             call fmcsdivi_r1(mxy(12), 1+2*nterm, qx)
         else
             call fmcsmpyi_r1(mxy(12), (1+4*nterm-2*n)*(3+4*nterm-2*n), qx)
             call fmcsmpyi_r1(mxy(12), (1+4*nterm+2*n)*(3+4*nterm+2*n), qx)
             call fmcsdivi_r1(mxy(12), -128, qx)
             call fmcsdivi_r1(mxy(12), (1+nterm)*(1+2*nterm), qx)
         endif
      enddo
      nterms = int(intmax/10)

      kl = 1
      do k = 1, nterms
         call fmcsmpy_r1(mxy(12), mxy(10), qx)
         do j = 1, j2
            call fmndig(ndsav1, qx)
            call fmadd_r1(mjsums(j), mxy(12), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            call fmndig(max(qx%ngrd22, ndsav1-int(mjsums(j)%mp(2) - mxy(12)%mp(2))), qx)
            call fmndig(min(ndsav1, qx%ndig), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
            nterm = nterm + 1
            if (3+4*nterm+2*n > large) then
                call fmcsmpyi_r1(mxy(12), 1+4*nterm-2*n, qx)
                call fmcsmpyi_r1(mxy(12), 3+4*nterm-2*n, qx)
                call fmcsmpyi_r1(mxy(12), 1+4*nterm+2*n, qx)
                call fmcsmpyi_r1(mxy(12), 3+4*nterm+2*n, qx)
                call fmcsdivi_r1(mxy(12), -128, qx)
                call fmcsdivi_r1(mxy(12), 1+nterm, qx)
                call fmcsdivi_r1(mxy(12), 1+2*nterm, qx)
            else
                call fmcsmpyi_r1(mxy(12), (1+4*nterm-2*n)*(3+4*nterm-2*n), qx)
                call fmcsmpyi_r1(mxy(12), (1+4*nterm+2*n)*(3+4*nterm+2*n), qx)
                call fmcsdivi_r1(mxy(12), -128, qx)
                call fmcsdivi_r1(mxy(12), (1+nterm)*(1+2*nterm), qx)
            endif
         enddo
         if (kl == 0) exit
         if (k == nterms) then
             call fmunknown(mresult, qx)
             return
         endif
      enddo

!             Put the j2 concurrent sums back together.

      call fmndig(ndsav1, qx)
      if (j2 > 1) then
          call fmeq(mjsums(j2), mxy(8), qx)
          do j = j2-1, 1, -1
             call fmcsmpy_r1(mxy(8), mxy(11), qx)
             call fmadd_r1(mxy(8), mjsums(j), qx)
          enddo
          call fmeq(mxy(8), mxy(9), qx)
      else
          call fmeq(mjsums(1), mxy(9), qx)
      endif

!             Sum the b(k) series.

      call fmndig(ndsav1, qx)
      if (n < large) then
          call fmi2m(4*n*n-1, mxy(12), qx)
      else
          call fmi2m(n, mxy(12), qx)
          call fmsqr_r1(mxy(12), qx)
          call fmcsmpyi_r1(mxy(12), 4, qx)
          call fmaddi(mxy(12), -1, qx)
      endif
      call fmcsdivi_r1(mxy(12), 8, qx)
      call fmdiv_r1(mxy(12), mxy(1), qx)
      do j = 1, j2
         nterm = j - 1
         call fmeq(mxy(12), mjsums(j), qx)
         if (3+4*nterm+2*n > large) then
             call fmcsmpyi_r1(mxy(12), 3+4*nterm-2*n, qx)
             call fmcsmpyi_r1(mxy(12), 5+4*nterm-2*n, qx)
             call fmcsmpyi_r1(mxy(12), 3+4*nterm+2*n, qx)
             call fmcsmpyi_r1(mxy(12), 5+4*nterm+2*n, qx)
             call fmcsdivi_r1(mxy(12), -128, qx)
             call fmcsdivi_r1(mxy(12), 1+nterm, qx)
             call fmcsdivi_r1(mxy(12), 3+2*nterm, qx)
         else
             call fmcsmpyi_r1(mxy(12), (3+4*nterm-2*n)*(5+4*nterm-2*n), qx)
             call fmcsmpyi_r1(mxy(12), (3+4*nterm+2*n)*(5+4*nterm+2*n), qx)
             call fmcsdivi_r1(mxy(12), -128, qx)
             call fmcsdivi_r1(mxy(12), (1+nterm)*(3+2*nterm), qx)
         endif
      enddo
      nterms = int(intmax/10)

      kl = 1
      do k = 1, nterms
         call fmcsmpy_r1(mxy(12), mxy(10), qx)
         do j = 1, j2
            call fmndig(ndsav1, qx)
            call fmadd_r1(mjsums(j), mxy(12), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            call fmndig(max(qx%ngrd22, ndsav1-int(mjsums(j)%mp(2) - mxy(12)%mp(2))), qx)
            call fmndig(min(ndsav1, qx%ndig), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
            nterm = nterm + 1
            if (3+4*nterm+2*n > large) then
                call fmcsmpyi_r1(mxy(12), 3+4*nterm-2*n, qx)
                call fmcsmpyi_r1(mxy(12), 5+4*nterm-2*n, qx)
                call fmcsmpyi_r1(mxy(12), 3+4*nterm+2*n, qx)
                call fmcsmpyi_r1(mxy(12), 5+4*nterm+2*n, qx)
                call fmcsdivi_r1(mxy(12), -128, qx)
                call fmcsdivi_r1(mxy(12), 1+nterm, qx)
                call fmcsdivi_r1(mxy(12), 3+2*nterm, qx)
            else
                call fmcsmpyi_r1(mxy(12), (3+4*nterm-2*n)*(5+4*nterm-2*n), qx)
                call fmcsmpyi_r1(mxy(12), (3+4*nterm+2*n)*(5+4*nterm+2*n), qx)
                call fmcsdivi_r1(mxy(12), -128, qx)
                call fmcsdivi_r1(mxy(12), (1+nterm)*(3+2*nterm), qx)
            endif
         enddo
         if (kl == 0) exit
         if (k == nterms) then
             call fmunknown(mresult, qx)
             return
         endif
      enddo

!             Put the j2 concurrent sums back together.

      call fmndig(ndsav1, qx)
      if (j2 > 1) then
          call fmeq(mjsums(j2), mxy(8), qx)
          do j = j2-1, 1, -1
             call fmcsmpy_r1(mxy(8), mxy(11), qx)
             call fmadd_r1(mxy(8), mjsums(j), qx)
          enddo
      else
          call fmeq(mjsums(1), mxy(8), qx)
      endif

!             To minimize cancellation error for very large x, with c = x - n*Pi/2 - Pi/4,
!             then we have
!             cos(c) = (k1*sin(x) + k2*cos(x)) / sqrt(2)
!             sin(c) = (k2*sin(x) - k1*cos(x)) / sqrt(2),  where
!             k1 = cos(n*Pi/2) + sin(n*Pi/2)
!             k2 = cos(n*Pi/2) - sin(n*Pi/2)
!             This is equivalent to
!             Mod( n, 4 ) =   0   1   2   3
!                      k1 =   1   1  -1  -1
!                      k2 =   1  -1  -1   1

      krsave = qx%krad
      qx%krad = 1
      call fmcssn(mxy(1), mxy(4), mxy(5), qx)
      qx%krad = krsave
      k = mod(n, 4)
      if (k == 0) then
          call fmadd(mxy(5), mxy(4), mxy(6), qx)
          call fmsub(mxy(5), mxy(4), mxy(7), qx)
      else if (k == 1) then
          call fmsub(mxy(5), mxy(4), mxy(6), qx)
          call fmadd(mxy(5), mxy(4), mxy(7), qx)
          call fmnegate(mxy(7), qx)
      else if (k == 2) then
          call fmadd(mxy(5), mxy(4), mxy(6), qx)
          call fmnegate(mxy(6), qx)
          call fmsub(mxy(4), mxy(5), mxy(7), qx)
      else
          call fmsub(mxy(4), mxy(5), mxy(6), qx)
          call fmadd(mxy(5), mxy(4), mxy(7), qx)
      endif
      call fmi2m(2, mxy(2), qx)
      call fmsqrt(mxy(2), mxy(3), qx)
      call fmdiv(mxy(6), mxy(3), mxy(4), qx)
      call fmdiv(mxy(7), mxy(3), mxy(5), qx)

      call fmmpy_r2(mxy(5), mxy(9), qx)
      call fmmpy_r2(mxy(4), mxy(8), qx)
      call fmadd(mxy(9), mxy(8), mxy(6), qx)
      call fmpi(mxy(7), qx)
      qx%ndigpi = 0
      call fmmpy(mxy(7), mxy(1), mxy(5), qx)
      call fmi2m(2, mxy(4), qx)
      call fmdiv(mxy(4), mxy(5), mxy(3), qx)
      call fmsqrt(mxy(3), mxy(4), qx)
      call fmmpy(mxy(4), mxy(6), mxy(9), qx)

      call fmeq(mxy(9), mresult, qx)

      return
      end subroutine fmbesy_m2

      subroutine fmbesy_sc(n, ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = bessel y(n,ma).

!  kresult = 1 is returned if a special case gives the value of bessel y(n,ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mresult
      integer :: n, kresult, ndsave
      intent (in) :: n, ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMBESY   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inpi1(n, ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (n < 0 .or. malocal%mp(3) == 0 .or. malocal%mp(1) == -1) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine fmbesy_sc

      subroutine fmbesy2(n1, n2, x, array, qx)

!  array = (/  y(n1,x) , ..., y(n2,x)  /)


      use fmvals_parallel
      implicit none

      integer :: n1, n2
      type(multi) :: array(abs(n2-n1)+1), x
      intent (in) :: n1, n2, x
      intent (inout) :: array
      type(fm_settings) :: qx

      integer :: j, k, n, ndsave
      type(multi) :: mxy(4)

      n = abs(n2-n1) + 1
      do j = 1, n
         call fmalloc(array(j), qx%ndig+2, qx)
      enddo
      ndsave = qx%ndig

      if (n1 < 0 .or. n2 < 0) then
          do j = 1, size(array)
             call fmunknown(array(j), qx)
          enddo
          return
      endif

!             The first two entries in the array are done with calls to fmbesy.
!             The rest use this recurrence:

!             y(k+1,x) = 2*k*y(k,x) / x  -  y(k-1,x)

      call fmndig(qx%ndig + qx%ngrd52, qx)
      call fmequ(x, mxy(1), ndsave, qx%ndig, qx)
      k = min(n1, n2)
      call fmbesy(k, mxy(1), mxy(4), qx)
      call fmequ(mxy(4), array(1), qx%ndig, ndsave, qx)
      if (n <= 1) then
          qx%ndig = ndsave
          return
      endif
      call fmbesy(k+1, mxy(1), mxy(3), qx)
      call fmequ(mxy(3), array(2), qx%ndig, ndsave, qx)
      if (n <= 2) then
          qx%ndig = ndsave
          return
      endif

      do j = k+2, max(n1, n2)
         call fmmpyi(mxy(3), 2*(j-1), mxy(2), qx)
         call fmdiv_r1(mxy(2), mxy(1), qx)
         call fmsub_r1(mxy(2), mxy(4), qx)
         call fmequ(mxy(2), array(j-k+1), qx%ndig, ndsave, qx)
         if (j == min(n1, n2)) exit
         call fmeq(mxy(3), mxy(4), qx)
         call fmeq(mxy(2), mxy(3), qx)
      enddo

!             Reverse the list if n2 < n1.

      if (n2 < n1) then
          qx%ndig = ndsave
          do j = 1, n/2
             call fmeq(array(j), mxy(4), qx)
             call fmeq(array(n+1-j), array(j), qx)
             call fmeq(mxy(4), array(n+1-j), qx)
          enddo
      endif

      qx%ndig = ndsave

      return
      end subroutine fmbesy2

      subroutine fmbeta(ma, mb, mc, qx)

!  mc = beta(ma,mb)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(22), mresult

      call fmalloc(mc, qx%ndig+2, qx)
      call fmenter2(ma, mb, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmbeta_sc(ma, mb, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mc, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call fmbeta_m1(ma, mb, mxy, mresult, mxsave, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mc, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmbeta

      subroutine fmbeta_m1(ma, mb, mxy, mresult, mxsave, ndsave, qx)

!  Method 1 for computing beta(ma,mb).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mxy(22), mresult
      integer :: ndsave
      real (kind(1.0d0)) :: mxsave
      intent (in) :: ma, mb, mxsave, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mzero, mt1
      real :: x
      double precision :: d
      integer :: iextra, j, jr, k, k10, k11, kb, kc, kflkb, kflnkb, kl,  &
                 kwrnsv, n, nb, nbot, ndsav2, nk, nkb
      type(multi) :: malocal, mblocal
      logical, external :: fmcomp

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)
      call fmequ(mb, mblocal, ndsave, qx%ndig, qx)

      if ((ma%mp(2) == qx%mexpov .or. (ma%mp(2) == qx%munkno .and. ma%mp(5) < 0 .and.  &
          ma%mp(4) > qx%ndig)) .and. ma%mp(1) > 0) then
          if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          if (mb%mp(2) == qx%mexpov .and. mb%mp(1) > 0) then
              call fmunderflow(1, mresult, qx)
              qx%kflag = -6
              mresult%mp(4) = -huge(qx%mbase)/d
              mresult%mp(5) = -(1.0d0 - epsilon(1.0d0)) * maxint
          else
              call fmgam(mblocal, mxy(2), qx)
              if (mxy(2)%mp(2) == qx%mexpov .and. mxy(2)%mp(4) == huge(qx%mbase)/d) then
                  call fmunderflow(1, mresult, qx)
                  qx%kflag = -6
                  mresult%mp(4) = -huge(qx%mbase)/d
                  mresult%mp(5) = -(1.0d0 - epsilon(1.0d0)) * maxint
              else
                  call fmpwr(malocal, mblocal, mxy(3), qx)
                  call fmdiv(mxy(2), mxy(3), mresult, qx)
              endif
          endif
          if (mresult%mp(2) == qx%munkno)  qx%kflag = -4
          return
      else if ((mb%mp(2) == qx%mexpov .or. (mb%mp(2) == qx%munkno .and.  &
               mb%mp(5) < 0 .and. mb%mp(4) > qx%ndig)) .and. mb%mp(1) > 0) then
          if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          call fmgam(malocal, mxy(2), qx)
          if (mxy(2)%mp(2) == qx%mexpov .and. mxy(2)%mp(4) == huge(qx%mbase)/d) then
              call fmunderflow(1, mresult, qx)
              qx%kflag = -6
              mresult%mp(4) = -huge(qx%mbase)/d
              mresult%mp(5) = -(1.0d0 - epsilon(1.0d0)) * maxint
          else
              call fmpwr(mblocal, malocal, mxy(3), qx)
              call fmdiv(mxy(2), mxy(3), mresult, qx)
          endif
          if (mresult%mp(2) == qx%munkno)  qx%kflag = -4
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      kl = 1
      do while (kl == 1)
         kl = 0
         if (qx%kround /= 1 .and. (ma%mp(2) < -qx%ndig .or. mb%mp(2) < -qx%ndig) .and.  &
             ma%mp(2) > -qx%mxexp .and. mb%mp(2) > -qx%mxexp                  .and.     &
             ma%mp(2) /= qx%munkno .and. mb%mp(2) /= qx%munkno) then
             j = qx%ntrace
             qx%ntrace = 0
             k = qx%kwarn
             qx%kwarn = 0
             ndsav2 = qx%ndig
             call fmndig(2*qx%ndig + qx%ngrd52, qx)
             if (ma%mp(2) <= mb%mp(2)) then
                 call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
                 call fmequ(mb, mxy(2), ndsave, qx%ndig, qx)
             else
                 call fmequ(ma, mxy(2), ndsave, qx%ndig, qx)
                 call fmequ(mb, mxy(1), ndsave, qx%ndig, qx)
             endif
             call fmabs(mxy(1), mxy(3), qx)
             call fmabs(mxy(2), mxy(4), qx)
             call fmadd(mxy(3), mxy(4), mxy(7), qx)
             call fmsqr(mxy(7), mxy(3), qx)
             if (mxy(3)%mp(2) <= mxy(7)%mp(2) - ndsave) then
                 call fmi2m(1, mxy(3), qx)
                 call fmdiv(mxy(3), mxy(1), mxy(4), qx)
                 call fmdiv(mxy(3), mxy(2), mxy(6), qx)
                 if (mxy(4)%mp(2) < qx%mexpov) then
                     call fmadd(mxy(1), mxy(2), mxy(7), qx)
                     call fmpi(mxy(8), qx)
                     qx%ndigpi = 0
                     call fmsqr_r1(mxy(8), qx)
                     call fmmpy(mxy(7), mxy(8), mxy(9), qx)
                     call fmdivi_r1(mxy(9), 6, qx)
                     call fmsub(mxy(6), mxy(9), mxy(10), qx)
                     call fmadd_r2(mxy(4), mxy(10), qx)
                     call fmeq(mxy(10), mresult, qx)
                     qx%kflag = 0
                     qx%ntrace = j
                     qx%kwarn = k
                     if (mresult%mp(2) < -qx%mxexp .or. mresult%mp(2) > qx%mxexp+1) then
                         call fmndig(ndsav2, qx)
                         exit
                     endif
                     return
                 endif
             else
                 call fmi2m(1, mxy(3), qx)
                 call fmsub(mxy(2), mxy(3), mxy(4), qx)
                 if (mxy(4)%mp(3) == 0) then
                     call fmdiv(mxy(3), mxy(1), mresult, qx)
                     qx%kflag = 0
                     qx%ntrace = j
                     qx%kwarn = k
                     if (mresult%mp(2) < -qx%mxexp .or. mresult%mp(2) > qx%mxexp+1) then
                         call fmndig(ndsav2, qx)
                         exit
                     endif
                     return
                 else
                     call fmdiv(mxy(3), mxy(1), mxy(4), qx)
                     call fmeulr(mxy(5), qx)
                     qx%ndgeul = 0
                     call fmpsi(mxy(2), mxy(6), qx)
                     call fmadd(mxy(5), mxy(6), mxy(7), qx)
                     call fmsub(mxy(4), mxy(7), mxy(8), qx)
                     call fmeq(mxy(8), mresult, qx)
                     qx%kflag = 0
                     qx%ntrace = j
                     qx%kwarn = k
                     if (mresult%mp(2) < -qx%mxexp .or. mresult%mp(2) > qx%mxexp+1) then
                         call fmndig(ndsav2, qx)
                         exit
                     endif
                     return
                 endif
             endif
             qx%kflag = 0
             qx%ntrace = j
             qx%kwarn = k
         endif
      enddo

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      call fmequ(mb, mxy(2), ndsave, qx%ndig, qx)
      call fmeq(mxy(1), mxy(21), qx)

      jr = qx%kround
      qx%kround = 1
      call fmadd(mxy(1), mxy(2), mxy(17), qx)
      qx%kround = jr
      if (mxy(1)%mp(3) == 0 .or. mxy(2)%mp(3) == 0) then
          call fmunknown(mresult, qx)
          qx%kflag = -4
          return
      endif

!             See if any of the terms are negative integers.

      call fmint(mxy(1), mxy(8), qx)
      if (mxy(1)%mp(1) < 0) then
          if (fmcomp(mxy(1), '==', mxy(8), qx)) then
              call fmunknown(mresult, qx)
              qx%kflag = -4
              return
          endif
      endif
      call fmint(mxy(2), mxy(9), qx)
      if (mxy(2)%mp(1) < 0) then
          if (fmcomp(mxy(2), '==', mxy(9), qx)) then
              call fmunknown(mresult, qx)
              qx%kflag = -4
              return
          endif
      endif
      if (fmcomp(mxy(17), '==', mxy(1), qx)) then
          if (mxy(2)%mp(2) > qx%mexpab) then
              call fmabs(mxy(2), mxy(13), qx)
              call fmdpm(qx%dlogmb, mxy(6), qx)
              call fmmpy_r2(mxy(6), mxy(13), qx)
              j = (mxy(1)%mp(2)+1)
              call fmmpyi_r1(mxy(13), j, qx)
          else
              call fmabs(mxy(2), mxy(13), qx)
          endif
          call fmi2m(1, mxy(6), qx)
          call fmulp(mxy(6), mxy(7), qx)
          if (fmcomp(mxy(13), '<=', mxy(7), qx)) then
              call fmgam(mxy(2), mresult, qx)
              return
          endif
      endif
      if (fmcomp(mxy(17), '==', mxy(2), qx)) then
          if (mxy(1)%mp(2) > qx%mexpab) then
              call fmabs(mxy(1), mxy(13), qx)
              call fmdpm(qx%dlogmb, mxy(6), qx)
              call fmmpy_r2(mxy(6), mxy(13), qx)
              j = (mxy(2)%mp(2)+1)
              call fmmpyi_r1(mxy(13), j, qx)
          else
              call fmabs(mxy(1), mxy(13), qx)
          endif
          call fmi2m(1, mxy(6), qx)
          call fmulp(mxy(6), mxy(7), qx)
          if (fmcomp(mxy(13), '<=', mxy(7), qx)) then
              call fmgam(mxy(1), mresult, qx)
              return
          endif
      endif
      if (mxy(17)%mp(3) == 0) then
          call fmi2m(0, mresult, qx)
          return
      else if (mxy(17)%mp(1) < 0) then
          call fmsub(mxy(1), mxy(8), mxy(6), qx)
          call fmsub(mxy(2), mxy(9), mxy(13), qx)
          call fmadd_r2(mxy(6), mxy(13), qx)
          call fmint(mxy(13), mxy(14), qx)
          if (fmcomp(mxy(13), '==', mxy(14), qx)) then
              call fmi2m(0, mresult, qx)
              return
          endif
      endif

!             See if any of the terms are small integers.

      kwrnsv = qx%kwarn
      qx%kwarn = 0
      call fmm2i(mxy(1), n, qx)
      kflkb = qx%kflag
      call fmm2i(mxy(2), k, qx)
      kflnkb = qx%kflag
      call fmm2i(mxy(17), nk, qx)
      qx%kwarn = kwrnsv
      nb = nk - 2
      kb = n - 1
      nkb = k - 1

      if (kflkb == 0 .and. kflnkb == 0 .and. qx%kflag == 0) then
          if (min(kb, nkb) <= 200) then
              call fmcmbi(nb, kb, mxy(22), qx)
              call fmi2m(n+k-1, mxy(8), qx)
              call fmmpy_r1(mxy(22), mxy(8), qx)
              call fmi2m(1, mxy(6), qx)
              call fmdiv(mxy(6), mxy(22), mresult, qx)
              return
          endif
      endif
      nbot = 0
      if (kflkb == 0 .and. n <= 200) then
          call fmeq(mxy(2), mxy(20), qx)
          call fmpoch(mxy(20), n, mxy(5), qx)
          call fmfcti(kb, mxy(11), qx)
          call fmdiv(mxy(11), mxy(5), mxy(21), qx)
          if (abs(mxy(21)%mp(2)) < mxsave) then
              call fmeq(mxy(21), mresult, qx)
              return
          endif
          nbot = 1
      else if (kflnkb == 0 .and. k <= 200) then
          call fmeq(mxy(1), mxy(20), qx)
          call fmpoch(mxy(20), k, mxy(5), qx)
          call fmfcti(nkb, mxy(11), qx)
          call fmdiv(mxy(11), mxy(5), mxy(21), qx)
          if (abs(mxy(21)%mp(2)) < mxsave) then
              call fmeq(mxy(21), mresult, qx)
              return
          endif
          nbot = 1
      endif
      if (nbot == 1) then
          call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
          call fmequ(mb, mxy(2), ndsave, qx%ndig, qx)
          call fmeq(mxy(1), mxy(21), qx)
          call fmadd(mxy(1), mxy(2), mxy(17), qx)
      endif

!             General case.  Use fmgam, unless one of the numbers is too big.  If so, use fmlngm.

      x = qx%alogmb*real(qx%mxexp)
      call fmsp2m(x/log(x), mxy(7), qx)
      call fmabs(mxy(17), mxy(18), qx)
      call fmabs(mxy(1), mxy(19), qx)
      call fmabs(mxy(2), mxy(3), qx)
      if (fmcomp(mxy(18), '>=', mxy(7), qx) .or. fmcomp(mxy(19), '>=', mxy(7),qx) .or.  &
          fmcomp(mxy(3), '>=', mxy(7), qx)) then

!             See if one argument is not very large and the other is
!             much larger.  For many of these cases, Stirling's formula
!             can be used to simplify Beta and avoid cancellation.

          if (mxy(1)%mp(2) > mxy(2)%mp(2)) then
              call fmeq(mxy(1), mxy(10), qx)
              call fmeq(mxy(2), mxy(11), qx)
          else
              call fmeq(mxy(2), mxy(10), qx)
              call fmeq(mxy(1), mxy(11), qx)
          endif
          if (mxy(10)%mp(2) > qx%ndig .and.  &
              mxy(10)%mp(2) >= mxy(11)%mp(2)+qx%ndig) then
              if (mxy(11)%mp(1) < 0) then
                  if (mxy(11)%mp(2) > qx%ndig) then
                      qx%kflag = -4
                      call fmunknown(mresult, qx)
                      return
                  else
                      call fmi2m(2, mxy(18), qx)
                      call fmeq(mxy(11), mxy(19), qx)
                      call fmnegate(mxy(19), qx)
                      call fmint(mxy(19), mxy(6), qx)
                      call fmmod(mxy(6), mxy(18), mxy(12), qx)
                      if (mxy(12)%mp(3) == 0) then
                          call fmadd(mxy(10), mxy(11), mxy(16), qx)
                          call fmln(mxy(16), mxy(6), qx)
                          qx%ndigli = 0
                          call fmmpy(mxy(11), mxy(6), mxy(16), qx)
                          call fmi2m(1, mxy(6), qx)
                          call fmadd(mxy(11), mxy(6), mxy(17), qx)
                          call fmeq(mxy(11), mxy(20), qx)
                          call fmlngm(mxy(17), mxy(4), qx)
                          call fmsub(mxy(4), mxy(16), mxy(6), qx)
                          call fmexp(mxy(6), mxy(13), qx)
                          qx%ndige = 0
                          call fmdiv_r1(mxy(13), mxy(20), qx)
                          call fmeq(mxy(13), mresult, qx)
                          return
                      endif
                  endif
              endif
              call fmadd(mxy(10), mxy(11), mxy(16), qx)
              call fmln(mxy(16), mxy(6), qx)
              qx%ndigli = 0
              call fmmpy(mxy(11), mxy(6), mxy(16), qx)
              call fmeq(mxy(11), mxy(20), qx)
              call fmlngm(mxy(20), mxy(17), qx)
              call fmsub(mxy(17), mxy(16), mxy(6), qx)
              call fmexp(mxy(6), mxy(13), qx)
              qx%ndige = 0
              call fmeq(mxy(13), mresult, qx)
              return
          endif

!             See if both arguments are large.  For many of these cases, Stirling's formula can be
!             used to detect cases where the result will underflow.

          call fmdpm(1.0d7, mxy(6), qx)
          if (fmcomp(mxy(1), '>', mxy(6), qx) .and. fmcomp(mxy(2), '>', mxy(6),qx)) then
              call fmadd(mxy(1), mxy(2), mxy(6), qx)
              call fmln(mxy(6), mxy(15), qx)
              qx%ndigli = 0
              call fmmpy_r2(mxy(6), mxy(15), qx)
              call fmnegate(mxy(15), qx)
              call fmln(mxy(1), mxy(6), qx)
              qx%ndigli = 0
              call fmmpy_r2(mxy(1), mxy(6), qx)
              call fmadd_r1(mxy(15), mxy(6), qx)
              call fmln(mxy(2), mxy(6), qx)
              qx%ndigli = 0
              call fmmpy_r2(mxy(2), mxy(6), qx)
              call fmadd_r1(mxy(15), mxy(6), qx)
              call fmexp(mxy(15), mxy(16), qx)
              qx%ndige = 0
              if (mxy(16)%mp(2) == qx%mexpun) then
                  call fmeq(mxy(16), mresult, qx)
                  return
              endif
          endif

!             Compute iextra, the number of extra digits required to compensate for
!             cancellation error.

          mzero = 0
          mt1 = max(mxy(17)%mp(2), mxy(1)%mp(2))
          mt1 = max(mt1, mxy(2)%mp(2))
          iextra = int(max(mt1, mzero))
          mt1 = max(mxy(17)%mp(2), mxy(1)%mp(2))
          if (max(mt1, mxy(2)%mp(2)) >= qx%mexpov)  &
              iextra = 0
          if (iextra > 0) then
              call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
              call fmequ_r1(mxy(2), qx%ndig, qx%ndig+iextra, qx)
          endif
          call fmndig(qx%ndig + iextra, qx)
          call fmadd(mxy(1), mxy(2), mxy(17), qx)
          call fmi2m(1, mxy(10), qx)
          call fmi2m(2, mxy(11), qx)
          call fmeq(mxy(17), mxy(22), qx)
          k10 = 0
          k11 = 0
          kc = 0
          if (mxy(1)%mp(1) < 0) then
              call fmint(mxy(1), mxy(12), qx)
              call fmmod(mxy(12), mxy(11), mxy(13), qx)
              if (mxy(13)%mp(3) == 0) then
                  k10 = 1
                  call fmadd_r1(mxy(1), mxy(10), qx)
              endif
          endif
          if (mxy(2)%mp(1) < 0) then
              call fmint(mxy(2), mxy(12), qx)
              call fmmod(mxy(12), mxy(11), mxy(13), qx)
              if (mxy(13)%mp(3) == 0) then
                  k11 = 1
                  call fmadd_r1(mxy(2), mxy(10), qx)
              endif
          endif
          if (mxy(22)%mp(1) < 0) then
              call fmint(mxy(22), mxy(12), qx)
              call fmmod(mxy(12), mxy(11), mxy(13), qx)
              if (mxy(13)%mp(3) == 0) then
                  kc = 1
                  call fmadd_r1(mxy(22), mxy(10), qx)
              endif
          endif
          call fmlngm(mxy(1), mxy(17), qx)
          call fmlngm(mxy(2), mxy(20), qx)
          call fmadd_r1(mxy(17), mxy(20), qx)
          call fmlngm(mxy(22), mxy(20), qx)
          call fmsub(mxy(17), mxy(20), mxy(6), qx)
          call fmexp(mxy(6), mxy(17), qx)
          qx%ndige = 0
          if (k10 == 1 .or. k11 == 1 .or. kc == 1) then
              call fmi2m(1, mxy(10), qx)
              if (k10 == 1) then
                  call fmsub_r1(mxy(1), mxy(10), qx)
                  call fmdiv_r1(mxy(17), mxy(1), qx)
              endif
              if (k11 == 1) then
                  call fmsub_r1(mxy(2), mxy(10), qx)
                  call fmdiv_r1(mxy(17), mxy(2), qx)
              endif
              if (kc == 1) then
                  call fmsub_r1(mxy(22), mxy(10), qx)
                  call fmmpy_r1(mxy(17), mxy(22), qx)
              endif
          endif
          call fmeq(mxy(17), mxy(22), qx)
      else
          call fmgam(mxy(1), mxy(20), qx)
          call fmgam(mxy(2), mxy(1), qx)
          call fmgam(mxy(17), mxy(22), qx)
          call fmmpy(mxy(20), mxy(1), mxy(8), qx)
          call fmdiv_r2(mxy(8), mxy(22), qx)
      endif

      call fmeq(mxy(22), mresult, qx)

      return
      end subroutine fmbeta_m1

      subroutine fmbeta_sc(ma, mb, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = beta(ma,mb).

!  kresult = 1 is returned if a special case gives the value of beta(ma,mb).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mresult
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal, mblocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMBETA   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp2(ma, mb, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)
      call fmequ(mb, mblocal, ndsave, qx%ndig, qx)

      if ((malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) .or.  &
          (mblocal%mp(2) == qx%munkno .and. mblocal%mp(5) >= 0)) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine fmbeta_sc

      subroutine fmbig(ma, qx)

!     ma = The biggest representable FM number using the current base and precision.
!          The smallest positive number is then 1.0/ma.
!          In some rounding modes, 1.0/(1.0/ma) may then overflow.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      intent (inout) :: ma
      integer :: j
      type(fm_settings) :: qx

      call fmalloc(ma, qx%ndig+2, qx)
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMBIG    '

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      qx%kflag = 0
      do j = 3, qx%ndig+2
         ma%mp(j) = qx%mbase - 1
      enddo
      ma%mp(2) = qx%mxexp0 + 1
      ma%mp(1) = 1

      call fmntr_out1(ma, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmbig

      subroutine fmc(ma, mb, qx)

!  mb = c(ma)    Fresnel Cosine Integral.

!  Integral from 0 to ma of cos(pi*t**2/2) dt.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(16), mresult, mretry

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmc_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      n_acc = nint(qx%ndig*qx%alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmc_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)
         if (ma%mp(1) == -1) then
             call fmnegate(mresult, qx)
         endif
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry, qx)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmc

      subroutine fmc_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)

!  Method selection for computing c(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(16), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc
      type(fm_settings) :: qx

      double precision :: x, xe, y
      integer :: iextra, k, kflagx, nmethd
      logical, external :: fmcomp

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      mxy(1)%mp(1) = 1

!             Check for special cases.

      if (mxy(1)%mp(3) == 0) then
          call fmeq(mxy(1), mresult, qx)
          retry = .false.
          return
      endif
      call fmovun_xe(mxy(1), xe, qx)
      if (4*xe < -qx%ndig) then
          call fmeq(mxy(1), mresult, qx)
          retry = .false.
          return
      endif
      call fmint(mxy(1), mxy(8), qx)
      call fmovun_xe(mxy(1), xe, qx)
      if (3*xe > qx%ndig .and. fmcomp(mxy(1), '==', mxy(8), qx) .and. xe < qx%mexpov) then
          mxy(1)%mp(1) = ma%mp(1)
          if (mod(int(qx%mbase), 2) == 0 .and. xe > ndsave) then
              k = 0
          else
              call fmi2m(2, mxy(8), qx)
              call fmmod(mxy(1), mxy(8), mxy(7), qx)
              call fmm2i(mxy(7), k, qx)
          endif
          call fmi2m(1, mxy(8), qx)
          if (mxy(1)%mp(1) < 0) then
              call fmdivi(mxy(8), -2, mxy(10), qx)
          else
              call fmdivi(mxy(8), 2, mxy(10), qx)
          endif
          if (k == 0) then
              call fmipwr(mxy(1), 3, mxy(7), qx)
              call fmpi(mxy(6), qx)
              qx%ndigpi = 0
              call fmsqr_r1(mxy(6), qx)
              call fmmpy_r1(mxy(6), mxy(7), qx)
              call fmdiv_r2(mxy(8), mxy(6), qx)
              call fmsub_r1(mxy(10), mxy(6), qx)
          else
              call fmpi(mxy(6), qx)
              qx%ndigpi = 0
              call fmmpy_r1(mxy(6), mxy(1), qx)
              call fmdiv_r2(mxy(8), mxy(6), qx)
              call fmadd_r1(mxy(10), mxy(6), qx)
          endif
          if (ma%mp(1) < 0) call fmnegate(mxy(10), qx)
          call fmeq(mxy(10), mresult, qx)
          retry = .false.
          return
      endif
      call fmovun_xe(mxy(1), xe, qx)
      if (xe > qx%ndig) then
          call fmi2m(1, mxy(8), qx)
          if (mxy(1)%mp(1) < 0) then
              call fmdivi(mxy(8), -2, mresult, qx)
          else
              call fmdivi(mxy(8), 2, mresult, qx)
          endif
          retry = .false.
          return
      endif

!             x is a double precision approximation to the input argument to this function.

      call fmm2dp(mxy(1), x, qx)
      kflagx = qx%kflag
      call fmovun_xe(mxy(1), xe, qx)
      if (qx%kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif

!             If ma is large in magnitude, use more guard digits.

      iextra = min(max(int(mxy(1)%mp(2)), 0) , int(2.0+qx%alogmx/qx%alogmb))
      if (mxy(1)%mp(2) >= qx%mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
      endif
      call fmndig(qx%ndig + iextra, qx)
      n_acc = nint(qx%ndig*qx%alogm2)

!             Determine which method to use.

!             nmethd = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      if (kflagx == 0) then
          if (abs(x) < sqrt(huge(x)/(4*log(huge(x))))) then
              y = (qx%dppi*x*x-1)/2
              y = (2*y+1.5)*log(2*y+2) - (2*y+1) - y*qx%dlogtw - (y+0.5)*log(y+1) + y - y*log(qx%dppi*x*x)
              if (y <= -(qx%ndig+1)*qx%dlogmb) then
                  nmethd = 2
              else
                  nmethd = 1
              endif
          else
              nmethd = 2
          endif
      else
          call fmovun_xe(mxy(1), xe, qx)
          if (xe <= 0) then
              nmethd = 1
          else
              nmethd = 2
          endif
      endif

      if (nmethd == 1) then
          call fmc_m1(mxy, mresult, ndsave, numtry, n_acc, kflagx, x, qx)
      else if (nmethd == 2) then
          call fmc_m2(mxy, mresult, ndsave, numtry, n_acc, qx)
      endif

      return
      end subroutine fmc_m

      subroutine fmc_m1(mxy, mresult, ndsave, numtry, n_acc, kflagx, x, qx)

!  Method 1 for computing c(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(16), mresult
      integer :: ndsave, numtry, n_acc, kflagx
      double precision :: x
      intent (in) :: numtry, ndsave, kflagx, x
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      double precision :: xe
      double precision, external :: fmnterms
      integer :: iextra, j, j2, k, kl, large, nbot, ndsav1, nterm
      type(multi) :: mjsums(ljsums)

!             Method 1.  Use x times the series (-1)**n*(pi*x*x/2)**(2*n)/((4*n+1)*(2*n)!).

      iextra = 0
      if (kflagx == 0) then
          iextra = max(0.0d0, (0.096*x*x + 0.033*abs(x) - 0.5)*log(1.0e7)/qx%alogmb)*1.02
          if (iextra > 0) then
              call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
          endif
      endif
      call fmndig(qx%ndig + iextra, qx)
      n_acc = nint(qx%ndig*qx%alogm2)
      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig-1), qx)
      endif

      if (kflagx == 0) then
          j2 = int(0.68*sqrt(fmnterms(3.14159d0*x*x/2, 2, 0, 0, 1, qx)) - 1.6)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums.

      call fmsqr(mxy(1), mxy(4), qx)
      call fmcsdivi(mxy(4), 2, mxy(9), qx)
      call fmpi(mxy(3), qx)
      qx%ndigpi = 0
      call fmcsmpy_r1(mxy(9), mxy(3), qx)
      call fmi2m(1, mxy(6), qx)
      call fmi2m(1, mjsums(1), qx)
      nterm = 0
      do j = 2, j2
         nterm = nterm + 2
         nbot = nterm*(nterm-1)
         large = int(intmax/nterm)
         if (nterm > large .or. nbot > mxbase) then
             if (nterm > 2) call fmcsdivi_r1(mxy(6), nterm-1, qx)
             call fmcsdivi_r1(mxy(6), nterm, qx)
         else
             call fmcsdivi_r1(mxy(6), nbot, qx)
         endif
         call fmcsdivi(mxy(6), 2*nterm+1, mjsums(j), qx)
      enddo
      call fmovun_xe(mxy(1), xe, qx)
      if (xe < -qx%ndig) then
          kl = 0
      else
          kl = 1
          call fmipwr(mxy(9), 2*j2, mxy(7), qx)
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(6), mxy(7), qx)
         do j = 1, j2
            nterm = nterm + 2
            large = int(intmax/nterm)
            if (nterm > large .or. nterm > mxbase/(nterm-1)) then
                call fmcsdivi_r1(mxy(6), nterm-1, qx)
                call fmcsdivi_r1(mxy(6), nterm, qx)
            else
                nbot = nterm*(nterm-1)
                call fmcsdivi_r1(mxy(6), nbot, qx)
            endif
            call fmcsdivi(mxy(6), 2*nterm+1, mxy(2), qx)
            call fmndig(ndsav1, qx)
            call fmcsaddnn_r1(mjsums(j), mxy(2), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            call fmndig(ndsav1 - int(mjsums(j)%mp(2) - mxy(6)%mp(2)), qx)
            call fmndig(min(ndsav1, qx%ndig), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         enddo
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmcsnsums(j2, mjsums, qx)
      call fmsqr(mxy(9), mxy(8), qx)
      mxy(8)%mp(1) = -1
      if (mjsums(1)%mp(1) > 0) then
          call fmeq(mjsums(1), mxy(15), qx)
          call fmi2m(0, mxy(16), qx)
      else
          call fmeq(mjsums(1), mxy(16), qx)
          call fmi2m(0, mxy(15), qx)
      endif
      call fmeq(mxy(8), mxy(12), qx)
      do j = 1, j2-1
         call fmmpy(mxy(12), mjsums(j+1), mxy(3), qx)
         if (mxy(3)%mp(1) > 0) then
             call fmadd_r1(mxy(15), mxy(3), qx)
         else
             call fmadd_r1(mxy(16), mxy(3), qx)
         endif
         call fmmpy_r1(mxy(12), mxy(8), qx)
      enddo
      call fmadd(mxy(15), mxy(16), mxy(10), qx)
      call fmcancel(mxy(15), mxy(16), mxy(10), k, qx)
      n_acc = n_acc - k
      call fmmpy_r1(mxy(10), mxy(1), qx)

      call fmeq(mxy(10), mresult, qx)

      return
      end subroutine fmc_m1

      subroutine fmc_m2(mxy, mresult, ndsave, numtry, n_acc, qx)

!  Method 2 for computing c(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(16), mresult
      integer :: ndsave, numtry, n_acc
      intent (in) :: ndsave, numtry
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      integer :: krsave

!             Method 2.  use the two n!/x**n asymptotic series for f(x) and g(x).
!                        then c(x) = 0.5 + f(x)*sin(pi*x*x/2) - g(x)*cos(pi*x*x/2).

      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig-1), qx)
      endif
      n_acc = nint(qx%ndig*qx%alogm2)
      call fmfgfi(mxy(1), mxy(11), mxy(12), qx)
      call fmsqr(mxy(1), mxy(4), qx)
      krsave = qx%krad
      qx%krad = 0
      call fmmpyi(mxy(4), 90, mxy(7), qx)
      call fmcssn(mxy(7), mxy(13), mxy(14), qx)
      qx%krad = krsave
      if (mxy(1)%mp(2) == qx%munkno .and. mxy(1)%mp(5) < 0 .and.        &
          ( (mxy(13)%mp(2) == qx%munkno .and. mxy(13)%mp(5) >= 0) .or.  &
            (mxy(14)%mp(2) == qx%munkno .and. mxy(14)%mp(5) >= 0) )) then
          call fmunknown(mxy(10), qx)
          mxy(10)%mp(4) = 0
          mxy(10)%mp(5) = -maxint * 0.5d0
      else
          call fmmpy(mxy(11), mxy(14), mxy(10), qx)
          call fmmpy(mxy(12), mxy(13), mxy(7), qx)
          call fmi2m(1, mxy(4), qx)
          call fmdivi(mxy(4), 2, mxy(5), qx)
          call fmadd(mxy(5), mxy(10), mxy(6), qx)
          call fmsub(mxy(6), mxy(7), mxy(10), qx)
      endif

      call fmeq(mxy(10), mresult, qx)

      return
      end subroutine fmc_m2

      subroutine fmc_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = c(ma).

!  kresult = 1 is returned if a special case gives the value of c(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(16), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      double precision :: xe, ye
      integer :: j, k, kl, krsave, nds
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMC      '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      k = 0
      if (qx%kround /= 1) then
          j = qx%ntrace
          qx%ntrace = 0
          kl = qx%kwarn
          qx%kwarn = 0
          call fmdp2m(1.0d-10, mxy(1), qx)
          call fmulp(mxy(1), mxy(2), qx)
          call fmsqrt(mxy(2), mxy(3), qx)
          call fmsqrt(mxy(3), mxy(2), qx)
          call fmabs(malocal, mxy(3), qx)
          call fmsub(mxy(3), mxy(2), mxy(4), qx)
          if (mxy(4)%mp(1) < 0) k = 1
          qx%ntrace = j
          qx%kwarn = kl
      endif
      if (qx%kround /= 1 .and. k == 1) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          krsave = qx%kround
          qx%kround = 1
          nds = qx%ndig
          call fmndig(qx%ndig + qx%ngrd52, qx)
          call fmequ(malocal, mxy(1), nds, qx%ndig, qx)
          call fmipwr(mxy(1), 5, mxy(2), qx)
          call fmpi(mxy(3), qx)
          qx%ndigpi = 0
          call fmsqr(mxy(3), mxy(4), qx)
          call fmdivi(mxy(4), 40, mxy(3), qx)
          call fmmpy(mxy(2), mxy(3), mxy(5), qx)
          call fmeq(mxy(1), mxy(4), qx)
          call fmovun_xe(mxy(4), xe, qx)
          call fmovun_xe(mxy(5), ye, qx)
          if (xe - ye > ndsave .and. mxy(4)%mp(2) > qx%mexpun) then
              call fmequ(mxy(4), mxy(10), qx%ndig, nds, qx)
              call fmequ(mxy(4), mxy(6), qx%ndig, nds, qx)
              call fmequ(mxy(6), mxy(8), nds, qx%ndig, qx)
              call fmsub(mxy(4), mxy(8), mxy(6), qx)
              if (mxy(6)%mp(3) == 0) then
                  call fmequ(mxy(4), mxy(6), qx%ndig, nds, qx)
                  call fmequ(mxy(5), mxy(7), qx%ndig, nds, qx)
                  call fmndig(nds, qx)
                  qx%kround = krsave
                  call fmsub(mxy(6), mxy(7), mresult, qx)
                  if (mresult%mp(2) >= qx%mexpov) then
                      if (mxy(6)%mp(1) > 0) then
                          if (mxy(7)%mp(1) > 0 .and. (qx%kround == -1 .or. qx%kround == 0)) then
                              call fmeq(mxy(6), mxy(1), qx)
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2), qx)
                              call fmsub(mxy(1), mxy(2), mxy(3), qx)
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mresult, qx)
                          else if (mxy(7)%mp(1) < 0 .and. qx%kround == 2) then
                              call fmeq(mxy(6), mxy(1), qx)
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2), qx)
                              call fmadd(mxy(1), mxy(2), mxy(3), qx)
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mresult, qx)
                          else
                              qx%kround = krsave
                              call fmeq(mxy(10), mresult, qx)
                          endif
                      else
                          if (mxy(7)%mp(1) > 0 .and. qx%kround == -1) then
                              call fmeq(mxy(6), mxy(1), qx)
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2), qx)
                              call fmadd(mxy(1), mxy(2), mxy(3), qx)
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mresult, qx)
                          else if (mxy(7)%mp(1) < 0 .and. (qx%kround == 2 .or. qx%kround == 0)) then
                              call fmeq(mxy(6), mxy(1), qx)
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2), qx)
                              call fmsub(mxy(1), mxy(2), mxy(3), qx)
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mresult, qx)
                          else
                              qx%kround = krsave
                              call fmeq(mxy(10), mresult, qx)
                          endif
                      endif
                  endif
              else
                  qx%kround = krsave
                  call fmequ(mxy(4), mresult, qx%ndig, nds, qx)
              endif
              qx%kflag = 0
              qx%ntrace = j
              qx%kwarn = k
              call fmndig(nds, qx)
              qx%kround = krsave
              kresult = 1
              return
          endif
          qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          call fmndig(nds, qx)
          qx%kround = krsave
      endif

      return
      end subroutine fmc_sc

      subroutine fmcancel(ma, mb, mc, nc, qx)
      use fmvals_parallel
      implicit none

!  Return nc as the number of bits of precision lost to cancellation after
!  mc = ma + mb or mc = ma - mb.

      type(multi) :: ma, mb, mc
      integer :: nc
      intent (in) :: ma, mb, mc
      intent (inout) :: nc
      type(fm_settings) :: qx

      type(multi) :: mxy(5)

      if (ma%mp(3) == 0 .or. ma%mp(3) == 0) then
          nc = 0
          return
      endif
      if (mc%mp(3) == 0) then
          nc = nint(qx%ndig*qx%alogm2)
          return
      endif
      if (abs(ma%mp(2)) >= qx%mexpov .or. abs(mb%mp(2)) >= qx%mexpov .or.  &
          abs(mc%mp(2)) >= qx%mexpov) then
          nc = 0
          return
      endif

      call fmabs(ma, mxy(1), qx)
      call fmabs(mb, mxy(2), qx)
      call fmabs(mc, mxy(3), qx)
      call fmmax(mxy(1), mxy(2), mxy(4), qx)
      call fmdiv(mxy(4), mxy(3), mxy(5), qx)
      nc = ( mxy(5)%mp(2)*log(dble(qx%mbase)) +  &
           log(mxy(5)%mp(3)/dble(qx%mbase) + mxy(5)%mp(4)/dble(qx%mbase)**2) ) / 0.69314718056d0

      return
      end subroutine fmcancel

      subroutine fmchangebase(ma, mb, new_mbase, new_ndig, qx)

!  Change the internal representation of a number from one base to another.
!  ma is given with ndig digits in base mbase (the current precision and base).
!  mb is returned as the same number, approximated with new_ndig digits in base new_mbase.

!  Note ndig and mbase are unchanged after calling fmchangebase, but if mb is to be used
!  in further operations, ndig and mbase should be changed to the new values in the calling program.
!
!  This routine is primarily meant to be used by the input and output conversion routines when the
!  base being used is not a power of ten.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: new_mbase, new_ndig
      intent (in) :: ma, new_mbase, new_ndig
      intent (inout) :: mb
      type(fm_settings) :: qx

      type(multi) :: mxy(4), mresult
      integer :: j, kovun, ndsave
      real (kind(1.0d0)) :: mbsave, mxsave

      j = qx%ntrace
      qx%ntrace = 0
      call fmalloc(mb, new_ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      qx%ndig = ndsave
      mbsave = qx%mbase
      qx%mbase = new_mbase
      call fmchangebase_sc(ma, mbsave, new_ndig, qx)
      call fmalloc(mresult, qx%ndig+2, qx)

      call fmchangebase_m1(ma, mxy, mresult, mbsave, ndsave, qx)

      call fmequ(mresult, mb, qx%ndig, new_ndig, qx)
      qx%ncall = qx%ncall - 1
      qx%ntrace = j
      qx%mbase = mbsave
      qx%mxexp = mxsave
      qx%ndig = ndsave
      call fmcons(qx)

      return
      end subroutine fmchangebase

      subroutine fmchangebase_m1(ma, mxy, mresult, mbsave, ndsave, qx)

!  Method 1 for computing changebase(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: ndsave
      real (kind(1.0d0)) :: mbsave
      intent (in) :: ma, mbsave, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      type(multi) :: mbpowers(9)
      integer :: k, krndsave

!             The change of base is done by summing this series in the new base:
!                 d(1)/b + d(2)/b**2 + ... + d(k)/b**k
!             where d(i) is the i-th digit in the old base, b.

!             Initialize the array of powers of the base.

      krndsave = qx%kround
      qx%kround = 1
      call imi2m2(1, mxy(3), qx)
      do k = 1, 9
         call immpyi2(mxy(3), int(mbsave), mbpowers(k), qx)
         call imeq(mbpowers(k), mxy(3), qx)
      enddo

      call fmchangebase_tq(ma, mbsave, 0, ndsave-1, mxy(1), mxy(2), mbpowers, qx)

      call imi2fm(mxy(1), mxy(3), qx)
      call imi2fm(mxy(2), mxy(4), qx)
      call fmdiv2(mxy(3), mxy(4), mxy(2), qx)

!             Put the exponent and sign on mresult.

      k = mbsave
      call fmi2m2(k, mxy(3), qx)
      k = ma%mp(2)
      if (k /= 0) then
          call fmipwr2(mxy(3), k, mxy(4), qx)
          call fmmpy2(mxy(2), mxy(4), mxy(1), qx)
          call fmeq(mxy(1), mxy(2), qx)
      endif
      mxy(2)%mp(1) = ma%mp(1)
      call fmeq(mxy(2), mresult, qx)
      qx%kround = krndsave

      return
      end subroutine fmchangebase_m1

      subroutine fmchangebase_sc(ma, mbsave, new_ndig, qx)

!  Reset base and precision for the base conversion.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: new_ndig
      real (kind(1.0d0)) :: mbsave
      intent (in) :: ma, mbsave, new_ndig
      type(fm_settings) :: qx

      integer :: iextra

      call fmcons(qx)
      call fmndig(new_ndig + qx%ngrd52, qx)

!             If the exponent is large, raise the precision.

      iextra = max(0, abs(int(log(max(1.0d0, dble(abs(ma%mp(2)))))/log(dble(mbsave))))+1)
      if (abs(ma%mp(2)) >= qx%mexpov) iextra = 0
      call fmndig(qx%ndig + iextra, qx)

      return
      end subroutine fmchangebase_sc

      recursive subroutine fmchangebase_tq(ma, mbsave, a, b, mt, mq, mbpowers, qx)

!  This routine does the binary splitting for computing a change of base.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mt, mq, mbpowers(9)
      integer :: a, b
      real (kind(1.0d0)) :: mbsave
      intent (in) :: ma, a, b, mbsave, mbpowers
      intent (inout) :: mt, mq
      type(fm_settings) :: qx

      type(multi) :: mxy(4)
      integer :: digit, j, k, m, old_base, result_size
      real (kind(0.0d0)) :: da, db, dm

      da = a
      db = b
      dm = mbsave
      old_base = mbsave
      result_size = ( (db-da+1)*log(dm) + 5 ) / qx%dlogmb + 8
      result_size = max(5, result_size)
      call fmalloc(mt, result_size, qx)
      call fmalloc(mq, result_size, qx)

      if (b-a < 9) then
          call fmalloc(mxy(1), result_size, qx)
          call fmalloc(mxy(2), result_size, qx)
          digit = ma%mp(a+3)
          call imi2m2(digit, mt, qx)
          do j = a+1, b
             call immpyi2(mt, old_base, mxy(2), qx)
             digit = ma%mp(j+3)
             call imi2m2(digit, mxy(1), qx)
             call imadd2(mxy(2), mxy(1), mt, qx)
          enddo

!             There may be thousands of calls, all with k = 5,6,7,8,9.
!             These powers are saved instead of re-computing them each time.

          k = b - a + 1
          call imeq(mbpowers(k), mq, qx)
          return
      endif

      m = a/2 + b/2 + mod(a, 2)*mod(b, 2)
      call fmchangebase_tq(ma, mbsave, a, m-1, mxy(1), mxy(2), mbpowers, qx)
      call fmchangebase_tq(ma, mbsave, m, b, mxy(3), mxy(4), mbpowers, qx)
      call immpy2(mxy(1), mxy(4), mq, qx)
      call imadd2(mxy(3), mq, mt, qx)

      call immpy2(mxy(2), mxy(4), mq, qx)

      return
      end subroutine fmchangebase_tq

      subroutine fmcheck_accuracy(ma, ndsave, retry, qx)

!  Internal routine used by routines that need to check for rounding accuracy.

!  Return retry = .true. if we need to try again with more guard digits because the current
!  guard digits in ma are too close to 1/2 ulp.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: ndsave
      logical :: retry
      intent (in) :: ma, ndsave
      intent (inout) :: retry
      type(fm_settings) :: qx

      integer :: j, kl
      double precision :: err

      if (abs(ma%mp(2)) >= qx%mexpov) return
      if (qx%ndig >= 2*ndsave+10) return
      if (qx%ncall <= 1) then
          kl = min(qx%ndig-ndsave, int(3*qx%dlogtn/qx%dlogmb + 2.5))
          err = 0
          do j = kl, 1, -1
             err = (err + ma%mp(j+ndsave+2)) / qx%mbase
          enddo
          if ((qx%kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
              (qx%kround /= 1 .and. (err > 0.998 .or. err < 0.002))) then
              call fmndig(2*ndsave+10, qx)
              retry = .true.
          endif
      endif

      return
      end subroutine fmcheck_accuracy

      subroutine fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)

!  FM special functions monitor cancellation error to see if a retry is needed at higher precision.

      use fmvals_parallel
      implicit none

      integer :: n_acc, ndsave, numtry
      type(multi) :: mresult, mretry
      logical :: retry
      intent (in) :: mresult, ndsave
      intent (inout) :: n_acc, numtry, mretry, retry
      type(fm_settings) :: qx

      integer :: iextra, j, kl, ndold, ngoal, ndgoal

      if (qx%ncall >= 1 .and. abs(mresult%mp(2)) <= qx%mxexp) then
          ngoal = int(real(ndsave)*qx%alogm2) + 17
      else
          ngoal = int(-qx%mxexp2)
      endif

      if (n_acc <= ngoal) then
          if (numtry > 0) then
              ndgoal = int(real(ngoal)/qx%alogm2 + 1.0)
              kl = 0
              do j = 1, ndgoal+1
                 if (mretry%mp(j+1) /= mresult%mp(j+1)) then
                     kl = 1
                     exit
                 endif
              enddo
              if (kl == 0) then
                  return
              endif
          endif
          iextra = int(real(ngoal-n_acc)/qx%alogm2 + 23.03/qx%alogmb) + 1
          ndold = qx%ndig
          call fmndig(qx%ndig + iextra, qx)
          call fmequ(mresult, mretry, ndold, qx%ndig, qx)
          retry = .true.
      endif

      return
      end subroutine fmcheck_cancellation

      subroutine fmchi(ma, mb, qx)

!  mb = hyperbolic cosine integral(ma)

!  eulergamma + ln(ma) + integral from 0 to ma of ( cosh(t) - 1 ) / t  dt.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(11), mresult, mretry

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmchi_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      n_acc = nint(qx%ndig*qx%alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmchi_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry, qx)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmchi

      subroutine fmchi_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)

!  Method selection for computing hyperbolic cosine integral(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(11), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc
      type(fm_settings) :: qx

      double precision :: x, y
      double precision :: d, xe
      integer :: iextra, kflagx, nmethd

      retry = .true.

      n_acc = nint(qx%ndig*qx%alogm2)
      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

!             x is a double precision approximation to the input argument to this function.

      call fmm2dp(mxy(1), x, qx)
      kflagx = qx%kflag
      call fmovun_xe(mxy(1), xe, qx)
      if (qx%kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif

!             If ma is large in magnitude, use more guard digits.

      iextra = min(max(int(mxy(1)%mp(2)), 0) , int(2.0+qx%alogmx/qx%alogmb))
      if (mxy(1)%mp(2) >= qx%mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
      endif
      call fmndig(qx%ndig + iextra, qx)
      n_acc = nint(qx%ndig*qx%alogm2)

!             Check for special cases.

      if (mxy(1)%mp(1) == -1 .or. mxy(1)%mp(3) == 0) then
          call fmunknown(mresult, qx)
          qx%kflag = -4
          retry = .false.
          return
      endif
      if (mxy(1)%mp(2) == qx%mexpov) then
          call fmoverflow(1, mxy(7), qx)
          if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          mxy(7)%mp(4) = huge(qx%mbase)/d
          mxy(7)%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
          qx%kflag = -5
          call fmeq(mxy(7), mresult, qx)
          retry = .false.
          return
      endif

!             Determine which method to use.

!             nmethd = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      nmethd = 1
      if (kflagx /= 0) then
          call fmovun_xe(mxy(1), xe, qx)
          if (xe <= 0) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          y = (qx%ndig+5)*qx%dlogmb
          if (abs(x) > y+(qx%dlogtp+log(y))/2.0d0) nmethd = 2
      endif

      if (nmethd == 1) then
          call fmchi_m1(mxy, mresult, ndsave, numtry, kflagx, n_acc, x, qx)
      else if (nmethd == 2) then
          call fmchi_m2(mxy, mresult, ndsave, numtry, n_acc, qx)
      endif

      return
      end subroutine fmchi_m

      subroutine fmchi_m1(mxy, mresult, ndsave, numtry, kflagx, n_acc, x, qx)

!  Method 1 for computing hyperbolic cosine integral(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(11), mresult
      integer :: ndsave, numtry, kflagx, n_acc
      double precision :: x
      intent (in) :: numtry, ndsave, kflagx, x
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      double precision, external :: fmnterms
      double precision :: xe
      integer :: j, j2, k, kl, large, nbot, ndsav1, nterm
      type(multi) :: mjsums(ljsums)

!             Method 1.  Use the gamma + ln(x) + x**(2*n)/((2*n)*(2*n)!) series.

      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig-1), qx)
      endif
      n_acc = nint(qx%ndig*qx%alogm2)
      if (kflagx == 0) then
          j2 = int(0.62*sqrt(fmnterms(x, 2, 0, 0, 1, qx)) - 1.3)
          j2 = max(1, min(ljsums, j2))
      else
          j2 = 2
      endif
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums.

      call fmsqr(mxy(1), mxy(2), qx)
      call fmcsdivi(mxy(2), 2, mxy(6), qx)
      call fmcsdivi(mxy(6), 2, mjsums(1), qx)
      nterm = 2
      do j = 2, j2
         nterm = nterm + 1
         call fmcsdivi_r1(mxy(6), nterm, qx)
         nterm = nterm + 1
         nbot = nterm
         call fmcsdivi_r1(mxy(6), nbot, qx)
         call fmcsdivi(mxy(6), nterm, mjsums(j), qx)
      enddo
      call fmovun_xe(mxy(1), xe, qx)
      if (xe < -qx%ndig) then
          kl = 0
      else
          kl = 1
          call fmipwr(mxy(1), 2*j2, mxy(4), qx)
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(6), mxy(4), qx)
         do j = 1, j2
            nterm = nterm + 2
            large = int(intmax/nterm)
            if (nterm > large .or. nterm > mxbase/(nterm-1)) then
                call fmcsdivi_r1(mxy(6), nterm, qx)
                nbot = (nterm - 1)
                call fmcsdivi_r1(mxy(6), nbot, qx)
            else
                nbot = nterm*(nterm-1)
                call fmcsdivi_r1(mxy(6), nbot, qx)
            endif
            call fmcsdivi(mxy(6), nterm, mxy(3), qx)
            call fmndig(ndsav1, qx)
            call fmcsaddnn_r1(mjsums(j), mxy(3), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            call fmndig(ndsav1 - int(mjsums(j)%mp(2) - mxy(3)%mp(2)), qx)
            call fmndig(min(ndsav1, qx%ndig), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         enddo
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmcsnsums(j2, mjsums, qx)
      call fmeq(mjsums(j2), mxy(7), qx)
      if (j2 >= 2) then
          call fmsqr(mxy(1), mxy(5), qx)
          do j = 2, j2
             call fmcsmpy_r1(mxy(7), mxy(5), qx)
             call fmadd_r1(mxy(7), mjsums(j2-j+1), qx)
          enddo
      endif
      call fmeulr(mxy(9), qx)
      qx%ndgeul = 0
      call fmadd(mxy(7), mxy(9), mxy(3), qx)
      call fmln(mxy(1), mxy(2), qx)
      qx%ndigli = 0
      call fmadd(mxy(3), mxy(2), mxy(7), qx)
      call fmcancel(mxy(3), mxy(2), mxy(7), k, qx)
      n_acc = n_acc - k

      call fmeq(mxy(7), mresult, qx)

      return
      end subroutine fmchi_m1

      subroutine fmchi_m2(mxy, mresult, ndsave, numtry, n_acc, qx)

!  Method 2 for computing hyperbolic cosine integral(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(11), mresult
      integer :: ndsave, numtry, n_acc
      intent (in) :: ndsave, numtry
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      double precision :: xe

!             Method 2.  Use the two n!/x**n asymptotic series for f(x) and g(x).
!                        then chi(x) = f(x)*sinh(x) + g(x)*cosh(x).

      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig-2), qx)
      endif
      n_acc = nint(qx%ndig*qx%alogm2)
      call fmfhgh(mxy(1), mxy(8), mxy(9), qx)
      call fmchsh(mxy(1), mxy(10), mxy(11), qx)
      call fmovun_xe(mxy(10), xe, qx)
      if (xe < qx%mexpov) then
          call fmmpy(mxy(8), mxy(11), mxy(7), qx)
          call fmmpy(mxy(9), mxy(10), mxy(4), qx)
          call fmadd_r1(mxy(7), mxy(4), qx)
      else
          call fmadd(mxy(8), mxy(9), mxy(4), qx)
          call fmdivi_r1(mxy(4), 2, qx)
          call fmln(mxy(4), mxy(7), qx)
          qx%ndigli = 0
          call fmadd(mxy(1), mxy(7), mxy(4), qx)
          call fmexp(mxy(4), mxy(7), qx)
          qx%ndige = 0
      endif

      call fmeq(mxy(7), mresult, qx)

      return
      end subroutine fmchi_m2

      subroutine fmchi_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = hyperbolic cosine integral(ma).

!  kresult = 1 is returned if a special case gives the value of hyperbolic cosine integral(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMCHI    '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine fmchi_sc

      subroutine fmchsh(ma, mb, mc, qx)

!  mb = cosh(ma),    mc = sinh(ma)

!  If both the hyperbolic sine and cosine are needed, this routine is faster than calling both
!  fmcosh and fmsinh.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      type(fm_settings) :: qx

      type(multi) :: mresult1, mresult2
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(3)

      call fmalloc(mb, qx%ndig+2, qx)
      call fmalloc(mc, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmchsh_sc(ma, mxy, ndsave, mresult1, mresult2, kresult, qx)
      if (kresult > 0) then
          call fmexit2(mresult1, mresult2, mb, mc, kovun, mxsave, ndsave, qx)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmchsh_m1(ma, mxy, mresult1, mresult2, ndsave, qx)
         call fmcheck_accuracy(mresult1, ndsave, retry, qx)
         if (retry) cycle
         call fmcheck_accuracy(mresult2, ndsave, retry, qx)
      enddo

      call fmexit2(mresult1, mresult2, mb, mc, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmchsh

      subroutine fmchsh_m1(ma, mxy, mresult1, mresult2, ndsave, qx)

!  Method 1 for computing fmchsh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(3), mresult1, mresult2
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult1, mresult2
      type(fm_settings) :: qx

      integer :: k
      integer :: krndsave

      krndsave = qx%kround
      qx%kround = 1
      call fmequ(ma, mxy(3), ndsave, qx%ndig, qx)
      mxy(3)%mp(1) = 1

      k = 1
      if (mxy(3)%mp(2) == 0 .and. mxy(3)%mp(3) /= 0) then
          if (qx%mbase/mxy(3)%mp(3) >= 100) k = 2
      endif
      if (mxy(3)%mp(2) >= 0 .and. mxy(3)%mp(3) /= 0 .and. k == 1) then
          call fmcosh(mxy(3), mresult1, qx)
          if (mresult1%mp(2) > qx%ndig) then
              call fmeq(mresult1, mresult2, qx)
              mresult2%mp(1) = ma%mp(1)
              return
          endif
          call fmsqr(mresult1, mxy(2), qx)
          call fmi2m(-1, mxy(1), qx)
          call fmadd_r1(mxy(2), mxy(1), qx)
          call fmsqrt(mxy(2), mresult2, qx)
      else
          call fmsinh(mxy(3), mresult2, qx)
          call fmsqr(mresult2, mxy(2), qx)
          call fmi2m(1, mxy(1), qx)
          call fmadd_r1(mxy(2), mxy(1), qx)
          call fmsqrt(mxy(2), mresult1, qx)
      endif
      mresult2%mp(1) = ma%mp(1)

      qx%kround = krndsave

      return
      end subroutine fmchsh_m1

      subroutine fmchsh_sc(ma, mxy, ndsave, mresult1, mresult2, kresult, qx)

!  Check for special cases for fmchsh(ma).

!  kresult = 1 is returned if a special case gives the values of the two results.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(3), mresult1, mresult2
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult1, mresult2, kresult
      type(fm_settings) :: qx

      integer :: j

      kresult = 0

      qx%namest(qx%ncall) = 'FMCHSH   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

      if (mxy(1)%mp(2) == qx%munkno .and. mxy(1)%mp(5) >= 0) then
          call fmunknown(mresult1, qx)
          call fmunknown(mresult2, qx)
          kresult = 1
          return
      endif

      if (abs(mxy(1)%mp(2)) >= qx%mexpov) then
          call fmcosh(mxy(1), mresult1, qx)
          call fmsinh(mxy(1), mresult2, qx)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (qx%kround /= 1 .and. mxy(1)%mp(2) < -ndsave) then
          call fmcosh(mxy(1), mresult1, qx)
          call fmsinh(mxy(1), mresult2, qx)
          kresult = 1
          return
      endif
      if (abs(mxy(1)%mp(2)) > qx%mexpab) then
          call fmcosh(mxy(1), mresult1, qx)
          call fmsinh(mxy(1), mresult2, qx)
          kresult = 1
          return
      endif

      return
      end subroutine fmchsh_sc

      subroutine fmci(ma, mb, qx)

!  mb = cosine integral(ma)

!  Integral from ma to infinity of -cos(t) / t  dt.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(13), mresult, mretry

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmci_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      n_acc = nint(qx%ndig*qx%alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmci_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry, qx)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmci

      subroutine fmci_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)

!  Method selection for computing cosine integral(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc
      type(fm_settings) :: qx

      double precision :: x, xe, y
      integer :: iextra, kflagx, nmethd

      retry = .true.

      n_acc = nint(qx%ndig*qx%alogm2)
      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

!             x is a double precision approximation to the input argument to this function.

      call fmm2dp(mxy(1), x, qx)
      kflagx = qx%kflag
      call fmovun_xe(mxy(1), xe, qx)
      if (qx%kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif

!             If ma is large in magnitude, use more guard digits.

      iextra = min(max(int(mxy(1)%mp(2)), 0) , int(2.0+qx%alogmx/qx%alogmb))
      if (mxy(1)%mp(2) >= qx%mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
      endif
      call fmndig(qx%ndig + iextra, qx)
      n_acc = nint(qx%ndig*qx%alogm2)

!             Determine which method to use.

!             nmethd = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      nmethd = 1
      if (kflagx /= 0) then
          call fmovun_xe(mxy(1), xe, qx)
          if (xe <= 0) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          y = (qx%ndig+5)*qx%dlogmb
          if (abs(x) > y+(qx%dlogtp+log(y))/2.0d0) nmethd = 2
      endif

      if (nmethd == 1) then
          call fmci_m1(mxy, mresult, numtry, n_acc, kflagx, x, qx)
      else if (nmethd == 2) then
          call fmci_m2(mxy, mresult, qx)
      endif

      return
      end subroutine fmci_m

      subroutine fmci_m1(mxy, mresult, numtry, n_acc, kflagx, x, qx)

!  Method 1 for computing cosine integral(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(13), mresult
      integer :: numtry, n_acc, kflagx
      double precision :: x
      intent (in) :: numtry, kflagx, x
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      double precision :: xe, y
      integer :: iextra, j, j2, k, kl, large, nbot, ndsav1, nterm
      type(multi) :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 1.  Use the  gamma + ln(x) + (-1)**n*x**(2*n)/((2*n)*(2*n)!) series.

      iextra = 0
      if (kflagx == 0) then
          y = nint(abs(x)/2)
          y = 2*y*log(abs(x)+1.0e-9) - log(2*y+1.0e-9) - (2*y+0.5)*log(2*y+1) + 2*y
          y = 1.03*y/qx%dlogmb
          iextra = max(0, int(y+1))
      endif
      if (iextra > 0) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
      endif
      if (abs(x) < 5 .and. numtry <= 0) then
          call fmndig(qx%ndig - 2, qx)
          n_acc = nint(qx%ndig*qx%alogm2)
          iextra = 0
      endif
      call fmndig(qx%ndig + iextra, qx)
      n_acc = nint(qx%ndig*qx%alogm2)

      if (kflagx == 0) then
          j2 = int(0.64*sqrt(fmnterms(x, 2, 0, 0, 1, qx)) - 1.4)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = qx%ndig
      call fmi2m(0, mxy(12), qx)
      call fmi2m(0, mxy(13), qx)

!             Split into j2 concurrent sums.

      call fmsqr(mxy(1), mxy(2), qx)
      call fmcsdivi(mxy(2), 2, mxy(6), qx)
      call fmcsdivi(mxy(6), 2, mjsums(1), qx)
      nterm = 2
      do j = 2, j2
         nterm = nterm + 2
         large = int(intmax/nterm)
         nbot = nterm*(nterm-1)
         if (nterm > large .or. nbot > mxbase) then
             call fmcsdivi_r1(mxy(6), nterm-1, qx)
             call fmcsdivi_r1(mxy(6), nterm, qx)
         else
             call fmcsdivi_r1(mxy(6), nbot, qx)
         endif
         call fmcsdivi(mxy(6), nterm, mjsums(j), qx)
      enddo
      call fmovun_xe(mxy(1), xe, qx)
      if (xe < -qx%ndig) then
          kl = 0
      else
          kl = 1
          call fmipwr(mxy(1), 2*j2, mxy(4), qx)
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(6), mxy(4), qx)
         do j = 1, j2
            nterm = nterm + 2
            large = int(intmax/nterm)
            if (nterm > large .or. nterm > mxbase/(nterm-1)) then
                call fmcsdivi_r1(mxy(6), nterm-1, qx)
                call fmcsdivi_r1(mxy(6), nterm, qx)
            else
                nbot = nterm*(nterm-1)
                call fmcsdivi_r1(mxy(6), nbot, qx)
            endif
            call fmcsdivi(mxy(6), nterm, mxy(3), qx)
            call fmndig(ndsav1, qx)
            call fmcsaddnn_r1(mjsums(j), mxy(3), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            call fmndig(ndsav1 - int(mjsums(j)%mp(2) - mxy(3)%mp(2)), qx)
            call fmndig(min(ndsav1, qx%ndig), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         enddo
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmcsnsums(j2, mjsums, qx)
      call fmsqr(mxy(1), mxy(5), qx)
      mxy(5)%mp(1) = -1
      if (mjsums(1)%mp(1) > 0) then
          call fmeq(mjsums(1), mxy(12), qx)
          call fmi2m(0, mxy(13), qx)
      else
          call fmeq(mjsums(1), mxy(13), qx)
          call fmi2m(0, mxy(12), qx)
      endif
      call fmeq(mxy(5), mxy(7), qx)
      do j = 1, j2-1
         call fmmpy(mxy(7), mjsums(j+1), mxy(3), qx)
         if (mxy(3)%mp(1) > 0) then
             call fmadd_r1(mxy(12), mxy(3), qx)
         else
             call fmadd_r1(mxy(13), mxy(3), qx)
         endif
         call fmmpy_r1(mxy(7), mxy(5), qx)
      enddo
      call fmmpyi(mxy(12), -1, mxy(3), qx)
      call fmmpyi(mxy(13), -1, mxy(12), qx)
      call fmeq(mxy(3), mxy(13), qx)
      call fmeulr(mxy(9), qx)
      qx%ndgeul = 0
      call fmadd_r1(mxy(12), mxy(9), qx)
      call fmln(mxy(1), mxy(2), qx)
      qx%ndigli = 0
      if (mxy(2)%mp(1) > 0) then
          call fmadd_r1(mxy(12), mxy(2), qx)
      else
          call fmadd_r1(mxy(13), mxy(2), qx)
      endif
      call fmadd(mxy(12), mxy(13), mxy(7), qx)
      call fmcancel(mxy(12), mxy(13), mxy(7), k, qx)
      n_acc = n_acc - k

      call fmeq(mxy(7), mresult, qx)

      return
      end subroutine fmci_m1

      subroutine fmci_m2(mxy, mresult, qx)

!  Method 2 for computing cosine integral(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(13), mresult
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: krsave

!             Method 2.  Use the two n!/x**n asymptotic series for f(x) and g(x).
!                        Then ci(x) = f(x)*sin(x) - g(x)*cos(x).

      call fmfxgx(mxy(1), mxy(8), mxy(9), qx)
      krsave = qx%krad
      qx%krad = 1
      call fmcssn(mxy(1), mxy(10), mxy(11), qx)
      qx%krad = krsave
      call fmmpy(mxy(8), mxy(11), mxy(7), qx)
      call fmmpy(mxy(9), mxy(10), mxy(4), qx)
      call fmsub_r1(mxy(7), mxy(4), qx)

      call fmeq(mxy(7), mresult, qx)

      return
      end subroutine fmci_m2

      subroutine fmci_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = cosine integral(ma).

!  kresult = 1 is returned if a special case gives the value of cosine integral(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMCI     '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (malocal%mp(1) < 0 .or. malocal%mp(3) == 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (malocal%mp(2) == qx%mexpov) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine fmci_sc

      subroutine fmcmbi(n, k, ma, qx)

!  Internal routine for computing binomial coefficients for integers.

!  ma = n choose k.

      use fmvals_parallel
      implicit none

      integer :: n, k
      type(multi) :: ma
      intent (in) :: n, k
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: intndg, j, kstart, kt, l, large, larged, ndiv, ndsave, nextd, nextn, nmpy, ntd, ntn

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      l = min(k, n-k)
      if (k < 0 .or. k > n) then
          call fmi2m(0,ma, qx)
          return
      endif
      if (l <= 0) then
          call fmi2m(1, ma, qx)
          return
      endif
      if (l <= 1) then
          call fmi2m(n, ma, qx)
          return
      endif

!             Find the largest value for n choose j using integers.

      ntn = n
      ntd = 1
      large = int(intmax/n)
      do j = 2, l
         if (ntn <= large) then
             ntn = (ntn*((n+1)-j))/j
         else
             call fmi2m(ntn, ma, qx)
             ntn = (n+1) - j
             ntd = j
             exit
         endif
      enddo

      if (ntd == 1) then
          call fmi2m(ntn, ma, qx)
          return
      endif

      intndg = int(qx%alogmx/qx%alogmb + 1.0)
      nextn = ntn
      nextd = ntd
      kstart = ntd + 1
      ndsave = qx%ndig

!             Compute the rest of n choose k.

      larged = min(large, int(mxbase))
      do kt = kstart, l
         nextn = nextn - 1
         nextd = nextd + 1
         if (ntn >= large .or. ntd >= larged) then
             call fmndig(max(3, min(ndsave, int(ma%mp(2))+intndg)), qx)
             call fmcsmpyi_r1(ma, ntn, qx)
             call fmcsdivi_r1(ma, ntd, qx)
             ntn = nextn
             ntd = nextd
             cycle
         endif
         nmpy = ntn*nextn
         ndiv = ntd*nextd
         if (nmpy <= large .and. ndiv <= larged) then
             ntn = nmpy
             ntd = ndiv
         else
             call fmgcdi(nmpy, ndiv)
             if (nmpy <= large .and. ndiv <= larged) then
                 ntn = nmpy
                 ntd = ndiv
             else
                 call fmndig(max(3, min(ndsave, int(ma%mp(2))+intndg)), qx)
                 call fmcsmpyi_r1(ma, ntn, qx)
                 call fmcsdivi_r1(ma, ntd, qx)
                 ntn = nextn
                 ntd = nextd
             endif
         endif
      enddo
      call fmndig(max(3, min(ndsave, int(ma%mp(2))+intndg)), qx)
      call fmgcdi(ntn, ntd)
      call fmcsmpyi_r1(ma, ntn, qx)
      call fmcsdivi_r1(ma, ntd, qx)
      qx%ndig = ndsave

      return
      end subroutine fmcmbi

      subroutine fmcomb(ma, mb, mc, qx)

!  mc = ma choose mb.  (Binomial coefficient -- uses gamma for non-integers)

!  mc = (ma)! / ( (mb)! * (ma-mb)! )

!  This routine extends this definition to allow negative integer values for ma and/or mb.
!  The standard recurrence comb(n,k) = comb(n-1,k-1) + comb(n-1,k) can be used to define
!  comb(n,k) for all integers n,k starting from the initializing definitions
!  comb(0,k) = 0, for all k except 0,
!  comb(n,0) = 1, for all n.
!  Ex:  n = 1, k = 1 => comb(1,1) = comb(0,0)   +  comb(0,1)
!                    => comb(1,1) =         1   +          0,  so  comb(1,1)   =  1
!       n = 0, k = 0 => comb(0,0) = comb(-1,-1) + comb(-1,0)
!                    =>         1 = comb(-1,-1) +          1,  so  comb(-1,-1) =  0
!       n = 0, k = 1 => comb(0,1) = comb(-1,0)  + comb(-1,1)
!                    =>         0 =          1  + comb(-1,1),  so  comb(-1,1)  = -1

!  This definition agrees with the standard factorial definition when n and k are non-negative
!  integers.  The factorial definition is undefined when n or k is a negative integer, since
!  x! has singularities at negative integers.

!  For negative integer n or k, this extended definition simplifies to:
!  if k < 0,             comb(n,k) = 0
!  if k >= 0 and n < 0,  comb(n,k) = (-1)**k * comb(-n+k-1,k)

!  These extended definitions are useful in some combinatorial applications.
!  Reference:  Concrete Mathematics - Graham, Knuth, Patashnik, Addison-Wesley, 1989.


      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(17), mresult

      call fmalloc(mc, qx%ndig+2, qx)
      call fmenter2(ma, mb, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmcomb_sc(ma, mb, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mc, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call fmcomb_m1(ma, mb, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mc, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmcomb

      subroutine fmcomb_m1(ma, mb, mxy, mresult, ndsave, qx)

!  Method 1 for computing comb(ma,mb).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mxy(17), mresult
      integer :: ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mzero, mt1
      real :: x
      integer :: iextra, j, jr, k, k09, k10, k11, kbot, kc, kflgk, kflgnk,  &
                 ksign, kwrnsv, large, n, nbot, nk
      logical :: lc1, lc2, lc3
      logical, external :: fmcomp

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      call fmequ(mb, mxy(2), ndsave, qx%ndig, qx)

      k = 0
      if (ma%mp(1) < 0) then
          k10 = qx%ntrace
          qx%ntrace = 0
          k11 = qx%kwarn
          qx%kwarn = 0
          call fmm2i(mxy(1), j, qx)
          if (qx%kflag == 0) k = 1
          qx%ntrace = k10
          qx%kwarn = k11
      endif

      if (ma%mp(2) >= qx%mexpov .or. mb%mp(2) >= qx%mexpov) then
          call fmint(mxy(1), mxy(11), qx)
          call fmint(mxy(2), mxy(12), qx)
          if (ma%mp(2) == qx%mexpov .and. ma%mp(1) < 0 .and.  &
              fmcomp(mxy(2), '==', mxy(12), qx)) then
              if (mxy(2)%mp(3) == 0) then
                  call fmi2m(1, mresult, qx)
              else if (mxy(2)%mp(1) < 0) then
                  call fmi2m(0, mresult, qx)
              else
                  call fmpwr(mxy(1), mxy(2), mxy(3), qx)
                  call fmfact(mxy(2), mxy(4), qx)
                  call fmdiv(mxy(3), mxy(4), mresult, qx)
              endif
          else if (mxy(2)%mp(2) == qx%mexpov .and. mxy(2)%mp(1) > 0 .and.          &
                   fmcomp(mxy(1), '==', mxy(11), qx) .and. mxy(1)%mp(1) > 0 .and.  &
                   fmcomp(mxy(1), '<', mxy(2), qx)) then
              call fmi2m(0, mresult, qx)
          else if (mxy(1)%mp(1) < 0 .or. mxy(2)%mp(1) < 0 .or.  &
                   fmcomp(mxy(2), '>=', mxy(1), qx)) then
              call fmunknown(mresult, qx)
          else if (mxy(2)%mp(3) == 0) then
              call fmi2m(1, mresult, qx)
          else
              call fmsub(mxy(1), mxy(2), mxy(12), qx)
              call fmi2m(1, mxy(3), qx)
              call fmadd(mxy(12), mxy(3), mxy(4), qx)
              call fmbeta(mxy(2), mxy(4), mxy(5), qx)
              call fmmpy(mxy(2), mxy(5), mxy(4), qx)
              call fmdiv(mxy(3), mxy(4), mresult, qx)
          endif
          if (mresult%mp(2) == qx%munkno) then
              qx%kflag = -4
          endif
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (qx%kround /= 1 .and. mxy(2)%mp(2) < -ndsave .and. k == 0) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          if (mxy(1)%mp(2) == qx%mexpun) then
              call fmtiny(mxy(11), qx)
              mxy(11)%mp(1) = mxy(1)%mp(1)
          else
              call fmeq(mxy(1), mxy(11), qx)
          endif
          if (mxy(2)%mp(2) == qx%mexpun) then
              call fmtiny(mxy(12), qx)
              mxy(12)%mp(1) = mxy(2)%mp(1)
          else
              call fmeq(mxy(2), mxy(12), qx)
          endif
          call fmsub(mxy(11), mxy(12), mxy(3), qx)
          if (mxy(3)%mp(3) /= 0) then
              call fmpi(mxy(4), qx)
              qx%ndigpi = 0
              call fmsqr(mxy(4), mxy(5), qx)
              call fmdivi(mxy(5), 6, mxy(4), qx)
              call fmi2m(1, mxy(6), qx)
              call fmpgam(2, mxy(6), mxy(5), qx)
              call fmmpy_r1(mxy(5), mxy(11), qx)
              call fmdivi_r1(mxy(5), 2, qx)
              call fmadd_r1(mxy(4), mxy(5), qx)
              call fmmpy_r1(mxy(3), mxy(4), qx)
              call fmmpy_r1(mxy(3), mxy(12), qx)
              call fmadd_r2(mxy(6), mxy(3), qx)
          else
              call fmi2m(1, mxy(3), qx)
          endif
          qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          call fmeq(mxy(3), mresult, qx)
          return
      endif

      ksign = 1

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      call fmequ(mb, mxy(2), ndsave, qx%ndig, qx)

      call fmsub(mxy(1), mxy(2), mxy(15), qx)
      if (mxy(2)%mp(3) == 0) then
          call fmi2m(1, mresult, qx)
          mresult%mp(1) = ksign*mresult%mp(1)
          return
      endif
      call fmi2m(1, mxy(3), qx)
      call fmsub(mxy(2), mxy(3), mxy(4), qx)
      if (mxy(4)%mp(3) == 0) then
          call fmeq(mxy(1), mresult, qx)
          mresult%mp(1) = ksign*mresult%mp(1)
          return
      endif

!             See if any of the terms are negative integers.

      call fmi2m(1, mxy(11), qx)
      k10 = 0
      if (mxy(1)%mp(1) < 0) then
          call fmint(mxy(1), mxy(7), qx)
          if (fmcomp(mxy(1), '==', mxy(7), qx)) k10 = -1
          if (ma%mp(2) == qx%mexpov)  k10 = -1
      endif
      k11 = 0
      if (mxy(2)%mp(1) < 0) then
          call fmint(mxy(2), mxy(8), qx)
          if (fmcomp(mxy(2), '==', mxy(8), qx)) k11 = -1
          if (mb%mp(2) == qx%mexpov)  k11 = -1
      endif
      k09 = 0
      if (fmcomp(mxy(1), '<', mxy(2), qx)) then
          call fmmod(mxy(1), mxy(11), mxy(9), qx)
          call fmmod(mxy(2), mxy(11), mxy(10), qx)
          call fmsub_r2(mxy(9), mxy(10), qx)
          call fmint(mxy(10), mxy(9), qx)
          if (fmcomp(mxy(10), '==', mxy(9), qx)) k09 = -1
      endif

      call fmi2m(2, mxy(10), qx)

      if (k11 == -1) then
          call fmi2m(0, mresult, qx)
          mresult%mp(1) = ksign*mresult%mp(1)
          return
      else if (mxy(15)%mp(3) == 0) then
          call fmi2m(1, mresult, qx)
          mresult%mp(1) = ksign*mresult%mp(1)
          return
      else if (k09 == -1 .and. k10 == 0) then
          call fmi2m(0, mresult, qx)
          mresult%mp(1) = ksign*mresult%mp(1)
          return
      else if (k10 == -1 .and. k09 == 0) then
          call fmunknown(mresult, qx)
          qx%kflag = -4
          mresult%mp(1) = ksign*mresult%mp(1)
          return
      else if (k10 == -1 .and. k09 == -1) then
          jr = qx%kround
          qx%kround = 1
          call fmmod(mxy(2), mxy(10), mxy(12), qx)
          if (mxy(12)%mp(3) /= 0) ksign = -1
          call fmsub(mxy(2), mxy(1), mxy(12), qx)
          call fmsub(mxy(12), mxy(11), mxy(1), qx)
          call fmsub(mxy(1), mxy(2), mxy(15), qx)
          qx%kround = jr
      endif
      if (mxy(1)%mp(2) >= 10000) then
          call fmi2m(1, mxy(5), qx)
          if (fmcomp(mxy(2), '>', mxy(5), qx) .and. fmcomp(mxy(2), '<', mxy(1),qx)) then
              call fmsub(mxy(1), mxy(2), mxy(5), qx)
              call fmmin(mxy(2), mxy(5), mxy(13), qx)
              call fmsub(mxy(1), mxy(13), mxy(5), qx)
              call fmaddi(mxy(5), 1, qx)
              call fmdiv(mxy(5), mxy(13), mxy(12), qx)
              call fmln(mxy(12), mxy(5), qx)
              qx%ndigli = 0
              call fmaddi(mxy(5), 1, qx)
              call fmmpy(mxy(13), mxy(5), mxy(12), qx)
              call fmdpm(6.283185d0, mxy(3), qx)
              call fmmpy(mxy(3), mxy(13), mxy(5), qx)
              call fmln(mxy(5), mxy(3), qx)
              qx%ndigli = 0
              call fmdivi(mxy(3), 2, mxy(5), qx)
              call fmsub_r1(mxy(12), mxy(5), qx)
              call fmexp(mxy(12), mxy(4), qx)
              qx%ndige = 0
              if (mxy(4)%mp(2) == qx%mexpov) then
                  call fmeq(mxy(4), mresult, qx)
                  qx%kflag = -5
                  mresult%mp(1) = ksign*mresult%mp(1)
                  return
              endif
          endif
      endif

!             See if any of the terms are small integers.

      kwrnsv = qx%kwarn
      qx%kwarn = 0
      call fmm2i(mxy(1), n, qx)
      call fmm2i(mxy(2), k, qx)
      kflgk = qx%kflag
      call fmm2i(mxy(15), nk, qx)
      kflgnk = qx%kflag
      qx%kwarn = kwrnsv

      call fmi2m(1, mxy(5), qx)
      jr = qx%kround
      qx%kround = 1
      call fmadd(mxy(1), mxy(5), mxy(3), qx)
      call fmsub_r1(mxy(3), mxy(5), qx)
      qx%kround = jr
      if (kflgk == 0 .and. mxy(3)%mp(3) == 0) then
          call fmi2m(2, mxy(17), qx)
          call fmmod(mxy(2), mxy(17), mxy(5), qx)
          call fmeq(mxy(5), mxy(17), qx)
          if (mxy(17)%mp(3) == 0) then
              call fmdiv(mxy(1), mxy(2), mxy(17), qx)
              call fmnegate(mxy(17), qx)
          else
              call fmdiv(mxy(1), mxy(2), mxy(17), qx)
          endif
          call fmeq(mxy(17), mresult, qx)
          mresult%mp(1) = ksign*mresult%mp(1)
          return
      endif
      if (kflgk == 0 .and. kflgnk == 0 .and. n /= 0) then
          if (min(k, nk) <= 200) then
              call fmcmbi(n, k, mresult, qx)
              mresult%mp(1) = ksign*mresult%mp(1)
              return
          endif
      endif
      nbot = 0
      if (kflgk == 0 .and. k <= 200) nbot = k
      if (kflgnk == 0 .and. nk <= 200) nbot = nk
      if (nbot > 0) then
          large = int(mxbase/nbot)
          kbot = 1
          call fmeq(mxy(1), mxy(7), qx)
          call fmeq(mxy(1), mxy(8), qx)
          call fmi2m(-1, mxy(9), qx)
          do j = 2, nbot
             call fmadd_r1(mxy(7), mxy(9), qx)
             call fmmpy_r2(mxy(7), mxy(8), qx)
             kbot = kbot*j
             if (kbot >= large) then
                 call fmdivi_r1(mxy(8), kbot, qx)
                 kbot = 1
             endif
          enddo
          call fmdivi(mxy(8), kbot, mresult, qx)
          mresult%mp(1) = ksign*mresult%mp(1)
          return
      endif

!             General case.  Use fmfact, unless one of the numbers is too big.  If so, use fmlngm.

      x = qx%alogmb*real(qx%mxexp)
      call fmsp2m(x/log(x), mxy(6), qx)
      call fmabs(mxy(15), mxy(5), qx)
      lc1 = fmcomp(mxy(5), '>=', mxy(6), qx)
      call fmabs(mxy(1), mxy(5), qx)
      lc2 = fmcomp(mxy(5), '>=', mxy(6), qx)
      call fmabs(mxy(2), mxy(5), qx)
      lc3 = fmcomp(mxy(5), '>=', mxy(6), qx)
      if (lc1 .or. lc2 .or. lc3) then

!             See if the second argument is not very large and the first is much larger.
!             For many of these cases, Stirling's formula can be used to simplify Comb
!             and avoid cancellation.

          if (mxy(1)%mp(2) > mxy(2)%mp(2) .and. mxy(1)%mp(1) > 0 .and.  &
              mxy(2)%mp(1) > 0) then
              call fmeq(mxy(1), mxy(9), qx)
              call fmeq(mxy(2), mxy(10), qx)
          else
              call fmi2m(1, mxy(9), qx)
              call fmi2m(1, mxy(10), qx)
          endif
          if (mxy(9)%mp(2) > qx%ndig .and.  &
              mxy(9)%mp(2) >= mxy(10)%mp(2)+qx%ndig) then
              call fmi2m(1, mxy(5), qx)
              call fmadd(mxy(10), mxy(5), mxy(16), qx)
              call fmln(mxy(9), mxy(5), qx)
              qx%ndigli = 0
              call fmaddi(mxy(5), -1, qx)
              call fmmpy(mxy(10), mxy(5), mxy(14), qx)
              call fmadd_r2(mxy(10), mxy(14), qx)
              call fmlngm(mxy(16), mxy(15), qx)
              call fmsub(mxy(14), mxy(15), mxy(5), qx)
              call fmexp(mxy(5), mxy(12), qx)
              qx%ndige = 0
              call fmeq(mxy(12), mresult, qx)
              mresult%mp(1) = ksign*mresult%mp(1)
              return
          endif

!             Compute iextra, the number of extra digits required to compensate for
!             cancellation error.

          mzero = 0
          mt1 = max(mxy(15)%mp(2), mxy(1)%mp(2))
          mt1 = max(mt1, mxy(2)%mp(2))
          iextra = int(max(mt1, mzero))
          if (mt1 >= qx%mexpov) iextra = 0
          if (qx%ndig+iextra > 3*10**5) then
              qx%kflag = -4
              call fmunknown(mresult, qx)
              mresult%mp(1) = ksign*mresult%mp(1)
              return
          endif
          if (iextra > 0) then
              call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
              call fmequ_r1(mxy(2), qx%ndig, qx%ndig+iextra, qx)
          endif
          call fmndig(qx%ndig + iextra, qx)
          if (k10 == -1 .and. k09 == -1) then
              jr = qx%kround
              qx%kround = 1
              call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
              call fmm2i(mxy(1), n, qx)
              call fmequ(mb, mxy(2), ndsave, qx%ndig, qx)
              call fmsub(mxy(2), mxy(1), mxy(12), qx)
              call fmi2m(1, mxy(11), qx)
              call fmsub(mxy(12), mxy(11), mxy(1), qx)
              qx%kround = jr
          endif

          call fmsub(mxy(1), mxy(2), mxy(15), qx)
          call fmi2m(1, mxy(9), qx)
          call fmi2m(2, mxy(10), qx)
          call fmadd(mxy(15), mxy(9), mxy(17), qx)
          call fmadd_r1(mxy(1), mxy(9), qx)
          call fmadd_r1(mxy(2), mxy(9), qx)
          k10 = 0
          k11 = 0
          kc = 0
          if (mxy(1)%mp(1) < 0) then
              call fmint(mxy(1), mxy(11), qx)
              call fmmod(mxy(11), mxy(10), mxy(12), qx)
              if (mxy(12)%mp(3) == 0) then
                  k10 = 1
                  call fmadd_r1(mxy(1), mxy(9), qx)
              endif
          endif
          if (mxy(2)%mp(1) < 0) then
              call fmint(mxy(2), mxy(11), qx)
              call fmmod(mxy(11), mxy(10), mxy(12), qx)
              if (mxy(12)%mp(3) == 0) then
                  k11 = 1
                  call fmadd_r1(mxy(2), mxy(9), qx)
              endif
          endif
          if (mxy(17)%mp(1) < 0) then
              call fmint(mxy(17), mxy(11), qx)
              call fmmod(mxy(11), mxy(10), mxy(12), qx)
              if (mxy(12)%mp(3) == 0) then
                  kc = 1
                  call fmadd_r1(mxy(17), mxy(9), qx)
              endif
          endif
          call fmlngm(mxy(1), mxy(15), qx)
          call fmlngm(mxy(2), mxy(16), qx)
          call fmsub_r1(mxy(15), mxy(16), qx)
          call fmlngm(mxy(17), mxy(16), qx)
          call fmsub_r1(mxy(15), mxy(16), qx)
          call fmexp(mxy(15), mxy(4), qx)
          qx%ndige = 0
          if (k10 == 1 .or. k11 == 1 .or. kc == 1) then
              call fmi2m(1, mxy(9), qx)
              if (k10 == 1) then
                  call fmsub_r1(mxy(1), mxy(9), qx)
                  call fmdiv_r1(mxy(4), mxy(1), qx)
              endif
              if (k11 == 1) then
                  call fmsub_r1(mxy(2), mxy(9), qx)
                  call fmmpy_r1(mxy(4), mxy(2), qx)
              endif
              if (kc == 1) then
                  call fmsub_r1(mxy(17), mxy(9), qx)
                  call fmmpy_r1(mxy(4), mxy(17), qx)
              endif
          endif
          call fmeq(mxy(4), mxy(17), qx)
      else
          call fmfact(mxy(1), mxy(16), qx)
          call fmfact(mxy(2), mxy(3), qx)
          call fmfact(mxy(15), mxy(17), qx)
          call fmmpy(mxy(17), mxy(3), mxy(7), qx)
          call fmdiv(mxy(16), mxy(7), mxy(17), qx)
      endif

      mxy(17)%mp(1) = ksign*mxy(17)%mp(1)

      call fmeq(mxy(17), mresult, qx)

      return
      end subroutine fmcomb_m1

      subroutine fmcomb_sc(ma, mb, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = comb(ma,mb).

!  kresult = 1 is returned if a special case gives the value of comb(ma,mb).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mxy(17), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal, mblocal
      logical, external :: fmcomp

      kresult = 0

      qx%namest(qx%ncall) = 'FMCOMB   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp2(ma, mb, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)
      call fmequ(mb, mblocal, ndsave, qx%ndig, qx)

      if ((malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) .or.  &
          (mblocal%mp(2) == qx%munkno .and. mblocal%mp(5) >= 0)) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (mblocal%mp(1) < 0) then
          call fmint(mblocal, mxy(2), qx)
          if (fmcomp(mblocal, '==', mxy(2), qx)) then
              call fmi2m(0, mresult, qx)
              kresult = 1
              return
          endif
      endif

      if (malocal%mp(1) > 0 .and. mblocal%mp(1) > 0) then
          if (fmcomp(malocal, '>', mblocal, qx)) then
              call fmsub(malocal, mblocal, mxy(5), qx)
              call fmmin(mblocal, mxy(5), mxy(1), qx)
              call fmdpm(0.99d+10, mxy(3), qx)
              if (fmcomp(mxy(1), '>', mxy(3), qx)) then

                  call fmln(malocal, mxy(1), qx)
                  qx%ndigli = 0
                  call fmaddi(mxy(1), -1, qx)
                  call fmmpy_r1(mxy(1), malocal, qx)

                  call fmln(mblocal, mxy(2), qx)
                  qx%ndigli = 0
                  call fmaddi(mxy(2), -1, qx)
                  call fmmpy_r1(mxy(2), mblocal, qx)
                  call fmsub_r1(mxy(1), mxy(2), qx)

                  call fmln(mxy(5), mxy(2), qx)
                  qx%ndigli = 0
                  call fmaddi(mxy(2), -1, qx)
                  call fmmpy_r1(mxy(2), mxy(5), qx)
                  call fmsub_r1(mxy(1), mxy(2), qx)

                  call fmpi(mxy(3), qx)
                  qx%ndigpi = 0
                  call fmmpyi_r1(mxy(3), 2, qx)
                  call fmmpy_r1(mxy(3), mblocal, qx)
                  call fmmpy_r1(mxy(3), mxy(5), qx)
                  call fmdiv_r2(malocal, mxy(3), qx)
                  call fmln(mxy(3), mxy(2), qx)
                  qx%ndigli = 0
                  call fmdivi_r1(mxy(2), 2, qx)
                  call fmadd_r1(mxy(1), mxy(2), qx)

                  call fmexp(mxy(1), mresult, qx)
                  qx%ndige = 0

                  if (mresult%mp(2) == qx%mexpov) then
                      kresult = 1
                      return
                  endif
              endif
          endif
      endif

      return
      end subroutine fmcomb_sc

      function fmcomp(ma, lrel, mb, qx)

!  Logical comparison of FM numbers ma and mb.

!  lrel is a character description of the comparison to be done:
!  lrel = 'eq' returns fmcomp = .true. if ma == mb
!       = 'ne', 'ge', 'gt', 'le', 'lt' also work like a logical if.
!       = '==', '/=', '<', '<=', '>', '>=' may be used.

!  For comparisons involving 'unknown' or two identical special symbols such as
!  +overflow,'eq',+overflow, fmcomp is returned false and a kflag = -4 error condition is returned.

      use fmvals_parallel
      implicit none

      logical :: fmcomp
      character(*) :: lrel
      type(multi) :: ma, mb
      intent (in) :: ma, lrel, mb
      character(2) :: jrel
      integer :: jcomp
      logical :: comp
      type(fm_settings) :: qx


      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMCOMP'

      if (qx%ncall <= qx%lvltrc .and. abs(qx%ntrace) >= 2) then
          write (qx%kw, "(' Input to FMCOMP')")

          if (qx%ntrace > 0) then
              call fmprnt(ma, qx)
              if (index('=/<>', lrel(1:1)) > 0) then
                  write (qx%kw, "(8X, A)") lrel
              else
                  write (qx%kw, "(7X, '.', A, '.')") lrel
              endif
              call fmprnt(mb, qx)
          else
              call fmntrj(ma, qx%ndig, qx)
              if (index('=/<>', lrel(1:1)) > 0) then
                  write (qx%kw, "(8X, A)") lrel
              else
                  write (qx%kw, "(7X, '.', A, '.')") lrel
              endif
              call fmntrj(mb, qx%ndig, qx)
          endif
      endif

!             jcomp will be 1 if ma >  mb
!                           2 if ma == mb
!                           3 if ma <  mb

!             Check for special cases.

      jrel = lrel
      if (lrel /= 'EQ' .and. lrel /= 'NE' .and. lrel /= 'LT' .and.  &
          lrel /= 'GT' .and. lrel /= 'LE' .and. lrel /= 'GE') then
          if (lrel == 'eq' .or. lrel == '==') then
              jrel = 'EQ'
          else if (lrel == 'ne' .or. lrel == '/=') then
              jrel = 'NE'
          else if (lrel == 'lt' .or. lrel == '<') then
              jrel = 'LT'
          else if (lrel == 'gt' .or. lrel == '>') then
              jrel = 'GT'
          else if (lrel == 'le' .or. lrel == '<=') then
              jrel = 'LE'
          else if (lrel == 'ge' .or. lrel == '>=') then
              jrel = 'GE'
          else
              fmcomp = .false.
              comp = .false.
              qx%kflag = -4
              if (qx%ncall /= 1 .or. qx%kwarn <= 0) then
                  call fmcomp3(comp, qx)
                  return
              endif
              if (qx%kwarn <= 0) then
                  call fmcomp3(comp, qx)
                  return
              endif
              write (qx%kw,                                                     &
                     "(/' Error of type KFLAG = -4 in FM package in', "     //  &
                     "' routine FMCOMP'//1X, A, ' is not one of the six', " //  &
                     "' recognized comparisons.'//' .FALSE. has been', "    //  &
                     "' returned.'/)"                                           &
                    ) lrel
              if (qx%kwarn >= 2) then
                  stop
              endif
              call fmcomp3(comp, qx)
              return
          endif
      endif

      if ((ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == qx%munkno .and. mb%mp(5) >= 0)) then
          fmcomp = .false.
          comp = .false.
          qx%kflag = -4
          call fmcomp3(comp, qx)
          return
      endif

      call fmcomp2(ma, mb, jcomp, qx)
      if (jcomp == 4) then
          fmcomp = .false.
          return
      endif

!             Match the jcomp value to the requested comparison.

      if (jcomp == 1 .and. ma%mp(1) < 0) then
          jcomp = 3
      else if (jcomp == 3 .and. mb%mp(1) < 0) then
          jcomp = 1
      endif

      fmcomp = .false.
      comp = .false.
      if (jcomp == 1 .and. (jrel == 'GT' .or. jrel == 'GE' .or. jrel == 'NE')) then
          fmcomp = .true.
          comp = .true.
      endif
      if (jcomp == 2 .and. (jrel == 'EQ' .or. jrel == 'GE' .or. jrel == 'LE')) then
          fmcomp = .true.
          comp = .true.
      endif
      if (jcomp == 3 .and. (jrel == 'NE' .or. jrel == 'LT' .or. jrel == 'LE')) then
          fmcomp = .true.
          comp = .true.
      endif
      call fmcomp3(comp, qx)

      return
      end function fmcomp

      subroutine fmcomp2(ma, mb, jcomp, qx)

!  Return  jcomp = 1 if ma >  mb
!                = 2 if ma == mb
!                = 3 if ma <  mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: jcomp
      intent (in) :: ma, mb
      intent (inout) :: jcomp
      type(fm_settings) :: qx

      integer :: j, nlast
      double precision :: d, xe, xf, ye, yf
      logical :: comp

      if (abs(ma%mp(2)) == qx%mexpov .and. ma%mp(2) == mb%mp(2) .and.  &
          ma%mp(3) == mb%mp(3) .and. ma%mp(1) == mb%mp(1)) then
          xe = ma%mp(4)
          xf = ma%mp(5)
          xf = -xf/maxint
          ye = mb%mp(4)
          yf = mb%mp(5)
          yf = -yf/maxint
          if (xe > ye) then
              jcomp = 1
          else if (xe < ye) then
              jcomp = 3
          else
              if (xf > yf) then
                  jcomp = 1
              else if (xf < yf) then
                  jcomp = 3
              else
                  jcomp = 2
                  if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
                      d = 1.0d+10
                  else
                      d = 4
                  endif
                  if (abs(xe) == huge(qx%mbase)/d) then
                      comp = .false.
                      qx%kflag = -4
                      if (qx%ncall /= 1 .or. qx%kwarn <= 0) then
                          call fmcomp3(comp, qx)
                          jcomp = 4
                          return
                      endif
                      if (qx%kwarn <= 0) then
                          call fmcomp3(comp, qx)
                          jcomp = 4
                          return
                      endif
                      write (qx%kw,                                                         &
                             "(/' Error of type KFLAG = -4 in FM package in routine', " //  &
                             "' FMCOMP'//' Two numbers in the same overflow or', "      //  &
                             "' underflow category are beyond the tracking range.'//"   //  &
                             "' .FALSE. has been returned.'/)"                              &
                             )
                      call fmcomp3(comp, qx)
                      jcomp = 4
                      return
                  endif
              endif
          endif
          return
      endif
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) then
          if (ma%mp(1) == mb%mp(1)) then
              call fmovun_xexf(ma, xe, xf, qx)
              call fmovun_xexf(mb, ye, yf, qx)
              if (xe > ye) then
                  jcomp = 1
              else if (xe < ye) then
                  jcomp = 3
              else
                  if (xf > yf) then
                      jcomp = 1
                  else if (xf < yf) then
                      jcomp = 3
                  else
                      jcomp = 2
                      if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
                          d = 1.0d+10
                      else
                          d = 4
                      endif
                      if (abs(xe) == huge(qx%mbase)/d) then
                          comp = .false.
                          qx%kflag = -4
                          if (qx%ncall /= 1 .or. qx%kwarn <= 0) then
                              call fmcomp3(comp, qx)
                              jcomp = 4
                              return
                          endif
                          write (qx%kw,                                                         &
                                 "(/' Error of type KFLAG = -4 in FM package in routine', " //  &
                                 "' FMCOMP'//' Two numbers in the same overflow or', "      //  &
                                 "' underflow category are beyond the tracking range.'//"   //  &
                                 "' .FALSE. has been returned.'/)"                              &
                                 )
                          call fmcomp3(comp, qx)
                          jcomp = 4
                          return
                      endif
                  endif
              endif
              return
          endif
      endif

!             Check for zero.

      qx%kflag = 0
      if (ma%mp(3) == 0) then
          jcomp = 2
          if (mb%mp(3) == 0) return
          if (mb%mp(1) < 0) jcomp = 1
          if (mb%mp(1) > 0) jcomp = 3
          return
      endif
      if (mb%mp(3) == 0) then
          jcomp = 1
          if (ma%mp(1) < 0) jcomp = 3
          return
      endif

!             Check for opposite signs.

      if (ma%mp(1) > 0 .and. mb%mp(1) < 0) then
          jcomp = 1
          return
      endif
      if (mb%mp(1) > 0 .and. ma%mp(1) < 0) then
          jcomp = 3
          return
      endif

!             See which one is larger in absolute value.

      if (ma%mp(2) > mb%mp(2)) then
          jcomp = 1
          return
      endif
      if (mb%mp(2) > ma%mp(2)) then
          jcomp = 3
          return
      endif
      nlast = qx%ndig + 1

      do j = 2, nlast
         if (abs(ma%mp(j+1)) > abs(mb%mp(j+1))) then
             jcomp = 1
             return
         endif
         if (abs(mb%mp(j+1)) > abs(ma%mp(j+1))) then
             jcomp = 3
             return
         endif
      enddo

      jcomp = 2

      return
      end subroutine fmcomp2

      subroutine fmcomp3(comp, qx)

!  Trace printing for fmcomp.

      use fmvals_parallel
      implicit none

      logical :: comp
      intent (in) :: comp
      type(fm_settings) :: qx

      if (qx%ntrace /= 0) then
          if (qx%ncall <= qx%lvltrc .and. abs(qx%ntrace) >= 1) then
              if (qx%kflag == 0) then
                  write (qx%kw,                                                      &
                         "(' FMCOMP', 15X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                         "I10, 5X, 'NDIG =', I10)"                                   &
                        ) qx%ncall, int(qx%mbase), qx%ndig
              else
                  write (qx%kw,                                                     &
                         "(' FMCOMP', 6X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                         "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"               &
                        ) qx%ncall, int(qx%mbase), qx%ndig, qx%kflag
              endif
              if (comp) then
                  write (qx%kw, "(7X, '.TRUE.')")
              else
                  write (qx%kw, "(7X, '.FALSE.')")
              endif
          endif
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmcomp3

      function fmcompare(ma, lrel, mb, qx)

      use fmvals_parallel
      implicit none

      logical :: fmcompare
      character(*) :: lrel
      type(multi) :: ma, mb
      intent (in) :: ma, lrel, mb
      type(fm_settings) :: qx

      logical, external :: fmcomp

      fmcompare = fmcomp(ma, lrel, mb, qx)

      return
      end function fmcompare

      subroutine fmcons(qx)

!  Set several saved machine precision constants.

      use fmvals_parallel
      implicit none

      type(fm_settings) :: qx

      qx%mblogs = qx%mbase
      qx%alogmb = log(real(qx%mbase))
      qx%alogm2 = qx%alogmb/log(2.0)
      qx%alogmx = log(real(maxint))
      qx%alogmt = qx%alogmb/log(10.0)
      qx%ngrd21 = int(2.0/qx%alogmt + 1.0)
      qx%ngrd52 = int(5.0/qx%alogmt + 2.0)
      qx%ngrd22 = int(2.0/qx%alogmt + 2.0)
      if (qx%mbase < 1000) then
          qx%ngrd21 = 2*qx%ngrd21
          qx%ngrd52 = 4*qx%ngrd52
          qx%ngrd22 = 2*qx%ngrd22
      else
          qx%ngrd21 = qx%ngrd21 + 1
          qx%ngrd52 = qx%ngrd52 + 1
          qx%ngrd22 = qx%ngrd22 + 1
      endif
      qx%mexpab = aint (qx%mxexp2/5)
      qx%dlogmb = log(dble(qx%mbase))
      qx%dlogtn = log(10.0d0)
      qx%dlogtw = log(2.0d0)
      qx%dppi = 4.0d0*atan(1.0d0)
      qx%dlogtp = log(2.0d0*qx%dppi)
      qx%dlogpi = log(qx%dppi)
      qx%dlogeb = -log(qx%dpeps)/qx%dlogmb

      return
      end subroutine fmcons

      subroutine fmcos(ma, mb, qx)

!  mb = cos(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(6), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmcos_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call fmcos_m1(ma, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmcos

      subroutine fmcos_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing cos(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(6), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: jcos, jsin, jswap, krndsave, kwrnsv, ndsv

      qx%ndigpi = 0
      qx%mbspi = 0
      krndsave = qx%kround
      qx%kround = 1
      call fmequ(ma, mresult, ndsave, qx%ndig, qx)
      mresult%mp(1) = 1
      if (ma%mp(2) > 3*10**5 .and. qx%krad == 1) then
          call fmunknown(mresult, qx)
          qx%kround = krndsave
          return
      endif
      call fmeq(mresult, mxy(5), qx)
      kwrnsv = qx%kwarn
      qx%kwarn = 0

!             Reduce the argument, convert to radians if the input is in degrees, and evaluate
!             the function.

      call fmrdc(mresult, jsin, jcos, jswap, qx)
      if (qx%kround /= 1 .and. qx%krad /= 1) then
          call fmi2m(30, mxy(1), qx)
          call fmsub(mresult, mxy(1), mxy(2), qx)
          if (mxy(2)%mp(3) == 0 .and. jswap == 1) then
              call fmst2m('0.5', mxy(1), qx)
              call fmmpyi(mxy(1), jcos, mresult, qx)
              qx%kround = krndsave
              return
          endif
      endif
      qx%kwarn = kwrnsv
      if (mresult%mp(2) == qx%munkno) then
          if (qx%krad /= 1 .or. jswap == 1) then
              call fmeq(mxy(5), mresult, qx)
              call fmrdc(mresult, jsin, jcos, jswap, qx)
              qx%kround = krndsave
              return
          endif
          if (qx%mbspi /= qx%mbase .or. qx%ndigpi < qx%ndig) then
              ndsv = qx%ndig
              call fmndig(qx%ndig + 2, qx)
              call fmpi(mxy(3), qx)
              qx%ndigpi = 0
              call fmndig(ndsv, qx)
          endif
          call fmpi(mxy(6), qx)
          qx%ndigpi = 0
          call fmdiv(mxy(5), mxy(6), mxy(3), qx)
          call fmnint(mxy(3), mxy(2), qx)
          call fmmpy(mxy(2), mxy(6), mxy(1), qx)
          call fmsub_r2(mxy(5), mxy(1), qx)
          if (mxy(1)%mp(3) == 0) call fmulp(mxy(5), mxy(1), qx)
          call fmi2m(1, mxy(3), qx)
          call fmsqr_r1(mxy(1), qx)
          call fmdivi_r1(mxy(1), 2, qx)
          call fmsub_r2(mxy(3), mxy(1), qx)
          call fmsub_r1(mxy(1), mxy(3), qx)
          if (mxy(1)%mp(3) == 0) then
              call fmi2m(jcos, mresult, qx)
          else
              call fmeq(mxy(5), mresult, qx)
              call fmrdc(mresult, jsin, jcos, jswap, qx)
          endif
          qx%kround = krndsave
          return
      endif
      if (qx%krad == 0) then
          if (qx%mbspi /= qx%mbase .or. qx%ndigpi < qx%ndig) then
              ndsv = qx%ndig
              call fmndig(qx%ndig + 2, qx)
              call fmpi(mxy(4), qx)
              qx%ndigpi = 0
              call fmndig(ndsv, qx)
          endif
          call fmpi(mxy(6), qx)
          qx%ndigpi = 0
          call fmmpy_r1(mresult, mxy(6), qx)
          call fmdivi_r1(mresult, 180, qx)
      endif
      if (mresult%mp(2) /= qx%munkno) then
          if (jswap == 0) then
              call fmcos2(mresult, mxy(4), qx)
              call fmeq(mxy(4), mresult, qx)
          else
              if (mresult%mp(2) < 0 .or. qx%ndig <= 50) then
                  call fmsin2(mresult, mxy(4), qx)
                  call fmeq(mxy(4), mresult, qx)
              else
                  call fmcos2(mresult, mxy(4), qx)
                  call fmi2m(1, mxy(2), qx)
                  call fmsqr(mxy(4), mresult, qx)
                  call fmsub_r2(mxy(2), mresult, qx)
                  call fmsqrt_r1(mresult, qx)
              endif
          endif
      endif

!             Append the sign and return.

      if (jcos == -1) call fmnegate(mresult, qx)

      qx%kround = krndsave

      return
      end subroutine fmcos_m1

      subroutine fmcos_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = cos(ma).

!  kresult = 1 is returned if a special case gives the value of cos(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(6), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j, k
      double precision :: b, pi, x, xe, xf

      kresult = 0

      qx%namest(qx%ncall) = 'FMCOS    '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, mxy(5), ndsave, qx%ndig, qx)

      if (mxy(5)%mp(2) == qx%munkno .and. mxy(5)%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      call fmovun_xexf(mxy(5), xe, xf, qx)
      if (2*xe < -ndsave .and. qx%kround == 1) then
          call fmi2m(1, mresult, qx)
          kresult = 1
          return
      endif

      if (mxy(5)%mp(2) == qx%munkno .and. mxy(5)%mp(5) < 0) then
          if (2*xe < -ndsave) then
              call fmi2m(1, mxy(2), qx)
              if (qx%krad == 1) then
                  call fmsqr(mxy(5), mxy(3), qx)
                  call fmdivi_r1(mxy(3), 2, qx)
                  call fmsub(mxy(2), mxy(3), mresult, qx)
              else
                  call fmpi(mxy(3), qx)
                  qx%ndigpi = 0
                  call fmmpy_r2(mxy(5), mxy(3), qx)
                  call fmdivi_r1(mxy(3), 180, qx)
                  call fmsqr_r1(mxy(3), qx)
                  call fmdivi_r1(mxy(3), 2, qx)
                  call fmsub(mxy(2), mxy(3), mresult, qx)
              endif
          else
              call fmunknown(mresult, qx)
              if (xe*qx%dlogmb+log(xf) < log(1.0d+12)) then
                  b = qx%mbase
                  if (qx%krad == 1) then
                      x = cos(xf*b**xe)
                  else
                      pi = acos(-1.0d0)
                      x = cos(pi*xf*b**xe/180.0d0)
                  endif
                  if (x < 0) then
                      mresult%mp(1) = -1
                      x = -x
                  endif
                  if (x == 1.0d0) then
                      xe = 1
                      xf = 1/b
                  else
                      xe = 0
                      xf = x
                  endif
                  do j = 1, 5
                     if (xf >= 1) then
                         xe = xe + 1
                         xf = xf / b
                     else if (xf < 1.0d0/b) then
                         xe = xe - 1
                         xf = xf * b
                     else
                         exit
                     endif
                  enddo
                  mresult%mp(4) = xe
                  mresult%mp(5) = -xf*maxint
              endif
          endif
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      call fmovun_xexf(mxy(5), xe, xf, qx)
      if (qx%kround /= 1 .and. mxy(5)%mp(2) < -ndsave) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          call fmsqr(mxy(5), mxy(1), qx)
          if (qx%krad == 0) then
              call fmpi(mxy(2), qx)
              qx%ndigpi = 0
              call fmsqr(mxy(2), mxy(3), qx)
              call fmdivi_r1(mxy(3), 32400, qx)
              call fmmpy_r1(mxy(1), mxy(3), qx)
          endif
          call fmdivi(mxy(1), -2, mxy(3), qx)
          if (mxy(3)%mp(2) > qx%mexpun) then
              call fmi2m(1, mxy(1), qx)
              call fmadd(mxy(1), mxy(3), mresult, qx)
          else if (mxy(5)%mp(2) == qx%mexpun) then
              call fmi2m(1, mxy(1), qx)
              call fmadd(mxy(1), mxy(3), mresult, qx)
          else if (qx%kround == -1 .or. qx%kround == 0) then
              call fmi2m(1, mxy(1), qx)
              call fmdp2m(0.9d0, mxy(2), qx)
              call fmulp(mxy(2), mxy(3), qx)
              call fmsub(mxy(1), mxy(3), mresult, qx)
          else
              call fmi2m(1, mresult, qx)
          endif
          if (qx%kflag > 0) qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          kresult = 1
      endif

      return
      end subroutine fmcos_sc

      subroutine fmcos2(ma, mb, qx)

!  internal subroutine for mb = cos(ma) where 0 <= ma <= 1.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: maxv
      integer :: j, j2, k2, kl, ktwo, kwrnsv, l, l2, large, n2, nbot, ndsav1, ndsave, nterm
      real :: alog2, alogt, t
      type(multi) :: mxy(3), mjsums(ljsums)
      double precision :: tj, xe, xf

      call fmalloc(mb, qx%ndig+2, qx)

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      if (ma%mp(3) == 0) then
          call fmi2m(1, mb, qx)
          return
      endif
      ndsave = qx%ndig
      kwrnsv = qx%kwarn
      qx%kwarn = 0

!             Use the direct series:  cos(x) = 1 - x**2/2! + x**4/4! - ...

!             The argument will be divided by 2**k2 before the series is summed.  The series will be
!             added as j2 concurrent series.

!             Since x is small when the series is summed, cos(x) - 1 is computed.  Then a version of
!             the recovery formula can be used that does not suffer from severe cancellation.

      t = max(qx%ndig-qx%ngrd52, 2)
      alog2 = log(2.0)
      alogt = log(t)
      tj = 0.69*(qx%ndig*qx%alogmt)**0.3333
      j2 = int(tj)
      j2 = max(2, min(j2+mod(j2, 2), ljsums))
      if (qx%ndig > 2000) then
          j2 = -4.0 + 3.0*alogt
      endif
      k2 = max(2, int(1.25*(qx%ndig*qx%alogmt)**0.3333 - 3.4))


      call fmovun_xexf(ma, xe, xf, qx)
      tj = - ( xe*qx%dlogmb + log(xf) ) / qx%dlogtw
      if (tj >= k2) then
          l = k2
      else if (tj > 0) then
          l = int(tj)
      else
          l = 0
      endif
      k2 = k2 - l
      if (qx%ndig > 2000) then
          k2 = 5.8*qx%alogmb - 263 + (35 - 0.58*qx%alogmb)*alogt
      endif
      if (k2 <= 0) then
          k2 = 0
          j2 = int(.43*sqrt(t*qx%alogmb/(alogt+real(l)*alog2)) + .33)
          j2 = max(1, min(j2, ljsums))
      endif

      n2 = int(t*qx%alogmb/(alogt+real(l)*alog2))
      l2 = int(log(real(n2)+2.0d0**k2)/qx%alogmb)
      call fmndig(qx%ndig + max(l2, 0), qx)
      ndsav1 = qx%ndig
      j2 = max(2, min(j2+mod(j2, 2), ljsums))

!             Divide the argument by 2**k2.

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      ktwo = 1
      maxv = mxbase/2
      if (k2 > 0) then
          do j = 1, k2
             ktwo = 2*ktwo
             if (ktwo > maxv) then
                 call fmcsdivi_r1(mxy(1), ktwo, qx)
                 ktwo = 1
             endif
          enddo
          if (ktwo > 1) call fmcsdivi_r1(mxy(1), ktwo, qx)
      endif

!             Split into j2 concurrent sums and reduce ndig while computing each term in the sum as
!             the terms get smaller.

      nterm = 2
      call fmi2m(1, mxy(2), qx)
      do j = 1, j2
         nbot = nterm*(nterm-1)
         call fmcsdivi_r1(mxy(2), nbot, qx)
         call fmeq(mxy(2), mjsums(j), qx)
         nterm = nterm + 2
      enddo
      kl = 1
      if (mxy(1)%mp(2) < -qx%ndig) then
          kl = 0
      else
          call fmsqr_r1(mxy(1), qx)
          call fmipwr(mxy(1), j2, mxy(3), qx)
          if (mxy(3)%mp(2) < -qx%ndig) kl = 0
      endif

      if (kl > 0) then
          do while (kl > 0)
             call fmcsmpy_r1(mxy(2), mxy(3), qx)
             do j = 1, j2
                large = int(intmax/nterm)
                if (nterm > large .or. nterm > mxbase/(nterm-1)) then
                    call fmcsdivi_r1(mxy(2), nterm, qx)
                    nbot = nterm - 1
                    call fmcsdivi_r1(mxy(2), nbot, qx)
                else
                    nbot = nterm*(nterm-1)
                    call fmcsdivi_r1(mxy(2), nbot, qx)
                endif
                call fmndig(ndsav1, qx)
                call fmcsaddnn_r1(mjsums(j), mxy(2), qx)
                if (qx%kflag /= 0) then
                    kl = 0
                    exit
                endif
                call fmndig(ndsav1 - int(mjsums(j)%mp(2)-mxy(2)%mp(2)), qx)
                if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                nterm = nterm + 2
             enddo
          enddo
      endif

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmcsnsums(j2, mjsums, qx)
      call fmeq(mjsums(j2), mxy(3), qx)
      call fmnegate(mxy(1), qx)
      do j = 2, j2
         call fmcsmpy_r1(mxy(3), mxy(1), qx)
         call fmadd_r1(mxy(3), mjsums(j2-j+1), qx)
      enddo
      call fmcsmpy_r1(mxy(3), mxy(1), qx)

!             Reverse the effect of reducing the argument to compute cos(ma).

      call fmndig(ndsav1, qx)
      if (k2 > 0) then
          if (ndsave <= 20) then
              call fmi2m(2, mxy(1), qx)
              do j = 1, k2
                 call fmadd(mxy(3), mxy(1), mxy(2), qx)
                 call fmcsmpy_r1(mxy(2), mxy(3), qx)
                 call fmadd(mxy(2), mxy(2), mxy(3), qx)
              enddo
          else
              do j = 1, k2
                 call fmsqr(mxy(3), mxy(2), qx)
                 call fmadd(mxy(3), mxy(3), mxy(1), qx)
                 call fmadd_r1(mxy(2), mxy(1), qx)
                 call fmadd(mxy(2), mxy(2), mxy(3), qx)
              enddo
          endif
      endif
      call fmi2m(1, mxy(2), qx)
      call fmadd_r2(mxy(2), mxy(3), qx)

      call fmequ(mxy(3), mb, ndsav1, ndsave, qx)
      qx%ndig = ndsave
      qx%kwarn = kwrnsv

      return
      end subroutine fmcos2

      subroutine fmcos_sin(ma, mb, mc, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      type(fm_settings) :: qx

      call fmcssn(ma, mb, mc, qx)

      return
      end subroutine fmcos_sin

      subroutine fmcosh(ma, mb, qx)

!  mb = cosh(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(3), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmcosh_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmcosh_m1(ma, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmcosh

      subroutine fmcosh_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing cosh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(3), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: krndsave, nmethd
      double precision :: xe

      krndsave = qx%kround
      qx%kround = 1
      call fmequ(ma, mresult, ndsave, qx%ndig, qx)

!             Use a series for small arguments, fmexp for large ones.

      if (mresult%mp(2) == qx%munkno) return
      call fmovun_xe(mresult, xe, qx)
      if (qx%mbase > 99) then
          if (xe <= 0) then
              nmethd = 1
          else if (xe >= 2) then
              nmethd = 2
          else if (abs(mresult%mp(3)) < 10) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          if (xe <= 0) then
              nmethd = 1
          else
              nmethd = 2
          endif
      endif

      if (nmethd == 1) then
          call fmcosh2(mresult, mxy(1), qx)
          call fmeq(mxy(1), mresult, qx)
      else
          call fmexp(mresult, mxy(1), qx)
          qx%ndige = 0
          call fmeq(mxy(1), mresult, qx)
          if (mresult%mp(2) == qx%mexpov) then
              return
          endif
          call fmovun_xe(mresult, xe, qx)
          if (xe <= (qx%ndig+1)/2) then
              call fmi2m(1, mxy(1), qx)
              call fmdiv_r1(mxy(1), mresult, qx)
              call fmadd_r1(mresult, mxy(1), qx)
          endif
          call fmdivi_r1(mresult, 2, qx)
      endif

      qx%kround = krndsave

      return
      end subroutine fmcosh_m1

      subroutine fmcosh_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = cosh(ma).

!  kresult = 1 is returned if a special case gives the value of mresult for cosh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(3), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      double precision :: xe, ye

      kresult = 0

      qx%namest(qx%ncall) = 'FMCOSH   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

      if (mxy(1)%mp(2) == qx%munkno .and. mxy(1)%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif
      if (mxy(1)%mp(2) == qx%munkno) then
          if (mxy(1)%mp(5) < 0) then
              call fmovun_xe(mxy(1), xe, qx)
              if (2*xe < -ndsave) then
                  call fmi2m(1, mxy(3), qx)
                  call fmsqr(mxy(1), mxy(2), qx)
                  call fmdivi_r1(mxy(2), 2, qx)
                  call fmadd(mxy(3), mxy(2), mresult, qx)
              else
                  call fmexp(mxy(1), mxy(2), qx)
                  qx%ndige = 0
                  call fmi2m(1, mxy(3), qx)
                  call fmdiv_r1(mxy(3), mxy(2), qx)
                  call fmadd_r2(mxy(2), mxy(3), qx)
                  call fmdivi(mxy(3), 2, mresult, qx)
              endif
          else
              call fmunknown(mresult, qx)
          endif
          kresult = 1
          return
      endif

      mxy(1)%mp(1) = 1
      if (mxy(1)%mp(3) == 0) then
          call fmi2m(1, mresult, qx)
          kresult = 1
          return
      endif
      if (mxy(1)%mp(2) == qx%mexpov) then
          call fmabs(mxy(1), mxy(3), qx)
          call fmexp(mxy(3), mresult, qx)
          qx%ndige = 0
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      call fmovun_xe(mxy(1), xe, qx)
      if (qx%kround /= 1 .and. xe < -ndsave) then
          call fmsqr(mxy(1), mxy(3), qx)
          call fmdivi(mxy(3), 2, mxy(2), qx)
          call fmovun_xe(mxy(1), ye, qx)
          if (ye > qx%mexpun) then
              call fmi2m(1, mxy(3), qx)
              call fmadd(mxy(3), mxy(2), mresult, qx)
          else if (mxy(1)%mp(2) == qx%mexpun) then
              call fmi2m(1, mxy(3), qx)
              call fmadd(mxy(3), mxy(2), mresult, qx)
          else if (qx%kround == 2) then
              call fmi2m(1, mxy(3), qx)
              call fmulp(mxy(3), mxy(2), qx)
              call fmadd(mxy(3), mxy(2), mresult, qx)
          else
              call fmi2m(1, mresult, qx)
          endif
          if (qx%kflag > 0) qx%kflag = 0
          kresult = 1
          return
      endif
      if (xe < -ndsave) then
          call fmi2m(1, mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine fmcosh_sc

      subroutine fmcosh2(ma, mb, qx)

!  Internal subroutine for mb = cosh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: maxv
      integer :: j, j2, k, k2, kexp, kl, ktwo, kwrnsv, l, l2, large, n2, nbot, ndsav1, ndsave, nterm
      real :: alog2, alogt, b, t, tj
      double precision :: xe
      type(multi) :: mxy(3), mjsums(ljsums)

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      if (ma%mp(3) == 0) then
          call fmi2m(1, mb, qx)
          return
      endif
      ndsave = qx%ndig
      kwrnsv = qx%kwarn
      qx%kwarn = 0

!             Use the direct series:  cosh(x) = 1 + x**2/2! + x**4/4! - ...

!             The argument will be divided by 2**k2 before the series is summed.  The series will be
!             added as j2 concurrent series.

!             Since x is small when the series is summed, cosh(x) - 1 is computed.  Then a version
!             of the recovery formula can be used that does not suffer from severe cancellation.

      b = real(qx%mbase)
      k = qx%ngrd52
      t = max(qx%ndig-k, 2)
      alog2 = log(2.0)
      alogt = log(t)
      tj = 0.65*(qx%ndig*qx%alogmt)**0.3333 - 2.0
      j2 = int(tj)
      j2 = max(2, min(j2+mod(j2, 2), ljsums))
      k2 = int(1.38*(qx%ndig*qx%alogmt)**0.3333 - 1.8)

      tj = -(real(ma%mp(2))*qx%alogmb +  &
             log(real(ma%mp(3))/b + real(ma%mp(4))/(b*b)))/alog2 - 0.3
      if (tj >= k2) then
          l = k2
      else if (tj > 0) then
          l = int(tj)
      else
          l = 0
      endif
      k2 = k2 - l
      if (k2 <= 0) then
          k2 = 0
          j2 = int(.43*sqrt(t*qx%alogmb/(alogt+real(l)*alog2)) + .33)
          j2 = max(1, min(j2, ljsums))
      endif
      if (j2 <= 1) j2 = 1

      n2 = int(t*qx%alogmb/(alogt+real(l)*alog2))
      l2 = int(log(real(n2)+2.0d0**k2)/qx%alogmb)
      call fmndig(qx%ndig + l2, qx)
      ndsav1 = qx%ndig
      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

!             Divide the argument by 2**k2.

      ktwo = 1
      maxv = mxbase/2
      if (k2 > 0) then
          do j = 1, k2
             ktwo = 2*ktwo
             if (ktwo > maxv) then
                 call fmcsdivi_r1(mxy(1), ktwo, qx)
                 ktwo = 1
             endif
          enddo
          if (ktwo > 1) call fmcsdivi_r1(mxy(1), ktwo, qx)
      endif

!             Split into j2 concurrent sums and reduce ndig while computing each term in the sum as
!             the terms get smaller.

      call fmsqr_r1(mxy(1), qx)
      call fmeq(mxy(1), mxy(2), qx)
      nterm = 2
      do j = 1, j2
         nbot = nterm*(nterm-1)
         call fmcsdivi_r1(mxy(2), nbot, qx)
         nterm = nterm + 2
         call fmeq(mxy(2), mjsums(j), qx)
      enddo
      call fmovun_xe(mxy(1), xe, qx)
      if (xe < -qx%ndig) then
          kl = 0
      else
          kl = 1
          call fmipwr(mxy(1), j2, mxy(3), qx)
      endif

      do while (kl > 0)
         call fmcsmpy_r1(mxy(2), mxy(3), qx)
         do j = 1, j2
            large = int(intmax/nterm)
            if (nterm > large .or. nterm > mxbase/(nterm-1)) then
                call fmcsdivi_r1(mxy(2), nterm, qx)
                nbot = nterm - 1
                call fmcsdivi_r1(mxy(2), nbot, qx)
            else
                nbot = nterm*(nterm-1)
                call fmcsdivi_r1(mxy(2), nbot, qx)
            endif
            call fmndig(ndsav1, qx)
            call fmcsaddnn_r1(mjsums(j), mxy(2), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            call fmndig(ndsav1 - int(mjsums(j)%mp(2)-mxy(2)%mp(2)), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
            nterm = nterm + 2
         enddo
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmcsnsums(j2, mjsums, qx)
      call fmeq(mjsums(j2), mxy(3), qx)
      do j = 2, j2
         call fmcsmpy_r1(mxy(3), mxy(1), qx)
         call fmadd_r1(mxy(3), mjsums(j2-j+1), qx)
      enddo

!             Reverse the effect of reducing the argument to compute cosh(ma).

      call fmndig(ndsav1, qx)
      if (k2 > 0) then
          if (ndsave <= 20) then
              call fmi2m(2, mxy(1), qx)
              do j = 1, k2
                 kexp = mxy(3)%mp(2)
                 if (qx%mbase == 2 .or. kexp > 0) then
                     call fmadd(mxy(3), mxy(1), mxy(2), qx)
                 else
                     do k = 1, 3-kexp
                        mxy(2)%mp(k) = mxy(1)%mp(k)
                     enddo
                     do k = 4-kexp, qx%ndig+2
                        mxy(2)%mp(k) = mxy(3)%mp(k-1+kexp)
                     enddo
                 endif
                 call fmcsmpy_r1(mxy(2), mxy(3), qx)
                 call fmcsmpyi(mxy(2), 2, mxy(3), qx)
              enddo
          else
              do j = 1, k2
                 call fmsqr(mxy(3), mxy(2), qx)
                 call fmadd(mxy(3), mxy(3), mxy(1), qx)
                 call fmadd_r1(mxy(2), mxy(1), qx)
                 call fmadd(mxy(2), mxy(2), mxy(3), qx)
              enddo
          endif
      endif
      call fmi2m(1, mxy(2), qx)
      call fmadd_r2(mxy(2), mxy(3), qx)

      call fmequ(mxy(3), mb, ndsav1, ndsave, qx)
      qx%ndig = ndsave
      qx%kwarn = kwrnsv

      return
      end subroutine fmcosh2

      subroutine fmcosh_sinh(ma, mb, mc, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      type(fm_settings) :: qx

      call fmchsh(ma, mb, mc, qx)

      return
      end subroutine fmcosh_sinh

      subroutine fmcsadd_r1(ma, mb, qx)

!  Internal addition routine.  ma = ma + mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb
      type(fm_settings) :: qx

      integer :: j, k, kp2, n1

      if ((qx%ntrace /= 0 .and. qx%lvltrc >= qx%ncall+1) .or. abs(ma%mp(2)) >= qx%mexpab .or.  &
          abs(mb%mp(2)) >= qx%mexpab .or. ma%mp(2) < mb%mp(2) .or.                             &
          ma%mp(1) < 0 .or. mb%mp(1) < 0 .or. ma%mp(3) == 0 .or.                               &
          mb%mp(3) == 0) then
          call fmadd_r1(ma, mb, qx)
          return
      endif
      qx%kflag = 0
      n1 = qx%ndig + 1
      k = ma%mp(2) - mb%mp(2)

!             Add ma and mb.

      kp2 = k + 2
      do j = kp2+1, n1+1
         ma%mp(j) = ma%mp(j) + mb%mp(j-k)
      enddo

!             Normalize.  Fix any digit not less than mbase.

      if (ma%mp(3) >= qx%mbase) then
          ma%mp(2) = ma%mp(2) + 1
          if (ma%mp(n1+1) >= qx%mbase) ma%mp(qx%ndig+1) = ma%mp(qx%ndig+1) + 1
          do j = qx%ndig+1, 4, -1
             if (ma%mp(j) >= qx%mbase) then
                 ma%mp(j+1) = ma%mp(j) - qx%mbase
                 ma%mp(j-1) = ma%mp(j-1) + 1
             else
                 ma%mp(j+1) = ma%mp(j)
             endif
          enddo
          ma%mp(4) = ma%mp(3) - qx%mbase
          ma%mp(3) = 1
      else
          do j = n1+1, 4, -1
             if (ma%mp(j) >= qx%mbase) then
                 ma%mp(j) = ma%mp(j) - qx%mbase
                 ma%mp(j-1) = ma%mp(j-1) + 1
             endif
          enddo
          if (ma%mp(3) >= qx%mbase) then
              do j = n1+1, 5, -1
                 ma%mp(j) = ma%mp(j-1)
              enddo
              ma%mp(4) = ma%mp(3) - qx%mbase
              ma%mp(3) = 1
              ma%mp(2) = ma%mp(2) + 1
          endif
      endif

      if (abs(ma%mp(2)-mb%mp(2)) >= qx%ndig) qx%kflag = 1

      return
      end subroutine fmcsadd_r1

      subroutine fmcsaddnn_r1(ma, mb, qx)

!  Internal addition routine.  ma = ma + mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb
      type(fm_settings) :: qx

      integer :: j, k, kp2, n1

      if ((qx%ntrace /= 0 .and. qx%lvltrc >= qx%ncall+1) .or. abs(ma%mp(2)) >= qx%mexpab .or.  &
          abs(mb%mp(2)) >= qx%mexpab .or. ma%mp(2) < mb%mp(2) .or.                             &
          ma%mp(3) == 0 .or. mb%mp(3) == 0) then
          call fmcsnorm(ma, qx)
          call fmadd_r1(ma, mb, qx)
          return
      endif
      qx%kflag = 0
      n1 = qx%ndig + 1
      k = ma%mp(2) - mb%mp(2)

!             Add ma and mb.

      kp2 = k + 2
      do j = kp2+1, n1+1
         ma%mp(j) = ma%mp(j) + mb%mp(j-k)
      enddo

!             See if the result is equal to one of the input arguments.

      if (abs(ma%mp(2)-mb%mp(2)) >= qx%ndig) qx%kflag = 1

      return
      end subroutine fmcsaddnn_r1

      subroutine fmcsdiv(ma, mb, mc, qx)

!  Internal division routine.  mc = ma / mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      double precision :: xb, xbr, xbase, xmwa
      real (kind(1.0d0)) :: maxmwa, mbp1, mcarry, mkt, mlmax, mqd
      real :: c
      integer :: j, jb, jl, ka, kb, kl, klp, kptmwa, n1, ng, nl, nmbwds, nzdmb

      c = 3100
      if ((qx%ntrace /= 0 .and. qx%lvltrc >= qx%ncall+1) .or. abs(ma%mp(2)) >= qx%mexpab  .or.  &
          abs(mb%mp(2)) >= qx%mexpab .or. ma%mp(3) == 0 .or.                                    &
          mb%mp(3) == 0 .or. qx%mbase < 1000 .or. qx%ndig >= c) then
          call fmdiv(ma, mb, mc, qx)
          return
      endif
      call fmalloc(mc, qx%ndig+2, qx)
      call fmalloc(qx%mwa, 2*qx%ndig+30, qx)
      qx%kflag = 0
      n1 = qx%ndig + 1
      ng = qx%ndig + qx%ngrd21
      nl = ng + 4
      qx%mwa%mp(2) = ma%mp(2) - mb%mp(2) + 1
      qx%mwa%mp(3) = 0
      do j = 2, n1
         qx%mwa%mp(j+2) = ma%mp(j+1)
      enddo
      nl = n1 + qx%ngrd21 + 3
      do j = qx%ndig+3, nl
         qx%mwa%mp(j+1) = 0
      enddo

!             nmbwds is the number of words of mb used to compute the estimated quotient digit mqd.

      nmbwds = 4
      if (qx%mbase < 100) nmbwds = 7

!             xb is an approximation of mb used in estimating the quotient digits.

      xbase = dble(qx%mbase)
      xb = 0
      jl = nmbwds
      if (jl <= n1) then
          do j = 2, jl
             xb = xb*xbase + dble(mb%mp(j+1))
          enddo
      else
          do j = 2, jl
             if (j <= n1) then
                 xb = xb*xbase + dble(mb%mp(j+1))
             else
                 xb = xb*xbase
             endif
          enddo
      endif
      if (jl+1 <= n1) then
          xb = xb + dble(mb%mp(jl+2))/xbase
      endif
      xbr = 1.0d0/xb

!             mlmax determines when to normalize all of mwa.

      mbp1 = qx%mbase + 1
      mlmax = maxint/mbp1
      mkt = intmax - qx%mbase
      mlmax = min(mlmax, mkt)

!             Count the trailing zero digits of mb.

      nzdmb = n1 - 2
      do j = n1, 2, -1
         if (mb%mp(j+1) /= 0) then
             nzdmb = n1 - j
             exit
         endif
      enddo

!             maxmwa is an upper bound on the size of values in mwa divided by mbase-1.  It is used
!             to determine whether normalization can be postponed.

      maxmwa = 0

!             kptmwa points to the next digit in the quotient.

      kptmwa = 2

!             This is the start of the division loop.

!             xmwa is an approximation of the active part of mwa used in estimating quotient digits.

      klp = 1
      do while (klp > 0)
         kl = kptmwa + nmbwds - 1
         if (kl <= nl) then
             xmwa = ((dble(qx%mwa%mp(kptmwa+1))*xbase + dble(qx%mwa%mp(kptmwa+2)))*xbase  &
                    + dble(qx%mwa%mp(kptmwa+3)))*xbase + dble(qx%mwa%mp(kptmwa+4))
             do j = kptmwa+4, kl
                xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
             enddo
         else
             xmwa = dble(qx%mwa%mp(kptmwa+1))
             do j = kptmwa+1, kl
                if (j <= nl) then
                    xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
                else
                    xmwa = xmwa*xbase
                endif
             enddo
         endif

!             mqd is the estimated quotient digit.

         mqd = aint(xmwa*xbr)
         if (mqd < 0) mqd = mqd - 1

         if (mqd > 0) then
             maxmwa = maxmwa + mqd
         else
             maxmwa = maxmwa - mqd
         endif

!             See if mwa must be normalized.

         ka = kptmwa + 1
         kb = min(ka+qx%ndig-1-nzdmb, nl)
         if (maxmwa >= mlmax) then
             do j = kb, ka, -1
                if (qx%mwa%mp(j+1) < 0) then
                    mcarry = int((-qx%mwa%mp(j+1)-1)/qx%mbase) + 1
                    qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
                    qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
                else if (qx%mwa%mp(j+1) >= qx%mbase) then
                    mcarry = -int(qx%mwa%mp(j+1)/qx%mbase)
                    qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
                    qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
                endif
             enddo
             xmwa = 0
             if (kl <= nl) then
                 do j = kptmwa, kl
                    xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
                 enddo
             else
                 do j = kptmwa, kl
                    if (j <= nl) then
                        xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
                    else
                        xmwa = xmwa*xbase
                    endif
                 enddo
             endif
             mqd = aint(xmwa*xbr)
             if (mqd < 0) mqd = mqd - 1
             if (mqd > 0) then
                 maxmwa = mqd
             else
                 maxmwa = -mqd
             endif
         endif

!             Subtract mqd*mb from mwa.

         jb = ka - 2
         if (mqd /= 0) then

!             Major (Inner Loop)

             do j = ka+1, kb+1
                qx%mwa%mp(j) = qx%mwa%mp(j) - mqd*mb%mp(j-jb)
             enddo
         endif

         qx%mwa%mp(ka+1) = qx%mwa%mp(ka+1) + qx%mwa%mp(ka)*qx%mbase
         qx%mwa%mp(kptmwa+1) = mqd

         kptmwa = kptmwa + 1
         if (kptmwa <= ng) cycle
         if (qx%mwa%mp(3) == 0 .and. kptmwa <= ng+1) cycle
         klp = 0
      enddo

      kl = kptmwa + nmbwds - 1
      if (kl <= nl) then
          xmwa = ((dble(qx%mwa%mp(kptmwa+1))*xbase + dble(qx%mwa%mp(kptmwa+2)))*xbase  &
                 + dble(qx%mwa%mp(kptmwa+3)))*xbase + dble(qx%mwa%mp(kptmwa+4))
          do j = kptmwa+4, kl
             xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
          enddo
      else
          xmwa = dble(qx%mwa%mp(kptmwa+1))
          do j = kptmwa+1, kl
             if (j <= nl) then
                 xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
             else
                 xmwa = xmwa*xbase
             endif
          enddo
      endif
      mqd = aint(xmwa*xbr)
      if (mqd < 0) mqd = mqd - 1
      qx%mwa%mp(kptmwa+1) = mqd
      qx%mwa%mp(kptmwa+2) = 0
      qx%mwa%mp(kptmwa+3) = 0

!             Final normalization.

      if (kptmwa > 2*qx%ndig) then
          do j = 2*qx%ndig+1, kptmwa
             if (qx%mwa%mp(j+1) /= qx%mbase-1) exit
             if (j == kptmwa) qx%mwa%mp(j+1) = qx%mbase
          enddo
      endif
      do j = kptmwa, 3, -1
         if (qx%mwa%mp(j+1) < 0) then
             mcarry = int((-qx%mwa%mp(j+1)-1)/qx%mbase) + 1
             qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
             qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
         else if (qx%mwa%mp(j+1) >= qx%mbase) then
             mcarry = -int(qx%mwa%mp(j+1)/qx%mbase)
             qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
             qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
         endif
      enddo
      call fmmove(qx%mwa, mc, qx)
      mc%mp(1) = ma%mp(1) * mb%mp(1)

      return
      end subroutine fmcsdiv

      subroutine fmcsdivi(ma, ival, mb, qx)

!  Internal divide by integer routine.  ma = ma / ival

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (inout) :: mb
      intent (in) :: ma, ival
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mkt, modint, mvalp
      integer :: j, ka, kb, kl, klp, kpt, kptwa, n1, nmval, nv2

      mvalp = abs(ival)
      nmval = int(mvalp)
      nv2 = nmval - 1
      if ((qx%ntrace /= 0 .and. qx%lvltrc >= qx%ncall+1) .or. abs(ma%mp(2)) >= qx%mexpab .or.  &
          ma%mp(3) == 0 .or. ival == 0 .or. abs(ival) > mxbase .or.                            &
          nmval /= abs(ival) .or. nv2 /= abs(ival)-1) then
          call fmdivi(ma, ival, mb, qx)
          return
      endif
      call fmalloc(mb, qx%ndig+2, qx)
      if (abs(ival) == 1) then
          call fmeq(ma, mb, qx)
          mb%mp(1) = ma%mp(1)*ival
          return
      endif

!             Find the first significant digit of the quotient.

      qx%kflag = 0
      n1 = qx%ndig + 1
      mvalp = abs(ival)
      mkt = ma%mp(3)
      klp = 0
      kpt = 2
      if (mkt >= mvalp) then
          kpt = 2
      else
          do j = 3, n1
             mkt = mkt*qx%mbase + ma%mp(j+1)
             if (mkt >= mvalp) then
                 kpt = j
                 klp = 1
                 exit
             endif
          enddo
          if (klp == 0) then
              kpt = n1
              do while (mkt < mvalp)
                 kpt = kpt + 1
                 mkt = mkt*qx%mbase
              enddo
          endif
      endif

!             Do the rest of the division.

      ka = kpt + 1
      mb%mp(1) = ma%mp(1)*ival/abs(ival)
      mb%mp(2) = ma%mp(2) + 2 - kpt
      mb%mp(3) = int (mkt/mvalp)
      modint = mkt - mb%mp(3)*mvalp
      kptwa = 2
      if (ka <= n1) then
          kl = 3 - ka

!             (Inner Loop)

          do j = ka+1, n1+1
             mkt = modint*qx%mbase + ma%mp(j)
             mb%mp(j+kl) = int (mkt/mvalp)
             modint = mkt - mb%mp(j+kl)*mvalp
          enddo
          kptwa = kl + n1
      endif

      ka = kptwa + 1
      kb = n1
      do j = ka, kb
         mkt = modint*qx%mbase
         mb%mp(j+1) = int (mkt/mvalp)
         modint = mkt - mb%mp(j+1)*mvalp
      enddo

      return
      end subroutine fmcsdivi

      subroutine fmcsdivi_r1(ma, ival, qx)

!  Internal divide by integer routine.  ma = ma / ival

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (inout) :: ma
      intent (in) :: ival
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mkt, modint, mvalp
      integer :: j, ka, kb, kl, klp, kpt, kptwa, n1, nmval, nv2

      mvalp = abs(ival)
      nmval = int(mvalp)
      nv2 = nmval - 1
      if ((qx%ntrace /= 0 .and. qx%lvltrc >= qx%ncall+1) .or. abs(ma%mp(2)) >= qx%mexpab .or.  &
          ma%mp(3) == 0 .or. ival == 0 .or. abs(ival) > mxbase .or.                            &
          nmval /= abs(ival) .or. nv2 /= abs(ival)-1) then
          call fmdivi_r1(ma, ival, qx)
          return
      endif
      if (abs(ival) == 1) then
          ma%mp(1) = ma%mp(1)*ival
          return
      endif

!             Find the first significant digit of the quotient.

      qx%kflag = 0
      n1 = qx%ndig + 1
      mvalp = abs(ival)
      mkt = ma%mp(3)
      klp = 0
      kpt = 2
      if (mkt >= mvalp) then
          kpt = 2
      else
          do j = 3, n1
             mkt = mkt*qx%mbase + ma%mp(j+1)
             if (mkt >= mvalp) then
                 kpt = j
                 klp = 1
                 exit
             endif
          enddo
          if (klp == 0) then
              kpt = n1
              do while (mkt < mvalp)
                 kpt = kpt + 1
                 mkt = mkt*qx%mbase
              enddo
          endif
      endif

!             Do the rest of the division.

      ka = kpt + 1
      ma%mp(2) = ma%mp(2) + 2 - kpt
      ma%mp(3) = int (mkt/mvalp)
      modint = mkt - ma%mp(3)*mvalp
      kptwa = 2
      if (ka <= n1) then
          kl = 3 - ka

!             (Inner Loop)

          do j = ka+1, n1+1
             mkt = modint*qx%mbase + ma%mp(j)
             ma%mp(j+kl) = int (mkt/mvalp)
             modint = mkt - ma%mp(j+kl)*mvalp
          enddo
          kptwa = kl + n1
      endif

      ka = kptwa + 1
      kb = n1
      do j = ka, kb
         mkt = modint*qx%mbase
         ma%mp(j+1) = int (mkt/mvalp)
         modint = mkt - ma%mp(j+1)*mvalp
      enddo
      if (ival < 0) call fmnegate(ma, qx)

      return
      end subroutine fmcsdivi_r1

      subroutine fmcsmpy_r1(ma, mb, qx)

!  Internal multiplication ma * mb.  The result is returned in ma.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      real (kind(1.0d0)) :: maxmwa, mbj, mbkj, mbnorm, mbp1, mk, mkt, mmax, mt
      real :: c
      integer :: j, jm1, k, kb, ki, kj, kl, knz, kwa, l, n1, nguard
      intent (inout) :: ma
      intent (in) :: mb
      type(fm_settings) :: qx

      c = 900
      if ((qx%ntrace /= 0 .and. qx%lvltrc >= qx%ncall+1) .or. abs(ma%mp(2)) >= qx%mexpab  .or.  &
          abs(mb%mp(2)) >= qx%mexpab .or. ma%mp(3) == 0 .or.                                    &
          mb%mp(3) == 0 .or. qx%mbase < 1000 .or. qx%ndig >= c) then
          call fmmpy_r1(ma, mb, qx)
          return
      endif
      call fmalloc(qx%mwa, 2*qx%ndig+30, qx)
      qx%kflag = 0
      n1 = qx%ndig + 1
      nguard = qx%ngrd22
      qx%mwa%mp(2) = ma%mp(2) + mb%mp(2)
      l = n1 + nguard
      qx%mwa%mp(l+2) = 0

!             The multiplication loop begins here.

!             mbnorm is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             maxmwa is an upper bound on the size of values in mwa divided by (mbase-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      mbp1 = qx%mbase + 1
      mbnorm = (maxint/(mbp1*mbp1))
      mmax = intmax - qx%mbase
      mmax = min((maxint/mbp1 - mbp1), mmax)
      if (mbnorm >= 2) then
          mbj = mb%mp(3)

!             Count the trailing zeros in ma.

          knz = n1
          if (ma%mp(n1+1) /= 0) then
              knz = n1
          else
              do j = qx%ndig, 2, -1
                 if (ma%mp(j+1) /= 0) then
                     knz = j
                     exit
                 endif
              enddo
          endif

          qx%mwa%mp(3) = 0
          do k = qx%ndig+2, l
             qx%mwa%mp(k+1) = 0
          enddo

!             (Inner Loop)

          do k = 3, n1+1
             qx%mwa%mp(k+1) = ma%mp(k)*mbj
          enddo
          maxmwa = mbj
          do j = 3, n1
             mbj = mb%mp(j+1)
             if (mbj /= 0) then
                 maxmwa = maxmwa + mbj
                 jm1 = j - 1
                 kl = min(knz, l-jm1)
                 do k = j+2, j+kl
                    qx%mwa%mp(k) = qx%mwa%mp(k) + ma%mp(k-jm1)*mbj
                 enddo
             endif

             if (maxmwa > mmax) then
                 maxmwa = 0
                 jm1 = j - 1
                 kl = min(knz, l-jm1)

!                       Here normalization is only required for the range of digits currently
!                       changing in mwa.

                 do kb = jm1+kl, jm1+2, -1
                    mkt = int (qx%mwa%mp(kb+1)/qx%mbase)
                    qx%mwa%mp(kb) = qx%mwa%mp(kb) + mkt
                    qx%mwa%mp(kb+1) = qx%mwa%mp(kb+1) - mkt*qx%mbase
                 enddo
             endif
          enddo

!             Perform the final normalization.  (Inner Loop)

          do kb = l+1, 4, -1
             mkt = int (qx%mwa%mp(kb)/qx%mbase)
             qx%mwa%mp(kb-1) = qx%mwa%mp(kb-1) + mkt
             qx%mwa%mp(kb) = qx%mwa%mp(kb) - mkt*qx%mbase
          enddo

      else

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          do j = 2, l
             qx%mwa%mp(j+1) = 0
          enddo
          kj = qx%ndig + 2
          do j = 2, n1
             kj = kj - 1
             mbkj = mb%mp(kj+1)
             if (mbkj == 0) cycle
             kl = l - kj + 1
             if (kl > n1) kl = n1
             ki = kl + 2
             kwa = kl+ kj + 1
             mk = 0
             do k = 2, kl
                mt = ma%mp(ki-k+1)*mbkj + qx%mwa%mp(kwa-k+1) + mk
                mk = int (mt/qx%mbase)
                qx%mwa%mp(kwa-k+1) = mt - qx%mbase*mk
             enddo
             qx%mwa%mp(kwa-kl) = mk
          enddo
      endif

      if (ma%mp(1)*mb%mp(1) < 0) then
          ma%mp(1) = -1
      else
          ma%mp(1) = 1
      endif
      ma%mp(2) = qx%mwa%mp(2)
      if (qx%mwa%mp(3) == 0) then
          ma%mp(2) = ma%mp(2) - 1
          do j = 3, n1+1
             ma%mp(j) = qx%mwa%mp(j+1)
          enddo
      else
          do j = 3, n1+1
             ma%mp(j) = qx%mwa%mp(j)
          enddo
      endif

      return
      end subroutine fmcsmpy_r1

      subroutine fmcsmpyi(ma, ival, mb, qx)

!  Internal multiply by integer routine.  mb = ma * ival

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mcarry, mkt, mval
      integer :: j, kshift, nmval, nv2

      if ((qx%ntrace /= 0 .and. qx%lvltrc >= qx%ncall+1) .or. abs(ma%mp(2)) >= qx%mexpab .or.  &
          ma%mp(3) == 0 .or. abs(ival) <= 1 .or. abs(ival) > mxbase) then
          call fmmpyi(ma, ival, mb, qx)
          return
      endif
      call fmalloc(mb, qx%ndig+2, qx)

!             Work with positive numbers.

      qx%kflag = 0
      mval = abs(ival)
      nmval = int(mval)
      nv2 = nmval - 1

!             To leave room for the normalization, shift the product to the right kshift
!             places in mb.

      kshift = 0
      mkt = ma%mp(3) * mval
      do j = 1, 100
         if (mkt < qx%mbase) exit
         kshift = kshift + 1
         mkt = int(mkt/qx%mbase)
      enddo

      if (kshift > qx%ndig .or. nmval /= abs(ival) .or. nv2 /= abs(ival)-1) then
          call fmmpyi(ma, ival, mb, qx)
          return
      endif
      mb%mp(2) = ma%mp(2) + kshift

      mcarry = 0
      do j = qx%ndig, qx%ndig-kshift+1, -1
         mkt = ma%mp(j+2)*mval + mcarry
         mcarry = int(mkt/qx%mbase)
      enddo
      do j = qx%ndig-kshift, 1, -1
         mkt = ma%mp(j+2)*mval + mcarry
         mcarry = int(mkt/qx%mbase)
         mb%mp(j+2+kshift) = mkt - mcarry*qx%mbase
      enddo
      do j = kshift, 1, -1
         mkt = mcarry
         mcarry = int(mkt/qx%mbase)
         mb%mp(j+2) = mkt - mcarry*qx%mbase
      enddo
      if (mcarry > 0) then
          mb%mp(2) = mb%mp(2) + 1
          do j = qx%ndig, 2, -1
             mb%mp(j+2) = mb%mp(j+1)
          enddo
          mb%mp(3) = mcarry
      endif

      if ((ma%mp(1) > 0 .and. ival > 0) .or. (ma%mp(1) < 0 .and. ival < 0)) then
          qx%jrsign = 1
      else
          qx%jrsign = -1
      endif
      mb%mp(1) = qx%jrsign

      return
      end subroutine fmcsmpyi

      subroutine fmcsmpyi_r1(ma, ival, qx)

!  Internal multiply by integer routine.  ma = ma * ival

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ival
      intent (inout) :: ma
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mcarry, mkt, mval
      integer :: j, kshift, nmval, nv2

      if ((qx%ntrace /= 0 .and. qx%lvltrc >= qx%ncall+1) .or. abs(ma%mp(2)) >= qx%mexpab .or.  &
          ma%mp(3) == 0 .or. abs(ival) <= 1 .or. abs(ival) > mxbase) then
          call fmmpyi_r1(ma, ival, qx)
          return
      endif

!             Work with positive numbers.

      qx%kflag = 0
      mval = abs(ival)
      nmval = int(mval)
      nv2 = nmval - 1

!             To leave room for the normalization, shift the product to the right kshift
!             places.

      kshift = 0
      mkt = ma%mp(3) * mval
      do j = 1, 100
         if (mkt < qx%mbase) exit
         kshift = kshift + 1
         mkt = int(mkt/qx%mbase)
      enddo

      if (kshift > qx%ndig .or. nmval /= abs(ival) .or. nv2 /= abs(ival)-1) then
          call fmmpyi_r1(ma, ival, qx)
          return
      endif
      ma%mp(2) = ma%mp(2) + kshift

      mcarry = 0
      do j = qx%ndig, qx%ndig-kshift+1, -1
         mkt = ma%mp(j+2)*mval + mcarry
         mcarry = int(mkt/qx%mbase)
      enddo
      do j = qx%ndig-kshift, 1, -1
         mkt = ma%mp(j+2)*mval + mcarry
         mcarry = int(mkt/qx%mbase)
         ma%mp(j+2+kshift) = mkt - mcarry*qx%mbase
      enddo
      do j = kshift, 1, -1
         mkt = mcarry
         mcarry = int(mkt/qx%mbase)
         ma%mp(j+2) = mkt - mcarry*qx%mbase
      enddo
      if (mcarry > 0) then
          ma%mp(2) = ma%mp(2) + 1
          do j = qx%ndig, 2, -1
             ma%mp(j+2) = ma%mp(j+1)
          enddo
          ma%mp(3) = mcarry
      endif

      if ((ma%mp(1) > 0 .and. ival > 0) .or. (ma%mp(1) < 0 .and. ival < 0)) then
          qx%jrsign = 1
      else
          qx%jrsign = -1
      endif
      ma%mp(1) = qx%jrsign

      return
      end subroutine fmcsmpyi_r1

      subroutine fmcsmpyin_r1(ma, jb, je, qx)

!  Internal routine for  ma = ma * jb**je

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: jb, je
      intent (in) :: jb, je
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: j, kj
      real (kind(1.0d0)) :: maxv

      kj = 1
      maxv = mxbase/jb
      if (je > 0) then
          do j = 1, je
             kj = jb*kj
             if (kj > maxv) then
                 call fmcsmpyi_r1(ma, kj, qx)
                 kj = 1
             endif
          enddo
          if (kj > 1) call fmcsmpyi_r1(ma, kj, qx)
      endif

      end subroutine fmcsmpyin_r1

      subroutine fmcsnorm(ma, qx)

!  Internal routine to normalize the digits of ma.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: k, kshift
      real (kind(1.0d0)) :: mkt

      if (abs(ma%mp(2)) >= qx%mexpov) return

      do k = qx%ndig+2, 4, -1
         mkt = int (ma%mp(k)/qx%mbase)
         ma%mp(k-1) = ma%mp(k-1) + mkt
         ma%mp(k) = ma%mp(k) - mkt*qx%mbase
      enddo
      if (ma%mp(3) >= qx%mbase) then
          mkt = ma%mp(3)
          kshift = 1
          do
             mkt = int (mkt/qx%mbase)
             if (mkt < qx%mbase) exit
             kshift = kshift + 1
          enddo
          do k = qx%ndig+2, 3+kshift, -1
             ma%mp(k) = ma%mp(k-kshift)
          enddo
          do k = 3+kshift, 4, -1
             mkt = int (ma%mp(k)/qx%mbase)
             ma%mp(k-1) = mkt
             ma%mp(k) = ma%mp(k) - mkt*qx%mbase
          enddo
          ma%mp(2) = ma%mp(2) + kshift
      endif

      end subroutine fmcsnorm

      subroutine fmcsnsums(j2, mjsums, qx)

!  Internal routine to normalize mjsums.

      use fmvals_parallel
      implicit none

      integer :: j2
      type(multi) :: mjsums(j2)
      intent (in) :: j2
      intent (inout) :: mjsums
      type(fm_settings) :: qx

      integer :: j

      do j = 1, j2
         call fmcsnorm(mjsums(j), qx)
      enddo

      return
      end subroutine fmcsnsums

      subroutine fmcssn(ma, mb, mc, qx)

!  mb = cos(ma),    mc = sin(ma)

!  If both the sine and cosine are needed, this routine is faster than calling both fmcos and fmsin.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      type(multi) :: mxy(4), mresult1, mresult2
      logical :: retry

      call fmalloc(mb, qx%ndig+2, qx)
      call fmalloc(mc, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmcssn_sc(ma, mxy, ndsave, mresult1, mresult2, kresult, qx)
      if (kresult > 0) then
          call fmexit2(mresult1, mresult2, mb, mc, kovun, mxsave, ndsave, qx)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmcssn_m1(ma, mxy, mresult1, mresult2, ndsave, qx)
         call fmcheck_accuracy(mresult1, ndsave, retry, qx)
         if (retry) cycle
         call fmcheck_accuracy(mresult2, ndsave, retry, qx)
      enddo

      call fmexit2(mresult1, mresult2, mb, mc, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmcssn

      subroutine fmcssn_m1(ma, mxy, mresult1, mresult2, ndsave, qx)

!  Method 1 for computing fmcssn(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(4), mresult1, mresult2
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult1, mresult2
      type(fm_settings) :: qx

      integer :: jcos, jsin, jswap, krndsave, ndsv
      qx%ndigpi = 0
      qx%mbspi = 0

      krndsave = qx%kround
      qx%kround = 1
      call fmequ(ma, mresult1, ndsave, qx%ndig, qx)
      mresult1%mp(1) = 1
      call fmeq(mresult1, mxy(4), qx)

!             Reduce the argument, convert to radians if the input is in degrees, and evaluate
!             the functions.

      call fmrdc(mresult1, jsin, jcos, jswap, qx)
      if (qx%kround /= 1 .and. qx%krad /= 1) then
          call fmi2m(30, mxy(1), qx)
          call fmsub(mresult1, mxy(1), mxy(2), qx)
          if (mxy(2)%mp(3) == 0) then
              call fmcos(mxy(4), mresult1, qx)
              call fmsin(mxy(4), mresult2, qx)
              if (ma%mp(1) < 0) call fmnegate(mresult2, qx)
              return
          endif
      endif
      if (mresult1%mp(2) == qx%munkno) then
          call fmcos(mxy(4), mresult1, qx)
          call fmsin(mxy(4), mresult2, qx)
          if (ma%mp(1) < 0) call fmnegate(mresult2, qx)
          return
      endif
      if (qx%krad == 0) then
          if (qx%mbspi /= qx%mbase .or. qx%ndigpi < qx%ndig) then
              ndsv = qx%ndig
              call fmndig(qx%ndig + 2, qx)
              call fmpi(mxy(2), qx)
              qx%ndigpi = 0
              call fmndig(ndsv, qx)
          endif
          call fmpi(mxy(1), qx)
          qx%ndigpi = 0
          call fmmpy_r1(mresult1, mxy(1), qx)
          call fmdivi_r1(mresult1, 180, qx)
      endif
      if (mresult1%mp(2) /= qx%munkno) then
          if (jswap == 0) then
              if (mresult1%mp(2) < 0) then
                  call fmsin2(mresult1, mresult2, qx)
                  mresult2%mp(1) = jsin*mresult2%mp(1)
                  call fmsqr(mresult2, mxy(2), qx)
                  call fmi2m(1, mxy(1), qx)
                  call fmsub_r2(mxy(1), mxy(2), qx)
                  call fmsqrt(mxy(2), mresult1, qx)
                  mresult1%mp(1) = jcos*mresult1%mp(1)
              else
                  call fmcos2(mresult1, mxy(3), qx)
                  call fmeq(mxy(3), mresult1, qx)
                  mresult1%mp(1) = jcos*mresult1%mp(1)
                  call fmsqr(mresult1, mxy(2), qx)
                  call fmi2m(1, mxy(1), qx)
                  call fmsub_r2(mxy(1), mxy(2), qx)
                  call fmsqrt(mxy(2), mresult2, qx)
                  mresult2%mp(1) = jsin*mresult2%mp(1)
              endif
          else
              if (mresult1%mp(2) < 0) then
                  call fmsin2(mresult1, mxy(3), qx)
                  call fmeq(mxy(3), mresult1, qx)
                  mresult1%mp(1) = jcos*mresult1%mp(1)
                  call fmsqr(mresult1, mxy(2), qx)
                  call fmi2m(1, mxy(1), qx)
                  call fmsub_r2(mxy(1), mxy(2), qx)
                  call fmsqrt(mxy(2), mresult2, qx)
                  mresult2%mp(1) = jsin*mresult2%mp(1)
              else
                  call fmcos2(mresult1, mresult2, qx)
                  mresult2%mp(1) = jsin*mresult2%mp(1)
                  call fmsqr(mresult2, mxy(2), qx)
                  call fmi2m(1, mxy(1), qx)
                  call fmsub_r2(mxy(1), mxy(2), qx)
                  call fmsqrt(mxy(2), mresult1, qx)
                  mresult1%mp(1) = jcos*mresult1%mp(1)
              endif
          endif
      else
          call fmeq(mresult1, mresult2, qx)
      endif
      qx%kround = krndsave
      if (ma%mp(1) < 0) call fmnegate(mresult2, qx)

      return
      end subroutine fmcssn_m1

      subroutine fmcssn_sc(ma, mxy, ndsave, mresult1, mresult2, kresult, qx)

!  Check for special cases for fmcssn.

!  kresult = 1 is returned if a special case gives the values of the two results.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(4), mresult1, mresult2
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult1, mresult2, kresult
      type(fm_settings) :: qx

      integer :: j

      kresult = 0

      qx%namest(qx%ncall) = 'FMCSSN   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

      if (mxy(1)%mp(2) == qx%munkno .and. mxy(1)%mp(5) >= 0) then
          call fmunknown(mresult1, qx)
          call fmunknown(mresult2, qx)
          kresult = 1
          return
      endif

      if (abs(mxy(1)%mp(2)) >= qx%mexpov) then
          call fmcos(mxy(1), mresult1, qx)
          call fmsin(mxy(1), mresult2, qx)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (qx%kround /= 1 .and. mxy(1)%mp(2) < -ndsave) then
          call fmcos(mxy(1), mresult1, qx)
          call fmsin(mxy(1), mresult2, qx)
          kresult = 1
          return
      endif
      if (abs(mxy(1)%mp(2)) > qx%mexpab .or. mxy(1)%mp(3) == 0) then
          call fmcos(mxy(1), mresult1, qx)
          call fmsin(mxy(1), mresult2, qx)
          kresult = 1
          return
      endif
      if (ma%mp(2) > 3*10**5 .and. qx%krad == 1) then
          call fmunknown(mresult1, qx)
          call fmunknown(mresult2, qx)
          kresult = 1
          return
      endif

      return
      end subroutine fmcssn_sc

      subroutine fmdbl(a, b, c)

!  c = a + b.  All are double precision.  This routine tries to force the compiler to round c to
!  double precision accuracy. Some compilers allow double precision loops like the one in fmdpm2 to
!  be done in extended precision, which defeats the routine's attempt to determine double precision
!  accuracy.  This can lead to doing too few Newton steps and failing to get sufficient accuracy in
!  several FM routines.

      use fmvals_parallel
      implicit none
      double precision :: a, b, c
      intent (in) :: a, b
      intent (inout) :: c
      c = a + b

      return
      end subroutine fmdbl

      subroutine fmdefine_error

      use fmvals_parallel
      implicit none

      write (*,*) ' '
      write (*,*) ' Error in FM.  Out of memory for multiple precision numbers'
      write (*,*) '               or character strings to format FM output.'
      write (*,*) '               Allocation of more memory failed.'
      write (*,*) ' '

      stop
      end subroutine fmdefine_error

      subroutine fmdig(nstack, kst, qx)

!  Compute the number of intermediate digits to be used in Newton iteration.  This assumes that a
!  starting approximation that is accurate to double precision is used, and the root is simple.

!  kst is the number of iterations needed for final accuracy ndig.
!  nstack(j) holds the value of ndig to be used for the jth iteration.

      use fmvals_parallel
      implicit none

      integer :: nstack(49), kst
      intent (inout) :: nstack, kst
      type(fm_settings) :: qx

      double precision :: y
      integer :: j, jt, kl, l, nd, ndt, ne

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

!             ne is the maximum number of base mbase digits that can be used in the first
!                Newton iteration.

      ne = int(1.9d0*qx%dlogeb)

!             Fill the intermediate digit stack (backwards).

      kst = 1
      nd = qx%ndig
      nstack(1) = nd
      if (nd < ne .or. nd <= 2) return

      kl = 1
      do while (kl == 1)
         y = nd

!             The 1.9 accounts for the fact that the number of correct digits approximately doubles
!             at each iteration.

         ndt = int(y/1.9d0)
         if (2*ndt <= nd) ndt = ndt + 1
         nd = ndt
         kst = kst + 1
         nstack(kst) = nd
         if (nd > ne .and. nd > 2) cycle
         kl = 0
      enddo

!             Reverse the stack.

      l = kst/2
      do j = 1, l
         jt = nstack(j)
         nstack(j) = nstack(kst+1-j)
         nstack(kst+1-j) = jt
      enddo

      return
      end subroutine fmdig

      subroutine fmdim(ma, mb, mc, qx)

!  mc = dim(ma, mb)

!  Positive difference.  mc = ma - mb  if ma >= mb,
!                           = 0        otherwise.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      logical, external :: fmcomp
      type(multi) :: mxy(3)

      call fmalloc(mc, qx%ndig+2, qx)
      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      call fmenter2(ma, mb, kovun, mxsave, ndsave, qx)
      qx%ndig = ndsave
      qx%namest(qx%ncall) = 'FMDIM    '
      call fmntr_inp2(ma, mb, qx)

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      call fmequ(mb, mxy(2), ndsave, qx%ndig, qx)

      if (fmcomp(mxy(1), '<', mxy(2), qx)) then
          call fmi2m(0, mxy(3), qx)
      else
          call fmsub(mxy(1), mxy(2), mxy(3), qx)
      endif

      if (qx%kflag == 1) qx%kflag = 0
      call fmexit1(mxy(3), mc, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmdim

      subroutine fmdiv(ma, mb, mc, qx)

!  mc = ma / mb

!  This routine performs the trace printing for division.  fmdiv2 is used to do the arithmetic.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: kovun

      qx%ncall = qx%ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == qx%mexpov .or. abs(mb%mp(2)) == qx%mexpov) kovun = 1
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) kovun = 2
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMDIV'
          call fmntr_inp2(ma, mb, qx)
      endif

      call fmdiv2(ma, mb, mc, qx)

      if ((abs(mc%mp(2)) == qx%mexpov .and. kovun == 0) .or.  &
          (abs(mc%mp(2)) == qx%munkno .and. kovun < 2)) then
          qx%namest(qx%ncall) = 'FMDIV'
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) then
          call fmntr_out1(mc, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmdiv

      subroutine fmdiv2(ma, mb, mc, qx)

!  Internal division routine.  mc = ma / mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      logical :: retry
      integer :: kresult, kr_retry

      call fmalloc(mc, qx%ndig+2, qx)
      call fmalloc(qx%mwa, 2*qx%ndig+30, qx)
      call fmdiv_sc(ma, mb, mc, kresult, qx)
      if (kresult > 0) then
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      kr_retry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fmdiv_m1(ma, mb, mc, kr_retry, retry, qx)
      enddo

      return
      end subroutine fmdiv2

      subroutine fmdiv2_r1(ma, mb, qx)

!  Internal division routine.  ma = ma / mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb
      type(fm_settings) :: qx

      type(multi) :: mxy

      call fmdiv2(ma, mb, mxy, qx)
      call fmeq(mxy, ma, qx)

      return
      end subroutine fmdiv2_r1

      subroutine fmdiv2_r2(ma, mb, qx)

!  Internal division routine.  mb = ma / mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(multi) :: mxy
      type(fm_settings) :: qx

      call fmdiv2(ma, mb, mxy, qx)
      call fmeq(mxy, mb, qx)

      return
      end subroutine fmdiv2_r2

      subroutine fmdiv3(mb, ng, qx)

!  Internal division routine.  Divide ma/mb and return the quotient in mwa.
!  ma has already been copied into mwa.
!  ng is the number of guard digits used.

      use fmvals_parallel
      implicit none

      type(multi) :: mb
      integer :: ng
      intent (in) :: mb, ng
      type(fm_settings) :: qx

      double precision :: xb, xbr, xbase, xmwa
      real (kind(1.0d0)) :: maxmwa, mbp1, mcarry, mkt, mlmax, mqd
      integer :: j, jb, jl, ka, kb, kl, kptmwa, n1, nl, nmbwds, nmethd, nzdmb
      real :: c
      logical :: div_loop


      n1 = qx%ndig + 1
      nl = ng + 4

!             Check for using an fft-based method if precision is very high.

      c = 3100
      if (qx%ndig >= c) then
          nzdmb = 0
          do j = 2, qx%ndig
             if (mb%mp(j+2) == 0) nzdmb = nzdmb + 1
          enddo
          if (qx%ndig-nzdmb < 50 .or. real(nzdmb)/qx%ndig > 0.8 ) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          nmethd = 1
      endif
      if (nmethd == 2) then
          call fmdivfft(mb, qx)
          return
      endif

!             nmbwds is the number of words of mb used to compute the estimated quotient digit mqd.

      nmbwds = 4
      if (qx%mbase < 100) nmbwds = 7

!             xb is an approximation of mb used in estimating the quotient digits.

      xbase = dble(qx%mbase)
      xb = 0
      jl = nmbwds
      if (jl <= n1) then
          do j = 2, jl
             xb = xb*xbase + dble(mb%mp(j+1))
          enddo
      else
          do j = 2, jl
             if (j <= n1) then
                 xb = xb*xbase + dble(mb%mp(j+1))
             else
                 xb = xb*xbase
             endif
          enddo
      endif
      if (jl+1 <= n1) then
          xb = xb + dble(mb%mp(jl+2))/xbase
      endif
      xbr = 1.0d0/xb

!             mlmax determines when to normalize all of mwa.

      mbp1 = qx%mbase + 1
      mlmax = maxint/mbp1
      mkt = intmax - qx%mbase
      mlmax = min(mlmax, mkt)

!             Count the trailing zero digits of mb.

      nzdmb = n1 - 2
      do j = n1, 2, -1
         if (mb%mp(j+1) /= 0) then
             nzdmb = n1 - j
             exit
         endif
      enddo

!             maxmwa is an upper bound on the size of values in mwa divided by mbase-1.  It is used
!             to determine whether normalization can be postponed.

      maxmwa = 0

!             kptmwa points to the next digit in the quotient.

      kptmwa = 2

!             This is the start of the division loop.

!             xmwa is an approximation of the active part of mwa used in estimating quotient digits.

      div_loop = .true.
      do while (div_loop)
         kl = kptmwa + nmbwds - 1
         if (kl <= nl) then
             xmwa = ((dble(qx%mwa%mp(kptmwa+1))*xbase + dble(qx%mwa%mp(kptmwa+2)))*xbase  &
                    + dble(qx%mwa%mp(kptmwa+3)))*xbase + dble(qx%mwa%mp(kptmwa+4))
             do j = kptmwa+4, kl
                xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
             enddo
         else
             xmwa = dble(qx%mwa%mp(kptmwa+1))
             do j = kptmwa+1, kl
                if (j <= nl) then
                    xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
                else
                    xmwa = xmwa*xbase
                endif
             enddo
         endif

!             mqd is the estimated quotient digit.

         mqd = aint(xmwa*xbr)
         if (mqd < 0) mqd = mqd - 1

         if (mqd > 0) then
             maxmwa = maxmwa + mqd
         else
             maxmwa = maxmwa - mqd
         endif

!             See if mwa must be normalized.

         ka = kptmwa + 1
         kb = min(ka+qx%ndig-1-nzdmb, nl)
         if (maxmwa >= mlmax) then
             do j = kb, ka, -1
                if (qx%mwa%mp(j+1) < 0) then
                    mcarry = int((-qx%mwa%mp(j+1)-1)/qx%mbase) + 1
                    qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
                    qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
                else if (qx%mwa%mp(j+1) >= qx%mbase) then
                    mcarry = -int(qx%mwa%mp(j+1)/qx%mbase)
                    qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
                    qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
                endif
             enddo
             xmwa = 0
             if (kl <= nl) then
                 do j = kptmwa, kl
                    xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
                 enddo
             else
                 do j = kptmwa, kl
                    if (j <= nl) then
                        xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
                    else
                        xmwa = xmwa*xbase
                    endif
                 enddo
             endif
             mqd = aint(xmwa*xbr)
             if (mqd < 0) mqd = mqd - 1
             if (mqd > 0) then
                 maxmwa = mqd
             else
                 maxmwa = -mqd
             endif
         endif

!             Subtract mqd*mb from mwa.

         jb = ka - 2
         if (mqd /= 0) then

!             Major (Inner Loop)

             do j = ka+1, kb+1
                qx%mwa%mp(j) = qx%mwa%mp(j) - mqd*mb%mp(j-jb)
             enddo
         endif

         qx%mwa%mp(ka+1) = qx%mwa%mp(ka+1) + qx%mwa%mp(ka)*qx%mbase
         qx%mwa%mp(kptmwa+1) = mqd

         kptmwa = kptmwa + 1
         if (kptmwa <= ng) then
             div_loop = .true.
         else if (qx%mwa%mp(3) == 0 .and. kptmwa <= ng+1) then
             div_loop = .true.
         else
             div_loop = .false.
         endif
      enddo

      kl = kptmwa + nmbwds - 1
      if (kl <= nl) then
          xmwa = ((dble(qx%mwa%mp(kptmwa+1))*xbase + dble(qx%mwa%mp(kptmwa+2)))*xbase  &
                 + dble(qx%mwa%mp(kptmwa+3)))*xbase + dble(qx%mwa%mp(kptmwa+4))
          do j = kptmwa+4, kl
             xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
          enddo
      else
          xmwa = dble(qx%mwa%mp(kptmwa+1))
          do j = kptmwa+1, kl
             if (j <= nl) then
                 xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
             else
                 xmwa = xmwa*xbase
             endif
          enddo
      endif
      mqd = aint(xmwa*xbr)
      if (mqd < 0) mqd = mqd - 1
      qx%mwa%mp(kptmwa+1) = mqd
      qx%mwa%mp(kptmwa+2) = 0
      qx%mwa%mp(kptmwa+3) = 0

!             Final normalization.

      if (kptmwa > 2*qx%ndig) then
          do j = 2*qx%ndig+1, kptmwa
             if (qx%mwa%mp(j+1) /= qx%mbase-1) exit
             if (j == kptmwa) qx%mwa%mp(j+1) = qx%mbase
          enddo
      endif
      do j = kptmwa, 3, -1
         if (qx%mwa%mp(j+1) < 0) then
             mcarry = int((-qx%mwa%mp(j+1)-1)/qx%mbase) + 1
             qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
             qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
         else if (qx%mwa%mp(j+1) >= qx%mbase) then
             mcarry = -int(qx%mwa%mp(j+1)/qx%mbase)
             qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
             qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
         endif
      enddo

      return
      end subroutine fmdiv3

      subroutine fmdiv_m1(ma, mb, mc, kr_retry, retry, qx)

!  Method 1 for computing mc = ma / mb.

      use fmvals_parallel
      implicit none

      type(multi) :: mpma, mpmb
      type(multi) :: ma, mb, mc
      integer :: kr_retry
      logical :: retry
      intent (in) :: ma, mb
      intent (inout) :: mc, kr_retry, retry
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mlr, mr, ms, mt1, mt2
      double precision :: err
      integer :: j, jrssav, k, kl, kt, kt1, kt2, kt3, l, n1, ng, nguard, nl

      qx%kflag = 0
      jrssav = qx%jrsign

!             nguard is the number of guard digits used.

      if (qx%ncall > 1) then
          nguard = qx%ngrd21
          if (nguard > qx%ndig) nguard = qx%ndig
      else
          nguard = qx%ngrd52 - 1
          if (kr_retry >= 1) then
              nguard = qx%ndig + 10
          endif
      endif
      if (nguard > qx%ndig+10) nguard = qx%ndig + 10
      n1 = qx%ndig + 1
      ng = qx%ndig + nguard
      if ((ma%mp(1) > 0 .and. mb%mp(1) > 0) .or. (ma%mp(1) < 0 .and. mb%mp(1) < 0)) then
          qx%jrsign = 1
      else
          qx%jrsign = -1
      endif
      qx%mwa%mp(2) = ma%mp(2) - mb%mp(2) + 1

      if (qx%mbase*qx%mbase <= mxbase/(4*qx%mbase)) then

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2**24) while
!             doing the operation.

          if (qx%ndigl /= qx%ndig .or. qx%mbasel /= qx%mbase .or. qx%nguarl /= nguard) then
              qx%mbasel = qx%mbase
              qx%ndigl = qx%ndig
              qx%nguarl = nguard
              do j = 2, 1000
                 mr = qx%mbase*qx%mbasel
                 if (4*mr > mxbase) then
                     qx%n21 = j - 1
                     call fmndig((qx%ndigl-1)/qx%n21 + 1, qx)
                     if (qx%ndig < 3) qx%ndig = 3
                     qx%ngrdn = (qx%ndigl+nguard-1)/qx%n21 + 2 - qx%ndig
                     if (qx%ngrdn < 1) qx%ngrdn = 1
                     exit
                 endif
                 qx%mbase = mr
              enddo
              qx%mbasen = qx%mbase
              qx%ndign = qx%ndig
          else
              qx%mbase = qx%mbasen
              call fmndig(qx%ndign, qx)
          endif
          if (qx%mblogs /= qx%mbase) call fmcons(qx)
          j = qx%ndig
          call fmndig(qx%ndig + qx%ngrdn + 5, qx)
          call fmalloc(mpma, qx%ndig+2, qx)
          call fmalloc(mpmb, qx%ndig+2, qx)
          call fmndig(j, qx)
          mpma%mp(1) = ma%mp(1)
          mpmb%mp(1) = mb%mp(1)
          mpma%mp(2) = 0
          mpmb%mp(2) = 0
          l = 2 - qx%n21
          do j = 2, qx%ndigl+2-qx%n21, qx%n21
             mt1 = ma%mp(j+1)
             mt2 = mb%mp(j+1)
             do k = j+1, j+qx%n21-1
                mt1 = mt1*qx%mbasel + ma%mp(k+1)
                mt2 = mt2*qx%mbasel + mb%mp(k+1)
             enddo
             mpma%mp(3+j/qx%n21) = mt1
             mpmb%mp(3+j/qx%n21) = mt2
             l = j
          enddo
          do j = 3+l/qx%n21, qx%ndig+qx%ngrdn+2
             mpma%mp(j+1) = 0
             mpmb%mp(j+1) = 0
          enddo
          if (l+qx%n21 <= qx%ndigl+1) then
              mt1 = 0
              mt2 = 0
              do j = l+qx%n21, l+2*qx%n21-1
                 if (j <= qx%ndigl+1) then
                     mt1 = mt1*qx%mbasel + ma%mp(j+1)
                     mt2 = mt2*qx%mbasel + mb%mp(j+1)
                 else
                     mt1 = mt1*qx%mbasel
                     mt2 = mt2*qx%mbasel
                 endif
              enddo
              mpma%mp(3+(l+qx%n21)/qx%n21) = mt1
              mpmb%mp(3+(l+qx%n21)/qx%n21) = mt2
          endif
          ng = qx%ndig + qx%ngrdn + 1
          if (mpma%mp(3) >= mpmb%mp(3)) ng = ng + 1

!             Copy ma into the working array.

          do j = 2, qx%ndig+1
             qx%mwa%mp(j+2) = mpma%mp(j+1)
          enddo
          qx%mwa%mp(3) = 0
          do j = qx%ndig+3, ng+4
             qx%mwa%mp(j+1) = 0
          enddo
          call fmdiv3(mpmb, ng, qx)
          if (qx%mwa%mp(3) >= qx%mbasel) then
              do j = 2+qx%ndig+qx%ngrdn, 3, -1
                 qx%mwa%mp(j+1) = qx%mwa%mp(j)
              enddo
              qx%mwa%mp(3) = 0
              qx%mwa%mp(2) = qx%mwa%mp(2) + 1
          endif
          kt3 = qx%n21 - 1
          if (qx%mbasel == 2 .and. qx%mbase < intmax) then
              do j = 2+qx%ndig+qx%ngrdn, 3, -1
                 kt1 = qx%mwa%mp(j+1)
                 kt = 2 + (j-2)*qx%n21
                 kt2 = qx%n21 + kt - 1
                 do k = kt, min(1+(j-1)*qx%n21, qx%ndigl+nguard+2+kt3)
                    qx%mwa%mp(k-kt3+1) = ibits(kt1, kt2-k, 1)
                 enddo
              enddo
          else
              ms = qx%mbasel**(qx%n21-1)
              do j = 2+qx%ndig+qx%ngrdn, 3, -1
                 mr = ms
                 mt1 = qx%mwa%mp(j+1)
                 do k = 2+(j-2)*qx%n21, min(1+(j-1)*qx%n21, qx%ndigl+nguard+2+kt3)
                    qx%mwa%mp(k-kt3+1) = aint (mt1/mr)
                    mt1 = mt1 - qx%mwa%mp(k-kt3+1)*mr
                    mr = aint (mr/qx%mbasel)
                 enddo
              enddo
          endif
          call fmndig(qx%ndigl, qx)
          qx%mbase = qx%mbasel
          if (qx%mblogs /= qx%mbase) call fmcons(qx)
      else

!             This is the normal case, where the base is not small.

!             Copy ma into the working array.

          do j = 2, n1
             qx%mwa%mp(j+2) = ma%mp(j+1)
          enddo
          qx%mwa%mp(3) = 0
          nl = n1 + nguard + 3
          do j = qx%ndig+3, nl
             qx%mwa%mp(j+1) = 0
          enddo
          call fmdiv3(mb, ng, qx)
      endif

!             Round, affix the sign, and return.

      if (qx%mwa%mp(3) == 0) then

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

          if (qx%ncall >= 1 .and. nguard < qx%ndig+10) then
              kl = min(nguard, int(3*qx%dlogtn/qx%dlogmb + 1.5))
              err = 0
              do j = kl, 1, -1
                 err = (err + qx%mwa%mp(j+qx%ndig+3)) / qx%mbase
              enddo
              if ( (qx%kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
                   (qx%kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) kr_retry = kr_retry + 1
          endif
          if (kr_retry == 1 .and. nguard < qx%ndig+10) then
              kr_retry = 2
              retry = .true.
              return
          endif
          mlr = 2*qx%mwa%mp(qx%ndig+4) + 1
          if (qx%kround == -1 .or. qx%kround == 2) then
              call fmrnd(qx%mwa, qx%ndig, nguard, 1, qx)
          else if (mlr >= qx%mbase) then
              if (mlr-1 > qx%mbase .and. qx%mwa%mp(n1+2) < qx%mbase-1) then
                  if (qx%kround /= 0) then
                      qx%mwa%mp(n1+2) = qx%mwa%mp(n1+2) + 1
                      qx%mwa%mp(n1+3) = 0
                  endif
              else
                  call fmrnd(qx%mwa, qx%ndig, nguard, 1, qx)
              endif
          endif
      else
          if (qx%ncall >= 1 .and. nguard < qx%ndig+10) then
              kl = min(nguard, int(3*qx%dlogtn/qx%dlogmb + 1.5))
              err = 0
              do j = kl, 1, -1
                 err = (err + qx%mwa%mp(j+qx%ndig+2)) / qx%mbase
              enddo
              if ( (qx%kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
                   (qx%kround /= 1 .and. (err > 0.998 .or. err < 0.002)) )    &
                  kr_retry = kr_retry + 1
          endif
          if (kr_retry == 1 .and. nguard < qx%ndig+10) then
              kr_retry = 2
              retry = .true.
              return
          endif
          mlr = 2*qx%mwa%mp(qx%ndig+3) + 1
          if (qx%kround == -1 .or. qx%kround == 2) then
              call fmrnd(qx%mwa, qx%ndig, nguard, 0, qx)
          else if (mlr >= qx%mbase) then
              if (mlr-1 > qx%mbase .and. qx%mwa%mp(n1+1) < qx%mbase-1) then
                  if (qx%kround /= 0) then
                      qx%mwa%mp(n1+1) = qx%mwa%mp(n1+1) + 1
                      qx%mwa%mp(n1+2) = 0
                  endif
              else
                  call fmrnd(qx%mwa, qx%ndig, nguard, 0, qx)
              endif
          endif
      endif
      call fmmove(qx%mwa, mc, qx)

      mc%mp(1) = 1
      if (ma%mp(1)*mb%mp(1) < 0 .and. mc%mp(2) /= qx%munkno .and.  &
          mc%mp(3) /= 0) mc%mp(1) = -1
      qx%jrsign = jrssav

      return
      end subroutine fmdiv_m1

      subroutine fmdiv_r1(ma, mb, qx)

!  ma = ma / mb

!  This routine performs the trace printing for division.  fmdiv2_r1 is used to do the arithmetic.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb
      type(fm_settings) :: qx

      integer :: kovun

      qx%ncall = qx%ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == qx%mexpov .or. abs(mb%mp(2)) == qx%mexpov) kovun = 1
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) kovun = 2
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMDIV_R1'
          call fmntr_inp2(ma, mb, qx)
      endif

      call fmdiv2_r1(ma, mb, qx)

      if ((abs(ma%mp(2)) == qx%mexpov .and. kovun == 0) .or.  &
          (abs(ma%mp(2)) == qx%munkno .and. kovun < 2)) then
          qx%namest(qx%ncall) = 'FMDIV_R1'
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) then
          call fmntr_out1(ma, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmdiv_r1

      subroutine fmdiv_r2(ma, mb, qx)

!  mb = ma / mb

!  This routine performs the trace printing for division.  fmdiv2_r2 is used to do the arithmetic.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      integer :: kovun

      qx%ncall = qx%ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == qx%mexpov .or. abs(mb%mp(2)) == qx%mexpov) kovun = 1
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) kovun = 2
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMDIV_R2'
          call fmntr_inp2(ma, mb, qx)
      endif

      call fmdiv2_r2(ma, mb, qx)

      if ((abs(mb%mp(2)) == qx%mexpov .and. kovun == 0) .or.  &
          (abs(mb%mp(2)) == qx%munkno .and. kovun < 2)) then
          qx%namest(qx%ncall) = 'FMDIV_R2'
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) then
          call fmntr_out1(mb, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmdiv_r2

      subroutine fmdiv_sc(ma, mb, mc, kresult, qx)

!  Check for special cases for mc = ma / mb.

!  kresult = 1 is returned if a special case gives the value of mc.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      integer :: kresult
      intent (in) :: ma, mb
      intent (inout) :: mc, kresult
      type(fm_settings) :: qx

      integer :: jrssav


      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      kresult = 0
      jrssav = qx%jrsign
      if ((ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == qx%munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc, qx)
          qx%kflag = -4
          kresult = 1
          return
      endif
      if (abs(ma%mp(2)) >= qx%mexpov .or. abs(mb%mp(2)) >= qx%mexpov) then
          call fmovun_div(ma, mb, mc, qx)
          kresult = 1
          return
      endif
      if (mb%mp(3) == 0) then
          call fmi2m2(0, mc, qx)
          qx%kflag = -4
          mc%mp(2) = qx%munkno
          mc%mp(3) = 1
          qx%jrsign = jrssav
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0) then
          call fmi2m2(0, mc, qx)
          qx%jrsign = jrssav
          kresult = 1
          return
      endif

      return
      end subroutine fmdiv_sc

      subroutine fmdivd(ma, mb, mc, md, me, qx)

!  Double division routine.  md = ma / mc,   me = mb / mc

!  It is usually slightly faster to do two divisions that have the same denominator with one call.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md, me
      intent (in) :: ma, mb, mc
      intent (inout) :: md, me
      type(fm_settings) :: qx

      qx%ncall = qx%ncall + 1
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMDIVD'
          call fmntr_inp3(ma, mb, mc, qx)

          call fmdivd2(ma, mb, mc, md, me, qx)

          call fmntr_out2(md, me, qx)
      else
          call fmdivd2(ma, mb, mc, md, me, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmdivd

      subroutine fmdivd2(ma, mb, mc, md, me, qx)

!  Double division routine.  md = ma / mc,   me = mb / mc

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md, me
      intent (in) :: ma, mb, mc
      intent (inout) :: md, me
      type(fm_settings) :: qx

      integer :: jrssav, kresult

      call fmalloc(md, qx%ndig+2, qx)
      call fmalloc(me, qx%ndig+2, qx)
      call fmalloc(qx%mwa, 2*qx%ndig+30, qx)
      call fmalloc(qx%mwd, 2*qx%ndig+30, qx)
      call fmdivd_sc(ma, mb, mc, md, me, kresult, qx)
      if (kresult > 0) then
          return
      endif
      jrssav = qx%jrsign

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      call fmdivd_m1(ma, mb, mc, md, me, qx)
      qx%jrsign = jrssav

      return
      end subroutine fmdivd2

      subroutine fmdivd3(k, ma, mb, mc, mw, mr, qx)

!  Round from the work area mw to mr.

!  k = 1 for rounding mw = ma / mc
!  k = 2 for rounding mw = mb / mc

      use fmvals_parallel
      implicit none

      integer :: k
      type(multi) :: ma, mb, mc, mw, mr
      intent (in) :: k, ma, mb, mc
      intent (inout) :: mw, mr
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mlr
      double precision :: err
      integer :: j, kl, n1, nguard

      if (qx%ncall > 1) then
          nguard = qx%ngrd21
          if (nguard > qx%ndig) nguard = qx%ndig
      else
          nguard = qx%ngrd52 - 1
      endif
      n1 = qx%ndig + 1

      if (k == 1) then
          qx%jrsign = ma%mp(1) * mc%mp(1)
      else
          qx%jrsign = mb%mp(1) * mc%mp(1)
      endif
      if (mw%mp(3) == 0) then
          if (qx%ncall >= 1) then
              kl = min(nguard, int(3*qx%dlogtn/qx%dlogmb + 1.5))
              err = 0
              do j = kl, 1, -1
                 err = (err + mw%mp(j+qx%ndig+3)) / qx%mbase
              enddo
              if ( (qx%kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
                   (qx%kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) then
                  if (k == 1) then
                      call fmdiv2(ma, mc, mr, qx)
                  else
                      call fmdiv2(mb, mc, mr, qx)
                  endif
                  return
              endif
          endif
          mlr = 2*mw%mp(qx%ndig+4) + 1
          if (qx%kround == -1 .or. qx%kround == 2) then
              call fmrnd(mw, qx%ndig, nguard, 1, qx)
          else if (mlr >= qx%mbase) then
              if (mlr-1 > qx%mbase .and. mw%mp(n1+2) < qx%mbase-1) then
                  if (qx%kround /= 0) then
                      mw%mp(n1+2) = mw%mp(n1+2) + 1
                      mw%mp(n1+3) = 0
                  endif
              else
                  call fmrnd(mw, qx%ndig, nguard, 1, qx)
              endif
          endif
      else
          if (qx%ncall >= 1) then
              kl = min(nguard, int(3*qx%dlogtn/qx%dlogmb + 1.5))
              err = 0
              do j = kl, 1, -1
                 err = (err + mw%mp(j+qx%ndig+2)) / qx%mbase
              enddo
              if ( (qx%kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
                   (qx%kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) then
                  if (k == 1) then
                      call fmdiv2(ma, mc, mr, qx)
                  else
                      call fmdiv2(mb, mc, mr, qx)
                  endif
                  return
              endif
          endif
          mlr = 2*mw%mp(qx%ndig+3) + 1
          if (qx%kround == -1 .or. qx%kround == 2) then
              call fmrnd(mw, qx%ndig, nguard, 0, qx)
          else if (mlr >= qx%mbase) then
              if (mlr-1 > qx%mbase .and. mw%mp(n1+1) < qx%mbase-1) then
                  if (qx%kround /= 0) then
                      mw%mp(n1+1) = mw%mp(n1+1) + 1
                      mw%mp(n1+2) = 0
                  endif
              else
                  call fmrnd(mw, qx%ndig, nguard, 0, qx)
              endif
          endif
      endif
      call fmmove(mw, mr, qx)

      return
      end subroutine fmdivd3

      subroutine fmdivd_m1(ma, mb, mc, md, me, qx)

!  Method 1 for computing  md = ma / mc  and  me = mb / mc.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md, me
      intent (in) :: ma, mb, mc
      intent (inout) :: md, me
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: ma2p, maxmwa, mb2p, mbp1, mc2p, mcarry, mkt, mlmax,  &
                            mqdmwa, mqdmwd, mtemp
      double precision :: xb, xbr, xbase, xmwa, xmwd
      integer :: j, jb, jl, ka, kb, kl, kptmw, n1, ng, nguard, nl, nmbwds, nzdmb

      qx%kflag = 0

!             nguard is the number of guard digits used.

      if (qx%ncall > 1) then
          nguard = qx%ngrd21
          if (nguard > qx%ndig) nguard = qx%ndig
      else
          nguard = qx%ngrd52 - 1
      endif
      if (nguard > qx%ndig+10) nguard = qx%ndig + 10
      ma2p = abs(ma%mp(3))
      mb2p = abs(mb%mp(3))
      mc2p = abs(mc%mp(3))
      if ((mc2p >= ma2p .or. mc2p >= mb2p) .and. nguard < 2) nguard = 2
      n1 = qx%ndig + 1
      ng = qx%ndig + nguard

!             Copy ma and mb into the working arrays.

      do j = 3, n1
         qx%mwa%mp(j+2) = ma%mp(j+1)
         qx%mwd%mp(j+2) = mb%mp(j+1)
      enddo
      qx%mwa%mp(2) = ma%mp(2) - mc%mp(2) + 1
      qx%mwd%mp(2) = mb%mp(2) - mc%mp(2) + 1
      qx%mwa%mp(3) = 0
      qx%mwd%mp(3) = 0
      nl = n1 + nguard + 3
      do j = qx%ndig+3, nl
         qx%mwa%mp(j+1) = 0
         qx%mwd%mp(j+1) = 0
      enddo

      qx%mwa%mp(4) = ma%mp(3)
      qx%mwd%mp(4) = mb%mp(3)

!             nmbwds is the number of words used to compute the estimated quotient digits.

      nmbwds = 4
      if (qx%mbase < 100) nmbwds = 7

!             xb is an approximation of mc used in selecting estimated quotients.

      xbase = dble(qx%mbase)
      xb = 0
      jl = nmbwds
      if (jl <= n1) then
          do j = 2, jl
             xb = xb*xbase + dble(mc%mp(j+1))
          enddo
      else
          do j = 2, jl
             if (j <= n1) then
                 xb = xb*xbase + dble(mc%mp(j+1))
             else
                 xb = xb*xbase
             endif
          enddo
      endif
      if (jl+1 <= n1) xb = xb + dble(mc%mp(jl+2))/xbase
      xbr = 1.0d0/xb

!             mlmax determines when to normalize all of mwa.

      mbp1 = qx%mbase + 1
      mlmax = maxint/mbp1
      mkt = intmax - qx%mbase
      mlmax = min(mlmax, mkt)

!             Count the trailing zero digits of mc.

      nzdmb = n1 - 2
      do j = n1, 2, -1
         if (mc%mp(j+1) /= 0) then
             nzdmb = n1 - j
             exit
         endif
      enddo

!             maxmwa is an upper bound on the size of values in mwa divided by mbase-1.  It is used
!             to determine whether normalization can be postponed.

      maxmwa = 0

!             kptmw points to the next digit in the quotient.

      kptmw = 2

!             This is the start of the division loop.

!             xmwa is an approximation of the active part of mwa used in selecting estimated
!             quotients.

      do while (kptmw <= ng)
         kl = kptmw + nmbwds - 1
         if (kl <= nl) then
             xmwa = ((dble(qx%mwa%mp(kptmw+1))*xbase + dble(qx%mwa%mp(kptmw+2)))*xbase  &
                    + dble(qx%mwa%mp(kptmw+3)))*xbase + dble(qx%mwa%mp(kptmw+4))
             xmwd = ((dble(qx%mwd%mp(kptmw+1))*xbase + dble(qx%mwd%mp(kptmw+2)))*xbase  &
                    + dble(qx%mwd%mp(kptmw+3)))*xbase + dble(qx%mwd%mp(kptmw+4))
             do j = kptmw+4, kl
                xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
                xmwd = xmwd*xbase + dble(qx%mwd%mp(j+1))
             enddo
         else
             xmwa = dble(qx%mwa%mp(kptmw+1))
             xmwd = dble(qx%mwd%mp(kptmw+1))
             do j = kptmw+1, kl
                if (j <= nl) then
                    xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
                    xmwd = xmwd*xbase + dble(qx%mwd%mp(j+1))
                else
                    xmwa = xmwa*xbase
                    xmwd = xmwd*xbase
                endif
             enddo
         endif

!             mqdmwa and mqdmwd are the estimated quotient digits.

         mqdmwa = aint(xmwa*xbr)
         if (mqdmwa < 0) mqdmwa = mqdmwa - 1
         mqdmwd = aint(xmwd*xbr)
         if (mqdmwd < 0) mqdmwd = mqdmwd - 1

         maxmwa = maxmwa + max(abs(mqdmwa), abs(mqdmwd))

!             See if mwa and mwd must be normalized.

         ka = kptmw + 1
         kb = min(ka+qx%ndig-1-nzdmb, nl)
         if (maxmwa >= mlmax) then
             do j = kb, ka, -1
                if (qx%mwa%mp(j+1) < 0) then
                    mcarry = int((-qx%mwa%mp(j+1)-1)/qx%mbase) + 1
                    qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
                    qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
                else if (qx%mwa%mp(j+1) >= qx%mbase) then
                    mcarry = -int(qx%mwa%mp(j+1)/qx%mbase)
                    qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
                    qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
                endif
                if (qx%mwd%mp(j+1) < 0) then
                    mcarry = int((-qx%mwd%mp(j+1)-1)/qx%mbase) + 1
                    qx%mwd%mp(j+1) = qx%mwd%mp(j+1) + mcarry*qx%mbase
                    qx%mwd%mp(j) = qx%mwd%mp(j) - mcarry
                else if (qx%mwd%mp(j+1) >= qx%mbase) then
                    mcarry = -int(qx%mwd%mp(j+1)/qx%mbase)
                    qx%mwd%mp(j+1) = qx%mwd%mp(j+1) + mcarry*qx%mbase
                    qx%mwd%mp(j) = qx%mwd%mp(j) - mcarry
                endif
             enddo
             xmwa = 0
             xmwd = 0
             if (kl <= nl) then
                 do j = kptmw, kl
                    xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
                    xmwd = xmwd*xbase + dble(qx%mwd%mp(j+1))
                 enddo
             else
                 do j = kptmw, kl
                    if (j <= nl) then
                        xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
                        xmwd = xmwd*xbase + dble(qx%mwd%mp(j+1))
                    else
                        xmwa = xmwa*xbase
                        xmwd = xmwd*xbase
                    endif
                 enddo
             endif
             mqdmwa = aint(xmwa*xbr)
             if (mqdmwa < 0) mqdmwa = mqdmwa - 1
             mqdmwd = aint(xmwd*xbr)
             if (mqdmwd < 0) mqdmwd = mqdmwd - 1
             maxmwa = max(abs(mqdmwa), abs(mqdmwd))
         endif

!             Subtract mqdmwa*mc from mwa and mqdmwd*mc from mwd.

         jb = ka - 2

!             Major (Inner Loop)

         do j = ka+1, kb+1
            mtemp = mc%mp(j-jb)
            qx%mwa%mp(j) = qx%mwa%mp(j) - mqdmwa*mtemp
            qx%mwd%mp(j) = qx%mwd%mp(j) - mqdmwd*mtemp
         enddo

         qx%mwa%mp(ka+1) = qx%mwa%mp(ka+1) + qx%mwa%mp(ka)*qx%mbase
         qx%mwd%mp(ka+1) = qx%mwd%mp(ka+1) + qx%mwd%mp(ka)*qx%mbase
         qx%mwa%mp(kptmw+1) = mqdmwa
         qx%mwd%mp(kptmw+1) = mqdmwd

         kptmw = kptmw + 1
      enddo

      kl = kptmw + nmbwds - 1
      if (kl <= nl) then
          xmwa = ((dble(qx%mwa%mp(kptmw+1))*xbase + dble(qx%mwa%mp(kptmw+2)))*xbase  &
                 + dble(qx%mwa%mp(kptmw+3)))*xbase + dble(qx%mwa%mp(kptmw+4))
          xmwd = ((dble(qx%mwd%mp(kptmw+1))*xbase + dble(qx%mwd%mp(kptmw+2)))*xbase  &
                 + dble(qx%mwd%mp(kptmw+3)))*xbase + dble(qx%mwd%mp(kptmw+4))
          do j = kptmw+4, kl
             xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
             xmwd = xmwd*xbase + dble(qx%mwd%mp(j+1))
          enddo
      else
          xmwa = dble(qx%mwa%mp(kptmw+1))
          xmwd = dble(qx%mwd%mp(kptmw+1))
          do j = kptmw+1, kl
             if (j <= nl) then
                 xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
                 xmwd = xmwd*xbase + dble(qx%mwd%mp(j+1))
             else
                 xmwa = xmwa*xbase
                 xmwd = xmwd*xbase
             endif
          enddo
      endif
      mqdmwa = aint(xmwa*xbr)
      if (mqdmwa < 0) mqdmwa = mqdmwa - 1
      mqdmwd = aint(xmwd*xbr)
      if (mqdmwd < 0) mqdmwd = mqdmwd - 1
      qx%mwa%mp(kptmw+1) = mqdmwa
      qx%mwa%mp(kptmw+2) = 0
      qx%mwa%mp(kptmw+3) = 0
      qx%mwd%mp(kptmw+1) = mqdmwd
      qx%mwd%mp(kptmw+2) = 0
      qx%mwd%mp(kptmw+3) = 0

!             Final normalization.

      do j = kptmw-1, 3, -1
         if (qx%mwa%mp(j+1) < 0) then
             mcarry = int((-qx%mwa%mp(j+1)-1)/qx%mbase) + 1
             qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
             qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
         else if (qx%mwa%mp(j+1) >= qx%mbase) then
             mcarry = -int(qx%mwa%mp(j+1)/qx%mbase)
             qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
             qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
         endif
         if (qx%mwd%mp(j+1) < 0) then
             mcarry = int((-qx%mwd%mp(j+1)-1)/qx%mbase) + 1
             qx%mwd%mp(j+1) = qx%mwd%mp(j+1) + mcarry*qx%mbase
             qx%mwd%mp(j) = qx%mwd%mp(j) - mcarry
         else if (qx%mwd%mp(j+1) >= qx%mbase) then
             mcarry = -int(qx%mwd%mp(j+1)/qx%mbase)
             qx%mwd%mp(j+1) = qx%mwd%mp(j+1) + mcarry*qx%mbase
             qx%mwd%mp(j) = qx%mwd%mp(j) - mcarry
         endif
      enddo

!             Round, affix the sign, and return.

      call fmdivd3(1, ma, mb, mc, qx%mwa, md, qx)
      call fmdivd3(2, ma, mb, mc, qx%mwd, me, qx)

      if (qx%kflag < 0) then
          qx%namest(qx%ncall) = 'FMDIVD'
          call fmwarn(qx)
      endif

      md%mp(1) = ma%mp(1)*mc%mp(1)
      me%mp(1) = mb%mp(1)*mc%mp(1)

      return
      end subroutine fmdivd_m1

      subroutine fmdivd_sc(ma, mb, mc, md, me, kresult, qx)

!  Check for special cases for  md = ma / mc  and  me = mb / mc.

!  kresult = 1 is returned if a special case gives the values of md, me.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md, me
      integer :: kresult
      intent (in) :: ma, mb, mc
      intent (inout) :: md, me, kresult
      type(fm_settings) :: qx

      integer :: kb, kc, kovun

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      kresult = 0
      kc = 3100
      if (qx%ndig >= kc .or.                                             &
          abs(ma%mp(2)) > qx%mexpab .or. abs(mb%mp(2)) > qx%mexpab .or.  &
          abs(mc%mp(2)) > qx%mexpab .or. qx%mbase*qx%mbase <= mxbase/(4*qx%mbase)) then
          kovun = 0
          if (ma%mp(2) == qx%mexpov .or. ma%mp(2) == qx%mexpun .or.  &
              mb%mp(2) == qx%mexpov .or. mb%mp(2) == qx%mexpun .or.  &
              mc%mp(2) == qx%mexpov .or. mc%mp(2) == qx%mexpun) kovun = 1
          if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno .or.  &
              mc%mp(2) == qx%munkno) kovun = 2
          qx%ncall = qx%ncall + 1
          call fmdiv2(ma, mc, md, qx)
          kb = qx%kflag
          call fmdiv2(mb, mc, me, qx)
          qx%ncall = qx%ncall - 1
          if (((qx%kflag < 0 .or. kb < 0) .and. kovun == 0) .or.  &
              ((qx%kflag == -4 .or. kb == -4) .and. kovun == 1)) then
              if (qx%kflag == -4 .or. kb == -4) then
                  qx%kflag = -4
              else if (qx%kflag == -5 .or. kb == -5) then
                  qx%kflag = -5
              else
                  qx%kflag = min(qx%kflag, kb)
              endif
              qx%namest(qx%ncall) = 'FMDIVD'
              call fmwarn(qx)
          endif
          kresult = 1
          return
      endif
      if (mc%mp(3) == 0) then
          qx%kflag = -4
          qx%namest(qx%ncall) = 'FMDIVD'
          call fmwarn(qx)
          call fmunknown(md, qx)
          call fmunknown(me, qx)
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0 .or. mb%mp(3) == 0) then
          call fmdiv2(ma, mc, md, qx)
          call fmdiv2(mb, mc, me, qx)
          kresult = 1
          return
      endif

      return
      end subroutine fmdivd_sc

      subroutine fmdivfft(mb, qx)
      use fmvals_parallel
      implicit none

!  Internal division routine ma/mb for very high precision.
!  ma has already been moved to mwa before this routine is called.
!  Fast Fourier transforms are used, and the number of digits carried is usually
!  raised slightly, because the fft needs for n to have only small prime factors.

      type(multi) :: mb
      intent (in) :: mb
      type(fm_settings) :: qx

      double precision :: xb
      real (kind(1.0d0)) :: mwa1
      integer :: j, k, kst, nd2, ndsave, nstack(49)
      type(multi) :: mxy(10)

      ndsave = qx%ndig

!             Save low precision copies of the numerator and denominator.

      call fmndig(20, qx)
      call fmi2m2(1, mxy(7), qx)
      do j = 1, size(mxy(7)%mp)-3
         mxy(7)%mp(j+2) = qx%mwa%mp(j+3)
      enddo
      mxy(7)%mp(2) = qx%mwa%mp(2) + mb%mp(2) - 1
      call fmequ(mb, mxy(8), ndsave, 20, qx)
      qx%ndig = ndsave

!             Use Newton iteration and the routine fmmpyfft, with the formula
!                 x = x + x*(1 - b*x)
!             to converge to 1/b.

      k = max(qx%ngrd52-1, 2)
      call fmndig(max(qx%ndig+k, 3), qx)

!             Generate the first approximation.

      call fmi2m2(1, mxy(1), qx)
      do j = 1, ndsave
         mxy(1)%mp(j+2) = qx%mwa%mp(j+3)
      enddo
      call fmequ(mb, mxy(2), ndsave, qx%ndig, qx)
      mxy(1)%mp(2) = 0
      mxy(2)%mp(1) = 1
      mxy(2)%mp(2) = 0
      kst = qx%mwa%mp(2)

!             fmadd2 will negate mxy(2) and add.

      qx%ksub = 1
      call fmadd2(mxy(1), mxy(2), mxy(3), qx)
      qx%ksub = 0
      if (mxy(3)%mp(1) >= 0) then
          mwa1 = kst
      else
          mwa1 = kst - 1
      endif
      call fmm2dp2(mxy(2), xb, qx)
      xb = 1.0d0/xb
      call fmdpm2(xb, mxy(3), qx)

!             Initialize.

      call fmi2m2(0, mxy(4), qx)
      call fmi2m2(0, mxy(5), qx)
      call fmi2m2(1, mxy(6), qx)
      call fmdig(nstack, kst, qx)

!             Newton iteration.

      do j = 1, kst-1
         call fmndig(nstack(j), qx)
         call fmmpy2(mxy(2), mxy(3), mxy(4), qx)
         qx%ksub = 1
         call fmadd2_r2(mxy(6), mxy(4), qx)
         qx%ksub = 0
         call fmndig(nstack(max(1, j-1)), qx)
         call fmmpy2(mxy(3), mxy(4), mxy(5), qx)
         call fmndig(nstack(j), qx)
         call fmadd2_r1(mxy(3), mxy(5), qx)
      enddo

!             Karp's trick:
!             The standard last step would give 1/b and then a final full precision
!             multiply by a would be done.  That does 2 full mpy's at the final precision,
!             and one at next-to-last (1/2 of final) precision.

!             Instead combine the a* step into the last iteration and get
!             y = a*x   at 1/2 precision, then
!             y = y + x*(a - b*y)
!             where the x* mpy is at 1/2 precision and only b*y is at final precision.

      call fmndig(nstack(max(1, kst-1)), qx)
      call fmmpy2(mxy(1), mxy(3), mxy(4), qx)
      call fmndig(nstack(kst), qx)
      call fmmpy2(mxy(2), mxy(4), mxy(5), qx)
      qx%ksub = 1
      call fmadd2(mxy(1), mxy(5), mxy(6), qx)
      qx%ksub = 0
      call fmndig(nstack(max(1, kst-1)), qx)
      call fmmpy2(mxy(3), mxy(6), mxy(5), qx)
      call fmndig(nstack(kst), qx)
      call fmadd2(mxy(4), mxy(5), mxy(6), qx)

      mxy(6)%mp(2) = mwa1

!             Because of rounding errors in the Newton iteration, if the quotient is very close
!             to a power of mbase the exponent of the result might be off by one.
!             Check by doing low precision multiplications.

      nd2 = qx%ndig
      mxy(7)%mp(1) = -1
      mxy(8)%mp(1) = 1
      call fmequ(mxy(6), mxy(4), ndsave, 20, qx)
      mxy(4)%mp(1) = 1
      call fmndig(20, qx)
      call fmmpy2(mxy(8), mxy(4), mxy(5), qx)
      call fmadd2(mxy(5), mxy(7), mxy(9), qx)
      mxy(9)%mp(1) = 1
      mxy(4)%mp(2) = mxy(4)%mp(2) + 1
      call fmmpy2(mxy(8), mxy(4), mxy(5), qx)
      call fmadd2(mxy(5), mxy(7), mxy(10), qx)
      if (mxy(10)%mp(3) /= 0) mxy(10)%mp(1) = -1
      call fmadd2(mxy(10), mxy(9), mxy(5), qx)
      if (mxy(5)%mp(1) == 1) then
          call fmeq(mxy(10), mxy(9), qx)
          mxy(6)%mp(2) = mxy(6)%mp(2) + 1
      endif
      mxy(4)%mp(2) = mxy(4)%mp(2) - 2
      call fmmpy2(mxy(8), mxy(4), mxy(5), qx)
      call fmadd2(mxy(5), mxy(7), mxy(10), qx)
      if (mxy(10)%mp(3) /= 0) mxy(10)%mp(1) = -1
      call fmadd2(mxy(10), mxy(9), mxy(5), qx)
      if (mxy(5)%mp(1) == 1) then
          mxy(6)%mp(2) = mxy(6)%mp(2) - 1
      endif
      call fmndig(nd2, qx)

      do j = 1, qx%ndig+2
         qx%mwa%mp(j) = mxy(6)%mp(j)
      enddo
      if (qx%kflag == 1) qx%kflag = 0
      qx%ndig = ndsave

      return
      end subroutine fmdivfft

      subroutine fmdivi(ma, ival, mb, qx)

!  mb = ma / ival

!  Divide fm number ma by one word integer ival.

!  This routine is faster than fmdiv when the divisor is less than mxbase (the square root of the
!  largest integer).
!  When ival is not less than mxbase, fmdiv2 is used.  In this case, if ival is known to be a
!  product of two integers less than mxbase, it is usually faster to make two calls to fmdivi
!  with half-word factors than one call with their product.

      use fmvals_parallel
      implicit none
      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      type(fm_settings) :: qx

      qx%ncall = qx%ncall + 1
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMDIVI'
          call fmntr_inp1i(ma, ival, qx)

          call fmdivi2(ma, ival, mb, qx)

          call fmntr_out1(mb, qx)
      else
          call fmdivi2(ma, ival, mb, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmdivi

      subroutine fmdivi2(ma, ival, mb, qx)

!  Internal divide by integer routine.  mb = ma / ival

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      type(fm_settings) :: qx

      integer :: kr_retry, kresult
      logical :: retry

      call fmalloc(mb, qx%ndig+2, qx)
      call fmalloc(qx%mwa, 2*qx%ndig+30, qx)
      call fmdivi_sc(ma, ival, mb, kresult, qx)
      if (kresult > 0) then
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      kr_retry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fmdivi_m1(ma, ival, mb, kr_retry, retry, qx)
      enddo

      return
      end subroutine fmdivi2

      subroutine fmdivi2_r1(ma, ival, qx)

!  Internal divide by integer routine.  ma = ma / ival

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ival
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: kr_retry, kresult
      logical :: retry

      call fmalloc(qx%mwa, 2*qx%ndig+30, qx)
      call fmdivi_r1_sc(ma, ival, kresult, qx)
      if (kresult > 0) then
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      kr_retry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fmdivi_r1_m1(ma, ival, kr_retry, retry, qx)
      enddo

      return
      end subroutine fmdivi2_r1

      subroutine fmdivi_m1(ma, ival, mb, kr_retry, retry, qx)

!  Method 1 for computing mb = ma / ival.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: ival, kr_retry
      logical :: retry
      intent (in) :: ma, ival
      intent (inout) :: mb, kr_retry, retry
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mkt, mlr, modint, mvalp
      double precision :: err
      integer :: ka, kb, kl, klp, kpt, kptwa, n1, nguard, nmval, nv2

      integer :: j, jrssav
      type(multi) :: mxy

!             nguard is the number of guard digits used.

      if (qx%ncall > 1) then
          nguard = qx%ngrd21
      else
          nguard = qx%ngrd52
          if (kr_retry >= 1) then
              nguard = qx%ndig + 10
          endif
      endif
      if (nguard > qx%ndig+10) nguard = qx%ndig + 10
      jrssav = qx%jrsign
      n1 = qx%ndig + 1

!             If abs(ival) >= mxbase use fmdiv.

      mvalp = abs(ival)
      nmval = int(mvalp)
      nv2 = nmval - 1
      if (abs(ival) > mxbase .or. nmval /= abs(ival) .or. nv2 /= abs(ival)-1) then
          call fmi2m2(ival, mxy, qx)
          call fmdiv2(ma, mxy, mb, qx)
          qx%jrsign = jrssav
          return
      endif

!             Find the first significant digit of the quotient.

      mkt = ma%mp(3)
      klp = 0
      kpt = 2
      if (mkt >= mvalp) then
          kpt = 2
      else
          do j = 3, n1
             mkt = mkt*qx%mbase + ma%mp(j+1)
             if (mkt >= mvalp) then
                 kpt = j
                 klp = 1
                 exit
             endif
          enddo
          if (klp == 0) then
              kpt = n1
              do while (mkt < mvalp)
                 kpt = kpt + 1
                 mkt = mkt*qx%mbase
              enddo
          endif
      endif

!             Do the rest of the division.

      ka = kpt + 1
      qx%mwa%mp(2) = ma%mp(2) + 2 - kpt
      qx%mwa%mp(3) = int (mkt/mvalp)
      modint = mkt - qx%mwa%mp(3)*mvalp
      kptwa = 2
      if (ka <= n1) then
          kl = 3 - ka

!             (Inner Loop)

          do j = ka+1, n1+1
             mkt = modint*qx%mbase + ma%mp(j)
             qx%mwa%mp(j+kl) = int (mkt/mvalp)
             modint = mkt - qx%mwa%mp(j+kl)*mvalp
          enddo
          kptwa = kl + n1
      endif

      ka = kptwa + 1
      kb = n1 + nguard
      do j = ka, kb
         mkt = modint*qx%mbase
         qx%mwa%mp(j+1) = int (mkt/mvalp)
         modint = mkt - qx%mwa%mp(j+1)*mvalp
      enddo

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      if (qx%ncall >= 1) then
          kl = min(nguard, int(3*qx%dlogtn/qx%dlogmb + 1.5))
          err = 0
          do j = kl, 1, -1
             err = (err + qx%mwa%mp(j+qx%ndig+2)) / qx%mbase
          enddo
          if ( (qx%kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
               (qx%kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) kr_retry = kr_retry + 1
      endif
      if (kr_retry == 1 .and. nguard < qx%ndig+10) then
          kr_retry = 2
          retry = .true.
          return
      endif

!             Round the result, put the sign on mb and return.

      mlr = 2*qx%mwa%mp(qx%ndig+3) + 1
      if ((ma%mp(1) > 0 .and. ival > 0) .or. (ma%mp(1) < 0 .and. ival < 0)) then
          qx%jrsign = 1
      else
          qx%jrsign = -1
      endif
      if (qx%kround == -1 .or. qx%kround == 2) then
          call fmrnd(qx%mwa, qx%ndig, nguard, 0, qx)
      else if (mlr >= qx%mbase) then
          if (mlr-1 > qx%mbase .and. qx%mwa%mp(n1+1) < qx%mbase-1) then
              if (qx%kround /= 0) then
                  qx%mwa%mp(n1+1) = qx%mwa%mp(n1+1) + 1
                  qx%mwa%mp(n1+2) = 0
              endif
          else
              call fmrnd(qx%mwa, qx%ndig, nguard, 0, qx)
          endif
      endif
      call fmmove(qx%mwa, mb, qx)

      if (qx%kflag < 0) then
          qx%namest(qx%ncall) = 'FMDIVI'
          call fmwarn(qx)
      endif
      mb%mp(1) = qx%jrsign
      qx%jrsign = jrssav

      return
      end subroutine fmdivi_m1

      subroutine fmdivi_r1(ma, ival, qx)

!  ma = ma / ival

!  Divide fm number ma by one word integer ival.

!  This routine is faster than fmdiv when the divisor is less than mxbase (the square root of the
!  largest integer).
!  When ival is not less than mxbase, fmdiv2 is used.  In this case, if ival is known to be a
!  product of two integers less than mxbase, it is usually faster to make two calls to fmdivi_r1
!  with half-word factors than one call with their product.

      use fmvals_parallel
      implicit none
      type(multi) :: ma
      integer :: ival
      intent (in) :: ival
      intent (inout) :: ma
      type(fm_settings) :: qx

      qx%ncall = qx%ncall + 1
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMDIVI_R1'
          call fmntr_inp1i(ma, ival, qx)

          call fmdivi2_r1(ma, ival, qx)

          call fmntr_out1(ma, qx)
      else
          call fmdivi2_r1(ma, ival, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmdivi_r1

      subroutine fmdivi_r1_m1(ma, ival, kr_retry, retry, qx)

!  Method 1 for computing ma = ma / ival.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: ival, kr_retry
      logical :: retry
      intent (in) :: ival
      intent (inout) :: ma, kr_retry, retry
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mkt, mlr, modint, mvalp
      double precision :: err
      integer :: ka, kb, kl, klp, kpt, kptwa, n1, nguard, nmval, nv2

      integer :: j, jrssav
      type(multi) :: mxy(2)

!             nguard is the number of guard digits used.

      if (qx%ncall > 1) then
          nguard = qx%ngrd21
      else
          nguard = qx%ngrd52
          if (kr_retry >= 1) then
              nguard = qx%ndig + 10
          endif
      endif
      if (nguard > qx%ndig+10) nguard = qx%ndig + 10
      jrssav = qx%jrsign
      n1 = qx%ndig + 1

!             If abs(ival) >= mxbase use fmdiv.

      mvalp = abs(ival)
      nmval = int(mvalp)
      nv2 = nmval - 1
      if (abs(ival) > mxbase .or. nmval /= abs(ival) .or. nv2 /= abs(ival)-1) then
          call fmi2m2(ival, mxy(1), qx)
          call fmdiv2(ma, mxy(1), mxy(2), qx)
          call fmeq(mxy(2), ma, qx)
          qx%jrsign = jrssav
          return
      endif

!             Find the first significant digit of the quotient.

      mkt = ma%mp(3)
      klp = 0
      kpt = 2
      if (mkt >= mvalp) then
          kpt = 2
      else
          do j = 3, n1
             mkt = mkt*qx%mbase + ma%mp(j+1)
             if (mkt >= mvalp) then
                 kpt = j
                 klp = 1
                 exit
             endif
          enddo
          if (klp == 0) then
              kpt = n1
              do while (mkt < mvalp)
                 kpt = kpt + 1
                 mkt = mkt*qx%mbase
              enddo
          endif
      endif

!             Do the rest of the division.

      ka = kpt + 1
      qx%mwa%mp(2) = ma%mp(2) + 2 - kpt
      qx%mwa%mp(3) = int (mkt/mvalp)
      modint = mkt - qx%mwa%mp(3)*mvalp
      kptwa = 2
      if (ka <= n1) then
          kl = 3 - ka

!             (Inner Loop)

          do j = ka+1, n1+1
             mkt = modint*qx%mbase + ma%mp(j)
             qx%mwa%mp(j+kl) = int (mkt/mvalp)
             modint = mkt - qx%mwa%mp(j+kl)*mvalp
          enddo
          kptwa = kl + n1
      endif

      ka = kptwa + 1
      kb = n1 + nguard
      do j = ka, kb
         mkt = modint*qx%mbase
         qx%mwa%mp(j+1) = int (mkt/mvalp)
         modint = mkt - qx%mwa%mp(j+1)*mvalp
      enddo

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      if (qx%ncall >= 1) then
          kl = min(nguard, int(3*qx%dlogtn/qx%dlogmb + 1.5))
          err = 0
          do j = kl, 1, -1
             err = (err + qx%mwa%mp(j+qx%ndig+2)) / qx%mbase
          enddo
          if ( (qx%kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
               (qx%kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) kr_retry = kr_retry + 1
      endif
      if (kr_retry == 1 .and. nguard < qx%ndig+10) then
          kr_retry = 2
          retry = .true.
          return
      endif

!             Round the result, put the sign on ma and return.

      mlr = 2*qx%mwa%mp(qx%ndig+3) + 1
      if ((ma%mp(1) > 0 .and. ival > 0) .or. (ma%mp(1) < 0 .and. ival < 0)) then
          qx%jrsign = 1
      else
          qx%jrsign = -1
      endif
      if (qx%kround == -1 .or. qx%kround == 2) then
          call fmrnd(qx%mwa, qx%ndig, nguard, 0, qx)
      else if (mlr >= qx%mbase) then
          if (mlr-1 > qx%mbase .and. qx%mwa%mp(n1+1) < qx%mbase-1) then
              if (qx%kround /= 0) then
                  qx%mwa%mp(n1+1) = qx%mwa%mp(n1+1) + 1
                  qx%mwa%mp(n1+2) = 0
              endif
          else
              call fmrnd(qx%mwa, qx%ndig, nguard, 0, qx)
          endif
      endif
      call fmmove(qx%mwa, ma, qx)

      if (qx%kflag < 0) then
          qx%namest(qx%ncall) = 'FMDIVI_R1'
          call fmwarn(qx)
      endif
      ma%mp(1) = qx%jrsign
      qx%jrsign = jrssav

      return
      end subroutine fmdivi_r1_m1

      subroutine fmdivi_r1_sc(ma, ival, kresult, qx)

!  Check for special cases for ma = ma / ival.

!  kresult = 1 is returned if a special case gives the value of ma.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: ival, kresult
      intent (in) :: ival
      intent (inout) :: ma, kresult
      type(fm_settings) :: qx

      integer :: kovun
      type(multi) :: mxy(2)

      kresult = 0
      if ((ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) .or. ival == 0) then
          call fmunknown(ma, qx)
          qx%kflag = -4
          kresult = 1
          return
      endif

      if (abs(ma%mp(2)) >= qx%mexpov) then
          kovun = 0
          if (ma%mp(2) == qx%munkno) kovun = 2
          call fmi2m(ival, mxy(1), qx)
          call fmovun_div(ma, mxy(1), mxy(2), qx)
          call fmeq(mxy(2), ma, qx)
          if (kovun /= 2 .and. ma%mp(2) == qx%munkno) then
              qx%namest(qx%ncall) = 'FMDIVI_R1'
              call fmwarn(qx)
          endif
          kresult = 1
          return
      endif

      if (ma%mp(3) == 0) then
          kresult = 1
          return
      endif

      if (abs(ival) == 1) then
          ma%mp(1) = ma%mp(1)*ival
          if (ma%mp(2) == qx%mexpov) qx%kflag = -5
          if (ma%mp(2) == qx%mexpun) qx%kflag = -6
          kresult = 1
          return
      endif

      return
      end subroutine fmdivi_r1_sc

      subroutine fmdivi_sc(ma, ival, mb, kresult, qx)

!  Check for special cases for mb = ma / ival.

!  kresult = 1 is returned if a special case gives the value of mb.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: ival, kresult
      intent (in) :: ma, ival
      intent (inout) :: mb, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: mxy

      kresult = 0
      if ((ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) .or. ival == 0) then
          call fmunknown(mb, qx)
          qx%kflag = -4
          kresult = 1
          return
      endif

      if (abs(ma%mp(2)) >= qx%mexpov) then
          call fmi2m(ival, mxy, qx)
          call fmovun_div(ma, mxy, mb, qx)
          if (ma%mp(2) /= qx%munkno .and. mb%mp(2) == qx%munkno) then
              qx%namest(qx%ncall) = 'FMDIVI'
              call fmwarn(qx)
          endif
          kresult = 1
          return
      endif

      if (ma%mp(3) == 0) then
          call fmeq(ma, mb, qx)
          kresult = 1
          return
      endif

      if (abs(ival) == 1) then
          do j = 1, qx%ndig+2
             mb%mp(j) = ma%mp(j)
          enddo
          mb%mp(1) = ma%mp(1)*ival
          if (ma%mp(2) == qx%mexpov) qx%kflag = -5
          if (ma%mp(2) == qx%mexpun) qx%kflag = -6
          kresult = 1
          return
      endif

      return
      end subroutine fmdivi_sc

      subroutine fmdp2m(x, ma, qx)

!  ma = x

!  Convert a double precision floating point number to FM format.

!  This version tries to convert the double precision machine number to FM with accuracy of nearly
!  full FM precision. If conversion to FM with approximately double precision accuracy is good
!  enough, fmdpm is faster and uses less scratch space.

!  This routine assumes the machine's base for double precision is a power of two.

      use fmvals_parallel
      implicit none

      double precision :: x
      type(multi) :: ma
      intent (in) :: x
      intent (inout) :: ma
      type(fm_settings) :: qx

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMDP2M'
      if (qx%ntrace /= 0) call fmntr_inpd(x, qx)

      call fmdp2m2(x, ma, qx)

      if (qx%ntrace /= 0) call fmntr_out1(ma, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmdp2m

      subroutine fmdp2m2(x, ma, qx)

!  Internal routine for converting double precision to multiple precision.

      use fmvals_parallel
      implicit none

      double precision :: x
      type(multi) :: ma
      intent (in) :: x
      intent (inout) :: ma
      type(fm_settings) :: qx

      double precision :: y, z
      integer :: j, k, kd, km, nb, ne, ndsave
      type(multi) :: mxy

      call fmalloc(ma, qx%ndig+2, qx)

!             Increase the working precision.

      ndsave = qx%ndig
      if (qx%ncall == 1) then
          k = max(qx%ngrd21, 1)
          call fmndig(max(qx%ndig+k, 3), qx)
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      qx%kflag = 0

!             Special case for x = 0.

      if (x == 0.0d0) then
          do j = 2, ndsave+2
             ma%mp(j) = 0
          enddo
          ma%mp(1) = 1
          qx%ndig = ndsave
          return
      endif

!             Check for x = + or - Infinity, or Nan.  Return unknown if so.

      if (x > huge(x) .or. x < -huge(x) .or. (.not.(x == x))) then
          do j = 4, ndsave+2
             ma%mp(j) = 0
          enddo
          qx%kflag = -4
          ma%mp(1) = 1
          ma%mp(2) = qx%munkno
          ma%mp(3) = 1
          call fmwarn(qx)
          qx%ndig = ndsave
          return
      endif

!             Special case for mbase = 2.

      if (qx%mbase == 2 .and. radix(x) == 2) then
          call fmndig(max(qx%ndig, digits(x)), qx)
          y = fraction(abs(x))
          call fmi2m(0, mxy, qx)
          do j = 1, min(digits(x), qx%ndig)
             y = y + y
             mxy%mp(j+2) = int(y)
             y = y - int(y)
          enddo
          mxy%mp(2) = exponent(x)
          call fmequ(mxy, ma, qx%ndig, ndsave, qx)
          ma%mp(1) = 1
          if (x < 0.0 .and. ma%mp(2) /= qx%munkno .and. ma%mp(3) /= 0) then
              ma%mp(1) = -1
          endif
          qx%ndig = ndsave
          return
      endif

!             General case.

      z = fraction(abs(x))
      nb = digits(x)
      y = z * 2.0d0**nb
      ne = nint( log(abs(x)/y) / log(2.0d0))
      kd = int( log(y) / log(qx%mbase) ) + 1
      call fmi2m(0, mxy, qx)
      mxy%mp(1) = 1
      mxy%mp(2) = kd

      do j = kd+2, 3, -1
         mxy%mp(j) = mod(y, qx%mbase)
         y = aint(y/qx%mbase)
      enddo

      km = 2
      do j = 1, abs(ne)
         if (ne > 0) then
             if (km >= (maxint/2)/qx%mbase .or. km >= intmax/2) then
                 call fmmpyi_r1(mxy, km, qx)
                 km = 2
             else
                 km = km * 2
             endif
         else if (ne < 0) then
             if (km >= mxbase/2) then
                 call fmdivi2_r1(mxy, km, qx)
                 km = 2
             else
                 km = km * 2
             endif
         endif
      enddo

      km = km / 2
      if (km > 1) then
          if (ne > 0) then
              call fmmpyi_r1(mxy, km, qx)
          else
              call fmdivi2_r1(mxy, km, qx)
          endif
      endif

      if (x < 0) mxy%mp(1) = -1

      call fmequ(mxy, ma, qx%ndig, ndsave, qx)

      ma%mp(1) = 1
      if (x < 0.0 .and. ma%mp(2) /= qx%munkno .and. ma%mp(3) /= 0) ma%mp(1) = -1
      qx%ndig = ndsave

      return
      end subroutine fmdp2m2

      function fmdplg(a, qx)

!  Internal routine for computing an approximation to log(gamma(a)) using Stirling's formula.

      use fmvals_parallel
      implicit none

      double precision :: fmdplg, a
      intent (in) :: a
      type(fm_settings) :: qx

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      if (a > 0.0d0) then
          fmdplg = -a + (a-0.5d0)*log(a) + qx%dlogtp/2.0d0
      else if (a < 0.0d0) then
          if (abs(a) < 1.0d+8 .and. abs(a) > 1) then
              fmdplg = -(a-1.0d0) - (0.5d0-a)*log(1.0d0-a) - qx%dlogtp/2.0d0 -  &
                       log(abs(sin(qx%dppi*a))+1.0d-10) + qx%dlogpi
          else
              fmdplg = -(a-1.0d0) - (0.5d0-a)*log(1.0d0-a) - qx%dlogtp/2.0d0 + qx%dlogpi
          endif
      else

!             a = 0 is really an approximation for some value in [-1,1].

          fmdplg = 0.0d0
      endif

      return
      end function fmdplg

      subroutine fmdpm(x, ma, qx)

!  ma = x

!  Convert a double precision floating point number to FM format.

!  In general, the relative accuracy of the FM number returned is only the relative accuracy of a
!  machine precision number.  This may be true even if x can be represented exactly in the machine
!  floating point number system.

!  This version is faster than fmdp2m, but often less accurate.

      use fmvals_parallel
      implicit none

      double precision :: x
      type(multi) :: ma
      intent (in) :: x
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: k
      double precision :: y, yt

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMDPM'
      if (qx%ntrace /= 0) call fmntr_inpd(x, qx)

!             Check to see if x is exactly a small integer.  If so, converting as an integer is
!             better.  Also see if x is exactly a small integer divided by a small power of two.

      y = 1048576.0d0
      if (abs(x) < y) then
          k = int(x)
          y = k
          if (y == x) then
              call fmi2m2(k, ma, qx)
              if (qx%ntrace /= 0) call fmntr_out1(ma, qx)
              qx%ncall = qx%ncall - 1
              return
          endif
      endif
      if (abs(x) < 1.0d0) then
          y = 4096.0d0*x
          k = int(y)
          yt = k
          if (y == yt) then
              call fmi2m2(k, ma, qx)
              call fmdivi_r1(ma, 4096, qx)
              if (qx%ntrace /= 0) call fmntr_out1(ma, qx)
              qx%ncall = qx%ncall - 1
              return
          endif
      endif

      call fmdpm2(x, ma, qx)

      if (qx%ntrace /= 0) call fmntr_out1(ma, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmdpm

      subroutine fmdpm2(x, ma, qx)

!  Internal routine for converting double precision to multiple precision.

      use fmvals_parallel
      implicit none

      double precision :: x
      type(multi) :: ma
      intent (in) :: x
      intent (inout) :: ma
      type(fm_settings) :: qx

      double precision :: one, xbase, y, y2, yt
      real (kind(1.0d0)) :: mk, mn
      integer :: j, k, ks, n1, n2, ne

      call fmalloc(ma, qx%ndig+2, qx)

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      qx%kflag = 0
      n1 = qx%ndig + 1
      n2 = qx%ndig + 2

!             Check for x = + or - Infinity, or Nan.  Return unknown if so.

      if (x > huge(x) .or. x < -huge(x) .or. (.not.(x == x))) then
          do j = 4, n2
             ma%mp(j) = 0
          enddo
          qx%kflag = -4
          ma%mp(1) = 1
          ma%mp(2) = qx%munkno
          ma%mp(3) = 1
          call fmwarn(qx)
          return
      endif

      one = 1.0d0
      xbase = qx%mbase
      k = 0

!             ne-1 is the number of words at the current precision and base roughly equal to
!             machine precision.

      ne = int(qx%dlogeb) + 3
      y = x
      if (x < 0.0) y = -x

      if (x == 0.0) then
          do j = 2, n2
             ma%mp(j) = 0
          enddo
          ma%mp(1) = 1
          if (x < 0.0 .and. ma%mp(2) /= qx%munkno .and. ma%mp(3) /= 0) then
              ma%mp(1) = -1
          endif
          return
      endif

!             Get the exponent.

      if (y > one) then
          if (y/xbase < y) then
              do while (y > one)
                 k = k + 1
                 y = y/xbase
              enddo
              if (y < one) then
                  ma%mp(2) = k
              endif
          else
              qx%kflag = -4
              call fmwarn(qx)
              do j = 4, n2
                 ma%mp(j) = 0
              enddo
              ma%mp(1) = 1
              ma%mp(2) = qx%munkno
              ma%mp(3) = 1
              return
          endif
      else if (y < one) then
          if (y*xbase > y) then
              do while (y < one)
                 k = k - 1
                 y = y*xbase
              enddo
              if (y > one) then
                  k = k + 1
                  y = y/xbase
                  ma%mp(2) = k
              endif
          else
              qx%kflag = -4
              call fmwarn(qx)
              do j = 4, n2
                 ma%mp(j) = 0
              enddo
              ma%mp(1) = 1
              ma%mp(2) = qx%munkno
              ma%mp(3) = 1
              return
          endif
      endif

      if (y == 1) then
          do j = 4, n2
             ma%mp(j) = 0
          enddo
          ma%mp(1) = 1
          ma%mp(2) = k + 1
          ma%mp(3) = 1
          if (x < 0.0 .and. ma%mp(2) /= qx%munkno .and. ma%mp(3) /= 0) then
              ma%mp(1) = -1
          endif
          return
      endif

!             Build the rest of the number.

      ks = 1
      do j = 2, ne
         y = y*xbase
         mk = aint(y)
         yt = -mk
         call fmdbl(y, yt, y2)
         y = y2
         ma%mp(j+1) = mk
         if (j >= n1) then
             ks = 0
             exit
         endif
      enddo
      if (ks == 1) then
          k = ne + 1
          do j = k+1, n2
             ma%mp(j) = 0
          enddo
      endif

!             Normalize.

      if (abs(ma%mp(3)) >= qx%mbase) then
          do j = n1, 3, -1
             ma%mp(j+1) = ma%mp(j)
          enddo
          mn = aint (ma%mp(3)/qx%mbase)
          ma%mp(4) = ma%mp(3) - mn*qx%mbase
          ma%mp(3) = mn
          ma%mp(2) = ma%mp(2) + 1
      else if (ma%mp(3) == 0) then
          do j = 2, qx%ndig
             ma%mp(j+1) = ma%mp(j+2)
          enddo
          ma%mp(2) = ma%mp(2) - 1
          ma%mp(n2) = 0
      endif

      ma%mp(1) = 1
      if (x < 0.0 .and. ma%mp(2) /= qx%munkno .and. ma%mp(3) /= 0) ma%mp(1) = -1

      return
      end subroutine fmdpm2

      subroutine fmei(ma, mb, qx)

!  mb = exponential integral(ma)

!  Integral from -infinity to ma of e**t / t  dt.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(17), mresult, mretry

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmei_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      n_acc = nint(qx%ndig*qx%alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmei_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry, qx)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmei

      subroutine fmei_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)

!  Method selection for computing ln(gamma(ma)).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(17), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc
      type(fm_settings) :: qx

      double precision :: x, y
      integer :: iextra, kflagx, nmethd

      retry = .true.

      n_acc = nint(qx%ndig*qx%alogm2)
      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

!             x is a double precision approximation to the input argument to this function.

      call fmm2dp(mxy(1), x, qx)
      kflagx = qx%kflag
      if (qx%kflag /= 0 .and. mxy(1)%mp(2) < 0) then
          x = (10.0d0*qx%dlogmb)/dpmax
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif

!             If ma is large in magnitude, use more guard digits.

      iextra = min(max(int(mxy(1)%mp(2)), 0), int(2.0+qx%alogmx/qx%alogmb))
      if (mxy(1)%mp(2) >= qx%mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
      endif
      call fmndig(qx%ndig + iextra, qx)
      n_acc = nint(qx%ndig*qx%alogm2)

!             Check for special cases.

      if (mxy(1)%mp(3) == 0 .or. mxy(1)%mp(2) == qx%mexpun) then
          call fmunknown(mresult, qx)
          qx%kflag = -4
          retry = .false.
          return
      else if (mxy(1)%mp(2) > qx%ndig) then
          call fmexp(mxy(1), mxy(2), qx)
          qx%ndige = 0
          call fmdiv(mxy(2), mxy(1), mresult, qx)
          retry = .false.
          return
      endif

!             Determine which method to use.

!             nmethd = 1 means use the convergent series,
!                    = 2 means use the asymptotic series,
!                    = 3 means use the continued fraction expansion.

      nmethd = 1
      if (kflagx /= 0) then
          if (mxy(1)%mp(2) <= 0) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          y = (qx%ndig+3)*qx%dlogmb
          if (abs(x) > y+(qx%dlogtp+log(y))/2.0d0) nmethd = 2
          if (x < 0.0d0 .and. nmethd == 1) then
              if (x <= -14.3d0-0.275d0*y) nmethd = 3
          endif
      endif

      if (nmethd == 1) then
          call fmei_m1(mxy, mresult, numtry, kflagx, n_acc, x, qx)
      else if (nmethd == 2) then
          call fmei_m2(mxy, mresult, ndsave, numtry, kflagx, n_acc, x, qx)
      else if (nmethd == 3) then
          call fmei_m3(mxy, mresult, n_acc, qx)
      endif

      return
      end subroutine fmei_m

      subroutine fmei_m1(mxy, mresult, numtry, kflagx, n_acc, x, qx)

!  Method 1 for computing ln(gamma(ma)).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(17), mresult
      integer :: numtry, kflagx, n_acc
      double precision :: x
      intent (in) :: numtry, kflagx, x
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      integer :: iextra, j, j2, k, kl, ndsav1, nterm
      double precision :: xe
      type(multi) :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 1.  Use the x**n/(n*n!) series.

      iextra = min(max(int(mxy(1)%mp(2)), 0), int(2.0+qx%alogmx/qx%alogmb))
      if (kflagx == 0) then
          if (x < 0) then
              iextra = int(2.0d0*abs(x)/qx%dlogmb)
          else if (numtry <= 0 .and. qx%ncall <= 1) then
              call fmndig(qx%ndig - iextra - 1, qx)
              iextra = 0
          else if (numtry <= 0 .and. qx%ncall > 1) then
              call fmndig(qx%ndig - iextra, qx)
              iextra = 0
          endif
      endif
      if (iextra > 0) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
      endif
      call fmndig(qx%ndig + iextra, qx)
      n_acc = nint(qx%ndig*qx%alogm2)

      if (kflagx == 0) then
          j2 = int(0.63*sqrt(fmnterms(abs(x), 1, 0, 0, 1, qx)) - 1.4)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums.

      call fmi2m(1, mxy(6), qx)
      call fmeq(mxy(6), mjsums(1), qx)
      nterm = 1
      do j = 2, j2
         nterm = nterm + 1
         call fmcsdivi_r1(mxy(6), nterm, qx)
         call fmcsdivi(mxy(6), nterm, mjsums(j), qx)
      enddo

      call fmovun_xe(mxy(1), xe, qx)
      if (xe < -qx%ndig) then
          kl = 0
      else
          kl = 1
          call fmipwr(mxy(1), j2, mxy(5), qx)
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(6), mxy(5), qx)
         do j = 1, j2
            nterm = nterm + 1
            call fmcsdivi_r1(mxy(6), nterm, qx)
            call fmcsdivi(mxy(6), nterm, mxy(4), qx)
            call fmndig(ndsav1, qx)
            call fmcsaddnn_r1(mjsums(j), mxy(4), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            call fmndig(ndsav1 - int(mjsums(j)%mp(2)-mxy(4)%mp(2)), qx)
            call fmndig(min(ndsav1, qx%ndig), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         enddo
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmcsnsums(j2, mjsums, qx)
      call fmi2m(0, mxy(16), qx)
      call fmi2m(0, mxy(17), qx)
      call fmeq(mxy(1), mxy(12), qx)
      do j = 1, j2
         call fmmpy(mxy(12), mjsums(j), mxy(3), qx)
         if (mxy(3)%mp(1) > 0) then
             call fmadd_r1(mxy(16), mxy(3), qx)
         else
             call fmadd_r1(mxy(17), mxy(3), qx)
         endif
         call fmmpy_r1(mxy(12), mxy(1), qx)
      enddo
      call fmeulr(mxy(3), qx)
      qx%ndgeul = 0
      call fmadd_r1(mxy(16), mxy(3), qx)
      call fmabs(mxy(1), mxy(2), qx)
      call fmln(mxy(2), mxy(11), qx)
      qx%ndigli = 0
      if (mxy(11)%mp(1) > 0) then
          call fmadd_r1(mxy(16), mxy(11), qx)
      else
          call fmadd_r1(mxy(17), mxy(11), qx)
      endif
      call fmadd(mxy(16), mxy(17), mxy(10), qx)
      call fmcancel(mxy(16), mxy(17), mjsums(1), k, qx)
      n_acc = n_acc - k

      call fmeq(mxy(10), mresult, qx)

      return
      end subroutine fmei_m1

      subroutine fmei_m2(mxy, mresult, ndsave, numtry, kflagx, n_acc, x, qx)

!  Method 2 for computing ln(gamma(ma)).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(17), mresult
      integer :: ndsave, numtry, kflagx, n_acc
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      integer :: j, j2, jterms, kl, ndsav1, nterm, nterms
      type(multi) :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 2.  Use the n!/x**n series.

      nterms = int(intmax/10)
      if (kflagx == 0) then
          j2 = int(0.38*sqrt(fmnterms(abs(x), 1, 0, 0, 0, qx)) + 0.6)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      if (kflagx == 0) then
          if (x > 0 .and. numtry <= 0 .and. qx%ncall <= 1) then
              call fmndig(max(ndsave+qx%ngrd52, qx%ndig-2), qx)
          endif
      endif
      n_acc = nint(qx%ndig*qx%alogm2)
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums.

      call fmi2m(1, mxy(6), qx)
      call fmdiv(mxy(6), mxy(1), mxy(15), qx)
      call fmeq(mxy(6), mjsums(1), qx)
      nterm = 1
      do j = 2, j2
         if (nterm >= 2) call fmcsmpyi_r1(mxy(6), nterm, qx)
         call fmeq(mxy(6), mjsums(j), qx)
         nterm = nterm + 1
      enddo
      if (mxy(15)%mp(2)+mxy(6)%mp(2) >= -qx%ndig-3) then
          call fmipwr(mxy(15), j2, mxy(5), qx)
          kl = 1

          do jterms = 1, nterms
             call fmcsmpy_r1(mxy(6), mxy(5), qx)
             do j = 1, j2
                call fmcsmpyi_r1(mxy(6), nterm, qx)
                call fmndig(ndsav1, qx)
                call fmcsaddnn_r1(mjsums(j), mxy(6), qx)
                if (qx%kflag /= 0) then
                    kl = 0
                    exit
                endif
                call fmndig(ndsav1 - int(mjsums(j)%mp(2)-mxy(6)%mp(2)), qx)
                call fmndig(min(ndsav1, qx%ndig), qx)
                if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                nterm = nterm + 1
             enddo
             if (kl == 0) exit
             if (jterms == nterms) then
                 call fmunknown(mresult, qx)
                 return
             endif
          enddo
      endif

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmcsnsums(j2, mjsums, qx)
      call fmeq(mjsums(j2), mxy(5), qx)
      do j = 2, j2
         call fmcsmpy_r1(mxy(5), mxy(15), qx)
         call fmadd_r1(mxy(5), mjsums(j2-j+1), qx)
      enddo
      call fmmpy(mxy(15), mxy(5), mxy(13), qx)
      call fmexp(mxy(1), mxy(11), qx)
      qx%ndige = 0
      if (mxy(11)%mp(2) == qx%mexpov .and. mxy(1)%mp(1) > 0) then
          call fmeq(mxy(11), mresult, qx)
          return
      else
          call fmmpy(mxy(11), mxy(13), mxy(10), qx)
      endif

      call fmndig(ndsav1, qx)

      call fmeq(mxy(10), mresult, qx)

      return
      end subroutine fmei_m2

      subroutine fmei_m3(mxy, mresult, n_acc, qx)

!  Method 3 for computing ln(gamma(ma)).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(17), mresult
      integer :: n_acc
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      integer :: j, jextra, kflag1, ndsav1, ndsav2, nterms

!             Method 3.  Use the continued fraction expansion.

!             mxy(14) is the current approximation.
!             mxy(10) is the term in the sum, s(k).
!             mxy(8), mxy(9) are the latest denominators, q(k-1) and q(k).


      nterms = int(intmax/10)
      ndsav1 = qx%ndig
      jextra = max(1, int(5.76/qx%alogmb + 1.0))
      if (qx%ndig+jextra > ndsav1) then
          call fmequ_r1(mxy(1), ndsav1, ndsav1+jextra, qx)
      endif
      call fmndig(qx%ndig + jextra, qx)
      n_acc = nint(qx%ndig*qx%alogm2)
      call fmeq(mxy(1), mxy(13), qx)
      call fmnegate(mxy(13), qx)
      call fmi2m(1, mxy(8), qx)
      call fmequ(mxy(13), mxy(9), ndsav1, qx%ndig, qx)
      call fmi2m(1, mxy(2), qx)
      call fmdiv(mxy(2), mxy(13), mxy(10), qx)
      call fmeq(mxy(10), mxy(14), qx)

!             Method 3 continued fraction loop.

      ndsav2 = qx%ndig
      do j = 1, nterms
         call fmcsmpyi(mxy(8), j, mxy(6), qx)
         call fmeq(mxy(9), mxy(7), qx)
         call fmcsadd_r1(mxy(7), mxy(6), qx)
         call fmcsmpy_r1(mxy(10), mxy(6), qx)
         call fmcsdiv(mxy(10), mxy(7), mxy(11), qx)
         call fmeq(mxy(11), mxy(10), qx)
         call fmnegate(mxy(10), qx)
         call fmndig(ndsav2, qx)
         call fmcsadd_r1(mxy(14), mxy(10), qx)
         kflag1 = qx%kflag
         call fmeq(mxy(9), mxy(8), qx)
         call fmeq(mxy(7), mxy(9), qx)
         call fmndig(min(ndsav2, max(qx%ngrd22, ndsav2-int(mxy(14)%mp(2)-mxy(10)%mp(2)))), qx)
         if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         call fmcsmpyi(mxy(8), j, mxy(6), qx)
         call fmeq(mxy(9), mxy(3), qx)
         call fmcsmpy_r1(mxy(3), mxy(13), qx)
         call fmeq(mxy(3), mxy(7), qx)
         call fmcsadd_r1(mxy(7), mxy(6), qx)
         call fmcsmpy_r1(mxy(10), mxy(6), qx)
         call fmcsdiv(mxy(10), mxy(7), mxy(11), qx)
         call fmeq(mxy(11), mxy(10), qx)
         call fmnegate(mxy(10), qx)
         call fmndig(ndsav2, qx)
         call fmcsadd_r1(mxy(14), mxy(10), qx)

!             Check for convergence.

         if (kflag1 == 1 .and. qx%kflag == 1) then
             exit
         endif
         call fmeq(mxy(9), mxy(8), qx)
         call fmeq(mxy(7), mxy(9), qx)
         call fmndig(min(ndsav2, max(qx%ngrd22, ndsav2-int(mxy(14)%mp(2)-mxy(10)%mp(2)))), qx)
         if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         if (j == nterms) then
             call fmunknown(mresult, qx)
             return
         endif
      enddo

      call fmequ_r1(mxy(14), qx%ndig, ndsav1, qx)
      call fmndig(ndsav1, qx)
      call fmexp(mxy(1), mxy(15), qx)
      qx%ndige = 0
      call fmmpy(mxy(14), mxy(15), mxy(10), qx)
      call fmnegate(mxy(10), qx)

      call fmeq(mxy(10), mresult, qx)

      return
      end subroutine fmei_m3

      subroutine fmei_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = ln(gamma(ma)).

!  kresult = 1 is returned if a special case gives the value of ln(gamma(ma)).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(17), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j, k
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMEI     '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif
      if (abs(malocal%mp(2)) >= qx%mexpov) then
          k = 0
          j = qx%ntrace
          qx%ntrace = 0
          if (malocal%mp(5) < 0) then
              if (malocal%mp(4) < 0) then
                  call fmabs(malocal, mxy(1), qx)
                  call fmln(mxy(1), mxy(2), qx)
                  qx%ndigli = 0
                  call fmeulr(mxy(3), qx)
                  qx%ndgeul = 0
                  call fmadd_r2(mxy(2), mxy(3), qx)
                  call fmadd_r2(malocal, mxy(3), qx)
                  call fmsqr(malocal, mxy(2), qx)
                  call fmdivi_r1(mxy(2), 4, qx)
                  call fmadd_r2(mxy(2), mxy(3), qx)
                  if (qx%kflag == 1) k = 1
              else
                  call fmi2m(1, mxy(1), qx)
                  call fmdiv(mxy(1), malocal, mxy(2), qx)
                  call fmsqr(mxy(2), mxy(3), qx)
                  call fmadd_r2(mxy(2), mxy(3), qx)
                  if (qx%kflag == 1) k = 1
                  call fmexp(malocal, mxy(1), qx)
                  qx%ndige = 0
                  if (malocal%mp(4) == mxy(1)%mp(4)) then
                      k = 1
                      call fmeq(malocal, mxy(3), qx)
                  else
                      call fmmpy_r2(mxy(1), mxy(3), qx)
                  endif
              endif
          endif
          qx%ntrace = j
          if (k == 1) then
              call fmeq(mxy(3), mresult, qx)
              kresult = 1
              return
          endif
      endif

      return
      end subroutine fmei_sc

      subroutine fmen(ival, ma, mb, qx)

!  mb = exponential integral(ival,ma)

!  Integral from 1 to infinity of e**(-ma*t) / t**ival  dt.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ival, ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(14), mresult, mretry

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmen_sc(ival, ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      n_acc = nint(qx%ndig*qx%alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmen_m(ival, ma, mxy, mresult, ndsave, numtry, n_acc, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
         if (.not. retry) then
             call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmen

      subroutine fmen_m(ival, ma, mxy, mresult, ndsave, numtry, n_acc, qx)

!  Method selection for computing exponential integral(ival,ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(14), mresult
      integer :: ival, ndsave, numtry, n_acc
      intent (in) :: ival, ma, ndsave, numtry
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      double precision :: d, x, xe
      integer :: k, kflagx, nmethd
      logical, external :: fmcomp

      n_acc = nint(qx%ndig*qx%alogm2)
      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

!             Special cases.

      if (ival > 0 .and. (mxy(1)%mp(1) < 0 .or. mxy(1)%mp(3) == 0)) then
          if (ival > 1 .and. mxy(1)%mp(3) == 0) then
              call fmi2m(1, mxy(2), qx)
              call fmdivi(mxy(2), ival-1, mresult, qx)
          else
              call fmunknown(mresult, qx)
          endif
          return
      endif
      if (ival <= 0 .and. mxy(1)%mp(3) == 0) then
          call fmunknown(mresult, qx)
          return
      endif
      if (mxy(1)%mp(2) == qx%mexpov) then
          if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          if (mxy(1)%mp(1) < 0) then
              call fmoverflow(-1, mxy(12), qx)
              mxy(12)%mp(4) = huge(qx%mbase)/d
              mxy(12)%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
              qx%kflag = -5
          else
              call fmunderflow(1, mxy(12), qx)
              mxy(12)%mp(4) = -huge(qx%mbase)/d
              mxy(12)%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
              qx%kflag = -6
          endif
          call fmeq(mxy(12), mresult, qx)
          return
      endif
      call fmovun_xe(mxy(1), xe, qx)
      if (ival == 0) then
          call fmi2m(-1000, mxy(3), qx)
          if (fmcomp(mxy(1), '>=', mxy(3), qx)) then
              call fmeq(mxy(1), mxy(3), qx)
              call fmnegate(mxy(3), qx)
              call fmexp(mxy(3), mxy(4), qx)
              qx%ndige = 0
              call fmdiv(mxy(4), mxy(1), mresult, qx)
          else
              call fmeq(mxy(1), mxy(3), qx)
              call fmnegate(mxy(3), qx)
              call fmln(mxy(3), mxy(4), qx)
              qx%ndigli = 0
              call fmsub(mxy(3), mxy(4), mxy(5), qx)
              call fmexp(mxy(5), mresult, qx)
              qx%ndige = 0
              call fmnegate(mresult, qx)
          endif
          return
      else if (ival == 1 .and. xe < -ndsave) then
          call fmeulr(mxy(11), qx)
          qx%ndgeul = 0
          call fmln(mxy(1), mxy(10), qx)
          qx%ndigli = 0
          call fmadd(mxy(10), mxy(11), mxy(4), qx)
          call fmsub(mxy(1), mxy(4), mresult, qx)
          return
      else if (ival == 2 .and. (xe < -ndsave .or. mxy(1)%mp(3) == 0)) then
          if (xe < -ndsave*2 .or. mxy(1)%mp(3) == 0) then
              call fmi2m(1, mresult, qx)
          else
              call fmeulr(mxy(11), qx)
              qx%ndgeul = 0
              call fmln(mxy(1), mxy(10), qx)
              qx%ndigli = 0
              call fmadd(mxy(10), mxy(11), mxy(4), qx)
              call fmi2m(1, mxy(3), qx)
              call fmsub(mxy(4), mxy(3), mxy(2), qx)
              call fmmpy(mxy(2), mxy(1), mxy(5), qx)
              call fmadd(mxy(3), mxy(5), mresult, qx)
          endif
          return
      else if (ival > 2 .and. (xe < -ndsave .or. mxy(1)%mp(3) == 0)) then
          call fmi2m(1, mxy(3), qx)
          call fmdivi(mxy(3), ival-1, mxy(4), qx)
          call fmdivi(mxy(1), ival-2, mxy(5), qx)
          call fmsub(mxy(4), mxy(5), mresult, qx)
          return
      endif

!             Determine which method to use.

!             nmethd = 1 use the convergent series,
!                    = 2 use the continued fraction expansion,
!                    = 3 for small positive ival use a recurrence involving exponentialei,
!                    = 4 for small negative ival use a recurrence involving exp,
!                    = 5 use incomplete gamma.

      call fmm2dp(mxy(1), x, qx)
      kflagx = qx%kflag
      call fmovun_xe(mxy(1), xe, qx)
      if (qx%kflag /= 0 .and. xe < 0) then
          x = (10.0d0*qx%dlogmb)/dpmax
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif
      if (qx%kflag /= 0 .and. xe > 0) then
          x = dpmax
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif
      nmethd = 5
      k = 0
      if (ival == 1 .and. abs(x) >= 1) k = 10
      if (ival > 0) then
          if (abs(x) < (qx%ndig*qx%alogmb)/(5.5 + 0.00095*ival) + k +                                  &
              (qx%ndig*qx%alogmb)**2 * 1.0e-4 * (4.22 + log(real(ival)))/(24 + log(real(ival))) .and.  &
              abs(xe) < qx%mexpov .and. mxy(1)%mp(3) /= 0) then
              nmethd = 1
          else if (ival < max(2, int((qx%ndig+3)*qx%alogmb/32)) .and.  &
                   abs(x) > (qx%ndig+5)*qx%alogmb + log(6.2832*(qx%ndig+5)*qx%alogmb)/2) then
              nmethd = 3
          else
              nmethd = 2
          endif
      else if (ival < 0 .and. ival >= -10 .and. abs(x) > 1 .and.  &
               abs(xe) < qx%mexpov .and. mxy(1)%mp(3) /= 0) then
          nmethd = 2
      else if (ival < 0 .and. ival >= -10 .and. abs(x) <= 1 .and.  &
               abs(xe) < qx%mexpov .and. mxy(1)%mp(3) /= 0) then
          nmethd = 4
      else if (ival < 0 .and. ival > -500 .and.  &
               abs(xe) < qx%mexpov .and. mxy(1)%mp(3) /= 0) then
          nmethd = 4
      endif
      if (ival == 1 .and. k == 10 .and. nmethd == 1) nmethd = 3
      if (mxy(1)%mp(2) == qx%mexpov) nmethd = 3

      if (nmethd == 1) then
          call fmen_m1(mxy, ival, mresult, numtry, kflagx, x, qx)
      else if (nmethd == 2) then
          call fmen_m2(mxy, ival, ndsave, mresult, numtry, kflagx, x, qx)
      else if (nmethd == 3) then
          call fmen_m3(mxy, ival, mresult, n_acc, kflagx, x, qx)
      else if (nmethd == 4) then
          call fmen_m4(mxy, ival, mresult, qx)
      else if (nmethd == 5) then
          call fmen_m5(mxy, ival, mresult, qx)
      endif

      return
      end subroutine fmen_m

      subroutine fmen_m1(mxy, ival, mresult, numtry, kflagx, x, qx)

!  Method 1 for computing exponential integral(ival,ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(14), mresult
      integer :: ival, numtry, kflagx
      double precision :: x
      intent (in) :: ival, numtry, kflagx, x
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: xe
      integer :: iextra, j, j2, jterm, k, kl, ndsav1, nterm
      type(multi) :: mjsums(ljsums)
      type(multi) :: m_euler_harmonic
      integer :: ival_e_h, ndig_e_h
      real (kind(1.0d0)) :: mbs_e_h
      double precision, external :: fmnterms
      ndig_e_h = 0
      mbs_e_h = 0
      ival_e_h = 0

!             Method 1.  Use the (-x)**n/((n-ival+1)*n!) series.

      iextra = 0
      if (kflagx == 0) then
          if (x > 0) then
              iextra = int(2.0d0*abs(x)/qx%dlogmb)
          else if (numtry <= 0) then
              call fmndig(qx%ndig - iextra - 1, qx)
              iextra = 0
          endif
      endif
      if (iextra > 0) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
      endif
      call fmndig(qx%ndig + iextra, qx)

      if (kflagx == 0) then
          j2 = int(0.68*sqrt(fmnterms(abs(x), 1, 0, 0, 1, qx)) + 0.7)
          j2 = max(1, min(ljsums, j2))
      else
          j2 = 1
      endif
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums.

      call fmi2m(1, mxy(6), qx)
      jterm = 0
      nterm = ival - 1
      do j = 1, j2
         if (j > 2) call fmcsdivi_r1(mxy(6), jterm, qx)
         if (nterm /= 0) then
             call fmcsdivi(mxy(6), nterm, mjsums(j), qx)
         else
             if (ival == ival_e_h .and. qx%ndig <= ndig_e_h .and. mbs_e_h == qx%mbase) then
                 call fmeq(m_euler_harmonic, mxy(2), qx)
                 call fmln(mxy(1), mxy(3), qx)
                 qx%ndigli = 0
                 call fmsub_r1(mxy(2), mxy(3), qx)
                 call fmmpy(mxy(6), mxy(2), mjsums(j), qx)
             else
                 call fmeuler(mxy(2), qx)
                 call fmnegate(mxy(2), qx)
                 call fmi2m(1, mxy(3), qx)
                 do k = 1, ival-1
                    call fmcsdivi(mxy(3), k, mxy(4), qx)
                    call fmadd_r1(mxy(2), mxy(4), qx)
                 enddo
                 ival_e_h = ival
                 ndig_e_h = qx%ndig
                 mbs_e_h = qx%mbase
                 call fmeq(mxy(2), m_euler_harmonic, qx)
                 call fmln(mxy(1), mxy(3), qx)
                 qx%ndigli = 0
                 call fmsub_r1(mxy(2), mxy(3), qx)
                 call fmmpy(mxy(6), mxy(2), mjsums(j), qx)
             endif
         endif
         jterm = jterm + 1
         nterm = nterm - 1
      enddo
      call fmovun_xe(mxy(1), xe, qx)
      if (xe < -qx%ndig) then
          kl = 0
      else
          kl = 1
          call fmeq(mxy(1), mxy(2), qx)
          call fmnegate(mxy(2), qx)
          call fmipwr(mxy(2), j2, mxy(5), qx)
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(6), mxy(5), qx)
         do j = 1, j2
            call fmcsdivi_r1(mxy(6), jterm, qx)
            if (nterm /= 0) then
                call fmcsdivi(mxy(6), nterm, mxy(4), qx)
            else
                if (ival == ival_e_h .and. qx%ndig <= ndig_e_h .and. mbs_e_h == qx%mbase) then
                    call fmeq(m_euler_harmonic, mxy(7), qx)
                    call fmln(mxy(1), mxy(3), qx)
                    qx%ndigli = 0
                    call fmsub_r1(mxy(7), mxy(3), qx)
                    call fmmpy(mxy(6), mxy(7), mxy(4), qx)
                else
                    call fmeuler(mxy(7), qx)
                    call fmnegate(mxy(7), qx)
                    call fmi2m(1, mxy(3), qx)
                    do k = 1, ival-1
                       call fmcsdivi(mxy(3), k, mxy(4), qx)
                       call fmadd_r1(mxy(7), mxy(4), qx)
                    enddo
                    ival_e_h = ival
                    ndig_e_h = qx%ndig
                    mbs_e_h = qx%mbase
                    call fmeq(mxy(7), m_euler_harmonic, qx)
                    call fmln(mxy(1), mxy(3), qx)
                    qx%ndigli = 0
                    call fmsub_r1(mxy(7), mxy(3), qx)
                    call fmmpy(mxy(6), mxy(7), mxy(4), qx)
                endif
            endif
            call fmndig(ndsav1, qx)
            call fmadd_r1(mjsums(j), mxy(4), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            call fmndig(ndsav1 - int(mjsums(j)%mp(2) - mxy(4)%mp(2)), qx)
            call fmndig(min(ndsav1, qx%ndig), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
            jterm = jterm + 1
            nterm = nterm - 1
         enddo
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmeq(mjsums(j2), mxy(5), qx)
      do j = 2, j2
         call fmcsmpy_r1(mxy(5), mxy(2), qx)
         call fmadd_r1(mxy(5), mjsums(j2-j+1), qx)
      enddo
      call fmeq(mxy(5), mxy(12), qx)

      call fmeq(mxy(12), mresult, qx)

      return
      end subroutine fmen_m1

      subroutine fmen_m2(mxy, ival, ndsave, mresult, numtry, kflagx, x, qx)

!  Method 2 for computing exponential integral(ival,ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(14), mresult
      integer :: ival, ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ival, ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: xe
      integer :: iextra, j, ndsav1, ndsav2, nterms

!             Method 2.  use the continued fraction expansion.

!             mxy(14) is the current approximation.
!             mxy(10) is the term in the sum, s(k).
!             mxy(8), mxy(9) are the latest denominators, q(k-1) and q(k).

      if (kflagx == 0) then
          if (x > 0 .and. ival > 0 .and. numtry <= 0 .and. qx%ncall <= 1) then
              call fmndig(max(ndsave+qx%ngrd52, qx%ndig-1), qx)
          endif
      endif
      call fmi2m(-ival, mxy(2), qx)
      call fmsub(mxy(2), mxy(1), mxy(3), qx)
      call fmnint(mxy(3), mxy(2), qx)
      call fmsub(mxy(3), mxy(2), mxy(4), qx)
      if (mxy(4)%mp(3) == 0) then
          if (ival <= 0) then
              if (abs(ival) <= 100) then
                  call fmen_m4(mxy, ival, mresult, qx)
                  return
              else
                  call fmen_m5(mxy, ival, mresult, qx)
              endif
          endif
      endif
      iextra = 0
      if (mxy(2)%mp(1) >= 0) then
          if (mxy(4)%mp(2) < 0) iextra = -mxy(4)%mp(2)
          if (abs(mxy(4)%mp(2)) >= qx%mexpov) iextra = 0
      endif
      if (ival < 0) then
          if (abs(x) > 1/sqrt(dpmax) .and. abs(x) < sqrt(dpmax)) then
              j = (log(6.2831853d0) + log(dble(-ival)) - ival*(log(dble(-ival))-1) -  &
                  (1-ival)*log(abs(x))) / qx%dlogmb + qx%ngrd21
          else
              call fmovun_xe(mxy(1), xe, qx)
              j = (log(6.2831853d0) + log(dble(-ival)) - ival*(log(dble(-ival))-1)) / qx%dlogmb  &
                  - dble(1-ival)*(xe-1)
          endif
          iextra = max(iextra, j)
      endif
      if (iextra > 0) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
      endif
      call fmndig(qx%ndig + iextra, qx)
      ndsav1 = qx%ndig
      call fmi2m(0, mxy(8), qx)
      call fmi2m(1, mxy(9), qx)
      call fmi2m(0, mxy(10), qx)
      call fmi2m(0, mxy(14), qx)
      nterms = int(intmax/10)

!             Continued fraction loop.

      ndsav2 = qx%ndig
      do j = 1, nterms
         if (mod(j, 2) == 1) then
             call fmeq(mxy(1), mxy(11), qx)
             call fmcsmpy_r1(mxy(11), mxy(9), qx)
             call fmcsmpyi(mxy(8), (j-1)/2, mxy(12), qx)
         else
             call fmeq(mxy(9), mxy(11), qx)
             call fmcsmpyi(mxy(8), ival+(j-2)/2, mxy(12), qx)
         endif
         if (j == 1) then
             call fmeq(mxy(11), mxy(7), qx)
             call fmexp(mxy(1), mxy(5), qx)
             qx%ndige = 0
             call fmovun_xe(mxy(5), xe, qx)
             if (xe >= qx%mexpov) then
                 call fmen_m5(mxy, ival, mresult, qx)
                 return
             endif
             call fmmpy(mxy(1), mxy(5), mxy(6), qx)
             call fmi2m(1, mxy(2), qx)
             call fmdiv(mxy(2), mxy(6), mxy(10), qx)
         else
             call fmadd(mxy(11), mxy(12), mxy(7), qx)
             call fmcsmpy_r1(mxy(10), mxy(12), qx)
             call fmcsdiv(mxy(10), mxy(7), mxy(3), qx)
             call fmeq(mxy(3), mxy(10), qx)
             call fmnegate(mxy(10), qx)
         endif
         call fmeq(mxy(9), mxy(8), qx)
         call fmeq(mxy(7), mxy(9), qx)
         call fmndig(ndsav2, qx)
         call fmcsadd_r1(mxy(14), mxy(10), qx)

!             Check for convergence.

         if (qx%kflag == 1 .and. j > 1) then
             exit
         endif
         call fmndig(min(ndsav2, max(qx%ngrd22, ndsav2-int(mxy(14)%mp(2)-mxy(10)%mp(2)))), qx)
         if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         if (j == nterms) then
             call fmunknown(mresult, qx)
             return
         endif
      enddo

      call fmeq(mxy(14), mxy(12), qx)
      call fmndig(ndsav1, qx)
      if (mxy(12)%mp(2) == qx%munkno .and. mxy(12)%mp(5) >= 0) then
          call fmen_m5(mxy, ival, mresult, qx)
          return
      endif

      call fmeq(mxy(12), mresult, qx)

      return
      end subroutine fmen_m2

      subroutine fmen_m3(mxy, ival, mresult, n_acc, kflagx, x, qx)

!  Method 3 for computing exponential integral(ival,ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(14), mresult
      integer :: ival, n_acc, kflagx
      double precision :: x
      intent (in) :: ival, kflagx, x
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      integer :: iextra, j, k

!             Method 3.  For small positive ival use a recurrence involving ExponentialEi.

      if (mxy(1)%mp(1) < 0) then
          call fmunknown(mxy(12), qx)
          qx%kflag = -4
      else if (ival == 1) then
          call fmeq(mxy(1), mxy(3), qx)
          call fmnegate(mxy(3), qx)
          call fmei(mxy(3), mxy(12), qx)
          call fmnegate(mxy((12)), qx)
      else
          iextra = 0
          if (kflagx == 0) then
              iextra = int(ival/2.25d0*(log(abs(x))-1.1d0*(log(dble(ival))-1.4d0))*qx%dlogtn/qx%dlogmb)
              iextra = max(0, iextra)
          endif
          if (abs(mxy(1)%mp(2)) >= qx%mexpov) iextra = 0
          if (iextra > 0) then
              call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
          endif
          call fmndig(qx%ndig + iextra, qx)
          n_acc = nint(qx%ndig*qx%alogm2)
          call fmeq(mxy(1), mxy(3), qx)
          call fmnegate(mxy(3), qx)
          call fmei(mxy(3), mxy(4), qx)
          call fmeq(mxy(4), mxy(8), qx)
          call fmipwr(mxy(3), ival-1, mxy(6), qx)
          call fmmpy_r1(mxy(4), mxy(6), qx)
          call fmnegate(mxy((4)), qx)
          if (mxy(4)%mp(1) > 0) then
              call fmeq(mxy(4), mxy(13), qx)
              call fmi2m(0, mxy(14), qx)
          else
              call fmeq(mxy(4), mxy(14), qx)
              call fmi2m(0, mxy(13), qx)
          endif
          if (mxy(8)%mp(2) == qx%mexpun) then
              call fmmpyi(mxy(8), -1, mxy(12), qx)
          else
              call fmexp(mxy(3), mxy(5), qx)
              qx%ndige = 0
              call fmmpy_r1(mxy(6), mxy(5), qx)
              do j = ival-2, 0, -1
                 call fmdiv_r1(mxy(6), mxy(3), qx)
                 if (mxy(6)%mp(1) > 0) then
                     call fmadd_r1(mxy(13), mxy(6), qx)
                 else
                     call fmadd_r1(mxy(14), mxy(6), qx)
                 endif
                 call fmmpyi_r1(mxy(6), ival-1-j, qx)
              enddo
              call fmadd(mxy(13), mxy(14), mxy(12), qx)
              call fmcancel(mxy(13), mxy(14), mxy(12), k, qx)
              n_acc = n_acc - k
              call fmfcti(ival-1, mxy(7), qx)
              call fmdiv_r1(mxy(12), mxy(7), qx)
          endif
      endif
      if (mxy(12)%mp(2) == qx%munkno .and. mxy(12)%mp(5) >= 0) then
          call fmen_m5(mxy, ival, mresult, qx)
          return
      endif

      call fmeq(mxy(12), mresult, qx)

      return
      end subroutine fmen_m3

      subroutine fmen_m4(mxy, ival, mresult, qx)

!  Method 4 for computing exponential integral(ival,ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(14), mresult
      integer :: ival
      intent (in) :: ival
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: j

!             Method 4.  For small negative ival use a recurrence involving exp.

      call fmeq(mxy(1), mxy(3), qx)
      call fmnegate(mxy(3), qx)
      call fmi2m(1, mxy(4), qx)
      call fmi2m(1, mxy(5), qx)
      do j = 1, -ival
         call fmmpy_r1(mxy(5), mxy(1), qx)
         if (j > 1) call fmdivi_r1(mxy(5), j, qx)
         call fmadd_r1(mxy(4), mxy(5), qx)
      enddo
      call fmmpy_r1(mxy(5), mxy(1), qx)
      call fmdiv(mxy(4), mxy(5), mxy(6), qx)
      call fmabs(mxy(6), mxy(7), qx)
      call fmln(mxy(7), mxy(8), qx)
      qx%ndigli = 0
      call fmsub(mxy(8), mxy(1), mxy(5), qx)
      call fmexp(mxy(5), mxy(12), qx)
      qx%ndige = 0
      if (mxy(6)%mp(1) < 0) call fmnegate(mxy(12), qx)
      if (mxy(12)%mp(2) == qx%munkno .and. mxy(12)%mp(5) >= 0) then
          call fmen_m5(mxy, ival, mresult, qx)
          return
      endif

      call fmeq(mxy(12), mresult, qx)

      return
      end subroutine fmen_m4

      subroutine fmen_m5(mxy, ival, mresult, qx)

!  Method 5 for computing exponential integral(ival,ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(14), mresult
      integer :: ival
      intent (in) :: ival
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: n
      logical, external :: fmcomp

!             Method 5.  use incomplete gamma.

      if (mxy(1)%mp(1) < 0) then
          if (ival > 0) then
              call fmunknown(mxy(12), qx)
              qx%kflag = -4
          else
              call fmi2m(-1, mxy(12), qx)
              if (ival == -1 .and. fmcomp(mxy(1), '==', mxy(12), qx)) then
                  call fmi2m(0, mxy(12), qx)
              else
                  n = 1 - ival
                  call fmi2m(n, mxy(12), qx)
                  qx%raise_ndig = 1
                  call fmigm2(mxy(12), mxy(1), mxy(13), qx)
                  qx%raise_ndig = 0
                  call fmeq(mxy(13), mxy(12), qx)
                  n = ival - 1
                  call fmipwr(mxy(1), n, mxy(3), qx)
                  call fmmpy_r2(mxy(3), mxy(12), qx)
              endif
          endif
      else
          n = 1 - ival
          call fmi2m(n, mxy(13), qx)
          qx%raise_ndig = 1
          call fmigm2(mxy(13), mxy(1), mxy(12), qx)
          call fmipwr(mxy(1), ival-1, mxy(13), qx)
          call fmmpy_r2(mxy(13), mxy(12), qx)
          qx%raise_ndig = 0
      endif

      call fmeq(mxy(12), mresult, qx)

      return
      end subroutine fmen_m5

      subroutine fmen_sc(ival, ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = exponential integral(ival,ma).

!  kresult = 1 is returned if a special case gives the value of exponential integral(ival,ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(14), mresult
      integer :: ival, kresult, ndsave
      intent (in) :: ival, ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j, k, kl, krsave, n, nds
      double precision :: xe, ye
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMEN     '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inpi1(ival, ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      k = 0
      n = ival

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (qx%kround /= 1) then
          call fmovun_xe(malocal, xe, qx)
          if (n > 1 .and. xe < -ndsave) k = 1
          if (n <= 0) then
              j = qx%ntrace
              qx%ntrace = 0
              kl = qx%kwarn
              qx%kwarn = 0
              krsave = qx%kround
              qx%kround = 1
              nds = qx%ndig
              call fmndig(qx%ndig + qx%ngrd52, qx)
              call fmequ(malocal, mxy(1), nds, qx%ndig, qx)
              call fmi2m(-n, mxy(2), qx)
              call fmfact(mxy(2), mxy(3), qx)
              call fmipwr(mxy(1), -n+1, mxy(5), qx)
              call fmdiv(mxy(3), mxy(5), mxy(4), qx)
              call fmi2m(-1, mxy(6), qx)
              call fmdivi(mxy(6), -n+1, mxy(5), qx)
              call fmovun_xe(mxy(4), xe, qx)
              call fmovun_xe(mxy(5), ye, qx)
              if (xe - ye > ndsave) k = 1
              qx%ntrace = j
              qx%kwarn = kl
              call fmndig(nds, qx)
              qx%kround = krsave
          endif
          if (malocal%mp(1) < 0 .and. n > 0) k = 0
      endif
      if (qx%kround /= 1 .and. k == 1) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          krsave = qx%kround
          qx%kround = 1
          nds = qx%ndig
          call fmndig(qx%ndig + qx%ngrd52, qx)
          call fmequ(malocal, mxy(1), nds, qx%ndig, qx)
          if (n == 2) then
              call fmi2m(1, mxy(4), qx)
              call fmln(mxy(1), mxy(2), qx)
              qx%ndigli = 0
              call fmeulr(mxy(3), qx)
              qx%ndgeul = 0
              call fmadd(mxy(2), mxy(3), mxy(5), qx)
              call fmmpy(mxy(5), mxy(1), mxy(6), qx)
              call fmsub(mxy(6), mxy(1), mxy(5), qx)
          else if (n >= 3) then
              call fmi2m(1, mxy(2), qx)
              call fmdivi(mxy(2), n-1, mxy(4), qx)
              call fmdivi(mxy(1), -(n-2), mxy(5), qx)
          endif
          call fmovun_xe(mxy(4), xe, qx)
          call fmovun_xe(mxy(5), ye, qx)
          if (xe - ye > ndsave+1) then
              call fmequ(mxy(4), mxy(10), qx%ndig, nds, qx)
              call fmequ(mxy(4), mxy(6), qx%ndig, nds, qx)
              call fmequ(mxy(6), mxy(8), nds, qx%ndig, qx)
              call fmsub(mxy(4), mxy(8), mxy(6), qx)
              if (mxy(6)%mp(3) == 0) then
                  call fmequ(mxy(4), mxy(6), qx%ndig, nds, qx)
                  call fmequ(mxy(5), mxy(7), qx%ndig, nds, qx)
                  call fmndig(nds, qx)
                  qx%kround = krsave
                  call fmadd(mxy(6), mxy(7), mresult, qx)
              else
                  qx%kround = krsave
                  call fmequ(mxy(4), mresult, qx%ndig, nds, qx)
              endif
              qx%kflag = 0
              qx%ntrace = j
              qx%kwarn = k
              call fmndig(nds, qx)
              qx%kround = krsave
              kresult = 1
              return
          endif
          qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          call fmndig(nds, qx)
          qx%kround = krsave
      endif

      return
      end subroutine fmen_sc

      subroutine fmenter0(kovun, mxsave, ndsave, qx)

!  At the start of a function this routine raises precision, and extends the
!  overflow/underflow threshold.

      use fmvals_parallel
      implicit none

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (inout) :: kovun, mxsave, ndsave
      type(fm_settings) :: qx

      integer :: k

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      kovun = 0

!             Increase the working precision.

      qx%ncall = qx%ncall + 1
      ndsave = qx%ndig
      if (qx%ncall == 1) then
          k = max(qx%ngrd52-1, 2)
          call fmndig(max(qx%ndig+k, 3), qx)
          qx%kround1 = qx%kround
      else if (qx%kround1 /= 1) then
          call fmndig(qx%ndig + qx%ngrd22, qx)
      endif

!             Extend the overflow/underflow threshold.

      mxsave = qx%mxexp
      qx%mxexp = qx%mxexp2

      return
      end subroutine fmenter0

      subroutine fmenter1(ma, kovun, mxsave, ndsave, qx)

!  At the start of a function this routine raises precision, and extends the
!  overflow/underflow threshold.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (in) :: ma
      intent (inout) :: kovun, mxsave, ndsave
      type(fm_settings) :: qx

      integer :: k

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      kovun = 0
      if (ma%mp(2) == qx%mexpov .or. ma%mp(2) == qx%mexpun) kovun = 1
      if (ma%mp(2) == qx%munkno) kovun = 2

!             Increase the working precision.

      qx%ncall = qx%ncall + 1
      ndsave = qx%ndig
      if (qx%ncall == 1) then
          k = max(qx%ngrd52-1, 2)
          call fmndig(max(qx%ndig+k, 3), qx)
          qx%kround1 = qx%kround
      else if (qx%kround1 /= 1) then
          call fmndig(qx%ndig + qx%ngrd22, qx)
      endif

!             Extend the overflow/underflow threshold.

      mxsave = qx%mxexp
      qx%mxexp = qx%mxexp2

      return
      end subroutine fmenter1

      subroutine fmenter2(ma, mb, kovun, mxsave, ndsave, qx)

!  At the start of a function this routine raises precision, and extends the
!  overflow/underflow threshold.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (in) :: ma, mb
      intent (inout) :: kovun, mxsave, ndsave
      type(fm_settings) :: qx

      integer :: k

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      kovun = 0
      if (ma%mp(2) == qx%mexpov .or. ma%mp(2) == qx%mexpun) kovun = 1
      if (mb%mp(2) == qx%mexpov .or. mb%mp(2) == qx%mexpun) kovun = 1
      if (ma%mp(2) == qx%munkno) kovun = 2
      if (mb%mp(2) == qx%munkno) kovun = 2

!             Increase the working precision.

      qx%ncall = qx%ncall + 1
      ndsave = qx%ndig
      if (qx%ncall == 1) then
          k = max(qx%ngrd52-1, 2)
          call fmndig(max(qx%ndig+k, 3), qx)
          qx%kround1 = qx%kround
      else if (qx%kround1 /= 1) then
          call fmndig(qx%ndig + qx%ngrd22, qx)
      endif

!             Extend the overflow/underflow threshold.

      mxsave = qx%mxexp
      qx%mxexp = qx%mxexp2

      return
      end subroutine fmenter2

      subroutine fmenter3(ma, mb, mc, kovun, mxsave, ndsave, qx)

!  At the start of a function this routine raises precision, and extends the
!  overflow/underflow threshold.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (in) :: ma, mb, mc
      intent (inout) :: kovun, mxsave, ndsave
      type(fm_settings) :: qx

      integer :: k

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      kovun = 0
      if (ma%mp(2) == qx%mexpov .or. ma%mp(2) == qx%mexpun) kovun = 1
      if (mb%mp(2) == qx%mexpov .or. mb%mp(2) == qx%mexpun) kovun = 1
      if (mc%mp(2) == qx%mexpov .or. mc%mp(2) == qx%mexpun) kovun = 1
      if (ma%mp(2) == qx%munkno) kovun = 2
      if (mb%mp(2) == qx%munkno) kovun = 2
      if (mc%mp(2) == qx%munkno) kovun = 2

!             Increase the working precision.

      qx%ncall = qx%ncall + 1
      ndsave = qx%ndig
      if (qx%ncall == 1) then
          k = max(qx%ngrd52-1, 2)
          call fmndig(max(qx%ndig+k, 3), qx)
          qx%kround1 = qx%kround
      else if (qx%kround1 /= 1) then
          call fmndig(qx%ndig + qx%ngrd22, qx)
      endif

!             Extend the overflow/underflow threshold.

      mxsave = qx%mxexp
      qx%mxexp = qx%mxexp2

      return
      end subroutine fmenter3

      subroutine fmenter_sp(ndsave, qx)

!  Called by the fm special functions, to raise precision more than for the elementary functions.

      use fmvals_parallel
      implicit none

      integer :: ndsave
      intent (in) :: ndsave
      type(fm_settings) :: qx

      integer :: k

!             Increase the working precision.

      if (qx%ncall >= 1 .or. qx%raise_ndig > 0) then
          k = int(qx%ngrd52 + 1 + 0.002*ndsave + (real(ndsave)*qx%alogmt)**0.35/qx%alogmt)
          call fmndig(max(ndsave+k, qx%ndig), qx)
          call fmndig(max(qx%ndig, 3), qx)
      endif

      return
      end subroutine fmenter_sp

      subroutine fmenteri(kovun, mxsave, ndsave, qx)

!  At the start of a function this routine raises precision, and extends the
!  overflow/underflow threshold.

      use fmvals_parallel
      implicit none

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (inout) :: kovun, mxsave, ndsave
      type(fm_settings) :: qx

      integer :: k

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      kovun = 0

!             Increase the working precision.

      qx%ncall = qx%ncall + 1
      ndsave = qx%ndig
      if (qx%ncall == 1) then
          k = max(qx%ngrd52-1, 2)
          call fmndig(max(qx%ndig+k, 3), qx)
          qx%kround1 = qx%kround
      else if (qx%kround1 /= 1) then
          call fmndig(qx%ndig + qx%ngrd22, qx)
      endif

!             Extend the overflow/underflow threshold.

      mxsave = qx%mxexp
      qx%mxexp = qx%mxexp2

      return
      end subroutine fmenteri

      subroutine fmeq(ma, mb, qx)

!  mb = ma

!  This is the standard form of equality, where ma and mb both have precision ndig.
!  Use fmequ for assignments that also change precision.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      integer :: j

      call fmalloc(mb, qx%ndig+2, qx)

!             If the user tries to change precision, one common mistake is to fail to increase the
!             size of all existing variables.  Check to make sure ma has a valid definition.

      if (.not. allocated(ma%mp)) call fminput_error(qx)
      if (size(ma%mp) < max(qx%ndig+2, 5)) call fminput_error(qx)
      if (ma%mp(2) > qx%munkno) then
          qx%kflag = -3
          call fmwarn(qx)
      endif

!             Copy ma to mb.

      do j = 1, qx%ndig+2
         mb%mp(j) = ma%mp(j)
      enddo

!             Check for overflow or underflow.

      if (abs(mb%mp(2)) > qx%mxexp) then
          if (mb%mp(2) /= qx%munkno .or. mb%mp(3) /= 1) then
              qx%ncall = qx%ncall + 1
              call fmtrap(mb, qx)
              qx%ncall = qx%ncall - 1
          endif
          if (mb%mp(2) == qx%munkno .and. qx%kflag /= 1) qx%kflag = -4
      endif

      return
      end subroutine fmeq

      subroutine fmequ(ma, mb, nda, ndb, qx)

!  Set mb (having ndb digits) equal to ma (having nda digits).

!  If mb has less precision than ma the result is rounded to ndb digits.

!  If mb has more precision the result has zero digits padded on the right, and will have
!  its size increased if needed.

      use fmvals_parallel
      implicit none

      integer :: nda, ndb
      type(multi) :: ma, mb
      intent (in) :: ma, nda, ndb
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mbs, mkt
      integer :: j, k, kb, kresult

      if (.not. allocated(ma%mp)) then
          write (qx%kw,*) ' '
          write (qx%kw,*) ' Error in FMEQU.'
          write (qx%kw,*) ' MA is not defined on input.'
          write (qx%kw,*) ' Call stack: '
          write (qx%kw, "(10(3X, A))") (qx%namest(j), j=1, qx%ncall)
          write (qx%kw,*) ' '
          stop
      endif
      call fmalloc(mb, ndb+2, qx)

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

!             If the user tries to change precision, one common mistake is to fail to increase the
!             size of all existing variables.  Check to make sure ma has a valid definition.

      if (.not. allocated(ma%mp)) call fminput_error(qx)
      if (size(ma%mp) < nda+2) call fminput_error(qx)

!             Check for precision in range.

      if (nda < 3 .or. ndb < 3) then
          qx%ncall = qx%ncall + 1
          qx%namest(qx%ncall) = 'FMEQU'
          qx%kflag = -1
          call fmwarn(qx)
          write (qx%kw,                                                    &
                 "(/' The two precisions in FMEQU were NDA =', I19, "  //  &
                  "' NDB =', I19/)"                                        &
                ) nda, ndb
          do j = 2, ndb
             mb%mp(j+2) = 0
          enddo
          qx%kflag = -1
          mb%mp(2) = qx%munkno
          mb%mp(3) = 1
          mb%mp(1) = 1
          qx%ncall = qx%ncall - 1
          return
      endif
      mbs = ma%mp(1)
      mb%mp(1) = mbs

!             Check for special symbols.

      qx%kflag = 0
      if (abs(ma%mp(2)) >= qx%mexpov) then
          k = 2
          if (ma%mp(5) < 0) then
              k = 4
              mb%mp(4) = ma%mp(4)
              mb%mp(5) = ma%mp(5)
          endif
          do j = k, ndb
             mb%mp(j+2) = 0
          enddo
          mb%mp(2) = ma%mp(2)
          mb%mp(3) = ma%mp(3)
          call fmequ2(mb, ndb, qx)
          return
      endif

      if (nda > ndb) then

!               Round ma from nda to ndb digits and return the result in mb.

          call fmequ_m1(ma, mb, nda, ndb, kresult, qx)
          if (kresult > 0) then
              call fmequ2(mb, ndb, qx)
              return
          endif
          mb%mp(ndb+2) = mb%mp(ndb+2) + 1

!             Check whether there was a carry in the rounded digit.

          kb = ndb + 1
          if (kb >= 3) then
              k = kb + 1
              do j = 3, kb
                 k = k - 1
                 if (mb%mp(k+1) < qx%mbase) exit
                 mkt = aint (mb%mp(k+1)/qx%mbase)
                 mb%mp(k) = mb%mp(k) + mkt
                 mb%mp(k+1) = mb%mp(k+1) - mkt*qx%mbase
              enddo
          endif

!             If there is a carry in the first digit then the exponent must be adjusted and the
!             number shifted right.

          if (mb%mp(3) >= qx%mbase) then
              if (kb >= 4) then
                  k = kb + 1
                  do j = 4, kb
                     k = k - 1
                     mb%mp(k+1) = mb%mp(k)
                  enddo
              endif

              mkt = aint (mb%mp(3)/qx%mbase)
              if (kb >= 3) mb%mp(4) = mb%mp(3) - mkt*qx%mbase
              mb%mp(3) = mkt
              mb%mp(2) = mb%mp(2) + 1
          endif

          if (mbs < 0 .and. mb%mp(2) /= qx%munkno .and. mb%mp(3) /= 0) then
              mb%mp(1) = -1
          endif
          call fmequ2(mb, ndb, qx)
          return
      else if (ndb == nda) then

!             ma and mb have the same precision.

          do j = 1, nda+1
             mb%mp(j+1) = ma%mp(j+1)
          enddo
          call fmequ2(mb, ndb, qx)
          return

      else if (ndb > nda) then

!             Extend to ndb digits by padding with zeros.

          do j = 1, nda+1
             mb%mp(j+1) = ma%mp(j+1)
          enddo
          do j = nda+2, ndb+1
             mb%mp(j+1) = 0
          enddo
          call fmequ2(mb, ndb, qx)
      endif

      return
      end subroutine fmequ

      subroutine fmequ2(mb, ndb, qx)

!  Check for overflow or underflow.

      use fmvals_parallel
      implicit none

      type(multi) :: mb
      integer :: ndb
      intent (in) :: ndb
      intent (inout) :: mb
      type(fm_settings) :: qx

      integer :: j, kbovun, kbsign, kxf
      double precision :: d, xe, xf


      if (abs(mb%mp(2)) > qx%mxexp) then
          if (mb%mp(2) /= qx%munkno .or. mb%mp(3) /= 1) then
              if (mb%mp(2) > qx%mxexp+1 .or. mb%mp(2) < -qx%mxexp) then
                  kbovun = 1
                  if (mb%mp(2) < -qx%mxexp) kbovun = -1
                  kbsign = mb%mp(1)
                  kxf = 0
                  xe = mb%mp(4)
                  xf = -mb%mp(5)/maxint
                  if (size(mb%mp) >= 5) then
                      if (mb%mp(5) < 0) then
                          xe = mb%mp(4)
                          xf = -mb%mp(5)/maxint
                          if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
                              d = 1.0d+10
                          else
                              d = 4
                          endif
                          if (xe > huge(qx%mbase)/d) then
                              xe = huge(qx%mbase)/d
                              xf = 1.0d0 - epsilon(1.0d0)
                          else if (xe < -huge(qx%mbase)/d) then
                              xe = -huge(qx%mbase)/d
                              xf = 1.0d0 - epsilon(1.0d0)
                          else if (xe == xe + 1.0d0) then
                              xf = 1.0d0 - epsilon(1.0d0)
                          endif
                          kxf = 1
                      endif
                  endif
                  if (kxf == 0) then
                      xe = mb%mp(2)
                      call fmovun_frac(mb, xf, qx)
                  endif
                  do j = 4, ndb
                     mb%mp(j+2) = 0
                  enddo
                  mb%mp(1) = kbsign
                  mb%mp(2) = qx%mexpov
                  qx%kflag = -5
                  if (kbovun == -1) then
                      mb%mp(2) = qx%mexpun
                      qx%kflag = -6
                  endif
                  mb%mp(3) = 1
                  if (xf >= 1.0d0) then
                      xf = xf / dble(qx%mbase)
                      xe = xe + 1
                      if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
                          d = 1.0d+10
                      else
                          d = 4
                      endif
                      if (xe > huge(qx%mbase)/d) then
                          xe = huge(qx%mbase)/d
                          xf = 1.0d0 - epsilon(1.0d0)
                      else if (xe < -huge(qx%mbase)/d) then
                          xe = -huge(qx%mbase)/d
                          xf = 1.0d0 - epsilon(1.0d0)
                      else if (xe == xe + 1.0d0) then
                          xf = 1.0d0 - epsilon(1.0d0)
                      endif
                  endif
                  mb%mp(4) = xe
                  mb%mp(5) = -xf*maxint
              endif
          endif
          if (mb%mp(2) == qx%munkno .and. qx%kflag /= 1) qx%kflag = -4
      endif

      return
      end subroutine fmequ2

      subroutine fmequ_m1(ma, mb, nda, ndb, kresult, qx)

!  Round ma from nda to ndb digits and return the result in mb.
!  nda > ndb.

      use fmvals_parallel
      implicit none

      integer :: nda, ndb, kresult
      type(multi) :: ma, mb
      intent (in) :: ma, nda, ndb
      intent (inout) :: mb, kresult
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: m2
      integer :: j, l, n1

      kresult = 0
      n1 = ndb + 1
      do j = 1, n1
         mb%mp(j+1) = ma%mp(j+1)
      enddo
      if (qx%kround == -1) then
          if (ma%mp(1) > 0) then
              kresult = 1
              return
          endif
          do j = ndb+2, nda+1
             if (ma%mp(j+1) > 0) return
          enddo
          kresult = 1
          return
      endif
      if (qx%kround == 2) then
          if (ma%mp(1) < 0) then
              kresult = 1
              return
          endif
          do j = ndb+2, nda+1
             if (ma%mp(j+1) > 0) return
          enddo
          kresult = 1
          return
      endif
      if (qx%kround == 0) then
          kresult = 1
          return
      endif

      if (int(qx%mbase-aint (qx%mbase/2)*2) /= 0) then
          m2 = aint (qx%mbase/2)
          do j = ndb+2, nda+1
             if (ma%mp(j+1) /= m2) exit
             if (j == nda+1) return
          enddo
      endif
      l = ndb + 2
      if (2*(ma%mp(l+1)+1) < qx%mbase) then
          kresult = 1
          return
      endif
      m2 = 2
      if (int(qx%mbase-aint (qx%mbase/m2)*m2) == 0) then
          if (2*ma%mp(l+1) < qx%mbase) then
              kresult = 1
              return
          endif
          if (2*ma%mp(l+1) == qx%mbase) then
              if (l <= nda) then
                  do j = l, nda
                     if (ma%mp(j+2) > 0) return
                  enddo
              endif

!                       Round to even.

              if (int(mb%mp(n1+1)-aint (mb%mp(n1+1)/m2)*m2) == 0) then
                  kresult = 1
                  return
              endif
          endif
      else
          if (2*ma%mp(l+1)+1 == qx%mbase) then
              if (l <= nda) then
                  do j = l, nda
                     if (2*(ma%mp(j+2)+1) < qx%mbase) then
                         kresult = 1
                         return
                     endif
                     if (2*ma%mp(j+2) > qx%mbase) return
                  enddo
                  call fmequ2(mb, ndb, qx)
                  return
              endif
          endif
      endif

      return
      end subroutine fmequ_m1

      subroutine fmequ_r1(ma, nda, ndb, qx)

!  Change precision of ma from nda digits on input to ndb digits on output.

!  If ndb is less than nda the result is rounded to ndb digits.

!  If ndb is greater than nda the result has zero digits padded on the right, and will have
!  its size increased if needed.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      type(multi) :: ma_copy
      integer :: nda, ndb
      type(fm_settings) :: qx

      integer :: j
      intent (inout) :: ma
      intent (in) :: nda, ndb

      if (.not. allocated(ma%mp)) then
          write (qx%kw,*) ' '
          write (qx%kw,*) ' Error in FMEQU_R1.'
          write (qx%kw,*) ' MA is not defined on input.'
          write (qx%kw,*) ' Call stack: '
          write (qx%kw, "(10(3X, A))") (qx%namest(j), j=1, qx%ncall)
          write (qx%kw,*) ' '
          stop
      endif

      call fmalloc(ma_copy, max(max(nda, ndb)+2, 5), qx)

      do j = 1, nda+2
         ma_copy%mp(j) = ma%mp(j)
      enddo
      call fmequ(ma_copy, ma, nda, ndb, qx)
      if (ndb < nda) then
          do j = ndb+1, nda
             ma%mp(j+2) = 0
          enddo
      endif

      return
      end subroutine fmequ_r1

      subroutine fmerf(ma, mb, qx)

!  mb = erf(ma)    Error function.

!  2/sqrt(pi) * integral from 0 to ma of e**(-t**2) dt.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(13), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmerf_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call fmerf_m(ma, mxy, mresult, ndsave, retry, qx)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry, qx)
         endif
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmerf

      subroutine fmerf_m(ma, mxy, mresult, ndsave, retry, qx)

!  Method selection for computing erf(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: ndsave
      logical :: retry
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, retry
      type(fm_settings) :: qx

      double precision :: c1, c2, x, xe
      integer :: kflagx, nmethd

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

!             Check for special cases.

      if (mxy(1)%mp(3) == 0) then
          call fmeq(mxy(1), mxy(3), qx)
          call fmerf_r(ma, mxy, mresult, qx)
          return
      endif
      call fmovun_xe(mxy(1), xe, qx)
      if (3*xe <= -qx%ndig) then
          call fmi2m(2, mxy(2), qx)
          call fmpi(mxy(3), qx)
          qx%ndigpi = 0
          call fmsqrt(mxy(3), mxy(4), qx)
          call fmdiv(mxy(2), mxy(4), mxy(3), qx)
          call fmmpy(mxy(3), mxy(1), mxy(4), qx)
          call fmsqr(mxy(1), mxy(2), qx)
          call fmmpy_r2(mxy(1), mxy(2), qx)
          call fmdivi_r1(mxy(2), 3, qx)
          call fmmpy_r2(mxy(3), mxy(2), qx)
          call fmsub(mxy(4), mxy(2), mxy(3), qx)
          mxy(3)%mp(1) = 1
          call fmerf_r(ma, mxy, mresult, qx)
          return
      endif

!             x is a double precision approximation to the input argument to this function.

      mxy(1)%mp(1) = 1
      call fmm2dp(mxy(1), x, qx)
      kflagx = qx%kflag
      if (qx%kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax**0.33d0
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif
      if (qx%kflag /= 0 .and. xe > 0) then
          x = dpmax**0.33d0
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif

!             Determine which method to use.

!             nmethd = 1 use the convergent series,
!                    = 2 use a 2nd convergent series -- slower but no cancellation,
!                    = 3 use a continued fraction expansion.

      c1 = sqrt(qx%dlogmb*(qx%ndig+21))/5
      c2 = (qx%dlogmb*(qx%ndig+6))**0.6d0/4.1d0
      if (xe < 1) then
          nmethd = 1
      else if (abs(x) <= c1) then
          nmethd = 1
      else if (abs(x) <= c2) then
          nmethd = 2
      else
          nmethd = 3
      endif

      if (nmethd == 1) then
          call fmerf_m1(mxy, kflagx, x, qx)
      else if (nmethd == 2) then
          call fmerf_m2(mxy, kflagx, x, qx)
      else if (nmethd == 3) then
          call fmerf_m3(mxy, qx)
      endif
      call fmerf_r(ma, mxy, mresult, qx)

      return
      end subroutine fmerf_m

      subroutine fmerf_m1(mxy, kflagx, x, qx)

!  Method 1 for computing erf(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(13)
      integer :: kflagx
      double precision :: x
      intent (in) :: kflagx, x
      intent (inout) :: mxy
      type(fm_settings) :: qx

      double precision :: xe
      integer :: iextra, j, j2, kl, ndsav1, nterm
      type(multi) :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 1.  Use the (-1)**n x**(2n+1) / n! / (2n+1) series.

!             If ma is large in magnitude, use more guard digits.

      if (kflagx == 0) then
          if (abs(x) > 2 .and. abs(x) < sqrt(huge(x))) then
              iextra = max(int((x*x-1.83-log(2*x*x+1))/qx%alogmb+1), 0)
              if (iextra > 0) then
                  call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
              endif
              call fmndig(qx%ndig + iextra, qx)
          endif
      endif
      if (kflagx == 0) then
          j2 = int(0.66*sqrt(fmnterms(x**2, 1, 0, 0, 1, qx)) - 0.8)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call fmi2m(1, mxy(6), qx)
      call fmi2m(1, mjsums(1), qx)
      do j = 2, j2
         if (nterm > 1) call fmcsdivi_r1(mxy(6), nterm, qx)
         call fmcsdivi(mxy(6), 2*nterm+1, mjsums(j), qx)
         nterm = nterm + 1
      enddo
      call fmovun_xe(mxy(1), xe, qx)
      if (xe < -qx%ndig) then
          kl = 0
      else
          kl = 1
          call fmipwr(mxy(1), 2*j2, mxy(5), qx)
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(6), mxy(5), qx)
         do j = 1, j2
            call fmcsdivi_r1(mxy(6), nterm, qx)
            call fmcsdivi(mxy(6), 2*nterm+1, mxy(4), qx)
            call fmndig(ndsav1, qx)
            call fmcsaddnn_r1(mjsums(j), mxy(4), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            call fmndig(ndsav1 - int(mjsums(j)%mp(2) - mxy(4)%mp(2)), qx)
            call fmndig(min(ndsav1, qx%ndig), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
            nterm = nterm + 1
         enddo
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmcsnsums(j2, mjsums, qx)
      call fmsqr(mxy(1), mxy(4), qx)
      call fmnegate(mxy(4), qx)
      call fmeq(mjsums(j2), mxy(5), qx)
      do j = 2, j2
         call fmcsmpy_r1(mxy(5), mxy(4), qx)
         call fmadd_r1(mxy(5), mjsums(j2-j+1), qx)
      enddo
      call fmcsmpy_r1(mxy(5), mxy(1), qx)

      call fmpi(mxy(4), qx)
      qx%ndigpi = 0
      call fmsqrt(mxy(4), mxy(3), qx)
      call fmcsmpyi(mxy(5), 2, mxy(4), qx)
      call fmdiv_r2(mxy(4), mxy(3), qx)

      return
      end subroutine fmerf_m1

      subroutine fmerf_m2(mxy, kflagx, x, qx)

!  Method 2 for computing erf(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(13)
      integer :: kflagx
      double precision :: x
      intent (in) :: kflagx, x
      intent (inout) :: mxy
      type(fm_settings) :: qx

      double precision :: xe
      integer :: j, j2, kl, ndsav1, nterm
      type(multi) :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 2.  Use the x**(2n+1) * 2**(n+1) / (1*3*5*...*(2n+1)) series.

      mxy(1)%mp(1) = 1
      if (kflagx == 0) then
          j2 = int(0.51*sqrt(fmnterms(2*x, 2, -1, 0, 1, qx)))
      else
          j2 = 1
      endif
      j2 = max(1, min(ljsums, j2))
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call fmcsmpyi(mxy(1), 2, mxy(6), qx)
      call fmeq(mxy(6), mjsums(1), qx)
      do j = 2, j2
         call fmcsmpyi_r1(mxy(6), 2, qx)
         call fmcsdivi_r1(mxy(6), 2*nterm+1, qx)
         call fmeq(mxy(6), mjsums(j), qx)
         nterm = nterm + 1
      enddo
      call fmovun_xe(mxy(1), xe, qx)
      if (xe < -qx%ndig) then
          kl = 0
      else
          kl = 1
          call fmipwr(mxy(1), 2*j2, mxy(5), qx)
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(6), mxy(5), qx)
         do j = 1, j2
            call fmcsmpyi_r1(mxy(6), 2, qx)
            call fmcsdivi_r1(mxy(6), 2*nterm+1, qx)
            call fmndig(ndsav1, qx)
            call fmcsaddnn_r1(mjsums(j), mxy(6), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            call fmndig(ndsav1 - int(mjsums(j)%mp(2)-mxy(6)%mp(2)), qx)
            call fmndig(min(ndsav1, qx%ndig), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
            nterm = nterm + 1
         enddo
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmcsnsums(j2, mjsums, qx)
      call fmsqr(mxy(1), mxy(6), qx)
      call fmeq(mjsums(j2), mxy(5), qx)
      do j = 2, j2
         call fmcsmpy_r1(mxy(5), mxy(6), qx)
         call fmadd_r1(mxy(5), mjsums(j2-j+1), qx)
      enddo

      call fmpi(mxy(4), qx)
      qx%ndigpi = 0
      call fmsqrt(mxy(4), mxy(3), qx)
      call fmdiv_r2(mxy(5), mxy(3), qx)
      call fmexp(mxy(6), mxy(4), qx)
      qx%ndige = 0
      call fmdiv_r1(mxy(3), mxy(4), qx)

      return
      end subroutine fmerf_m2

      subroutine fmerf_m3(mxy, qx)

!  Method 2 for computing erf(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(13)
      intent (inout) :: mxy
      type(fm_settings) :: qx

      integer :: j, ndsav1, ndsav2, nterms

!             Method 3.  Use the continued fraction expansion.

!             mxy(2) is abs(x).
!             mxy(3) is abs(2x).
!             mxy(4) is -x*x.
!             mxy(13) is the current approximation.
!             mxy(10) is the term in the sum, s(k).
!             mxy(8), mxy(9) are the latest denominators, q(k-1) and q(k).

      ndsav1 = qx%ndig
      call fmabs(mxy(1), mxy(2), qx)
      call fmmpyi(mxy(2), 2, mxy(3), qx)
      call fmsqr(mxy(2), mxy(4), qx)
      call fmnegate(mxy(4), qx)
      call fmi2m(0, mxy(8), qx)
      call fmi2m(1, mxy(9), qx)
      call fmi2m(1, mxy(10), qx)
      call fmi2m(1, mxy(13), qx)
      nterms = int(intmax/10)

!             Continued fraction loop.

      ndsav2 = qx%ndig
      do j = 1, nterms
         if (mod(j, 2) == 1) then
             call fmeq(mxy(2), mxy(11), qx)
             call fmcsmpy_r1(mxy(11), mxy(9), qx)
         else
             call fmeq(mxy(3), mxy(11), qx)
             call fmcsmpy_r1(mxy(11), mxy(9), qx)
         endif
         if (j == 1) then
             call fmeq(mxy(11), mxy(7), qx)
             call fmexp(mxy(4), mxy(5), qx)
             qx%ndige = 0
             call fmpi(mxy(12), qx)
             qx%ndigpi = 0
             call fmsqrt(mxy(12), mxy(6), qx)
             call fmdiv(mxy(5), mxy(6), mxy(10), qx)
             call fmdiv_r1(mxy(10), mxy(2), qx)
             call fmnegate(mxy(10), qx)
         else
             call fmcsmpyi(mxy(8), j-1, mxy(12), qx)
             call fmadd(mxy(11), mxy(12), mxy(7), qx)
             call fmcsmpy_r1(mxy(10), mxy(12), qx)
             call fmeq(mxy(10), mxy(5), qx)
             call fmcsdiv(mxy(5), mxy(7), mxy(10), qx)
             call fmnegate(mxy(10), qx)
         endif
         call fmeq(mxy(9), mxy(8), qx)
         call fmeq(mxy(7), mxy(9), qx)
         call fmndig(ndsav2, qx)
         call fmcsadd_r1(mxy(13), mxy(10), qx)

!             Check for convergence.

         if (qx%kflag == 1) then
             exit
         endif
         call fmndig(min(ndsav2, max(qx%ngrd22, ndsav2-int(mxy(13)%mp(2)-mxy(10)%mp(2)))), qx)
         if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         if (j == nterms) then
             call fmunknown(mxy(3), qx)
             return
         endif
      enddo

      call fmeq(mxy(13), mxy(3), qx)
      call fmndig(ndsav1, qx)

      return
      end subroutine fmerf_m3

      subroutine fmerf_r(ma, mxy, mresult, qx)

!  Check non-symmetric rounding for computing erf(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(13), mresult
      intent (in) :: ma
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: krsave
      if (qx%kround /= 1) then
          if (mxy(3)%mp(2) == 1 .and. ma%mp(1) > 0 .and.  &
              (qx%kround == -1 .or. qx%kround == 0)) then
              call fmtiny(mxy(1), qx)
              call fmsub_r1(mxy(3), mxy(1), qx)
          endif
          if (mxy(3)%mp(2) == 1 .and. ma%mp(1) < 0 .and.  &
              (qx%kround == 2 .or. qx%kround == 0)) then
              krsave = qx%kround
              qx%kround = 0
              call fmtiny(mxy(1), qx)
              call fmsub_r1(mxy(3), mxy(1), qx)
              qx%kround = krsave
          endif
          if (qx%kflag == 1) qx%kflag = 0
      endif

      if (ma%mp(1) < 0) then
          call fmnegate(mxy(3), qx)
      endif

      call fmeq(mxy(3), mresult, qx)

      return
      end subroutine fmerf_r

      subroutine fmerf_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = erf(ma).

!  kresult = 1 is returned if a special case gives the value of erf(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMERF    '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine fmerf_sc

      subroutine fmerfc(ma, mb, qx)

!  mb = erfc(ma)    Complimentary Error function.

!  2/sqrt(pi) * integral from ma to infinity of e**(-t**2) dt.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(13), mresult, mretry

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmerfc_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      n_acc = nint(qx%ndig*qx%alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmerfc_m(ma, mxy, mresult, ndsave, numtry, retry, qx)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry, qx)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmerfc

      subroutine fmerfc_m(ma, mxy, mresult, ndsave, numtry, retry, qx)

!  Method selection for computing erfc(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: ndsave, numtry
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry
      type(fm_settings) :: qx

      integer :: nmethd
      double precision :: c1, x, xe

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      call fmi2m(1, mxy(3), qx)
      call fmdivi_r1(mxy(3), 2, qx)

!             Check for special cases.

      if (mxy(1)%mp(3) == 0 .or. mxy(1)%mp(2) == qx%mexpun) then
          call fmi2m(1, mresult, qx)
          retry = .false.
          return
      endif

!             x is a double precision approximation to the input argument to this function.

      call fmm2dp(mxy(1), x, qx)
      call fmovun_xe(mxy(1), xe, qx)
      if (qx%kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax
          if (mxy(1)%mp(1) < 0) x = -x
      endif
      if (qx%kflag /= 0 .and. xe > 0) then
          x = dpmax
          if (mxy(1)%mp(1) < 0) x = -x
      endif

!             Determine which method to use.

!             nmethd = 1 means use 1 - erf(x),
!                    = 2 means use the continued fraction expansion.

      c1 = (qx%dlogmb*(qx%ndig+6))**0.7d0/9
      if (xe < 1) then
          nmethd = 1
      else if (x <= c1) then
          nmethd = 1
      else
          nmethd = 2
      endif

      if (nmethd == 1) then
          call fmerfc_m1(mxy, mresult, ndsave, numtry, x, qx)
      else if (nmethd == 2) then
          call fmerfc_m2(mxy, mresult, qx)
      endif
      call fmerfc_r(mxy, mresult, qx)

      return
      end subroutine fmerfc_m

      subroutine fmerfc_m1(mxy, mresult, ndsave, numtry, x, qx)

!  Method 1 for computing erfc(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(13), mresult
      integer :: ndsave, numtry
      double precision :: x
      intent (in) :: numtry, ndsave, x
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: iextra

!             Method 1.  Use erf.

      if (numtry <= 0 .and. qx%ncall <= 1 .and. qx%ndig < 100) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig-1), qx)
      endif
      if (x < 2) then
          call fmerf(mxy(1), mxy(4), qx)
          call fmi2m(1, mxy(2), qx)
          call fmsub(mxy(2), mxy(4), mresult, qx)
          return
      endif

!             Raise precision to compensate for cancellation if x is large.

      iextra = max(int((x*x+log(2*x))/qx%alogmb+1), 0)
      if (iextra > 0) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
      endif
      call fmndig(qx%ndig + iextra, qx)
      qx%raise_ndig = 1
      call fmerf(mxy(1), mxy(4), qx)
      qx%raise_ndig = 0
      call fmi2m(1, mxy(2), qx)
      call fmsub(mxy(2), mxy(4), mxy(3), qx)

      call fmeq(mxy(3), mresult, qx)

      return
      end subroutine fmerfc_m1

      subroutine fmerfc_m2(mxy, mresult, qx)

!  Method 2 for computing erfc(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(13), mresult
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: j, ndsav2, nterms

!             Method 2.  Use the continued fraction expansion.

!             mxy(2) is abs(x).
!             mxy(3) is abs(2x).
!             mxy(4) is -x*x.
!             mxy(13) is the current approximation.
!             mxy(10) is the term in the sum, s(k).
!             mxy(8), mxy(9) are the latest denominators, q(k-1) and q(k).

      call fmabs(mxy(1), mxy(2), qx)
      call fmmpyi(mxy(2), 2, mxy(3), qx)
      call fmsqr(mxy(2), mxy(4), qx)
      call fmnegate(mxy(4), qx)
      call fmi2m(0, mxy(8), qx)
      call fmi2m(1, mxy(9), qx)
      call fmi2m(1, mxy(10), qx)
      call fmi2m(0, mxy(13), qx)
      nterms = int(intmax/10)

!             Continued fraction loop.

      ndsav2 = qx%ndig
      do j = 1, nterms
         if (mod(j, 2) == 1) then
             call fmeq(mxy(2), mxy(11), qx)
             call fmcsmpy_r1(mxy(11), mxy(9), qx)
         else
             call fmeq(mxy(3), mxy(11), qx)
             call fmcsmpy_r1(mxy(11), mxy(9), qx)
         endif
         if (j == 1) then
             call fmeq(mxy(11), mxy(7), qx)
             call fmexp(mxy(4), mxy(5), qx)
             qx%ndige = 0
             call fmpi(mxy(12), qx)
             qx%ndigpi = 0
             call fmsqrt(mxy(12), mxy(6), qx)
             call fmdiv(mxy(5), mxy(6), mxy(10), qx)
             call fmdiv_r1(mxy(10), mxy(2), qx)
             if (mxy(10)%mp(2) == qx%mexpun) then
                 call fmeq(mxy(10), mresult, qx)
                 return
             endif
         else
             call fmcsmpyi(mxy(8), j-1, mxy(12), qx)
             call fmadd(mxy(11), mxy(12), mxy(7), qx)
             call fmcsmpy_r1(mxy(10), mxy(12), qx)
             call fmeq(mxy(10), mxy(5), qx)
             call fmcsdiv(mxy(5), mxy(7), mxy(10), qx)
             call fmnegate(mxy(10), qx)
         endif
         call fmeq(mxy(9), mxy(8), qx)
         call fmeq(mxy(7), mxy(9), qx)
         call fmndig(ndsav2, qx)
         call fmcsadd_r1(mxy(13), mxy(10), qx)

!             Check for convergence.

         if (j > 1 .and. qx%kflag == 1) then
             exit
         endif
         call fmndig(min(ndsav2, max(qx%ngrd22, ndsav2-int(mxy(13)%mp(2)-mxy(10)%mp(2)))), qx)
         if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         if (j == nterms) then
             call fmunknown(mresult, qx)
             return
         endif
      enddo

      call fmeq(mxy(13), mresult, qx)

      return
      end subroutine fmerfc_m2

      subroutine fmerfc_r(mxy, mresult, qx)

!  Check non-symmetric rounding for computing erfc(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(13), mresult
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      logical, external :: fmcomp

      if (qx%kround == -1 .or. qx%kround == 0) then
          call fmi2m(2, mxy(1), qx)
          if (fmcomp(mresult, '==', mxy(1), qx)) then
              call fmdp2m(1.9999d0, mxy(2), qx)
              call fmulp(mxy(2), mxy(4), qx)
              call fmsub(mxy(1), mxy(4), mresult, qx)
          endif
      endif

      return
      end subroutine fmerfc_r

      subroutine fmerfc_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = erfc(ma).

!  kresult = 1 is returned if a special case gives the value of erfc(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      double precision :: xe, ye
      integer :: j, k, krsave, nds
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMERFC   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      call fmovun_xe(malocal, xe, qx)
      if (qx%kround /= 1 .and. xe < -ndsave) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          krsave = qx%kround
          qx%kround = 1
          nds = qx%ndig
          call fmndig(qx%ndig + qx%ngrd52, qx)
          call fmequ(malocal, mxy(1), nds, qx%ndig, qx)
          call fmi2m(1, mxy(4), qx)
          if (malocal%mp(2) == qx%mexpun) then
              call fmi2m(0, mxy(2), qx)
              call fmsub(mxy(2), mxy(1), mxy(5), qx)
          else
              call fmpi(mxy(2), qx)
              qx%ndigpi = 0
              call fmsqrt(mxy(2), mxy(3), qx)
              call fmdiv(mxy(4), mxy(3), mxy(5), qx)
              call fmmpyi(mxy(5), -2, mxy(6), qx)
              call fmmpy(mxy(1), mxy(6), mxy(5), qx)
          endif
          call fmovun_xe(mxy(4), xe, qx)
          call fmovun_xe(mxy(5), ye, qx)
          if (xe - ye > ndsave) then
              call fmequ(mxy(4), mxy(6), qx%ndig, nds, qx)
              call fmequ(mxy(5), mxy(7), qx%ndig, nds, qx)
              call fmndig(nds, qx)
              qx%kround = krsave
              call fmadd(mxy(6), mxy(7), mresult, qx)
              qx%kflag = 0
              qx%ntrace = j
              qx%kwarn = k
              kresult = 1
              return
          endif
          qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          call fmndig(nds, qx)
          qx%kround = krsave
      endif

      return
      end subroutine fmerfc_sc

      subroutine fmerfcs(ma, mb, qx)

!  mb = erfc_scaled(ma)    Scaled Complimentary Error function.

!     = exp(x**2) * erfc(x)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(13), mresult, mretry

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmerfcs_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      n_acc = nint(qx%ndig*qx%alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmerfcs_m(ma, mxy, mresult, ndsave, numtry, retry, qx)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry, qx)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmerfcs

      subroutine fmerfcs_m(ma, mxy, mresult, ndsave, numtry, retry, qx)

!  Method selection for computing erfc_scaled(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: ndsave, numtry
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry
      type(fm_settings) :: qx

      double precision :: c1, x, xe
      integer :: nmethd

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      call fmi2m(1, mxy(3), qx)
      call fmdivi_r1(mxy(3), 2, qx)

!             Check for special cases.

      if (mxy(1)%mp(3) == 0 .or. mxy(1)%mp(2) == qx%mexpun) then
          call fmi2m(1, mresult, qx)
          retry = .false.
          return
      endif

!             x is a double precision approximation to the input argument to this function.

      call fmm2dp(mxy(1), x, qx)
      call fmovun_xe(mxy(1), xe, qx)
      if (qx%kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax
          if (mxy(1)%mp(1) < 0) x = -x
      endif
      if (qx%kflag /= 0 .and. xe > 0) then
          x = dpmax
          if (mxy(1)%mp(1) < 0) x = -x
      endif

!             Determine which method to use.

!             nmethd = 1 means use exp(x**2) * (1 - erf(x)),
!                    = 2 means use the continued fraction expansion.

      c1 = (qx%dlogmb*(qx%ndig+6))**0.7d0/9
      call fmovun_xe(mxy(1), xe, qx)
      if (xe < 1) then
          nmethd = 1
      else if (x <= c1) then
          nmethd = 1
      else
          nmethd = 2
      endif

      if (nmethd == 1) then
          call fmerfcs_m1(mxy, mresult, ndsave, numtry, x, qx)
      else if (nmethd == 2) then
          call fmerfcs_m2(mxy, mresult, qx)
      endif

      return
      end subroutine fmerfcs_m

      subroutine fmerfcs_m1(mxy, mresult, ndsave, numtry, x, qx)

!  Method 1 for computing erfc_scaled(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(13), mresult
      integer :: ndsave, numtry
      double precision :: x
      intent (in) :: numtry, ndsave, x
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: iextra

!             Method 1.  Use erf.

      if (numtry <= 0 .and. qx%ncall <= 1 .and. qx%ndig < 100) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig-1), qx)
      endif
      if (x < 2) then
          qx%raise_ndig = 1
          call fmerf(mxy(1), mxy(4), qx)
          qx%raise_ndig = 0
          call fmi2m(1, mxy(2), qx)
          call fmsub(mxy(2), mxy(4), mxy(3), qx)
          call fmsqr(mxy(1), mxy(2), qx)
          call fmexp(mxy(2), mxy(4), qx)
          qx%ndige = 0
          call fmmpy_r1(mxy(3), mxy(4), qx)
          call fmeq(mxy(3), mresult, qx)
          return
      endif

!             Raise precision to compensate for cancellation if x is large.

      iextra = max(int((x*x+log(2*x))/qx%alogmb+1), 0)
      if (iextra > 0) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
      endif
      call fmndig(qx%ndig + iextra, qx)
      qx%raise_ndig = 1
      call fmerf(mxy(1), mxy(4), qx)
      qx%raise_ndig = 0
      call fmi2m(1, mxy(2), qx)
      call fmsub(mxy(2), mxy(4), mxy(3), qx)
      call fmsqr(mxy(1), mxy(2), qx)
      call fmexp(mxy(2), mxy(4), qx)
      qx%ndige = 0
      call fmmpy_r1(mxy(3), mxy(4), qx)

      call fmeq(mxy(3), mresult, qx)

      return
      end subroutine fmerfcs_m1

      subroutine fmerfcs_m2(mxy, mresult, qx)

!  Method 2 for computing erfc_scaled(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(13), mresult
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: j, ndsav2, nterms

!             Method 2.  Use the continued fraction expansion.

!             mxy(2) is abs(x).
!             mxy(3) is abs(2x).
!             mxy(13) is the current approximation.
!             mxy(10) is the term in the sum, s(k).
!             mxy(8), mxy(9) are the latest denominators, q(k-1) and q(k).

      call fmabs(mxy(1), mxy(2), qx)
      call fmmpyi(mxy(2), 2, mxy(3), qx)
      call fmi2m(0, mxy(8), qx)
      call fmi2m(1, mxy(9), qx)
      call fmi2m(1, mxy(10), qx)
      call fmi2m(0, mxy(13), qx)
      nterms = int(intmax/10)

!             Continued fraction loop.

      ndsav2 = qx%ndig
      do j = 1, nterms
         if (mod(j, 2) == 1) then
             call fmeq(mxy(2), mxy(11), qx)
             call fmcsmpy_r1(mxy(11), mxy(9), qx)
         else
             call fmeq(mxy(3), mxy(11), qx)
             call fmcsmpy_r1(mxy(11), mxy(9), qx)
         endif
         if (j == 1) then
             call fmeq(mxy(11), mxy(7), qx)
             call fmi2m(1, mxy(5), qx)
             call fmpi(mxy(12), qx)
             qx%ndigpi = 0
             call fmsqrt(mxy(12), mxy(6), qx)
             call fmdiv(mxy(5), mxy(6), mxy(10), qx)
             call fmdiv_r1(mxy(10), mxy(2), qx)
             if (mxy(10)%mp(2) == qx%mexpun) then
                 call fmeq(mxy(10), mresult, qx)
                 return
             endif
         else
             call fmcsmpyi(mxy(8), j-1, mxy(12), qx)
             call fmadd(mxy(11), mxy(12), mxy(7), qx)
             call fmcsmpy_r1(mxy(10), mxy(12), qx)
             call fmeq(mxy(10), mxy(5), qx)
             call fmcsdiv(mxy(5), mxy(7), mxy(10), qx)
             call fmnegate(mxy(10), qx)
         endif
         call fmeq(mxy(9), mxy(8), qx)
         call fmeq(mxy(7), mxy(9), qx)
         call fmndig(ndsav2, qx)
         call fmcsadd_r1(mxy(13), mxy(10), qx)

!             Check for convergence.

         if (j > 1 .and. qx%kflag == 1) then
             exit
         endif
         call fmndig(min(ndsav2, max(qx%ngrd22, ndsav2-int(mxy(13)%mp(2)-mxy(10)%mp(2)))), qx)
         if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         if (j == nterms) then
             call fmunknown(mresult, qx)
             return
         endif
      enddo

      call fmeq(mxy(13), mresult, qx)

      return
      end subroutine fmerfcs_m2

      subroutine fmerfcs_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = erfc_scaled(ma).

!  kresult = 1 is returned if a special case gives the value of erfc_scaled(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      double precision :: xe, ye
      integer :: j, k, krsave, nds
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMERFCS  '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      call fmovun_xe(malocal, xe, qx)
      if (qx%kround /= 1 .and. xe < -ndsave) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          krsave = qx%kround
          qx%kround = 1
          nds = qx%ndig
          call fmndig(qx%ndig + qx%ngrd52, qx)
          call fmequ(malocal, mxy(1), nds, qx%ndig, qx)
          call fmi2m(1, mxy(4), qx)
          if (malocal%mp(2) == qx%mexpun) then
              call fmi2m(0, mxy(2), qx)
              call fmsub(mxy(2), mxy(1), mxy(5), qx)
          else
              call fmpi(mxy(2), qx)
              qx%ndigpi = 0
              call fmsqrt(mxy(2), mxy(3), qx)
              call fmdiv(mxy(4), mxy(3), mxy(5), qx)
              call fmmpyi(mxy(5), -2, mxy(6), qx)
              call fmmpy(mxy(1), mxy(6), mxy(5), qx)
          endif
          call fmovun_xe(mxy(4), xe, qx)
          call fmovun_xe(mxy(5), ye, qx)
          if (xe - ye > ndsave) then
              call fmequ(mxy(4), mxy(6), qx%ndig, nds, qx)
              call fmequ(mxy(5), mxy(7), qx%ndig, nds, qx)
              call fmndig(nds, qx)
              qx%kround = krsave
              call fmadd(mxy(6), mxy(7), mresult, qx)
              qx%kflag = 0
              qx%ntrace = j
              qx%kwarn = k
              kresult = 1
              return
          endif
          qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          call fmndig(nds, qx)
          qx%kround = krsave
      endif

      return
      end subroutine fmerfcs_sc

      subroutine fmeuler(ma, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx

      call fmeulr(ma, qx)
      qx%ndgeul = 0

      return
      end subroutine fmeuler

      subroutine fmeulr(ma, qx)

!  ma = Euler's constant ( 0.5772156649... )

      use fmvals_parallel
      implicit none

      type(multi) :: m_euler
      type(multi) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx

      character(2315) :: string
      character :: st2(2315)
      integer :: j, k, ndmb, ndsave, ndsv
      type(multi) :: mxy(1)

      call fmalloc(ma, qx%ndig+2, qx)
      qx%ndgeul = 0
      qx%mbseul = 0

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      qx%kflag = 0
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMEULR'
      if (abs(qx%ntrace) >= 2 .and. qx%ncall <= qx%lvltrc) then
          write (qx%kw, "(' Input to FMEULR')")
      endif

!             Increase the working precision.

      ndsave = qx%ndig
      if (qx%ncall == 1) then
          k = int(5.0/qx%alogmt + 2.0 + (real(qx%ndig)*qx%alogmt)**0.35/qx%alogmt)
          call fmndig(max(qx%ndig+k, 3), qx)
      endif

!             Check to see if Euler's constant has previously been saved in base mbase with
!             sufficient precision.

      if (qx%mbseul == qx%mbase .and. qx%ndgeul >= qx%ndig) then
          call fmequ(m_euler, ma, qx%ndgeul, ndsave, qx)
      else

!             Euler's constant is slower to compute than the other saved constants, so more digits
!             are stored in string for quick conversion.

          ndmb = int(2300.0*2.302585/qx%alogmb)
          if (ndmb >= qx%ndig) then
              string = '0.57721566490153286060651209008240243104215933593992359880576723488486'//  &
              '7726777664670936947063291746749514631447249807082480960504014486542836224173997'//  &
              '6449235362535003337429373377376739427925952582470949160087352039481656708532331'//  &
              '5177661152862119950150798479374508570574002992135478614669402960432542151905877'//  &
              '5535267331399254012967420513754139549111685102807984234877587205038431093997361'//  &
              '3725530608893312676001724795378367592713515772261027349291394079843010341777177'//  &
              '8088154957066107501016191663340152278935867965497252036212879226555953669628176'//  &
              '3887927268013243101047650596370394739495763890657296792960100901512519595092224'//  &
              '3501409349871228247949747195646976318506676129063811051824197444867836380861749'//  &
              '4551698927923018773910729457815543160050021828440960537724342032854783670151773'//  &
              '9439870030237033951832869000155819398804270741154222781971652301107356583396734'//  &
              '8717650491941812300040654693142999297779569303100503086303418569803231083691640'//  &
              '0258929708909854868257773642882539549258736295961332985747393023734388470703702'//  &
              '8441292016641785024873337908056275499843459076164316710314671072237002181074504'//  &
              '4418664759134803669025532458625442225345181387912434573501361297782278288148945'//  &
              '9098638460062931694718871495875254923664935204732436410972682761608775950880951'//  &
              '2620840454447799229915724829251625127842765965708321461029821461795195795909592'//  &
              '2704208989627971255363217948873764210660607065982561990102880756125199137511678'//  &
              '2176436190570584407835735015800560774579342131449885007864151716151945657061704'//  &
              '3245075008168705230789093704614306684817916496842549150496724312183783875356489'//  &
              '4950868454102340601622508515583867234944187880440940770106883795111307872023426'//  &
              '3952269209716088569083825113787128368204911789259447848619911852939102930990592'//  &
              '5526691727446892044386971114717457157457320393520912231608508682755889010945168'//  &
              '1181016874975470969366671210206304827165895049327314860874940207006742590918248'//  &
              '7596213738423114426531350292303175172257221628324883811245895743862398703757662'//  &
              '8551303314392999540185313414158621278864807611003015211965780068117773763501681'//  &
              '8389733896639868957932991456388644310370608078174489957958324579418962026049841'//  &
              '0439225078604603625277260229196829958609883390137871714226917883819529844560791'//  &
              '6051972797360475910251099577913351579177225150254929324632502874767794842158405'//  &
              '07599290401855764599018627262'
              k = min(int(qx%ndig * qx%dlogmb / qx%dlogtn + 3), len(string))
              do j = 1, k
                 st2(j) = string(j:j)
              enddo
              call fminp(st2, m_euler, 1, k, qx)
              qx%mbseul = qx%mbase
              qx%ndgeul = qx%ndig
              if (abs(m_euler%mp(2)) > 10) qx%ndgeul = 0
              call fmequ(m_euler, ma, qx%ndig, ndsave, qx)
          else
              ndsv = qx%ndig
              call fmndig(qx%ndig + 2, qx)
              call fmeulr_b(mxy(1), qx)
              call fmeq(mxy(1), m_euler, qx)
              qx%mbseul = qx%mbase
              qx%ndgeul = qx%ndig
              if (abs(m_euler%mp(2)) > 10) qx%ndgeul = 0
              call fmequ(m_euler, ma, qx%ndig, ndsave, qx)
              call fmndig(ndsv, qx)
          endif
      endif

      qx%ndig = ndsave
      if (qx%ntrace /= 0) call fmntr_out1(ma, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmeulr

      subroutine fmeulr_b(mb, qx)

!  mb = Euler's constant = .577215...

!  Binary splitting version.
!  called by fmeulr for large ndig.  Faster and saves memory by not using Bernoulli numbers.

!  Sum f(x) = 1 + x/(1!)**2 + x**2/(2!)**2 + ...
!  and g(x) = h(1)*x/(1!)**2 + h(2)*x**2/(2!)**2 + ...
!  where h(n) = 1 + 1/2 + ... + 1/n.

!  As x --> infinity, g(x)/f(x) - ln(x)/2 --> Euler's constant.

      use fmvals_parallel
      implicit none

      type(multi) :: mb
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: k, kt, n, ndsave, level_of_recursion
      type(multi) :: mxy(7), x

      call fmalloc(mb, qx%ndig+2, qx)
      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      qx%ncall = qx%ncall + 1
      ndsave = qx%ndig
      if (qx%ncall == 1) then
          k = max(qx%ngrd52-1, 2)
          call fmndig(max(qx%ndig+k, 3), qx)
      endif
      mxsave = qx%mxexp
      qx%mxexp = qx%mxexp2

!             Determine x, variable in the series.

      n = qx%ndig*qx%dlogmb/4
      do
         k = n
         do
            kt = k/2
            if (2*kt == k) then
                k = kt
            else
                exit
            endif
         enddo
         do
            kt = k/3
            if (3*kt == k) then
                k = kt
            else
                exit
            endif
         enddo
         do
            kt = k/5
            if (5*kt == k) then
                k = kt
            else
                exit
            endif
         enddo
         do
            kt = k/7
            if (7*kt == k) then
                k = kt
            else
                exit
            endif
         enddo
         if (k == 1) exit
         n = n + 1
      enddo

      call imi2m(n, mxy(1), qx)
      call imsqr(mxy(1), x, qx)

!             Determine k, the number of terms to sum in the series.

      k = 3.5912d0*n
      level_of_recursion = 0
      call fmeulr_ptdcv(0, k, mxy(1), mxy(2), mxy(3), mxy(4), mxy(5), x, level_of_recursion, qx)
      if (mxy(3)%mp(2) >= qx%ndig) then
          call fmeq(mxy(3), mxy(7), qx)
      else
          call imi2fm(mxy(3), mxy(7), qx)
      endif
      call fmsqr(mxy(7), mxy(4), qx)
      if (mxy(2)%mp(2) >= qx%ndig) then
          call fmeq(mxy(2), mxy(1), qx)
      else
          call imi2fm(mxy(2), mxy(1), qx)
      endif
      call fmdiv(mxy(1), mxy(4), mxy(6), qx)
      call fmaddi(mxy(6), 1, qx)

      call fmmpy(mxy(7), mxy(4), mxy(1), qx)
      if (mxy(5)%mp(2) >= qx%ndig) then
          call fmeq(mxy(5), mxy(4), qx)
      else
          call imi2fm(mxy(5), mxy(4), qx)
      endif
      call fmdiv(mxy(4), mxy(1), mxy(2), qx)

      call fmdiv(mxy(2), mxy(6), mxy(5), qx)
      call fmlni(n, mxy(1), qx)
      qx%ndigli = 0
      call fmsub(mxy(5), mxy(1), mxy(3), qx)

!             Round the result and return.

      qx%mxexp = mxsave
      call fmequ(mxy(3), mb, qx%ndig, ndsave, qx)

      return
      end subroutine fmeulr_b

      recursive subroutine fmeulr_ptdcv(a, b, mp, mt, md, mc, mv, mx, level_of_recursion, qx)

!  This routine does the binary splitting for computing Euler's constant.

      use fmvals_parallel
      implicit none

      type(multi) :: mp, mt, md, mc, mv, mx
      integer :: a, b, level_of_recursion
      intent (in) :: a, b
      intent (inout) :: mp, mt, md, mc, mv, mx, level_of_recursion
      type(fm_settings) :: qx

      type(multi) :: mxy(10)
      integer :: j, jp, jd, m, result_size
      real (kind(0.0d0)) :: da, db

      da = a
      db = b
      result_size = ( (db - da + 1)*mx%mp(2) ) + 5
      result_size = max(5, result_size)
      result_size = min(qx%ndig+10, result_size)
      call fmalloc(mp, result_size, qx)
      jp = result_size
      result_size = ( (db+1.5d0)*log(db+2) - db + 1/(12*(db+2)) -  &
                    ( (da+0.5d0)*log(da+1) - da + 1/(12*(da+1)) ) - 1 ) / qx%dlogmb + 10
      result_size = min(qx%ndig+10, result_size)
      call fmalloc(md, result_size, qx)
      jd = result_size
      call fmalloc(mc, result_size, qx)
      call imi2m(a, mxy(1), qx)
      if (mxy(1)%mp(2) > mx%mp(2)) then
          result_size = mx%mp(2) + 4*jd
      else
          result_size = jp + 2*jd
      endif
      result_size = min(qx%ndig+10, result_size)
      call fmalloc(mt, result_size, qx)
      result_size = result_size + jd
      result_size = min(qx%ndig+10, result_size)
      call fmalloc(mv, result_size, qx)
      level_of_recursion = level_of_recursion + 1

      if (b-a < 12) then
          call fmalloc(mxy(1), result_size, qx)
          call fmalloc(mxy(2), result_size, qx)
          call fmalloc(mxy(3), result_size, qx)
          call fmalloc(mxy(4), result_size, qx)
          call fmalloc(mxy(5), result_size, qx)

          call imi2m(b-a+1, mxy(2), qx)
          call impwr(mx, mxy(2), mp, qx)

          call imi2m(1, md, qx)
          do j = a, b-1, 2
             call immpyi(md, j+1, mxy(1), qx)
             call immpyi(mxy(1), j+2, md, qx)
          enddo
          if (mod(b-a, 2) == 0) then
              call immpyi(md, b+1, mxy(1), qx)
              call imeq(mxy(1), md, qx)
          endif

          call imi2m(0, mc, qx)
          do j = a, b
             call imdivi(md, j+1, mxy(2), qx)
             call imadd(mc, mxy(2), mxy(3), qx)
             call imeq(mxy(3), mc, qx)
          enddo

!             mt is the t sum
!             mxy(1) is the next term
!             mv is the v sum
!             mxy(3) is the harmonic sum in the v terms

          call imi2m(0, mt, qx)
          call imi2m(0, mv, qx)
          call imsqr(md, mxy(1), qx)
          call imi2m(0, mxy(3), qx)
          do j = a, b
             call imdivi(mxy(1), j+1, mxy(2), qx)
             call imdivi(mxy(2), j+1, mxy(1), qx)
             call immpy(mxy(1), mx, mxy(2), qx)
             call imeq(mxy(2), mxy(1), qx)
             call imadd(mt, mxy(1), mxy(2), qx)
             call imeq(mxy(2), mt, qx)

             call imdivi(md, j+1, mxy(4), qx)
             call imadd(mxy(3), mxy(4), mxy(5), qx)
             call imeq(mxy(5), mxy(3), qx)
             call immpy(mxy(1), mxy(3), mxy(5), qx)
             call imadd(mv, mxy(5), mxy(2), qx)
             call imeq(mxy(2), mv, qx)
          enddo
      else

          m = a/2 + b/2 + mod(a, 2)*mod(b, 2)
          call fmeulr_ptdcv(a, m-1, mxy(1), mxy(2), mxy(3), mxy(4), mxy(5), mx, level_of_recursion, qx)
          call fmeulr_ptdcv(m, b, mxy(6), mxy(7), mxy(8), mxy(9), mxy(10), mx, level_of_recursion, qx)
          call im_or_fm_mpy(mxy(1), mxy(7), mt, qx)
          call im_or_fm_sqr(mxy(8), mp, qx)
          call im_or_fm_mpy(mxy(4), mxy(8), md, qx)

!             mp and mc are not needed in fmeulr_b, so their calculations can be skipped at the
!             top level of the recursion.

          if (level_of_recursion > 1) then
              call im_or_fm_mpy(mxy(9), mxy(3), mxy(4), qx)
              call im_or_fm_add(md, mxy(4), mc, qx)
          else
              call imi2m(0, mc, qx)
          endif

          call im_or_fm_mpy(md, mt, mxy(4), qx)
          call im_or_fm_mpy(mp, mxy(8), mv, qx)
          call im_or_fm_mpy(mv, mxy(5), mxy(9), qx)
          call im_or_fm_add(mxy(9), mxy(4), mv, qx)
          call im_or_fm_mpy(mxy(3), mxy(1), mxy(4), qx)
          call im_or_fm_mpy(mxy(4), mxy(10), mxy(9), qx)
          call im_or_fm_add(mv, mxy(9), mxy(4), qx)
          call im_or_fm_eq(mxy(4), mv, qx)

          call im_or_fm_mpy(mxy(3), mxy(8), md, qx)

          call im_or_fm_mpy(mp, mxy(2), mxy(3), qx)
          call im_or_fm_add(mxy(3), mt, mxy(8), qx)
          call im_or_fm_eq(mxy(8), mt, qx)

          if (level_of_recursion > 1) then
              call im_or_fm_mpy(mxy(1), mxy(6), mp, qx)
          else
              call imi2m(0, mp, qx)
          endif
      endif

      level_of_recursion = level_of_recursion - 1

      return
      end subroutine fmeulr_ptdcv

      subroutine fmexit0(mxsave, ndsave, qx)

!  At the end of a function this routine resets precision and the overflow/underflow threshold
!  to the values from the start of that function.

      use fmvals_parallel
      implicit none

      real (kind(1.0d0)) :: mxsave
      integer :: ndsave
      intent (inout) :: mxsave, ndsave
      type(fm_settings) :: qx

      qx%mxexp = mxsave
      qx%ndig = ndsave
      if (qx%kflag == 1) qx%kflag = 0
      if (qx%kflag < 0) call fmwarn(qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmexit0

      subroutine fmexit1(ma, mb, kovun, mxsave, ndsave, qx)

!  At the end of a function this routine checks for tracing the output argument,
!  rounds ma from precision ndig to precision ndsave as the returned function value mb,
!  and resets precision, and the overflow/underflow threshold to the values from the
!  start of that function.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (in) :: ma
      intent (inout) :: mb, kovun, mxsave, ndsave
      type(fm_settings) :: qx

      integer :: kfsave, kwrnsv

      kwrnsv = qx%kwarn
      qx%kwarn = 0
      qx%mxexp = mxsave
      kfsave = qx%kflag
      call fmequ(ma, mb, qx%ndig, ndsave, qx)
      if (qx%kflag /= -5 .and. qx%kflag /= -6) qx%kflag = kfsave
      qx%ndig = ndsave
      qx%kwarn = kwrnsv
      if (qx%kflag == 1) qx%kflag = 0
      if (qx%kflag >= 0 .or. qx%kflag == -4 .or. qx%kflag == -5 .or. qx%kflag == -6) then
          if (mb%mp(2) == qx%munkno) qx%kflag = -4
          if (mb%mp(2) == qx%mexpov) qx%kflag = -5
          if (mb%mp(2) == qx%mexpun) qx%kflag = -6
      endif
      if ((mb%mp(2) == qx%munkno .and. qx%kflag /= -9 .and. kovun /= 2) .or.  &
          (mb%mp(2) == qx%mexpun .and. kovun == 0)                   .or.     &
          (mb%mp(2) == qx%mexpov .and. kovun == 0)) then
         call fmwarn(qx)
      else if ((qx%kflag < 0 .and. qx%kflag > -4) .or. qx%kflag < -6) then
         call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) call fmntr_out1(mb, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmexit1

      subroutine fmexit2(ma, mb, mc, md, kovun, mxsave, ndsave, qx)

!  At the end of a function this routine checks for tracing the output argument,
!  rounds ma from precision ndig to precision ndsave as the returned function value mb,
!  and resets precision, and the overflow/underflow threshold to the values from the
!  start of that function.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (in) :: ma, mb
      intent (inout) :: mc, md, kovun, mxsave, ndsave
      type(fm_settings) :: qx

      integer :: kfsave, kwrnsv

      kwrnsv = qx%kwarn
      qx%kwarn = 0
      qx%mxexp = mxsave
      kfsave = qx%kflag
      call fmequ(ma, mc, qx%ndig, ndsave, qx)
      call fmequ(mb, md, qx%ndig, ndsave, qx)
      if (qx%kflag /= -5 .and. qx%kflag /= -6) qx%kflag = kfsave
      qx%ndig = ndsave
      qx%kwarn = kwrnsv
      if (qx%kflag == 1) qx%kflag = 0
      if (qx%kflag >= 0 .or. qx%kflag == -4 .or. qx%kflag == -5 .or. qx%kflag == -6) then
          if (mc%mp(2) == qx%mexpun .or. md%mp(2) == qx%mexpun) qx%kflag = -6
          if (mc%mp(2) == qx%mexpov .or. md%mp(2) == qx%mexpov) qx%kflag = -5
          if (mc%mp(2) == qx%munkno .or. md%mp(2) == qx%munkno) qx%kflag = -4
      endif
      if ((mc%mp(2) == qx%munkno .and. qx%kflag /= -9 .and. kovun /= 2) .or.  &
          (md%mp(2) == qx%munkno .and. qx%kflag /= -9 .and. kovun /= 2) .or.  &
          (abs(mc%mp(2)) == qx%mexpov .and. kovun == 0)              .or.     &
          (abs(md%mp(2)) == qx%mexpov .and. kovun == 0)) then
         call fmwarn(qx)
      else if ((qx%kflag < 0 .and. qx%kflag > -4) .or. qx%kflag < -6) then
         call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) call fmntr_out2(mc, md, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmexit2

      subroutine fmexp(ma, mb, qx)

!  mb = exp(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(4), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmexp_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmexp_m1(ma, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmexp

      subroutine fmexp2(ma, mb, qx)

!  mb = exp(ma)

!  Internal exponential routine (called with 0 < ma <= 1).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: maxv
      real (kind(0.0d0)) :: x1, x2, x3, f1, f2, f3, pi
      integer :: j, j2, k, k2, kexp, kl, ktwo, l, l2, n2, nbig, nbot, ndsav1, ndsave, nterm, ntop
      real :: alog2, alogt, b, t, tj, xn
      type(multi) :: mxy(4), mjsums(ljsums)

      call fmalloc(mb, qx%ndig+2, qx)

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      ndsave = qx%ndig
      if (ma%mp(2) == 1) then

!             Special case exp(1).

          t = qx%ndig
          xn = t*qx%alogmb/log(t)
          k = int(log(xn)/qx%alogmb)
          call fmndig(max(qx%ndig+k, 3), qx)
          ndsav1 = qx%ndig

          if (ndsave < 100) then

!             If precision is not very high, use the direct series  e = 1/0! + 1/1! + 1/2! + ...
!             Do as much of the work as possible using small integers to minimize the number of
!             FM calls.  Reduce ndig while computing each term in the sum as the terms get smaller.

              call fmi2m(2, mxy(2), qx)
              call fmi2m(1, mxy(1), qx)
              j = 2
              nbig = int(mxbase)
              kl = 1
              do while (kl > 0)
                 ntop = 1
                 nbot = j
                 do while (nbot <= nbig/(j+1))
                    j = j + 1
                    ntop = j*ntop + 1
                    nbot = j*nbot
                 enddo

                 call fmcsdivi_r1(mxy(1), nbot, qx)
                 if (ntop > 1) then
                     call fmcsmpyi(mxy(1), ntop, mxy(3), qx)
                     call fmndig(ndsav1, qx)
                     call fmadd_r1(mxy(2), mxy(3), qx)
                     call fmndig(ndsav1 - int(mxy(2)%mp(2)-mxy(3)%mp(2)), qx)
                     if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                 else
                     call fmndig(ndsav1, qx)
                     call fmadd_r1(mxy(2), mxy(1), qx)
                     call fmndig(ndsav1 - int(mxy(2)%mp(2)-mxy(1)%mp(2)), qx)
                     if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                 endif
                 if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                 if (qx%kflag /= 1) then
                     j = j + 1
                 else
                     kl = 0
                 endif
              enddo

              qx%ndig = ndsave
              qx%kflag = 0
              call fmequ(mxy(2), mb, ndsav1, ndsave, qx)
          else

!             If precision is high, use the binary splitting method for summing the direct series.

!             Determine k, the number of terms to sum in the series for e.

              x1 = 1.184*qx%ndig*qx%dlogmb/log(qx%ndig*qx%dlogmb) + 1.95*real(qx%ndig)**0.777 + 10
              pi = acos(-1.0d0)
              f1 = qx%ndig*qx%dlogmb - (x1 + 0.5)*log(x1) + x1 - log(2.0*pi)/2 - 1/(12.0*x1)
              if (f1 < 0) then
                  x2 = 0.9*x1
              else
                  x2 = 1.1*x1
              endif
              f2 = qx%ndig*qx%dlogmb - (x2 + 0.5)*log(x2) + x2 - log(2.0*pi)/2 - 1/(12.0*x2)
              x3 = x2
              do j = 1, 5
                 x3 = x2 - f2*(x2 - x1)/(f2 - f1)
                 f3 = qx%ndig*qx%dlogmb - (x3 + 0.5)*log(x3) + x3 - log(2.0*pi)/2 - 1/(12.0*x3)
                 if (abs(x3-x2) < 0.1) exit
                 x1 = x2
                 f1 = f2
                 x2 = x3
                 f2 = f3
              enddo

              k = x3 + 10
              call fmexp2_tq(0, k, mxy(1), mxy(2), qx)
              if (mxy(1)%mp(2) >= qx%ndig .and. mxy(2)%mp(2) >= qx%ndig) then
                  call fmdiv_r2(mxy(1), mxy(2), qx)
                  qx%ndig = ndsave
                  qx%kflag = 0
                  call fmequ(mxy(2), mb, ndsav1, ndsave, qx)
              else
                  call imi2fm(mxy(1), mxy(3), qx)
                  call imi2fm(mxy(2), mxy(4), qx)
                  call fmdiv(mxy(3), mxy(4), mxy(2), qx)
                  qx%ndig = ndsave
                  qx%kflag = 0
                  call fmequ(mxy(2), mb, ndsav1, ndsave, qx)
              endif
          endif
          return
      endif

!             Here is the general case.  Compute exp(ma) where 0 < ma < 1.

!             Use the direct series
!                  exp(x) = 1 + x + x**2/2! + x**3/3! + ...

!             The argument will be halved k2 times before the series is summed.  The series will be
!             added as j2 concurrent series.

      b = real(qx%mbase)
      k = qx%ngrd52
      t = max(qx%ndig-k, 2)
      alog2 = real(qx%dlogtw)
      alogt = log(t)
      tj = 0.87*(qx%ndig*qx%alogmt)**0.3333 - 1.3
      j2 = int(tj)
      j2 = max(1, min(j2, ljsums))
      k2 = max(2, int(2.0*(qx%ndig*qx%alogmt)**0.3333 - 0.5))

      tj = -(real(ma%mp(2))*qx%alogmb +  &
             log(real(ma%mp(3))/b + real(ma%mp(4))/(b*b)))/alog2 - 0.3
      if (tj >= k2) then
          l = k2
      else if (tj > 0) then
          l = int(tj)
      else
          l = 0
      endif
      k2 = k2 - l
      if (k2 <= 0) then
          k2 = 0
          j2 = int(.43*sqrt(t*qx%alogmb/(alogt+real(l)*alog2)) + .33)
          j2 = max(1, min(j2, ljsums))
      endif

      n2 = int(t*qx%alogmb/(alogt+real(l)*alog2))
      l2 = int(log(real(n2)+2.0d0**k2)/qx%alogmb)
      call fmndig(qx%ndig + l2, qx)
      ndsav1 = qx%ndig

!             Halve the argument k2 times.

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      ktwo = 1
      maxv = mxbase/2
      if (k2 > 0) then
          do j = 1, k2
             ktwo = 2*ktwo
             if (ktwo > maxv) then
                 call fmcsdivi_r1(mxy(1), ktwo, qx)
                 ktwo = 1
             endif
          enddo
          if (ktwo > 1) call fmcsdivi_r1(mxy(1), ktwo, qx)
      endif

!             Sum the series x + x**2/2! + x**3/3! + ....
!             Split into j2 concurrent sums and reduce ndig while computing each term in the sum as
!             the terms get smaller.

      call fmeq(mxy(1), mxy(2), qx)
      nterm = 1
      do j = 1, j2
         call fmcsdivi_r1(mxy(2), nterm, qx)
         nterm = nterm + 1
         call fmeq(mxy(2), mjsums(j), qx)
      enddo

      if (mxy(1)%mp(2) >= -qx%ndig) then
          call fmipwr(mxy(1), j2, mxy(3), qx)
          kl = 1
          do while (kl > 0)
             call fmcsmpy_r1(mxy(2), mxy(3), qx)
             do j = 1, j2
                call fmcsdivi_r1(mxy(2), nterm, qx)
                call fmndig(ndsav1, qx)
                call fmcsaddnn_r1(mjsums(j), mxy(2), qx)
                if (qx%kflag /= 0) then
                    kl = 0
                    exit
                endif
                call fmndig(ndsav1 - int(mjsums(j)%mp(2)-mxy(2)%mp(2)), qx)
                if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                nterm = nterm + 1
             enddo
          enddo
      endif

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmcsnsums(j2, mjsums, qx)
      call fmeq(mjsums(j2), mxy(3), qx)
      do j = 2, j2
         call fmcsmpy_r1(mxy(3), mxy(1), qx)
         call fmadd_r1(mxy(3), mjsums(j2-j+1), qx)
      enddo

!             Reverse the effect of halving the argument to compute exp(ma).

      call fmndig(ndsav1, qx)
      if (k2 > 0) then
          if (ndsave <= 20) then
              call fmi2m(2, mxy(1), qx)
              do j = 1, k2
                 kexp = mxy(3)%mp(2)
                 if (qx%mbase == 2 .or. kexp > 0) then
                     call fmadd(mxy(3), mxy(1), mxy(2), qx)
                 else
                     do k = 1, 3-kexp
                        mxy(2)%mp(k) = mxy(1)%mp(k)
                     enddo
                     do k = 4-kexp, qx%ndig+2
                        mxy(2)%mp(k) = mxy(3)%mp(k-1+kexp)
                     enddo
                 endif
                 call fmcsmpy_r1(mxy(3), mxy(2), qx)
              enddo
          else
              do j = 1, k2
                 call fmsqr(mxy(3), mxy(2), qx)
                 call fmadd(mxy(3), mxy(3), mxy(1), qx)
                 call fmadd(mxy(2), mxy(1), mxy(3), qx)
              enddo
          endif
      endif
      call fmi2m(1, mxy(1), qx)
      call fmadd(mxy(1), mxy(3), mxy(2), qx)

      call fmequ(mxy(2), mb, ndsav1, ndsave, qx)
      qx%ndig = ndsave

      return
      end subroutine fmexp2

      recursive subroutine fmexp2_tq(a, b, mt, mq, qx)

!  This routine does the binary splitting for computing the constant e.
!  When a is zero, e is approximated by mt/mq.

      use fmvals_parallel
      implicit none

      integer :: a, b
      type(multi) :: mt, mq
      intent (in) :: a, b
      intent (inout) :: mt, mq
      type(fm_settings) :: qx

      type(multi) :: mxy(4)
      integer :: j, km, result_size
      real (kind(0.0d0)) :: da, db

      da = a
      db = b

      if (b-a < 25) then
          result_size = ( (db+0.5d0)*log(db+1) - db + 1/(12*(db+1)) -  &
                        ( (da+0.5d0)*log(da+1) - da + 1/(12*(da+1)) ) + 10 ) / qx%dlogmb + 8
          result_size = max(5, result_size)
          call fmalloc(mt, result_size, qx)
          call fmalloc(mq, result_size, qx)
          call fmalloc(mxy(1), result_size, qx)
          call fmalloc(mxy(2), result_size, qx)
          call fmalloc(mxy(3), result_size, qx)
          call fmalloc(mxy(4), result_size, qx)
          call imi2m(1, mt, qx)
          call imi2m(1, mxy(1), qx)
          do j = 0, b-a-2, 2
             call immpyi(mxy(1), b-j, mxy(2), qx)
             call imadd(mt, mxy(2), mxy(3), qx)
             call immpyi(mxy(2), b-j-1, mxy(1), qx)
             call imadd(mxy(3), mxy(1), mt, qx)
          enddo
          if (mod(b-a, 2) == 1) then
              call immpyi(mxy(1), a+1, mxy(2), qx)
              call imadd(mt, mxy(2), mxy(3), qx)
              call imeq(mxy(3), mt, qx)
          endif

          if (a == 0) then
              call imi2m(1, mq, qx)
          else
              call imi2m(a, mq, qx)
          endif
          do j = a+1, b-1, 2
             call immpyi(mq, j, mxy(1), qx)
             call immpyi(mxy(1), j+1, mq, qx)
          enddo
          if (mod(b-a+1, 2) == 0) then
              call immpyi(mq, b, mxy(1), qx)
              call imeq(mxy(1), mq, qx)
          endif
          return
      endif

      km = a/2 + b/2 + mod(a, 2)*mod(b, 2)
      call fmexp2_tq(a, km-1, mxy(1), mxy(2), qx)
      call fmexp2_tq(km, b, mxy(3), mxy(4), qx)

      call im_or_fm_mpy(mxy(2), mxy(4), mq, qx)

      call im_or_fm_mpy(mxy(1), mxy(4), mxy(2), qx)
      call im_or_fm_add(mxy(3), mxy(2), mt, qx)

      return
      end subroutine fmexp2_tq

      subroutine fmexp_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing exp(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mesav
      type(multi) :: ma, mxy(4), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      character(155) :: string
      character :: st2(155)
      integer :: iextra, j, k, kt, kwrnsv, ndmb, ndsv, nmethd
      logical :: kt_large

      qx%ndige = 0
      qx%mbse = 0
      call fmequ(ma, mxy(2), ndsave, qx%ndig, qx)

!             Split ma into integer and fraction parts.  Work with a positive argument.
!             mxy(1) = integer part of abs(ma)
!             mxy(2) = fraction part of abs(ma)

      mxy(2)%mp(1) = 1
      call fmint(mxy(2), mxy(1), qx)
      call fmsub_r1(mxy(2), mxy(1), qx)

!             If the integer part is not zero, compute e**(mxy(1)).

      kwrnsv = qx%kwarn
      qx%kwarn = 0
      call fmm2i(mxy(1), kt, qx)
      kt_large = .false.
      if (kt < 0) then
          kt_large = .true.
          kt = huge(kt)
      endif
      qx%kwarn = kwrnsv
      if (kt /= 0) then

!             Compute iextra, the number of extra digits required to get exp(kt) correct to the
!             current precision.

          iextra = int(log(real(kt))/qx%alogmb + 0.5)
          if (iextra > 0) then
              call fmequ_r1(mxy(2), qx%ndig, qx%ndig+iextra, qx)
          endif
          call fmndig(qx%ndig + iextra, qx)

!             Check whether the current precision of e is large enough.

          if (qx%mbse /= qx%mbase .or. qx%ndig > qx%ndige) then
              ndmb = int(150.0*2.302585/qx%alogmb)
              if (ndmb >= qx%ndig) then
                  string = '2.718281828459045235360287471352662497757247'//  &
                  '09369995957496696762772407663035354759457138217852516'//  &
                  '6427427466391932003059921817413596629043572900334295261'
                  k = min(int((qx%ndig-1) * qx%dlogmb / qx%dlogtn + 3), len(string))
                  do j = 1, k
                     st2(j) = string(j:j)
                  enddo
                  call fminp(st2, mesav, 1, k, qx)
                  qx%mbse = qx%mbase
                  qx%ndige = qx%ndig
                  if (abs(mesav%mp(2)) > 10) qx%ndige = 0
              else
                  ndsv = qx%ndig
                  call fmndig(qx%ndig + 2 + qx%ndig/100, qx)
                  call fmi2m(1, mesav, qx)
                  call fmexp2(mesav, mxy(4), qx)
                  call fmeq(mxy(4), mesav, qx)
                  qx%mbse = qx%mbase
                  qx%ndige = qx%ndig
                  if (abs(mesav%mp(2)) > 10) qx%ndige = 0
                  call fmndig(ndsv, qx)
              endif
          endif
      endif

!             Now do the fraction part of ma and combine the results.

      kwrnsv = qx%kwarn
      qx%kwarn = 0
      nmethd = 1
      if (qx%ndig > 50) nmethd = 2
      if (mxy(2)%mp(3) /= 0 .and. kt > 0 .and. nmethd == 1) then
          call fmexp2(mxy(2), mxy(4), qx)
          if (kt_large) then
              call fmexp_m2(ma, mesav, mxy(3), ndsave, qx)
          else
              call fmipwr(mesav, kt, mxy(3), qx)
          endif
          call fmmpy(mxy(4), mxy(3), mxy(2), qx)
      else if (mxy(2)%mp(3) /= 0 .and. kt == 0 .and. nmethd == 1) then
          call fmexp2(mxy(2), mxy(4), qx)
          call fmeq(mxy(4), mxy(2), qx)
      else if (mxy(2)%mp(3) /= 0 .and. kt > 0 .and. nmethd == 2) then
          ndsv = qx%ndig
          call fmndig(qx%ndig + qx%ngrd21, qx)
          call fmequ_r1(mxy(2), ndsv, qx%ndig, qx)
          if (mxy(2)%mp(2) >= 0) then
              call fmcosh2(mxy(2), mxy(4), qx)
              call fmsqr(mxy(4), mxy(3), qx)
              call fmi2m(-1, mxy(1), qx)
              call fmadd_r1(mxy(3), mxy(1), qx)
              call fmsqrt_r1(mxy(3), qx)
              call fmadd(mxy(4), mxy(3), mxy(2), qx)
          else
              call fmsinh2(mxy(2), mxy(4), qx)
              call fmsqr(mxy(4), mxy(3), qx)
              call fmi2m(1, mxy(1), qx)
              call fmadd_r1(mxy(3), mxy(1), qx)
              call fmsqrt_r1(mxy(3), qx)
              call fmadd(mxy(4), mxy(3), mxy(2), qx)
          endif
          call fmndig(ndsv, qx)
          if (kt_large) then
              call fmexp_m2(ma, mesav, mxy(3), ndsave, qx)
          else
              call fmipwr(mesav, kt, mxy(3), qx)
          endif
          call fmmpy_r1(mxy(2), mxy(3), qx)
      else if (mxy(2)%mp(3) /= 0 .and. kt == 0 .and. nmethd == 2) then
          ndsv = qx%ndig
          call fmndig(qx%ndig + qx%ngrd21, qx)
          call fmequ_r1(mxy(2), ndsv, qx%ndig, qx)
          if (mxy(2)%mp(2) >= 0) then
              call fmcosh2(mxy(2), mxy(4), qx)
              call fmsqr(mxy(4), mxy(3), qx)
              call fmi2m(-1, mxy(1), qx)
              call fmadd_r1(mxy(3), mxy(1), qx)
              call fmsqrt_r1(mxy(3), qx)
              call fmadd(mxy(4), mxy(3), mxy(2), qx)
          else
              call fmsinh2(mxy(2), mxy(4), qx)
              call fmsqr(mxy(4), mxy(3), qx)
              call fmi2m(1, mxy(1), qx)
              call fmadd_r1(mxy(3), mxy(1), qx)
              call fmsqrt_r1(mxy(3), qx)
              call fmadd(mxy(4), mxy(3), mxy(2), qx)
          endif
          call fmndig(ndsv, qx)
      else if (mxy(2)%mp(3) == 0 .and. kt > 0) then
          if (kt_large) then
              call fmexp_m2(ma, mesav, mxy(2), ndsave, qx)
          else
              call fmipwr(mesav, kt, mxy(2), qx)
          endif
      else
          call fmi2m(1, mxy(2), qx)
      endif

!             Invert if ma was negative.

      if (ma%mp(1) < 0) then
          call fmi2m(1, mxy(1), qx)
          call fmdiv_r2(mxy(1), mxy(2), qx)
      endif
      qx%kwarn = kwrnsv
      call fmeq(mxy(2), mresult, qx)

      return
      end subroutine fmexp_m1

      subroutine fmexp_m2(ma, mb, mc, ndsave, qx)

!  Internal routine to compute mc = mb**int(abs(ma)).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      integer :: ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mc
      type(fm_settings) :: qx

      type(multi) :: mxy(5)

      call fmequ(ma, mxy(2), ndsave, qx%ndig, qx)
      mxy(2)%mp(1) = 1
      call fmint(mxy(2), mxy(1), qx)

      call fmi2m(2, mxy(2), qx)
      call fmmod(mxy(1), mxy(2), mxy(3), qx)
      if (mxy(3)%mp(3) == 0) then
          call fmi2m2(1, mxy(3), qx)
      else
          call fmeq(mb, mxy(3), qx)
      endif
      call fmeq(mb, mxy(2), qx)

!             This is the multiplication loop.

      do while (mxy(1)%mp(2) > 1 .or.  &
               (mxy(1)%mp(2) == 1 .and.  mxy(1)%mp(3) > 1))
         call fmdivi(mxy(1), 2, mxy(5), qx)
         call fmint(mxy(5), mxy(1), qx)
         call fmsqr2_r1(mxy(2), qx)
         call fmi2m(2, mxy(5), qx)
         call fmmod(mxy(1), mxy(5), mxy(4), qx)
         if (mxy(4)%mp(3) == 1) call fmmpy2_r2(mxy(2), mxy(3), qx)
      enddo
      call fmeq(mxy(3), mc, qx)

      return
      end subroutine fmexp_m2

      subroutine fmexp_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = exp(ma).

!  kresult = 1 is returned if a special case gives the value of exp(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j, k, kl, nds
      double precision :: b, d, xe, xf, ye, yf, z1, z2, ze, zf

      kresult = 0

      qx%namest(qx%ncall) = 'FMEXP    '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

      if (mxy(1)%mp(2) == qx%munkno .and. mxy(1)%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (mxy(1)%mp(2) == qx%munkno) then
          call fmunknown(mxy(3), qx)
          if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          call fmovun_xexf(mxy(1), xe, xf, qx)
          xe = abs(xe)
          ze = log( (huge(qx%mbase)/d) * qx%dlogmb ) / qx%dlogmb
          if (xe > ze) then
              if (mxy(1)%mp(4) > 0) then
                  if (mxy(1)%mp(1) > 0) then
                      call fmoverflow(1, mresult, qx)
                      mresult%mp(4) = huge(qx%mbase)/d
                      mresult%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
                  else
                      call fmunderflow(1, mresult, qx)
                      mresult%mp(4) = -huge(qx%mbase)/d
                      mresult%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
                  endif
              else
                  call fmi2m(1, mresult, qx)
                  if (qx%kround /= 1) then
                      call fmulp(mresult, mxy(3), qx)
                      mxy(3)%mp(2) = mxy(3)%mp(2) - 2
                      if (mxy(1)%mp(1) > 0) then
                          call fmadd_r1(mresult, mxy(3), qx)
                      else
                          call fmsub_r1(mresult, mxy(3), qx)
                      endif
                  endif
                  qx%kflag = 0
              endif
              kresult = 1
              return
          endif

          call fmovun_xexf(mxy(1), xe, xf, qx)
          xe = abs(xe)
          b = qx%mbase
          ye = aint(b**xe * xf / qx%dlogmb) + 1
          yf = b**xe * xf - ye*qx%dlogmb
          if (-2*qx%dlogmb <= yf .and. yf < -qx%dlogmb) then
              ye = ye - 1
              yf = yf + qx%dlogmb
          else if (0 <= yf .and. yf < qx%dlogmb) then
              ye = ye + 1
              yf = yf - qx%dlogmb
          endif
          if (-qx%dlogmb <= yf .and. yf < 0) then
              yf = exp(b**xe * xf - ye*qx%dlogmb)
          else
              yf = 1.0d0 - epsilon(1.0d0)
          endif
          if (mxy(1)%mp(1) < 0) then
              ye = -ye + 1
              yf = 1/(b*yf)
              if (yf == 1) then
                  ye = ye + 1
                  yf = yf / b
              endif
          endif
          mxy(3)%mp(4) = ye
          mxy(3)%mp(5) = -yf*maxint
          if (ye > qx%mxexp0) mxy(3)%mp(2) = qx%mexpov
          if (ye < -qx%mxexp0) mxy(3)%mp(2) = qx%mexpun
          call fmeq(mxy(3), mresult, qx)
          kresult = 1
          return
      endif
      if (mxy(1)%mp(2) == qx%mexpov) then
          if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          if (mxy(1)%mp(1) > 0) then
              call fmoverflow(1, mresult, qx)
              mresult%mp(4) = huge(qx%mbase)/d
              mresult%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
          else
              call fmunderflow(1, mresult, qx)
              mresult%mp(4) = -huge(qx%mbase)/d
              mresult%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
          endif
          kresult = 1
          return
      else if (mxy(1)%mp(3) == 0) then
          call fmi2m(1, mresult, qx)
          kresult = 1
          return
      else if (mxy(1)%mp(2) == qx%mexpun) then
          call fmi2m(1, mresult, qx)
          call fmadd_r1(mresult, mxy(1), qx)
          kresult = 1
          return
      else
          kl = 0
          if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          call fmovun_xexf(mxy(1), xe, xf, qx)
          b = qx%mbase
          z1 = xe*log(b) + log(xf) - log(log(b))
          z2 = log(huge(qx%mbase)/d)
          if (z1 > z2) then
              if (mxy(1)%mp(1) > 0) then
                  call fmoverflow(1, mxy(2), qx)
                  ze = huge(qx%mbase)/d
                  zf = 1.0d0 - epsilon(1.0d0)
              else
                  call fmunderflow(1, mxy(2), qx)
                  ze = -huge(qx%mbase)/d
                  zf = 1.0d0 - epsilon(1.0d0)
              endif
              mxy(2)%mp(4) = ze
              mxy(2)%mp(5) = -maxint * zf
              kl = 1
          else
              if (mxy(1)%mp(1) > 0) then
                  z2 = qx%mxexp+1
                  z2 = log(z2)
                  if (z1 > z2) then
                      call fmoverflow(1, mxy(2), qx)
                      ze = b**xe * xf / log(b)
                      if (ze == ze + 1) then
                          zf = 1.0d0 - epsilon(1.0d0)
                      else
                          z1 = aint(ze)
                          if (ze - z1 == 0) then
                              ze = z1 + 1
                              zf = 1/b
                          else
                              z1 = z1 + 1
                              zf = b**( ze - z1 )
                              ze = z1
                          endif
                      endif
                      if (zf == 0) then
                          ze = ze + 1
                          zf = 1/b
                      endif
                      mxy(2)%mp(4) = ze
                      mxy(2)%mp(5) = -maxint * zf
                      kl = 1
                  endif
              else
                  z2 = qx%mxexp
                  z2 = log(z2)
                  if (z1 > z2) then
                      call fmunderflow(1, mxy(2), qx)
                      ze = -(b**xe * xf / log(b))
                      if (ze == ze + 1) then
                          zf = 1.0d0 - epsilon(1.0d0)
                      else
                          z1 = aint(ze)
                          if (ze - z1 == 0) then
                              ze = z1 + 1
                              zf = 1/b
                          else
                              zf = b**( ze - z1 )
                              ze = z1
                          endif
                      endif
                      if (zf == 0) then
                          ze = ze + 1
                          zf = 1/b
                      endif
                      mxy(2)%mp(4) = ze
                      mxy(2)%mp(5) = -maxint * zf
                      kl = 1
                  endif
              endif
          endif
          if (kl == 1) then
              call fmeq(mxy(2), mresult, qx)
              if (mresult%mp(2) == qx%mexpun) qx%kflag = -6
              kresult = 1
              return
          endif
      endif

      if (qx%ndig > 1000) then
          nds = qx%ndig
          call fmndig(qx%ndig + 100 + qx%ndig/100, qx)
          call fmalloc(qx%mwa, 2*qx%ndig+30, qx)
          call fmndig(nds, qx)
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (qx%kround /= 1 .and. ma%mp(2) < -ndsave) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          call fmi2m(1, mxy(2), qx)
          call fmadd(mxy(2), mxy(1), mresult, qx)
          qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          kresult = 1
          return
      endif

      return
      end subroutine fmexp_sc

      subroutine fmfact(ma, mb, qx)

!  mc = ma!    ( = gamma(ma+1))

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(2), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmfact_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call fmfact_m1(ma, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmfact

      subroutine fmfact_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing ma!.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(2), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      call fmaddi(mxy(1), 1, qx)
      qx%in_fact = 1
      call fmgam(mxy(1), mresult, qx)
      qx%in_fact = 0

      return
      end subroutine fmfact_m1

      subroutine fmfact_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = ma!.

!  kresult = 1 is returned if a special case gives the value of ma!.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(2), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j, k
      double precision :: xe
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMFACT   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      call fmovun_xe(malocal, xe, qx)
      if (qx%kround /= 1 .and. xe < -ndsave) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          call fmeulr(mxy(1), qx)
          qx%ndgeul = 0
          call fmmpy(mxy(1), malocal, mxy(2), qx)
          call fmi2m(1, mxy(1), qx)
          call fmsub(mxy(1), mxy(2), mresult, qx)
          qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          kresult = 1
          return
      endif

      return
      end subroutine fmfact_sc

      subroutine fmfcti(num, ma, qx)

!  ma = num factorial, where num is an integer.

      use fmvals_parallel
      implicit none

      integer :: num
      type(multi) :: ma
      intent (in) :: num
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: j, jk, k, large

      call fmi2m(1, ma, qx)
      if (num <= 1) then
          return
      endif
      j = num
      k = 1
      large = int(intmax/j)
      do jk = 2, j
         k = k*jk
         if (k > large) then
             call fmcsmpyi_r1(ma, k, qx)
             k = 1
         endif
      enddo
      if (k > 1) call fmmpyi_r1(ma, k, qx)

      return
      end subroutine fmfcti

      subroutine fmfft(a, n, a2, roots_of_unity)

!  a is returned as the fast fourier transform of the complex input array a(1:n)

!  This is not a general fft subroutine.  It is designed to be called by fm's multiplication
!  routines.  n will be a small integer times a power of 2.

      use fmvals_parallel
      implicit none
      integer :: n
      complex (kind(0.0d0)) :: roots_of_unity(0:n-1)
      complex (kind(0.0d0)) :: a(n), a2(n)
      intent (in) :: n
      intent (inout) :: a, a2

      complex (kind(0.0d0)) :: ft(15), r_u(0:225), zi
      double precision :: pi
      integer :: h, its, j, jlists, js, jstep, k, k1, k2, l, level, lg, nl
      integer, allocatable :: first(:)

      pi = acos(-1.0d0)
      zi = cmplx( 0.0d0 , 1.0d0 , kind(1.0d0) )
      level = 0
      k = n
      do while (mod(k, 2) == 0)
         level = level + 1
         k = k / 2
      enddo

      nl = 2**level
      lg = n/nl
      allocate( first(nl) )

!             The bottom level is to do the transforms of nl lists of length lg directly from
!             the definition of the Fourier transform.
!             Generate a list of starting points in the original list for these sublists.

      jlists = 1
      first(1) = 1
      h = 1
      do j = 1, level
         do k = jlists, 1, -1
            first(2*k-1) = first(k)
            first(2*k)   = first(k) + h
         enddo
         h = 2*h
         jlists = 2*jlists
      enddo

!             Do the initial transforms.

      do j = 1, nl
         do k = 0, lg-1
            a2(1+k+(j-1)*lg) = a(first(j)+k*h)
         enddo
      enddo

      if (lg > 1) then
          do k = 0, lg-1
             do k2 = 0, lg-1
                r_u(k*k2) = exp((2*pi*zi*k*k2)/lg)
             enddo
          enddo

          do j = 1, nl

!             Do the direct Fourier transform using the definition.
!             The jth sublist has length lg and starts at a2(1+(j-1)*lg).

             do k = 1, 15
                ft(k) = 0
             enddo
             k1 = 1 + (j-1)*lg
             do k = 1, lg
                do k2 = 0, lg-1
                   ft(k) = ft(k) + a2(k2+k1) * r_u((k-1)*k2)
                enddo
             enddo
             do k = 1, lg
                a2(k+(j-1)*lg) = ft(k)
             enddo
          enddo
      endif

!             Iterate, combining pairs of lists using the Cooley-Tukey recurrence until only
!             one list remains.

      its = nint( log( dble(nl) ) / log(2.0d0) )
      jstep = its + 1
      do l = 2, its, 2

         jstep = jstep - 1
         js = -1
         k1 = 2**(jstep-1)
         if (jstep > 1) js = (n / k1) * (k1 - 1) - 1
         do k = 2, nl, 2
            k1 = (k-2)*lg
            k2 = k1 + lg
            do j = 1, lg
               a(j+k1) = a2(j+k1) + roots_of_unity(j+js) * a2(j+k2)
               a(j+k2) = a2(j+k1) - roots_of_unity(j+js) * a2(j+k2)
            enddo
         enddo

         lg = 2 * lg
         nl = nl / 2
         jstep = jstep - 1
         js = -1
         k1 = 2**(jstep-1)
         if (jstep > 1) js = (n / k1) * (k1 - 1) - 1
         do k = 2, nl, 2
            k1 = (k-2)*lg
            k2 = k1 + lg
            do j = 1, lg
               a2(j+k1) = a(j+k1) + roots_of_unity(j+js) * a(j+k2)
               a2(j+k2) = a(j+k1) - roots_of_unity(j+js) * a(j+k2)
            enddo
         enddo

         lg = 2 * lg
         nl = nl / 2

      enddo

      if (mod(its, 2) == 0) then
          do j = 1, n
             a(j) = a2(j)
          enddo
      else
          jstep = jstep - 1
          js = -1
          k1 = 2**(jstep-1)
          if (jstep > 1) js = (n / k1) * (k1 - 1) - 1
          do k = 2, nl, 2
             k1 = (k-2)*lg
             k2 = k1 + lg
             do j = 1, lg
                a(j+k1) = a2(j+k1) + roots_of_unity(j+js) * a2(j+k2)
                a(j+k2) = a2(j+k1) - roots_of_unity(j+js) * a2(j+k2)
             enddo
          enddo
      endif

      deallocate( first )

      return
      end subroutine fmfft

      subroutine fmfft_init(n, roots_of_unity)

!  Initialize roots of unity.

      use fmvals_parallel
      implicit none
      integer :: n
      complex (kind(0.0d0)) :: roots_of_unity(0:n-1)
      intent (in) :: n

      complex (kind(0.0d0)) :: s, st
      double precision :: pi, t
      integer :: its, j, js, jstep, k, l, level, nr, n_def

!     if (n_roots_of_unity == n) return

      level = 0
      k = n
      do while (mod(k, 2) == 0)
         level = level + 1
         k = k / 2
      enddo

      n_def = n / 2**level
      if (n < n_def) n_def = n
      its = nint( log( dble(n) / n_def ) / log(2.0d0) )

!             Compute the roots of unity.

      pi = acos(-1.0d0)
      t = 2*pi/n
      st = cmplx(-2*sin(pi/n)**2, sin(2*pi/n), kind(0.0d0) )
      nr = n/2
      jstep = 32
      do k = 0, nr/jstep - 1
         js = k*jstep
         s = cmplx( cos(js*t) , sin(js*t) , kind(0.0d0) )
         do j = 0, jstep - 1
            roots_of_unity(j+js) = s
            s = s + st*s
         enddo
      enddo
      k = (nr/jstep)*jstep
      do j = k, nr-1
         roots_of_unity(j) = cmplx( cos(j*t) , sin(j*t) , kind(0.0d0) )
      enddo
      l = nr - 1
      do j = 2, its
         jstep = 2**(j-1)
         do k = 0, nr-1, jstep
            l = l + 1
            roots_of_unity(l) = roots_of_unity(k)
         enddo
      enddo

      end subroutine fmfft_init

      subroutine fmfgfi(ma, mb, mc, qx)

!  Internal routine for the two auxiliary asymptotic series used in the sine and cosine
!  Fresnel integral functions.

!  For x = ma the two values returned are mb and mc, where

!  mb = f(x) = (1 - 1*3/(pi*x*x)**2 + 1*3*5*7/(pi*x*x)**4 - ...) / (pi*x)
!  mc = g(x) = (1 - 1*3*5/(pi*x*x)**2 + 1*3*5*7*9/(pi*x*x)**4 - ...) / (pi**2*x**3)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      type(fm_settings) :: qx

      integer :: j, j2, jterms, kl, nbot, ndsav1, nterm, nterms
      double precision :: x, xe, ye
      double precision, external :: fmnterms
      type(multi) :: mxy(6), mjsums(ljsums)

      call fmalloc(mb, qx%ndig+2, qx)
      call fmalloc(mc, qx%ndig+2, qx)

      nterms = int(intmax/10)
      call fmm2dp(ma, x, qx)
      if (qx%kflag == 0) then
          j2 = int(0.35*sqrt(fmnterms(3.14159d0*x*x/2, 2, 0, 0, 0, qx)) - 0.2)
          j2 = max(2, min(j2+mod(j2, 2), ljsums/2))
      else
          j2 = 2
      endif
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums for f(x) and another j2 concurrent sums for g(x).
!             Because the two sums use the same powers of x, the calculations for f and g
!             are interleaved.

      call fmi2m(1, mxy(4), qx)
      call fmdiv(mxy(4), ma, mxy(2), qx)
      call fmsqr(mxy(2), mxy(6), qx)
      call fmpi(mxy(1), qx)
      qx%ndigpi = 0
      call fmdiv(mxy(6), mxy(1), mxy(2), qx)
      call fmsqr(mxy(2), mxy(6), qx)
      nterm = 0
      do j = 1, j2
         nbot = 2*nterm - 1
         if (nterm >= 2) call fmcsmpyi_r1(mxy(4), nbot, qx)
         call fmeq(mxy(4), mjsums(j), qx)
         nterm = nterm + 1

         nbot = 2*nterm - 1
         if (nterm >= 2) call fmcsmpyi_r1(mxy(4), nbot, qx)
         call fmeq(mxy(4), mjsums(j2+j), qx)
         nterm = nterm + 1
      enddo
      call fmovun_xe(mxy(6), xe, qx)
      call fmovun_xe(mxy(4), ye, qx)
      if (xe + ye < -qx%ndig-3) then
          kl = 0
      else
          call fmipwr(mxy(6), j2, mxy(3), qx)
          kl = 1
      endif

      if (kl == 1) then
          do jterms = 1, nterms
             call fmcsmpy_r1(mxy(4), mxy(3), qx)
             do j = 1, j2
                nbot = 2*nterm - 1
                call fmcsmpyi_r1(mxy(4), nbot, qx)
                call fmndig(ndsav1, qx)
                call fmcsaddnn_r1(mjsums(j), mxy(4), qx)
                if (qx%kflag /= 0) then
                    kl = 0
                    exit
                endif
                call fmndig(max(qx%ngrd22, ndsav1-int(mjsums(j)%mp(2) - mxy(4)%mp(2))), qx)
                call fmndig(min(ndsav1, qx%ndig), qx)
                if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                nterm = nterm + 1

                nbot = 2*nterm - 1
                call fmcsmpyi_r1(mxy(4), nbot, qx)
                call fmndig(ndsav1, qx)
                call fmcsaddnn_r1(mjsums(j2+j), mxy(4), qx)
                if (qx%kflag /= 0) then
                    kl = 0
                    exit
                endif
                call fmndig(max(qx%ngrd22, ndsav1-int(mjsums(j2+j)%mp(2) - mxy(4)%mp(2))), qx)
                call fmndig(min(ndsav1, qx%ndig), qx)
                if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                nterm = nterm + 1
             enddo
             if (kl == 0) exit
             if (jterms == nterms) then
                 call fmunknown(mb, qx)
                 call fmunknown(mc, qx)
                 return
             endif
          enddo
      endif

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmcsnsums(2*j2, mjsums, qx)
      call fmeq(mjsums(j2), mxy(3), qx)
      call fmeq(mjsums(j2+j2), mxy(5), qx)
      call fmnegate(mxy(6), qx)
      do j = 2, j2
         call fmcsmpy_r1(mxy(3), mxy(6), qx)
         call fmadd_r1(mxy(3), mjsums(j2-j+1), qx)

         call fmcsmpy_r1(mxy(5), mxy(6), qx)
         call fmadd_r1(mxy(5), mjsums(j2+j2-j+1), qx)
      enddo
      call fmmpy(ma, mxy(1), mxy(2), qx)
      call fmdiv(mxy(3), mxy(2), mb, qx)

      call fmsqr(mxy(2), mxy(3), qx)
      call fmmpy(mxy(3), ma, mxy(2), qx)
      call fmdiv(mxy(5), mxy(2), mc, qx)

      call fmndig(ndsav1, qx)

      return
      end subroutine fmfgfi

      subroutine fmfhgh(ma, mb, mc, qx)

!  Internal routine for the two auxiliary asymptotic series used in the hyperbolic sine and
!  cosine integral functions.

!  for x = ma the two values returned are mb and mc, where

!  mb = f(x) = (1 + 2!/x**2 + 4!/x**4 + ...) / x
!  mc = g(x) = (1 + 3!/x**2 + 5!/x**4 + ...) / x**2

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      type(fm_settings) :: qx

      integer :: j, j2, jterms, kl, nbot, ndsav1, nterm, nterms
      double precision :: x, xe, ye
      type(multi) :: mxy(5), mjsums(ljsums)
      double precision, external :: fmnterms

      call fmalloc(mb, qx%ndig+2, qx)
      call fmalloc(mc, qx%ndig+2, qx)

      nterms = int(intmax/10)
      call fmm2dp(ma, x, qx)
      if (qx%kflag == 0) then
          j2 = int(0.30*sqrt(fmnterms(x, 2, 0, 0, 0, qx)) + 0.8)
          j2 = max(1, min(ljsums/2, j2))
      else
          j2 = 1
      endif
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums for f(x) and another j2 concurrent sums for g(x).
!             Because the two sums use the same powers of x, the calculations for f and g
!             are interleaved.

      call fmi2m(1, mxy(3), qx)
      call fmdiv(mxy(3), ma, mxy(1), qx)
      call fmsqr(mxy(1), mxy(5), qx)
      nterm = 0
      do j = 1, j2
         nbot = nterm
         if (nterm >= 2) call fmcsmpyi_r1(mxy(3), nbot, qx)
         call fmeq(mxy(3), mjsums(j), qx)
         nterm = nterm + 1

         if (nterm >= 2) call fmcsmpyi_r1(mxy(3), nterm, qx)
         call fmeq(mxy(3), mjsums(j2+j), qx)
         nterm = nterm + 1
      enddo
      call fmovun_xe(mxy(5), xe, qx)
      call fmovun_xe(mxy(3), ye, qx)
      if (xe + ye < -qx%ndig-3) then
          kl = 0
      else
          call fmipwr(mxy(5), j2, mxy(2), qx)
          kl = 1
      endif

      if (kl == 1) then
          do jterms = 1, nterms
             call fmcsmpy_r1(mxy(3), mxy(2), qx)
             do j = 1, j2
                nbot = nterm
                call fmcsmpyi_r1(mxy(3), nbot, qx)
                call fmndig(ndsav1, qx)
                call fmcsaddnn_r1(mjsums(j), mxy(3), qx)
                if (qx%kflag /= 0) then
                    kl = 0
                    exit
                endif
                call fmndig(max(qx%ngrd22, ndsav1-int(mjsums(j)%mp(2) - mxy(3)%mp(2))), qx)
                call fmndig(min(ndsav1, qx%ndig), qx)
                if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                nterm = nterm + 1

                call fmcsmpyi_r1(mxy(3), nterm, qx)
                call fmndig(ndsav1, qx)
                call fmcsaddnn_r1(mjsums(j2+j), mxy(3), qx)
                if (qx%kflag /= 0) then
                    kl = 0
                    exit
                endif
                call fmndig(max(qx%ngrd22, ndsav1-int(mjsums(j2+j)%mp(2) - mxy(3)%mp(2))), qx)
                call fmndig(min(ndsav1, qx%ndig), qx)
                if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                nterm = nterm + 1
                if (jterms == nterms) then
                    call fmunknown(mb, qx)
                    call fmunknown(mc, qx)
                    return
                endif
             enddo
             if (kl == 0) exit
          enddo
      endif

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmcsnsums(2*j2, mjsums, qx)
      call fmeq(mjsums(j2), mxy(2), qx)
      call fmeq(mjsums(2*j2), mxy(4), qx)
      do j = 2, j2
         call fmcsmpy_r1(mxy(2), mxy(5), qx)
         call fmadd_r1(mxy(2), mjsums(j2-j+1), qx)

         call fmcsmpy_r1(mxy(4), mxy(5), qx)
         call fmadd_r1(mxy(4), mjsums(j2+j2-j+1), qx)
      enddo
      call fmdiv(mxy(2), ma, mb, qx)
      call fmmpy(mxy(4), mxy(5), mc, qx)

      call fmndig(ndsav1, qx)

      return
      end subroutine fmfhgh

      function fmfi(n)

!  Format integers for trace output.

      implicit none

      character(40) :: fmfi
      integer :: n
      intent (in) :: n

      character(40) :: temp
      integer :: j

      fmfi = ' '
      write (temp,*) n
      do j = 1, 40
         if (temp(j:j) /= ' ') then
             fmfi(1:41-j) = temp(j:40)
             return
         endif
      enddo

      return
      end function fmfi

      subroutine fmflag(k, qx)

!  Return the internal condition variable kflag to the user.

      use fmvals_parallel
      implicit none

      integer :: k
      intent (inout) :: k
      type(fm_settings) :: qx

      k = qx%kflag

      return
      end subroutine fmflag

      subroutine fmform(form, ma, string, qx)

!  convert an fm number (ma) to a character string base 10 (string) using character string
!  form format.

!  form can be one of these types:  iw,  fw.d,  ew.d,  esw.d,  1pew.d  for positive integers w,d.

!  if iw format is used and ma is not exactly an integer, then the nearest integer to ma is printed.

      use fmvals_parallel
      implicit none

      character :: cmbuff(lmbuff)
      character(*) :: form, string
      type(multi) :: ma
      intent (in) :: form, ma
      intent (inout) :: string
      type(fm_settings) :: qx
      double precision :: val
      integer :: j, jf1sav, jf2sav, jpt, k1, k2, k3, kd, ksave, kwd, kwi, last, lb, lengfm,  &
                 lengst, lfirst, nd, nexp
      type(multi) :: mxy(1)


      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMFORM'

      ksave = qx%kflag
      jf1sav = qx%jform1
      jf2sav = qx%jform2
      string = ' '
      lengfm = len(form)
      lengst = len(string)
      kwi = 75
      kwd = 40

      if (index(form, 'I') > 0 .or. index(form, 'i') > 0) then
          k1 = max(index(form, 'I'), index(form, 'i')) + 1
          k2 = lengfm
          if (k2 >= k1) then
              call fmst2d(form(k1:k2), val, qx)
              kwi = nint(val)
          else
              kwi = lengst
          endif
          kwi = max(1, min(kwi, lengst))
          qx%jform1 = 2
          qx%jform2 = 0
          kwd = kwi + 21
          if (kwd+50 > lmbuff) then
              write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                                  " Raise its size (lmbuff) or change the format being used."
              stop
          endif
          call fmnint(ma, mxy(1), qx)
          if (mxy(1)%mp(3) /= 0) then
              call fmout(mxy(1), cmbuff, kwd, qx)
          else
              do j = 1, kwd
                 cmbuff(j) = ' '
              enddo
              cmbuff(2) = '0'
          endif
          lfirst = 1
          last = 1
          do j = 1, kwd
             if (cmbuff(kwd+1-j) /= ' ') lfirst = kwd+1-j
             if (cmbuff(j) /= ' ') last = j
          enddo
          jpt = 1
          if (last-lfirst+1 > kwi) then
              call fmform_err(string, lengst, jf1sav, jf2sav, qx)
              return
          endif
          if (last <= kwi) then
              do j = last, lfirst, -1
                 jpt = kwi - last + j
                 string(jpt:jpt) = cmbuff(j)
              enddo
              do j = 1, jpt-1
                 string(j:j) = ' '
              enddo
          else
              do j = lfirst, last
                 jpt = kwi - last + j
                 string(jpt:jpt) = cmbuff(j)
              enddo
          endif
      else if (index(form, 'F') > 0 .or. index(form, 'f') > 0) then
          k1 = max(index(form, 'F'), index(form, 'f')) + 1
          k2 = index(form, '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val, qx)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val, qx)
              kd = nint(val)
          else
              kd = 0
          endif
          kwi = max(1, min(kwi, lengst))
          kd = max(0, min(kd, kwi-2))
          qx%jform1 = 2
          qx%jform2 = kd
          nd = int(real(qx%ndig)*log10(real(qx%mbase))) + 1
          if (nd < 2) nd = 2
          nexp = int(2.0*log10(real(mxbase))) + 16
          lb = max(qx%jform2+nexp, nd+nexp)
          kwd = lb
          if (kwd+50 > lmbuff) then
              write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                                  " Raise its size (lmbuff) or change the format being used."
              stop
          endif
          call fmout(ma, cmbuff, kwd, qx)
          lfirst = 1
          last = 1
          do j = 1, kwd
             if (cmbuff(kwd+1-j) /= ' ') lfirst = kwd+1-j
             if (cmbuff(j) /= ' ') last = j
          enddo
          if (last-lfirst+1 > kwi) then

!             Not enough room for this f format, or fmout converted it to e format to avoid showing
!             no significant digits.  See if a shortened form will fit in e format.

              nexp = int(log10((abs(real(ma%mp(2)))+1)*log10(real(qx%mbase))+1)+1)
              nd = kwi - nexp - 5
              if (nd < 1) then
                  call fmform_err(string, lengst, jf1sav, jf2sav, qx)
                  return
              else
                  qx%jform1 = 0
                  qx%jform2 = nd
                  if (kwi+50 > lmbuff) then
                      write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                                          " Raise its size (lmbuff) or change the format being used."
                      stop
                  endif
                  call fmout(ma, cmbuff, kwi, qx)
                  lfirst = 1
                  last = 1
                  do j = 1, kwi
                     if (cmbuff(kwi+1-j) /= ' ') lfirst = kwi+1-j
                     if (cmbuff(j) /= ' ') last = j
                  enddo
              endif
          endif
          jpt = 1
          if (last <= kwi) then
              do j = last, lfirst, -1
                 jpt = kwi - last + j
                 string(jpt:jpt) = cmbuff(j)
              enddo
              do j = 1, jpt-1
                 string(j:j) = ' '
              enddo
          else
              do j = lfirst, last
                 jpt = kwi - last + j
                 string(jpt:jpt) = cmbuff(j)
              enddo
          endif
      else if (index(form, '1PE') > 0 .or. index(form, '1pe') > 0 .or. index(form, 'ES') > 0 .or.  &
               index(form, 'es') > 0) then
          if (index(form, '1PE') > 0 .or. index(form, '1pe') > 0) then
              k1 = max(index(form, 'E'), index(form, 'e')) + 1
          else
              k1 = max(index(form, 'S'), index(form, 's')) + 1
          endif
          k2 = index(form, '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val, qx)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val, qx)
              kd = nint(val)
          else
              kd = 0
          endif
          kwi = max(1, min(kwi, lengst))
          kd = max(0, min(kd, kwi-2))
          qx%jform1 = 1
          qx%jform2 = kd + 1
          if (kwi+50 > lmbuff) then
              write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                                  " Raise its size (lmbuff) or change the format being used."
              stop
          endif
          call fmout(ma, cmbuff, kwi, qx)
          do j = kwi, 1, -1
             if (j > lengst) then
                 if (cmbuff(j) /= ' ') then
                     call fmform_err(string, lengst, jf1sav, jf2sav, qx)
                     return
                 endif
             else
                 string(j:j) = cmbuff(j)
             endif
          enddo
      else if (index(form, 'E') > 0 .or. index(form, 'e') > 0) then
          k1 = max(index(form, 'E'), index(form, 'e')) + 1
          k2 = index(form, '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val, qx)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val, qx)
              kd = nint(val)
          else
              kd = 0
          endif
          kwi = max(1, min(kwi, lengst))
          kd = max(0, min(kd, kwi-2))
          qx%jform1 = 0
          qx%jform2 = kd
          if (kwi+50 > lmbuff) then
              write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                                  " Raise its size (lmbuff) or change the format being used."
              stop
          endif
          call fmout(ma, cmbuff, kwi, qx)
          do j = kwi, 1, -1
             if (j > lengst) then
                 if (cmbuff(j) /= ' ') then
                     call fmform_err(string, lengst, jf1sav, jf2sav, qx)
                     return
                 endif
             else
                 string(j:j) = cmbuff(j)
             endif
          enddo
      else
          call fmform_err(string, lengst, jf1sav, jf2sav, qx)
          return
      endif

      qx%kflag = ksave
      qx%jform1 = jf1sav
      qx%jform2 = jf2sav
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmform

      subroutine fmform_err(string, n, jf1sav, jf2sav, qx)

!  If an error occurs during input conversion, return string = '***...***'

      use fmvals_parallel
      implicit none

      character(*) :: string
      integer :: n, jf1sav, jf2sav
      intent (in) :: n, jf1sav, jf2sav
      intent (inout) :: string
      type(fm_settings) :: qx

      integer :: j

      qx%kflag = -8
      do j = 1, n
         string(j:j) = '*'
      enddo

      qx%jform1 = jf1sav
      qx%jform2 = jf2sav
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmform_err

      subroutine fmfprint(form, ma, qx)

      use fmvals_parallel
      implicit none

      character(*) :: form
      type(multi) :: ma
      intent (in) :: form, ma
      type(fm_settings) :: qx

      call fmfprt(form, ma, qx)

      return
      end subroutine fmfprint

      subroutine fmfprt(form, ma, qx)

!  print an fm number (ma) on unit kw using character string form format.

!  form can be one of these types:  iw,  fw.d,  ew.d,  esw.d,  1pew.d  for positive integers w,d.

!  if iw format is used and ma is not exactly an integer, then the nearest integer to ma is printed.

      use fmvals_parallel
      implicit none

      character :: cmbuff(lmbuff)
      character(*) :: form
      type(multi) :: ma
      intent (in) :: form, ma
      type(fm_settings) :: qx

      character(20) :: form2
      double precision :: val
      integer :: j, jf1sav, jf2sav, jpt, k, k1, k2, k3, kd, ksave, kwd, kwi, last, lb,  &
                 lengfm, lfirst, nd, nexp
      type(multi) :: mxy(1)


      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMFPRT'

      ksave = qx%kflag
      jf1sav = qx%jform1
      jf2sav = qx%jform2
      lengfm = len(form)
      kwi = 75
      kwd = 40

      if (index(form, 'I') > 0 .or. index(form, 'i') > 0) then
          k1 = max(index(form, 'I'), index(form, 'i')) + 1
          k2 = lengfm
          if (k2 >= k1) then
              call fmst2d(form(k1:k2), val, qx)
              kwi = nint(val)
          else
              kwi = 50
          endif
          qx%jform1 = 2
          qx%jform2 = 0
          kwd = kwi + 21
          if (kwd+50 > lmbuff) then
              write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                                  " Raise its size (lmbuff) or change the format being used."
              stop
          endif
          call fmnint(ma, mxy(1), qx)
          if (mxy(1)%mp(3) /= 0) then
              call fmout(mxy(1), cmbuff, kwd, qx)
          else
              do j = 1, kwd
                 cmbuff(j) = ' '
              enddo
              cmbuff(2) = '0'
          endif
          lfirst = 1
          last = 1
          do j = 1, kwd
             if (cmbuff(kwd+1-j) /= ' ') lfirst = kwd+1-j
             if (cmbuff(j) /= ' ') last = j
          enddo
          jpt = 1
          if (last-lfirst+1 > kwi) then
              call fmfprt_err(kwi, jf1sav, jf2sav, qx)
              return
          endif
          if (last <= kwi) then
              do j = last, lfirst, -1
                 jpt = kwi - last + j
                 if (jpt /= j) cmbuff(jpt) = cmbuff(j)
              enddo
              do j = 1, jpt-1
                 cmbuff(j) = ' '
              enddo
          else
              do j = lfirst, last
                 jpt = kwi - last + j
                 if (jpt /= j) cmbuff(jpt) = cmbuff(j)
              enddo
          endif
      else if (index(form, 'F') > 0 .or. index(form, 'f') > 0) then
          k1 = max(index(form, 'F'), index(form, 'f')) + 1
          k2 = index(form(1:lengfm), '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val, qx)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val, qx)
              kd = nint(val)
          else
              kd = 0
          endif
          kd = max(0, min(kd, kwi-2))
          qx%jform1 = 2
          qx%jform2 = kd
          nd = int(real(qx%ndig)*log10(real(qx%mbase))) + 1
          if (nd < 2) nd = 2
          nexp = int(2.0*log10(real(mxbase))) + 16
          lb = max(qx%jform2+nexp, nd+nexp)
          kwd = lb
          if (kwd+50 > lmbuff) then
              write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                                  " Raise its size (lmbuff) or change the format being used."
              stop
          endif
          call fmout(ma, cmbuff, kwd, qx)
          lfirst = 1
          last = 1
          do j = 1, kwd
             if (cmbuff(kwd+1-j) /= ' ') lfirst = kwd+1-j
             if (cmbuff(j) /= ' ') last = j
          enddo
          if (last-lfirst+1 > kwi) then

!             Not enough room for this f format, or fmout converted it to e format to avoid showing
!             no significant digits.  See if a shortened form will fit in e format.

              nexp = int(log10((abs(real(ma%mp(2)))+1)*log10(real(qx%mbase))+1)+1)
              nd = kwi - nexp - 5
              if (nd < 1) then
                  call fmfprt_err(kwi, jf1sav, jf2sav, qx)
                  return
              else
                  qx%jform1 = 0
                  qx%jform2 = nd
                  if (kwi+50 > lmbuff) then
                      write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                                          " Raise its size (lmbuff) or change the format being used."
                      stop
                  endif
                  call fmout(ma, cmbuff, kwi, qx)
                  lfirst = 1
                  last = 1
                  do j = 1, kwi
                     if (cmbuff(kwi+1-j) /= ' ') lfirst = kwi+1-j
                     if (cmbuff(j) /= ' ') last = j
                  enddo
              endif
          endif
          jpt = 1
          if (last <= kwi) then
              do j = last, lfirst, -1
                 jpt = kwi - last + j
                 if (jpt /= j) cmbuff(jpt) = cmbuff(j)
              enddo
              do j = 1, jpt-1
                 cmbuff(j) = ' '
              enddo
          else
              do j = lfirst, last
                 jpt = kwi - last + j
                 if (jpt /= j) cmbuff(jpt) = cmbuff(j)
              enddo
          endif
      else if (index(form, '1PE') > 0 .or. index(form, '1pe') > 0 .or. index(form, 'ES') > 0 .or.  &
               index(form, 'es') > 0) then
          if (index(form, '1PE') > 0 .or. index(form, '1pe') > 0) then
              k1 = max(index(form, 'E'), index(form, 'e')) + 1
          else
              k1 = max(index(form, 'S'), index(form, 's')) + 1
          endif
          k2 = index(form(1:lengfm), '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val, qx)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val, qx)
              kd = nint(val)
          else
              kd = 0
          endif
          kd = max(0, min(kd, kwi-2))
          qx%jform1 = 1
          qx%jform2 = kd + 1
          if (kwi+50 > lmbuff) then
              write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                                  " Raise its size (lmbuff) or change the format being used."
              stop
          endif
          call fmout(ma, cmbuff, kwi, qx)
      else if (index(form, 'E') > 0 .or. index(form, 'e') > 0) then
          k1 = max(index(form, 'E'), index(form, 'e')) + 1
          k2 = index(form(1:lengfm), '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val, qx)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val, qx)
              kd = nint(val)
          else
              kd = 0
          endif
          kd = max(0, min(kd, kwi-2))
          qx%jform1 = 0
          qx%jform2 = kd
          if (kwi+50 > lmbuff) then
              write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                                  " Raise its size (lmbuff) or change the format being used."
              stop
          endif
          call fmout(ma, cmbuff, kwi, qx)
      else
          call fmfprt_err(kwi, jf1sav, jf2sav, qx)
          return
      endif

      write (form2, "(' (6X, ', I3, 'A1) ')") qx%kswide-7
      if (qx%kflag /= -8) qx%kflag = ksave
      qx%jform1 = jf1sav
      qx%jform2 = jf2sav
      do j = kwi, 1, -1
         if (cmbuff(j) /= ' ' .or. j == 1) then
             write (qx%kw, form2) (cmbuff(k), k=1, j)
             exit
         endif
      enddo
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmfprt

      subroutine fmfprt_err(kwi, jf1sav, jf2sav, qx)

!  If an error occurs during input conversion, return string = '***...***'

      use fmvals_parallel
      implicit none

      character :: cmbuff(lmbuff)
      integer :: kwi, jf1sav, jf2sav
      intent (in) :: kwi, jf1sav, jf2sav
      type(fm_settings) :: qx

      integer :: j, k
      character(20) :: form2

      qx%kflag = -8
      do j = 1, kwi
         cmbuff(j) = '*'
      enddo

      write (form2, "(' (6X, ', I3, 'A1) ')") qx%kswide-7
      qx%jform1 = jf1sav
      qx%jform2 = jf2sav
      do j = kwi, 1, -1
         if (cmbuff(j) /= ' ' .or. j == 1) then
             write (qx%kw, form2) (cmbuff(k), k=1, j)
             qx%ncall = qx%ncall - 1
             return
         endif
      enddo
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmfprt_err

      subroutine fmfxgx(ma, mb, mc, qx)

!  Internal routine for the two auxiliary asymptotic series used in the sine and
!  cosine integral functions.

!  for x = ma the two values returned are mb and mc, where

!  mb = f(x) = (1 - 2!/x**2 + 4!/x**4 - ...) / x
!  mc = g(x) = (1 - 3!/x**2 + 5!/x**4 - ...) / x**2

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      type(fm_settings) :: qx

      integer :: j, j2, jterms, kl, ndsav1, nterm, nterms
      double precision :: x, xe, ye
      type(multi) :: mxy(5), mjsums(ljsums)
      double precision, external :: fmnterms

      call fmalloc(mb, qx%ndig+2, qx)
      call fmalloc(mc, qx%ndig+2, qx)

      nterms = int(intmax/10)
      call fmm2dp(ma, x, qx)
      if (qx%kflag == 0) then
          j2 = int(0.38*sqrt(fmnterms(x, 2, 0, 0, 0, qx)) - 0.2)
          j2 = max(2, min(j2+mod(j2, 2), ljsums/2))
      else
          j2 = 2
      endif
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums for f(x) and another j2 concurrent sums for g(x).
!             Because the two sums use the same powers of x, the calculations for f and g
!             are interleaved.

      call fmi2m(1, mxy(3), qx)
      call fmdiv(mxy(3), ma, mxy(1), qx)
      call fmsqr(mxy(1), mxy(5), qx)
      nterm = 0
      do j = 1, j2
         if (nterm >= 2) call fmcsmpyi_r1(mxy(3), nterm, qx)
         call fmeq(mxy(3), mjsums(j), qx)
         nterm = nterm + 1

         if (nterm >= 2) call fmcsmpyi_r1(mxy(3), nterm, qx)
         call fmeq(mxy(3), mjsums(j2+j), qx)
         nterm = nterm + 1
      enddo
      call fmovun_xe(mxy(5), xe, qx)
      call fmovun_xe(mxy(3), ye, qx)
      if (xe + ye < -qx%ndig-3) then
          kl = 0
      else
          call fmipwr(mxy(5), j2, mxy(2), qx)
          kl = 1
      endif

      if (kl == 1) then
          do jterms = 1, nterms
             call fmcsmpy_r1(mxy(3), mxy(2), qx)
             do j = 1, j2
                call fmcsmpyi_r1(mxy(3), nterm, qx)
                call fmndig(ndsav1, qx)
                call fmcsaddnn_r1(mjsums(j), mxy(3), qx)
                if (qx%kflag /= 0) then
                    kl = 0
                    exit
                endif
                call fmndig(max(qx%ngrd22, ndsav1-int(mjsums(j)%mp(2) - mxy(3)%mp(2))), qx)
                call fmndig(min(ndsav1, qx%ndig), qx)
                if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                nterm = nterm + 1

                call fmcsmpyi_r1(mxy(3), nterm, qx)
                call fmndig(ndsav1, qx)
                call fmcsaddnn_r1(mjsums(j2+j), mxy(3), qx)
                if (qx%kflag /= 0) then
                    kl = 0
                    exit
                endif
                call fmndig(max(qx%ngrd22, ndsav1-int(mjsums(j2+j)%mp(2) - mxy(3)%mp(2))), qx)
                call fmndig(min(ndsav1, qx%ndig), qx)
                if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                nterm = nterm + 1
                if (jterms == nterms) then
                    call fmunknown(mb, qx)
                    call fmunknown(mc, qx)
                    return
                endif
             enddo
             if (kl == 0) exit
          enddo
      endif

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmcsnsums(2*j2, mjsums, qx)
      call fmeq(mjsums(j2), mxy(2), qx)
      call fmeq(mjsums(j2+j2), mxy(4), qx)
      call fmnegate(mxy(5), qx)
      do j = 2, j2
         call fmcsmpy_r1(mxy(2), mxy(5), qx)
         call fmadd_r1(mxy(2), mjsums(j2-j+1), qx)

         call fmcsmpy_r1(mxy(4), mxy(5), qx)
         call fmadd_r1(mxy(4), mjsums(j2+j2-j+1), qx)
      enddo
      call fmdiv(mxy(2), ma, mb, qx)
      mxy(5)%mp(1) = 1
      call fmmpy(mxy(4), mxy(5), mc, qx)

      call fmndig(ndsav1, qx)

      return
      end subroutine fmfxgx

      subroutine fmgam(ma, mb, qx)

!  mc = gamma(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(17), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      if (qx%in_fact == 1) qx%ndig = ndsave
      call fmgam_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fmgam_m(ma, mxy, mresult, ndsave, numtry, qx)
         qx%ndggam = 0
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmgam

      subroutine fmgam_c(ndig_c, mbase_c, c, qx)

!  Initialize the constants used in the gamma polynomial.

      use fmvals_parallel
      implicit none

      type(multi) :: c(0:196)
      integer :: ndig_c
      real (kind(1.0d0)) :: mbase_c
      intent (inout) :: c, ndig_c, mbase_c
      type(fm_settings) :: qx

      integer :: ndsave
      character(220) :: st

      ndsave = qx%ndig
      call fmndig(max(qx%ndig, nint(210*qx%dlogtn/qx%dlogmb)), qx)
      ndig_c = qx%ndig
      mbase_c = qx%mbase

      st = " 2 "
      call fmst2m(st, c(0), qx)
      st = " 1.845568670196934278786975819835195137915681328120152802388465530" //  &
           "230264546444670658126105873416506500970737105500385835038078991971" //  &
           "02691432755165200471015292749299933251412532452465211441480948350581017M+0"
      call fmst2m(st, c(1), qx)
      st = " 1.246464995951346528971255032754062122751889033636657384469089862" //  &
           "717670083765963530684050979376234434063149542816318341831199882570" //  &
           "54136293454241409125655601075903604372266188019198826399323980756659507M+0"
      call fmst2m(st, c(2), qx)
      st = " 5.749941689206122275465545297069514629181683280995911506411578080" //  &
           "726118046263102563376406423582057300595042023225863076035376079997" //  &
           "58104823944616583929664137138189407083120305067949277678404599957423943M-1"
      call fmst2m(st, c(3), qx)
      st = " 2.300749407541140630184757374755110638744965329574536384291172327" //  &
           "224547634301735916779398033223621567106468104559113876289562540922" //  &
           "49810183476230067472728208959273220898874770326648720581128183324434328M-1"
      call fmst2m(st, c(4), qx)
      st = " 7.371504661602386878317788712652808511825657580343462427360683175" //  &
           "509260544574956944742301697314778437297368730369274995615677873789" //  &
           "35133238331475104267889872993214666032986278826546933416543800481312385M-2"
      call fmst2m(st, c(5), qx)
      st = " 2.204110936751696733001055930504381988327566876073187686154801967" //  &
           "909973103233273981903764688650115297934327575508639951789708251337" //  &
           "92707722587521058280471694968009955629145006098566559417433720825728363M-2"
      call fmst2m(st, c(6), qx)
      st = " 5.448754075820309416743506865467445124448139461938118242185774040" //  &
           "091229588005782816224467061542163141883870132680748064163312525326" //  &
           "79285947455982778971828128624591203392889667559929450792010659863151692M-3"
      call fmst2m(st, c(7), qx)
      st = " 1.355220860239435200782800511692912879531376156061699075016521316" //  &
           "639789508602632933261809843993626303860552687494426922068347662436" //  &
           "50638664308894605216771132545723510121680479395222846647397509645416658M-3"
      call fmst2m(st, c(8), qx)
      st = " 2.647856630454963762916703027588487719988377646494592862588577877" //  &
           "670108768701128952589855350528375734341831836105261848089596212014" //  &
           "43438318203511988335596380750860411655605437077878364306986421443576571M-4"
      call fmst2m(st, c(9), qx)
      st = " 6.120306281920072864297933044336079606323020239995311203374612431" //  &
           "474530317806041317622369821667524651305326663533305730887143946711" //  &
           "61266460849960962516510977842732486514289292246744768624817147886489117M-5"
      call fmst2m(st, c(10), qx)
      st = " 8.505579174881354789674853004022777303159200477826996950880457101" //  &
           "421412876328884015915508261943090083057713903043228932335601231203" //  &
           "40141960454601937991265277526358454689641320642200080030286310049533045M-6"
      call fmst2m(st, c(11), qx)
      st = " 2.406177240131441866815352548925218907359016756341071832415175589" //  &
           "258269044824185640836078834625474374503849871861065571818953770220" //  &
           "34975008487473056363745663434694457043463856223590513289898353487696130M-6"
      call fmst2m(st, c(12), qx)
      st = " 8.802390990648096801589149015845004893557805933708362167755975543" //  &
           "372057695537675243732864757390172399681575843089705450975708832670" //  &
           "47894590480007482518734894597525237926945509694423313414680575733951262M-8"
      call fmst2m(st, c(13), qx)
      st = " 1.142227645342158377586670448383448546854299529797736913759691985" //  &
           "910949533336448816683159056251333466684021985223318722135340801690" //  &
           "72260625981817135095639775689249807942339836246106905787385604364337194M-7"
      call fmst2m(st, c(14), qx)
      st = " 1.631475210082743727954198968671352602693131133480080900245408554" //  &
           "939316524124591839852475746114674778530360919625180046232777005122" //  &
           "27236317509067632839828070252526276470500723929148927321567689434907911M-8"
      call fmst2m(st, c(15), qx)
      st = " 8.623497389978272698928826543954910754554854080065660353539135917" //  &
           "773916063595516849273098040739690585246037837539507713246122281847" //  &
           "07020525306666205624027189054003604432165771697650991757066138256773314M-9"
      call fmst2m(st, c(16), qx)
      st = " 2.441104025235454263800352688428668916552720940475516379601031040" //  &
           "328703631852876301331001731922670655825329213688582617123340479731" //  &
           "30453030855966898642614830460583649086634599347191276139711017402687474M-9"
      call fmst2m(st, c(17), qx)
      st = " 8.729150638722326041474546798911555513733749137711634358293958504" //  &
           "106518519494766446793260191698472463238634461285021617971659072089" //  &
           "64830740638437222612735276515039966197638188663669442608898762584643632M-10"
      call fmst2m(st, c(18), qx)
      st = " 2.839029513083401421929170732563229229668325235436226039051054572" //  &
           "783508115759922623716045941336385750870556656615699867502848974601" //  &
           "25690803078266597331301210600902409196080711025610915592408863593987027M-10"
      call fmst2m(st, c(19), qx)
      st = " 9.560889804988413908509285509380646041154360005479482459192247765" //  &
           "357528992664976535701311631674646910607500850899901331610584447013" //  &
           "61092693917685042900085585432034263673380064316273851782544357969469641M-11"
      call fmst2m(st, c(20), qx)
      st = " 3.178270013361840262252491679259206811383776452439447460847595023" //  &
           "655033077497304599287176316699672432816255052883697868521388307529" //  &
           "40383229860610241927494715179896090660025570060233690995092455619052433M-11"
      call fmst2m(st, c(21), qx)
      st = " 1.061093469576602661180070676287816314794459534888083832039943125" //  &
           "106258601567850805437194313637331057164170163808855202657895983163" //  &
           "75070581362231098256864140947088822349901059528755152892715695385840670M-11"
      call fmst2m(st, c(22), qx)
      st = " 3.536842812699221803341361602631772393030775267007960695600138342" //  &
           "475056171314799106864974683735705965078815702431194850519988946394" //  &
           "60297349449303074734807619318567432754104422976962193319806157373676528M-12"
      call fmst2m(st, c(23), qx)
      st = " 1.179381890210746859019626609111101179189547278121204798102640669" //  &
           "089589106613555171765287658695791241618592970217136500883583515937" //  &
           "07042245469783966737397377617384891192343427489490590732643362286614565M-12"
      call fmst2m(st, c(24), qx)
      st = " 3.931867733137363527554885326768660997026944151573526847589071835" //  &
           "861161866217034417877097706264724092166846479646830599648529767479" //  &
           "29972500613317852095515147938660038231478063008302625870299351511379064M-13"
      call fmst2m(st, c(25), qx)
      st = " 1.310821437225892696503587059884518604419875759028225403332569486" //  &
           "263124550715228960875605764084965585015810053174223154386683364225" //  &
           "82940623880095674287091265178854323811489670635974124477257044106228515M-13"
      call fmst2m(st, c(26), qx)
      st = " 4.369852680143739417301538884456930730266716017178643408797678607" //  &
           "489727662002478005547544394166113056281405054193512564204527806783" //  &
           "21820023428536694798337606178682340961609542697763176968052664696930530M-14"
      call fmst2m(st, c(27), qx)
      st = " 1.456734329592486133181460315029414930377211960023817769883504280" //  &
           "093804008390039009055883271224157190963826905955811848380812603165" //  &
           "54224971663883071707665069028985176275185941888330865659033519170133935M-14"
      call fmst2m(st, c(28), qx)
      st = " 4.856068671580721652825423134564758955030518962120078212851284455" //  &
           "507593020938761405142314134920533228978526051606006790133466381223" //  &
           "50359680218686853748359459683818517509731959413893343189086282950465935M-15"
      call fmst2m(st, c(29), qx)
      st = " 1.618761872087034547065539210485881034248882944054015543045073210" //  &
           "910330056730122088065602760823181836215863575050044591541254549198" //  &
           "06533155170588574561959173365139660326081560892373137180542173284519690M-15"
      call fmst2m(st, c(30), qx)
      st = " 5.396053371990928374785154960328771472570021055817837913960904096" //  &
           "760099091618418168792262897777467993922856366402610309885017994638" //  &
           "31375328961628239846054792847689945091796341112338488175505578851091459M-16"
      call fmst2m(st, c(31), qx)
      st = " 1.798729611660976774380774106560359446517486065245326232319884896" //  &
           "239912275072122853296640979664466879259429595297450987702461004648" //  &
           "40931772056892963070221773391675849856440134420289464625930506084236358M-16"
      call fmst2m(st, c(32), qx)
      st = " 5.995878246226820269265104853882744953833262677515218945976170565" //  &
           "702779924974464149394857574835844004490020924890860726739848899923" //  &
           "95696324825550829660096649087698612645940055809410964879423696294173532M-17"
      call fmst2m(st, c(33), qx)
      st = " 1.998654305589399275726998250553254783542933078465976133420153128" //  &
           "272381058668053909214099708471764295907486937756314951544992358421" //  &
           "97144228984621236873733301083447645823872653994272286143235273563570481M-17"
      call fmst2m(st, c(34), qx)
      st = " 6.662251581403731529306004514600953655139824062623862163440755266" //  &
           "354957947460012639499946309112697689542491881916960750384664086547" //  &
           "74220845245988438400136805239697524619278380861197973816032911820925462M-18"
      call fmst2m(st, c(35), qx)
      st = " 2.220768169107932862809420803989156159852745026278540490315171027" //  &
           "166630658162840832652660890951304947572979341837638582334903909155" //  &
           "05010378303851983844455677013599258308919578609796169265316664802443791M-18"
      call fmst2m(st, c(36), qx)
      st = " 7.402604670809900203376581979566914810234491834807160670117173102" //  &
           "679048535794208132168246922357691220447769517665621319685807754668" //  &
           "30524972355162004213858351086934604282899918908012797069231868984875389M-19"
      call fmst2m(st, c(37), qx)
      st = " 2.467545917514843068413870814987535001534095121397550756283431485" //  &
           "174239672848806618511211094654861620856356668212851618482113031080" //  &
           "96983868763519240779629920703298714890476973363239861006308885857104223M-19"
      call fmst2m(st, c(38), qx)
      st = " 8.225180627404782368968305939492307217250324537166525666738082095" //  &
           "443986514199471391717760463558674271532612180804614900051667267307" //  &
           "84828422378491452316833093910246472565776447483034439499635086721544230M-20"
      call fmst2m(st, c(39), qx)
      st = " 2.741733768240659509936720350920901622511204615005846102750077012" //  &
           "225034115334522335690591847723821637675971676287391586929140867246" //  &
           "24157389063680220659693708857804287064240054553450007399411745938008177M-20"
      call fmst2m(st, c(40), qx)
      st = " 9.139129792265891288417212538920834449088699985871081943229349237" //  &
           "308947859965368326191615768810794304428951588196306949098368574539" //  &
           "28605395142908365050404570472066333401820331325326810443520131888072775M-21"
      call fmst2m(st, c(41), qx)
      st = " 3.046380905361179933871534873717109530976853470108494529882869084" //  &
           "727927972747326006151030730201866380503024676995328258901563345953" //  &
           "00658838459344187262962809267579300899208726174226364547735769503160384M-21"
      call fmst2m(st, c(42), qx)
      st = " 1.015461378786517931007333337553073166997854684093926238094172044" //  &
           "744795968432075139196598233114739312125317801492097820991352317417" //  &
           "40293799704807080092075189476011412233026066523677916838565466920346563M-21"
      call fmst2m(st, c(43), qx)
      st = " 3.384873955149684581869145002322761445395722444488361773402583112" //  &
           "448446196579967067830143563552847474861011075678427137967175986491" //  &
           "77423399240122512958345857834877457342567505386357823149491980041361130M-22"
      call fmst2m(st, c(44), qx)
      st = " 1.128291991521080392925404045314099582618612165311869719114516335" //  &
           "417518456246100356538652790526704797786336190873078001030469915965" //  &
           "30342451983442856226503526150387619863083398681667798679726159209459487M-22"
      call fmst2m(st, c(45), qx)
      st = " 3.760974987926624413050052192380026663425879102031305346359345746" //  &
           "935876097802220422384767553022229983969369775506060549782771493660" //  &
           "85309029600033693383948806798756523782518697759939484580588143464857350M-23"
      call fmst2m(st, c(46), qx)
      st = " 1.253658750025309164633924716897191398251340412647146221607418983" //  &
           "652266605895765756004913716691084072256991264216324248980009909612" //  &
           "59662905496332238803040488263666172235045176892125202448596644986008747M-23"
      call fmst2m(st, c(47), qx)
      st = " 4.178863551880140415652989937671280452129584936360929800867252116" //  &
           "863675482287565904618697224054245640513684845309376666513701521263" //  &
           "52903495786573790786121590010548700491620543046740323819627331118835276M-24"
      call fmst2m(st, c(48), qx)
      st = " 1.392954780243262418680115701340497736540387201421965383888625288" //  &
           "310091918535511115914306440504769869531128337443764472227581178596" //  &
           "20874940378776837220110757980964940848165877287239082243508787832464445M-24"
      call fmst2m(st, c(49), qx)
      st = " 4.643183258187456757363871480237105948494753871341586050997508099" //  &
           "595411224954239240596072142323602079719155358372134330760070497787" //  &
           "55364393549841452404607067507295993200758608506748675165475527877530949M-25"
      call fmst2m(st, c(50), qx)
      st = " 1.547727917073673030893407669122051522765823276651858723363536117" //  &
           "860559780947473082931957648716608923599799859242924550204192502327" //  &
           "93202961853805884072569165830891801693280119768515402102389811485890830M-25"
      call fmst2m(st, c(51), qx)
      st = " 5.159093467774295934623929324290510691555682927619718795937537456" //  &
           "443748751641411020603883876314313578961537671360400477911224749990" //  &
           "32619951820624633170971754679797702479266215176809962392844181877752600M-26"
      call fmst2m(st, c(52), qx)
      st = " 1.719697925307095214819334128534788375205527844306001827485335608" //  &
           "178891188953930792336558066117385344867670787386310361133421997787" //  &
           "32437687430376200145015883834569265381524778650808598371769510961689717M-26"
      call fmst2m(st, c(53), qx)
      st = " 5.732326674479775700977445632081415478242873164984623088760026987" //  &
           "046479843038489986034336241981077004936330751439598114357862316445" //  &
           "25391747885525449466566054526270451667824579066863518701758860381778789M-27"
      call fmst2m(st, c(54), qx)
      st = " 1.910775622357349859006177503807224410484768271435458299879734511" //  &
           "091872750666800933837592866045341090057920381872911981841539613531" //  &
           "34532853835424993139130432850991078908443110651776717566117546886621263M-27"
      call fmst2m(st, c(55), qx)
      st = " 6.369252235018181185695546747418083648737457861666758649658733495" //  &
           "450326624296352111648047112820334535082139732219092514871542197623" //  &
           "45438407830542732130710826023492126216948058010058111121438710893185370M-28"
      call fmst2m(st, c(56), qx)
      st = " 2.123084118462838161068146373210838937742442106504888126619598244" //  &
           "689122838503449807948835352511168142442994048637204680573237012416" //  &
           "88214862798756633312023510560919642366853351380446601871574640377801289M-28"
      call fmst2m(st, c(57), qx)
      st = " 7.076947161851452988857602069175395219260001742350326617810798286" //  &
           "412997417428572002897367283988898197215995346896337658412178803828" //  &
           "71600585988840954970771671278144596708302210216220397647874970105717455M-29"
      call fmst2m(st, c(58), qx)
      st = " 2.358982412360992050118851554506979955647201613693684896233810502" //  &
           "944787306402820374939041591698662853950957584483745174219063623695" //  &
           "13294756585697364356697316138631583855315160276428811116906407698998717M-29"
      call fmst2m(st, c(59), qx)
      st = " 7.863274770562928683386208182169555716408523732927181605570254642" //  &
           "783489336698077228912261535122643231786047779260925663715692218511" //  &
           "54079525591282153925777222923833127312465613000068227777044732926174616M-30"
      call fmst2m(st, c(60), qx)
      st = " 2.621091605860885533233898952848549221472883408639509048156174492" //  &
           "952501040386862212314276518084902725209461671925415533723193076219" //  &
           "02166363594957080995260573241730794841247260537467180156250342238881167M-30"
      call fmst2m(st, c(61), qx)
      st = " 8.736972058719399393773664808053499235464951884789194640368079086" //  &
           "177143026321168823182202095050518931856284116458482040667912530023" //  &
           "17830489701338487555343938051214348611787932621065770035562250631323146M-31"
      call fmst2m(st, c(62), qx)
      st = " 2.912324029368913239221905377728027928932487827862157086587586846" //  &
           "896450700145411015082377114761533704468584083695734375828642409882" //  &
           "69259984928264053284030731675607849783920249775114691953904644907709015M-31"
      call fmst2m(st, c(63), qx)
      st = " 9.707746789052497475085146052433896715360382198339051019251763880" //  &
           "518185755627159066562273677244070805548234512751403592056913207327" //  &
           "80251017233714875898746055682870640485635412611964103637495935078818638M-32"
      call fmst2m(st, c(64), qx)
      st = " 3.235915602473196442669228672981134089711213167383910530833953829" //  &
           "792990006951794162312454635926395818450571401725370707981435503583" //  &
           "55570191731695332982121199537121246583519326445577596987891273510182193M-32"
      call fmst2m(st, c(65), qx)
      st = " 1.078638535688323258277639294637321095007154872462571028231301143" //  &
           "605467142930516231430752807470673434147256477737840344704980947455" //  &
           "43053554636974298772295627289032328328373036848556849010802235448385016M-32"
      call fmst2m(st, c(66), qx)
      st = " 3.595461789454222217017444496718864771407199081151484546256978274" //  &
           "929484367469843471052909175769814275173782972424785067903628062172" //  &
           "38267851839020384161912309600523898207350166920811200389438694198073310M-33"
      call fmst2m(st, c(67), qx)
      st = " 1.198487264108026960553291549779110538131003576080453431007006512" //  &
           "268160233237697351800460921121832519391521815357041008416084888598" //  &
           "27557131190172270346227678454195010189227547853345612460399635783630149M-33"
      call fmst2m(st, c(68), qx)
      st = " 3.994957549418305520762016700744032876853769637744488924267188269" //  &
           "584393732051483805590060972426573672962844815489806656051668047426" //  &
           "97928538442568628891602616126915832496578665989847126282893366534237083M-34"
      call fmst2m(st, c(69), qx)
      st = " 1.331652517070655772993246798258154050119486912201311455268437349" //  &
           "114193156345900532664095994600506577877633489606677937802093759650" //  &
           "12137846480275713137733722530126859812615084188357652189387132980702776M-34"
      call fmst2m(st, c(70), qx)
      st = " 4.438841725063570781178568100283946176488573680079007649477905193" //  &
           "017992386971455066988895758316824569677887493778455225021106826855" //  &
           "29026392300941094435783945574507271437954562521405284456074260144096753M-35"
      call fmst2m(st, c(71), qx)
      st = " 1.479613908728203152730390143133201780942639054825565044507758917" //  &
           "773304661939287594029105088656760879117520103897129013490206639754" //  &
           "87435121659508261905208347102886094942106298340234319457765604513963509M-35"
      call fmst2m(st, c(72), qx)
      st = " 4.932046363361542755686335602696750869830288252199443432734105813" //  &
           "943462260083819436478927601708900720110450661448493818380083105762" //  &
           "71590161306544076696091310423964644508740590548145866774529617253109923M-36"
      call fmst2m(st, c(73), qx)
      st = " 1.644015454687397316689944677831911620211552013511192085616959005" //  &
           "082583370344704494312506871603969621047795163740944612049682148927" //  &
           "59356353337859121253234322350982876222750860528515262326476034089950266M-36"
      call fmst2m(st, c(74), qx)
      st = " 5.480051516208532057249213551633236335403175178397767120722791995" //  &
           "833335758082301610732726590856354303605009314671070073367443285322" //  &
           "81719944336949977298072286244404059176341969451639495219169668432874625M-37"
      call fmst2m(st, c(75), qx)
      st = " 1.826683838882145937413050728363254416465068672788666223790911345" //  &
           "427048802205722820790024964162626522627539834294555447603439041292" //  &
           "92403842411688509922659248102884925797066250995812515878053578599537543M-37"
      call fmst2m(st, c(76), qx)
      st = " 6.088946129972074589720378401074071029218658010685074635511831120" //  &
           "277695386768911269891962771874827650899040106965903278757448364187" //  &
           "28574155937467016044284632565747254397900833533383192879263530571086410M-38"
      call fmst2m(st, c(77), qx)
      st = " 2.029648710081921896663063938682967174463636477103609117669608797" //  &
           "346033378612490707724833983253281429017993058131396854118481222339" //  &
           "85407951679907254491401107628467015394676060959591476686232563916557226M-38"
      call fmst2m(st, c(78), qx)
      st = " 6.765495700501148906774995358078228324235325066490434291070320211" //  &
           "666634035845840680799492809322166392640915607858746928019847633868" //  &
           "45020162815858209793574963810268541266706689851018528823213713218014553M-39"
      call fmst2m(st, c(79), qx)
      st = " 2.255165233557401948601014902186205602789864371948507888958512686" //  &
           "894666882870433310683786297682141353940837232625056953901094633832" //  &
           "03813175465801305121046951268786662654220745685289766957573976902789674M-39"
      call fmst2m(st, c(80), qx)
      st = " 7.517217445333887278263065941349084170211801907036126548415826613" //  &
           "097540864542220787119574822998915671722740530800746773131556370537" //  &
           "17036257265431709600760536998990725283074006064618438905604324155029841M-40"
      call fmst2m(st, c(81), qx)
      st = " 2.505739148480265955233204413682186719497131266833487675446538783" //  &
           "092174430438507742800231748635072748340810415087125614579378635688" //  &
           "66151322710496155055815000392267489014427962480151154107924769960320348M-40"
      call fmst2m(st, c(82), qx)
      st = " 8.352463828356645340468994201986157494921881256993571664141509541" //  &
           "823273109890101870519752598083111861872055684078254288142631302953" //  &
           "90656071678927672118181416754149675034388261080192075026592829943869784M-41"
      call fmst2m(st, c(83), qx)
      st = " 2.784154609474488152611480955615773344997254762720123569187499710" //  &
           "482501105031142742130099147104245620254144813103304543108707461283" //  &
           "03676294384838274788281739537719423506089439601147338491518140111085245M-41"
      call fmst2m(st, c(84), qx)
      st = " 9.280515364970643106573953106487348079696240473524263398418948085" //  &
           "686805363427549650077259362814392417398055197835215069289928148824" //  &
           "67963286545183505632254520821084189068903494611293308100453524544737026M-42"
      call fmst2m(st, c(85), qx)
      st = " 3.093505121670801685004800389514423527223386419080428824653989649" //  &
           "679279518505124420083928960371367692487927529341787666280479065858" //  &
           "20227384416309509890526585569312748427209499872674012860539332555258032M-42"
      call fmst2m(st, c(86), qx)
      st = " 1.031168373893747390707549843146989045155823157470502623225595250" //  &
           "851710797449759760498072278428597174778192322827019231254514348869" //  &
           "35739852926303601231003771300391351671865972802045601948838060198753437M-42"
      call fmst2m(st, c(87), qx)
      st = " 3.437227912987858374961865176796344063877564237772445606496240106" //  &
           "757864483254589585823971686699471956766584959383102055399682270269" //  &
           "52352941784639649980429822410674941181991395320188803002740041936488314M-43"
      call fmst2m(st, c(88), qx)
      st = " 1.145742637664794559805828100464320725242403637362145522388352767" //  &
           "861006812839084798058391247493282342027006725688139044431839514660" //  &
           "53654774876669055000807030176806220727453288403581728457403167939166997M-43"
      call fmst2m(st, c(89), qx)
      st = " 3.819142125554752953067839505315181594779066795846739238810201522" //  &
           "091877503536260790984284322275300395166507566249167177334314175598" //  &
           "37162971702086753249324866744493897786886912065021929714836592305111972M-44"
      call fmst2m(st, c(90), qx)
      st = " 1.273047375186277089451795607705259637601635385366665197585993775" //  &
           "074526908019448436164455682411887757929212685231623835262681489558" //  &
           "82648858340071059461127000212205125717165045854603000054982553620290401M-44"
      call fmst2m(st, c(91), qx)
      st = " 4.243491250624322227579766750508513228093573956231840709615359110" //  &
           "716873987770463557146491514771994072759888669351546219633295358033" //  &
           "66517307409098637643711145428866491214789294814344532842968257523643745M-45"
      call fmst2m(st, c(92), qx)
      st = " 1.414497083542290391545199323374869916206725399320438141384531327" //  &
           "265477522477777915006882588147304129058542612492747596977199928651" //  &
           "94869243918440516701383178149493577193540062534758351817970713054178365M-45"
      call fmst2m(st, c(93), qx)
      st = " 4.714990278476425427697520544930204334035129865733446210245204030" //  &
           "355616997118279522525088487975375771703855109208249987771017533193" //  &
           "90291285366875213381956263086437252260808891626942562877561594888642475M-46"
      call fmst2m(st, c(94), qx)
      st = " 1.571663426159339506535953571864003053494761363991342538284158655" //  &
           "584260596318169435197761794741189000363244392470381778816827538385" //  &
           "70503152182049565811831241089687440405169499752285888183719228270040702M-46"
      call fmst2m(st, c(95), qx)
      st = " 5.238878087199125931711927428699616143954533668740342266002176483" //  &
           "066317524800888207882487253378527961702366607212427983576029574311" //  &
           "70477008468882187587684440329802260450306316947736342927462019072062451M-47"
      call fmst2m(st, c(96), qx)
      st = " 1.746292695733373871385356099575152433557917368382321044143123707" //  &
           "125733276511427813036854586467480879063125488695590156424518309858" //  &
           "40776387319594992052236593986791986838450118314507991811649011797951517M-47"
      call fmst2m(st, c(97), qx)
      st = " 5.820975652445409306654690542379619928753899950100022072575451976" //  &
           "896049502425251330032699117677706811131644722750272961660598812323" //  &
           "95528274546713027672214860795936676307396171912021238503162387066702843M-48"
      call fmst2m(st, c(98), qx)
      st = " 1.940325217482010536060783297163692278507114464120206717431891734" //  &
           "053010284461713330551549047577932453595163579118201359494986630173" //  &
           "01494093463680448771677875123107012368194613913742739952428603002168229M-48"
      call fmst2m(st, c(99), qx)
      st = " 6.467750724940553704809014908981646231351194700919134365131054499" //  &
           "044206347270309742459318050095528539735477919872551695967650699099" //  &
           "88953248180134764653841795790617888566272316181621003159336089850848991M-49"
      call fmst2m(st, c(100), qx)
      st = " 2.155916908313647547754610174771515398662821458991609891428955252" //  &
           "290583442620154212776250181824196267358169201447214242363354724316" //  &
           "89903280067672089810407626181445703141886320049309134936640041251647199M-49"
      call fmst2m(st, c(101), qx)
      st = " 7.186389694379149274561055379686410434878982979762824712204962808" //  &
           "871607736477144813893452054031932010405337926726732941950536667006" //  &
           "84810252591610140816882396575440916998193275137670082479286587744869582M-50"
      call fmst2m(st, c(102), qx)
      st = " 2.395463231459797453698442182708267050312141998051092331530640409" //  &
           "893924848764443035384500574394756654315653015364123642221973250880" //  &
           "68362683781580014370472600811020274312157465907532281112816349722673774M-50"
      call fmst2m(st, c(103), qx)
      st = " 7.984877438199527417773369963127799969498648440970510669498583482" //  &
           "161029591317677710672043612633451504552983943030656888570069226104" //  &
           "04295259910858734307563648182821156659161484763549481645932818220413101M-51"
      call fmst2m(st, c(104), qx)
      st = " 2.661625812733226448952431335647978161413961687446878335164533806" //  &
           "702910875419295287094135193138742564146281522194125689011703047524" //  &
           "45739306220536816835347815852152246454806822705745730784267021864361647M-51"
      call fmst2m(st, c(105), qx)
      st = " 8.872086042444214770744709174167341653906439941556420653788154173" //  &
           "929048445735834186760727780453829909511846845819831435241835442504" //  &
           "04079891107632829549289090071219101574622546793854950277712602194795534M-52"
      call fmst2m(st, c(106), qx)
      st = " 2.957362014148103242140721175656428119533141966179427551155676500" //  &
           "671725653671481845278656623962048055150306031384279834386038577295" //  &
           "72584556615286334177021422182622284915641930082182710316087748100105028M-52"
      call fmst2m(st, c(107), qx)
      st = " 9.857873380493756603533616420387300817360969314828251071875082336" //  &
           "698703611411040709238371719721287012785465953801003782742219530827" //  &
           "73983924014324680294547858829752678323087789357138505841177563631130388M-53"
      call fmst2m(st, c(108), qx)
      st = " 3.285957793497938650277342040351753052374376933619786220663421040" //  &
           "427587332321480401454840426545683394351958951963755749546928108005" //  &
           "75979757809361423163013264428850345811205867029087095522459004260861910M-53"
      call fmst2m(st, c(109), qx)
      st = " 1.095319264499317829033981510140817754508285369349556399833223737" //  &
           "174998151312514038433336840462205568158214000003108865975414472963" //  &
           "70581756862795260586373374661842883378795511151785344346238350698780645M-53"
      call fmst2m(st, c(110), qx)
      st = " 3.651064214997738460800440485464116453512465873766107387248343452" //  &
           "458997203837952291715916094766655886246438013372552836368973829605" //  &
           "29202550932685485563387565304843167421189066345923958359568125707813957M-54"
      call fmst2m(st, c(111), qx)
      st = " 1.217021404999249244605272366723881223583838603878543320302210671" //  &
           "409056933719216026722268770996716099812270381542447122348883231949" //  &
           "38922656964910194439295935941196896773701049861546343314133034224282491M-54"
      call fmst2m(st, c(112), qx)
      st = " 4.056738016664171876197055085310199605151026698635243534713457892" //  &
           "107296169062875134691895441571499550130093746425411512549327123228" //  &
           "16601740468340561446321921103466463550189353682758076018331072415996381M-55"
      call fmst2m(st, c(113), qx)
      st = " 1.352246005554725890610555164289246652995273648088741088360045973" //  &
           "623667364361191345555088170702142598112873445326035312084757222791" //  &
           "25547996491724650392650447881135472685838861374568021340343847835638534M-55"
      call fmst2m(st, c(114), qx)
      st = " 4.507486685182424465064025894185168278371602793396197455600512532" //  &
           "406474418197117862785333707359281266142995363043310398030388775224" //  &
           "96855355439438225180328883970301863313369556592379689501165566142115306M-56"
      call fmst2m(st, c(115), qx)
      st = " 1.502495561727476029111885802751588446409759610042467877987373043" //  &
           "860038180719787874668067312469292183193912200682893897594757683194" //  &
           "08099696091579813882633694420046951596146901116935629924246701724845131M-56"
      call fmst2m(st, c(116), qx)
      st = " 5.008318539091589782265978940332517362043223441916201948536518072" //  &
           "099322344676502315123489826715051040283829780783100995910094849108" //  &
           "65034584595413084839701258466960248343166395950551930374997082566708225M-57"
      call fmst2m(st, c(117), qx)
      st = " 1.669439513030530682061916213454823087218137831151025299167070973" //  &
           "190879095582514009353872307284741332656640434042133116166845579709" //  &
           "81635243531150493888288323800171093455101171326873303863260272601517849M-57"
      call fmst2m(st, c(118), qx)
      st = " 5.564798376768437493472862129317060203208340292866327711857634512" //  &
           "795204118217070748492626708664751935590615442683377362519336018325" //  &
           "51004856969881087903485123401331518636537459253893877449123506707146950M-58"
      call fmst2m(st, c(119), qx)
      st = " 1.854932792256146302807572731110803878429090610101994543365419672" //  &
           "049548214027388780306433203424820289079873088082231836000918687537" //  &
           "23334792833523598579662177790912527794946886117189075782702240392408839M-58"
      call fmst2m(st, c(120), qx)
      st = " 6.183109307520488855150122490825215119994140805333496249840425315" //  &
           "260483680241891966697616887289397465885493861812930613441993149861" //  &
           "75026053269580573584851572426023443652902431378207237270671672948970109M-59"
      call fmst2m(st, c(121), qx)
      st = " 2.061036435840163246497927510477654121008516108356441555748893883" //  &
           "538337771585715140176109550136417103188492842915425790968199189673" //  &
           "75115850238127872748852300922000306375635048830126739836684145179941549M-59"
      call fmst2m(st, c(122), qx)
      st = " 6.870121452800544891946141735609200171965629448722202434217816987" //  &
           "853447483793178217562366316730782300693739885096060635165076652920" //  &
           "41995525029854871068500757566629399110685057219153231404821304733713204M-60"
      call fmst2m(st, c(123), qx)
      st = " 2.290040484266848481553643087076101079355964961713023345779978400" //  &
           "982834140969803837340319397848019038722638870138573135003750122280" //  &
           "67644649360313184772818630784452829131845685063424590204739986167925734M-60"
      call fmst2m(st, c(124), qx)
      st = " 7.633468280889495399107799895007148312706155591452982323077149986" //  &
           "120899748236386385448066771935353332443050965065257767414246512604" //  &
           "54742904592796348751455213798689879834161009662040701046444537526427115M-61"
      call fmst2m(st, c(125), qx)
      st = " 2.544489426963165248184847366204930714902412817306190051775615959" //  &
           "530879632335665207219382767168166468926593335092194936311475724489" //  &
           "22045567698482778031098111145226005087891270132458202092192296860039337M-61"
      call fmst2m(st, c(126), qx)
      st = " 8.481631423210551115155109723717829106916950881296846054083649985" //  &
           "810525218550324029659230629073310007635840875342630862789117074541" //  &
           "87098166442436318923705470772023710069850200723928832617470068484538900M-62"
      call fmst2m(st, c(127), qx)
      st = " 2.827210474403517110353107867003629422731212331386162488716730521" //  &
           "351064005716979204840102164742676308078783782599324060431157817109" //  &
           "88654841674710921627884749621343607380343694451939622450448527669612216M-62"
      call fmst2m(st, c(128), qx)
      st = " 9.424034914678390547763871121100990122397792341363117728757038903" //  &
           "649538172737671552516290289880795766718250080584367536271759196670" //  &
           "39697325553891033518536553021634662617083010606852575129875069462163167M-63"
      call fmst2m(st, c(129), qx)
      st = " 3.141344971559463560901334931474821601568811602982335715041502627" //  &
           "827982932089655486622557870156127718095126494732372850918038888332" //  &
           "54551941638266722522763646352278545149136303285285604558173356388928708M-63"
      call fmst2m(st, c(130), qx)
      st = " 1.047114990519821198212122783269017133872736396216455065194396848" //  &
           "772182771964575553018906528347835085989108829213513953424609300128" //  &
           "95630377523418163375718344777771305545237149991145713842104433495405185M-63"
      call fmst2m(st, c(131), qx)
      st = " 3.490383301732737355486270459507822699258345311341941846849921659" //  &
           "545613492122376436148560471436321288125576975707576514288727189135" //  &
           "81234008256049155059395856211182401981576994675285833396791180771117772M-64"
      call fmst2m(st, c(132), qx)
      st = " 1.163461100577579125523555448655563780187894154820747936001916075" //  &
           "833373823024344903789897831688942109838607391549196509166544386710" //  &
           "32984677138183863587254008956883033409075083480154979676313298835611005M-64"
      call fmst2m(st, c(133), qx)
      st = " 3.878203668591930435982181400901299436435180157598905860060992780" //  &
           "769432703831655807641542938250104063615345695580486254706194715454" //  &
           "60229972174586144050891402920273633768999530012198276610097006412695734M-65"
      call fmst2m(st, c(134), qx)
      st = " 1.292734556197310149719976276646194118747432707279683488755745696" //  &
           "740947679118453560585318506784845508484302703353713015155212188239" //  &
           "59563349122999271475430680808380714359508027924891221587469189007133570M-65"
      call fmst2m(st, c(135), qx)
      st = " 4.309115187324367176714710446351861339597497796718143278961320946" //  &
           "586948534200778409616190905114541820432168004724255101140047339531" //  &
           "16503452628730864113604659140394417734969121530536316322243286765720986M-66"
      call fmst2m(st, c(136), qx)
      st = " 1.436371729108122394983600863166786192397968628737741530628906208" //  &
           "660940944816769480739740878584831113565249313940195309419096432913" //  &
           "23986224865537803560999682866769231274805486620569029108114354610082602M-66"
      call fmst2m(st, c(137), qx)
      st = " 4.787905763693741323475412996513093551712741258381159384549759206" //  &
           "662442822072738588515832300420257228803664662013090680472314997210" //  &
           "47994366822587964409268875557318665191628748298284520227769123490709406M-67"
      call fmst2m(st, c(138), qx)
      st = " 1.595968587897913776207656861993669785407285064500745185434113800" //  &
           "096356494376241989760638754749237977344465547010132327612679509965" //  &
           "90606634208693254568607053260913032981301281185089491854456988622988789M-67"
      call fmst2m(st, c(139), qx)
      st = " 5.319895292993045924981820864535497749048234307774210374132739226" //  &
           "662962493896584326632876715466366610480847242863534749368020824442" //  &
           "26347859777033625778816141835475590087036758263889428530371159240382397M-68"
      call fmst2m(st, c(140), qx)
      st = " 1.773298430997681976066348119317279371541102493785396123709304532" //  &
           "963732653591086234204258910992398206481527117154837605280677866587" //  &
           "40860519847234648346851518177302296315561478928449266143246491562286927M-68"
      call fmst2m(st, c(141), qx)
      st = " 5.910994769992273256235513308905467236327084289024213039675731610" //  &
           "148156011515848201203908937219678972731231236325011698208574736079" //  &
           "80168427550976937837979750480068076198135077050989661245596743172379630M-69"
      call fmst2m(st, c(142), qx)
      st = " 1.970331589997424419415425997445581585340102744812802313473388703" //  &
           "562069927312660229009236127416616182518232875620838559077842053926" //  &
           "92349876121987505300275410560304423025355686582773348179088042892097570M-69"
      call fmst2m(st, c(143), qx)
      st = " 6.567771966658081399727057227641186570727529727910776691977632634" //  &
           "165946988657121076389626270986170591723497353782252176685973776995" //  &
           "43528417602815951738160201869055681397572348387528732209187423794662534M-70"
      call fmst2m(st, c(144), qx)
      st = " 2.189257322219360466994595051007995333389857163416210506204122933" //  &
           "434092909606199446262463730440462471061414357649669288454519822486" //  &
           "33439286916366526139243135196086518512441365472582736479048872262858017M-70"
      call fmst2m(st, c(145), qx)
      st = " 7.297524407397868224362590109254773419614298510807208602130225559" //  &
           "169843334057978765051658253298688634379979983044623872624689424224" //  &
           "07554019829693239747911909633693703476580188084738005493123701521791467M-71"
      call fmst2m(st, c(146), qx)
      st = " 2.432508135799289408382681708766459710814072648334087437525650247" //  &
           "402627470576079904894860765869748078205431190272078201162332612662" //  &
           "86925426506431278564366927546261623009686964819372619868333948357411039M-71"
      call fmst2m(st, c(147), qx)
      st = " 8.108360452664298028596818159143547381983866077866697620113475392" //  &
           "867557609420149388391146208299955439299097511073088600020008797364" //  &
           "90254145831112916894519121436284980569670233198361465597386807462396245M-72"
      call fmst2m(st, c(148), qx)
      st = " 2.702786817554766009695908457319192274936196517820205990720071929" //  &
           "267436760629307786446087225623272749165348119673554381961913455458" //  &
           "93050660537495047726291186100258874974179781198259808664194749915523789M-72"
      call fmst2m(st, c(149), qx)
      st = " 9.009289391849220032728785940466253732893526544523495429162278552" //  &
           "296342689979948102270331957628702643264702399700740206586719143369" //  &
           "63516748801336419497668271497140970017083857566651892279908542196784275M-73"
      call fmst2m(st, c(150), qx)
      st = " 3.003096463949740011011890954041623476083928522268342083771940551" //  &
           "403977301983996687445005688089790997335068650775774411500709972696" //  &
           "00052352997217396436659500075907900727290635046242137258265027272046707M-73"
      call fmst2m(st, c(151), qx)
      st = " 1.001032154649913337029531966564025740882006821416233309378396854" //  &
           "352648141475996724306705629001209846327383244434702908491488661840" //  &
           "33666122248311247777472186264526745924646761167750923503037999124457410M-73"
      call fmst2m(st, c(152), qx)
      st = " 3.336773848833044456828335032653876240316804704924144044073849579" //  &
           "816206165795104200289660358785996996484528456071385377435139123676" //  &
           "57709192610536558746890780425020107260403503414920896791666418548557679M-74"
      call fmst2m(st, c(153), qx)
      st = " 1.112257949611014818958755021576306436637772541032306466006509854" //  &
           "188967690019629658157071337514432146127855476046945605695950179554" //  &
           "39845790791214616926248699635001115509938807913024195016995950944619712M-74"
      call fmst2m(st, c(154), qx)
      st = " 3.707526498703382729922171432032250515805881149465794264372984724" //  &
           "327809012896984209000978195800679443631566152731613311969108735093" //  &
           "51590966384556456803036744807880814153226574822433894031208374029742738M-75"
      call fmst2m(st, c(155), qx)
      st = " 1.235842166234460909984137514518387752942293928074591712157524109" //  &
           "560139067764692539980008571135341128797657051727809999365157975182" //  &
           "53322235173852278845187716078871110242776570216352174337398795667971328M-75"
      call fmst2m(st, c(156), qx)
      st = " 4.119473887448203032778434343895875695597840528814474282367848794" //  &
           "205301550322451475974554397356862932040320235498247930630480575568" //  &
           "25417807718570483485133432555365627049395094885528093686245256557591509M-76"
      call fmst2m(st, c(157), qx)
      st = " 1.373157962482734344263376419251248172548827589625457941472696797" //  &
           "100175825647692982915548765225643706779206935633946071637767635709" //  &
           "79966315426397983742300900492572704510866186342432593363321634147388215M-76"
      call fmst2m(st, c(158), qx)
      st = " 4.577193208275781160777550837017921925055088338901698850930906043" //  &
           "311063967012540679380363564085256672110282867832397021602920753059" //  &
           "62941763379439217899247719980351463557310935320189195654346581389521961M-77"
      call fmst2m(st, c(159), qx)
      st = " 1.525731069425260386985167951519330997746387629867941705993359606" //  &
           "803096607303855736985249240116888915751939824222470295586537784557" //  &
           "14766559903817261522752203057544899378743721133360484530771023423930290M-77"
      call fmst2m(st, c(160), qx)
      st = " 5.085770231417534312974277748264028715371006669759625749888114997" //  &
           "040535088461914628203462029057668451395058320957895155954018999649" //  &
           "89570133824275977321769674422087255596053232511973102592783007464375573M-78"
      call fmst2m(st, c(161), qx)
      st = " 1.695256743805844769769991874189352969259021005362418248962236686" //  &
           "450929128768148436336404059930819742510685161671532907373324896396" //  &
           "92385277655969091090205296324356998243606127274626181023449273081779115M-78"
      call fmst2m(st, c(162), qx)
      st = " 5.650855812686156039218806037909235903455451213739689260418037318" //  &
           "509446943950605499341032642835238412850215403194710979806557582704" //  &
           "37936259002958165848823746298586989930806700558037154118861273544045145M-79"
      call fmst2m(st, c(163), qx)
      st = " 1.883618604228718704933778437940690307805004962163899221957470918" //  &
           "058716333776074607305943978262640017375578856797709581746515819407" //  &
           "51489901662136678406269201616881521607807260952614167843862068838710312M-79"
      call fmst2m(st, c(164), qx)
      st = " 6.278728680762256512126149402150794782943415735579294630724544224" //  &
           "964157228232060226941740181573870879258048900467741995915140892478" //  &
           "63661908097641164941373210234799596031030310767570648902522277881849187M-80"
      call fmst2m(st, c(165), qx)
      st = " 2.092909560254085021914720610883566852288010979452630217312140514" //  &
           "778472364540695790415885690351086108014265966713921440025212436361" //  &
           "73967300532411889825601604598920039776377478055710366101143130338433473M-80"
      call fmst2m(st, c(166), qx)
      st = " 6.976365200849595928554228570881565721048784920515468405614250170" //  &
           "741926248557408642176573843779290903009186026063040672689273898432" //  &
           "88910357288258162475303198325632084369407383550262099668489007926100917M-81"
      call fmst2m(st, c(167), qx)
      st = " 2.325455066949873863603395561978748601800147911008192886172463050" //  &
           "451820515051068562317761231512963759254765453729061173550997868120" //  &
           "58407734788242875774377719715615329774495325545245938734484625573096582M-81"
      call fmst2m(st, c(168), qx)
      st = " 7.751516889786273230324814807015203014115787760363240263773567207" //  &
           "238770582250611249333986919911192763902738500220512285746471179825" //  &
           "77571260191751902463570497659486034004412403189688932637270843323495731M-82"
      call fmst2m(st, c(169), qx)
      st = " 2.583838963261950823749231801853943339353886424780054671299212593" //  &
           "953839989881747235093144189509781483529556454394968872792726683435" //  &
           "27643326289916001403186650841236534106807785205861848342075189337865239M-82"
      call fmst2m(st, c(170), qx)
      st = " 8.612796544966339593458567326158368856673430376795891557224772538" //  &
           "947415233055213978085860502193079097945197318656791149694366866539" //  &
           "72822366330690625287806683992931214418731468102411025539925415006202370M-83"
      call fmst2m(st, c(171), qx)
      st = " 2.870932181657563853681094248589222833815589612305003013771994066" //  &
           "486301003023979828481138638939770854259457931497871219438623202895" //  &
           "38689833732465547124246759187251713896087958971527124804970116015889039M-83"
      call fmst2m(st, c(172), qx)
      st = " 9.569773927459502329186355848231519845153615256953762486987693008" //  &
           "642824433756506369875737104132534466116626389178752624525042798289" //  &
           "22548975065811830797487032916317956125950813783158098289413462007841293M-84"
      call fmst2m(st, c(173), qx)
      st = " 3.189924642457193947274111017893685291988923107347172733780095937" //  &
           "504990242848262256269173114579259710506482337540368636019319969386" //  &
           "73520058153132922629586433368902183759949488890960340616457392616954301M-84"
      call fmst2m(st, c(174), qx)
      st = " 1.063308229833233763649615961280021009800959973857039083389096247" //  &
           "411276485934365597139214502542489173998160641619626621325276246417" //  &
           "76894303109902050056828926820785431328629167285741168999780547981801651M-84"
      call fmst2m(st, c(175), qx)
      st = " 3.544360766480896268661403387806726005830929777366570657261489401" //  &
           "694611013460386506117284436161560434270675994478125024682804092939" //  &
           "15998067887747220478181658639560020083789407982402045792182967207779297M-85"
      call fmst2m(st, c(176), qx)
      st = " 1.181453391991692193233769222790948883554160416544364056162345177" //  &
           "930450135664579747942304147194452606107088227217835015752643760372" //  &
           "89824167494419232372153209806697818554092135462778008255059604732701717M-85"
      call fmst2m(st, c(177), qx)
      st = " 3.938177969065104259816236800771282813142970611653130614923372425" //  &
           "876301727778466158006947186295720851119739977650492841350794668106" //  &
           "75909743699184418774259697017658821999190863053142757985704314111950238M-86"
      call fmst2m(st, c(178), qx)
      st = " 1.312728231460229835781690690024789271337659581458734016769897717" //  &
           "615695172767934655904718896955205839028238358310418293184633392500" //  &
           "09974095126152086147719595157884930629859403536081952476482731834669587M-86"
      call fmst2m(st, c(179), qx)
      st = " 4.375760815315077535413569523720083421030822320092520690986988142" //  &
           "097203566380515277459454385250926657264251938784637571214707790842" //  &
           "13901922704849922902680056772549256776092849835805341467509317300857668M-87"
      call fmst2m(st, c(180), qx)
      st = " 1.458563929048378339389303099779179984031579246114615330084586060" //  &
           "391340363385450968349489278357541331271188532814617890065655968100" //  &
           "90864106047591784785100253214527821779035249121314752150297703091924694M-87"
      call fmst2m(st, c(181), qx)
      st = " 4.861879359454319859107717556333622023158902013437521581162884873" //  &
           "340193641755594234893503470462192100416392001882798233766279202968" //  &
           "02742623676171486751287082335949083937364296608060437072511301740262916M-88"
      call fmst2m(st, c(182), qx)
      st = " 1.620837575639336717669552632235434719742418568812043976527454822" //  &
           "311557369332525067245294696277568831932145434818066929071312277435" //  &
           "59667900060244610446776086220578843202917562200852939911588169882033048M-88"
      call fmst2m(st, c(183), qx)
      st = " 5.402795219201229254205787739591614371703058387299744106863813045" //  &
           "890074410469634798352875615158044666258805327295738061277040804255" //  &
           "11706167845408641690753715592108911157218063444936673090628364776228851M-89"
      call fmst2m(st, c(184), qx)
      st = " 1.799216964519093606731199173063133848252752532638951929530332271" //  &
           "088757960440794118609774620691669941349561692799601479867289303361" //  &
           "36573900179559749556590933182210908857440047681409893684369308365396546M-89"
      call fmst2m(st, c(185), qx)
      st = " 5.997366309057088767075246255186377444897385269608659113392135251" //  &
           "083240010154867782825603589060665479283491811344357943450419502328" //  &
           "30863890415054273770878371228558497389363862954168787497855394907612488M-90"
      call fmst2m(st, c(186), qx)
      st = " 2.011301294926252140726377746074781953178862150579839442308024059" //  &
           "805516340858995612053131399074329904610352755793706433609739823274" //  &
           "35441280105568641478715458116693621474886783585502490686457813740208553M-90"
      call fmst2m(st, c(187), qx)
      st = " 6.704482593621562564692904617177008442804824808114929721560806403" //  &
           "083889880113942537426720271890350736903006981375786722754398310176" //  &
           "64290862799510364108316770714557534855989672010291914054754244834573505M-91"
      call fmst2m(st, c(188), qx)
      st = " 2.160351395289544486253218378105888708749936652071087348664876866" //  &
           "590595135247617954742090212769559780976713437175453455128216319294" //  &
           "79621451615761249300873617293850399062283747501629953564198534458556254M-91"
      call fmst2m(st, c(189), qx)
      st = " 7.200419569439204992397564583120569704507791779761471734959614293" //  &
           "903195879211244064072895412909288124860635443865351473928153163314" //  &
           "35648140579845782685750371868061482151886800120453245481648754938151403M-92"
      call fmst2m(st, c(190), qx)
      st = " 2.784319712626698759566042489347515628094423349698152057970857358" //  &
           "347754564870738442303737360847085557292665631767832280403826508366" //  &
           "53961878379952572306276562137966777737866334027041960083257419418474932M-92"
      call fmst2m(st, c(191), qx)
      st = " 9.284263699802481030477799658347338855061343963325012856142524485" //  &
           "337551481107985173202144915554476793675287039218856327451603285101" //  &
           "60910890143062738353240079101453208140103839949856135593728282192403791M-93"
      call fmst2m(st, c(192), qx)
      st = " 1.469128321729119845643778628274835930841237239875100463308434786" //  &
           "723561392709397386626554407894406027910890887423959020221165249040" //  &
           "77624688503604251276023392875008399104638564047518405899300367036809361M-93"
      call fmst2m(st, c(193), qx)
      st = " 4.886379978539319342120516219783307378314461447995883185804991015" //  &
           "296960664895043875586362313203658735183472813064062209400386162722" //  &
           "42806131645480493919198786449897808824436924850601891974937230254873784M-94"
      call fmst2m(st, c(194), qx)
      st = " 7.046670647920504479063472745872909513874517692559573509267252909" //  &
           "755965774748698930668458487567120021155413053722800379339662049820" //  &
           "26470884186471084008635684699341681154401901074420825646205892400124466M-94"
      call fmst2m(st, c(195), qx)
      st = " 2.351541158501990523752731183260855698650611680331234753194545827" //  &
           "615066582884384059556932538832948082760844393963381962615300495238" //  &
           "72892129343291577201989578726783775602985638203462774865396580295272103M-94"
      call fmst2m(st, c(196), qx)

      qx%ndig = ndsave

      return
      end subroutine fmgam_c

      subroutine fmgam_m(ma, mxy, mresult, ndsave, numtry, qx)

!  Method 1 for computing gamma(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: m_gamma_ma, m_gamma_mb
      type(multi) :: ma, mxy(17), mresult
      integer :: ndsave, numtry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: x, z
      integer :: j, kdiff, kfl, krflct, kwrnsv, nmethd
      logical, external :: fmcomp

      qx%ndggam = 0
      qx%mbsgam = 0
      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

!             See if there is a small integer separating this argument from the last one.

      if (qx%mbase == qx%mbsgam .and. qx%ndig <= qx%ndggam) then
          if (ma%mp(1) == -1) then
              call fmint(mxy(1), mxy(10), qx)
              if (fmcomp(mxy(1), '==', mxy(10), qx)) then
                  call fmunknown(mresult, qx)
                  qx%kflag = -4
                  return
              endif
          endif
          call fmsub(mxy(1), m_gamma_ma, mxy(7), qx)
          if (mxy(7)%mp(3) == 0) then
              call fmeq(m_gamma_mb, mresult, qx)
              return
          endif
          kwrnsv = qx%kwarn
          qx%kwarn = 0
          call fmm2i(mxy(7), kdiff, qx)
          qx%kwarn = kwrnsv
          if (qx%kflag == 0 .and. abs(kdiff) <= 50) then
              if (kdiff > 0) then
                  call fmeq(m_gamma_ma, mxy(10), qx)
              else
                  call fmeq(mxy(1), mxy(10), qx)
              endif
              call fmeq(mxy(10), mxy(9), qx)
              do j = 1, abs(kdiff)-1
                 call fmi2m(1, mxy(5), qx)
                 call fmadd_r1(mxy(10), mxy(5), qx)
                 call fmmpy_r1(mxy(9), mxy(10), qx)
              enddo
              if (kdiff > 0) then
                  call fmmpy(m_gamma_mb, mxy(9), mxy(11), qx)
              else
                  call fmdiv(m_gamma_mb, mxy(9), mxy(11), qx)
              endif
              call fmgam_sg(mxy, m_gamma_ma, m_gamma_mb, qx)
              call fmeq(mxy(11), mresult, qx)
              return
          endif
      endif
      call fmeq(mxy(1), mxy(15), qx)

!             Near zero Gamma(x) is about 1/x.

      if (mxy(15)%mp(2) < (-qx%ndig-3)) then
          call fmi2m(1, mxy(5), qx)
          call fmdiv(mxy(5), mxy(15), mxy(11), qx)
          call fmgam_sg(mxy, m_gamma_ma, m_gamma_mb, qx)
          call fmeq(mxy(11), mresult, qx)
          return
      endif

!             Check for special cases.

      krflct = 0
      call fmdpm(dble(-0.5), mxy(7), qx)
      if (fmcomp(mxy(15), '<=', mxy(7), qx)) then
          krflct = 1
          kfl = 0
          if (mxy(1)%mp(2) <= ndsave) then
              call fmint(mxy(15), mxy(10), qx)
              if (fmcomp(mxy(15), '==', mxy(10), qx)) kfl = -4
          else
              kfl = -4
          endif
          if (kfl /= 0) then
              call fmunknown(mresult, qx)
              qx%kflag = -4
              return
          else
              call fmi2m(1, mxy(5), qx)
              call fmsub_r2(mxy(5), mxy(15), qx)
          endif
      endif

!             Determine which method to use.

!             nmethd = 1 means use the polynomial approximation,
!                    = 2 means use the asymptotic series.

      nmethd = 1
      call fmnint(mxy(15), mxy(2), qx)
      call fmsub(mxy(15), mxy(2), mxy(6), qx)
      call fmm2dp(mxy(6), z, qx)
      z = max(abs(z), 1.0d-50)
      if (qx%kflag /= 0 .or. abs(z) >= 1) then
          nmethd = 2
      else
          if (190*log(z) - 77*qx%dlogtn >= -(qx%ndig+1)*qx%dlogmb .or. -190*qx%dlogtn >= -qx%ndig*qx%dlogmb) then
              nmethd = 2
          endif
      endif
      call fmm2dp(mxy(15), x, qx)
      if (qx%kflag /= 0) then
          nmethd = 2
      else if (nmethd == 1) then
          if (x > 145 - (8+qx%ndig*qx%dlogmb/(25*qx%dlogtn))*log(z) .or. x > 250) nmethd = 2
      endif
      if (nmethd == 1) then
          call fmgam_m1(ma, mxy, mresult, ndsave, numtry, z, krflct, m_gamma_ma, m_gamma_mb, qx)
      else
          call fmgam_m2(mxy, mresult, m_gamma_ma, m_gamma_mb, qx)
      endif
      call fmgam_rfl(mxy, mresult, krflct, m_gamma_ma, m_gamma_mb, qx)

      return
      end subroutine fmgam_m

      subroutine fmgam_m1(ma, mxy, mresult, ndsave, numtry, z, krflct, m_gamma_ma, m_gamma_mb, qx)

!  Method 1 for computing gamma(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: m_gamma_ma, m_gamma_mb
      type(multi) :: ma, mxy(17), mresult
      integer :: ndsave, numtry, krflct
      double precision :: z
      intent (in) :: ma, ndsave, numtry, z
      intent (inout) :: mxy, mresult, krflct
      type(fm_settings) :: qx

      integer :: j, j2, k, k0, k1, k2, kdiff, kfl, kl, kls, kwrnsv, lshift, ndsav1, nterm
      type(multi) :: mjsums(ljsums), c(0:196)
      integer :: ndig_c
      real (kind(1.0d0)) :: mbase_c
      logical, external :: fmcomp
      qx%ndggam = 0
      qx%mbsgam = 0
      ndig_c = 0
      mbase_c = 0

!             Method 1.  Use the polynomial c(0) + c(1)*(x-3) + ... + c(196)*(x-3)**196

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      if (ma%mp(1) > 0 .and. ndsave+qx%ngrd52 < qx%ndig .and. numtry == 0) call fmndig(ndsave + qx%ngrd52, qx)

!             Since precision may have changed, check again to see if the saved value from a
!             previous call can be used as a shortcut.

      if (qx%mbase == qx%mbsgam .and. qx%ndig <= qx%ndggam) then
          if (ma%mp(1) == -1) then
              call fmint(mxy(1), mxy(10), qx)
              if (fmcomp(mxy(1), '==', mxy(10), qx)) then
                  call fmunknown(mresult, qx)
                  qx%kflag = -4
                  krflct = 0
                  return
              endif
          endif
          call fmsub(mxy(1), m_gamma_ma, mxy(7), qx)
          if (mxy(7)%mp(3) == 0) then
              call fmeq(m_gamma_mb, mresult, qx)
              krflct = 0
              return
          endif
          kwrnsv = qx%kwarn
          qx%kwarn = 0
          call fmm2i(mxy(7), kdiff, qx)
          qx%kwarn = kwrnsv
          if (qx%kflag == 0 .and. abs(kdiff) <= 50) then
              if (kdiff > 0) then
                  call fmeq(m_gamma_ma, mxy(10), qx)
              else
                  call fmeq(mxy(1), mxy(10), qx)
              endif
              call fmeq(mxy(10), mxy(9), qx)
              do j = 1, abs(kdiff)-1
                 call fmi2m(1, mxy(5), qx)
                 call fmadd_r1(mxy(10), mxy(5), qx)
                 call fmmpy_r1(mxy(9), mxy(10), qx)
              enddo
              if (kdiff > 0) then
                  call fmmpy(m_gamma_mb, mxy(9), mxy(11), qx)
              else
                  call fmdiv(m_gamma_mb, mxy(9), mxy(11), qx)
              endif
              call fmgam_sg(mxy, m_gamma_ma, m_gamma_mb, qx)
              call fmeq(mxy(11), mresult, qx)
              krflct = 0
              return
          endif
      endif
      call fmm2i(mxy(2), lshift, qx)
      lshift = lshift - 3
      if (ndig_c < qx%ndig .or. mbase_c /= qx%mbase) then
          call fmgam_c(ndig_c, mbase_c, c, qx)
      endif
      j2 = (0.38*log(z) + 4.1)*(qx%ndig*qx%dlogmb/(84*qx%dlogtn))
      j2 = max(2, min(j2+mod(j2, 2), ljsums))
      ndsav1 = qx%ndig
      do j = 1, 2
         call fmeq(c(j-1), mjsums(j), qx)
      enddo
      call fmsqr(mxy(6), mxy(5), qx)
      call fmeq(mxy(5), mxy(17), qx)
      nterm = 1
      kl = 1
      do while (kl == 1)
         if (nterm > 1) then
             k = qx%ndig
             call fmndig(ndsav1, qx)
             call fmcsmpy_r1(mxy(17), mxy(5), qx)
             call fmndig(k, qx)
         endif
         do j = 1, 2
            nterm = nterm + 1
            call fmeq(mxy(17), mxy(4), qx)
            call fmcsmpy_r1(mxy(4), c(nterm), qx)
            call fmndig(ndsav1, qx)
            call fmcsaddnn_r1(mjsums(j), mxy(4), qx)
            if (qx%kflag /= 0 .or. nterm == 13) then
                kl = 0
                exit
            endif
            call fmndig(ndsav1 - int(mjsums(j)%mp(2)-mxy(4)%mp(2)), qx)
            call fmndig(min(ndsav1, qx%ndig), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         enddo
      enddo
      kfl = qx%kflag
      qx%kflag = 0
      call fmcsnsums(2, mjsums, qx)
      call fmndig(ndsav1, qx)
      call fmeq(mjsums(2), mxy(16), qx)
      call fmeq(mxy(6), mxy(3), qx)
      call fmcsmpy_r1(mxy(16), mxy(3), qx)
      call fmcsadd_r1(mxy(16), mjsums(1), qx)
      kls = 1
      if (kfl == 0) then
          call fmcsmpy_r1(mxy(17), mxy(5), qx)
      else
          call fmi2m(0, mxy(8), qx)
          kls = 0
      endif

      if (kls == 1) then
          call fmi2m(1, mxy(4), qx)
          do j = 14, j2+13
             call fmadd(c(j), mxy(4), mjsums(j-13), qx)
          enddo
          call fmipwr(mxy(6), j2, mxy(5), qx)
          call fmeq(mxy(5), mxy(7), qx)
          nterm = j2 + 13
          kl = 1
          do while (kl == 1)
             if (nterm > j2+13) call fmcsmpy_r1(mxy(7), mxy(5), qx)
             do j = 1, j2
                nterm = nterm + 1
                call fmeq(mxy(7), mxy(4), qx)
                call fmcsmpy_r1(mxy(4), c(nterm), qx)
                call fmndig(ndsav1, qx)
                call fmcsaddnn_r1(mjsums(j), mxy(4), qx)
                if (qx%kflag /= 0 .or. nterm == 196) then
                    kl = 0
                    exit
                endif
                call fmndig(ndsav1 - int(mjsums(j)%mp(2)-mxy(4)%mp(2)), qx)
                call fmndig(min(ndsav1, qx%ndig), qx)
                if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
             enddo
          enddo
          qx%kflag = 0
          call fmcsnsums(j2, mjsums, qx)
          call fmndig(ndsav1, qx)
          if (nterm == 196) then
              call fmgam_m2(mxy, mresult, m_gamma_ma, m_gamma_mb, qx)
              return
          endif
          call fmi2m(1, mxy(4), qx)
          call fmsub(mjsums(j2), mxy(4), mxy(8), qx)
          call fmeq(mxy(6), mxy(3), qx)
          call fmnegate(mxy(3), qx)
          do j = 2, j2
             call fmcsmpy_r1(mxy(8), mxy(3), qx)
             call fmsub_r1(mjsums(j2-j+1), mxy(4), qx)
             call fmcsadd_r1(mxy(8), mjsums(j2-j+1), qx)
          enddo
      endif

!             Recover from using a shifted argument.

      call fmcsmpy_r1(mxy(8), mxy(17), qx)
      call fmadd(mxy(8), mxy(16), mxy(10), qx)
      if (lshift < 0) then
          call fmeq(mxy(15), mxy(3), qx)
          call fmeq(mxy(15), mxy(14), qx)
          do j = 2, -lshift
             call fmaddi(mxy(14), 1, qx)
             call fmcsmpy_r1(mxy(3), mxy(14), qx)
          enddo
          call fmdiv_r1(mxy(10), mxy(3), qx)
      endif
      if (lshift > 0) then
          if (mod(lshift, 4) == 0) then
              call fmi2m(1, mxy(3), qx)
              call fmeq(mxy(6), mxy(14), qx)
              call fmaddi(mxy(14), 3, qx)
          else
              call fmeq(mxy(6), mxy(3), qx)
              call fmaddi(mxy(3), 3, qx)
              call fmeq(mxy(3), mxy(14), qx)
              do j = 1, mod(lshift, 4)-1
                 call fmaddi(mxy(14), 1, qx)
                 call fmcsmpy_r1(mxy(3), mxy(14), qx)
              enddo
              call fmaddi(mxy(14), 1, qx)
          endif
          lshift = lshift - mod(lshift, 4)

!             The product z*(z+1)*...*(z+lshift-1) is computed four terms at a time to reduce
!             the number of fmmpy calls.

!             mxy(14) is z
!             mxy(6) is z**2
!             mxy(7) is z**3
!             mxy(8) is (z+k)*...*(z+k+3)
!             mxy(11) is the current product

          call fmi2m(1, mxy(11), qx)
          if (lshift > 0) then
              call fmsqr(mxy(14), mxy(6), qx)
              call fmmpy(mxy(14), mxy(6), mxy(7), qx)
              call fmsqr(mxy(6), mxy(8), qx)
              call fmcsmpyi(mxy(7), 6, mxy(12), qx)
              call fmcsadd_r1(mxy(8), mxy(12), qx)
              call fmcsmpyi(mxy(6), 11, mxy(12), qx)
              call fmcsadd_r1(mxy(8), mxy(12), qx)
              call fmcsmpyi(mxy(14), 6, mxy(12), qx)
              call fmcsadd_r1(mxy(8), mxy(12), qx)
              call fmeq(mxy(8), mxy(11), qx)
              call fmcsmpyi_r1(mxy(7), 16, qx)
              do k = 0, lshift-8, 4
                 call fmcsadd_r1(mxy(8), mxy(7), qx)
                 k2 = 24*(2*k + 7)
                 call fmcsmpyi(mxy(6), k2, mxy(12), qx)
                 call fmcsadd_r1(mxy(8), mxy(12), qx)
                 if (k <= sqrt(real(intmax)/49.0)) then
                     k1 = 8*(6*k*k + 42*k + 79)
                     call fmcsmpyi(mxy(14), k1, mxy(12), qx)
                     call fmcsadd_r1(mxy(8), mxy(12), qx)
                 else
                     k1 = 48*k
                     call fmcsmpyi(mxy(14), k1, mxy(12), qx)
                     call fmcsmpyi_r1(mxy(12), k, qx)
                     call fmcsadd_r1(mxy(8), mxy(12), qx)
                     k1 = 336*k + 632
                     call fmcsmpyi(mxy(14), k1, mxy(12), qx)
                     call fmcsadd_r1(mxy(8), mxy(12), qx)
                 endif
                 if (k <= (real(intmax)/17.0)**0.3333) then
                     k0 = 8*(2*k + 7)*(k*k + 7*k + 15)
                     call fmaddi(mxy(8), k0, qx)
                 else if (k <= sqrt(real(intmax)*0.9)) then
                     k0 = 8*(2*k + 7)
                     call fmi2m(k0, mxy(12), qx)
                     k0 = k*k + 7*k + 15
                     call fmcsmpyi_r1(mxy(12), k0, qx)
                     call fmcsadd_r1(mxy(8), mxy(12), qx)
                 else
                     k0 = 8*(2*k + 7)
                     call fmi2m(k0, mxy(12), qx)
                     call fmcsmpyi(mxy(12), k, mxy(9), qx)
                     call fmcsmpyi_r1(mxy(9), k, qx)
                     call fmcsadd_r1(mxy(8), mxy(9), qx)
                     k0 = 7*k + 15
                     call fmcsmpyi_r1(mxy(12), k0, qx)
                     call fmcsadd_r1(mxy(8), mxy(12), qx)
                 endif
                 call fmcsmpy_r1(mxy(11), mxy(8), qx)
              enddo
          endif
          call fmcsmpy_r1(mxy(11), mxy(3), qx)
          call fmcsmpy_r1(mxy(10), mxy(11), qx)
      endif
      call fmeq(mxy(10), mxy(11), qx)

      call fmeq(mxy(11), mresult, qx)

      return
      end subroutine fmgam_m1

      subroutine fmgam_m2(mxy, mresult, m_gamma_ma, m_gamma_mb, qx)

!  Method 2 for computing gamma(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: m_gamma_ma, m_gamma_mb
      type(multi) :: mxy(17), mresult
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: iextra, inta, k, k0, k1, k2, kwsave, large, lshift, ndsav2

!             Method 2.  Use the Ln(Gamma(z)) asymptotic series, then use exp.
!                        To speed the asymptotic series calculation,
!                        increase the argument by lshift.

      kwsave = qx%kwarn
      qx%kwarn = 0
      call fmm2i(mxy(15), inta, qx)
      qx%kwarn = kwsave

      if (qx%kflag == -4) then
          lshift = 0
      else
          lshift = max(0, int(real(qx%ndig)*qx%alogmb/4.46-real(inta)))
      endif
      if (lshift > 0) lshift = 4*(lshift/4 + 1)
      if (qx%kflag == 0) then
          if (inta <= max(200, int(qx%dlogmb*qx%ndig))) then
              if (inta <= 2) then
                  call fmi2m(1, mxy(11), qx)
                  call fmgam_sg(mxy, m_gamma_ma, m_gamma_mb, qx)
                  call fmeq(mxy(11), mresult, qx)
                  return
              endif
              inta = inta - 1
              call fmfcti(inta, mxy(11), qx)
              call fmgam_sg(mxy, m_gamma_ma, m_gamma_mb, qx)
              call fmeq(mxy(11), mresult, qx)
              return
          endif
      endif

      if (lshift /= 0) then
          call fmi2m(lshift, mxy(5), qx)
          call fmadd(mxy(15), mxy(5), mxy(14), qx)
      else
          call fmeq(mxy(15), mxy(14), qx)
      endif

!             Get Gamma for the shifted argument.

!             Compute iextra, the number of extra digits required to compensate for cancellation
!             error when the argument is large.

      iextra = min(max(int(mxy(14)%mp(2))-1, 0), int(1.0+qx%alogmx/qx%alogmb))
      if (mxy(14)%mp(2) >= qx%mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(14), qx%ndig, qx%ndig+iextra, qx)
          call fmequ_r1(mxy(15), qx%ndig, qx%ndig+iextra, qx)
      endif
      ndsav2 = qx%ndig
      call fmndig(qx%ndig + iextra, qx)
      call fmlngm(mxy(14), mxy(4), qx)
      call fmexp(mxy(4), mxy(11), qx)
      qx%ndige = 0

      call fmndig(ndsav2, qx)

!             Reverse the shifting.
!             The product ma*(ma+1)*...*(ma+lshift-1) is computed four terms at a time to reduce
!             the number of fmmpy calls.

!             mxy(6)  is z
!             mxy(7)  is z**2
!             mxy(8)  is z**3
!             mxy(9)  is (z+k)*...*(z+k+3)
!             mxy(12) is the current product

      call fmeq(mxy(15), mxy(6), qx)
      if (lshift > 0) then
          call fmsqr(mxy(6), mxy(7), qx)
          call fmmpy(mxy(6), mxy(7), mxy(8), qx)
          call fmsqr(mxy(7), mxy(9), qx)
          call fmcsmpyi(mxy(8), 6, mxy(13), qx)
          call fmcsadd_r1(mxy(9), mxy(13), qx)
          call fmcsmpyi(mxy(7), 11, mxy(13), qx)
          call fmcsadd_r1(mxy(9), mxy(13), qx)
          call fmcsmpyi(mxy(6), 6, mxy(13), qx)
          call fmcsadd_r1(mxy(9), mxy(13), qx)
          call fmeq(mxy(9), mxy(12), qx)
          call fmcsmpyi_r1(mxy(8), 16, qx)
          large = intmax
          do k = 0, lshift-8, 4
             call fmcsadd_r1(mxy(9), mxy(8), qx)
             k2 = 24*(2*k + 7)
             call fmcsmpyi(mxy(7), k2, mxy(13), qx)
             call fmcsadd_r1(mxy(9), mxy(13), qx)
             if (k <= sqrt(real(large)/49.0)) then
                 k1 = 8*(6*k*k + 42*k + 79)
                 call fmcsmpyi(mxy(6), k1, mxy(13), qx)
                 call fmcsadd_r1(mxy(9), mxy(13), qx)
             else
                 k1 = 48*k
                 call fmcsmpyi(mxy(6), k1, mxy(13), qx)
                 call fmcsmpyi_r1(mxy(13), k, qx)
                 call fmcsadd_r1(mxy(9), mxy(13), qx)
                 k1 = 336*k + 632
                 call fmcsmpyi(mxy(6), k1, mxy(13), qx)
                 call fmcsadd_r1(mxy(9), mxy(13), qx)
             endif
             if (k <= (real(large)/17.0)**0.3333) then
                 k0 = 8*(2*k + 7)*(k*k + 7*k + 15)
                 call fmaddi(mxy(9), k0, qx)
             else if (k <= sqrt(real(large)*0.9)) then
                 k0 = 8*(2*k + 7)
                 call fmi2m(k0, mxy(13), qx)
                 k0 = k*k + 7*k + 15
                 call fmcsmpyi_r1(mxy(13), k0, qx)
                 call fmcsadd_r1(mxy(9), mxy(13), qx)
             else
                 k0 = 8*(2*k + 7)
                 call fmi2m(k0, mxy(13), qx)
                 call fmcsmpyi(mxy(13), k, mxy(10), qx)
                 call fmcsmpyi_r1(mxy(10), k, qx)
                 call fmcsadd_r1(mxy(9), mxy(10), qx)
                 k0 = 7*k + 15
                 call fmcsmpyi_r1(mxy(13), k0, qx)
                 call fmcsadd_r1(mxy(9), mxy(13), qx)
             endif
             call fmcsmpy_r1(mxy(12), mxy(9), qx)
          enddo
          call fmdiv_r1(mxy(11), mxy(12), qx)
      endif

      call fmgam_sg(mxy, m_gamma_ma, m_gamma_mb, qx)
      call fmeq(mxy(11), mresult, qx)

      return
      end subroutine fmgam_m2

      subroutine fmgam_rfl(mxy, mresult, krflct, m_gamma_ma, m_gamma_mb, qx)

!  Use the reflection formula if ma was less than -1/2.

      use fmvals_parallel
      implicit none

      type(multi) :: m_gamma_ma, m_gamma_mb
      type(multi) :: mxy(17), mresult
      integer :: krflct
      intent (in) :: krflct
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: krsave, ksign
      logical, external :: fmcomp

      if (krflct == 1) then

!             Reduce the argument before multiplying by Pi.

          call fmnint(mxy(15), mxy(7), qx)
          call fmdivi(mxy(7), 2, mxy(8), qx)
          call fmint(mxy(8), mxy(2), qx)
          call fmmpyi(mxy(2), 2, mxy(9), qx)
          ksign = -1
          if (fmcomp(mxy(7), '==', mxy(9), qx)) ksign = 1
          call fmsub(mxy(15), mxy(7), mxy(10), qx)
          call fmpi(mxy(12), qx)
          qx%ndigpi = 0
          call fmmpy_r1(mxy(12), mxy(10), qx)
          krsave = qx%krad
          qx%krad = 1
          call fmsin(mxy(12), mxy(3), qx)
          mxy(3)%mp(1) = ksign*mxy(3)%mp(1)
          qx%krad = krsave
          call fmpi(mxy(12), qx)
          qx%ndigpi = 0
          call fmdiv_r2(mxy(12), mxy(3), qx)
          call fmdiv_r2(mxy(3), mxy(11), qx)
          call fmgam_sg(mxy, m_gamma_ma, m_gamma_mb, qx)
          call fmeq(mxy(11), mresult, qx)
      endif

      return
      end subroutine fmgam_rfl

      subroutine fmgam_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = gamma(ma).

!  kresult = 1 is returned if a special case gives the value of gamma(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(17), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j, k
      double precision :: d
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMGAM    '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (ma%mp(2) == qx%mexpov .and. ma%mp(1) > 0) then
          call fmoverflow(1, mresult, qx)
          if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          mresult%mp(4) = huge(qx%mbase)/d
          mresult%mp(5) = -(1.0d0 - epsilon(1.0d0)) * maxint
          kresult = 1
          return
      endif

      if (qx%kround /= 1 .and. ma%mp(2) < -ndsave) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          call fmi2m(1, mxy(1), qx)
          call fmdiv(mxy(1), malocal, mxy(2), qx)
          call fmeulr(mxy(1), qx)
          qx%ndgeul = 0
          call fmsub(mxy(2), mxy(1), mresult, qx)
          if (qx%kflag > 0) qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          kresult = 1
          return
      endif

      return
      end subroutine fmgam_sc

      subroutine fmgam_sg(mxy, m_gamma_ma, m_gamma_mb, qx)

!  Save the current values of ma and gamma(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: m_gamma_ma, m_gamma_mb
      type(multi) :: mxy(17)
      intent (in) :: mxy
      type(fm_settings) :: qx

      qx%ndggam = 0
      qx%mbsgam = 0
      if (abs(mxy(1)%mp(2)) < qx%mexpov .and. abs(mxy(11)%mp(2)) < qx%mexpov) then
          call fmeq(mxy(1), m_gamma_ma, qx)
          call fmeq(mxy(11), m_gamma_mb, qx)
          qx%ndggam = qx%ndig
          qx%mbsgam = qx%mbase
      endif

      return
      end subroutine fmgam_sg

      subroutine fmgcdi(n1, n2)

!  Find the greatest common divisor of n1 and n2, and return both having been divided by their gcd.
!  Both must be positive.

      use fmvals_parallel
      implicit none
      integer :: n1, n2
      intent (inout) :: n1, n2

      integer :: k1, k2, k3

      k1 = max(n1, n2)
      k2 = min(n1, n2)
      k3 = mod(k1, k2)
      do while (k3 > 0)
         k1 = k2
         k2 = k3
         k3 = mod(k1, k2)
      enddo

      n1 = n1/k2
      n2 = n2/k2

      return
      end subroutine fmgcdi

      subroutine fmhtbl(qx)

!  Initialize two hash tables that are used for character look-up during input conversion.

      use fmvals_parallel
      implicit none

      integer :: j, kpt
      character :: lchars(21) = (/                                             &
                  '+', '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',  &
                  '.', 'E', 'D', 'Q', 'M', 'e', 'd', 'q', 'm' /)
      integer :: ltypes(21) = (/ 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4 /)
      integer :: lvals(21) = (/  1,-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0 /)
      type(fm_settings) :: qx

      do j = lhash1, lhash2
         qx%khasht(j) = 5
         qx%khashv(j) = 0
      enddo
      do j = 1, 21
         kpt = ichar(lchars(j))
         if (kpt < lhash1 .or. kpt > lhash2) then
             write (qx%kw,                                                       &
                "(/' Error in input conversion.'/"                           //  &
                "' ICHAR function was out of range for the current', "       //  &
                "' dimensions.'/' ICHAR(''', A, ''') gave the value ', "     //  &
                "I12, ', which is outside the currently'/' dimensioned', "   //  &
                "' bounds of (', I5, ':', I5, ') for variables KHASHT ', "   //  &
                "'and KHASHV.'/' Re-define the two parameters ', "           //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain', "    //  &
                "' all possible output values from ICHAR.'//)"                   &
                   ) lchars(j), kpt, lhash1, lhash2
         else
             qx%khasht(kpt) = ltypes(j)
             qx%khashv(kpt) = lvals(j)
         endif
      enddo
      qx%lhash = 1

      return
      end subroutine fmhtbl

      subroutine fmhypot(ma, mb, mc, qx)

!  mc = sqrt( ma**2 + mb**2 )

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(2), mresult

      call fmalloc(mc, qx%ndig+2, qx)
      call fmenter2(ma, mb, kovun, mxsave, ndsave, qx)
      call fmhypot_sc(ma, mb, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mc, kovun, mxsave, ndsave, qx)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmhypot_m1(ma, mb, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mc, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmhypot

      subroutine fmhypot_m1(ma, mb, mxy, mresult, ndsave, qx)

!  Method 1 for computing sqrt( ma**2 + mb**2 )

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mxy(2), mresult
      integer :: ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      call fmequ(mb, mxy(2), ndsave, qx%ndig, qx)

      call fmsqr_r1(mxy(1), qx)
      call fmsqr_r1(mxy(2), qx)
      call fmadd_r1(mxy(1), mxy(2), qx)
      call fmsqrt(mxy(1), mresult, qx)

      return
      end subroutine fmhypot_m1

      subroutine fmhypot_sc(ma, mb, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = sqrt( ma**2 + mb**2 ).

!  kresult = 1 is returned if a special case gives the value of sqrt( ma**2 + mb**2 )

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mxy(2), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      double precision :: xe, ye
      logical, external :: fmcomp

      kresult = 0

      qx%namest(qx%ncall) = 'FMHYPOT  '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp2(ma, mb, qx)
      call fmndig(j, qx)

      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) then
          if (ma%mp(5) >= 0 .or. mb%mp(5) >= 0) then
              call fmunknown(mresult, qx)
              kresult = 1
              return
          endif
      endif

      if (qx%kround /= 1) then
          call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
          call fmequ(mb, mxy(2), ndsave, qx%ndig, qx)
          mxy(1)%mp(1) = 1
          mxy(2)%mp(1) = 1
          if (fmcomp(mxy(1), '>=', mxy(2), qx)) then
              call fmsqr_r1(mxy(2), qx)
              call fmdivi_r1(mxy(2), 2, qx)
              call fmdiv_r1(mxy(2), mxy(1), qx)
              call fmovun_xe(mxy(1), xe, qx)
              call fmovun_xe(mxy(2), ye, qx)
              if (xe > ye+ndsave) then
                  call fmadd(mxy(1), mxy(2), mresult, qx)
                  kresult = 1
                  return
              endif
          else
              call fmsqr_r1(mxy(1), qx)
              call fmdivi_r1(mxy(1), 2, qx)
              call fmdiv_r1(mxy(1), mxy(2), qx)
              call fmovun_xe(mxy(1), xe, qx)
              call fmovun_xe(mxy(2), ye, qx)
              if (ye > xe+ndsave) then
                  call fmadd(mxy(2), mxy(1), mresult, qx)
                  kresult = 1
                  return
              endif
          endif
      endif

      return
      end subroutine fmhypot_sc

      subroutine fmi2m(ival, ma, qx)

!  ma = ival

!  Convert an integer to fm format.

!  The conversion is exact if ival is less than mbase**ndig, otherwise the result is
!  an approximation.

!  This routine performs the trace printing for the conversion.  fmi2m2 is used to do
!  the arithmetic

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ival
      intent (inout) :: ma
      type(fm_settings) :: qx

      qx%ncall = qx%ncall + 1
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMI2M'
          call fmntr_inpi(ival, qx)

          call fmi2m2(ival, ma, qx)

          call fmntr_out1(ma, qx)
      else
          call fmi2m2(ival, ma, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmi2m

      subroutine fmi2m2(ival, ma, qx)

!  ma = ival.  Internal integer conversion routine.

!  The conversion is exact if ival is less than mbase**ndig, otherwise fmdpm2 is used to get
!  an approximation.

      use fmvals_parallel
      implicit none

      integer :: ival
      type(multi) :: ma
      intent (in) :: ival
      intent (inout) :: ma
      type(fm_settings) :: qx

      double precision :: x
      real (kind(1.0d0)) :: mk, ml, mval
      integer :: j, k, nmval, nv2

      call fmalloc(ma, qx%ndig+2, qx)

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      qx%kflag = 0

      mval = abs(ival)
      nmval = int(mval)
      nv2 = nmval - 1
      if (mval > mxbase .or. nmval /= abs(ival) .or. nv2 /= abs(ival)-1) then
          call fmi2m2s(ival, ma, qx)
          return
      endif

!             Check for small ival.

      if (mval < qx%mbase) then
          do j = 4, qx%ndig+2
             ma%mp(j) = 0
          enddo
          if (ival >= 0) then
              ma%mp(3) = ival
              ma%mp(1) = 1
          else
              ma%mp(3) = -ival
              ma%mp(1) = -1
          endif
          if (ival == 0) then
              ma%mp(2) = 0
          else
              ma%mp(2) = 1
          endif
          return
      endif

!             Compute and store the digits, right to left.

      ma%mp(2) = 0
      j = qx%ndig + 2
      do while (j >= 3)
         mk = aint (mval/qx%mbase)
         ml = mval - mk*qx%mbase
         ma%mp(2) = ma%mp(2) + 1
         ma%mp(j) = ml
         if (mk > 0) then
             mval = mk
             j = j - 1
             if (j >= 3) cycle

!                  Here ival cannot be expressed exactly.

             x = ival
             call fmdpm2(x, ma, qx)
             return
         else
             exit
         endif
      enddo

!             Normalize ma.

      if (j > 3) then
          do k = j, qx%ndig+2
             ma%mp(k-j+3) = ma%mp(k)
          enddo
          do k = qx%ndig-j+6, qx%ndig+2
             ma%mp(k) = 0
          enddo
      endif

      ma%mp(1) = 1
      if (ival < 0 .and. ma%mp(2) /= qx%munkno .and. ma%mp(3) /= 0) ma%mp(1) = -1

      return
      end subroutine fmi2m2

      subroutine fmi2m2s(ival, ma, qx)

!  ma = ival.  Internal integer conversion routine.

!  This routine is called when m-variable precision is less than integer precision.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ival
      intent (inout) :: ma
      type(fm_settings) :: qx

      double precision :: x
      real (kind(1.0d0)) :: ml
      integer :: j, k, kbase, kmk, kval

      call fmalloc(ma, qx%ndig+2, qx)

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      qx%kflag = 0

!             Check for small ival.

      kval = abs(ival)
      kbase = int(qx%mbase)
      if (kval < kbase) then
          do j = 4, qx%ndig+2
             ma%mp(j) = 0
          enddo
          if (ival >= 0) then
              ma%mp(3) = ival
              ma%mp(1) = 1
          else
              ma%mp(3) = -ival
              ma%mp(1) = -1
          endif
          if (ival == 0) then
              ma%mp(2) = 0
          else
              ma%mp(2) = 1
          endif
          return
      endif

!             Compute and store the digits, right to left.

      ma%mp(2) = 0
      j = qx%ndig + 2
      do while (j >= 3)
         kmk = kval / kbase
         ml = kval - kmk*kbase
         ma%mp(2) = ma%mp(2) + 1
         ma%mp(j) = ml
         if (kmk > 0) then
             kval = kmk
             j = j - 1
             if (j >= 3) cycle

!                  Here ival cannot be expressed exactly.

             x = ival
             call fmdpm2(x, ma, qx)
             return
         else
             exit
         endif
      enddo

!             Normalize ma.

      if (j > 3) then
          do k = j, qx%ndig+2
             ma%mp(k-j+3) = ma%mp(k)
          enddo
          do k = qx%ndig-j+6, qx%ndig+2
             ma%mp(k) = 0
          enddo
      endif

      ma%mp(1) = 1
      if (ival < 0 .and. ma%mp(2) /= qx%munkno .and. ma%mp(3) /= 0) ma%mp(1) = -1

      return
      end subroutine fmi2m2s

      subroutine fmibta(mx, ma, mb, mc, qx)

!  mc = incomplete beta(mx,ma,mb)

!  Integral from 0 to mx of  t**(ma-1) * (1-t)**(mb-1)  dt.

!  0 <= mx <= 1,    0 < ma,    0 <= mb.

!  Some comments below refer to this function and its arguments as b(x,a,b).

      use fmvals_parallel
      implicit none

      type(multi) :: mx, ma, mb, mc
      intent (in) :: mx, ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, n_acc
      type(multi) :: mxy(40), mresult

      call fmalloc(mc, qx%ndig+2, qx)
      call fmenter3(mx, ma, mb, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmibta_sc(mx, ma, mb, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mc, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      call fmibta_m(mx, ma, mb, mxy, mresult, ndsave, mxsave, n_acc, qx)

      call fmexit1(mresult, mc, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmibta

      subroutine fmibta2(k_return_code, mxy, mxsave, nterms, numtry, nmethd, qx)

!  Check for various special cases in incomplete beta.

      use fmvals_parallel
      implicit none

      type(multi) :: mbern(lmbern)
      integer :: ndbern(lmbern)
      integer :: k_return_code, nterms, numtry, nmethd
      type(multi) :: mxy(40)
      real (kind(1.0d0)) :: mxsave
      intent (in) :: mxsave
      intent (inout) :: k_return_code, mxy, nterms, numtry, nmethd
      type(fm_settings) :: qx

      integer :: iextra, j, j4, jr, jswitch, k, krsave, n, nd, nd1, ndsav1, nup
      integer, parameter :: kprime(8) = (/ 2, 3, 5, 7, 11, 13, 17, 19 /)
      type(multi) :: mjsums(ljsums)
      logical, external :: fmcomp

      k_return_code = 0
      call fmi2m(0, mxy(32), qx)
      ndsav1 = qx%ndig

!             If b is small, use more guard digits.

      call fmdpm(1.0d-10, mxy(12), qx)
      if (fmcomp(mxy(3), '<=', mxy(12), qx)) then
          iextra = qx%ngrd52
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
          call fmequ_r1(mxy(2), qx%ndig, qx%ndig+iextra, qx)
          call fmequ_r1(mxy(3), qx%ndig, qx%ndig+iextra, qx)
          call fmndig(qx%ndig + iextra, qx)
      endif

      nterms = int(intmax/10)
      nmethd = 0

!             Check for special cases.

      if (mxy(1)%mp(3) == 0) then
          call fmi2m(0, mxy(21), qx)
          k_return_code = 1
          return
      endif
      call fmi2m(1, mxy(28), qx)
      if (fmcomp(mxy(28), '==', mxy(1), qx)) then
          iextra = qx%ngrd52
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
          call fmequ_r1(mxy(2), qx%ndig, qx%ndig+iextra, qx)
          call fmequ_r1(mxy(3), qx%ndig, qx%ndig+iextra, qx)
          call fmndig(qx%ndig + iextra, qx)
          call fmbeta(mxy(2), mxy(3), mxy(31), qx)
          call fmeq(mxy(31), mxy(21), qx)
          k_return_code = 1
          return
      else if (mxy(1)%mp(1) < 0 .or. fmcomp(mxy(1), '>', mxy(28), qx)) then
          call fmunknown(mxy(21), qx)
          qx%kflag = -4
          k_return_code = 2
          return
      endif
      if (mxy(2)%mp(1) < 0 .or. mxy(2)%mp(3) == 0) then
          call fmunknown(mxy(21), qx)
          qx%kflag = -4
          k_return_code = 2
          return
      endif
      if (mxy(3)%mp(1) < 0) then
          call fmunknown(mxy(21), qx)
          qx%kflag = -4
          k_return_code = 2
          return
      endif
      jr = numtry
      if (mxy(2)%mp(2) < -qx%ndig .and. mxy(3)%mp(2) < -qx%ndig) then
          call fmsub(mxy(28), mxy(1), mxy(12), qx)
          call fmln(mxy(12), mxy(21), qx)
          qx%ndigli = 0
          call fmdiv(mxy(28), mxy(2), mxy(12), qx)
          call fmsub(mxy(12), mxy(21), mxy(13), qx)
          call fmpwr(mxy(1), mxy(2), mxy(12), qx)
          call fmmpy(mxy(13), mxy(12), mxy(21), qx)
          k_return_code = 1
          return
      endif
      call fmi2m(1, mxy(12), qx)
      call fmsub(mxy(12), mxy(3), mxy(7), qx)
      call fmmpy(mxy(1), mxy(7), mxy(12), qx)
      jr = qx%kround
      qx%kround = 1
      call fmadd(mxy(12), mxy(28), mxy(7), qx)
      qx%kround = jr
      if (fmcomp(mxy(7), '==', mxy(28), qx)) then
          call fmln(mxy(1), mxy(12), qx)
          qx%ndigli = 0
          call fmmpy(mxy(2), mxy(12), mxy(21), qx)
          call fmln(mxy(2), mxy(12), qx)
          qx%ndigli = 0
          call fmsub_r2(mxy(21), mxy(12), qx)
          call fmexp(mxy(12), mxy(21), qx)
          qx%ndige = 0
          k_return_code = 2
          return
      endif

!             When a or b is large, check for an underflowed result.

      call fmdpm(1.0d+7, mxy(12), qx)
      if (fmcomp(mxy(2), '>', mxy(12), qx) .or. fmcomp(mxy(3), '>', mxy(12),qx)) then

!             If b is much larger than a, approximate beta(a, b) and use that as an upper bound.

          if (mxy(3)%mp(2) >= mxy(2)%mp(2)+qx%ndig) then
              call fmadd(mxy(3), mxy(2), mxy(12), qx)
              call fmln(mxy(12), mxy(23), qx)
              qx%ndigli = 0
              call fmmpy_r2(mxy(2), mxy(23), qx)
              call fmeq(mxy(2), mxy(27), qx)
              call fmlngm(mxy(27), mxy(24), qx)
              call fmsub(mxy(24), mxy(23), mxy(12), qx)
              call fmexp(mxy(12), mxy(21), qx)
              qx%ndige = 0
              if (mxy(21)%mp(2) <= -mxsave-1) then
                  k_return_code = 2
                  return
              endif
          endif

!             If a > 2 > b, use the bound
!                c = min( x , (a-2)/(a+b-2) )
!                beta(x, a, b) < (a-1)*x/b * c**(a-2) * (1-c)**b
!
!             An alternate bound is also tried:
!                c = min( x , (a-1)/(a+b-2) )
!                beta(x, a, b) < c**a * (1-c)**(1-b)

          call fmi2m(2, mxy(12), qx)
          if (fmcomp(mxy(2), '>', mxy(12), qx) .and. fmcomp(mxy(3), '<', mxy(12),qx)) then
              call fmi2m(2, mxy(6), qx)
              call fmsub(mxy(2), mxy(6), mxy(12), qx)
              call fmadd(mxy(2), mxy(3), mxy(7), qx)
              call fmsub_r1(mxy(7), mxy(6), qx)
              call fmdiv_r1(mxy(12), mxy(7), qx)
              call fmmin(mxy(1), mxy(12), mxy(23), qx)
              call fmi2m(1, mxy(12), qx)
              call fmsub_r2(mxy(2), mxy(12), qx)
              call fmln(mxy(12), mxy(27), qx)
              qx%ndigli = 0
              call fmln(mxy(1), mxy(12), qx)
              qx%ndigli = 0
              call fmadd_r1(mxy(27), mxy(12), qx)
              call fmln(mxy(3), mxy(12), qx)
              qx%ndigli = 0
              call fmsub_r1(mxy(27), mxy(12), qx)
              call fmi2m(2, mxy(7), qx)
              call fmsub(mxy(2), mxy(7), mxy(21), qx)
              call fmln(mxy(23), mxy(12), qx)
              qx%ndigli = 0
              call fmmpy_r2(mxy(21), mxy(12), qx)
              call fmadd_r1(mxy(27), mxy(12), qx)
              call fmi2m(1, mxy(7), qx)
              call fmsub(mxy(7), mxy(23), mxy(12), qx)
              call fmln(mxy(12), mxy(21), qx)
              qx%ndigli = 0
              call fmmpy(mxy(3), mxy(21), mxy(12), qx)
              call fmadd_r1(mxy(27), mxy(12), qx)
              call fmexp(mxy(27), mxy(21), qx)
              qx%ndige = 0
              if (mxy(21)%mp(2) <= -mxsave-1) then
                  k_return_code = 2
                  return
              endif
              call fmi2m(1, mxy(7), qx)
              call fmsub(mxy(2), mxy(7), mxy(12), qx)
              call fmadd(mxy(2), mxy(3), mxy(7), qx)
              call fmi2m(2, mxy(6), qx)
              call fmsub_r1(mxy(7), mxy(6), qx)
              call fmdiv_r1(mxy(12), mxy(7), qx)
              call fmmin(mxy(1), mxy(12), mxy(23), qx)
              call fmi2m(1, mxy(7), qx)
              call fmsub(mxy(7), mxy(23), mxy(12), qx)
              call fmln(mxy(12), mxy(27), qx)
              qx%ndigli = 0
              call fmsub(mxy(3), mxy(7), mxy(6), qx)
              call fmmpy_r2(mxy(6), mxy(27), qx)
              call fmln(mxy(1), mxy(12), qx)
              qx%ndigli = 0
              call fmmpy_r2(mxy(2), mxy(12), qx)
              call fmadd_r2(mxy(12), mxy(27), qx)
              call fmexp(mxy(27), mxy(21), qx)
              qx%ndige = 0
              if (mxy(21)%mp(2) <= -mxsave-1) then
                  k_return_code = 2
                  return
              endif
          endif

!             If a > 2 and b > 2, use the bound
!                c = min( x , (a-1)/(a+b-2) )
!                beta(x, a, b) < x * c**(a-1) * (1-c)**(b-1)

          call fmi2m(2, mxy(12), qx)
          if (fmcomp(mxy(2), '>', mxy(12), qx) .and. fmcomp(mxy(3), '>', mxy(12),qx)) then
              call fmi2m(1, mxy(7), qx)
              call fmsub(mxy(2), mxy(7), mxy(12), qx)
              call fmadd(mxy(2), mxy(3), mxy(7), qx)
              call fmi2m(2, mxy(6), qx)
              call fmsub_r1(mxy(7), mxy(6), qx)
              call fmdiv_r1(mxy(12), mxy(7), qx)
              call fmmin(mxy(1), mxy(12), mxy(23), qx)
              call fmi2m(1, mxy(7), qx)
              call fmsub(mxy(7), mxy(23), mxy(12), qx)
              call fmln(mxy(12), mxy(27), qx)
              qx%ndigli = 0
              call fmsub(mxy(3), mxy(7), mxy(6), qx)
              call fmmpy_r2(mxy(6), mxy(27), qx)
              call fmln(mxy(23), mxy(12), qx)
              qx%ndigli = 0
              call fmsub(mxy(2), mxy(7), mxy(6), qx)
              call fmmpy_r2(mxy(6), mxy(12), qx)
              call fmadd_r2(mxy(12), mxy(27), qx)
              call fmln(mxy(1), mxy(12), qx)
              qx%ndigli = 0
              call fmadd_r2(mxy(12), mxy(27), qx)
              call fmexp(mxy(27), mxy(21), qx)
              qx%ndige = 0
              if (mxy(21)%mp(2) <= -mxsave-1) then
                  k_return_code = 2
                  return
              endif
          endif
      endif

!             Check for cases where x is large enough so that at this precision, b(x,a,b) = b(a,b).
!             These are often unstable, so it is better to use Beta.

      call fmi2m(1, mxy(12), qx)
      call fmi2m(2, mxy(6), qx)
      call fmadd(mxy(2), mxy(3), mxy(7), qx)
      if (fmcomp(mxy(2), '>', mxy(12), qx) .and. fmcomp(mxy(7), '>', mxy(6),qx)) then
              call fmi2m(1, mxy(7), qx)
              call fmsub(mxy(2), mxy(7), mxy(12), qx)
              call fmadd(mxy(2), mxy(3), mxy(7), qx)
              call fmi2m(2, mxy(6), qx)
              call fmsub_r1(mxy(7), mxy(6), qx)
              call fmdiv(mxy(12), mxy(7), mxy(31), qx)
          call fmi2m(1, mxy(12), qx)
          call fmadd(mxy(2), mxy(3), mxy(7), qx)
          call fmaddi(mxy(7), -3, qx)
          if (fmcomp(mxy(31), '<', mxy(12), qx) .and. fmcomp(mxy(1), '>', mxy(31),qx) .and.  &
              mxy(7)%mp(3) /= 0) then
              call fmi2m(1, mxy(7), qx)
              call fmsub(mxy(2), mxy(7), mxy(6), qx)
              call fmsub(mxy(3), mxy(7), mxy(12), qx)
              call fmmpy_r2(mxy(6), mxy(12), qx)
              call fmadd(mxy(2), mxy(3), mxy(6), qx)
              call fmi2m(3, mxy(7), qx)
              call fmsub_r2(mxy(6), mxy(7), qx)
              call fmdiv(mxy(12), mxy(7), mxy(30), qx)
              if (mxy(30)%mp(1) >= 0) then
                  call fmi2m(1, mxy(7), qx)
                  call fmsub_r2(mxy(2), mxy(7), qx)
                  call fmsqrt(mxy(30), mxy(12), qx)
                  call fmadd(mxy(7), mxy(12), mxy(30), qx)
                  call fmadd(mxy(2), mxy(3), mxy(7), qx)
                  call fmi2m(2, mxy(6), qx)
                  call fmsub_r1(mxy(7), mxy(6), qx)
                  call fmdiv_r1(mxy(30), mxy(7), qx)
              else
                  call fmdpm(dble(1.1), mxy(30), qx)
              endif
              call fmi2m(1, mxy(12), qx)
              if (fmcomp(mxy(30), '>', mxy(31), qx) .and. fmcomp(mxy(30), '<', mxy(12),qx) .and.  &
                  fmcomp(mxy(1), '>=', mxy(30), qx)) then

!                 Approximate b(a, b).

                  jr = qx%kround
                  qx%kround = 1
                  call fmadd(mxy(2), mxy(3), mxy(12), qx)
                  qx%kround = jr
                  if (fmcomp(mxy(12), '==', mxy(2), qx)) then
                      call fmln(mxy(3), mxy(12), qx)
                      qx%ndigli = 0
                      call fmdpm(0.5d0, mxy(7), qx)
                      call fmsub_r2(mxy(3), mxy(7), qx)
                      call fmmpy(mxy(7), mxy(12), mxy(29), qx)
                      call fmsub_r1(mxy(29), mxy(3), qx)
                      call fmdpm(qx%dlogtp/2.0d0, mxy(12), qx)
                      call fmsub_r1(mxy(29), mxy(12), qx)
                      call fmln(mxy(2), mxy(12), qx)
                      qx%ndigli = 0
                      call fmmpy_r2(mxy(3), mxy(12), qx)
                      call fmsub_r1(mxy(29), mxy(12), qx)
                  else if (fmcomp(mxy(12), '==', mxy(3), qx)) then
                      call fmln(mxy(2), mxy(12), qx)
                      qx%ndigli = 0
                      call fmdp2m(0.5d0, mxy(7), qx)
                      call fmsub_r2(mxy(2), mxy(7), qx)
                      call fmmpy(mxy(7), mxy(12), mxy(29), qx)
                      call fmsub_r1(mxy(29), mxy(2), qx)
                      call fmdpm(qx%dlogtp/2.0d0, mxy(12), qx)
                      call fmsub_r1(mxy(29), mxy(12), qx)
                      call fmln(mxy(3), mxy(12), qx)
                      qx%ndigli = 0
                      call fmmpy_r2(mxy(2), mxy(12), qx)
                      call fmsub_r1(mxy(29), mxy(12), qx)
                  else
                      call fmln(mxy(2), mxy(12), qx)
                      qx%ndigli = 0
                      call fmdp2m(0.5d0, mxy(7), qx)
                      call fmsub_r2(mxy(2), mxy(7), qx)
                      call fmmpy(mxy(7), mxy(12), mxy(29), qx)
                      call fmln(mxy(3), mxy(12), qx)
                      qx%ndigli = 0
                      call fmdp2m(0.5d0, mxy(7), qx)
                      call fmsub_r2(mxy(3), mxy(7), qx)
                      call fmmpy_r2(mxy(7), mxy(12), qx)
                      call fmadd_r1(mxy(29), mxy(12), qx)
                      call fmadd(mxy(2), mxy(3), mxy(12), qx)
                      call fmln(mxy(12), mxy(7), qx)
                      qx%ndigli = 0
                      call fmdp2m(0.5d0, mxy(6), qx)
                      call fmsub_r2(mxy(12), mxy(6), qx)
                      call fmmpy(mxy(6), mxy(7), mxy(12), qx)
                      call fmsub_r1(mxy(29), mxy(12), qx)
                      call fmdpm(qx%dlogtp/2.0d0, mxy(12), qx)
                      call fmsub_r1(mxy(29), mxy(12), qx)
                  endif
                  call fmexp(mxy(29), mxy(9), qx)
                  qx%ndige = 0
                  call fmeq(mxy(9), mxy(29), qx)

!                 Bound the area from x to 1.

                  call fmi2m(1, mxy(12), qx)
                  jr = qx%kround
                  qx%kround = 1
                  call fmsub(mxy(12), mxy(1), mxy(7), qx)
                  qx%kround = jr
                  if (fmcomp(mxy(7), '==', mxy(12), qx)) then
                      call fmln(mxy(1), mxy(12), qx)
                      qx%ndigli = 0
                      call fmi2m(1, mxy(6), qx)
                      call fmsub(mxy(2), mxy(6), mxy(7), qx)
                      call fmmpy(mxy(7), mxy(12), mxy(28), qx)
                      call fmsub(mxy(3), mxy(6), mxy(7), qx)
                      call fmmpy(mxy(1), mxy(7), mxy(12), qx)
                      call fmsub_r1(mxy(28), mxy(12), qx)
                      call fmsub(mxy(6), mxy(1), mxy(12), qx)
                      call fmdivi_r1(mxy(12), 2, qx)
                      call fmln(mxy(12), mxy(13), qx)
                      qx%ndigli = 0
                      call fmsub_r1(mxy(28), mxy(13), qx)
                  else
                      call fmln(mxy(1), mxy(12), qx)
                      qx%ndigli = 0
                      call fmi2m(1, mxy(6), qx)
                      call fmsub(mxy(2), mxy(6), mxy(7), qx)
                      call fmmpy(mxy(7), mxy(12), mxy(28), qx)
                      call fmsub(mxy(3), mxy(6), mxy(7), qx)
                      call fmsub(mxy(6), mxy(1), mxy(12), qx)
                      call fmln(mxy(12), mxy(13), qx)
                      qx%ndigli = 0
                      call fmmpy_r2(mxy(7), mxy(13), qx)
                      call fmadd_r1(mxy(28), mxy(13), qx)
                      call fmdivi_r1(mxy(12), 2, qx)
                      call fmln(mxy(12), mxy(13), qx)
                      qx%ndigli = 0
                      call fmadd_r1(mxy(28), mxy(13), qx)
                  endif
                  call fmexp(mxy(28), mxy(9), qx)
                  qx%ndige = 0
                  call fmeq(mxy(9), mxy(28), qx)
                  jr = qx%kround
                  qx%kround = 1
                  call fmsub(mxy(29), mxy(28), mxy(12), qx)
                  qx%kround = jr
                  if (fmcomp(mxy(12), '==', mxy(29), qx)) then
                      call fmeq(mxy(28), mxy(33), qx)
                      call fmbeta(mxy(2), mxy(3), mxy(31), qx)
                      jr = qx%kround
                      qx%kround = 1
                      call fmsub(mxy(31), mxy(33), mxy(12), qx)
                      qx%kround = jr
                      if (fmcomp(mxy(12), '==', mxy(31), qx)) then
                          call fmeq(mxy(31), mxy(21), qx)
                          k_return_code = 1
                          return
                      endif
                  endif
              endif
          endif
      else if (mxy(2)%mp(2) < 1 .and. fmcomp(mxy(3), '>', mxy(12), qx)) then

!                 Approximate b(a, b).

          jr = qx%kround
          qx%kround = 1
          call fmadd(mxy(2), mxy(3), mxy(12), qx)
          qx%kround = jr
          if (fmcomp(mxy(12), '==', mxy(2), qx)) then
              call fmln(mxy(3), mxy(12), qx)
              qx%ndigli = 0
              call fmdp2m(0.5d0, mxy(7), qx)
              call fmsub_r2(mxy(3), mxy(7), qx)
              call fmmpy(mxy(7), mxy(12), mxy(29), qx)
              call fmsub_r1(mxy(29), mxy(3), qx)
              call fmdpm(qx%dlogtp/2.0d0, mxy(12), qx)
              call fmsub_r1(mxy(29), mxy(12), qx)
              call fmln(mxy(2), mxy(12), qx)
              qx%ndigli = 0
              call fmmpy_r2(mxy(3), mxy(12), qx)
              call fmsub_r1(mxy(29), mxy(12), qx)
          else if (fmcomp(mxy(12), '==', mxy(3), qx)) then
              call fmln(mxy(2), mxy(12), qx)
              qx%ndigli = 0
              call fmdp2m(0.5d0, mxy(7), qx)
              call fmsub_r2(mxy(2), mxy(7), qx)
              call fmmpy(mxy(7), mxy(12), mxy(29), qx)
              call fmsub_r1(mxy(29), mxy(2), qx)
              call fmdpm(qx%dlogtp/2.0d0, mxy(12), qx)
              call fmsub_r1(mxy(29), mxy(12), qx)
              call fmln(mxy(3), mxy(12), qx)
              qx%ndigli = 0
              call fmmpy_r2(mxy(2), mxy(12), qx)
              call fmsub_r1(mxy(29), mxy(12), qx)
          else
              call fmln(mxy(2), mxy(12), qx)
              qx%ndigli = 0
              call fmdp2m(0.5d0, mxy(7), qx)
              call fmsub_r2(mxy(2), mxy(7), qx)
              call fmmpy(mxy(7), mxy(12), mxy(29), qx)
              call fmln(mxy(3), mxy(12), qx)
              qx%ndigli = 0
              call fmdp2m(0.5d0, mxy(7), qx)
              call fmsub_r2(mxy(3), mxy(7), qx)
              call fmmpy_r2(mxy(7), mxy(12), qx)
              call fmadd_r1(mxy(29), mxy(12), qx)
              call fmadd(mxy(2), mxy(3), mxy(12), qx)
              call fmln(mxy(12), mxy(7), qx)
              qx%ndigli = 0
              call fmdp2m(0.5d0, mxy(6), qx)
              call fmsub_r2(mxy(12), mxy(6), qx)
              call fmmpy(mxy(6), mxy(7), mxy(12), qx)
              call fmsub_r1(mxy(29), mxy(12), qx)
              call fmdpm(qx%dlogtp/2.0d0, mxy(12), qx)
              call fmsub_r1(mxy(29), mxy(12), qx)
          endif
          call fmexp(mxy(29), mxy(9), qx)
          qx%ndige = 0
          call fmeq(mxy(9), mxy(29), qx)

!                 Bound the area from x to 1.

          call fmi2m(1, mxy(12), qx)
          jr = qx%kround
          qx%kround = 1
          call fmsub(mxy(12), mxy(1), mxy(7), qx)
          qx%kround = jr
          if (fmcomp(mxy(7), '==', mxy(12), qx)) then
              call fmln(mxy(1), mxy(12), qx)
              qx%ndigli = 0
              call fmi2m(1, mxy(6), qx)
              call fmsub(mxy(2), mxy(6), mxy(7), qx)
              call fmmpy(mxy(7), mxy(12), mxy(28), qx)
              call fmsub(mxy(3), mxy(6), mxy(7), qx)
              call fmmpy(mxy(1), mxy(7), mxy(12), qx)
              call fmsub_r1(mxy(28), mxy(12), qx)
              call fmsub(mxy(6), mxy(1), mxy(12), qx)
              call fmdivi_r1(mxy(12), 2, qx)
              call fmln(mxy(12), mxy(13), qx)
              qx%ndigli = 0
              call fmsub_r1(mxy(28), mxy(13), qx)
              call fmexp(mxy(28), mxy(9), qx)
              qx%ndige = 0
              call fmeq(mxy(9), mxy(28), qx)
          else
              call fmln(mxy(1), mxy(12), qx)
              qx%ndigli = 0
              call fmi2m(1, mxy(6), qx)
              call fmsub(mxy(2), mxy(6), mxy(7), qx)
              call fmmpy(mxy(7), mxy(12), mxy(28), qx)
              call fmsub(mxy(3), mxy(6), mxy(7), qx)
              call fmsub(mxy(6), mxy(1), mxy(12), qx)
              call fmln(mxy(12), mxy(13), qx)
              qx%ndigli = 0
              call fmmpy_r2(mxy(7), mxy(13), qx)
              call fmadd_r1(mxy(28), mxy(13), qx)
              call fmdivi_r1(mxy(12), 2, qx)
              call fmln(mxy(12), mxy(13), qx)
              qx%ndigli = 0
              call fmadd_r1(mxy(28), mxy(13), qx)
              call fmexp(mxy(28), mxy(9), qx)
              qx%ndige = 0
              call fmeq(mxy(9), mxy(28), qx)
          endif
          jr = qx%kround
          qx%kround = 1
          call fmsub(mxy(29), mxy(28), mxy(12), qx)
          qx%kround = jr
          if (fmcomp(mxy(12), '==', mxy(29), qx)) then
              call fmbeta(mxy(2), mxy(3), mxy(31), qx)
              call fmeq(mxy(31), mxy(21), qx)
              k_return_code = 1
              return
          endif
      endif

!             If b is small enough, use one of two series or an asymptotic series,
!             depending on the size of x and a.

      call fmi2m(1, mxy(6), qx)
      jr = qx%kround
      qx%kround = 1
      call fmadd(mxy(6), mxy(3), mxy(7), qx)
      call fmadd(mxy(2), mxy(3), mxy(12), qx)
      qx%kround = jr
      if ((fmcomp(mxy(7), '==', mxy(6), qx) .and. fmcomp(mxy(12), '==', mxy(2),qx)) ) then
          call fmdp2m(0.5d0, mxy(12), qx)
          if (fmcomp(mxy(1), '<=', mxy(12), qx)) then
              call fmi2m(0, mxy(22), qx)
              call fmeq(mxy(1), mxy(23), qx)
              call fmi2m(1, mxy(7), qx)
              call fmadd(mxy(2), mxy(7), mxy(12), qx)
              call fmdiv(mxy(23), mxy(12), mxy(24), qx)
              call fmeq(mxy(2), mxy(14), qx)
              call fmaddi(mxy(14), 1, qx)
              ndsav1 = qx%ndig
              do j = 2, nterms
                 call fmadd_r1(mxy(22), mxy(24), qx)
                 if (qx%kflag /= 0 .and. j >= 3) exit
                 nd1 = max(qx%ngrd22, ndsav1-int(mxy(22)%mp(2)-mxy(24)%mp(2))+1)
                 nd = min(ndsav1, nd1)
                 call fmndig(nd, qx)
                 if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                 call fmmpy_r1(mxy(23), mxy(1), qx)
                 call fmaddi(mxy(14), 1, qx)
                 call fmdiv(mxy(23), mxy(14), mxy(24), qx)
                 call fmndig(ndsav1, qx)
                 if (j == nterms) then
                     call fmunknown(mxy(21), qx)
                     k_return_code = 2
                     return
                 endif
              enddo
              call fmpwr(mxy(1), mxy(2), mxy(12), qx)
              call fmi2m(1, mxy(6), qx)
              call fmdiv(mxy(6), mxy(2), mxy(7), qx)
              call fmadd(mxy(7), mxy(22), mxy(6), qx)
              call fmmpy(mxy(12), mxy(6), mxy(22), qx)
              call fmeq(mxy(22), mxy(21), qx)
              k_return_code = 1
              return
          endif
          call fmdp2m(0.5d0, mxy(12), qx)
          call fmi2m(20, mxy(7), qx)
          if ((fmcomp(mxy(1), '>', mxy(12), qx) .and. fmcomp(mxy(2), '<', mxy(7),qx))) then
              call fmi2m(0, mxy(22), qx)
              call fmi2m(1, mxy(12), qx)
              call fmsub(mxy(12), mxy(1), mxy(25), qx)
              call fmi2m(1, mxy(7), qx)
              call fmadd(mxy(3), mxy(7), mxy(12), qx)
              call fmpwr(mxy(25), mxy(12), mxy(23), qx)
              call fmi2m(1, mxy(12), qx)
              call fmsub(mxy(12), mxy(2), mxy(7), qx)
              call fmmpy_r2(mxy(7), mxy(23), qx)

              call fmeq(mxy(23), mxy(24), qx)
              ndsav1 = qx%ndig
              do j = 2, nterms
                 call fmadd_r1(mxy(22), mxy(24), qx)
                 if (qx%kflag /= 0 .and. j >= 3) exit
                 nd1 = max(qx%ngrd22, ndsav1-int(mxy(22)%mp(2)-mxy(24)%mp(2))+1)
                 nd = min(ndsav1, nd1)
                 call fmndig(nd, qx)
                 if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                 call fmi2m(j, mxy(7), qx)
                 call fmsub(mxy(7), mxy(2), mxy(12), qx)
                 call fmmpy(mxy(23), mxy(12), mxy(7), qx)
                 call fmmpy(mxy(7), mxy(25), mxy(12), qx)
                 call fmdivi(mxy(12), j, mxy(23), qx)
                 call fmdivi(mxy(23), j, mxy(24), qx)
                 call fmndig(ndsav1, qx)
                 if (j == nterms) then
                     call fmunknown(mxy(21), qx)
                     k_return_code = 2
                     return
                 endif
              enddo
              call fmln(mxy(25), mxy(12), qx)
              qx%ndigli = 0
              call fmi2m(1, mxy(7), qx)
              call fmdiv(mxy(7), mxy(2), mxy(6), qx)
              call fmsub(mxy(6), mxy(12), mxy(7), qx)
              call fmsub(mxy(7), mxy(22), mxy(23), qx)
              call fmeulr(mxy(24), qx)
              qx%ndgeul = 0
              call fmi2m(1, mxy(12), qx)
              call fmadd(mxy(2), mxy(12), mxy(25), qx)
              call fmpsi(mxy(25), mxy(11), qx)
              call fmeq(mxy(11), mxy(25), qx)
              call fmsub(mxy(23), mxy(24), mxy(12), qx)
              call fmsub(mxy(12), mxy(25), mxy(21), qx)
              k_return_code = 1
              return
          endif

          call fmdp2m(0.5d0, mxy(12), qx)
          call fmi2m(20, mxy(7), qx)
          if ((fmcomp(mxy(1), '>', mxy(12), qx) .and. fmcomp(mxy(2), '>=', mxy(7),qx))) then
              call fmdp2m(0.7*dble(qx%ndig)*qx%alogmt, mxy(28), qx)
              if (fmcomp(mxy(2), '>=', mxy(28), qx)) then
                  nup = 0
                  call fmeq(mxy(2), mxy(32), qx)
                  call fmi2m(0, mxy(33), qx)
              else
                  call fmsub(mxy(28), mxy(2), mxy(12), qx)
                  call fmaddi(mxy(12), 1, qx)
                  call fmm2i(mxy(12), nup, qx)
                  call fmi2m(nup, mxy(12), qx)
                  call fmadd(mxy(2), mxy(12), mxy(32), qx)
                  call fmi2m(1, mxy(33), qx)
                  call fmeq(mxy(2), mxy(23), qx)
                  ndsav1 = qx%ndig
                  do j = 1, nup-1
                     call fmmpy_r1(mxy(23), mxy(1), qx)
                     call fmi2m(j, mxy(12), qx)
                     call fmadd(mxy(2), mxy(12), mxy(7), qx)
                     call fmdiv(mxy(23), mxy(7), mxy(24), qx)
                     call fmndig(ndsav1, qx)
                     call fmadd_r1(mxy(33), mxy(24), qx)
                     nd1 = max(qx%ngrd22, ndsav1-int(mxy(33)%mp(2)-mxy(24)%mp(2))+1)
                     nd = min(ndsav1, nd1)
                     call fmndig(nd, qx)
                  enddo
                  call fmndig(ndsav1, qx)
                  call fmpwr(mxy(1), mxy(2), mxy(12), qx)
                  call fmmpy(mxy(33), mxy(12), mxy(13), qx)
                  call fmi2m(1, mxy(7), qx)
                  call fmsub(mxy(7), mxy(1), mxy(12), qx)
                  call fmpwr(mxy(12), mxy(3), mxy(33), qx)
                  call fmmpy_r2(mxy(13), mxy(33), qx)
                  call fmdiv_r1(mxy(33), mxy(2), qx)
              endif

              call fmi2m(1, mxy(7), qx)
              call fmdivi(mxy(7), 2, mxy(12), qx)
              call fmsub(mxy(32), mxy(12), mxy(29), qx)
              call fmln(mxy(1), mxy(12), qx)
              qx%ndigli = 0
              call fmmpy(mxy(29), mxy(12), mxy(30), qx)
              call fmnegate(mxy(30), qx)
              call fmigm2(mxy(3), mxy(30), mxy(31), qx)
              call fmpwr(mxy(30), mxy(3), mxy(12), qx)
              call fmeq(mxy(30), mxy(13), qx)
              call fmnegate(mxy(13), qx)
              call fmexp(mxy(13), mxy(7), qx)
              qx%ndige = 0
              call fmmpy(mxy(7), mxy(12), mxy(13), qx)
              call fmdiv_r1(mxy(31), mxy(13), qx)
              call fmeq(mxy(31), mxy(22), qx)
              call fmsqr(mxy(29), mxy(12), qx)
              call fmmpyi(mxy(12), 4, mxy(23), qx)
              call fmi2m(1, mxy(24), qx)
              call fmi2m(1, mxy(25), qx)
              call fmi2m(1, mxy(26), qx)
              call fmln(mxy(1), mxy(12), qx)
              qx%ndigli = 0
              call fmdivi(mxy(12), 2, mxy(7), qx)
              call fmsqr(mxy(7), mxy(28), qx)
              ndsav1 = qx%ndig
              j4 = 0
              krsave = qx%kround
              qx%kround = 1
              do j = 1, nterms
                 jswitch = max(2, int(qx%ndig*qx%dlogmb/(2.0d0*log(23.0)) + 2))
                 if (j < jswitch) then
                     j4 = 0
                     call fmmpyi_r1(mxy(25), 4, qx)
                     call fmmpyi(mxy(26), 2*j-1, mxy(12), qx)
                     call fmmpyi(mxy(12), 2*j, mxy(26), qx)
                     call fmi2m(2, mxy(7), qx)
                     call fmsub(mxy(7), mxy(25), mxy(12), qx)
                     call fmdiv(mxy(12), mxy(26), mxy(27), qx)
                     call fmbern(2*j, mxy(27), mxy(8), mbern, ndbern, qx)
                     call fmeq(mxy(8), mxy(27), qx)
                 else
                     if (j4 == 0) then
                         j4 = 1
                         n = 2*j
                         do k = 1, 8
                            call fmi2m(kprime(k), mjsums(k), qx)
                            call fmipwr(mjsums(k), n, mxy(12), qx)
                            call fmeq(mxy(12), mjsums(k), qx)
                         enddo
                     else
                         do k = 1, 8
                            call fmmpyi_r1(mjsums(k), kprime(k)**2, qx)
                         enddo
                     endif
                     call fmpi(mxy(18), qx)
                     qx%ndigpi = 0
                     call fmi2m(1, mxy(14), qx)
                     call fmi2m(1, mxy(15), qx)
                     do k = 1, 8
                        call fmeq(mjsums(k), mxy(17), qx)
                        call fmi2m(kprime(k)**2-1, mxy(12), qx)
                        jr = qx%kround
                        qx%kround = 1
                        call fmsub(mxy(17), mxy(14), mxy(7), qx)
                        call fmdiv_r2(mxy(12), mxy(7), qx)
                        call fmsub(mxy(14), mxy(7), mxy(16), qx)
                        qx%kround = jr
                        call fmi2m(1, mxy(12), qx)
                        if (fmcomp(mxy(16), '==', mxy(12), qx)) exit
                        call fmmpy_r1(mxy(15), mxy(16), qx)
                     enddo
                     call fmeq(mjsums(1), mxy(17), qx)
                     call fmi2m(-1, mxy(7), qx)
                     call fmsqr(mxy(18), mxy(13), qx)
                     call fmdiv(mxy(7), mxy(13), mxy(12), qx)
                     call fmi2m(2, mxy(7), qx)
                     call fmsub(mxy(7), mxy(17), mxy(6), qx)
                     call fmi2m(8, mxy(7), qx)
                     call fmsub_r1(mxy(7), mxy(17), qx)
                     call fmdiv(mxy(6), mxy(7), mxy(13), qx)
                     call fmmpy(mxy(12), mxy(13), mxy(7), qx)
                     call fmmpy(mxy(7), mxy(15), mxy(16), qx)
                     call fmmpy_r2(mxy(16), mxy(27), qx)
                 endif
                 call fmi2m(2*j-2, mxy(7), qx)
                 call fmadd(mxy(3), mxy(7), mxy(12), qx)
                 call fmmpy(mxy(12), mxy(31), mxy(7), qx)
                 call fmmpyi(mxy(7), 2*j-1, mxy(31), qx)
                 call fmi2m(2*j-1, mxy(7), qx)
                 call fmadd(mxy(30), mxy(7), mxy(12), qx)
                 call fmmpy(mxy(24), mxy(12), mxy(7), qx)
                 call fmadd_r1(mxy(31), mxy(7), qx)
                 call fmdiv_r1(mxy(31), mxy(23), qx)
                 call fmmpy_r1(mxy(24), mxy(28), qx)
                 call fmmpy(mxy(27), mxy(31), mxy(19), qx)
                 call fmndig(ndsav1, qx)
                 call fmadd_r1(mxy(22), mxy(19), qx)
                 if (qx%kflag /= 0 .and. j >= 3) exit
                 nd1 = max(qx%ngrd22, ndsav1-int(mxy(22)%mp(2)-mxy(19)%mp(2))+1)
                 nd = min(ndsav1, nd1)
                 call fmndig(nd, qx)
                 if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                 if (j == nterms) then
                     call fmunknown(mxy(21), qx)
                     k_return_code = 2
                     return
                 endif
              enddo
              qx%kround = krsave
              call fmndig(ndsav1, qx)
              call fmpwr(mxy(1), mxy(29), mxy(12), qx)
              call fmln(mxy(1), mxy(13), qx)
              qx%ndigli = 0
              call fmnegate(mxy(13), qx)
              call fmpwr(mxy(13), mxy(3), mxy(21), qx)
              call fmmpy(mxy(22), mxy(12), mxy(7), qx)
              call fmmpy_r2(mxy(7), mxy(21), qx)
              call fmadd_r2(mxy(33), mxy(21), qx)
              k_return_code = 1
              return
          endif
      endif

!             If a or b is large in magnitude, use more guard digits.

      nd1 = max(int(mxy(2)%mp(2)), int(mxy(3)%mp(2)))
      nd1 = max(nd1, 0)
      iextra = min(nd1 , int(1.0+qx%alogmx/qx%alogmb))
      if (abs(mxy(2)%mp(2)) >= qx%mexpov .or. abs(mxy(3)%mp(2)) >= qx%mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
          call fmequ_r1(mxy(2), qx%ndig, qx%ndig+iextra, qx)
          call fmequ_r1(mxy(3), qx%ndig, qx%ndig+iextra, qx)
      endif
      call fmndig(qx%ndig + iextra, qx)

      return
      end subroutine fmibta2

      subroutine fmibta3(mx, ma, mb, mc, mxy, k_return_code, qx)

!  Rounding for special cases in non-standard rounding modes.

      use fmvals_parallel
      implicit none

      type(multi) :: mx, ma, mb, mc, mxy(40)
      integer :: k_return_code
      intent (in) :: mx, ma, mb
      intent (inout) :: mc, mxy, k_return_code
      type(fm_settings) :: qx

      integer :: j, j1, j2, k, k1, k2, krsave, ndsave

      j = qx%ntrace
      qx%ntrace = 0
      k = qx%kwarn
      qx%kwarn = 0
      ndsave = qx%ndig
      krsave = qx%kround
      qx%kround = 1
      call fmi2m(1, mxy(1), qx)
      call fmsub(mxy(1), mx, mxy(2), qx)
      if (mx%mp(1) < 0 .or. mxy(2)%mp(1) < 0 .or. ma%mp(1) < 0 .or. mb%mp(1) < 0) then
          qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          qx%ndig = ndsave
          qx%kround = krsave
          return
      endif
      if (krsave /= 1 .and. (mxy(2)%mp(3) == 0 .or. mx%mp(2) < -qx%ndig .or.  &
                             ma%mp(2) < -qx%ndig .or. mb%mp(2) < -qx%ndig)) then
          if (mxy(2)%mp(3) == 0) then
              qx%kround = krsave
              call fmbeta(ma, mb, mc, qx)
              k_return_code = 1
          else if (mx%mp(3) == 0) then
              qx%kround = krsave
              call fmi2m(0, mc, qx)
              k_return_code = 1
          else
              call fmndig(qx%ndig + qx%ngrd52, qx)
              call fmequ(mx, mxy(1), ndsave, qx%ndig, qx)
              call fmequ(ma, mxy(2), ndsave, qx%ndig, qx)
              call fmequ(mb, mxy(3), ndsave, qx%ndig, qx)
              call fmi2m(1, mxy(4), qx)
              call fmsub(mxy(4), mxy(3), mxy(5), qx)
              call fmmpy(mxy(1), mxy(5), mxy(6), qx)
              call fmadd(mxy(2), mxy(4), mxy(7), qx)
              call fmdiv(mxy(6), mxy(7), mxy(8), qx)
              call fmdiv(mxy(4), mxy(2), mxy(9), qx)
              if (mxy(9)%mp(2) - mxy(8)%mp(2) > qx%ndig) then
                  call fmpwr(mxy(1), mxy(2), mxy(10), qx)
                  if (mxy(10)%mp(2) > qx%mexpun .and. mxy(10)%mp(2) < qx%mexpov) then
                      call fmdiv(mxy(10), mxy(2), mxy(11), qx)
                      call fmmpy(mxy(10), mxy(8), mxy(12), qx)
                      if (ma%mp(2) < -ndsave) then
                          call fmln(mxy(1), mxy(13), qx)
                          qx%ndigli = 0
                          call fmadd_r1(mxy(12), mxy(13), qx)
                          call fmequ(mxy(9), mxy(5), qx%ndig, ndsave, qx)
                          call fmequ(mxy(13), mxy(6), qx%ndig, ndsave, qx)
                          qx%ndig = ndsave
                          qx%kround = krsave
                          call fmadd(mxy(5), mxy(6), mc, qx)
                          k_return_code = 1
                      else if (mxy(11)%mp(2) < qx%mexpov) then
                          call fmequ(mxy(11), mxy(5), qx%ndig, ndsave, qx)
                          call fmequ(mxy(5), mxy(13), ndsave, qx%ndig, qx)
                          call fmsub(mxy(11), mxy(13), mxy(8), qx)
                          if (mxy(8)%mp(3) == 0) then
                              call fmequ(mxy(12), mxy(6), qx%ndig, ndsave, qx)
                              qx%ndig = ndsave
                              qx%kround = krsave
                              call fmadd(mxy(5), mxy(6), mc, qx)
                              if (mc%mp(2) == qx%munkno) then
                                  j1 = mxy(5)%mp(2)
                                  k1 = mxy(6)%mp(2)
                                  j2 = j1
                                  if (j1 /= qx%mexpun .and. j1 < 0) j2 = j1 + 2*qx%ndig
                                  if (j1 /= qx%mexpov .and. j1 > 0) j2 = j1 - 2*qx%ndig
                                  k2 = k1
                                  if (k1 /= qx%mexpun .and. k1 < 0) k2 = k1 + 2*qx%ndig
                                  if (k1 /= qx%mexpov .and. k1 > 0) k2 = k1 - 2*qx%ndig
                                  mxy(5)%mp(2) = j2
                                  mxy(6)%mp(2) = k2
                                  call fmadd(mxy(5), mxy(6), mc, qx)
                                  k2 = mc%mp(2) - (j2 - j1) - (k2 - k1)
                                  if (mc%mp(2) /= qx%munkno) mc%mp(2) = k2
                              endif
                          else
                              qx%kround = krsave
                              call fmequ(mxy(11), mc, qx%ndig, ndsave, qx)
                          endif
                          k_return_code = 1
                      endif
                  endif
              endif
              if (k_return_code /= 1) then
                  call fmi2m(1, mxy(4), qx)
                  call fmsub(mxy(4), mxy(1), mxy(5), qx)
                  call fmpwr(mxy(5), mxy(3), mxy(6), qx)
                  call fmdiv(mxy(4), mxy(3), mxy(7), qx)
                  call fmsub(mxy(4), mxy(2), mxy(8), qx)
                  call fmmpy(mxy(1), mxy(8), mxy(9), qx)
                  call fmadd(mxy(3), mxy(4), mxy(10), qx)
                  call fmdiv(mxy(9), mxy(10), mxy(11), qx)
                  if (mxy(6)%mp(2) <= qx%mexpun) then
                      qx%ndig = ndsave
                      qx%kround = krsave
                      call fmbeta(ma, mb, mc, qx)
                      k_return_code = 1
                  else
                      call fmadd(mxy(7), mxy(11), mxy(12), qx)
                      call fmmpy(mxy(6), mxy(12), mxy(8), qx)
                      qx%ndig = ndsave
                      qx%kround = krsave
                      call fmbeta(ma, mb, mc, qx)
                      if (mc%mp(2) - mxy(8)%mp(2) > qx%ndig) k_return_code = 1
                  endif
              endif
          endif
      endif

      qx%kflag = 0
      qx%ntrace = j
      qx%kwarn = k
      qx%ndig = ndsave
      qx%kround = krsave

      return
      end subroutine fmibta3

      subroutine fmibta_m(mx, ma, mb, mxy, mresult, ndsave, mxsave, n_acc, qx)

!  Main logic for computing ibta(mx,ma,mb).

      use fmvals_parallel
      implicit none

      type(multi) :: mx, ma, mb, mxy(40), mresult
      real (kind(1.0d0)) :: mxsave
      integer :: ndsave, n_acc
      intent (in) :: mx, ma, mb, ndsave, mxsave
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      type(multi) :: mretry, mxlocal
      double precision :: err
      integer :: j, kashift, kbigab, kbshift, kfsave, kl, klr, kr_retry, krt,  &
                 k_return_code, nmethd, nterms, numtry, nwds1

      kr_retry = 0
      krt = 0
      klr = 1
      k_return_code = 0
      kbigab = 0
      do while (klr == 1)
         klr = 0

         kbigab = 0
         if (krt == 0) then
             call fmequ(mx, mxy(1), ndsave, qx%ndig, qx)
             call fmequ(ma, mxy(2), ndsave, qx%ndig, qx)
             call fmequ(mb, mxy(3), ndsave, qx%ndig, qx)
             call fmibta_ma(mx, ma, mb, mxy, k_return_code, numtry, nwds1, kashift, kbshift, kbigab, qx)
             if (k_return_code == 2) exit
         endif

!             Check some special cases.

         n_acc = nint(qx%ndig*qx%alogm2)
         call fmibta2(k_return_code, mxy, mxsave, nterms, numtry, nmethd, qx)
         qx%numbrn = 0
         if (k_return_code == 2) exit

         if (k_return_code /= 1) then
             call fmibta_mb(mxy, nmethd, qx)

             call fmequ(mx, mxlocal, ndsave, qx%ndig, qx)
             if (nmethd == 1) call fmibta_m1(mxy, k_return_code, n_acc, qx)
             if (nmethd == 2) call fmibta_m2(mxy, k_return_code, n_acc, qx)
             if (nmethd == 5) call fmibta_m5(mxy, mxlocal, nmethd, ndsave, k_return_code, n_acc, qx)

             if (nmethd == 3 .or. nmethd == 4 .or. nmethd == 6) then
                 call fmibta_mc(mxlocal, mxy, numtry, nmethd, ndsave, k_return_code, n_acc,  &
                                nwds1, kashift, kbshift, qx)
             endif
             if (k_return_code == 2) exit
         endif

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

         if (qx%ncall >= 1) then
             kl = min(qx%ndig-ndsave, int(3*qx%dlogtn/qx%dlogmb + 1.5))
             err = 0
             do j = kl, 1, -1
                err = (err + mxy(21)%mp(j+ndsave+2)) / qx%mbase
             enddo
             if ( (qx%kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
                  (qx%kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) kr_retry = kr_retry + 1
         endif
         if (kr_retry == 1 .and. qx%ndig < 2*ndsave+10) then
             kr_retry = 2
             klr = 1
             cycle
         endif

         call fmibta_md(mx, ma, mb, mxy, nterms, ndsave, k_return_code, n_acc,  &
                        kashift, kbshift, kfsave, qx)
         if (k_return_code == 2) exit
         call fmibta_me(mx, ma, mb, mxy, nterms, ndsave, k_return_code, n_acc, kbshift, qx)
         if (k_return_code == 2) exit
         call fmibta_mf(mx, ma, mb, mxy, krt, k_return_code, numtry, nmethd, ndsave, n_acc,  &
                        kashift, kbshift, kfsave, mretry, qx)
         if (k_return_code == 2) exit
         if (krt == 1) klr = 1
      enddo

      call fmequ(mxy(21), mxy(20), qx%ndig, ndsave, qx)
      if (kbigab /= 0) then
          if ((mxy(20)%mp(2) >= -mxsave  .and. kbigab == -1) .or.  &
              (mxy(20)%mp(2) <= mxsave+1 .and. kbigab ==  1) .or. (kbigab == -9)) then
              call fmunknown(mxy(21), qx)
              qx%kflag = -4
          endif
      endif

      call fmeq(mxy(21), mresult, qx)

      return
      end subroutine fmibta_m

      subroutine fmibta_m1(mxy, k_return_code, n_acc, qx)
      use fmvals_parallel
      implicit none

      type(multi) :: mxy(40)
      integer :: k_return_code, n_acc
      intent (inout) :: mxy, k_return_code, n_acc
      type(fm_settings) :: qx

      integer :: int_temp1, int_temp2, int_temp3, int_temp4, j, jcheck, jextra,  &
                 k, kl, krsave, ndig2, ndsav1, nterms

!             Method 1.  Use the pochhammer(1-b,n)*x**n/((a+n)*n!) series.

!             mxy(21) is the sum.
!             mxy(17) is the current term.
!             mxy(18) is j-b.
!             mxy(19) is 1.
!             mxy(20) is a+j.

      n_acc = nint(qx%ndig*qx%alogm2)
      nterms = int(intmax/10)
      jextra = int(0.06*qx%ndig)
      if (qx%ndig+jextra > qx%ndig) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+jextra, qx)
          call fmequ_r1(mxy(2), qx%ndig, qx%ndig+jextra, qx)
          call fmequ_r1(mxy(3), qx%ndig, qx%ndig+jextra, qx)
      endif
      call fmndig(qx%ndig + jextra, qx)
      call fmi2m(1, mxy(17), qx)
      call fmdiv(mxy(17), mxy(2), mxy(38), qx)
      call fmi2m(0, mxy(39), qx)
      call fmeq(mxy(3), mxy(18), qx)
      call fmnegate(mxy(18), qx)
      call fmeq(mxy(2), mxy(20), qx)
      call fmi2m(1, mxy(19), qx)
      call fmi2m(0, mxy(16), qx)
      call fmi2m(0, mxy(22), qx)
      jcheck = 5
      ndsav1 = qx%ndig

!             Method 1 summation loop.

      krsave = qx%kround
      qx%kround = 1
      do j = 1, nterms
         call fmndig(ndsav1, qx)
         call fmcsadd_r1(mxy(18), mxy(19), qx)
         int_temp3 = ndsav1 - int(mxy(38)%mp(2) - mxy(17)%mp(2))
         int_temp4 = ndsav1 - int(mxy(39)%mp(2) - mxy(17)%mp(2))
         int_temp1 = max(int_temp3, int_temp4)
         int_temp2 = max(qx%ngrd22, int_temp1)
         ndig2 = min(ndsav1, int_temp2)
         call fmndig(ndig2, qx)
         call fmcsmpy_r1(mxy(17), mxy(18), qx)
         call fmcsmpy_r1(mxy(17), mxy(1), qx)
         if (j > 1) call fmdivi_r1(mxy(17), j, qx)
         call fmndig(ndsav1, qx)
         call fmcsadd_r1(mxy(20), mxy(19), qx)
         call fmndig(ndig2, qx)
         call fmcsdiv(mxy(17), mxy(20), mxy(16), qx)

         call fmndig(ndsav1, qx)
         if (int(mxy(16)%mp(1)) < 0) then
             call fmadd_r2(mxy(16), mxy(39), qx)
         else
             call fmadd_r2(mxy(16), mxy(38), qx)
         endif

         if (qx%kflag < 0) exit
         if (mod(j, jcheck) == 0) then
             call fmadd(mxy(38), mxy(39), mxy(16), qx)
             kl = 1
             do k = qx%ndig+1, 1, -1
                if (mxy(16)%mp(k+1) /= mxy(22)%mp(k+1)) then
                    call fmeq(mxy(16), mxy(22), qx)
                    kl = 0
                    exit
                endif
             enddo
             if (kl == 1) exit
         endif
         if (j == nterms) then
             call fmunknown(mxy(21), qx)
             k_return_code = 2
             return
         endif
      enddo
      qx%kround = krsave

      call fmpwr(mxy(1), mxy(2), mxy(12), qx)
      call fmadd(mxy(38), mxy(39), mxy(7), qx)
      call fmcancel(mxy(38), mxy(39), mxy(7), j, qx)
      n_acc = n_acc - j
      call fmmpy(mxy(7), mxy(12), mxy(21), qx)
      call fmmpy_r1(mxy(38), mxy(12), qx)
      call fmmpy_r1(mxy(39), mxy(12), qx)

      return
      end subroutine fmibta_m1

      subroutine fmibta_m2(mxy, k_return_code, n_acc, qx)
      use fmvals_parallel
      implicit none

      type(multi) :: mxy(40)
      integer :: k_return_code, n_acc
      intent (inout) :: mxy, k_return_code, n_acc
      type(fm_settings) :: qx

      integer :: int_temp1, int_temp2, j, jextra, k, kflag1, krsave, ndsav1, nterms

!             Method 2.  Continued fraction expansion for b(x,a,b).

!             mxy(22) is the current approximation.
!             mxy(21) is the term in the sum, s(k).
!             mxy(19), mxy(20) are the latest denominators, q(k-1) and q(k).

      n_acc = nint(qx%ndig*qx%alogm2)
      nterms = int(intmax/10)
      jextra = max(1, int(5.76/qx%alogmb + 1.0)) + qx%ngrd52 + int(0.152*qx%ndig)
      if (qx%ndig+jextra > qx%ndig) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+jextra, qx)
          call fmequ_r1(mxy(2), qx%ndig, qx%ndig+jextra, qx)
          call fmequ_r1(mxy(3), qx%ndig, qx%ndig+jextra, qx)
      endif
      call fmndig(qx%ndig + jextra, qx)
      ndsav1 = qx%ndig
      call fmi2m(1, mxy(19), qx)
      call fmi2m(1, mxy(20), qx)
      call fmi2m(1, mxy(21), qx)
      call fmeq(mxy(21), mxy(38), qx)
      call fmi2m(0, mxy(39), qx)
      call fmeq(mxy(2), mxy(24), qx)
      call fmadd(mxy(2), mxy(3), mxy(25), qx)
      call fmeq(mxy(2), mxy(26), qx)
      call fmi2m(1, mxy(12), qx)
      call fmadd(mxy(2), mxy(12), mxy(27), qx)
      call fmeq(mxy(3), mxy(28), qx)
      call fmsqr(mxy(2), mxy(29), qx)
      call fmadd(mxy(29), mxy(26), mxy(30), qx)
      call fmsub(mxy(29), mxy(26), mxy(31), qx)
      call fmmpy(mxy(24), mxy(25), mxy(12), qx)
      call fmmpy(mxy(12), mxy(1), mxy(7), qx)
      call fmdiv(mxy(7), mxy(30), mxy(33), qx)
      call fmnegate(mxy(33), qx)
      call fmmpy(mxy(33), mxy(19), mxy(18), qx)
      call fmadd(mxy(20), mxy(18), mxy(17), qx)
      call fmmpy(mxy(18), mxy(21), mxy(12), qx)
      call fmdiv(mxy(12), mxy(17), mxy(21), qx)
      call fmnegate(mxy(21), qx)
      if (mxy(21)%mp(1) > 0) then
          call fmadd(mxy(38), mxy(21), mxy(19), qx)
          call fmeq(mxy(19), mxy(38), qx)
      else
          call fmadd(mxy(39), mxy(21), mxy(19), qx)
          call fmeq(mxy(19), mxy(39), qx)
      endif
      call fmeq(mxy(20), mxy(19), qx)
      call fmeq(mxy(17), mxy(20), qx)

!             Method 2 continued fraction loop.

      krsave = qx%kround
      qx%kround = 1
      do j = 1, nterms
         call fmaddi(mxy(24), 1, qx)
         call fmaddi(mxy(25), 1, qx)
         call fmaddi(mxy(26), 2, qx)
         call fmaddi(mxy(27), 2, qx)
         call fmaddi(mxy(28), -1, qx)
         call fmmpyi(mxy(26), 4, mxy(15), qx)
         call fmaddi(mxy(15), -4, qx)
         call fmcsadd_r1(mxy(29), mxy(15), qx)
         call fmadd(mxy(29), mxy(26), mxy(30), qx)
         call fmsub(mxy(29), mxy(26), mxy(31), qx)

         call fmeq(mxy(28), mxy(15), qx)
         call fmcsmpy_r1(mxy(15), mxy(1), qx)
         call fmmpyi_r1(mxy(15), j, qx)
         call fmcsdiv(mxy(15), mxy(31), mxy(33), qx)

         call fmeq(mxy(33), mxy(18), qx)
         call fmcsmpy_r1(mxy(18), mxy(19), qx)
         call fmadd(mxy(20), mxy(18), mxy(17), qx)
         call fmeq(mxy(18), mxy(15), qx)
         call fmcsmpy_r1(mxy(15), mxy(21), qx)
         call fmcsdiv(mxy(15), mxy(17), mxy(21), qx)
         call fmnegate(mxy(21), qx)

         call fmndig(ndsav1, qx)
         if (mxy(21)%mp(1) > 0) then
             call fmadd(mxy(38), mxy(21), mxy(19), qx)
             int_temp1 = qx%kflag
             call fmeq(mxy(19), mxy(38), qx)
         else
             call fmadd(mxy(39), mxy(21), mxy(19), qx)
             int_temp1 = qx%kflag
             call fmeq(mxy(19), mxy(39), qx)
         endif
         kflag1 = int_temp1

         call fmeq(mxy(20), mxy(19), qx)
         call fmeq(mxy(17), mxy(20), qx)
         call fmadd(mxy(38), mxy(39), mxy(15), qx)
         int_temp1 = ndsav1 - int(mxy(15)%mp(2) - mxy(21)%mp(2))
         int_temp2 = max(qx%ngrd22, int_temp1)
         call fmndig(min(ndsav1, int_temp2), qx)
         call fmeq(mxy(24), mxy(15), qx)
         call fmcsmpy_r1(mxy(15), mxy(25), qx)
         call fmcsmpy_r1(mxy(15), mxy(1), qx)
         call fmcsdiv(mxy(15), mxy(30), mxy(33), qx)
         call fmnegate(mxy(33), qx)

         call fmeq(mxy(33), mxy(18), qx)
         call fmcsmpy_r1(mxy(18), mxy(19), qx)
         call fmadd(mxy(20), mxy(18), mxy(17), qx)
         call fmeq(mxy(18), mxy(15), qx)
         call fmcsmpy_r1(mxy(15), mxy(21), qx)
         call fmcsdiv(mxy(15), mxy(17), mxy(21), qx)
         call fmnegate(mxy(21), qx)

         call fmndig(ndsav1, qx)
         if (mxy(21)%mp(1) > 0) then
             call fmadd(mxy(38), mxy(21), mxy(19), qx)
             int_temp1 = qx%kflag
             call fmeq(mxy(19), mxy(38), qx)
         else
             call fmadd(mxy(39), mxy(21), mxy(19), qx)
             int_temp1 = qx%kflag
             call fmeq(mxy(19), mxy(39), qx)
         endif
         qx%kflag = int_temp1

!             Check for convergence.

         if (kflag1 == 1 .and. qx%kflag == 1) then
             exit
         endif
         call fmeq(mxy(20), mxy(19), qx)
         call fmeq(mxy(17), mxy(20), qx)
         call fmadd(mxy(38), mxy(39), mxy(15), qx)
         int_temp1 = ndsav1 - int(mxy(15)%mp(2) - mxy(21)%mp(2))
         int_temp2 = max(qx%ngrd22, int_temp1)
         call fmndig(min(ndsav1, int_temp2), qx)
         if (j == nterms) then
             call fmunknown(mxy(21), qx)
             k_return_code = 2
             return
         endif
      enddo
      call fmadd(mxy(38), mxy(39), mxy(15), qx)
      call fmcancel(mxy(38), mxy(39), mxy(15), k, qx)
      n_acc = n_acc - k
      call fmeq(mxy(15), mxy(22), qx)
      qx%kround = krsave

!             Multiply the sums by x**a * (1-x)**b / a

      call fmeq(mxy(38), mxy(40), qx)
      call fmibta_m2b(mxy, k_return_code, qx)
      if (k_return_code == 2) return
      call fmeq(mxy(40), mxy(38), qx)
      call fmeq(mxy(39), mxy(40), qx)
      call fmibta_m2b(mxy, k_return_code, qx)
      if (k_return_code == 2) return
      call fmeq(mxy(40), mxy(39), qx)
      call fmeq(mxy(22), mxy(40), qx)
      call fmibta_m2b(mxy, k_return_code, qx)
      if (k_return_code == 2) return
      call fmeq(mxy(40), mxy(21), qx)

      return
      end subroutine fmibta_m2

      subroutine fmibta_m2b(mxy, k_return_code, qx)
      use fmvals_parallel
      implicit none

!  Multiply the sum in mxy(40) by  x^a * (1-x)^b / a  and return the result in mxy(40).

      type(multi) :: mxy(40)
      integer :: k_return_code
      intent (inout) :: mxy, k_return_code
      type(fm_settings) :: qx

      integer :: k, nterms

      nterms = int(intmax/10)

      call fmln(mxy(1), mxy(19), qx)
      qx%ndigli = 0
      call fmmpy_r1(mxy(19), mxy(2), qx)
      if (mxy(1)%mp(2)*(-10) >= qx%ndig) then
          call fmeq(mxy(1), mxy(15), qx)
          call fmeq(mxy(1), mxy(20), qx)
          do k = 2, nterms
             call fmmpy_r1(mxy(15), mxy(1), qx)
             call fmdivi(mxy(15), k, mxy(12), qx)
             call fmadd_r1(mxy(20), mxy(12), qx)
             if (qx%kflag /= 0) exit
             if (k == nterms) then
                 call fmunknown(mxy(21), qx)
                 k_return_code = 2
                 return
             endif
          enddo
          call fmmpy_r1(mxy(20), mxy(3), qx)
          call fmnegate(mxy(20), qx)
      else
          call fmi2m(1, mxy(12), qx)
          call fmsub_r1(mxy(12), mxy(1), qx)
          call fmln(mxy(12), mxy(20), qx)
          qx%ndigli = 0
          call fmmpy_r1(mxy(20), mxy(3), qx)
      endif
      call fmadd(mxy(19), mxy(20), mxy(12), qx)
      call fmexp(mxy(12), mxy(21), qx)
      qx%ndige = 0
      call fmmpy_r1(mxy(40), mxy(21), qx)
      if (mxy(21)%mp(2) == qx%munkno) then
          if (mxy(40)%mp(1)*mxy(40)%mp(3) > 0) then
              call fmln(mxy(40), mxy(12), qx)
              qx%ndigli = 0
              call fmadd(mxy(12), mxy(19), mxy(7), qx)
              call fmadd(mxy(7), mxy(20), mxy(12), qx)
              call fmexp(mxy(12), mxy(21), qx)
              qx%ndige = 0
          else
              call fmeq(mxy(40), mxy(13), qx)
              call fmnegate(mxy(13), qx)
              call fmln(mxy(13), mxy(12), qx)
              qx%ndigli = 0
              call fmadd(mxy(12), mxy(19), mxy(7), qx)
              call fmadd(mxy(7), mxy(20), mxy(12), qx)
              call fmexp(mxy(12), mxy(21), qx)
              qx%ndige = 0
              call fmnegate(mxy(21), qx)
          endif
      endif
      if (abs(mxy(40)%mp(2)) < qx%mexpov) call fmdiv_r1(mxy(40), mxy(2), qx)

      return
      end subroutine fmibta_m2b

      subroutine fmibta_m5(mxy, mx, nmethd, ndsave, k_return_code, n_acc, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(40), mx
      integer :: nmethd, ndsave, k_return_code, n_acc
      intent (in) :: mx, nmethd, ndsave
      intent (inout) :: mxy, k_return_code, n_acc
      type(fm_settings) :: qx

      integer :: int_temp1, int_temp2, j, jextra, k, krsave, ndsav1, nterms

!             Method 5.  Continued fraction expansion 2 for b(x,a,b).

!             mxy(22) is the current sum.
!             mxy(21) is the term in the sum, s(k).
!             mxy(19), mxy(20) are the latest denominators, q(k-1) and q(k).

      n_acc = nint(qx%ndig*qx%alogm2)
      nterms = int(intmax/10)
      jextra = max(1, int(5.76/qx%alogmb + 1.0)) + int(0.07*qx%ndig)
      if (qx%ndig+jextra > qx%ndig) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+jextra, qx)
          call fmequ_r1(mxy(2), qx%ndig, qx%ndig+jextra, qx)
          call fmequ_r1(mxy(3), qx%ndig, qx%ndig+jextra, qx)
      endif
      call fmndig(qx%ndig + jextra, qx)
      ndsav1 = qx%ndig
      call fmsqr(mxy(1), mxy(23), qx)
      call fmi2m(1, mxy(12), qx)
      call fmsub(mxy(2), mxy(12), mxy(24), qx)
      call fmadd(mxy(2), mxy(3), mxy(25), qx)
      call fmaddi(mxy(25), -1, qx)
      call fmeq(mxy(24), mxy(26), qx)
      call fmi2m(1, mxy(12), qx)
      call fmadd(mxy(2), mxy(12), mxy(27), qx)
      call fmeq(mxy(3), mxy(28), qx)
      call fmi2m(1, mxy(7), qx)
      call fmsub(mxy(2), mxy(7), mxy(12), qx)
      call fmsqr(mxy(12), mxy(29), qx)
      call fmi2m(2, mxy(12), qx)
      call fmsub(mxy(12), mxy(1), mxy(30), qx)
      if (nmethd == 6) then
          call fmequ(mx, mxy(19), ndsave, qx%ndig, qx)
          call fmmpy(mxy(2), mxy(19), mxy(7), qx)
          call fmmpy(mxy(3), mxy(1), mxy(12), qx)
          call fmsub(mxy(7), mxy(12), mxy(31), qx)
          call fmaddi(mxy(31), 1, qx)
      else
          call fmadd(mxy(2), mxy(3), mxy(7), qx)
          call fmmpy(mxy(7), mxy(1), mxy(12), qx)
          call fmsub(mxy(2), mxy(12), mxy(31), qx)
          call fmaddi(mxy(31), 1, qx)
      endif
      call fmeq(mxy(2), mxy(35), qx)
      call fmi2m(2, mxy(7), qx)
      call fmsub(mxy(2), mxy(7), mxy(12), qx)
      call fmmpyi(mxy(12), 4, mxy(36), qx)

      call fmi2m(1, mxy(33), qx)
      call fmmpy(mxy(35), mxy(31), mxy(12), qx)
      call fmdiv(mxy(12), mxy(27), mxy(34), qx)

      call fmi2m(1, mxy(19), qx)
      call fmeq(mxy(34), mxy(20), qx)
      call fmdiv(mxy(33), mxy(34), mxy(21), qx)
      if (mxy(21)%mp(1) > 0) then
          call fmeq(mxy(21), mxy(38), qx)
          call fmi2m(0, mxy(39), qx)
      else
          call fmeq(mxy(21), mxy(39), qx)
          call fmi2m(0, mxy(38), qx)
      endif

!             Method 5 continued fraction loop.

      krsave = qx%kround
      qx%kround = 1
      do j = 1, nterms
         call fmaddi(mxy(24), 1, qx)
         call fmaddi(mxy(25), 1, qx)
         call fmaddi(mxy(26), 2, qx)
         call fmaddi(mxy(27), 2, qx)
         call fmaddi(mxy(28), -1, qx)
         call fmaddi(mxy(36), 8, qx)
         call fmcsadd_r1(mxy(29), mxy(36), qx)
         call fmcsadd_r1(mxy(31), mxy(30), qx)
         call fmaddi(mxy(35), 1, qx)

         call fmeq(mxy(24), mxy(15), qx)
         call fmcsmpy_r1(mxy(15), mxy(25), qx)
         call fmcsmpyi_r1(mxy(15), j, qx)
         call fmcsmpy_r1(mxy(15), mxy(28), qx)
         call fmcsmpy_r1(mxy(15), mxy(23), qx)
         call fmcsdiv(mxy(15), mxy(29), mxy(33), qx)

         call fmeq(mxy(35), mxy(15), qx)
         call fmcsmpy_r1(mxy(15), mxy(31), qx)
         call fmcsdiv(mxy(15), mxy(27), mxy(34), qx)
         call fmeq(mxy(28), mxy(15), qx)
         call fmcsmpy_r1(mxy(15), mxy(1), qx)
         call fmcsmpyi_r1(mxy(15), j, qx)
         call fmdiv_r1(mxy(15), mxy(26), qx)
         call fmcsadd_r1(mxy(34), mxy(15), qx)
         call fmaddi(mxy(34), j, qx)

         call fmeq(mxy(33), mxy(18), qx)
         call fmcsmpy_r1(mxy(18), mxy(19), qx)
         call fmeq(mxy(34), mxy(15), qx)
         call fmcsmpy_r1(mxy(15), mxy(20), qx)
         call fmadd(mxy(15), mxy(18), mxy(17), qx)
         call fmeq(mxy(18), mxy(15), qx)
         call fmcsmpy_r1(mxy(15), mxy(21), qx)
         call fmcsdiv(mxy(15), mxy(17), mxy(21), qx)
         call fmnegate(mxy(21), qx)

         call fmndig(ndsav1, qx)
         if (mxy(21)%mp(1) > 0) then
             call fmadd(mxy(38), mxy(21), mxy(19), qx)
             int_temp1 = qx%kflag
             call fmeq(mxy(19), mxy(38), qx)
         else
             call fmadd(mxy(39), mxy(21), mxy(19), qx)
             int_temp1 = qx%kflag
             call fmeq(mxy(19), mxy(39), qx)
         endif
         qx%kflag = int_temp1

!             Check for convergence.

         if (qx%kflag == 1 .and. j > 4) then
             exit
         endif

         call fmeq(mxy(20), mxy(19), qx)
         call fmeq(mxy(17), mxy(20), qx)
         call fmadd(mxy(38), mxy(39), mxy(15), qx)
         int_temp1 = ndsav1 - int(mxy(15)%mp(2) - mxy(21)%mp(2))
         int_temp2 = max(qx%ngrd22, int_temp1)
         call fmndig(min(ndsav1, int_temp2), qx)
         if (j == nterms) then
             call fmunknown(mxy(21), qx)
             k_return_code = 2
             return
         endif
      enddo
      call fmadd(mxy(38), mxy(39), mxy(15), qx)
      call fmcancel(mxy(38), mxy(39), mxy(15), k, qx)
      n_acc = n_acc - k
      call fmeq(mxy(15), mxy(22), qx)

      qx%kround = krsave
      call fmndig(ndsav1, qx)

!             Multiply the sums by x**a * (1-x)**b

      call fmeq(mxy(38), mxy(40), qx)
      call fmibta_m5b(mx, mxy, ndsave, k_return_code, nmethd, qx)
      if (k_return_code == 2) return
      call fmeq(mxy(40), mxy(38), qx)
      call fmeq(mxy(39), mxy(40), qx)
      call fmibta_m5b(mx, mxy, ndsave, k_return_code, nmethd, qx)
      if (k_return_code == 2) return
      call fmeq(mxy(40), mxy(39), qx)
      call fmeq(mxy(22), mxy(40), qx)
      call fmibta_m5b(mx, mxy, ndsave, k_return_code, nmethd, qx)
      if (k_return_code == 2) return
      call fmeq(mxy(40), mxy(21), qx)

      return
      end subroutine fmibta_m5

      subroutine fmibta_m5b(mx, mxy, ndsave, k_return_code, nmethd, qx)
      use fmvals_parallel
      implicit none

!  Return mxy(40) = x^a * (1-x)^b

      type(multi) :: mx, mxy(40)
      integer :: ndsave, k_return_code, nmethd
      intent (in) :: mx, ndsave, nmethd
      intent (inout) :: mxy, k_return_code
      type(fm_settings) :: qx

      integer :: k, nterms
      logical, external :: fmcomp

      nterms = int(intmax/10)
      call fmi2m(1, mxy(12), qx)
      if (fmcomp(mxy(1), '==', mxy(12), qx) .and.  &
          nmethd == 6) then
          call fmequ(mx, mxy(19), ndsave, qx%ndig, qx)
          call fmmpy_r1(mxy(19), mxy(2), qx)
          call fmnegate(mxy(19), qx)
      else if (mx%mp(2) <= -1 .and. nmethd == 6) then
          call fmequ(mx, mxy(19), ndsave, qx%ndig, qx)
          call fmeq(mxy(19), mxy(15), qx)
          call fmeq(mxy(19), mxy(20), qx)
          do k = 2, nterms
             call fmmpy_r1(mxy(15), mxy(19), qx)
             call fmdivi(mxy(15), k, mxy(12), qx)
             call fmadd_r1(mxy(20), mxy(12), qx)
             if (qx%kflag /= 0) exit
             if (k == nterms) then
                 call fmunknown(mxy(21), qx)
                 k_return_code = 2
                 return
             endif
          enddo
          call fmmpy(mxy(20), mxy(2), mxy(19), qx)
          call fmnegate(mxy(19), qx)
      else
          call fmln(mxy(1), mxy(19), qx)
          qx%ndigli = 0
          call fmmpy_r1(mxy(19), mxy(2), qx)
      endif
      if (nmethd == 6) then
          call fmequ(mx, mxy(20), ndsave, qx%ndig, qx)
          call fmln(mxy(20), mxy(10), qx)
          qx%ndigli = 0
          call fmmpy(mxy(10), mxy(3), mxy(20), qx)
      else if (mxy(1)%mp(2) <= -1) then
          call fmeq(mxy(1), mxy(15), qx)
          call fmeq(mxy(1), mxy(20), qx)
          do k = 2, nterms
             call fmmpy_r1(mxy(15), mxy(1), qx)
             call fmdivi(mxy(15), k, mxy(12), qx)
             call fmadd_r1(mxy(20), mxy(12), qx)
             if (qx%kflag /= 0) exit
             if (k == nterms) then
                 call fmunknown(mxy(21), qx)
                 k_return_code = 2
                 return
             endif
          enddo
          call fmmpy_r1(mxy(20), mxy(3), qx)
          call fmnegate(mxy(20), qx)
      else
          call fmi2m(1, mxy(12), qx)
          call fmsub_r1(mxy(12), mxy(1), qx)
          call fmln(mxy(12), mxy(20), qx)
          qx%ndigli = 0
          call fmmpy_r1(mxy(20), mxy(3), qx)
      endif
      call fmadd(mxy(19), mxy(20), mxy(12), qx)
      call fmexp(mxy(12), mxy(21), qx)
      qx%ndige = 0
      call fmmpy_r2(mxy(40), mxy(21), qx)
      if (mxy(21)%mp(2) == qx%munkno) then
          if (mxy(40)%mp(1)*mxy(40)%mp(3) > 0) then
              call fmln(mxy(40), mxy(12), qx)
              qx%ndigli = 0
              call fmadd(mxy(12), mxy(19), mxy(7), qx)
              call fmadd(mxy(7), mxy(20), mxy(12), qx)
              call fmexp(mxy(12), mxy(21), qx)
              qx%ndige = 0
          else
              call fmeq(mxy(40), mxy(13), qx)
              call fmnegate(mxy(13), qx)
              call fmln(mxy(13), mxy(12), qx)
              qx%ndigli = 0
              call fmadd(mxy(12), mxy(19), mxy(7), qx)
              call fmadd(mxy(7), mxy(20), mxy(12), qx)
              call fmexp(mxy(12), mxy(21), qx)
              qx%ndige = 0
              call fmnegate(mxy(21), qx)
          endif
      endif
      call fmeq(mxy(21), mxy(40), qx)

      return
      end subroutine fmibta_m5b

      subroutine fmibta_ma(mx, ma, mb, mxy, k_return_code, numtry, nwds1, kashift, kbshift, kbigab, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: mx, ma, mb, mxy(40)
      integer :: k_return_code, numtry, nwds1, kashift, kbshift, kbigab
      intent (in) :: mx, ma, mb
      intent (inout) :: mxy, k_return_code, numtry, nwds1, kashift, kbshift, kbigab
      type(fm_settings) :: qx

      logical, external :: fmcomp


!             Handle cases where at least one of x, a, b is underflow or overflow.
!             Increasing any underflowed values to 1/huge makes the calculations more stable.
!             If a is underflow and the final result is overflow, it is safe to return overflow.
!             If x is underflow and the final result is underflow, it is safe to return underflow.
!             If b is underflow, it is replaced by zero.
!             Similarly, decreasing any overflowed a or b values to huge and then getting a final
!             result of underflow means it is safe to return underflow.
!             Any cases where the inequalities conflict, such as a = underflow, b = overflow,
!             will return unknown.

      kbigab = 0
      if (ma%mp(2) == qx%mexpov) then
          call fmbig(mxy(2), qx)
          kbigab = -1
      endif
      if (mb%mp(2) == qx%mexpov) then
          call fmbig(mxy(3), qx)
          kbigab = -1
      endif
      if (mx%mp(2) == qx%mexpun) then
          call fmbig(mxy(1), qx)
          call fmi2m(1, mxy(12), qx)
          call fmdiv_r2(mxy(12), mxy(1), qx)
          kbigab = -1
      endif
      if (ma%mp(2) == qx%mexpun) then
          call fmbig(mxy(2), qx)
          call fmi2m(1, mxy(12), qx)
          call fmdiv_r2(mxy(12), mxy(2), qx)
          if (kbigab < 0) then
              kbigab = -9
              call fmi2m(0, mxy(21), qx)
              k_return_code = 2
              return
          else
              kbigab = 1
          endif
      endif
      if (mb%mp(2) == qx%mexpun) then
          call fmi2m(1, mxy(12), qx)
          if (fmcomp(mxy(1), '/=', mxy(12), qx)) then
              call fmi2m(0, mxy(3), qx)
          endif
      endif
      numtry = 0
      nwds1 = 0
      kashift = 0
      kbshift = 0

      return
      end subroutine fmibta_ma

      subroutine fmibta_mb(mxy, nmethd, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(40)
      integer :: nmethd
      intent (inout) :: mxy, nmethd
      type(fm_settings) :: qx

      logical, external :: fmcomp

!             Determine which method to use.

!             nmethd = 1 means use the convergent series for b(x,a,b),
!                    = 2 means use continued fraction expansion 1 for b(x,a,b),
!                    = 3 means use the convergent series for b(1-x,b,a).
!                    = 4 means use continued fraction expansion 1 for b(1-x,b,a).
!                    = 5 means use continued fraction expansion 2 for b(x,a,b).
!                    = 6 means use continued fraction expansion 2 for b(1-x,b,a).

      call fmsqr(mxy(2), mxy(12), qx)
      call fmdpm(dble(0.00173), mxy(7), qx)
      call fmmpy(mxy(7), mxy(12), mxy(6), qx)
      call fmsqr(mxy(3), mxy(12), qx)
      call fmdpm(dble(0.01253), mxy(7), qx)
      call fmmpy(mxy(7), mxy(12), mxy(5), qx)
      call fmadd_r1(mxy(6), mxy(5), qx)
      call fmdpm(dble(0.21583), mxy(7), qx)
      call fmmpy(mxy(7), mxy(2), mxy(5), qx)
      call fmadd_r1(mxy(6), mxy(5), qx)
      call fmdpm(dble(0.03891), mxy(7), qx)
      call fmmpy(mxy(7), mxy(3), mxy(5), qx)
      call fmadd_r1(mxy(6), mxy(5), qx)
      call fmdpm(dble(9.14350), mxy(5), qx)
      call fmadd_r1(mxy(6), mxy(5), qx)

      call fmdpm(dble(0.11709), mxy(7), qx)
      call fmmpy(mxy(7), mxy(2), mxy(5), qx)
      call fmdpm(dble(0.62633), mxy(7), qx)
      call fmmpy(mxy(7), mxy(3), mxy(4), qx)
      call fmadd_r1(mxy(5), mxy(4), qx)
      call fmaddi(mxy(5), 1, qx)

      call fmdiv(mxy(5), mxy(6), mxy(33), qx)

      call fmdpm(dble(0.29217), mxy(7), qx)
      call fmmpy(mxy(7), mxy(2), mxy(6), qx)
      call fmdpm(dble(2.09304), mxy(7), qx)
      call fmmpy(mxy(7), mxy(3), mxy(5), qx)
      call fmadd_r1(mxy(6), mxy(5), qx)
      call fmdpm(dble(1.53724), mxy(5), qx)
      call fmadd_r1(mxy(6), mxy(5), qx)

      call fmdpm(dble(0.29217), mxy(7), qx)
      call fmmpy(mxy(7), mxy(2), mxy(5), qx)
      call fmdpm(dble(2.09304), mxy(7), qx)
      call fmmpy(mxy(7), mxy(3), mxy(4), qx)
      call fmadd_r1(mxy(5), mxy(4), qx)
      call fmaddi(mxy(5), 1, qx)

      call fmdiv(mxy(5), mxy(6), mxy(34), qx)

      call fmsqr(mxy(2), mxy(12), qx)
      call fmdpm(dble(0.04038), mxy(7), qx)
      call fmmpy(mxy(7), mxy(12), mxy(6), qx)
      call fmsqr(mxy(3), mxy(12), qx)
      call fmdpm(dble(0.05754), mxy(7), qx)
      call fmmpy(mxy(7), mxy(12), mxy(5), qx)
      call fmadd_r1(mxy(6), mxy(5), qx)
      call fmdpm(dble(0.02670), mxy(7), qx)
      call fmmpy(mxy(7), mxy(2), mxy(5), qx)
      call fmadd_r1(mxy(6), mxy(5), qx)
      call fmdpm(dble(0.56206), mxy(7), qx)
      call fmmpy(mxy(7), mxy(3), mxy(5), qx)
      call fmadd_r1(mxy(6), mxy(5), qx)
      call fmdpm(dble(0.13746), mxy(5), qx)
      call fmadd_r1(mxy(6), mxy(5), qx)

      call fmdpm(dble(0.87312), mxy(7), qx)
      call fmmpy(mxy(7), mxy(2), mxy(5), qx)
      call fmdpm(dble(0.20334), mxy(7), qx)
      call fmmpy(mxy(7), mxy(3), mxy(4), qx)
      call fmadd_r1(mxy(5), mxy(4), qx)
      call fmaddi(mxy(5), 1, qx)

      call fmdiv(mxy(5), mxy(6), mxy(35), qx)

      call fmdpm(dble(0.64584), mxy(7), qx)
      call fmmpy(mxy(7), mxy(2), mxy(6), qx)
      call fmdpm(dble(0.64584), mxy(7), qx)
      call fmmpy(mxy(7), mxy(3), mxy(5), qx)
      call fmadd_r1(mxy(6), mxy(5), qx)
      call fmdpm(dble(6.31958), mxy(5), qx)
      call fmadd_r1(mxy(6), mxy(5), qx)

      call fmdpm(dble(0.64584), mxy(7), qx)
      call fmmpy(mxy(7), mxy(2), mxy(5), qx)
      call fmaddi(mxy(5), 1, qx)

      call fmdiv(mxy(5), mxy(6), mxy(36), qx)

      call fmsqr(mxy(2), mxy(12), qx)
      call fmdpm(dble(0.11637), mxy(7), qx)
      call fmmpy(mxy(7), mxy(12), mxy(6), qx)
      call fmsqr(mxy(3), mxy(12), qx)
      call fmdpm(dble(0.10718), mxy(7), qx)
      call fmmpy(mxy(7), mxy(12), mxy(5), qx)
      call fmadd_r1(mxy(6), mxy(5), qx)
      call fmdpm(dble(0.92626), mxy(7), qx)
      call fmmpy(mxy(7), mxy(2), mxy(5), qx)
      call fmadd_r1(mxy(6), mxy(5), qx)
      call fmdpm(dble(0.05518), mxy(7), qx)
      call fmmpy(mxy(7), mxy(3), mxy(5), qx)
      call fmadd_r1(mxy(6), mxy(5), qx)
      call fmdpm(dble(0.28962), mxy(5), qx)
      call fmadd_r1(mxy(6), mxy(5), qx)

      call fmdpm(dble(0.99773), mxy(7), qx)
      call fmmpy(mxy(7), mxy(2), mxy(5), qx)
      call fmdpm(dble(0.56855), mxy(7), qx)
      call fmmpy(mxy(7), mxy(3), mxy(4), qx)
      call fmadd_r1(mxy(5), mxy(4), qx)
      call fmaddi(mxy(5), 1, qx)

      call fmdiv(mxy(5), mxy(6), mxy(37), qx)
      if (fmcomp(mxy(1), '<=', mxy(33), qx)) then
          nmethd = 1
      else if (fmcomp(mxy(1), '>=', mxy(34), qx)) then
          nmethd = 3
      else if (fmcomp(mxy(1), '<', mxy(37), qx)) then
          if (fmcomp(mxy(1), '<', mxy(35), qx)) then
              nmethd = 2
          else
              nmethd = 4
          endif
      else
          if (fmcomp(mxy(1), '<', mxy(36), qx)) then
              nmethd = 5
          else
              nmethd = 6
          endif
      endif
      if (mxy(3)%mp(2) <= 0 .and. mxy(2)%mp(2)+qx%ndig < 0) then
          nmethd = 1
      endif

      return
      end subroutine fmibta_mb

      subroutine fmibta_mc(mx, mxy, numtry, nmethd, ndsave, k_return_code, n_acc,  &
                           nwds1, kashift, kbshift, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: mx, mxy(40)
      integer :: numtry, nmethd, ndsave, k_return_code, n_acc, nwds1, kashift, kbshift
      intent (in) :: mx, ndsave
      intent (inout) :: mxy, numtry, nmethd, k_return_code, n_acc, nwds1, kashift, kbshift
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mla
      integer :: j, k


!             Method 3, 4, or 6.  b(x,a,b) = b(a,b) - b(1-x,b,a).

      call fmi2m(1, mxy(12), qx)
      call fmsub_r2(mxy(12), mxy(1), qx)
      do j = 1, qx%ndig+2
         mla = mxy(2)%mp(j)
         mxy(2)%mp(j) = mxy(3)%mp(j)
         mxy(3)%mp(j) = mla
      enddo
      if (nmethd == 3) then
          call fmibta_m1(mxy, k_return_code, n_acc, qx)
      else if (nmethd == 4) then
          call fmibta_m2(mxy, k_return_code, n_acc, qx)
      else
          call fmibta_m5(mxy, mx, nmethd, ndsave, k_return_code, n_acc, qx)
      endif
      if (k_return_code == 2) return

      k = nwds1
      call fmeq(mxy(21), mxy(30), qx)
      call fmbeta(mxy(2), mxy(3), mxy(32), qx)
      n_acc = nint(qx%ndig*qx%alogm2)
      if (mxy(32)%mp(1) > 0) then
          call fmsub(mxy(32), mxy(39), mxy(37), qx)
          call fmmpyi(mxy(38), -1, mxy(39), qx)
          call fmeq(mxy(37), mxy(38), qx)
      else
          call fmsub(mxy(32), mxy(38), mxy(37), qx)
          call fmmpyi(mxy(39), -1, mxy(38), qx)
          call fmeq(mxy(37), mxy(39), qx)
      endif
      call fmadd(mxy(38), mxy(39), mxy(21), qx)
      nwds1 = int(max(mxy(32)%mp(2), mxy(30)%mp(2)))
      call fmcancel(mxy(38), mxy(39), mxy(21), j, qx)
      n_acc = n_acc - j
      nwds1 = max(0, nwds1-int(mxy(21)%mp(2)))
      if (k /= nwds1 .and. numtry >= 1) then
          if (kashift == 0 .and. kbshift == 0) n_acc = -1
      endif

      return
      end subroutine fmibta_mc

      subroutine fmibta_md(mx, ma, mb, mxy, nterms, ndsave, k_return_code, n_acc,  &
                           kashift, kbshift, kfsave, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: mx, ma, mb, mxy(40)
      integer :: nterms, ndsave, k_return_code, n_acc, kashift, kbshift, kfsave
      intent (in) :: mx, ma, mb, ndsave
      intent (inout) :: mxy, nterms, k_return_code, n_acc, kashift, kbshift, kfsave
      type(fm_settings) :: qx

      integer :: j, k

!             Check for too much cancellation.

      kfsave = qx%kflag

!             Reverse the translation if kashift is positive.
!             This is used when a is small and a retry was required because of cancellation.

      if (kashift > 0 .and. n_acc > 0) then
          call fmequ(mx, mxy(22), ndsave, qx%ndig, qx)
          call fmequ(ma, mxy(23), ndsave, qx%ndig, qx)
          call fmequ(mb, mxy(24), ndsave, qx%ndig, qx)
          if (kbshift > 0) call fmaddi(mxy(24), kbshift, qx)
          call fmi2m(1, mxy(19), qx)
          call fmadd(mxy(23), mxy(24), mxy(16), qx)
          call fmi2m(1, mxy(12), qx)
          call fmadd(mxy(23), mxy(12), mxy(7), qx)
          call fmdiv(mxy(16), mxy(7), mxy(20), qx)
          call fmi2m(1, mxy(12), qx)
          call fmsub(mxy(12), mxy(22), mxy(17), qx)
          call fmeq(mxy(22), mxy(18), qx)
          call fmmpy(mxy(20), mxy(22), mxy(12), qx)
          call fmadd_r1(mxy(19), mxy(12), qx)
          call fmeq(mxy(16), mxy(14), qx)
          call fmeq(mxy(23), mxy(15), qx)
          call fmaddi(mxy(15), 1, qx)
          do j = 2, kashift-1
             call fmaddi(mxy(14), 1, qx)
             call fmaddi(mxy(15), 1, qx)
             call fmmpy_r1(mxy(20), mxy(14), qx)
             call fmdiv_r1(mxy(20), mxy(15), qx)
             call fmmpy_r1(mxy(18), mxy(22), qx)
             call fmmpy(mxy(20), mxy(18), mxy(13), qx)
             call fmadd_r1(mxy(19), mxy(13), qx)
          enddo
          if (mxy(22)%mp(2)*(-10) >= qx%ndig) then
              call fmeq(mxy(22), mxy(15), qx)
              call fmeq(mxy(22), mxy(17), qx)
              do k = 2, nterms
                 call fmmpy_r1(mxy(15), mxy(22), qx)
                 call fmdivi(mxy(15), k, mxy(12), qx)
                 call fmadd_r1(mxy(17), mxy(12), qx)
                 if (qx%kflag /= 0) exit
                 if (k == nterms) then
                     call fmunknown(mxy(21), qx)
                     k_return_code = 2
                     return
                 endif
              enddo
              call fmmpy(mxy(17), mxy(24), mxy(12), qx)
              call fmnegate(mxy(12), qx)
              call fmexp(mxy(12), mxy(18), qx)
              qx%ndige = 0
              call fmeq(mxy(19), mxy(15), qx)
              call fmpwr(mxy(22), mxy(23), mxy(12), qx)
              call fmmpy(mxy(19), mxy(12), mxy(7), qx)
              call fmmpy(mxy(7), mxy(18), mxy(12), qx)
              call fmdiv(mxy(12), mxy(23), mxy(19), qx)
              if (mxy(19)%mp(2) == qx%munkno) then
                  call fmln(mxy(22), mxy(12), qx)
                  qx%ndigli = 0
                  call fmmpy(mxy(23), mxy(12), mxy(19), qx)
                  call fmln(mxy(15), mxy(12), qx)
                  qx%ndigli = 0
                  call fmadd_r2(mxy(12), mxy(19), qx)
                  call fmmpy(mxy(17), mxy(24), mxy(12), qx)
                  call fmsub_r1(mxy(19), mxy(12), qx)
                  call fmln(mxy(23), mxy(12), qx)
                  qx%ndigli = 0
                  call fmsub_r2(mxy(19), mxy(12), qx)
                  call fmexp(mxy(12), mxy(19), qx)
                  qx%ndige = 0
              endif
          else
              call fmpwr(mxy(22), mxy(23), mxy(12), qx)
              call fmmpy_r1(mxy(19), mxy(12), qx)
              call fmpwr(mxy(17), mxy(24), mxy(12), qx)
              call fmmpy_r1(mxy(19), mxy(12), qx)
              call fmdiv_r1(mxy(19), mxy(23), qx)
          endif
          call fmmpy(mxy(21), mxy(20), mxy(12), qx)
          call fmi2m(kashift-1, mxy(7), qx)
          call fmadd_r2(mxy(16), mxy(7), qx)
          call fmmpy_r1(mxy(12), mxy(7), qx)
          call fmdiv(mxy(12), mxy(23), mxy(20), qx)
          call fmadd(mxy(20), mxy(19), mxy(21), qx)
          call fmcancel(mxy(20), mxy(19), mxy(21), j, qx)
          n_acc = n_acc - j
      endif

      return
      end subroutine fmibta_md

      subroutine fmibta_me(mx, ma, mb, mxy, nterms, ndsave, k_return_code, n_acc, kbshift, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: mx, ma, mb, mxy(40)
      integer :: nterms, ndsave, k_return_code, n_acc, kbshift
      intent (in) :: mx, ma, mb, ndsave
      intent (inout) :: mxy, nterms, k_return_code, n_acc, kbshift
      type(fm_settings) :: qx

      integer :: j, k

!             Reverse the translation if kbshift is positive.
!             This is used when x is close to 1, b is small, and a retry was required because
!             of cancellation.

      if (kbshift > 0 .and. n_acc > 0) then
          call fmequ(mx, mxy(22), ndsave, qx%ndig, qx)
          call fmequ(ma, mxy(23), ndsave, qx%ndig, qx)
          call fmequ(mb, mxy(24), ndsave, qx%ndig, qx)
          call fmi2m(1, mxy(19), qx)
          call fmi2m(1, mxy(12), qx)
          call fmadd(mxy(24), mxy(12), mxy(7), qx)
          call fmadd(mxy(23), mxy(24), mxy(12), qx)
          call fmdiv(mxy(12), mxy(7), mxy(20), qx)
          call fmadd(mxy(23), mxy(24), mxy(16), qx)
          call fmi2m(1, mxy(12), qx)
          call fmsub(mxy(12), mxy(22), mxy(17), qx)
          call fmeq(mxy(17), mxy(18), qx)
          call fmmpy(mxy(20), mxy(18), mxy(12), qx)
          call fmadd_r1(mxy(19), mxy(12), qx)
          call fmeq(mxy(16), mxy(14), qx)
          call fmeq(mxy(24), mxy(15), qx)
          call fmaddi(mxy(15), 1, qx)
          do j = 2, kbshift-1
             call fmaddi(mxy(14), 1, qx)
             call fmaddi(mxy(15), 1, qx)
             call fmmpy_r1(mxy(20), mxy(14), qx)
             call fmdiv_r1(mxy(20), mxy(15), qx)
             call fmmpy_r1(mxy(18), mxy(17), qx)
             call fmmpy(mxy(20), mxy(18), mxy(13), qx)
             call fmadd_r1(mxy(19), mxy(13), qx)
          enddo
          if (mxy(22)%mp(2)*(-10) >= qx%ndig) then
              call fmeq(mxy(22), mxy(15), qx)
              call fmeq(mxy(22), mxy(17), qx)
              do k = 2, nterms
                 call fmmpy_r1(mxy(15), mxy(22), qx)
                 call fmdivi(mxy(15), k, mxy(12), qx)
                 call fmadd_r1(mxy(17), mxy(12), qx)
                 if (qx%kflag /= 0) exit
                 if (k == nterms) then
                     call fmunknown(mxy(21), qx)
                     k_return_code = 2
                     return
                 endif
              enddo
              call fmmpy(mxy(17), mxy(24), mxy(12), qx)
              call fmnegate(mxy(12), qx)
              call fmexp(mxy(12), mxy(17), qx)
              qx%ndige = 0
              call fmpwr(mxy(22), mxy(23), mxy(12), qx)
              call fmmpy(mxy(19), mxy(12), mxy(7), qx)
              call fmmpy(mxy(7), mxy(17), mxy(12), qx)
              call fmdiv(mxy(12), mxy(24), mxy(19), qx)
          else
              call fmpwr(mxy(22), mxy(23), mxy(12), qx)
              call fmmpy_r1(mxy(19), mxy(12), qx)
              call fmpwr(mxy(17), mxy(24), mxy(12), qx)
              call fmmpy_r1(mxy(19), mxy(12), qx)
              call fmdiv_r1(mxy(19), mxy(24), qx)
          endif
          call fmmpy(mxy(21), mxy(20), mxy(12), qx)
          call fmi2m(kbshift-1, mxy(7), qx)
          call fmadd_r2(mxy(16), mxy(7), qx)
          call fmmpy_r1(mxy(12), mxy(7), qx)
          call fmdiv(mxy(12), mxy(24), mxy(20), qx)
          call fmsub(mxy(20), mxy(19), mxy(21), qx)
          call fmcancel(mxy(20), mxy(19), mxy(21), j, qx)
          n_acc = n_acc - j
      endif

      return
      end subroutine fmibta_me

      subroutine fmibta_mf(mx, ma, mb, mxy, krt, k_return_code, numtry, nmethd, ndsave, n_acc,  &
                           kashift, kbshift, kfsave, mretry, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: mx, ma, mb, mxy(40), mretry
      integer :: krt, k_return_code, numtry, nmethd, ndsave, n_acc, kashift, kbshift, kfsave
      intent (in) :: mx, ma, mb, ndsave, kfsave
      intent (inout) :: mxy, mretry, krt, k_return_code, numtry, nmethd, n_acc, kashift, kbshift
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mla
      integer :: iextra, j, ksk, ndgoal, ndold, ngoal
      logical, external :: fmcomp

      krt = 0
      if (qx%ncall >= 1) then
          ngoal = 1.06*(int(dble(ndsave)*qx%alogm2) + 29)
      else
          ngoal = int(-qx%mxexp2)
      endif
      ndgoal = int(dble(ngoal)/qx%alogm2 + 1.0)
      if (n_acc <= ngoal) then
          if (numtry > 0) then
              ksk = 0
              if (mxy(21)%mp(3) == 0 .or. kfsave < 0) then
                  ksk = 1
              else
                  do j = 1, ndgoal+1
                     if (mretry%mp(j+1) /= mxy(21)%mp(j+1)) then
                         ksk = 1
                         exit
                     endif
                  enddo
              endif
              if (ksk == 0) then
                  call fmi2m(1, mxy(15), qx)
                  n_acc = nint(qx%ndig*qx%alogm2)
                  k_return_code = 2
                  return
              endif
          endif

          iextra = int(dble(ngoal-n_acc)/qx%alogm2 + 23.03/qx%alogmb) + 1
          ndold = qx%ndig
          call fmndig(qx%ndig + iextra, qx)
          if (n_acc < 0) call fmndig(ndold + 10*2**numtry, qx)
          if (abs(mx%mp(2)) >= qx%mexpov .or. abs(ma%mp(2)) >= qx%mexpov .or.  &
              abs(mb%mp(2)) >= qx%mexpov) then
              call fmunknown(mxy(21), qx)
              qx%kflag = -4
              k_return_code = 2
              return
          endif
          call fmequ_r1(mxy(1), ndsave, qx%ndig, qx)
          call fmequ_r1(mxy(2), ndsave, qx%ndig, qx)
          call fmequ_r1(mxy(3), ndsave, qx%ndig, qx)
          if (nmethd == 3 .or. nmethd == 4 .or. nmethd == 6) then
              call fmequ(mx, mxy(1), ndsave, qx%ndig, qx)
              do j = 1, qx%ndig+2
                 mla = mxy(2)%mp(j)
                 mxy(2)%mp(j) = mxy(3)%mp(j)
                 mxy(3)%mp(j) = mla
              enddo
          endif

          if (kashift > 0) then
              call fmequ(ma, mxy(2), ndsave, qx%ndig, qx)
              if (kashift <= 2000) then
                  kashift = 9*kashift
              else
                  kashift = qx%ndig
              endif
              call fmaddi(mxy(2), kashift, qx)
          endif
          if (kbshift > 0) then
              call fmequ(mb, mxy(3), ndsave, qx%ndig, qx)
              if (kbshift <= 2000) then
                  kbshift = 9*kbshift
              else
                  kbshift = qx%ndig
              endif
              call fmaddi(mxy(3), kbshift, qx)
          endif

!             Check to see if a retry is about to be done for small a and large b.
!             If so, raise a by 2*ndig to reduce the potential cancellation error.

          call fmi2m(200, mxy(12), qx)
          if (numtry == 0 .and.                        &
              fmcomp(mxy(2), '<=', mxy(12), qx) .and.  &
              fmcomp(mxy(3), '>=', mxy(2), qx)) then
              kashift = 2*qx%ndig
              call fmaddi(mxy(2), 2*qx%ndig, qx)
          endif

!             Check to see if a retry is about to be done for a > 100 and b < 2.
!             If so, raise b by 2*ndig to reduce the potential cancellation error.

          call fmi2m(100, mxy(12), qx)
          call fmi2m(2, mxy(7), qx)
          if (numtry == 0 .and.                        &
              fmcomp(mxy(2), '>=', mxy(12), qx) .and.  &
              fmcomp(mxy(3), '<=', mxy(7), qx)) then
              kbshift = 2*qx%ndig
              call fmaddi(mxy(3), 2*qx%ndig, qx)
          endif

          call fmi2m(40*numtry, mxy(12), qx)
          call fmi2m(100, mxy(7), qx)
          if (numtry > 0 .and. kashift == 0 .and.      &
              fmcomp(mxy(2), '<=', mxy(12), qx) .and.  &
              fmcomp(mxy(3), '>=', mxy(7), qx)) then
              kashift = 2*qx%ndig
              call fmaddi(mxy(2), 2*qx%ndig, qx)
          endif

          call fmi2m(40*numtry, mxy(12), qx)
          call fmi2m(100, mxy(7), qx)
          if (numtry > 0 .and. kbshift == 0 .and.      &
              fmcomp(mxy(2), '>=', mxy(12), qx) .and.  &
              fmcomp(mxy(3), '<=', mxy(7), qx)) then
              kbshift = 2*qx%ndig
              call fmaddi(mxy(3), 2*qx%ndig, qx)
          endif

          numtry = numtry + 1
          call fmequ(mxy(21), mretry, ndold, qx%ndig, qx)
          if (kashift == 2*qx%ndig .or. kbshift == 2*qx%ndig) then
              call fmndig(max(qx%ndig, ndold+2), qx)
          endif
          krt = 1
          return
      endif

      return
      end subroutine fmibta_mf

      subroutine fmibta_sc(mx, ma, mb, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = ibta(mx,ma,mb).

!  kresult = 1 is returned if a special case gives the value of ibta(mx,ma,mb).

      use fmvals_parallel
      implicit none

      type(multi) :: mx, ma, mb, mxy(40), mresult
      integer :: kresult, ndsave
      intent (in) :: mx, ma, mb, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j, krs
      double precision :: b_xe, x_xe
      type(multi) :: mxlocal, malocal, mblocal
      logical, external :: fmcomp
      logical :: lun

      kresult = 0

      qx%namest(qx%ncall) = 'FMIBTA   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp3(mx, ma, mb, qx)
      call fmndig(j, qx)

      call fmequ(mx, mxlocal, ndsave, qx%ndig, qx)
      call fmequ(ma, malocal, ndsave, qx%ndig, qx)
      call fmequ(mb, mblocal, ndsave, qx%ndig, qx)

      if ((mxlocal%mp(2) == qx%munkno .and. mxlocal%mp(5) >= 0) .or.  &
          (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) .or.  &
          (mblocal%mp(2) == qx%munkno .and. mblocal%mp(5) >= 0)) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      call fmi2m(1, mxy(1), qx)
      lun = mx%mp(1) < 0 .or. ma%mp(1) < 0 .or. mb%mp(1) < 0
      lun = lun .or. ma%mp(3) == 0  .or. fmcomp(mxlocal, '>', mxy(1), qx)
      if (lun) then
          call fmunknown(mresult, qx)
          qx%kflag = -4
          kresult = 1
          return
      endif
      if (abs(mx%mp(2)) == qx%mexpov .or. abs(ma%mp(2)) == qx%mexpov .or.  &
          abs(mb%mp(2)) == qx%mexpov .or. mx%mp(3) == 0) then
          krs = 0
          call fmi2m(1, mxy(1), qx)
          if (mx%mp(3) == 0) then
              call fmi2m(0, mxy(8), qx)
              krs = 1
          else if (mx%mp(2) == qx%mexpun) then
              call fmovun_xe(mxlocal, x_xe, qx)
              call fmovun_xe(mblocal, b_xe, qx)
              if (b_xe+x_xe < -ndsave) then
                  call fmpwr(mxlocal, malocal, mxy(2), qx)
                  call fmdiv(mxy(2), malocal, mxy(8), qx)
                  if (mxy(8)%mp(2) /= qx%munkno) then
                      krs = 1
                  endif
              endif
          else if (ma%mp(2) == qx%mexpun .and. mb%mp(2) < qx%mexpov) then
              call fmdiv(mxy(1), malocal, mxy(8), qx)
              krs = 1
          else if (fmcomp(malocal, '==', mxy(1), qx)) then
              call fmsub(mxy(1), mxlocal, mxy(2), qx)
              call fmpwr(mxy(2), mblocal, mxy(3), qx)
              call fmsub(mxy(1), mxy(3), mxy(2), qx)
              call fmdiv(mxy(2), mblocal, mxy(8), qx)
              if (mxy(8)%mp(2) /= qx%munkno) then
                  krs = 1
              endif
          endif
          if (krs == 1) then
              call fmeq(mxy(8), mresult, qx)
              if (mresult%mp(2) == qx%munkno) then
                  qx%kflag = -4
              endif
              kresult = 1
              return
          endif
      endif

      call fmibta3(mxlocal, malocal, mblocal, mresult, mxy, kresult, qx)

      return
      end subroutine fmibta_sc

      subroutine fmigm1(ma, mb, mc, qx)

!  mc = incomplete gamma(ma, mb)

!  Integral from 0 to mb of e**(-t) * t**(ma-1)  dt.

!  This is (lower case) gamma(a, x).   Domain:  ma: all reals except integers <= 0,  mb >= 0.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(18), mresult, mretry

      call fmalloc(mc, qx%ndig+2, qx)
      call fmenter2(ma, mb, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmigm1_sc(ma, mb, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mc, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      n_acc = nint(qx%ndig*qx%alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmigm1_m(ma, mb, mxy, mresult, ndsave, retry, n_acc, mxsave, qx)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry, qx)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mc, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmigm1

      subroutine fmigm1_m(ma, mb, mxy, mresult, ndsave, retry, n_acc, mxsave, qx)

!  Method selection for computing igm1(ma, mb).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mxy(18), mresult
      integer :: ndsave, n_acc
      double precision :: mxsave
      logical :: retry
      intent (in) :: ma, mb, ndsave, mxsave
      intent (inout) :: mxy, mresult, retry, n_acc
      type(fm_settings) :: qx

      double precision :: a, b, big, c, c1, c2, d, dt1, small, t, t1, tlnb, tol, x, y
      real (kind(1.0d0)) :: moda2
      integer :: iextra, inta, intg, j, jr, k, kflaga, kflagi, kflagx, kwrnsv, kxneg,  &
                 nd1, nmethd, nterms
      logical, external :: fmcomp
      double precision, external :: fmdplg

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      call fmequ(mb, mxy(2), ndsave, qx%ndig, qx)
      n_acc = nint(qx%ndig*qx%alogm2)
      nterms = int(intmax/10)


!             Check for special cases.

!             See if a is small enough so that the result is x**a/a.

      call fmi2m(1, mxy(5), qx)
      jr = qx%kround
      qx%kround = 1
      call fmadd(mxy(1), mxy(5), mxy(4), qx)
      qx%kround = jr
      if (fmcomp(mxy(4), '==', mxy(5), qx)) then
          call fmpwr(mxy(2), mxy(1), mxy(5), qx)
          call fmdiv(mxy(5), mxy(1), mxy(13), qx)
          if (mxy(13)%mp(2) /= qx%munkno) then
              call fmeq(mxy(13), mresult, qx)
              retry = .false.
              return
          endif
      endif

!             Check to see if x is large enough so that the result is gamma(a).

      call fmi2m(1, mxy(5), qx)
      call fmdiv(mxy(1), mxy(2), mxy(4), qx)
      mxy(4)%mp(1) = 1
      call fmdpm(dble(0.001), mxy(3), qx)
      if (fmcomp(mxy(2), '>', mxy(5), qx) .and. fmcomp(mxy(4), '<=', mxy(3),qx)) then
          call fmi2m(1, mxy(4), qx)
          call fmsub(mxy(1), mxy(4), mxy(5), qx)
          call fmln(mxy(2), mxy(6), qx)
          qx%ndigli = 0
          call fmmpy(mxy(5), mxy(6), mxy(4), qx)
          call fmsub(mxy(4), mxy(2), mxy(6), qx)
          call fmexp(mxy(6), mxy(15), qx)
          qx%ndige = 0
          if (mxy(15)%mp(2) /= qx%munkno) then
              call fmgam(mxy(1), mxy(14), qx)
              call fmsub_r1(mxy(14), mxy(15), qx)
              if (mxy(14)%mp(2) > mxy(15)%mp(2)+qx%ndig .and.  &
                  mxy(14)%mp(2) /= qx%munkno) then
                  call fmeq(mxy(14), mresult, qx)
                  retry = .false.
                  return
              endif
          endif
      endif

!             a, x are double precision approximations to the two arguments to this function.
!             inta = a if a is a small integer.  It is used to limit the number of terms used in
!                    the asymptotic series and in the continued fraction expansion.

      inta = nterms
      kwrnsv = qx%kwarn
      qx%kwarn = 0
      call fmm2i(mxy(1), intg, qx)
      kflagi = qx%kflag
      if (qx%kflag == 0) inta = intg
      call fmm2dp(mxy(1), a, qx)
      kflaga = qx%kflag
      if (qx%kflag /= 0 .and. mxy(1)%mp(2) < 0) then
          a = 1.0d0/dpmax
          if (mxy(1)%mp(1) < 0) a = -a
          kflaga = 0
      endif
      call fmm2dp(mxy(2), x, qx)
      kflagx = qx%kflag
      if (qx%kflag /= 0 .and. mxy(2)%mp(2) < 0) then
          x = 1.0d0/dpmax
          if (mxy(2)%mp(1) < 0) x = -x
          kflagx = 0
      endif
      qx%kwarn = kwrnsv

!             If a or x is large in magnitude, use more guard digits.

      j = mxy(1)%mp(2)
      if (mxy(1)%mp(3) >= sqrt(dble(qx%mbase))) j = j + 1
      k = mxy(2)%mp(2)
      if (mxy(2)%mp(3) >= sqrt(dble(qx%mbase))) k = k + 1
      nd1 = max(j, k)
      iextra = min(max(nd1, 0) , int(1.0+qx%alogmx/qx%alogmb))
      if (iextra > 0) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
          call fmequ_r1(mxy(2), qx%ndig, qx%ndig+iextra, qx)
      endif
      call fmndig(qx%ndig + iextra, qx)
      n_acc = nint(qx%ndig*qx%alogm2)

!             kxneg = 1 if x is negative and a is a positive integer.

      kxneg = 0

!             moda2 = mod(a, 2) when kxneg is 1.

      moda2 = 0

      if (mxy(1)%mp(2) == qx%mexpov .or. mxy(2)%mp(2) == qx%mexpov) then
          if (mxy(1)%mp(2) == qx%mexpov .and. mxy(1)%mp(1) > 0) then
              if (mxy(2)%mp(3) == 0) then
                  call fmi2m(0, mresult, qx)
                  return
              endif
              if (mxy(2)%mp(2) == qx%mexpov .and. mxy(2)%mp(1) > 0) then
                  call fmgam(mxy(1), mresult, qx)
                  return
              else if (mxy(2)%mp(1) > 0) then
                  call fmi2m(1, mxy(13), qx)
                  if (fmcomp(mxy(2), '<=', mxy(13), qx)) then
                      call fmpwr(mxy(2), mxy(1), mxy(11), qx)
                      call fmexp(mxy(2), mxy(12), qx)
                      qx%ndige = 0
                      call fmmpy_r2(mxy(1), mxy(12), qx)
                      call fmdiv(mxy(11), mxy(12), mresult, qx)
                      qx%kflag = -6
                      return
                  else
                      call fmoverflow(1, mxy(13), qx)
                      if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
                          d = 1.0d+10
                      else
                          d = 4
                      endif
                      mxy(13)%mp(4) = huge(qx%mbase)/d
                      mxy(13)%mp(5) = -(1.0d0 - epsilon(1.0d0)) * maxint
                      qx%kflag = -5
                      call fmeq(mxy(13), mresult, qx)
                      return
                  endif
              endif
          endif
          if (mxy(2)%mp(2) == qx%mexpov .and. mxy(2)%mp(1) > 0) then
              call fmgam(mxy(1), mxy(15), qx)
              call fmeq(mxy(15), mresult, qx)
              return
          endif
          if (mxy(2)%mp(2) == qx%mexpov .and. mxy(2)%mp(1) < 0 .and.  &
              mxy(1)%mp(1) > 0.and. mxy(1)%mp(3) > 0) then
              if (mxy(1)%mp(2) /= qx%mexpov) then
                  call fmint(mxy(1), mxy(12), qx)
                  if (fmcomp(mxy(1), '==', mxy(12), qx)) then
                      call fmi2m(2, mxy(9), qx)
                      call fmmod(mxy(12), mxy(9), mxy(5), qx)
                      call fmeq(mxy(5), mxy(9), qx)
                      if (mxy(9)%mp(3) /= 0) then
                          call fmoverflow(-1, mxy(13), qx)
                          if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
                              d = 1.0d+10
                          else
                              d = 4
                          endif
                          mxy(13)%mp(4) = huge(qx%mbase)/d
                          mxy(13)%mp(5) = -(1.0d0 - epsilon(1.0d0)) * maxint
                          qx%kflag = -5
                          call fmeq(mxy(13), mresult, qx)
                          return
                      else
                          call fmoverflow(1, mxy(13), qx)
                          if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
                              d = 1.0d+10
                          else
                              d = 4
                          endif
                          mxy(13)%mp(4) = huge(qx%mbase)/d
                          mxy(13)%mp(5) = -(1.0d0 - epsilon(1.0d0)) * maxint
                          qx%kflag = -5
                          call fmeq(mxy(13), mresult, qx)
                          return
                      endif
                  endif
              endif
          endif
          call fmunknown(mresult, qx)
          qx%kflag = -4
          retry = .false.
          return
      endif

      if (mxy(1)%mp(2) == qx%mexpun .or. mxy(2)%mp(2) == qx%mexpun) then
          call fmabs(mxy(1), mxy(4), qx)
          call fmi2m(1, mxy(5), qx)
          if (fmcomp(mxy(4), '<', mxy(5), qx) .and. mxy(2)%mp(2) == qx%mexpun) then
              call fmunknown(mresult, qx)
              qx%kflag = -4
              retry = .false.
              return
          endif
          call fmabs(mxy(1), mxy(4), qx)
          call fmi2m(1, mxy(5), qx)
          if (fmcomp(mxy(4), '>=', mxy(5), qx) .and. mxy(2)%mp(2) == qx%mexpun .and.  &
              mxy(1)%mp(1) > 0 .and. mxy(2)%mp(1) > 0) then
              call fmunderflow(1, mresult, qx)
              qx%kflag = -6
              retry = .false.
              return
          endif
      endif

      if (mxy(1)%mp(1) < 0 .or. mxy(1)%mp(3) == 0) then
          call fmint(mxy(1), mxy(12), qx)
          if (fmcomp(mxy(1), '==', mxy(12), qx)) then
              call fmunknown(mresult, qx)
              qx%kflag = -4
              retry = .false.
              return
          endif
      endif
      if (mxy(2)%mp(3) == 0) then
          if (mxy(1)%mp(1) <= 0) then
              call fmunknown(mresult, qx)
              qx%kflag = -4
              retry = .false.
              return
          else
              call fmi2m(0, mresult, qx)
              retry = .false.
              return
          endif
      endif
      if (mxy(2)%mp(1) < 0) then
          call fmint(mxy(1), mxy(12), qx)
          if (fmcomp(mxy(1), '==', mxy(12), qx)) then
              kxneg = 1
              call fmi2m(2, mxy(9), qx)
              call fmmod(mxy(12), mxy(9), mxy(5), qx)
              call fmeq(mxy(5), mxy(9), qx)
              if (mxy(9)%mp(3) /= 0) moda2 = 1
          else
              call fmunknown(mresult, qx)
              qx%kflag = -4
              retry = .false.
              return
          endif
      endif
      call fmmax(mxy(1), mxy(2), mxy(5), qx)
      call fmmin(mxy(1), mxy(2), mxy(6), qx)
      call fmdpm(1.0d6, mxy(3), qx)
      call fmdpm(1.0d2, mxy(4), qx)
      if (fmcomp(mxy(5), '>=', mxy(3), qx) .and. fmcomp(mxy(6), '>=', mxy(4),qx)) then
          call fmi2m(1, mxy(5), qx)
          call fmsub(mxy(1), mxy(5), mxy(7), qx)
          call fmmin(mxy(7), mxy(2), mxy(8), qx)
          call fmaddi(mxy(8), -1, qx)
          call fmln(mxy(8), mxy(5), qx)
          qx%ndigli = 0
          call fmmpy(mxy(7), mxy(5), mxy(4), qx)
          call fmsub(mxy(4), mxy(8), mxy(5), qx)
          call fmexp(mxy(5), mxy(10), qx)
          qx%ndige = 0
          if ((mxy(10)%mp(2) == qx%mexpov .and. mxy(10)%mp(1) > 0) .or.  &
              mxy(10)%mp(2) > mxsave+1) then
              call fmabs(mxy(10), mresult, qx)
              qx%kflag = -5
              return
          endif
      endif
      call fmi2m(1, mxy(5), qx)
      if (fmcomp(mxy(1), '==', mxy(5), qx) .and. mxy(2)%mp(2) >= 0) then
          if (abs(mxy(2)%mp(2)) < qx%mexpov) then
              call fmeq(mxy(2), mxy(6), qx)
              call fmnegate(mxy(6), qx)
              call fmexp(mxy(6), mxy(7), qx)
              qx%ndige = 0
              call fmsub(mxy(5), mxy(7), mxy(13), qx)
              if (mxy(13)%mp(2) /= qx%munkno) then
                  call fmeq(mxy(13), mresult, qx)
                  retry = .false.
                  return
              endif
          endif
      endif

!             Determine which method to use.

!             nmethd = 1 means use the convergent series,
!                    = 2 means use the asymptotic series,
!                    = 3 means use the continued fraction expansion.

      nmethd = 1
      call fmi2m(-10000, mxy(8), qx)
      call fmi2m(10000, mxy(9), qx)
      call fmabs(mxy(1), mxy(11), qx)
      call fmabs(mxy(2), mxy(12), qx)
      call fmsub(mxy(12), mxy(11), mxy(10), qx)

!             Check whether the smallest term in the asymptotic series is small enough to give
!             the required accuracy.

      if (kflaga /= 0 .or. kflagx /= 0) then
          call fmdiv(mxy(12), mxy(11), mxy(10), qx)
          call fmi2m(1, mxy(8), qx)
          call fmsub(mxy(8), mxy(10), mxy(9), qx)
          if (mxy(9)%mp(1) < 0) then
              nmethd = 2
          else
              nmethd = 1
          endif
      else
          t1 = fmdplg(a, qx)
          small = t1 - fmdplg(-abs(x), qx) - (a+abs(x))*log(abs(x))
          tol = -dble(qx%ndig+2)*qx%dlogmb - 12.0d0
          b = 1.0d0
          if (a > abs(x)) b = a - abs(x)
          big = t1 - fmdplg(a-b, qx) - b*log(abs(x))

          if (fmcomp(mxy(10), '<=', mxy(8), qx)) then
              nmethd = 1
          else if (fmcomp(mxy(10), '>=', mxy(9), qx) .and. mxy(1)%mp(1) > 0 .and.  &
                   mxy(2)%mp(1) > 0) then
              nmethd = 3
              if (small < tol+big) nmethd = 2
          else if (fmcomp(mxy(10), '>=', mxy(9), qx)) then
              nmethd = 3
          else if (mxy(1)%mp(1) > 0 .and. mxy(2)%mp(1) > 0) then
              call fmdp2m(sqrt(dpmax), mxy(8), qx)
              if (fmcomp(mxy(2), '>=', mxy(8), qx)) then
                  qx%kflag = -5
                  call fmoverflow(1, mresult, qx)
                  return
              endif

              c2 = dble(ndsave)*qx%dlogmb
              c1 = c2/10.0d0 + a + 10.0d0
              dt1 = max( 10.0d0 , c2/6.0d0 )
              c2 = max( dt1 , a - 3.5d0*a/(sqrt(a)+1.0d0))
              if (x < c1) then
                  nmethd = 1
              else
                  nmethd = 3
              endif
              if (x > c2) then
                  nmethd = 3
                  if (small < tol+big) nmethd = 2
              endif
          else if (mxy(1)%mp(1) < 0 .and. mxy(2)%mp(1) > 0) then
              tlnb = qx%ndig*qx%dlogmb
              c = 0.75/tlnb**0.35
              d = 0.80*tlnb**0.70
              if (kflaga == 0 .and. kflagx == 0) then
                  t = -a - d/c
                  y = d + c*t/2.0 + (c/2.0)*sqrt(t**2 + t + (2.0/c)**2)
                  if (x > y) then
                      nmethd = 3
                  else
                      nmethd = 1
                  endif
              else
                  call fmdpm(dble(c), mxy(5), qx)
                  call fmmpy(mxy(5), mxy(1), mxy(8), qx)
                  mxy(8)%mp(1) = 1
                  if (fmcomp(mxy(2), '>', mxy(8), qx)) then
                      nmethd = 3
                  else
                      nmethd = 1
                  endif
              endif
          else if (mxy(1)%mp(1) > 0 .and. mxy(2)%mp(1) < 0) then
              call fmdpm(dble(-0.8), mxy(5), qx)
              call fmmpy(mxy(5), mxy(1), mxy(8), qx)
              if (fmcomp(mxy(8), '<', mxy(2), qx)) then
                  nmethd = 1
              else
                  nmethd = 3
              endif
          endif
      endif
      if (ma%mp(1) > 0 .and. mb%mp(1) < 0 .and.  &
          ma%mp(2) > qx%ndig .and. mb%mp(2) > qx%ndig) nmethd = 3

      if (nmethd == 1) then
          call fmigm1_m1(mxy, mresult, n_acc, kxneg, kflagx, kflaga, kflagi, inta, moda2, x, a, qx)
      else if (nmethd == 2) then
          call fmigm1_m2(mxy, mresult, n_acc, kxneg, kflagx, kflaga, kflagi, inta, x, a, qx)
      else if (nmethd == 3) then
          call fmigm1_m3(mxy, mresult, n_acc, kflagx, kflaga, kflagi, inta, moda2, x, a, qx)
      endif

      return
      end subroutine fmigm1_m

      subroutine fmigm1_m1(mxy, mresult, n_acc, kxneg, kflagx, kflaga, kflagi, inta, moda2, x, a, qx)

!  Method 1 for computing igm1(ma, mb).  Use the x**n/Pochhammer(a+1, n) series.

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(18), mresult
      integer :: n_acc, kxneg, kflagx, kflaga, kflagi, inta
      double precision :: x, a
      real (kind(1.0d0)) :: moda2
      intent (in) :: kxneg, kflagx, kflaga, kflagi, inta, moda2, x, a
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      double precision :: t1
      real (kind(1.0d0)) :: maxe
      integer :: iextra, int_temp1, j, jextra, k, kflgok, kl, ndig2,  &
                 ndsav1, nmnndg, nmxdif, nterms
      logical, external :: fmcomp
      double precision, external :: fmdplg

!             mxy(13) = mxy(17) + mxy(18) is the current sum.
!             mxy(9) is the current term.
!             mxy(8) is (a+n)/x.
!             mxy(14) is 1/x

      nterms = int(intmax/10)

!             Raise the precision if a is negative and near an integer, to compensate
!             for cancellation when (a+n)/x is near zero.

      if (mxy(1)%mp(1) < 0) then
          call fmnint(mxy(1), mxy(17), qx)
          call fmsub(mxy(1), mxy(17), mxy(14), qx)
          iextra = max(-int(mxy(14)%mp(2)), 0)
          if (abs(mxy(14)%mp(2)) >= qx%mexpov) iextra = 0
          if (iextra > 0) then
              call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
              call fmequ_r1(mxy(2), qx%ndig, qx%ndig+iextra, qx)
          endif
          call fmndig(qx%ndig + iextra, qx)
          n_acc = nint(qx%ndig*qx%alogm2)
      endif

      jextra = 0

      kl = 1
      do while (kl == 1)
         kl = 0
         call fmi2m(1, mxy(17), qx)
         call fmi2m(0, mxy(18), qx)
         call fmi2m(1, mxy(7), qx)
         call fmadd(mxy(1), mxy(7), mxy(8), qx)
         call fmdiv(mxy(2), mxy(8), mxy(9), qx)
         call fmdiv_r1(mxy(8), mxy(2), qx)
         call fmdiv(mxy(7), mxy(2), mxy(14), qx)
         ndsav1 = qx%ndig
         maxe = 1

!             If a is negative and abs(a) > abs(x), the terms in the series first decrease,
!             then increase, then decrease.  Try to predict the number of extra digits required
!             to keep the precision from prematurely becoming too small.

         kflgok = 1
         if (mxy(1)%mp(1) < 0) then
             if (kflaga == 0) then
                 if (abs(a) > 1.0d3) then
                     call fmigm1_m3(mxy, mresult, n_acc, kflagx, kflaga, kflagi, inta, moda2, x, a, qx)
                     return
                 endif
             else
                 call fmigm1_m3(mxy, mresult, n_acc, kflagx, kflaga, kflagi, inta, moda2, x, a, qx)
                 return
             endif
             kflgok = 0
             call fmabs(mxy(1), mxy(3), qx)
             call fmabs(mxy(2), mxy(4), qx)
             if (fmcomp(mxy(3), '>', mxy(4), qx)) then
                 if (jextra == 0) then
                     if (kflaga == 0 .and. kflagx == 0) then
                         t1 = fmdplg(a+aint(-abs(x)-a), qx) - fmdplg(a+1.0d0+aint(abs(x)-a),qx)
                         t1 = (t1 + 2.0d0*abs(x)*log(abs(x)+1.0d-10))/qx%dlogmb
                         t1 = max(0.0d0, t1+1.0d0)
                         jextra = t1
                     endif
                 endif

!             If a is negative and abs(a) is much bigger than abs(x), the later increase in
!             the size of the terms can be ignored.

                 if (kflaga == 0 .and. kflagx == 0) then
                     t1 = (aint(x-a)*log(abs(x)+1.0d-10) + fmdplg(a+1.0d0, qx)  &
                          - fmdplg(a+1.0d0+aint(x-a), qx)) / qx%dlogmb
                     if (t1 < -dble(qx%ndig)) kflgok = 1
                 else
                     kflgok = 1
                 endif
             endif
         endif

         nmnndg = ndsav1
         nmxdif = 0

!             Method 1 summation loop.

         n_acc = nint(qx%ndig*qx%alogm2)
         do j = 1, nterms
            call fmndig(ndsav1, qx)
            maxe = max(maxe, mxy(9)%mp(2))
            if (mxy(9)%mp(1) > 0) then
                call fmadd(mxy(17), mxy(9), mxy(16), qx)
                int_temp1 = qx%kflag
                call fmeq(mxy(16), mxy(17), qx)
            else
                call fmadd(mxy(18), mxy(9), mxy(16), qx)
                int_temp1 = qx%kflag
                call fmeq(mxy(16), mxy(18), qx)
            endif
            call fmadd(mxy(17), mxy(18), mxy(13), qx)
            qx%kflag = int_temp1
            if (qx%kflag /= 0 .and. (j > 2 .or. abs(mxy(17)%mp(2)) > qx%mxexp .or.  &
                abs(mxy(18)%mp(2)) > qx%mxexp)) then
                if (kflgok == 0 .and. kflaga == 0 .and. kflagx == 0) then
                    if (dble(j) > x-a) exit
                else
                    exit
                endif
            endif

            call fmcsadd_r1(mxy(8), mxy(14), qx)

            ndig2 = max(qx%ngrd22, ndsav1-int(mxy(13)%mp(2)-mxy(9)%mp(2)))
            call fmndig(min(ndsav1, ndig2+jextra), qx)
            nmnndg = min(nmnndg, qx%ndig)
            nmxdif = max(nmxdif, qx%ndig-nmnndg)
            call fmcsdiv(mxy(9), mxy(8), mxy(5), qx)
            call fmeq(mxy(5), mxy(9), qx)
            if (j == nterms) then
                call fmunknown(mresult, qx)
                return
            endif
         enddo
         call fmadd(mxy(17), mxy(18), mxy(16), qx)
         call fmcancel(mxy(17), mxy(18), mxy(16), k, qx)
         n_acc = n_acc - k
         call fmeq(mxy(16), mxy(13), qx)

         call fmndig(ndsav1, qx)
         if (nmxdif > jextra+1) then
             jextra = nmxdif
             kl = 1
         endif
      enddo

      call fmabs(mxy(2), mxy(5), qx)
      call fmln(mxy(5), mxy(6), qx)
      qx%ndigli = 0
      call fmmpy(mxy(1), mxy(6), mxy(4), qx)
      call fmsub(mxy(4), mxy(2), mxy(14), qx)
      call fmexp(mxy(14), mxy(15), qx)
      qx%ndige = 0
      if (mxy(15)%mp(2) == qx%munkno) then
          call fmpwr(mxy(5), mxy(1), mxy(4), qx)
          call fmexp(mxy(2), mxy(6), qx)
          qx%ndige = 0
          call fmdiv(mxy(4), mxy(6), mxy(15), qx)
      endif
      call fmdiv(mxy(13), mxy(1), mxy(12), qx)
      call fmmpy(mxy(15), mxy(12), mxy(11), qx)
      if (mxy(11)%mp(2) == qx%munkno) then
          call fmln(mxy(13), mxy(5), qx)
          qx%ndigli = 0
          call fmln(mxy(1), mxy(6), qx)
          qx%ndigli = 0
          call fmadd(mxy(14), mxy(5), mxy(4), qx)
          call fmsub(mxy(4), mxy(6), mxy(14), qx)
          call fmexp(mxy(14), mxy(13), qx)
          qx%ndige = 0
      else
          call fmeq(mxy(11), mxy(13), qx)
      endif
      if (kxneg == 1 .and. moda2 == 1) call fmnegate(mxy(13), qx)

      call fmeq(mxy(13), mresult, qx)

      return
      end subroutine fmigm1_m1

      subroutine fmigm1_m2(mxy, mresult, n_acc, kxneg, kflagx, kflaga, kflagi, inta, x, a, qx)

!  Method 2 for computing igm1(ma, mb).  Use the Pochhammer(a-n, n)/x**n series.

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(18), mresult
      integer :: n_acc, kxneg, kflagx, kflaga, kflagi, inta
      double precision :: x, a
      intent (in) :: kxneg, kflagx, kflaga, kflagi, inta, x, a
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      double precision :: bigj, t1
      integer :: iextra, j, jterms, k, less, ndig2, ndsav1, nt, nterms

!             mxy(13) = mxy(17) + mxy(18) is the current sum.
!             mxy(9) is the current term.
!             mxy(8) is (a-n)/x.
!             mxy(14) is -1/x

      nterms = int(intmax/10)

!             Raise the precision if a is positive and near an integer, to compensate for
!             cancellation when (a-n)/x is near zero.

      if (mxy(1)%mp(1) > 0) then
          call fmnint(mxy(1), mxy(13), qx)
          call fmsub(mxy(1), mxy(13), mxy(14), qx)
          iextra = max(-int(mxy(14)%mp(2)), 0)
          if (abs(mxy(14)%mp(2)) >= qx%mexpov) iextra = 0
          if (iextra > 0) then
              call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
              call fmequ_r1(mxy(2), qx%ndig, qx%ndig+iextra, qx)
          endif
          call fmndig(qx%ndig + iextra, qx)
      endif
      n_acc = nint(qx%ndig*qx%alogm2)

      call fmgam(mxy(1), mxy(15), qx)
      if (kflaga == 0 .and. kflagx == 0) then
          nt = int(((a-1)*log(abs(x)+1.0d-10) - x)/qx%dlogmb)
          less = max(0, int(mxy(15)%mp(2)) - nt - 1)
          if (less > qx%ndig .and. abs(a) < abs(x)) then
              call fmeq(mxy(15), mresult, qx)
              return
          endif
      endif
      if (qx%kflag /= 0) then
          call fmeq(mxy(15), mresult, qx)
          return
      endif
      if (kxneg == 0) then
          call fmln(mxy(2), mxy(14), qx)
          qx%ndigli = 0
          call fmmpy(mxy(1), mxy(14), mxy(5), qx)
          call fmsub(mxy(5), mxy(2), mxy(13), qx)
          call fmsub_r2(mxy(13), mxy(14), qx)
          call fmexp(mxy(14), mxy(9), qx)
          qx%ndige = 0
      else
          call fmi2m(1, mxy(5), qx)
          call fmsub(mxy(1), mxy(5), mxy(13), qx)
          call fmpwr(mxy(2), mxy(13), mxy(14), qx)
          call fmexp(mxy(2), mxy(12), qx)
          qx%ndige = 0
          call fmdiv(mxy(14), mxy(12), mxy(9), qx)
      endif

!             Here mxy(9) is x**(a-1)/exp(x).

      call fmnegate(mxy(9), qx)
      call fmeq(mxy(15), mxy(13), qx)
      if (mxy(15)%mp(1) > 0) then
          call fmeq(mxy(15), mxy(17), qx)
          call fmi2m(0, mxy(18), qx)
      else
          call fmeq(mxy(15), mxy(18), qx)
          call fmi2m(0, mxy(17), qx)
      endif
      call fmdiv(mxy(1), mxy(2), mxy(8), qx)
      call fmi2m(1, mxy(5), qx)
      call fmdiv(mxy(5), mxy(2), mxy(14), qx)
      call fmnegate(mxy(14), qx)
      ndsav1 = qx%ndig

!             Disable ndig reduction until the terms in the sum begin to decrease in size.

      bigj = 0
      if (kflaga == 0 .and. kflagx == 0) bigj = abs(a) - abs(x)
      jterms = nterms
      if (kflagi == 0 .and. inta > 0) then
          jterms = inta
      else if (kflaga == 0 .and. kflagx == 0) then
          t1 = a + abs(x)
          if (t1 > 0 .and. t1 < dble(nterms)) jterms = int(t1) + 2
      endif

!             Method 2 summation loop.

      n_acc = nint(qx%ndig*qx%alogm2)
      do j = 1, jterms
         call fmndig(ndsav1, qx)
         call fmcsadd_r1(mxy(13), mxy(9), qx)
         if (mxy(9)%mp(1) > 0) then
             call fmadd_r2(mxy(9), mxy(17), qx)
         else
             call fmadd_r2(mxy(9), mxy(18), qx)
         endif
         k = max(mxy(17)%mp(2), mxy(18)%mp(2)) - qx%ndig
         if (mxy(9)%mp(2) < k) qx%kflag = 1
         if (qx%kflag /= 0 .and. j > 1) then
             exit
         endif
         call fmcsadd_r1(mxy(8), mxy(14), qx)
         if (dble(j) >= bigj) then
             call fmadd(mxy(17), mxy(18), mxy(13), qx)
             ndig2 = max(qx%ngrd22, ndsav1-int(mxy(13)%mp(2)-mxy(9)%mp(2)))
             call fmndig(min(ndsav1, ndig2), qx)
         endif
         call fmcsmpy_r1(mxy(9), mxy(8), qx)
         if (j == nterms) then
             call fmunknown(mresult, qx)
             return
         endif
      enddo

      call fmndig(ndsav1, qx)
      call fmadd(mxy(17), mxy(18), mxy(13), qx)
      call fmcancel(mxy(17), mxy(18), mxy(13), k, qx)
      n_acc = n_acc - k
      call fmeq(mxy(13), mresult, qx)

      return
      end subroutine fmigm1_m2

      subroutine fmigm1_m3(mxy, mresult, n_acc, kflagx, kflaga, kflagi, inta, moda2, x, a, qx)

!  Method 3 for computing igm1(ma, mb).Use the continued fraction expansion.

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(18), mresult
      integer :: n_acc, kflagx, kflaga, kflagi, inta
      double precision :: x, a
      real (kind(1.0d0)) :: moda2
      intent (in) :: kflagx, kflaga, kflagi, inta, moda2, x, a
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      double precision :: yt
      integer :: j, jextra, k, kflag1, less, ndsav1, ndsav2, nt, nterms


!             mxy(14) = mxy(17) + mxy(18) is the current approximation.
!             mxy(13) is the term in the sum, s(k).
!             mxy(11), mxy(12) are the latest denominators, q(k-1) and q(k).

      call fmgam(mxy(1), mxy(15), qx)
      n_acc = nint(qx%ndig*qx%alogm2)
      ndsav1 = qx%ndig
      if (kflaga == 0 .and. kflagx == 0) then
          yt = min(dble(huge(1))/11, aint(((a-1)*log(abs(x)+1.0d-10) - x)/qx%dlogmb))
          nt = huge(1)/10
          nt = min(dble(nt), yt)
          less = max(0, int(mxy(15)%mp(2)) - nt - 1)
          if (less > qx%ndig) then
              call fmeq(mxy(15), mresult, qx)
              return
          endif
          call fmndig(min(ndsav1, max(qx%ngrd22, qx%ndig-less)), qx)
      endif
      jextra = max(1, int(5.76/qx%alogmb + 1.0))
      if (qx%ndig+jextra > ndsav1) then
          call fmequ_r1(mxy(1), ndsav1, ndsav1+jextra, qx)
          call fmequ_r1(mxy(2), ndsav1, ndsav1+jextra, qx)
      endif
      call fmndig(qx%ndig + jextra, qx)
      call fmequ(mxy(1), mxy(8), ndsav1, qx%ndig, qx)
      call fmnegate(mxy(8), qx)
      call fmi2m(1, mxy(11), qx)
      call fmequ(mxy(2), mxy(12), ndsav1, qx%ndig, qx)
      call fmi2m(1, mxy(5), qx)
      call fmdiv(mxy(5), mxy(12), mxy(13), qx)
      if (mxy(13)%mp(1) > 0) then
          call fmeq(mxy(13), mxy(17), qx)
          call fmi2m(0, mxy(18), qx)
      else
          call fmeq(mxy(13), mxy(18), qx)
          call fmi2m(0, mxy(17), qx)
      endif

      nterms = int(intmax/10)
      n_acc = nint(qx%ndig*qx%alogm2)

!             Method 3 continued fraction loop.

      ndsav2 = qx%ndig
      n_acc = nint(qx%ndig*qx%alogm2)
      do j = 1, min(nterms, inta-1)
         call fmaddi(mxy(8), 1, qx)
         call fmeq(mxy(8), mxy(10), qx)
         call fmcsmpy_r1(mxy(10), mxy(11), qx)
         call fmadd(mxy(12), mxy(10), mxy(9), qx)
         call fmeq(mxy(10), mxy(6), qx)
         call fmcsmpy_r1(mxy(6), mxy(13), qx)
         call fmcsdiv(mxy(6), mxy(9), mxy(13), qx)
         call fmnegate(mxy(13), qx)
         call fmndig(ndsav2, qx)
         if (mxy(13)%mp(1) > 0) then
             call fmadd_r1(mxy(17), mxy(13), qx)
         else
             call fmadd_r1(mxy(18), mxy(13), qx)
         endif
         kflag1 = qx%kflag
         call fmadd(mxy(17), mxy(18), mxy(14), qx)
         call fmeq(mxy(12), mxy(11), qx)
         call fmeq(mxy(9), mxy(12), qx)
         call fmndig(min(ndsav2, max(qx%ngrd22, ndsav2-int(mxy(14)%mp(2)-mxy(13)%mp(2)))), qx)
         if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         call fmcsmpyi(mxy(11), j, mxy(10), qx)
         call fmeq(mxy(2), mxy(6), qx)
         call fmcsmpy_r1(mxy(6), mxy(12), qx)
         call fmadd(mxy(6), mxy(10), mxy(9), qx)
         call fmeq(mxy(10), mxy(6), qx)
         call fmcsmpy_r1(mxy(6), mxy(13), qx)
         call fmcsdiv(mxy(6), mxy(9), mxy(13), qx)
         call fmnegate(mxy(13), qx)
         call fmndig(ndsav2, qx)
         if (mxy(13)%mp(1) > 0) then
             call fmadd_r1(mxy(17), mxy(13), qx)
         else
             call fmadd_r1(mxy(18), mxy(13), qx)
         endif

!             Check for convergence.

         if (kflag1 == 1 .and. qx%kflag == 1 .and. j > 2) then
             exit
         endif
         call fmadd(mxy(17), mxy(18), mxy(14), qx)
         call fmeq(mxy(12), mxy(11), qx)
         call fmeq(mxy(9), mxy(12), qx)
         call fmndig(min(ndsav2, max(qx%ngrd22, ndsav2-int(mxy(14)%mp(2)-mxy(13)%mp(2)))), qx)
         if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         if (j == nterms) then
             call fmunknown(mresult, qx)
             return
         endif
      enddo

      call fmndig(ndsav2, qx)
      call fmequ_r1(mxy(14), qx%ndig, ndsav1, qx)
      call fmequ_r1(mxy(17), qx%ndig, ndsav1, qx)
      call fmequ_r1(mxy(18), qx%ndig, ndsav1, qx)
      call fmndig(ndsav1, qx)
      if (mxy(2)%mp(1) > 0) then
          call fmln(mxy(2), mxy(5), qx)
          qx%ndigli = 0
          call fmmpy(mxy(1), mxy(5), mxy(4), qx)
          call fmsub(mxy(4), mxy(2), mxy(5), qx)
          call fmexp(mxy(5), mxy(12), qx)
          qx%ndige = 0
      else if (kflagi == 0) then
          call fmexp(mxy(2), mxy(13), qx)
          qx%ndige = 0
          call fmipwr(mxy(2), inta, mxy(5), qx)
          call fmdiv(mxy(5), mxy(13), mxy(12), qx)
      else
          call fmabs(mxy(2), mxy(5), qx)
          call fmln(mxy(5), mxy(6), qx)
          qx%ndigli = 0
          call fmmpy(mxy(1), mxy(6), mxy(4), qx)
          call fmsub(mxy(4), mxy(2), mxy(5), qx)
          call fmexp(mxy(5), mxy(12), qx)
          qx%ndige = 0
          if (moda2 == 1) call fmnegate(mxy(12), qx)
      endif

      if (mxy(12)%mp(2) /= qx%mexpov) then
          call fmmpy_r2(mxy(12), mxy(17), qx)
          call fmmpy_r2(mxy(12), mxy(18), qx)
      else if (mxy(12)%mp(2)+mxy(14)%mp(2) >= qx%mxexp2/2) then
          call fmeq(mxy(12), mxy(13), qx)
          if (mxy(14)%mp(1) < 0) call fmnegate(mxy(13), qx)
      else
          call fmmpy_r2(mxy(12), mxy(17), qx)
          call fmmpy_r2(mxy(12), mxy(18), qx)
      endif
      n_acc = nint(qx%ndig*qx%alogm2)
      if (mxy(15)%mp(1) > 0) then
          call fmsub(mxy(15), mxy(18), mxy(16), qx)
          call fmmpyi(mxy(17), -1, mxy(18), qx)
          call fmeq(mxy(16), mxy(17), qx)
      else
          call fmsub(mxy(15), mxy(17), mxy(16), qx)
          call fmmpyi(mxy(18), -1, mxy(17), qx)
          call fmeq(mxy(16), mxy(18), qx)
      endif
      call fmadd(mxy(17), mxy(18), mxy(13), qx)
      call fmcancel(mxy(17), mxy(18), mxy(13), k, qx)
      n_acc = n_acc - k
      call fmeq(mxy(13), mresult, qx)

      return
      end subroutine fmigm1_m3

      subroutine fmigm1_sc(ma, mb, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = igm1(ma, mb).

!  kresult = 1 is returned if a special case gives the value of igm1(ma, mb).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mxy(18), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j, k, krsave, nds
      double precision :: xe, ye
      type(multi) :: malocal, mblocal
      logical, external :: fmcomp

      kresult = 0

      qx%namest(qx%ncall) = 'FMIGM1   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp2(ma, mb, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)
      call fmequ(mb, mblocal, ndsave, qx%ndig, qx)

      call fmint(malocal, mxy(1), qx)
      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          kresult = 1
      else if (mblocal%mp(2) == qx%munkno .and. mblocal%mp(5) >= 0) then
          kresult = 1
      else if (mblocal%mp(1) < 0 .and. fmcomp(malocal, '/=', mxy(1), qx)) then
          kresult = 1
      else if (malocal%mp(3) == 0) then
          kresult = 1
      else if (malocal%mp(1) < 0 .and. fmcomp(malocal, '==', mxy(1), qx)) then
          kresult = 1
      endif
      if (kresult == 1) then
          call fmunknown(mresult, qx)
          return
      endif

      if (mblocal%mp(2) == qx%mexpun) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          krsave = qx%kround
          qx%kround = 1
          nds = qx%ndig
          qx%ndig = ndsave
          call fmpwr(mblocal, malocal, mxy(3), qx)
          call fmdiv(mxy(3), malocal, mxy(4), qx)
          call fmi2m(1, mxy(1), qx)
          qx%kround = krsave
          if (fmcomp(mxy(3), '==', mxy(1), qx) .and. qx%kround /= 1) then
              call fmtiny(mxy(2), qx)
              call fmsub(mxy(4), mxy(2), mxy(3), qx)
          else
              call fmeq(mxy(4), mxy(3), qx)
          endif
          qx%ntrace = j
          qx%kwarn = k
          if (mxy(3)%mp(2) /= qx%munkno) then
              call fmeq(mxy(3), mresult, qx)
              kresult = 1
              return
          endif
          call fmndig(nds, qx)
      endif

      if (mb%mp(3) == 0 .and. ma%mp(3) /= 0 .and. ma%mp(1) > 0) then
          call fmi2m(0, mresult, qx)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      call fmovun_xe(malocal, xe, qx)
      call fmovun_xe(mblocal, ye, qx)
      if (qx%kround /= 1 .and. (xe < -ndsave .or. ye < -ndsave)) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          nds = qx%ndig
          krsave = qx%kround
          qx%kround = 1
          call fmndig(qx%ndig + qx%ngrd52, qx)
          call fmequ(malocal, mxy(1), nds, qx%ndig, qx)
          call fmequ(mblocal, mxy(2), nds, qx%ndig, qx)
          call fmi2m(1, mxy(3), qx)
          call fmadd(mxy(1), mxy(3), mxy(4), qx)
          if (mxy(1)%mp(3) /= 0 .and. mxy(4)%mp(3) /= 0) then
              call fmdiv(mxy(2), mxy(4), mxy(6), qx)
              call fmmpy(mxy(6), mxy(1), mxy(5), qx)
              call fmovun_xe(mxy(3), xe, qx)
              call fmovun_xe(mxy(5), ye, qx)
              if (xe - ye > ndsave) then
                  call fmpwr(mxy(2), mxy(1), mxy(6), qx)
                  call fmdiv(mxy(6), mxy(1), mxy(7), qx)
                  call fmequ(mxy(7), mxy(6), qx%ndig, nds, qx)
                  call fmequ(mxy(6), mxy(8), nds, qx%ndig, qx)
                  call fmsub(mxy(7), mxy(8), mxy(6), qx)
                  if (abs(mxy(7)%mp(2)) >= qx%mexpov) then
                      call fmeq(mxy(7), mresult, qx)
                  else if (mxy(6)%mp(3) == 0) then
                      call fmmpy(mxy(5), mxy(7), mxy(8), qx)
                      call fmequ(mxy(7), mxy(9), qx%ndig, nds, qx)
                      call fmequ(mxy(8), mxy(6), qx%ndig, nds, qx)
                      call fmndig(nds, qx)
                      qx%kround = krsave
                      call fmsub(mxy(9), mxy(6), mresult, qx)
                      if (mresult%mp(2) == qx%munkno) then
                          call fmi2m(2, mxy(9), qx)
                          call fmmod(malocal, mxy(9), mxy(8), qx)
                          if (mblocal%mp(1) < 0 .and. mxy(8)%mp(3) /= 0) then
                              if (krsave ==  2) qx%kround = -1
                              if (krsave == -1) qx%kround =  2
                          endif
                          call fmi2m(1, mxy(8), qx)
                          call fmsub(mxy(8), mxy(5), mxy(6), qx)
                          call fmmpy(mxy(7), mxy(6), mresult, qx)
                      endif
                  else
                      qx%kround = krsave
                      call fmmpy(mxy(3), mxy(7), mxy(6), qx)
                      call fmmpy(mxy(5), mxy(7), mxy(8), qx)
                      call fmsub_r2(mxy(6), mxy(8), qx)
                      call fmeq(mxy(8), mresult, qx)
                  endif
                  qx%ntrace = j
                  qx%kwarn = k
                  call fmequ_r1(mresult, qx%ndig, nds, qx)
                  call fmndig(nds, qx)
                  qx%kround = krsave
                  kresult = 1
                  return
              endif
              call fmovun_xe(malocal, xe, qx)
              if (xe < -ndsave) then
                  call fmdiv(mxy(3), mxy(1), mxy(4), qx)
                  call fmequ(mxy(4), mxy(6), qx%ndig, nds, qx)
                  call fmequ(mxy(6), mxy(5), nds, qx%ndig, qx)
                  call fmsub(mxy(4), mxy(5), mxy(6), qx)
                  if (mxy(6)%mp(3) == 0) then
                      call fmi2m(0, mxy(5), qx)
                      call fmsub(mxy(5), mxy(2), mxy(6), qx)
                      call fmei(mxy(6), mxy(7), qx)
                      call fmln(mxy(2), mxy(8), qx)
                      qx%ndigli = 0
                      call fmsub(mxy(7), mxy(8), mxy(9), qx)
                      call fmeulr(mxy(10), qx)
                      qx%ndgeul = 0
                      call fmsub(mxy(9), mxy(10), mxy(11), qx)
                      call fmpwr(mxy(2), mxy(1), mxy(5), qx)
                      call fmmpy(mxy(5), mxy(11), mxy(12), qx)
                      call fmadd(mxy(8), mxy(12), mxy(13), qx)
                      call fmequ(mxy(4), mxy(6), qx%ndig, nds, qx)
                      call fmequ(mxy(13), mxy(7), qx%ndig, nds, qx)
                      call fmndig(nds, qx)
                      qx%kround = krsave
                      call fmadd(mxy(6), mxy(7), mresult, qx)
                      qx%ntrace = j
                      qx%kwarn = k
                      kresult = 1
                      return
                  endif
              endif
          endif
          qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          call fmndig(nds, qx)
          qx%kround = krsave
      endif

      return
      end subroutine fmigm1_sc

      subroutine fmigm2(ma, mb, mc, qx)

!  mc = incomplete gamma(ma, mb)

!  Integral from mb to infinity of e**(-t) * t**(ma-1)  dt.

!  This is (upper case) Gamma(a, x).   Domain:  ma: all reals,  mb >= 0.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: inta, kmeth4, kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(20), mresult, mretry

      call fmalloc(mc, qx%ndig+2, qx)
      call fmenter2(ma, mb, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmigm2_sc(ma, mb, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mc, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      kmeth4 = 0
      n_acc = nint(qx%ndig*qx%alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmigm2_m(ma, mb, mxy, mresult, ndsave, retry, n_acc, mxsave, inta, kmeth4, qx)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry, qx)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)
                 if (kmeth4 == 1) then
                     call fmi2m(inta, mxy(1), qx)
                 endif
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mc, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmigm2

      subroutine fmigm2_m(ma, mb, mxy, mresult, ndsave, retry, n_acc, mxsave, inta, kmeth4, qx)

!  Method selection for computing igm2(ma, mb).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mxy(20), mresult
      integer :: ndsave, n_acc, inta, kmeth4
      real (kind(1.0d0)) :: mxsave
      logical :: retry
      intent (in) :: ma, mb, ndsave, mxsave
      intent (inout) :: mxy, mresult, retry, n_acc, inta, kmeth4
      type(fm_settings) :: qx

      double precision :: a, b, big, c1, c2, small, tol, t1, x, xe, ye, yf
      real (kind(1.0d0)) :: moda2
      integer :: iextra, intg, kabigr, kflaga, kflagi, kflagx, kwrnsv, kxneg, nd1, nmethd, nterms
      logical, external :: fmcomp
      double precision, external :: fmdplg

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      call fmequ(mb, mxy(2), ndsave, qx%ndig, qx)
      n_acc = nint(qx%ndig*qx%alogm2)
      nterms = int(intmax/10)

!             a, x are double precision approximations to the two arguments to this function.
!             inta = a if a is a small integer.  It is used to limit the number of terms used
!                    in the asymptotic series and in the continued fraction expansion.

      inta = nterms
      kwrnsv = qx%kwarn
      qx%kwarn = 0
      call fmm2i(mxy(1), intg, qx)
      kflagi = qx%kflag
      if (qx%kflag == 0) inta = intg
      call fmm2dp(mxy(1), a, qx)
      kflaga = qx%kflag
      call fmovun_xe(mxy(1), xe, qx)
      if (qx%kflag /= 0 .and. xe < 0) then
          a = 1.0d0/dpmax
          if (mxy(1)%mp(1) < 0) a = -a
          kflaga = 0
      endif
      call fmm2dp(mxy(2), x, qx)
      kflagx = qx%kflag
      call fmovun_xe(mxy(2), xe, qx)
      if (qx%kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax
          if (mxy(2)%mp(1) < 0) x = -x
          kflagx = 0
      endif
      qx%kwarn = kwrnsv

!             If a or x is large in magnitude use more guard digits.

      nd1 = max(int(mxy(1)%mp(2)), int(mxy(2)%mp(2)))
      nd1 = max(nd1, 0)
      iextra = min(nd1 , int(1.0+qx%alogmx/qx%alogmb))
      if (mxy(1)%mp(2) >= qx%mexpov .or. mxy(2)%mp(2) >= qx%mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
          call fmequ_r1(mxy(2), qx%ndig, qx%ndig+iextra, qx)
      endif
      call fmndig(qx%ndig + iextra, qx)
      n_acc = nint(qx%ndig*qx%alogm2)

!             kxneg = 1 if x is negative and a is a positive integer.

      kxneg = 0

!             moda2 = mod(a, 2) when kxneg is 1.

      moda2 = 0

!             Check for special cases.

      if (mxy(2)%mp(3) == 0) then
          if (mxy(1)%mp(1) < 0 .or. mxy(1)%mp(3) == 0) then
              call fmunknown(mresult, qx)
              qx%kflag = -4
              retry = .false.
              return
          else
              call fmgam(mxy(1), mxy(18), qx)
              call fmeq(mxy(18), mresult, qx)
              return
          endif
      endif
      if (mxy(1)%mp(2) == qx%mexpov .or. mxy(2)%mp(2) == qx%mexpov) then
          call fmabs(mxy(1), mxy(3), qx)
          call fmabs(mxy(2), mxy(4), qx)
          if (mxy(1)%mp(2) == qx%mexpov .and. mxy(1)%mp(1) < 0 .and.  &
              mxy(2)%mp(1) > 0 .and. mxy(2)%mp(2) < 1) then
              call fmgam(mxy(3), mxy(16), qx)
          else if (fmcomp(mxy(3), '>', mxy(4), qx)) then
              call fmgam(mxy(3), mxy(16), qx)
              if (ma%mp(1) < 0) then
                  call fmi2m(1, mxy(5), qx)
                  call fmdiv_r2(mxy(5), mxy(16), qx)
              endif
          else if (fmcomp(mxy(3), '<', mxy(4), qx)) then
              call fmi2m(1, mxy(5), qx)
              call fmsub(mxy(1), mxy(5), mxy(6), qx)
              call fmovun_xexf(mxy(2), ye, yf, qx)
              ye = ye*qx%dlogmb + log(yf)
              call fmdp2m(ye, mxy(7), qx)
              call fmmpy(mxy(6), mxy(7), mxy(8), qx)
              call fmsub(mxy(8), mxy(2), mxy(9), qx)
              call fmexp(mxy(9), mxy(16), qx)
              qx%ndige = 0
          else
              call fmgam(mxy(3), mxy(16), qx)
              call fmdivi_r1(mxy(16), 2, qx)
              if (ma%mp(1) < 0) then
                  call fmi2m(1, mxy(5), qx)
                  call fmdiv_r2(mxy(5), mxy(16), qx)
              endif
          endif
          call fmeq(mxy(16), mresult, qx)
          if (abs(mxy(16)%mp(2)) >= qx%mexpov) then
              return
          endif
          retry = .false.
          return
      endif

      if (mxy(1)%mp(2) == qx%mexpun .or. mxy(2)%mp(2) == qx%mexpun) then
          if (mxy(1)%mp(2) == qx%mexpun .and. mxy(2)%mp(2) == qx%mexpun) then
              call fmunknown(mresult, qx)
              qx%kflag = -4
              retry = .false.
              return
          endif
          if (mxy(2)%mp(2) == qx%mexpun .and. mxy(2)%mp(1) > 0 .and.  &
              mxy(2)%mp(3) /= 0                                     ) then
              if (mxy(1)%mp(2) >= 1 .and. mxy(1)%mp(1) > 0) then
                  call fmgam(mxy(1), mxy(18), qx)
                  call fmeq(mxy(18), mresult, qx)
                  return
              else if (mxy(1)%mp(2) >= 1 .and. mxy(1)%mp(1) < 0) then
                  call fmoverflow(1, mresult, qx)
                  qx%kflag = -5
                  retry = .false.
                  return
              else
                  call fmunknown(mresult, qx)
                  qx%kflag = -4
                  retry = .false.
                  return
              endif
          endif
      endif
      if (mxy(2)%mp(1) < 0) then
          call fmint(mxy(1), mxy(15), qx)
          if (fmcomp(mxy(1), '==', mxy(15), qx) .and. mxy(1)%mp(1)*mxy(1)%mp(3) > 0) then
              kxneg = 1
              call fmi2m(2, mxy(12), qx)
              call fmmod(mxy(15), mxy(12), mxy(7), qx)
              call fmeq(mxy(7), mxy(12), qx)
              if (mxy(12)%mp(3) /= 0) moda2 = 1
          else
              call fmunknown(mresult, qx)
              qx%kflag = -4
              retry = .false.
              return
          endif
      endif
      if (mxy(2)%mp(2) == qx%mexpun) then
          if (mxy(1)%mp(1) < 0 .and. mxy(1)%mp(2) >= 1) then
              call fmoverflow(1, mxy(16), qx)
              qx%kflag = -5
          else
              call fmgam(mxy(1), mxy(18), qx)
              call fmeq(mxy(18), mresult, qx)
          endif
          return
      endif
      if (mxy(1)%mp(2) == qx%mexpun) then
          call fmi2m(0, mxy(1), qx)
      endif
      call fmmax(mxy(1), mxy(2), mxy(7), qx)
      call fmmin(mxy(1), mxy(2), mxy(8), qx)
      call fmdpm(1.0d6, mxy(3), qx)
      call fmdpm(1.0d2, mxy(4), qx)
      if (fmcomp(mxy(7), '>=', mxy(3), qx) .and. fmcomp(mxy(8), '>=', mxy(4),qx)) then
          call fmi2m(1, mxy(7), qx)
          call fmsub(mxy(1), mxy(7), mxy(9), qx)
          call fmmax(mxy(9), mxy(2), mxy(11), qx)
          call fmaddi(mxy(11), 1, qx)
          call fmln(mxy(11), mxy(7), qx)
          qx%ndigli = 0
          call fmmpy(mxy(9), mxy(7), mxy(4), qx)
          call fmsub(mxy(4), mxy(11), mxy(7), qx)
          call fmexp(mxy(7), mxy(13), qx)
          qx%ndige = 0
          if ((mxy(13)%mp(2) == qx%mexpov .and. mxy(13)%mp(1) > 0 .and.  &
              mxy(13)%mp(3) /= 0) .or. mxy(13)%mp(2) > mxsave+1) then
              call fmeq(mxy(13), mresult, qx)
              qx%kflag = -5
              return
          endif
      endif

!             If a is 1 the result is exp(-x).

      call fmi2m(1, mxy(7), qx)
      if (fmcomp(mxy(1), '==', mxy(7), qx)) then
          if (abs(mxy(2)%mp(2)) < qx%mexpov) then
              call fmeq(mxy(2), mxy(8), qx)
              call fmnegate(mxy(8), qx)
              call fmexp(mxy(8), mxy(16), qx)
              qx%ndige = 0
              if (mxy(16)%mp(2) /= qx%munkno) then
                  call fmeq(mxy(16), mresult, qx)
                  retry = .false.
                  return
              endif
          endif
      endif

!             If a is negative and x is small, the result is -x**a / a.

      if (mxy(1)%mp(1) == -1 .and. mxy(2)%mp(2) < -ndsave) then
          call fmpwr(mxy(2), mxy(1), mxy(8), qx)
          call fmdiv(mxy(8), mxy(1), mxy(16), qx)
          if (mxy(16)%mp(2) == qx%munkno) then
              call fmln(mxy(2), mxy(8), qx)
              qx%ndigli = 0
              call fmmpy(mxy(8), mxy(1), mxy(9), qx)
              call fmabs(mxy(1), mxy(10), qx)
              call fmln(mxy(10), mxy(11), qx)
              qx%ndigli = 0
              call fmsub(mxy(9), mxy(11), mxy(10), qx)
              call fmexp(mxy(10), mxy(16), qx)
              qx%ndige = 0
              call fmnegate(mxy(16), qx)
          endif
          call fmnegate(mxy(16), qx)
          if (mxy(16)%mp(2) /= qx%munkno) then
              call fmeq(mxy(16), mresult, qx)
              retry = .false.
              return
          endif
      endif
      if (mxy(1)%mp(1) == -1 .and. mxy(2)%mp(1) == 1 .and.  &
          mxy(1)%mp(2) > qx%ndig .and.                      &
          mxy(1)%mp(2) - mxy(2)%mp(2) > qx%ndig) then
          call fmi2m(1, mxy(3), qx)
          call fmsub(mxy(3), mxy(1), mxy(4), qx)
          call fmadd(mxy(4), mxy(2), mxy(6), qx)
          call fmdiv(mxy(3), mxy(6), mxy(5), qx)
          call fmsqr(mxy(1), mxy(4), qx)
          call fmmpyi(mxy(2), 2, mxy(6), qx)
          call fmaddi(mxy(6), 3, qx)
          call fmmpy(mxy(1), mxy(6), mxy(7), qx)
          call fmsub(mxy(4), mxy(7), mxy(8), qx)
          call fmdiv(mxy(5), mxy(8), mxy(9), qx)
          call fmsub(mxy(1), mxy(3), mxy(10), qx)
          call fmmpy(mxy(10), mxy(9), mxy(11), qx)
          if (mxy(11)%mp(2) /= qx%munkno) then
              call fmadd(mxy(5), mxy(11), mxy(12), qx)
          else
              call fmeq(mxy(5), mxy(12), qx)
          endif
          call fmpwr(mxy(2), mxy(1), mxy(13), qx)
          if (mxy(1)%mp(2) == qx%mexpov .or. mxy(1)%mp(2) == qx%mexpun) then
              call fmeq(mxy(13), mxy(16), qx)
          else
              call fmexp(mxy(2), mxy(14), qx)
              qx%ndige = 0
              call fmmpy(mxy(12), mxy(13), mxy(15), qx)
              call fmdiv(mxy(15), mxy(14), mxy(16), qx)
          endif
          if (mxy(16)%mp(2) /= qx%munkno) then
              call fmeq(mxy(16), mresult, qx)
              retry = .false.
              return
          endif
      endif

!             Determine which method to use.

!             nmethd = 1 means use the convergent series,
!                    = 2 means use the asymptotic series,
!                    = 3 means use the continued fraction expansion,
!                    = 4 means use an o(a**2) formula.

      call fmi2m(-10000, mxy(11), qx)
      call fmi2m(10000, mxy(12), qx)
      call fmabs(mxy(1), mxy(14), qx)
      call fmabs(mxy(2), mxy(15), qx)
      call fmsub(mxy(15), mxy(14), mxy(13), qx)
      kabigr = 1
      if (mxy(13)%mp(3) >= 0 .and. mxy(13)%mp(1) > 0) kabigr = 0

!             Check whether the smallest term in the asymptotic series is small enough to give
!             the required accuracy.

      if (kflaga /= 0 .or. kflagx /= 0) then
          call fmdiv(mxy(14), mxy(15), mxy(10), qx)
          call fmi2m(1, mxy(8), qx)
          call fmsub(mxy(8), mxy(10), mxy(9), qx)
          if (mxy(9)%mp(1) < 0) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          t1 = fmdplg(a, qx)
          small = t1 - fmdplg(-abs(x), qx) - (a+abs(x))*log(abs(x))
          tol = -dble(qx%ndig+2)*qx%dlogmb - 12.0d0
          b = 1.0d0
          if (a > abs(x)) b = a - abs(x)
          big = t1 - fmdplg(a-b, qx) - b*log(abs(x))

          nmethd = 0
          if (fmcomp(mxy(13), '<=', mxy(11), qx)) then
              if (mxy(1)%mp(1) > 0 .and. mxy(1)%mp(3) /= 0) then
                  nmethd = 1
              else
                  nmethd = 3
              endif
          else if (fmcomp(mxy(13), '>=', mxy(12), qx) .and. mxy(1)%mp(1) > 0 .and.  &
                   mxy(1)%mp(3) > 0 .and. mxy(2)%mp(1) > 0 .and.                    &
                   mxy(2)%mp(3) > 0) then
              nmethd = 3
              if (small < tol+big) nmethd = 2
          else if (fmcomp(mxy(13), '>=', mxy(12), qx)) then
              nmethd = 3
          else if (mxy(1)%mp(1) > 0 .and. mxy(2)%mp(1) > 0 .and.  &
                   mxy(2)%mp(3) > 0) then
              call fmdp2m(sqrt(dpmax), mxy(11), qx)
              if (fmcomp(mxy(2), '>=', mxy(11), qx)) then
                  qx%kflag = -5
                  call fmoverflow(1, mresult, qx)
                  return
              endif

              if (mxy(1)%mp(1) > 0 .and. mxy(1)%mp(3) /= 0) then
                  c2 = dble(ndsave)*qx%dlogmb/6.0d0
                  c1 = max( 10.0d0 , c2 )
                  c1 = max( c1 , a )
                  c2 = max( 10.0d0 , c2 )
                  c2 = max( c2 , a - 6.5d0*a/(sqrt(a)+1.0d0) )
              else
                  c1 = max( 15.0d0 , dble(ndsave)*qx%dlogmb/5.0d0 )
                  c2 = c1
              endif
              if (x < min(c1, c2)) then
                  if (-2*mxy(1)%mp(2) > qx%ndig .or. mxy(1)%mp(3) == 0) then
                      nmethd = 4
                  else
                      nmethd = 1
                  endif
              else if (x > c2) then
                  if (small < tol+big) nmethd = 2
              endif
              if (nmethd == 0 .and. x > c1) nmethd = 3
              if (nmethd == 0) nmethd = 1
          else if (mxy(1)%mp(1) < 0 .and. mxy(2)%mp(1) > 0 .and.  &
              mxy(2)%mp(3) > 0) then
              call fmdp2m(sqrt(dpmax), mxy(11), qx)
              if (fmcomp(mxy(2), '>=', mxy(11), qx)) then
                  qx%kflag = -6
                  call fmunderflow(1, mresult, qx)
                  return
              endif

              c1 = max( 10.0d0 , dble(ndsave)*qx%dlogmb/7.0d0 )
              c2 = -2.0d0*a
              if (x < c1) then
                  if (-2*mxy(1)%mp(2) > qx%ndig) then
                      nmethd = 4
                  else
                      nmethd = 1
                  endif
              else if (x > c2) then
                  t1 = fmdplg(a, qx)
                  small = t1 - fmdplg(-abs(x), qx) - (a+abs(x))*log(abs(x))
                  tol = -dble(qx%ndig+2)*qx%dlogmb - 12.0d0
                  b = 1.0d0
                  if (a > abs(x)) b = a - abs(x)
                  big = t1 - fmdplg(a-b, qx) - b*log(abs(x))
                  if (small < tol+big) nmethd = 2
              endif
              if (nmethd == 0 .and. x > c1) nmethd = 3
              if (nmethd == 0) nmethd = 1
          else if (mxy(1)%mp(1) > 0 .and. mxy(1)%mp(3) > 0 .and.  &
              mxy(2)%mp(1) < 0) then
              call fmeq(mxy(2), mxy(11), qx)
              call fmnegate(mxy(11), qx)
              call fmmpyi(mxy(1), 2, mxy(12), qx)
              if (fmcomp(mxy(11), '<', mxy(1), qx)) then
                  nmethd = 1
              else if (fmcomp(mxy(11), '<', mxy(12), qx)) then
                  nmethd = 3
              else
                  nmethd = 3
                  if (small < tol+big) nmethd = 2
              endif
          endif
      endif

      if (nmethd == 1) then
          call fmigm2_m1(mxy, mresult, ndsave, n_acc, kxneg, kflagx, kflaga, kflagi,  &
                         kmeth4, inta, moda2, kabigr, x, a, qx)
      else if (nmethd == 2) then
          call fmigm2_m2(mxy, mresult, n_acc, kxneg, kflagx, kflaga, kflagi, inta, moda2, x, a, qx)
      else if (nmethd == 3) then
          call fmigm2_m3(mxy, mresult, n_acc, kxneg, kflagx, kflaga, inta, moda2, x, a, qx)
      else if (nmethd == 4) then
          call fmigm2_m4(mxy, mresult, n_acc, kflagx, kflaga, kflagi, kmeth4, inta, x, a, qx)
      endif

      return
      end subroutine fmigm2_m

      subroutine fmigm2_m1(mxy, mresult, ndsave, n_acc, kxneg, kflagx, kflaga, kflagi,  &
                           kmeth4, inta, moda2, kabigr, x, a, qx)

!  Method 1 for computing igm2(ma, mb).  Use the x**n/Pochhammer(a+1, n) series.

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(20), mresult
      integer :: ndsave, n_acc, kxneg, kflagx, kflaga, kflagi, kmeth4, inta, kabigr
      double precision :: x, a
      real (kind(1.0d0)) :: moda2
      intent (in) :: ndsave, kxneg, kflagx, kflaga, kflagi, inta, moda2, kabigr, x
      intent (inout) :: mxy, mresult, n_acc, kmeth4, a
      type(fm_settings) :: qx

      double precision :: c1, t1
      real (kind(1.0d0)) :: maxm09
      integer :: iextra, j, jextra, k, kflgok, ndig2, ndsav1, nmnndg, nterms
      logical, external :: fmcomp
      double precision, external :: fmdplg

!             Method 1.  Use the x**n/Pochhammer(a+1, n) series.

!             mxy(16) = mxy(19) + mxy(20) is the current sum.
!             mxy(12) is the current term.
!             mxy(11) is (a+n)/x.
!             mxy(17) is 1/x

!             Raise the precision if a is negative and near an integer, to compensate for
!             cancellation when (a+n)/x is near zero.
!             Raise the precision if a is positive and near zero, since there will be cancellation
!             in subtracting the sum from Gamma(a).
!             If a is a negative integer use method 3 or 4.

      iextra = 0
      if (mxy(1)%mp(1) < 0) then
          if (kflaga == 0) then
              if (abs(a) > 1.0d3) then
                  call fmigm2_m3(mxy, mresult, n_acc, kxneg, kflagx, kflaga, inta, moda2, x, a, qx)
                  return
              endif
          else
              call fmigm2_m3(mxy, mresult, n_acc, kxneg, kflagx, kflaga, inta, moda2, x, a, qx)
              return
          endif
          call fmnint(mxy(1), mxy(16), qx)
          if (fmcomp(mxy(16), '==', mxy(1), qx)) then
              if (kflagi == 0) then
                  if (kflagx /= 0) then
                      call fmigm2_m3(mxy, mresult, n_acc, kxneg, kflagx, kflaga, inta, moda2, x, a, qx)
                      return
                  else
                      if (abs(x) <= 20.0d0) then
                          c1 = 0.7d0*(dble(ndsave)*qx%dlogmb*(20.0d0-x))**0.75d0
                          if (abs(a) > c1) then
                              call fmigm2_m3(mxy, mresult, n_acc, kxneg, kflagx, kflaga,  &
                                             inta, moda2, x, a, qx)
                              return
                          else
                              call fmigm2_m4(mxy, mresult, n_acc, kflagx, kflaga, kflagi, kmeth4,  &
                                             inta, x, a, qx)
                              return
                          endif
                      else
                          call fmigm2_m3(mxy, mresult, n_acc, kxneg, kflagx, kflaga,  &
                                         inta, moda2, x, a, qx)
                          return
                      endif
                  endif
              else
                  call fmigm2_m3(mxy, mresult, n_acc, kxneg, kflagx, kflaga, inta, moda2, x, a, qx)
                  return
              endif
          endif
          call fmsub(mxy(1), mxy(16), mxy(17), qx)
          iextra = max(-2*int(mxy(17)%mp(2)), -int(mxy(1)%mp(2))+1)
          iextra = max(iextra, 0)
          if (abs(mxy(17)%mp(2)) >= qx%mexpov .or. abs(mxy(1)%mp(2)) >= qx%mexpov)  &
              iextra = 0
      else
          iextra = max(-int(mxy(1)%mp(2))+1, 0)
          if (abs(mxy(1)%mp(2)) >= qx%mexpov) iextra = 0
      endif

!             Raise the precision further as x increases in magnitude.

      if (kflagx == 0 .and. kflaga == 0) then
          t1 = (0.92d0 + (x-a) + (a-0.5d0)*log(abs(a)+1.0d-10) -  &
               (a-1.0d0)*log(abs(x)+1.0d-10))/qx%dlogmb
          if (t1 > 0 .and. abs(x) > 1.0d0) then
              if (a < 0.0d0 .or. x >= a) then
                  iextra = iextra + max(0, int(t1)+1)
              endif
          endif
      endif

      if (iextra > 0) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
          call fmequ_r1(mxy(2), qx%ndig, qx%ndig+iextra, qx)
      endif
      call fmndig(qx%ndig + iextra, qx)
      n_acc = nint(qx%ndig*qx%alogm2)

      jextra = 0

      if (kabigr == 1) then
          call fmgam(mxy(1), mxy(18), qx)
          if (qx%kflag /= 0) then
              call fmeq(mxy(18), mresult, qx)
              return
          endif
          call fmeq(mxy(18), mxy(16), qx)
          if (mxy(18)%mp(1) > 0) then
              call fmeq(mxy(18), mxy(19), qx)
              call fmi2m(0, mxy(20), qx)
          else
              call fmeq(mxy(18), mxy(20), qx)
              call fmi2m(0, mxy(19), qx)
          endif
      else
          call fmi2m(0, mxy(16), qx)
          call fmi2m(0, mxy(19), qx)
          call fmi2m(0, mxy(20), qx)
      endif

      maxm09 = mxy(16)%mp(2)

      call fmabs(mxy(2), mxy(17), qx)
      call fmln(mxy(17), mxy(6), qx)
      qx%ndigli = 0
      call fmmpy_r2(mxy(1), mxy(6), qx)
      call fmsub_r1(mxy(6), mxy(2), qx)
      call fmexp(mxy(6), mxy(18), qx)
      qx%ndige = 0
      call fmdiv(mxy(18), mxy(1), mxy(12), qx)
      if (mxy(12)%mp(2) == qx%munkno) then
          call fmln(mxy(1), mxy(15), qx)
          qx%ndigli = 0
          call fmsub_r1(mxy(6), mxy(15), qx)
          call fmexp(mxy(6), mxy(12), qx)
          qx%ndige = 0
      endif
      if (kxneg == 1 .and. moda2 == 1) call fmnegate(mxy(12), qx)

      call fmnegate(mxy(12), qx)
      call fmadd_r1(mxy(16), mxy(12), qx)
      if (mxy(12)%mp(1) > 0) then
          call fmadd_r1(mxy(19), mxy(12), qx)
      else
          call fmadd_r1(mxy(20), mxy(12), qx)
      endif
      maxm09 = max(maxm09, mxy(16)%mp(2))

      call fmi2m(1, mxy(9), qx)
      call fmadd(mxy(1), mxy(9), mxy(11), qx)
      call fmdiv_r1(mxy(12), mxy(11), qx)
      call fmmpy_r1(mxy(12), mxy(2), qx)
      call fmdiv_r1(mxy(11), mxy(2), qx)
      call fmdiv(mxy(9), mxy(2), mxy(17), qx)
      ndsav1 = qx%ndig

!             If a is negative and abs(a) > abs(x), the terms in the series first decrease,
!             then increase, then decrease. Try to predict the number of extra digits required to
!             keep the precision from prematurely becoming too small.

      kflgok = 1
      if (mxy(1)%mp(1) < 0) then
          kflgok = 0
          call fmabs(mxy(1), mxy(3), qx)
          call fmabs(mxy(2), mxy(4), qx)
          if (fmcomp(mxy(3), '>', mxy(4), qx)) then
              if (jextra == 0) then
                  if (kflaga == 0 .and. kflagx == 0) then
                      t1 = fmdplg(a+aint(-abs(x)-a), qx) - fmdplg(a+1.0d0+aint(abs(x)-a),qx)
                      t1 = (t1 + 2.0d0*abs(x)*log(abs(x)+1.0d-10))/qx%dlogmb
                      t1 = max(0.0d0, t1+1.0d0)
                      jextra = t1
                  endif
              endif

!             If a is negative and abs(a) is much bigger than abs(x), then the later increase
!             in the size of the terms can be ignored.

              if (kflaga == 0 .and. kflagx == 0) then
                  t1 = (aint(x-a)*log(abs(x)+1.0d-10) + fmdplg(a+1.0d0, qx)  &
                       - fmdplg(a+1.0d0+aint(x-a), qx)) / qx%dlogmb
                  if (t1 < -dble(qx%ndig)) kflgok = 1
              else
                  kflgok = 1
              endif
          endif
      endif

      nmnndg = ndsav1

!             Method 1 summation loop.

      nterms = int(intmax/10)
      do j = 1, nterms
         call fmndig(ndsav1, qx)
         if (mxy(12)%mp(1) > 0) then
             call fmadd_r1(mxy(19), mxy(12), qx)
         else
             call fmadd_r1(mxy(20), mxy(12), qx)
         endif
         call fmcsadd_r1(mxy(16), mxy(12), qx)
         maxm09 = max(maxm09, mxy(16)%mp(2))
         if (qx%kflag /= 0) then
             if (kflgok == 0 .and. kflaga == 0 .and. kflagx == 0) then
                 if (dble(j) > x-a) exit
             else
                 exit
             endif
         endif

         call fmcsadd_r1(mxy(11), mxy(17), qx)

         ndig2 = max(qx%ngrd22, ndsav1-int(mxy(16)%mp(2)-mxy(12)%mp(2)))
         call fmndig(min(ndsav1, ndig2+jextra), qx)
         nmnndg = min(nmnndg, qx%ndig)
         call fmcsdiv(mxy(12), mxy(11), mxy(5), qx)
         call fmeq(mxy(5), mxy(12), qx)
         if (j == nterms) then
             call fmunknown(mresult, qx)
             return
         endif
      enddo

      call fmndig(ndsav1, qx)
      if (kabigr == 0) then
          call fmeq(mxy(16), mxy(17), qx)
          call fmgam(mxy(1), mxy(18), qx)
          if (qx%kflag /= 0) then
              call fmeq(mxy(18), mresult, qx)
              return
          endif
          call fmadd(mxy(18), mxy(17), mxy(16), qx)
          if (mxy(9)%mp(1) > 0) then
              call fmadd_r1(mxy(19), mxy(18), qx)
          else
              call fmadd_r1(mxy(20), mxy(18), qx)
          endif

      endif

!             If too much cancellation occurred, raise the precision and do the calculation again.

      call fmadd(mxy(19), mxy(20), mxy(16), qx)
      call fmcancel(mxy(19), mxy(20), mxy(16), k, qx)
      n_acc = n_acc - k


      call fmeq(mxy(16), mresult, qx)

      return
      end subroutine fmigm2_m1

      subroutine fmigm2_m2(mxy, mresult, n_acc, kxneg, kflagx, kflaga, kflagi, inta, moda2, x, a, qx)

!  Method 2 for computing igm2(ma, mb).  Use the Pochhammer(a-n, n)/x**n series.

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(20), mresult
      integer :: n_acc, kxneg, kflagx, kflaga, kflagi, inta
      real (kind(1.0d0)) :: moda2
      double precision :: x, a
      intent (in) :: kxneg, kflagx, kflaga, kflagi, inta, moda2, x, a
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      double precision :: bigj, t1
      integer :: j, jterms, k, ndig2, ndsav1, nterms

!             Method 2.  Use the Pochhammer(a-n, n)/x**n series.

!             mxy(16) is the current sum.
!             mxy(12) is the current term.
!             mxy(11) is (a-n)/x.
!             mxy(17) is -1/x

      nterms = int(intmax/10)
      call fmabs(mxy(2), mxy(17), qx)
      call fmln(mxy(17), mxy(6), qx)
      qx%ndigli = 0
      call fmmpy(mxy(1), mxy(6), mxy(16), qx)
      call fmsub_r2(mxy(16), mxy(6), qx)
      call fmsub_r1(mxy(6), mxy(2), qx)
      call fmexp(mxy(6), mxy(12), qx)
      qx%ndige = 0
      if (kxneg == 1 .and. moda2 == 0) call fmnegate(mxy(12), qx)
      if (abs(mxy(12)%mp(2)) >= qx%mxexp2) then
          call fmeq(mxy(12), mresult, qx)
          return
      endif

!             Here mxy(12) is x**(a-1)/exp(x).

      call fmi2m(0, mxy(16), qx)
      call fmi2m(0, mxy(19), qx)
      call fmi2m(0, mxy(20), qx)
      call fmeq(mxy(1), mxy(11), qx)
      call fmdiv_r1(mxy(11), mxy(2), qx)
      call fmi2m(1, mxy(9), qx)
      call fmdiv(mxy(9), mxy(2), mxy(17), qx)
      call fmnegate(mxy(17), qx)
      ndsav1 = qx%ndig

!             Disable ndig reduction until the terms in the sum begin to decrease in size.

      bigj = 0
      if (kflaga == 0 .and. kflagx == 0) bigj = abs(a) - abs(x)
      jterms = nterms
      if (kflagi == 0 .and. inta > 0) then
          jterms = inta
      else if (kflagx == 0) then
          if (kflaga == 0) then
              t1 = a + abs(x)
              if (t1 > 0 .and. t1 < dble(nterms)) jterms = int(t1) + 2
          else if (mxy(1)%mp(2) < 0) then
              t1 = abs(x)
              if (t1 > 0 .and. t1 < dble(nterms)) jterms = int(t1) + 2
          endif
      endif

!             Method 2 summation loop.

      do j = 1, jterms
         call fmndig(ndsav1, qx)
         if (mxy(12)%mp(1) > 0) then
             call fmadd_r1(mxy(19), mxy(12), qx)
         else
             call fmadd_r1(mxy(20), mxy(12), qx)
         endif
         call fmcsadd_r1(mxy(16), mxy(12), qx)
         if (qx%kflag /= 0 .and. j > 1) then
             exit
         endif
         call fmcsadd_r1(mxy(11), mxy(17), qx)
         if (real(j) >= bigj) then
             ndig2 = max(qx%ngrd22, ndsav1-int(mxy(16)%mp(2)-mxy(12)%mp(2)))
             call fmndig(min(ndsav1, ndig2), qx)
         endif
         call fmcsmpy_r1(mxy(12), mxy(11), qx)
         if (j == nterms) then
             call fmunknown(mresult, qx)
             return
         endif
      enddo

      call fmndig(ndsav1, qx)
      call fmadd(mxy(19), mxy(20), mxy(16), qx)
      call fmcancel(mxy(19), mxy(20), mxy(16), k, qx)
      n_acc = n_acc - k

      call fmeq(mxy(16), mresult, qx)

      return
      end subroutine fmigm2_m2

      subroutine fmigm2_m3(mxy, mresult, n_acc, kxneg, kflagx, kflaga, inta, moda2, x, a, qx)

!  Method 3 for computing igm2(ma, mb).Use the continued fraction expansion.

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(20), mresult
      integer :: n_acc, kxneg, kflagx, kflaga, inta
      double precision :: x, a
      real (kind(1.0d0)) :: moda2
      intent (in) :: kxneg, kflagx, kflaga, inta, moda2, x, a
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      double precision :: t1
      integer :: j, jextra, jterms, k, kflag1, ndsav1, ndsav2, nterms

!             Method 3.  Use the continued fraction expansion.

!             mxy(17) = mxy(19) + mxy(20) is the current approximation.
!             mxy(16) is the term in the sum, s(k).
!             mxy(14), mxy(15) are the latest denominators, q(k-1) and q(k).

!             Raise the precision so that convergence of the continued fraction expansion
!             is easier to detect.

      jextra = max(1, int(5.76/qx%alogmb + 1.0))

!             Raise the precision further for small x if a is positive.

      if (kflagx == 0 .and. kflaga == 0) then
          t1 = (0.92d0 + (abs(x)-a) + (a-0.5d0)*log(abs(a)+1.0d-10) -  &
               (a-1.0d0)*log(abs(x)+1.0d-10))/qx%dlogmb
          if (t1 > 0.0d0 .and. a > 0.0d0) then
              if (abs(x) < a) then
                  jextra = jextra + max(0, int(1.5d0*t1)+1)
              endif
          endif
      endif
      ndsav1 = qx%ndig
      if (qx%ndig+jextra > ndsav1) then
          call fmequ_r1(mxy(1), ndsav1, ndsav1+jextra, qx)
          call fmequ_r1(mxy(2), ndsav1, ndsav1+jextra, qx)
      endif
      call fmndig(qx%ndig + jextra, qx)
      n_acc = nint(qx%ndig*qx%alogm2)
      call fmequ(mxy(1), mxy(11), ndsav1, qx%ndig, qx)
      call fmnegate(mxy(11), qx)
      call fmi2m(1, mxy(14), qx)
      call fmequ(mxy(2), mxy(15), ndsav1, qx%ndig, qx)
      call fmi2m(1, mxy(7), qx)
      call fmdiv(mxy(7), mxy(15), mxy(16), qx)
      call fmeq(mxy(16), mxy(17), qx)
      if (mxy(17)%mp(1) > 0) then
          call fmeq(mxy(17), mxy(19), qx)
          call fmi2m(0, mxy(20), qx)
      else
          call fmeq(mxy(17), mxy(20), qx)
          call fmi2m(0, mxy(19), qx)
      endif

      nterms = int(intmax/10)
      jterms = nterms
      if (inta > 0) jterms = inta - 1

!             Method 3 continued fraction loop.

      ndsav2 = qx%ndig
      do j = 1, jterms
         call fmaddi(mxy(11), 1, qx)
         call fmeq(mxy(11), mxy(13), qx)
         call fmcsmpy_r1(mxy(13), mxy(14), qx)
         call fmadd(mxy(15), mxy(13), mxy(12), qx)
         call fmeq(mxy(13), mxy(8), qx)
         call fmcsmpy_r1(mxy(8), mxy(16), qx)
         call fmcsdiv(mxy(8), mxy(12), mxy(16), qx)
         call fmnegate(mxy(16), qx)
         call fmndig(ndsav2, qx)
         if (mxy(16)%mp(1) > 0) then
             call fmadd_r1(mxy(19), mxy(16), qx)
         else
             call fmadd_r1(mxy(20), mxy(16), qx)
         endif
         call fmcsadd_r1(mxy(17), mxy(16), qx)
         kflag1 = qx%kflag
         call fmeq(mxy(15), mxy(14), qx)
         call fmeq(mxy(12), mxy(15), qx)
         call fmndig(min(ndsav2, max(qx%ngrd22, ndsav2-int(mxy(17)%mp(2)-mxy(16)%mp(2)))), qx)
         if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         call fmcsmpyi(mxy(14), j, mxy(13), qx)
         call fmeq(mxy(2), mxy(8), qx)
         call fmcsmpy_r1(mxy(8), mxy(15), qx)
         call fmadd(mxy(8), mxy(13), mxy(12), qx)
         call fmeq(mxy(13), mxy(8), qx)
         call fmcsmpy_r1(mxy(8), mxy(16), qx)
         call fmcsdiv(mxy(8), mxy(12), mxy(16), qx)
         call fmnegate(mxy(16), qx)
         call fmndig(ndsav2, qx)
         if (mxy(16)%mp(1) > 0) then
             call fmadd_r1(mxy(19), mxy(16), qx)
         else
             call fmadd_r1(mxy(20), mxy(16), qx)
         endif
         call fmcsadd_r1(mxy(17), mxy(16), qx)

!             Check for convergence.

         if (kflag1 == 1 .and. qx%kflag == 1) then
             exit
         endif
         call fmeq(mxy(15), mxy(14), qx)
         call fmeq(mxy(12), mxy(15), qx)
         call fmndig(min(ndsav2, max(qx%ngrd22, ndsav2-int(mxy(17)%mp(2)-mxy(16)%mp(2)))), qx)
         if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         if (j == nterms) then
             call fmunknown(mresult, qx)
             return
         endif
      enddo

      call fmndig(ndsav2, qx)
      call fmadd(mxy(19), mxy(20), mxy(17), qx)
      call fmcancel(mxy(19), mxy(20), mxy(17), k, qx)
      n_acc = n_acc - k
      call fmequ_r1(mxy(17), qx%ndig, ndsav1, qx)
      call fmndig(ndsav1, qx)
      call fmabs(mxy(2), mxy(15), qx)
      call fmln(mxy(15), mxy(6), qx)
      qx%ndigli = 0
      call fmmpy_r2(mxy(1), mxy(6), qx)
      call fmsub_r1(mxy(6), mxy(2), qx)
      call fmexp(mxy(6), mxy(5), qx)
      qx%ndige = 0
      if (kxneg == 1 .and. moda2 == 1) call fmnegate(mxy(5), qx)
      if (abs(mxy(5)%mp(2)) >= qx%mxexp2) then
          call fmeq(mxy(5), mresult, qx)
          if (mxy(17)%mp(1) < 0) call fmnegate(mresult, qx)
          return
      endif

      call fmmpy(mxy(5), mxy(17), mxy(16), qx)
       call fmeq(mxy(16), mresult, qx)

      return
      end subroutine fmigm2_m3

      subroutine fmigm2_m4(mxy, mresult, n_acc, kflagx, kflaga, kflagi, kmeth4, inta, x, a, qx)

!  Method 4 for computing igm2(ma, mb).Use the continued fraction expansion.

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(20), mresult
      integer :: n_acc, kflagx, kflaga, kflagi, kmeth4, inta
      double precision :: x, a
      intent (in) :: kflagx, kflaga, kflagi, inta, x
      intent (inout) :: mxy, mresult, n_acc, kmeth4, a
      type(fm_settings) :: qx

      double precision :: t1, t2
      integer :: iextra, j, jr, n, ndig2, ndsav1, nterms
      logical, external :: fmcomp

!             Method 4.  Use the o(a**2) formula when a is small.

!             mxy(16) is the current term.
!             mxy(17) is the current sum.

!             Raise the precision if x is larger than a in magnitude.
!             The terms initially increase in size, and the final sum is small.

      iextra = 0
      nterms = int(intmax/10)

!             If a is a negative integer, replace it by zero and later use a recurrence to recover
!             the original function value.

      if (kflagi == 0 .and. inta < 0) then
          call fmi2m(0, mxy(1), qx)
          a = 0.0d0
          kmeth4 = 1
      endif

      if (kflagx == 0) then
          if (kflaga == 0) then
              t1 = abs(x) - abs(a)
          else
              t1 = abs(x)
          endif
          if (t1 > 0) then
              t2 = (t1 + log(t1))/qx%dlogmb
              if (t2 > dble(qx%mxexp2/10)) t2 = dble(qx%mxexp2/10)
              iextra = int(max(0.0d0, t2))
          endif
          t1 = abs(x)+1.0d-10
          t2 = (t1 - 0.5d0*log(6.2831853d0*t1))/qx%dlogmb
          if (t2 > dble(qx%mxexp2/10)) t2 = dble(qx%mxexp2/10)
          iextra = iextra + int(max(0.0d0, t2))
      endif

      if (iextra > 0) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
          call fmequ_r1(mxy(2), qx%ndig, qx%ndig+iextra, qx)
      endif
      call fmndig(qx%ndig + iextra, qx)
      n_acc = nint(qx%ndig*qx%alogm2)

      call fmeulr(mxy(17), qx)
      qx%ndgeul = 0
      call fmeq(mxy(17), mxy(18), qx)
      mxy(17)%mp(1) = -1
      call fmabs(mxy(2), mxy(16), qx)
      call fmln(mxy(16), mxy(15), qx)
      qx%ndigli = 0
      call fmsub_r1(mxy(17), mxy(15), qx)
      if (mxy(1)%mp(3) /= 0 .and. mxy(1)%mp(2) >= -qx%ndig-1) then
          call fmsqr(mxy(15), mxy(7), qx)
          call fmmpy(mxy(7), mxy(1), mxy(4), qx)
          call fmdivi(mxy(4), 2, mxy(16), qx)
          call fmsub_r1(mxy(17), mxy(16), qx)

          call fmsqr(mxy(18), mxy(14), qx)
          call fmpi(mxy(13), qx)
          qx%ndigpi = 0
          call fmsqr(mxy(13), mxy(7), qx)
          call fmdivi(mxy(7), 6, mxy(13), qx)
          call fmadd(mxy(13), mxy(14), mxy(7), qx)
          call fmmpy(mxy(7), mxy(1), mxy(4), qx)
          call fmdivi(mxy(4), 2, mxy(14), qx)
          call fmadd_r1(mxy(17), mxy(14), qx)
      endif

      ndsav1 = qx%ndig
      call fmi2m(1, mxy(14), qx)
      jr = qx%kround
      qx%kround = 1
      call fmadd(mxy(1), mxy(14), mxy(13), qx)
      qx%kround = jr
      if (fmcomp(mxy(14), '==', mxy(13), qx)) then
          call fmi2m(-1, mxy(16), qx)
          do j = 1, nterms
             ndig2 = max(qx%ngrd22, ndsav1-int(mxy(17)%mp(2)-mxy(16)%mp(2)))
             call fmndig(min(ndsav1, ndig2), qx)
             call fmmpy_r1(mxy(16), mxy(2), qx)
             call fmnegate(mxy(16), qx)
             call fmdivi_r1(mxy(16), j, qx)
             call fmdivi(mxy(16), j, mxy(15), qx)
             call fmndig(ndsav1, qx)
             call fmadd_r1(mxy(17), mxy(15), qx)
             if (qx%kflag /= 0) exit
             if (j == nterms) then
                 call fmunknown(mresult, qx)
                 return
             endif
          enddo
      else
          call fmpwr(mxy(2), mxy(1), mxy(16), qx)
          call fmnegate(mxy(16), qx)
          call fmeq(mxy(1), mxy(18), qx)
          do j = 1, nterms
             ndig2 = max(qx%ngrd22, ndsav1-int(mxy(17)%mp(2)-mxy(16)%mp(2)))
             call fmndig(min(ndsav1, ndig2), qx)
             call fmmpy_r1(mxy(16), mxy(2), qx)
             call fmnegate(mxy(16), qx)
             call fmdivi_r1(mxy(16), j, qx)
             call fmndig(ndsav1, qx)
             call fmadd_r1(mxy(18), mxy(14), qx)
             call fmndig(min(ndsav1, ndig2), qx)
             call fmdiv(mxy(16), mxy(18), mxy(15), qx)
             call fmndig(ndsav1, qx)
             call fmadd_r1(mxy(17), mxy(15), qx)
             if (qx%kflag /= 0) exit
             if (j == nterms) then
                 call fmunknown(mresult, qx)
                 return
             endif
          enddo
      endif
      call fmeq(mxy(17), mxy(16), qx)

!             Use the recurrence relation if a was a negative integer.

      if (kflagi == 0 .and. inta < 0) then
          n = -inta
          call fmi2m(1, mxy(17), qx)
          call fmdiv_r1(mxy(17), mxy(2), qx)
          call fmeq(mxy(17), mxy(15), qx)
          call fmeq(mxy(17), mxy(14), qx)
          do j = 1, n-1
             call fmmpyi_r1(mxy(15), j, qx)
             call fmmpy_r1(mxy(15), mxy(14), qx)
             call fmnegate(mxy(15), qx)
             call fmadd_r1(mxy(17), mxy(15), qx)
          enddo
          call fmexp(mxy(2), mxy(14), qx)
          qx%ndige = 0
          call fmdiv_r1(mxy(17), mxy(14), qx)
          call fmsub_r1(mxy(16), mxy(17), qx)
          call fmfcti(n, mxy(14), qx)
          call fmdiv_r1(mxy(16), mxy(14), qx)
          if (mod(n, 2) == 1) call fmnegate(mxy(16), qx)
      endif

      call fmeq(mxy(16), mresult, qx)

      return
      end subroutine fmigm2_m4

      subroutine fmigm2_sc(ma, mb, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = igm2(ma, mb).

!  kresult = 1 is returned if a special case gives the value of igm2(ma, mb).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mxy(20), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j, k, kl, krsave
      double precision :: xe, ye
      type(multi) :: malocal, mblocal
      logical, external :: fmcomp

      kresult = 0

      qx%namest(qx%ncall) = 'FMIGM2   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp2(ma, mb, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)
      call fmequ(mb, mblocal, ndsave, qx%ndig, qx)

      j = qx%ntrace
      qx%ntrace = 0
      k = qx%kwarn
      qx%kwarn = 0
      call fmint(malocal, mxy(1), qx)
      qx%ntrace = j
      qx%kwarn = k
      if ((malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0)   .or.       &
          (mblocal%mp(2) == qx%munkno .and. mblocal%mp(5) >= 0)   .or.       &
          (mblocal%mp(1) < 0 .and. fmcomp(malocal, '/=', mxy(1), qx))  .or.  &
          (mblocal%mp(1) < 0 .and. malocal%mp(3) == 0)   .or.                &
          (malocal%mp(1) < 0 .and. mblocal%mp(1) < 0)) then
          qx%ntrace = j
          qx%kwarn = k
          call fmunknown(mresult, qx)
          qx%kflag = -4
          kresult = 1
          return
      endif
      if (abs(malocal%mp(2)) >= qx%mexpov .or. abs(mblocal%mp(2)) >= qx%mexpov) then
          qx%ntrace = j
          qx%kwarn = k
          if (mblocal%mp(3) == 0 .and. malocal%mp(1) > 0) then
              call fmgam(malocal, mresult, qx)
          else if ((malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) .or.  &
                   (mblocal%mp(2) == qx%munkno .and. mblocal%mp(5) >= 0)) then
              call fmunknown(mresult, qx)
          else
              call fmovun_xe(malocal, xe, qx)
              call fmovun_xe(mblocal, ye, qx)
              if ((ye-xe >= qx%ndig .and. ye > ndsave) .or.  &
                  (mblocal%mp(2) == qx%mexpov .and. fmcomp(mblocal, '>', malocal, qx))) then
                  call fmabs(mblocal, mxy(1), qx)
                  call fmln(mxy(1), mxy(3), qx)
                  qx%ndigli = 0
                  call fmi2m(1, mxy(2), qx)
                  call fmadd_r2(malocal, mxy(2), qx)
                  call fmmpy_r2(mxy(2), mxy(3), qx)
                  call fmsub_r1(mxy(3), mblocal, qx)
                  call fmexp(mxy(3), mresult, qx)
                  qx%ndige = 0
              else if ((xe > qx%ndig .and. xe-ye >= qx%ndig) .or.  &
                       (malocal%mp(2) == qx%mexpov .and. fmcomp(malocal, '>', mblocal, qx))) then
                  if (malocal%mp(1) > 0) then
                      call fmabs(malocal, mxy(1), qx)
                      call fmln(mxy(1), mxy(3), qx)
                      qx%ndigli = 0
                      call fmaddi(mxy(3), -1, qx)
                      call fmmpy_r2(malocal, mxy(3), qx)
                      call fmexp(mxy(3), mxy(2), qx)
                      qx%ndige = 0
                      call fmpi(mxy(1), qx)
                      qx%ndigpi = 0
                      call fmmpyi_r1(mxy(1), 2, qx)
                      call fmdiv_r1(mxy(1), malocal, qx)
                      if (mxy(1)%mp(1) < 0) call fmnegate(mxy(1), qx)
                      call fmsqrt_r1(mxy(1), qx)
                      call fmmpy(mxy(1), mxy(2), mresult, qx)
                  else
                      call fmpwr(mblocal, malocal, mxy(1), qx)
                      call fmdiv(mxy(1), malocal, mresult, qx)
                      call fmnegate(mresult, qx)
                  endif
              else if (xe < -ndsave .and. ye < -ndsave) then
                  call fmndig(qx%ndig + qx%ngrd22, qx)
                  call fmequ(mblocal, mxy(2), qx%ndig-qx%ngrd22, qx%ndig, qx)
                  call fmabs(mxy(2), mxy(1), qx)
                  call fmln(mxy(1), mxy(2), qx)
                  qx%ndigli = 0
                  call fmnegate(mxy(2), qx)
                  call fmeulr(mxy(3), qx)
                  qx%ndgeul = 0
                  call fmsub_r2(mxy(2), mxy(3), qx)
                  call fmeq(mxy(3), mresult, qx)
              else if (xe < -ndsave .and. ye >= 0) then

                  call fmndig(qx%ndig + qx%ngrd22, qx)
                  call fmequ(mblocal, mxy(1), qx%ndig-qx%ngrd22, qx%ndig, qx)
                  call fmnegate(mxy(1), qx)
                  call fmei(mxy(1), mxy(2), qx)
                  call fmnegate(mxy(2), qx)
                  call fmabs(mxy(1), mxy(3), qx)
                  call fmln(mxy(3), mxy(1), qx)
                  qx%ndigli = 0
                  call fmequ(malocal, mxy(3), qx%ndig-qx%ngrd22, qx%ndig, qx)
                  call fmmpy_r2(mxy(1), mxy(3), qx)
                  call fmmpy_r2(mxy(2), mxy(3), qx)
                  call fmadd_r2(mxy(2), mxy(3), qx)
                  if (mxy(3)%mp(5) >= 0) then
                      call fmequ(malocal, mxy(3), qx%ndig-qx%ngrd22, qx%ndig, qx)
                      call fmmpy_r2(mxy(1), mxy(3), qx)
                      call fmaddi(mxy(3), 1, qx)
                      call fmmpy_r2(mxy(2), mxy(3), qx)
                  endif
                  call fmeq(mxy(3), mresult, qx)
              else if (xe >= 0 .and. ye < -ndsave .and. malocal%mp(3) /= 0) then
                  call fmndig(qx%ndig + qx%ngrd22, qx)
                  call fmequ(malocal, mxy(3), qx%ndig-qx%ngrd22, qx%ndig, qx)
                  call fmequ(mblocal, mxy(4), qx%ndig-qx%ngrd22, qx%ndig, qx)
                  call fmpwr(mxy(4), mxy(3), mxy(1), qx)
                  call fmdiv_r1(mxy(1), mxy(3), qx)
                  call fmgam(mxy(3), mxy(2), qx)
                  call fmsub(mxy(2), mxy(1), mxy(3), qx)
                  call fmeq(mxy(3), mresult, qx)
              else
                  call fmunknown(mresult, qx)
              endif
          endif
          kresult = 1
          return
      endif


!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      call fmovun_xe(mblocal, ye, qx)

      if (qx%kround /= 1 .and. mblocal%mp(1) > 0 .and. malocal%mp(3) /= 0 .and.   &
          ye < -ndsave - qx%ngrd52) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          krsave = qx%kround
          qx%kround = 1
          call fmndig(qx%ndig + qx%ngrd52, qx)
          call fmequ(malocal, mxy(1), ndsave, qx%ndig, qx)
          call fmequ(mblocal, mxy(2), ndsave, qx%ndig, qx)
          call fmgam(mxy(1), mxy(3), qx)
          if (mxy(3)%mp(2) /= qx%munkno) then
              call fmigm1(mxy(1), mxy(2), mxy(4), qx)
              qx%kround = krsave
              call fmsub(mxy(3), mxy(4), mxy(5), qx)
              call fmovun_xe(mxy(3), xe, qx)
              call fmovun_xe(mxy(5), ye, qx)
              if (mxy(5)%mp(3) == 0 .or. ye < xe-qx%ngrd52) then
                  qx%kflag = 0
                  qx%ntrace = j
                  qx%kwarn = k
                  call fmndig(qx%ndig - qx%ngrd52, qx)
                  return
              endif
          else
              call fmm2i(mxy(1), kl, qx)
              call fmipwr(mxy(2), kl, mxy(4), qx)
              if (mxy(4)%mp(2) /= qx%mexpov) then
                  call fmdivi_r1(mxy(4), -kl, qx)
              endif
              call fmtiny(mxy(5), qx)
              qx%kround = krsave
              call fmsub_r2(mxy(4), mxy(5), qx)
          endif
          qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          call fmeq(mxy(5), mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine fmigm2_sc

      subroutine fminp(line, ma, la, lb, qx)

!  Convert an array of characters to floating point multiple precision format.

!  line is an a1 character array of length lb to be converted to fm format and returned in ma.
!  Convert the section line(la:lb).

!  The input number may be in integer or any real format.

!  keswch = 1  causes input to fminp with no digits before the exponent letter to be treated as if
!              there were a leading '1'.  This is sometimes better for interactive input:
!              'e7' converts to 10.0**7.
!         = 0  causes a leading zero to be assumed.  This gives compatibility with Fortran:
!              'e7' converts to 0.0.

!  In exponential format the 'e' may also be 'd', 'q', or 'm'.

!  So that fminp will convert any output from fmout, line is tested to see if the input is one of
!  the special symbols +overflow, -overflow, +underflow, -underflow, or unknown.
!  For user input the abbreviations ovfl, unfl, unkn may be used.

      use fmvals_parallel
      implicit none

      integer :: la, lb
      character :: line(lb)
      type(multi) :: ma
      intent (in) :: line, la, lb
      intent (inout) :: ma
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kpower, kresult, krnd, kwrnsave, ndsave, ntrsave
      type(multi) :: mxy(5), mresult
      logical :: retry

      call fmalloc(ma, qx%ndig+2, qx)
      call fmenter0(kovun, mxsave, ndsave, qx)
      ntrsave = qx%ntrace
      qx%ntrace = 0
      qx%kflag = 0
      kwrnsave = qx%kwarn
      qx%kwarn = 0
      call fminp_sc(line, la, lb, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, ma, kovun, mxsave, ndsave, qx)
          qx%kflag = 0
          qx%ntrace = ntrsave
          qx%kwarn = kwrnsave
          return
      endif

      krnd = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fminp_m1(line, la, lb, mxy, mresult, ma, krnd, kpower, ndsave, qx)
         if (qx%mbase == 10**kpower) exit
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      if (krnd == 0) then
          call fmexit1(mresult, ma, kovun, mxsave, ndsave, qx)
      else
          call fmexit1(mresult, mxy(1), kovun, mxsave, ndsave, qx)
      endif
      qx%ntrace = ntrsave
      qx%kwarn = kwrnsave

      return
      end subroutine fminp

      subroutine fminp2(mxy, line, kstart, kstop, kpower, mbsave, qx)

!  Internal routine for input conversion for a power of ten mbase.

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(5)
      integer :: kstart, kstop, kpower
      real (kind(1.0d0)) :: mbsave
      character :: line(kstop)
      intent (in) :: line, kstart, kstop, kpower, mbsave
      intent (inout) :: mxy
      type(fm_settings) :: qx

      integer :: j, jstate, k, kdflag, kexp, kf1, kf1dig, kf2, kf2dig, kf2pt, knzdig, kpt,  &
                  kshift, ksign, ksignx, ktype, kval, lnzd, nf1, nf2
      double precision :: d, dlog_10, dlog_mbsave, f1, f2, fexp, fp

!  Simulate a finite-state automaton to scan the input line and build the number.
!  States of the machine:

!  1.  Initial entry to the subroutine
!  2.  Sign of the number
!  3.  Scanning digits before a decimal point
!  4.  Decimal point
!  5.  Scanning digits after a decimal point
!  6.  e, d, q, or m -- precision indicator before the exponent
!  7.  Sign of the exponent
!  8.  Scanning exponent
!  9.  Syntax error

!  Character types recognized by the machine:

!  1.  Sign (+,-)
!  2.  Numeral (0,1,...,9)
!  3.  Decimal point (.)
!  4.  Precision indicator (e,d,q,m)
!  5.  Illegal character for number

!  All blanks are ignored.  The analysis of the number proceeds as follows:  If the simulated
!  machine is in state jstate and a character of type jtype is encountered the new state of the
!  machine is given by jtrans(jstate,jtype).

!  In this initialization, the array is loaded by columns.

!          State   1  2  3  4  5  6  7  8

      integer :: jtrans(8, 4) = reshape(  (/    &
                   2, 9, 7, 7, 7, 7, 9, 9,      &
                   3, 3, 3, 5, 5, 8, 8, 8,      &
                   4, 4, 4, 9, 9, 9, 9, 9,      &
                   6, 6, 6, 6, 6, 9, 9, 9   /)  &
        , (/ 8, 4 /) )

      jstate = 1
      kdflag = 0
      ksign = 1
      ksignx = 1
      kf1 = 0
      knzdig = 0
      lnzd = 0
      kf1dig = 0
      kf2 = 0
      kf2dig = 0
      kf2pt = 2
      kexp = 0
      nf1 = 0
      nf2 = 0
      f1 = 0
      f2 = 0
      fexp = 0
      fp = 1
      dlog_10 = log(10.0d0)
      dlog_mbsave = log(dble(mbsave))

!             Scan the number.

      do j = kstart, kstop
         if (line(j) == ' ') cycle
         kpt = ichar(line(j))
         if (kpt < lhash1 .or. kpt > lhash2) then
             write (qx%kw,                                                      &
                "(/' Error in input conversion.'/"                          //  &
                "' ICHAR function was out of range for the current', "      //  &
                "' dimensions.'/' ICHAR(''', A, ''') gave the value ', "    //  &
                "I12, ', which is outside the currently'/' dimensioned', "  //  &
                "' bounds of (', I5, ':', I5, ') for variables KHASHT ', "  //  &
                "'and KHASHV.'/' Re-define the two parameters ', "          //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain', "   //  &
                "' all possible output values from ICHAR.'//)"                  &
                   ) line(j), kpt, lhash1, lhash2
             ktype = 5
             kval  = 0
         else
             ktype = qx%khasht(kpt)
             kval  = qx%khashv(kpt)
         endif

         if (ktype >= 5) then

!                  Error in converting the number.

             call fmi2m2(0, mxy(5), qx)
             mxy(5)%mp(2) = qx%munkno
             mxy(5)%mp(3) = 1
             mxy(5)%mp(1) = 1
             qx%kflag = -7
             return
         endif

         jstate = jtrans(jstate, ktype)

         select case (jstate)

!             State 2.  Sign of the number.

         case (2)
             ksign = kval

!             State 3.  Digits before a decimal point.

         case (3)
             kdflag = 1
             kf1 = 10*kf1 + kval
             if (f1 <= huge(f1)/11) then
                 f1 = 10 * f1 + kval
             else
                 nf1 = nf1 + 1
             endif
             if (kval > 0) lnzd = 1
             if (kval > 0 .or. knzdig /= 0) then
                 knzdig = 1
                 kf1dig = kf1dig + 1
             endif
             if (kf1dig == kpower) then
                 mxy(2)%mp(2) = mxy(2)%mp(2) + 1
                 k = mxy(2)%mp(2)
                 if (k < qx%ndig) then
                     mxy(2)%mp(k+2) = kf1
                 endif
                 kf1 = 0
                 kf1dig = 0
             endif

!             State 4.  Decimal point

         case (4)
             cycle

!             State 5.  Digits after a decimal point.

         case (5)
             kdflag = 1
             if (kval == 0 .and. fp == 1.0d0) then
                 nf2 = nf2 + 1
             else
                 if (fp > tiny(fp)*11) then
                     fp = fp / 10.0d0
                     f2 = f2 + fp * kval
                 endif
             endif
             if (kval > 0) lnzd = 1
             if (kf2pt > qx%ndig+1) cycle
             kf2 = 10*kf2 + kval
             kf2dig = kf2dig + 1
             if (kf2dig == kpower) then
                 mxy(3)%mp(kf2pt+1) = kf2
                 if (kf2 == 0 .and. kf2pt == 2) then
                     mxy(3)%mp(2) = mxy(3)%mp(2) - 1
                 else
                     kf2pt = kf2pt + 1
                 endif
                 kf2 = 0
                 kf2dig = 0
             endif

!             State 6.  Precision indicator.

         case (6)
             if (kdflag == 0 .and. qx%keswch == 1) then
                 lnzd = 1
                 call fmi2m2(1, mxy(2), qx)
                 kf1 = 1
                 f1 = 1
             endif

!             State 7.  Sign of the exponent.

         case (7)
             ksignx = kval

!             State 8.  Digits of the exponent.

         case (8)
             if (lnzd == 0) then
                 call fmi2m2(0, mxy(5), qx)
                 return
             endif

!                  Check for overflow or underflow.

             if (fexp >= huge(fexp)/11) then
                 if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
                     d = 1.0d+10
                 else
                     d = 4
                 endif
                 call fmi2m2(1, mxy(5), qx)
                 if (ksignx > 0) then
                     mxy(5)%mp(1) = ksign
                     mxy(5)%mp(2) = qx%mexpov
                     mxy(5)%mp(4) = huge(qx%mbase)/d
                     mxy(5)%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
                 else
                     mxy(5)%mp(1) = ksign
                     mxy(5)%mp(2) = qx%mexpun
                     mxy(5)%mp(4) = -huge(qx%mbase)/d
                     mxy(5)%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
                 endif
                 return
             endif
             fexp = 10*fexp + kval
             k = 0
             if (ksignx > 0) then
                 if (nf1 > 0) then
                     if (log(f1) + nf1*dlog_10 + fexp*dlog_10 >= (qx%mxexp0+4.0d0) * dlog_mbsave) then
                         k = 1
                     endif
                 else
                     if (f1 == 0) then
                         if (log(f2) - nf2*dlog_10 + fexp*dlog_10 >=  &
                             (qx%mxexp0+4.0d0) * dlog_mbsave) then
                             k = 1
                         endif
                     else if (nf2 > 50) then
                         if (log(f1) + fexp*dlog_10 >= (qx%mxexp0+4.0d0) * dlog_mbsave) then
                             k = 1
                         endif
                     else
                         if (log(f1+f2/10.0d0**nf2) + fexp*dlog_10 >=  &
                             (qx%mxexp0+4.0d0) * dlog_mbsave) then
                             k = 1
                         endif
                     endif
                 endif
             else
                 if (nf1 > 0) then
                     if (log(f1) + nf1*dlog_10 - fexp*dlog_10 < (-qx%mxexp0-3.0d0) * dlog_mbsave) then
                         k = 1
                     endif
                 else
                     if (f1 == 0) then
                         if (log(f2) - nf2*dlog_10 - fexp*dlog_10 <  &
                             (-qx%mxexp0-3.0d0) * dlog_mbsave) then
                             k = 1
                         endif
                     else if (nf2 > 50) then
                         if (log(f1) - fexp*dlog_10 < (-qx%mxexp0-3.0d0) * dlog_mbsave) then
                             k = 1
                         endif
                     else
                         if (log(f1+f2/10.0d0**nf2) - fexp*dlog_10 <  &
                             (-qx%mxexp0-3.0d0) * dlog_mbsave) then
                             k = 1
                         endif
                     endif
                 endif
             endif
             if (k == 1) then
                 call fminp2b(kf1, kf2, kf1dig, kf2dig, kf2pt, kpower, mxy, qx)
                 call fminp3(line, kstart, kstop, mxy, mbsave, qx)
                 return
             endif
             kexp = 10*kexp + kval

         case default

!                  Error in converting the number.

             call fmi2m2(0, mxy(5), qx)
             mxy(5)%mp(2) = qx%munkno
             mxy(5)%mp(3) = 1
             mxy(5)%mp(1) = 1
             qx%kflag = -7
             return

         end select

      enddo

!             Form the number and return.  mxy(5) = ksign*(mxy(2) + mxy(3))*10.0**(ksignx*kexp)

      call fminp2b(kf1, kf2, kf1dig, kf2dig, kf2pt, kpower, mxy, qx)

      if (kexp /= 0) then
          if (ksignx == 1) then
              mxy(4)%mp(2) = int(kexp/kpower) + 1
              mxy(4)%mp(3) = 10**(mod(kexp, kpower))
          else
              mxy(4)%mp(2) = -int((kexp-1)/kpower)
              kshift = 10**(mod(kexp, kpower))
              if (kshift > 1) then
                  mxy(4)%mp(3) = qx%mbase/kshift
              else
                  mxy(4)%mp(3) = 1
              endif
          endif
      endif

      call fmadd2(mxy(2), mxy(3), mxy(5), qx)

      if (kexp > 0) call fmmpy2_r1(mxy(5), mxy(4), qx)
      mxy(5)%mp(1) = ksign

      return
      end subroutine fminp2

      subroutine fminp2b(kf1, kf2, kf1dig, kf2dig, kf2pt, kpower, mxy, qx)

!  Internal routine to complete the evaluation of
!  mxy(2) = number represented by any digits before a decimal point
!  mxy(3) = number represented by any digits after a decimal point

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(5)
      integer :: kf1, kf2, kf1dig, kf2dig, kf2pt, kpower
      intent (in) :: kf1, kf2, kf1dig, kf2dig, kf2pt, kpower
      intent (inout) :: mxy
      type(fm_settings) :: qx

      integer :: k, kshift

      if (kf1dig /= 0) then
          mxy(2)%mp(2) = mxy(2)%mp(2) + 1
          kshift = 10**(kpower-kf1dig)
          k = mxy(2)%mp(2)
          if (k < qx%ndig) mxy(2)%mp(2+int(k)) = kf1*kshift
          if (kshift > 1) then
              call fmdivi2_r1(mxy(2), kshift, qx)
          endif
      endif
      if (mxy(2)%mp(3) == 0) then
          mxy(2)%mp(1) = 1
          mxy(2)%mp(2) = 0
      else
          mxy(2)%mp(1) = 1
      endif

      if (kf2dig /= 0) then
          kshift = 10**(kpower-kf2dig)
          mxy(3)%mp(kf2pt+1) = kf2*kshift
      endif
      if (mxy(3)%mp(3) == 0) then
          mxy(3)%mp(1) = 1
          mxy(3)%mp(2) = 0
      else
          mxy(3)%mp(1) = 1
      endif

      return
      end subroutine fminp2b

      subroutine fminp3(line, kstart, kstop, mxy, mbsave, qx)

!  Internal routine to see if the input character string in line would overflow or underflow
!  with the current base and precision.

!  mxy(5) is returned as + or - over/underflow or unknown.

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(5)
      integer :: kstart, kstop
      character :: line(kstop)
      real (kind(1.0d0)) :: mbsave
      intent (in) :: line, kstart, kstop, mbsave
      intent (inout) :: mxy
      type(fm_settings) :: qx

      integer :: j, jstate, kdigfl, kpt, ksign, ksignx, ktype, kval
      double precision :: dlog_mbsave, f1, fexp, flarge, ze, zf
      integer :: jtrans(8, 4) = reshape(  (/    &
                   2, 9, 7, 7, 7, 7, 9, 9,      &
                   3, 3, 3, 5, 5, 8, 8, 8,      &
                   4, 4, 4, 9, 9, 9, 9, 9,      &
                   6, 6, 6, 6, 6, 9, 9, 9   /)  &
        , (/ 8, 4 /) )
      character :: kblank = ' '

      jstate = 1
      ksign = 1
      dlog_mbsave = log(dble(mbsave))
      f1 = 0
      ksignx = 1
      fexp = 0
      flarge = huge(f1)/31

!             kdigfl will be 1 if any digits are found before 'e'.

      kdigfl = 0

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      if (qx%lhash == 0) call fmhtbl(qx)

!             Scan the number.

      do j = kstart, kstop
         if (line(j) == kblank) cycle
         kpt = ichar(line(j))
         if (kpt < lhash1 .or. kpt > lhash2) then
             write (qx%kw,                                                      &
                "(/' Error in input conversion.'/"                          //  &
                "' ICHAR function was out of range for the current', "      //  &
                "' dimensions.'/' ICHAR(''', A, ''') gave the value ', "    //  &
                "I12, ', which is outside the currently'/' dimensioned', "  //  &
                "' bounds of (', I5, ':', I5, ') for variables KHASHT ', "  //  &
                "'and KHASHV.'/' Re-define the two parameters ', "          //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain', "   //  &
                "' all possible output values from ICHAR.'//)"                  &
                   ) line(j), kpt, lhash1, lhash2
             ktype = 5
             kval  = 0
         else
             ktype = qx%khasht(kpt)
             kval  = qx%khashv(kpt)
         endif
         if (ktype >= 5) then

!                  Error in converting the number.

             call fmi2m2(0, mxy(5), qx)
             mxy(5)%mp(2) = qx%munkno
             mxy(5)%mp(3) = 1
             mxy(5)%mp(1) = 1
             qx%kflag = -7
             return
         endif

         jstate = jtrans(jstate, ktype)

         select case (jstate)

!             State 2.  Sign of the number.

         case (2)
             ksign = kval

!             State 3.  Digits before a decimal point.

         case (3)
             cycle

!             State 4.  Decimal point

         case (4)
             cycle

!             State 5.  Digits after a decimal point.

         case (5)
             cycle

!             State 6.  Precision indicator.

         case (6)
             if (kdigfl == 0) f1 = 1.0d0

!             State 7.  Sign of the exponent.

         case (7)
             ksignx = kval

!             State 8.  Digits of the exponent.

         case (8)
             if (fexp < flarge) then
                 fexp = 10*fexp + kval
             endif

         case default

!                  Error in converting the number.

             call fmi2m2(0, mxy(5), qx)
             mxy(5)%mp(2) = qx%munkno
             mxy(5)%mp(3) = 1
             mxy(5)%mp(1) = 1
             qx%kflag = -7
             return

         end select

      enddo

!             mxy(5) = ksign*(mxy(2) + mxy(3))*10.0**(ksignx*fexp)

      call fmi2m2(1, mxy(1), qx)
      if (ksignx > 0) then
          ze = aint(ksignx*fexp*log(10.0d0)/dlog_mbsave)
      else
          ze = aint(ksignx*fexp*log(10.0d0)/dlog_mbsave) - 1.0d0
      endif
      zf = ksignx*fexp*log(10.0d0) - ze*dlog_mbsave
      if (zf < -dlog_mbsave) then
          zf = 1.0d0/mbsave
      else if (zf > 0.0d0) then
          zf = 1.0d0 - epsilon(1.0d0)
      else
          zf = exp(zf)
      endif
      mxy(1)%mp(1) = ksign
      if (ze > qx%mxexp0+1) then
          mxy(1)%mp(2) = qx%mexpov
      else if (ze < -qx%mxexp0) then
          mxy(1)%mp(2) = qx%mexpun
      else
          mxy(1)%mp(2) = qx%munkno
      endif
      mxy(1)%mp(4) = ze
      mxy(1)%mp(5) = -maxint * zf
      call fmadd2(mxy(2), mxy(3), mxy(4), qx)
      call fmmpy2(mxy(1), mxy(4), mxy(5), qx)

      return
      end subroutine fminp3

      subroutine fminp_m1(line, la, lb, mxy, mresult, ma, krnd, kpower, ndsave, qx)

!  Method 1 for computing fminp.

      use fmvals_parallel
      implicit none

      integer :: la, lb, krnd, kpower, ndsave
      character :: line(lb)
      type(multi) :: mxy(5), mresult, ma
      intent (in) :: line, la, lb, ndsave
      intent (inout) :: mxy, mresult, ma, krnd, kpower
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mbsave, mxsav1, mxsav2
      character(9) :: namest_save(0:50)
      integer :: j, k, krndsave, kstart, kstop, l, m, nd, ndsav1,  &
                 new_mbase, new_ndig, ntrsav

      krnd = 0
      krndsave = qx%kround
      qx%kround = 1
      mbsave = qx%mbase
      mxsav1 = qx%mxexp
      mxsav2 = qx%mxexp2
      ndsav1 = qx%ndig
      kstart = la
      kstop = lb

!             If mbase is a power of ten then call fminp2 for faster input conversion.

      kpower = int(log10(dble(qx%mbase)) + 0.5d0)
      if (qx%mbase == 10**kpower) then
          k = 0
          do j = la, lb
             if (line(j) /= ' ') then
                 do l = lb, la, -1
                    if (line(l) /= ' ') then
                        k = (l-j+1)*log(10.0d0)/log(dble(qx%mbase))
                        exit
                    endif
                 enddo
                 exit
             endif
          enddo
          if (qx%ndig <= k+2) then
              call fmndig(k + 3, qx)
              ndsav1 = qx%ndig
          endif
          call fmi2m2(0, mxy(1), qx)
          call fmi2m2(0, mxy(2), qx)
          call fmi2m2(0, mxy(3), qx)
          call fmi2m2(0, mxy(4), qx)
          call fmi2m2(0, mxy(5), qx)
          call fminp2(mxy, line, kstart, kstop, kpower, mbsave, qx)
          call fmeq(mxy(5), mresult, qx)
          if (mxy(5)%mp(2) == qx%munkno) qx%kflag = -7
          qx%mxexp = mxsav1
          qx%mxexp2 = mxsav2
          qx%kround = krndsave
          if (qx%kflag == 1) qx%kflag = 0
          if (mresult%mp(3) == 0) mresult%mp(1) = 1
          return
      endif

!             If mbase is not a power of ten then call fminp2 first using a power of ten base,
!             then change to base mbase.

      mbsave = qx%mbase
      kpower = int(log10(dble(mxbase)/4) + 0.5d0)
      qx%mbase = 10**kpower
      call fmndig(int(ndsav1*log(dble(mbsave))/log(dble(qx%mbase)) + 3), qx)
      k = 0
      do j = la, lb
         if (line(j) /= ' ') then
             do l = lb, la, -1
                if (line(l) /= ' ') then
                    k = (l-j+1)*log(10.0d0)/log(dble(qx%mbase))
                    exit
                endif
             enddo
             exit
         endif
      enddo
      if (qx%ndig <= k+9) then
          call fmndig(k + 10, qx)
      endif
      call fmcons(qx)
      call fmi2m2(0, mxy(1), qx)
      call fmi2m2(0, mxy(2), qx)
      call fmi2m2(0, mxy(3), qx)
      call fmi2m2(0, mxy(4), qx)
      call fmi2m2(0, mxy(5), qx)
      j = qx%mxexp2
      k = j*log(dble(mbsave))/log(dble(qx%mbase)) + 0.5
      qx%mxexp2 = k
      call fminp2(mxy, line, kstart, kstop, kpower, mbsave, qx)
      qx%mxexp2 = j
      new_mbase = mbsave
      new_ndig = max(ndsav1, qx%ndig*nint(log(dble(qx%mbase))/log(dble(mbsave))))
      nd = 2
      do j = qx%ndig, 3, -1
         if (mxy(5)%mp(j+2) /= 0) then
             nd = j
             exit
         endif
      enddo
      call fmndig(nd, qx)
      ntrsav = qx%ntrace
      qx%ntrace = 0
      j = qx%ncall
      do m = 0, qx%ncall
         namest_save(m) = qx%namest(m)
      enddo
      qx%ncall = 0
      if (abs(mxy(5)%mp(2)) < qx%mexpov) then
          call fmchangebase(mxy(5), mxy(4), new_mbase, new_ndig, qx)
      else
          call fmequ(mxy(5), mxy(4), qx%ndig, new_ndig, qx)
      endif
      qx%ncall = j
      do m = 0, qx%ncall
         qx%namest(m) = namest_save(m)
      enddo
      qx%ntrace = ntrsav
      qx%mbase = mbsave
      call fmndig(new_ndig, qx)
      call fmcons(qx)
      call fmeq(mxy(4), mresult, qx)
      if (mresult%mp(2) == qx%munkno) then
          qx%kflag = -7
          qx%mxexp = mxsav1
          qx%mxexp2 = mxsav2
          qx%kround = krndsave
          if (qx%kflag == 1) qx%kflag = 0
          if (mresult%mp(3) == 0) mresult%mp(1) = 1
          return
      endif

      qx%mxexp = mxsav1
      qx%mxexp2 = mxsav2
      qx%kround = krndsave
      if (int(qx%mbase-aint (qx%mbase/2)*2) == 0) then
          call fmequ(mresult, ma, qx%ndig, ndsave, qx)
      else
          call fmequ(mresult, ma, qx%ndig-1, ndsave, qx)
      endif
      krnd = 1

      return
      end subroutine fminp_m1

      subroutine fminp_sc(line, la, lb, mresult, kresult, qx)

!  Check for special cases for fminp.

!  kresult = 1 is returned if a special case gives the values of the two results.

      use fmvals_parallel
      implicit none

      integer :: la, lb, kresult
      character :: line(lb)
      type(multi) :: mresult
      intent (in) :: line, la, lb
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j, kmn, kof, kpt, ktype, kuf, kuk

      character :: kovfl(4) = (/ 'O', 'V', 'F', 'L' /)
      character :: kunfl(4) = (/ 'U', 'N', 'F', 'L' /)
      character :: kunkn(4) = (/ 'U', 'N', 'K', 'N' /)
      character :: lovfl(4) = (/ 'o', 'v', 'f', 'l' /)
      character :: lunfl(4) = (/ 'u', 'n', 'f', 'l' /)
      character :: lunkn(4) = (/ 'u', 'n', 'k', 'n' /)

      kresult = 0
      qx%namest(qx%ncall) = 'FMINP    '

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      if (qx%lhash == 0) call fmhtbl(qx)

!             Check for special symbols.

      kmn = 1
      kof = 1
      kuf = 1
      kuk = 1
      do j = la, lb
         kpt = ichar(line(j))
         if (kpt >= lhash1 .and. kpt <= lhash2) then
             ktype = qx%khasht(kpt)
             if (ktype == 2) return
         endif
         if (line(j) == '-') kmn = -1
         if (line(j) == kovfl(kof) .or. line(j) == lovfl(kof)) then
             kof = kof + 1
             if (kof == 5) then
                 call fmi2m2(0, mresult, qx)
                 mresult%mp(1) = kmn
                 mresult%mp(2) = qx%mexpov
                 mresult%mp(3) = 1
                 mresult%mp(4) = qx%mxexp0 + 2
                 mresult%mp(5) = -(1.01d0*maxint)/qx%mbase
                 kresult = 1
                 return
             endif
         endif
         if (line(j) == kunfl(kuf) .or. line(j) == lunfl(kuf)) then
             kuf = kuf + 1
             if (kuf == 5) then
                 call fmi2m2(0, mresult, qx)
                 mresult%mp(1) = kmn
                 mresult%mp(2) = qx%mexpun
                 mresult%mp(3) = 1
                 mresult%mp(4) = -qx%mxexp0 - 1
                 mresult%mp(5) = -(0.495d0*maxint)
                 kresult = 1
                 return
             endif
         endif
         if (line(j) == kunkn(kuk) .or. line(j) == lunkn(kuk)) then
             kuk = kuk + 1
             if (kuk == 5) then
                 call fmi2m2(0, mresult, qx)
                 mresult%mp(2) = qx%munkno
                 mresult%mp(3) = 1
                 kresult = 1
                 return
             endif
         endif
      enddo

      return
      end subroutine fminp_sc

      subroutine fminput_error(qx)
      use fmvals_parallel
      implicit none
      integer :: e(2)
      type(fm_settings) :: qx
      e = 0
      write (*,*) ' '
      write (*,*) ' '
      write (*,*) ' ***  Error in a program using the FM package  ***'
      write (*,*) ' '
      write (*,*) ' A multiple precision number is undefined in an expression or as an input'
      write (*,*) ' argument to a subprogram.'
      write (*,*) ' '
      write (*,*) ' '
      write (*,*) ' The most common causes of this error are:'
      write (*,*) "     1. A multiple-precision variable (type(fm), (im), (zm), etc.) appears in an"
      write (*,*) "        expression in the user's program before it has been given a value."
      write (*,*) "     2. The user's program raises precision (ndig) and later tries to use a"
      write (*,*) "        variable previously defined at a lower precision."
      write (*,*) "        Call fm_equ or fm_equ_r1 to increase the size of type(fm) variables"
      write (*,*) "        after increasing precision, zm_equ for type(zm) variables, etc."
      write (*,*) ' '
      write (*,*) ' To help isolate the code that caused this error, this error message is followed'
      write (*,*) ' by an illegal out-of-range array reference.  Some compilers have an option for'
      write (*,*) ' checking array bounds and will give a traceback with the line number in the'
      write (*,*) ' calling program where the error originated.'
      write (*,*) ' '
      write (*,*) ' The program has been stopped.'
      write (*,*) ' '
      if (e(-qx%ndig) > -314159) write (*,*) ' Negative array subscript.'
      stop
      end subroutine fminput_error

      subroutine fmint(ma, mb, qx)

!  mb = int(ma)

!  The integer part of ma is computed and returned in mb as a multiple precision floating
!  point number.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      integer :: j, ka, kresult

      call fmalloc(mb, qx%ndig+2, qx)

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      qx%kflag = 0
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMINT'
      if (qx%ntrace /= 0) call fmntr_inp1(ma, qx)

      call fmint_sc(ma, mb, kresult, qx)
      if (kresult > 0) then
          mb%mp(1) = ma%mp(1)
          if (mb%mp(3) == 0) mb%mp(1) = 1
          if (qx%ntrace /= 0) call fmntr_out1(mb, qx)
          qx%ncall = qx%ncall - 1
          return
      endif

!             Here ma has both integer and fraction parts.  Replace the digits right of the
!             radix point by zeros.

      ka = int(ma%mp(2)) + 2
      do j = 1, ka
         mb%mp(j) = ma%mp(j)
      enddo
      do j = ka+1, qx%ndig+2
         mb%mp(j) = 0
      enddo

      mb%mp(1) = ma%mp(1)
      if (mb%mp(3) == 0) mb%mp(1) = 1
      if (qx%ntrace /= 0) call fmntr_out1(mb, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmint

      subroutine fmint_sc(ma, mb, kresult, qx)

!  Special cases for  mb = int(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: kresult
      intent (in) :: ma
      intent (inout) :: mb, kresult
      type(fm_settings) :: qx

      double precision :: x, xe, xf, ye, yf
      integer :: j
      type(multi) :: mxy

      kresult = 0

      if (ma%mp(2) == qx%munkno .and. ma%mp(5) < 0) then
          qx%kflag = -4
          if (ma%mp(4) > qx%ndig) then
              call fmeq(ma, mb, qx)
          else if (ma%mp(4) < -qx%ndig) then
              call fmi2m(0, mb, qx)
              qx%kflag = 0
          else
              call fmovun_xexf(ma, xe, xf, qx)
              call fmst2m('1.0E+12', mb, qx)
              call fmovun_xexf(mb, ye, yf, qx)
              if (xe > ye .or. (xe == ye .and. xf > yf)) then
                  call fmeq(ma, mb, qx)
              else
                  call fmunknown(mb, qx)
                  x = dble(qx%mbase)**xe * xf
                  if (aint(x) == 0) then
                      mb%mp(4) = 0
                      mb%mp(5) = -maxint * (1/dble(qx%mbase))
                  else
                      x = aint(x)
                      call fmdpm2(x, mxy, qx)
                      call fmovun_xexf(mxy, ye, yf, qx)
                      qx%kflag = -4
                      mb%mp(4) = ye
                      mb%mp(5) = -maxint * yf
                  endif
                  mb%mp(1) = ma%mp(1)
              endif
          endif
          kresult = 1
          return
      endif

!             If ma is less than one in magnitude, return zero.

      if (ma%mp(2) <= 0) then
          do j = 1, qx%ndig+2
             mb%mp(j) = 0
          enddo
          kresult = 1
          return
      endif

!             If the radix point is off the right end of ma then ma is already an integer.
!             Return ma.

      if (ma%mp(2) >= qx%ndig) then
          do j = 1, qx%ndig+2
             mb%mp(j) = ma%mp(j)
          enddo
          if (ma%mp(2) == qx%munkno) qx%kflag = -4
          if (ma%mp(2) == qx%mexpov) qx%kflag = -5
          kresult = 1
          return
      endif

      return
      end subroutine fmint_sc

      subroutine fmipower(ma, ival, mb, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      type(fm_settings) :: qx

      call fmipwr(ma, ival, mb, qx)

      return
      end subroutine fmipower

      subroutine fmipwr(ma, ival, mb, qx)

!  mb = ma**ival

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(2), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmipwr_sc(ma, ival, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call fmipwr_m1(ma, ival, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmipwr

      subroutine fmipwr2(ma, ival, mb, qx)

!  Internal version of fmipwr without any tracing.  mb = ma**ival.
!  Only called by other fm routines.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      type(fm_settings) :: qx

      double precision :: xval
      integer :: k, kwrnsv, ndsave
      type(multi) :: mxy(2)

      call fmalloc(mb, qx%ndig+2, qx)
      xval = abs(ival)
      ndsave = qx%ndig
      if (xval > 10.0 .or. real(qx%mbase) <= 999.0) then
          k = int(log(xval)/qx%alogmb + 1.0)
          call fmndig(qx%ndig + k, qx)
      endif

!             Initialize.

      k = abs(ival)
      kwrnsv = qx%kwarn
      qx%kwarn = 0
      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

!             Handle small exponents by hand.

      if (k == 0) then
          call fmi2m2(1, mxy(2), qx)
      else if (k == 1) then
          call fmeq(mxy(1), mxy(2), qx)
      else if (k == 2) then
          call fmsqr2(mxy(1), mxy(2), qx)
      else if (k == 3) then
          call fmsqr2(mxy(1), mxy(2), qx)
          call fmmpy2_r1(mxy(2), mxy(1), qx)
      else if (k == 4) then
          call fmsqr2(mxy(1), mxy(2), qx)
          call fmsqr2_r1(mxy(2), qx)
      else if (k == 5) then
          call fmsqr2(mxy(1), mxy(2), qx)
          call fmsqr2_r1(mxy(2), qx)
          call fmmpy2_r1(mxy(2), mxy(1), qx)
      endif
      if (k <= 5) then
          if (ival < 0) then
              call fmi2m2(1, mxy(1), qx)
              call fmdiv2_r2(mxy(1), mxy(2), qx)
          endif
          call fmequ(mxy(2), mb, qx%ndig, ndsave, qx)
          qx%ndig = ndsave
          qx%kwarn = kwrnsv
          return
      endif

      if (mod(k, 2) == 0) then
          call fmi2m2(1, mxy(2), qx)
      else
          call fmeq(mxy(1), mxy(2), qx)
      endif

!             This is the multiplication loop.

      do while (k > 1)
         k = k/2
         call fmsqr2_r1(mxy(1), qx)
         if (mod(k, 2) == 1) call fmmpy2_r2(mxy(1), mxy(2), qx)
      enddo

!             Invert if the exponent is negative.

      if (ival < 0) then
          call fmi2m2(1, mxy(1), qx)
          call fmdiv2_r2(mxy(1), mxy(2), qx)
      endif

      call fmequ(mxy(2), mb, qx%ndig, ndsave, qx)
      qx%ndig = ndsave
      qx%kwarn = kwrnsv

      return
      end subroutine fmipwr2

      subroutine fmipwr_m1(ma, ival, mxy, mresult, ndsave, qx)

!  Method 1 for computing ma**ival

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(2), mresult
      integer :: ival, ndsave
      intent (in) :: ma, ival, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: xval
      integer :: k, kwrnsv

      if (qx%ncall == 1) then
          xval = abs(ival)
          k = int((5.0*real(qx%dlogtn) + log(xval))/qx%alogmb + qx%ngrd52 - 1)
          call fmndig(max(qx%ndig+k, 3), qx)
      else
          xval = abs(ival)
          if (xval > 10.0 .or. real(qx%mbase) <= 999.0) then
              k = int(log(xval)/qx%alogmb + 1.0)
              call fmndig(qx%ndig + k, qx)
          endif
      endif

!             Initialize.

      k = abs(ival)
      kwrnsv = qx%kwarn
      qx%kwarn = 0
      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

!             Handle small exponents by hand.

      if (k == 2) then
          call fmsqr2(mxy(1), mresult, qx)
      else if (k == 3) then
          call fmsqr2(mxy(1), mresult, qx)
          call fmmpy2_r1(mresult, mxy(1), qx)
      else if (k == 4) then
          call fmsqr2(mxy(1), mresult, qx)
          call fmsqr2_r1(mresult, qx)
      else if (k == 5) then
          call fmsqr2(mxy(1), mresult, qx)
          call fmsqr2_r1(mresult, qx)
          call fmmpy2_r1(mresult, mxy(1), qx)
      endif
      if (k <= 5) then
          if (ival < 0) then
              call fmi2m2(1, mxy(1), qx)
              call fmdiv2_r2(mxy(1), mresult, qx)
          endif
          qx%kwarn = kwrnsv
          return
      endif

      if (mod(k, 2) == 0) then
          call fmi2m2(1, mresult, qx)
      else
          call fmeq(mxy(1), mresult, qx)
      endif

!             This is the multiplication loop.

      do while (k > 1)
         k = k/2
         call fmsqr2_r1(mxy(1), qx)
         if (mod(k, 2) == 1) call fmmpy2_r2(mxy(1), mresult, qx)
      enddo

!             Invert if the exponent is negative.

      if (ival < 0) then
          call fmi2m2(1, mxy(1), qx)
          call fmdiv2_r2(mxy(1), mresult, qx)
      endif
      qx%kwarn = kwrnsv

      return
      end subroutine fmipwr_m1

      subroutine fmipwr_sc(ma, ival, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = ma**ival.

!  kresult = 1 is returned if a special case gives the value of ma**ival.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(2), mresult
      integer :: ival, kresult, ndsave
      intent (in) :: ma, ival, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j, kwrnsv

      kresult = 0

      qx%namest(qx%ncall) = 'FMIPWR   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1i(ma, ival, qx)
      call fmndig(j, qx)

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

      if (mxy(1)%mp(2) == qx%munkno .and. mxy(1)%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (mxy(1)%mp(2) == qx%munkno .and. mxy(1)%mp(5) < 0) then
          call fmi2m2(ival, mxy(2), qx)
          call fmovun_pwr(mxy(1), mxy(2), mresult, qx)
          kresult = 1
          return
      endif

      if (ival <= 0 .and. mxy(1)%mp(3) == 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (ival == 0) then
          call fmi2m2(1, mresult, qx)
          kresult = 1
          return
      endif

      if (abs(ival) == 1) then
          kwrnsv = qx%kwarn
          qx%kwarn = 0
          if (ival == 1) then
              call fmeq(mxy(1), mresult, qx)
          else
              call fmi2m2(1, mxy(2), qx)
              call fmdiv2(mxy(2), mxy(1), mresult, qx)
          endif
          qx%kwarn = kwrnsv
          kresult = 1
          return
      endif

      if (mxy(1)%mp(3) == 0) then
          call fmeq(mxy(1), mresult, qx)
          kresult = 1
          return
      endif

      if (abs(mxy(1)%mp(2)) == qx%mexpov) then
          call fmi2m2(ival, mxy(2), qx)
          call fmovun_pwr(mxy(1), mxy(2), mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine fmipwr_sc

      subroutine fmlerc(ma, mb, qx)

!  mb = ln(erfc(ma))

!  ma must be positive, and is assumed to be large enough that erfc(ma) might underflow.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(16), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmlerc_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fmlerc_m(ma, mxy, mresult, ndsave, numtry, retry, qx)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry, qx)
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmlerc

      subroutine fmlerc_m(ma, mxy, mresult, ndsave, numtry, retry, qx)

!  Method selection for computing ln(gamma(ma)).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(16), mresult
      integer :: ndsave, numtry
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry
      type(fm_settings) :: qx

      double precision :: xe
      integer :: j, nmethd, nterms
      logical, external :: fmcomp

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

      nterms = int(intmax/10)

!             Check for special cases.

      if (mxy(1)%mp(3) == 0) then
          call fmi2m(0, mresult, qx)
          retry = .false.
          return
      endif
      if (mxy(1)%mp(2) == qx%mexpun) then
          call fmi2m(-2, mxy(2), qx)
          call fmpi(mxy(3), qx)
          qx%ndigpi = 0
          call fmsqrt(mxy(3), mxy(4), qx)
          call fmdiv(mxy(2), mxy(4), mxy(3), qx)
          call fmmpy(mxy(1), mxy(3), mresult, qx)
          return
      endif
      if (mxy(1)%mp(2) == qx%mexpov .and. mxy(1)%mp(1) > 0) then
          call fmsqr(mxy(1), mresult, qx)
          mresult%mp(1) = -1
          qx%kflag = -5
          return
      endif

!             Close to zero use the series for Ln(1-erf(x)).

      call fmovun_xe(mxy(1), xe, qx)
      if (log(mxy(1)%mp(3)+1.0d0)+(xe-1)*qx%dlogmb < -10.0d0*qx%dlogtn) then
          call fmerf(mxy(1), mxy(10), qx)
          call fmeq(mxy(10), mxy(11), qx)
          call fmeq(mxy(10), mxy(6), qx)
          call fmnegate(mxy(11), qx)
          do j = 2, nterms
             call fmmpy_r1(mxy(6), mxy(10), qx)
             call fmdivi(mxy(6), j, mxy(3), qx)
             call fmsub_r1(mxy(11), mxy(3), qx)
             if (qx%kflag == 1) exit
             if (j == nterms) then
                 call fmunknown(mresult, qx)
                 return
             endif
          enddo
          call fmeq(mxy(11), mresult, qx)
          return
      endif

!             Determine which method to use.

!             nmethd = 1 means use fmerfc,
!                    = 2 means use the asymptotic value,
!                    = 3 means use the continued fraction expansion.

      nmethd = 1
      call fmi2m(1000, mxy(3), qx)
      call fmovun_xe(mxy(1), xe, qx)
      if (xe >= qx%ndig) then
          nmethd = 2
      else if (fmcomp(mxy(1), '>', mxy(3), qx)) then
          nmethd = 3
      endif

      if (nmethd == 1) then
          call fmlerc_m1(mxy, mresult, ndsave, numtry, qx)
      else if (nmethd == 2) then
          call fmlerc_m2(mxy, mresult, ndsave, numtry, qx)
      else if (nmethd == 3) then
          call fmlerc_m3(mxy, mresult, ndsave, numtry, qx)
      endif

      return
      end subroutine fmlerc_m

      subroutine fmlerc_m1(mxy, mresult, ndsave, numtry, qx)

!  Method 1 for computing ln(gamma(ma)).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(16), mresult
      integer :: ndsave, numtry
      intent (in) :: numtry, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

!             Method 1.  Use fmerfc.

      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig-1), qx)
      endif
      call fmerfc(mxy(1), mxy(15), qx)
      call fmln(mxy(15), mxy(11), qx)
      qx%ndigli = 0

      qx%namest(qx%ncall) = 'FMLERC'

      call fmeq(mxy(11), mresult, qx)

      return
      end subroutine fmlerc_m1

      subroutine fmlerc_m2(mxy, mresult, ndsave, numtry, qx)

!  Method 2 for computing ln(gamma(ma)).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(16), mresult
      integer :: ndsave, numtry
      intent (in) :: ndsave, numtry
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

!             Method 2.  Use the asymptotic value.

      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig-1), qx)
      endif
      if (mxy(1)%mp(1) == 1) then
          call fmpi(mxy(16), qx)
          qx%ndigpi = 0
          call fmsqrt(mxy(16), mxy(3), qx)
          call fmmpy_r1(mxy(3), mxy(1), qx)
          call fmi2m(1, mxy(2), qx)
          call fmdiv(mxy(2), mxy(3), mxy(11), qx)
          call fmln(mxy(11), mxy(4), qx)
          qx%ndigli = 0
          call fmsqr(mxy(1), mxy(5), qx)
          call fmsub(mxy(4), mxy(5), mxy(11), qx)
      else
          call fmi2m(2, mxy(3), qx)
          call fmln(mxy(3), mxy(11), qx)
          qx%ndigli = 0
      endif

      call fmeq(mxy(11), mresult, qx)

      return
      end subroutine fmlerc_m2

      subroutine fmlerc_m3(mxy, mresult, ndsave, numtry, qx)

!  Method 3 for computing ln(gamma(ma)).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(16), mresult
      integer :: ndsave, numtry
      intent (in) :: ndsave, numtry
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: xe
      integer :: j, jextra, ndsav1, ndsav2, nterms

!             Method 3.  Use the continued fraction expansion.

!             mxy(14) is the current approximation.
!             mxy(11) is the term in the sum, s(k).
!             mxy(9), mxy(10) are the latest denominators, q(k-1) and q(k).

      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig-1), qx)
      endif
      ndsav1 = qx%ndig
      jextra = max(1, int(5.76/qx%alogmb + 1.0))
      if (qx%ndig+jextra > ndsav1) then
          call fmequ_r1(mxy(1), ndsav1, ndsav1+jextra, qx)
      endif
      call fmndig(qx%ndig + jextra, qx)
      call fmi2m(1, mxy(9), qx)
      call fmeq(mxy(1), mxy(10), qx)
      call fmi2m(1, mxy(11), qx)
      call fmi2m(1, mxy(14), qx)
      nterms = int(intmax/10)

!             Method 3 continued fraction loop.

      ndsav2 = qx%ndig
      do j = 1, nterms
         if (mod(j, 2) == 0) then
             call fmcsmpyi(mxy(9), j/2, mxy(7), qx)
             call fmeq(mxy(1), mxy(3), qx)
             call fmcsmpy_r1(mxy(3), mxy(10), qx)
             call fmadd(mxy(3), mxy(7), mxy(8), qx)
         else
             call fmcsmpyi(mxy(9), j, mxy(3), qx)
             call fmcsdivi(mxy(3), 2, mxy(7), qx)
             call fmeq(mxy(1), mxy(3), qx)
             call fmcsmpy_r1(mxy(3), mxy(10), qx)
             call fmadd(mxy(3), mxy(7), mxy(8), qx)
         endif
         call fmeq(mxy(7), mxy(3), qx)
         call fmcsmpy_r1(mxy(3), mxy(11), qx)
         call fmdiv(mxy(3), mxy(8), mxy(11), qx)
         call fmnegate(mxy(11), qx)
         call fmndig(ndsav2, qx)
         call fmcsadd_r1(mxy(14), mxy(11), qx)

!             Check for convergence.

         if (qx%kflag == 1) then
             exit
         endif
         call fmeq(mxy(10), mxy(9), qx)
         call fmeq(mxy(8), mxy(10), qx)
         call fmndig(min(ndsav2, max(qx%ngrd22, ndsav2-int(mxy(14)%mp(2)-mxy(11)%mp(2)))), qx)
         if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         if (j == nterms) then
             call fmunknown(mresult, qx)
             return
         endif
      enddo

      call fmequ_r1(mxy(14), qx%ndig, ndsav1, qx)
      call fmndig(ndsav1, qx)
      call fmpi(mxy(16), qx)
      qx%ndigpi = 0
      call fmsqrt(mxy(16), mxy(3), qx)
      call fmdiv(mxy(14), mxy(3), mxy(11), qx)
      call fmdiv(mxy(11), mxy(1), mxy(12), qx)
      call fmln(mxy(12), mxy(13), qx)
      qx%ndigli = 0
      call fmsqr(mxy(1), mxy(12), qx)
      call fmovun_xe(mxy(12), xe, qx)
      if (xe < qx%mexpov) then
          call fmsub(mxy(13), mxy(12), mxy(11), qx)
      else
          call fmeq(mxy(12), mxy(11), qx)
          call fmnegate(mxy(11), qx)
      endif

      call fmeq(mxy(11), mresult, qx)

      return
      end subroutine fmlerc_m3

      subroutine fmlerc_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = ln(gamma(ma)).

!  kresult = 1 is returned if a special case gives the value of ln(gamma(ma)).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMLERC   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine fmlerc_sc

      subroutine fmlg10(ma, mb, qx)

!  mb = log10(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: mln2, mln3, mln5, mln7
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(6), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmlg10_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call fmlg10_m1(ma, mxy, mresult, ndsave, mln2, mln3, mln5, mln7, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmlg10

      subroutine fmlg10_m1(ma, mxy, mresult, ndsave, mln2, mln3, mln5, mln7, qx)

!  Method 1 for computing log10(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mln2, mln3, mln5, mln7
      type(multi) :: ma, mxy(6), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      type(multi) :: mt
      double precision :: x

      qx%ndigli = 0
      qx%mbsli = 0
      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

      if (ma%mp(2) == 0 .or. ma%mp(2) == 1) then
          x = qx%mbase
          x = x**(int(ma%mp(2))-1)*(dble(ma%mp(3))+dble(ma%mp(4))/x)
      else
          x = 2.0
      endif
      if (x > 0.9 .and. x < 1.1) then
          call fmndig(qx%ndig + 1, qx)
          call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      endif

      call fmln(mxy(1), mt, qx)
      qx%ndigli = 0
      if (qx%mbase /= qx%mbsli .or. qx%ndig > qx%ndigli) then
          call fmlni_m1(10, mxy, mresult, mln2, mln3, mln5, mln7, qx)
          call fmeq(mresult, mxy(2), qx)
      else
          call fmadd(mln2, mln5, mxy(2), qx)
      endif
      call fmdiv(mt, mxy(2), mresult, qx)

      return
      end subroutine fmlg10_m1

      subroutine fmlg10_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = log10(ma).

!  kresult = 1 is returned if a special case gives the value of fmlg10(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(6), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j

      kresult = 0

      qx%namest(qx%ncall) = 'FMLG10   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

      if (mxy(1)%mp(2) == qx%munkno .and. mxy(1)%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine fmlg10_sc

      subroutine fmli(ma, mb, qx)

!  mb = logarithmic integral(ma)

!  Integral from 0 to ma of 1 / ln(t)  dt.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(3), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmli_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call fmli_m1(ma, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmli

      subroutine fmli_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing li(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(3), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: b, xe, xf, ye, ze, zf

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

      if (mxy(1)%mp(3) == 0) then
          call fmi2m(0, mxy(2), qx)
      else if (mxy(1)%mp(2) == qx%mexpun .and. mxy(1)%mp(1) == 1) then
          call fmovun_xexf(mxy(1), xe, xf, qx)
          b = qx%mbase
          ze = xe + log(xf)/log(b)
          zf = log(-ze)/log(b) + log(log(b))/log(b)
          if (ze-zf == ze) then
              ze = xe
              zf = xf
          else
              ye = aint(ze-zf)
              zf = b**(ze-zf - aint(ze-zf))
              ze = ye
          endif
          call fmunderflow(-1, mxy(2), qx)
          mxy(2)%mp(4) = ze
          mxy(2)%mp(5) = -maxint * zf
          qx%kflag = -6
      else if (mxy(1)%mp(2) == qx%mexpov .and. mxy(1)%mp(1) == 1) then
          call fmovun_xexf(mxy(1), xe, xf, qx)
          b = qx%mbase
          ze = xe + log(xf)/log(b)
          zf = log(ze)/log(b) + log(log(b))/log(b)
          if (ze-zf == ze) then
              ze = xe
              zf = xf
          else
              ye = aint(ze-zf) + 1
              zf = b**(ze-zf - aint(ze-zf) - 1)
              ze = ye
          endif
          if (ze <= qx%mxexp0+1) then
              call fmunknown(mxy(2), qx)
              qx%kflag = -4
          else
              call fmoverflow(1, mxy(2), qx)
              mxy(2)%mp(4) = ze
              mxy(2)%mp(5) = -maxint * zf
              qx%kflag = -5
          endif
      else
          call fmln(mxy(1), mxy(3), qx)
          qx%ndigli = 0
          call fmei(mxy(3), mxy(2), qx)
      endif

      call fmeq(mxy(2), mresult, qx)

      return
      end subroutine fmli_m1

      subroutine fmli_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = li(ma).

!  kresult = 1 is returned if a special case gives the value of li(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMLI     '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine fmli_sc

      subroutine fmln(ma, mb, qx)

!  mb = ln(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: mln2, mln3, mln5, mln7
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(6), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmln_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call fmln_m(ma, mxy, mresult, ndsave, mln2, mln3, mln5, mln7, qx)
         qx%ndiglb = 0
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmln

      subroutine fmln_m(ma, mxy, mresult, ndsave, mln2, mln3, mln5, mln7, qx)

!  Method selection for computing ln(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mlbsav
      type(multi) :: mln2, mln3, mln5, mln7
      type(multi) :: ma, mxy(6), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      type(multi) :: mt
      real (kind(1.0d0)) :: ma1
      integer :: ival, j, k2exp, km1, kscale, kwrnsv, last, n1, n3, ndsv, nmethd

      qx%ndiglb = 0
      qx%mbslb = 0
      qx%ndigli = 0
      qx%mbsli = 0
      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      ma1 = ma%mp(2)

!             Check to see if the argument is a small integer.  If so use fmlni.

      km1 = 0
      kwrnsv = qx%kwarn
      qx%kwarn = 0
      call fmm2i(mxy(1), ival, qx)
      qx%kwarn = kwrnsv
      if (qx%kflag == 0 .and. ival < mxbase) then
          call fmlni_m1(ival, mxy, mresult, mln2, mln3, mln5, mln7, qx)
          return
      endif

!             See if the argument can be scaled to a small integer.

      n3 = qx%ndig + 3
      n1 = qx%ndig + 1
      last = n3 - n1 - 1
      do j = 2, n1
         if (mxy(1)%mp(n3-j+1) /= 0) then
             last = n3 - j - 1
             exit
         endif
      enddo
      kscale = int(ma1) - last
      mxy(1)%mp(2) = last
      kwrnsv = qx%kwarn
      qx%kwarn = 0
      call fmm2i(mxy(1), ival, qx)
      qx%kwarn = kwrnsv
      if (qx%kflag == 0 .and. ival < mxbase) then
          call fmlni_m1(ival, mxy, mt, mln2, mln3, mln5, mln7, qx)
          if (ival == 1) km1 = 1
          k2exp = 0

!             Compute ln(mbase**kscale).

          if ((qx%mbslb /= qx%mbase .or. qx%ndiglb < qx%ndig) .and. kscale /= 0) then
              ndsv = qx%ndig
              call fmndig(qx%ndig + 2 + qx%ndig/100, qx)
              call fmlni_m1(int(qx%mbase), mxy, mlbsav, mln2, mln3, mln5, mln7, qx)
              qx%mbslb = qx%mbase
              qx%ndiglb = qx%ndig
              if (abs(mlbsav%mp(2)) > 10) qx%ndiglb = 0
              call fmndig(ndsv, qx)
          endif

          if (kscale /= 0 .and. km1 == 0) then
              call fmmpyi(mlbsav, kscale, mxy(6), qx)
              call fmadd_r2(mt, mxy(6), qx)
          else if (kscale /= 0 .and. km1 == 1) then
              call fmmpyi(mlbsav, kscale, mxy(6), qx)
          else if (kscale == 0 .and. km1 == 0) then
              call fmeq(mt, mxy(6), qx)
          else if (kscale == 0 .and. km1 == 1) then
              call fmi2m(0, mxy(6), qx)
          endif
          call fmeq(mxy(6), mt, qx)

          if (k2exp /= 0) then
              if (qx%mbase /= qx%mbsli .or. qx%ndig > qx%ndigli) then
                  call fmlni_m1(2, mxy, mresult, mln2, mln3, mln5, mln7, qx)
                  call fmeq(mresult, mxy(4), qx)
              endif
              call fmmpyi(mln2, k2exp, mxy(4), qx)
              call fmadd_r1(mt, mxy(4), qx)
          endif
          call fmeq(mt, mresult, qx)
          return
      endif

      nmethd = 1
      if (qx%ndig*qx%dlogmb/qx%dlogtn > 110000) nmethd = 2
      if (nmethd == 1) then
          call fmln_m1(ma, mxy, mresult, ndsave, mln2, mln3, mln5, mln7, mlbsav, qx)
      else
          call fmln_m2(ma, mxy, mresult, ndsave, mln2, mln3, mln5, mln7, mlbsav, qx)
      endif

      return
      end subroutine fmln_m

      subroutine fmln_m1(ma, mxy, mresult, ndsave, mln2, mln3, mln5, mln7, mlbsav, qx)

!  Method 1 for computing ln(ma).

!  Convert ma to a value x close to 1, then use the Taylor series:
!  Ln(x) = 2*( t + t**3/3 + t**5/5 + ...), where t = (x-1)/(x+1).

!  The argument will be moved closer to 1 by removing the base mbase exponent, and then
!  multiplying by powers of 2, 3, 5, 7 before the series is summed.  The series will be
!  added as j2 concurrent series.

      use fmvals_parallel
      implicit none

      type(multi) :: mlbsav
      type(multi) :: mln2, mln3, mln5, mln7
      type(multi) :: ma, mxy(6), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: jexp(8, 4), kexp(4)
      double precision :: y, xv(8)
      integer :: j, j2, k, k2, ke1, kl, ndsav1, nterm
      real :: tj
      type(multi) :: mjsums(ljsums), mt

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      call fmequ(ma, mxy(2), ndsave, qx%ndig, qx)
      mxy(2)%mp(2) = 0
      call fmm2dp(mxy(2), y, qx)
      ke1 = 0
      if (y*qx%mbase < 1 + 1.0d-7) then
          y = y * qx%mbase
          mxy(2)%mp(2) = 1
          ke1 = 1
      endif
      jexp(1, 1:4) = (/    1,   1,  -1,   0 /)
      jexp(2, 1:4) = (/    2,   2,  -1,  -1 /)
      jexp(3, 1:4) = (/    6,   0,  -5,   2 /)
      jexp(4, 1:4) = (/   -5,  -1,  -2,   4 /)
      jexp(5, 1:4) = (/    3, -13,  10,  -2 /)
      jexp(6, 1:4) = (/   51, -13,  -1, -10 /)
      jexp(7, 1:4) = (/    9, -28,  37, -18 /)
      jexp(8, 1:4) = (/ -193,  -6,   5,  68 /)
      kexp(1:4) = 0
      xv(1:8) = (/ 1.2000000000000000d0, 1.0285714285714286d0, 1.0035200000000000d0,  &
                   1.0004166666666667d0, 1.0000406160495965d0, 1.0000070529094230d0,  &
                   1.0000006193987026d0, 1.0000001178537107d0  /)
      do
         if (7*y <= 1 + 1.0d-7) then
             y = 7*y
             kexp(4) = kexp(4) + 1
         else
             exit
         endif
      enddo
      if (5*y <= 1 + 1.0d-7) then
          y = 5*y
          kexp(3) = kexp(3) + 1
      endif
      if (3*y <= 1 + 1.0d-7) then
          y = 3*y
          kexp(2) = kexp(2) + 1
      endif
      if (2*y <= 1 + 1.0d-7) then
          y = 2*y
          kexp(1) = kexp(1) + 1
      endif
      k2 = 5 + sqrt(ndsave*qx%dlogmb/qx%dlogtn)/15
      if (k2 < 5) k2 = 5
      if (k2 > 8) k2 = 8
      do j = 1, k2
         k = -log(y)/log(xv(j))
         y = y * 2.0d0**(k*jexp(j, 1))
         kexp(1) = kexp(1) + k*jexp(j, 1)
         y = y * 3.0d0**(k*jexp(j, 2))
         kexp(2) = kexp(2) + k*jexp(j, 2)
         y = y * 5.0d0**(k*jexp(j, 3))
         kexp(3) = kexp(3) + k*jexp(j, 3)
         y = y * 7.0d0**(k*jexp(j, 4))
         kexp(4) = kexp(4) + k*jexp(j, 4)
      enddo
      call fmi2m(1, mxy(3), qx)
      if (kexp(1) > 0) then
          call fmcsmpyin_r1(mxy(2), 2, kexp(1), qx)
      else if (kexp(1) < 0) then
          call fmcsmpyin_r1(mxy(3), 2, -kexp(1), qx)
      endif
      if (kexp(2) > 0) then
          call fmcsmpyin_r1(mxy(2), 3, kexp(2), qx)
      else if (kexp(2) < 0) then
          call fmcsmpyin_r1(mxy(3), 3, -kexp(2), qx)
      endif
      if (kexp(3) > 0) then
          call fmcsmpyin_r1(mxy(2), 5, kexp(3), qx)
      else if (kexp(3) < 0) then
          call fmcsmpyin_r1(mxy(3), 5, -kexp(3), qx)
      endif
      if (kexp(4) > 0) then
          call fmcsmpyin_r1(mxy(2), 7, kexp(4), qx)
      else if (kexp(4) < 0) then
          call fmcsmpyin_r1(mxy(3), 7, -kexp(4), qx)
      endif
      if (kexp(1) < 0 .or. kexp(2) < 0 .or. kexp(3) < 0 .or. kexp(4) < 0) then
          call fmdiv_r1(mxy(2), mxy(3), qx)
      endif
      call fmi2m(1, mxy(3), qx)
      call fmsub(mxy(2), mxy(3), mxy(4), qx)
      call fmadd(mxy(2), mxy(3), mxy(5), qx)
      call fmdiv(mxy(4), mxy(5), mxy(1), qx)

      tj = 1.25d0 + (ndsave*qx%dlogmb/qx%dlogtn)**0.6d0/18
      j2 = int(tj)
      j2 = max(1, min(j2, ljsums))
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums and reduce ndig while computing each term in the sum as
!             the terms get smaller.

      call fmi2m(1, mxy(2), qx)
      nterm = 1
      do j = 1, j2
         call fmcsdivi(mxy(2), nterm, mjsums(j), qx)
         nterm = nterm + 2
      enddo
      call fmipwr(mxy(1), 2*j2, mxy(3), qx)

      kl = 1
      do while (kl == 1)
         if (nterm > 2*j2+1) then
             call fmcsmpy_r1(mxy(2), mxy(3), qx)
         else
             call fmeq(mxy(3), mxy(2), qx)
         endif
         do j = 1, j2
            call fmcsdivi(mxy(2), nterm, mxy(4), qx)
            call fmndig(ndsav1, qx)
            call fmcsaddnn_r1(mjsums(j), mxy(4), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            call fmndig(ndsav1 - int(mjsums(j)%mp(2)-mxy(4)%mp(2)), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
            nterm = nterm + 2
         enddo
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmcsnsums(j2, mjsums, qx)
      call fmsqr(mxy(1), mxy(4), qx)
      call fmeq(mjsums(j2), mxy(3), qx)
      do j = 2, j2
         call fmcsmpy_r1(mxy(3), mxy(4), qx)
         call fmadd_r1(mxy(3), mjsums(j2-j+1), qx)
      enddo
      call fmmpy(mxy(3), mxy(1), mxy(6), qx)
      call fmmpyi_r1(mxy(6), 2, qx)
      k = ma%mp(2) - ke1
      ndsav1 = qx%ndig
      call fmndig(qx%ndig + qx%ngrd21, qx)
      call fmequ(mxy(6), mt, ndsav1, qx%ndig, qx)
      if (k /= 0) then
          if (qx%ndiglb >= qx%ndig .and. qx%mbase == qx%mbslb) then
              call fmmpyi(mlbsav, k, mxy(5), qx)
          else
              call fmlni_m1(int(qx%mbase), mxy, mlbsav, mln2, mln3, mln5, mln7, qx)
              qx%mbslb = qx%mbase
              qx%ndiglb = qx%ndig
              call fmmpyi(mlbsav, k, mxy(5), qx)
          endif
          call fmadd_r1(mt, mxy(5), qx)
      endif
      if (qx%ndigli < qx%ndig .or. qx%mbase /= qx%mbsli) then
          call fmlni_m1(210, mxy, mresult, mln2, mln3, mln5, mln7, qx)
          call fmeq(mresult, mxy(2), qx)
      endif
      if (kexp(1) /= 0) then
          call fmcsmpyi(mln2, kexp(1), mxy(3), qx)
          call fmsub_r1(mt, mxy(3), qx)
      endif
      if (kexp(2) /= 0) then
          call fmcsmpyi(mln3, kexp(2), mxy(3), qx)
          call fmsub_r1(mt, mxy(3), qx)
      endif
      if (kexp(3) /= 0) then
          call fmcsmpyi(mln5, kexp(3), mxy(3), qx)
          call fmsub_r1(mt, mxy(3), qx)
      endif
      if (kexp(4) /= 0) then
          call fmcsmpyi(mln7, kexp(4), mxy(3), qx)
          call fmsub_r1(mt, mxy(3), qx)
      endif
      call fmequ(mt, mresult, qx%ndig, ndsav1, qx)
      call fmndig(ndsav1, qx)

      return
      end subroutine fmln_m1

      subroutine fmln_m2(ma, mxy, mresult, ndsave, mln2, mln3, mln5, mln7, mlbsav, qx)

!  Method 2 for computing ln(ma).

!  At high precision, use arithmetic-geometric mean iteration.

      use fmvals_parallel
      implicit none

      type(multi) :: mlbsav
      type(multi) :: mln2, mln3, mln5, mln7
      type(multi) :: ma, mxy(6), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      type(multi) :: mt
      double precision :: y
      integer :: k, m

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      mxy(1)%mp(2) = 0
      call fmm2dp(mxy(1), y, qx)
      m = max(1, int((qx%ndig*qx%dlogmb/36 - log(y))/qx%dlogtw + 1))
      call fmcsmpyin_r1(mxy(1), 2, m, qx)
      call fmi2m(1, mxy(2), qx)
      call fmdiv(mxy(2), mxy(1), mxy(4), qx)
      call fmeq(mxy(4), mxy(2), qx)
      call fmsqr(mxy(2), mxy(5), qx)
      call fmsqr(mxy(5), mxy(3), qx)
      call fmsqr(mxy(3), mxy(5), qx)
      call fmmpy(mxy(4), mxy(5), mxy(6), qx)
      call fmadd_r1(mxy(2), mxy(6), qx)
      call fmsqr_r1(mxy(5), qx)
      call fmadd_r1(mxy(3), mxy(5), qx)
      call fmmpy_r1(mxy(5), mxy(6), qx)
      call fmadd_r1(mxy(2), mxy(5), qx)
      call fmmpyi_r1(mxy(2), 2, qx)
      call fmmpyi_r1(mxy(3), 2, qx)
      call fmi2m(1, mxy(5), qx)
      call fmadd_r1(mxy(3), mxy(5), qx)
      call fmmpy(mxy(2), mxy(3), mxy(5), qx)
      call fmsqr_r1(mxy(2), qx)
      call fmsqr_r1(mxy(3), qx)
      call fmadd(mxy(2), mxy(3), mxy(4), qx)
      call fmdivi(mxy(4), 2, mxy(2), qx)
      call fmeq(mxy(5), mxy(3), qx)
      do
         call fmsub(mxy(3), mxy(2), mxy(4), qx)
         if (mxy(4)%mp(3) == 0 .or.  &
             mxy(4)%mp(2) - max(mxy(2)%mp(2), mxy(3)%mp(2)) <= -qx%ndig+1) exit
         call fmdivi_r1(mxy(4), 2, qx)
         call fmmpy(mxy(2), mxy(3), mxy(5), qx)
         call fmsqrt(mxy(5), mxy(3), qx)
         call fmadd_r1(mxy(2), mxy(4), qx)
      enddo

      call fmpi(mxy(1), qx)
      qx%ndigpi = 0
      call fmmpyi_r1(mxy(2), 4, qx)
      call fmdiv(mxy(1), mxy(2), mt, qx)
      if (qx%ndigli >= qx%ndig .and. qx%mbase == qx%mbsli) then
          call fmmpyi(mln2, m, mxy(3), qx)
      else
          call fmlni_m1(2, mxy, mresult, mln2, mln3, mln5, mln7, qx)
          call fmeq(mresult, mxy(2), qx)
          call fmmpyi(mxy(2), m, mxy(3), qx)
      endif
      call fmsub_r1(mt, mxy(3), qx)
      k = ma%mp(2)
      if (k /= 0) then
          if (qx%ndiglb >= qx%ndig .and. qx%mbase == qx%mbslb) then
              call fmmpyi(mlbsav, k, mxy(5), qx)
          else
              call fmlni_m1(int(qx%mbase), mxy, mlbsav, mln2, mln3, mln5, mln7, qx)
              qx%mbslb = qx%mbase
              qx%ndiglb = qx%ndig
              call fmmpyi(mlbsav, k, mxy(5), qx)
          endif
          call fmadd_r1(mt, mxy(5), qx)
      endif
      call fmeq(mt, mresult, qx)

      return
      end subroutine fmln_m2

      subroutine fmln_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = ln(ma).

!  kresult = 1 is returned if a special case gives the value of ln(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(6), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      double precision :: xe, xf, ye, yf, ze
      integer :: j

      kresult = 0

      qx%namest(qx%ncall) = 'FMLN     '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

      if ((mxy(1)%mp(2) == qx%munkno .and. mxy(1)%mp(5) >= 0) .or.  &
          mxy(1)%mp(1) < 0 .or. mxy(1)%mp(3) == 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (abs(mxy(1)%mp(2)) >= qx%mexpov) then
          call fmunknown(mresult, qx)
          xe = abs(mxy(1)%mp(4))
          xf = -mxy(1)%mp(5)/maxint
          if (mxy(1)%mp(4) <= 0) xf = 1/xf

          if (xe > huge(1.0d0)/qx%dlogmb) then
              ze = huge(1.0d0)
          else
              ze = xe*qx%dlogmb + log(xf)
          endif

          ye = floor(log(ze)/qx%dlogmb) + 1
          yf = ze / qx%mbase**ye

          mresult%mp(4) = ye
          mresult%mp(5) = -yf*maxint
          if (mxy(1)%mp(4) <= 0) mresult%mp(1) = -1
          kresult = 1
          return
      endif

      return
      end subroutine fmln_sc

      subroutine fmlngm(ma, mb, qx)

!  mb = ln(gamma(ma))

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(15), mresult, mretry

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmlngm_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      n_acc = nint(qx%ndig*qx%alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmlngm_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry, qx)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmlngm

      subroutine fmlngm_c(ndig_c, mbase_c, c, qx)

!  Initialize the constants used in the log gamma polynomial.

      use fmvals_parallel
      implicit none

      type(multi) :: c(0:196)
      integer :: ndig_c
      real (kind(1.0d0)) :: mbase_c
      intent (inout) :: c, ndig_c, mbase_c
      integer :: ndsave
      character(220) :: st
      type(fm_settings) :: qx

      ndsave = qx%ndig
      call fmndig(max(qx%ndig, nint(210*qx%dlogtn/qx%dlogmb)), qx)
      ndig_c = qx%ndig
      mbase_c = qx%mbase

      st = " 6.931471805599453094172321214581765680755001343602552541206800094" //  &
           "933936219696947156058633269964186875420014810205706857336855202357" //  &
           "58130557032670751635075961930727570828371435190307038623891673471123350M-1"
      call fmst2m(st, c(0), qx)
      st = " 9.227843350984671393934879099175975689578406640600764011942327651" //  &
           "151322732223353290630529367082532504853685527501929175190394959855" //  &
           "13457163775826002355076463746499666257062662262326057207404741752905084M-1"
      call fmst2m(st, c(1), qx)
      st = " 1.974670334241132182362075833230125946094749506033992188677791146" //  &
           "850037352016004369168144503098793526520021594811685953398143623435" //  &
           "02503893967551473165433138415866654683881302547625503436070027398405779M-1"
      call fmst2m(st, c(2), qx)
      st = " 2.568563438653142846657938717048333025499543078016629393075718511" //  &
           "394606859543769672881862453644508604873305259842023980616399866622" //  &
           "44277379254656124026333871513139276497866889063971918407474980813205213M-2"
      call fmst2m(st, c(3), qx)
      st = " 4.955808427784547879000924135291975693687737979681726920744053861" //  &
           "030154046742211639227408985424979308247703477010685603646017893642" //  &
           "51133732050087867905480177194587022770925733154718370654381840105887655M-3"
      call fmst2m(st, c(4), qx)
      st = " 1.135551028673985266273097291406833611416183900382562394838535580" //  &
           "760717957256296912008621311426667275924068293311321808560192355831" //  &
           "19416836702214436017528973257267436070719672792473025777796267055355048M-3"
      call fmst2m(st, c(5), qx)
      st = " 2.863436640748566190863216318200879836362483388089269737347773340" //  &
           "553638169929829804623296564225284217131985270424264778996969080555" //  &
           "16975632152723012109455292088401608926031282713256898710394755277209657M-4"
      call fmst2m(st, c(6), qx)
      st = " 7.668248313183240568536426425667994283765150931981520246901951022" //  &
           "878261676510504944242413055018913842306480735586784104096820283433" //  &
           "36343308283287191406517315813519407491295119077092395710810995273468308M-5"
      call fmst2m(st, c(7), qx)
      st = " 2.138827474304242233565481358155815737009883123125254113877533157" //  &
           "286907184360179941090379654649639056545605878533625329428744350917" //  &
           "29963707838227249505773740942777859121824166285189382035452217278554155M-5"
      call fmst2m(st, c(8), qx)
      st = " 6.140869564690490872529914712451165067316821654306283177401767753" //  &
           "894821139822105599229903018842906378733862871895584602819330080270" //  &
           "01700768138875158345454772076408505044108823934202891440461609291305270M-6"
      call fmst2m(st, c(9), qx)
      st = " 1.801262781808533714595890031901700601953156447751725778899463629" //  &
           "146515191295439704196861038565275400689206320530767736809020353629" //  &
           "38073190695949842873953621603334722352596732052178932328832066543779584M-6"
      call fmst2m(st, c(10), qx)
      st = " 5.370321926785962456620478609033153278577962007833744674032818230" //  &
           "963452927104275083493657782390759550975407401180548454361763677022" //  &
           "25719502127813332819843513403345897099400330508911246024488125358988974M-7"
      call fmst2m(st, c(11), qx)
      st = " 1.621606923373582198331706449725800346740381669503777534126777710" //  &
           "016401617427540869007126583916228785817454388595224584374431558565" //  &
           "62424003947302186656188945000933064454593249101343833268069567881424866M-7"
      call fmst2m(st, c(12), qx)
      st = " 4.946423680685744244896356595351648270045350075731820789781699205" //  &
           "590998801613945328568871293350300180372347783056466467421940336962" //  &
           "37993051766799459115354359781619794227922798691721786471256812355243228M-8"
      call fmst2m(st, c(13), qx)
      st = " 1.521277205034494703893608109526767726401208246782019680016091878" //  &
           "150165553006261855592657131910806289218694348060771816544039319519" //  &
           "70268151503584997891542218258262605500864512242956007183617857332741602M-8"
      call fmst2m(st, c(14), qx)
      st = " 4.710545468032903448567376337505841863247123878500437995526222151" //  &
           "143756151971538155623134503232957797896283285550201985050591879362" //  &
           "14529603180002288823222154049517099193894892610640999441314930078235979M-9"
      call fmst2m(st, c(15), qx)
      st = " 1.466896634491983285717977295126452336811904470697069075224299192" //  &
           "939247071986642850302895153896641951172329934777380990036068940704" //  &
           "92049327640255496401589822485890032872392277699930611719523121420745147M-9"
      call fmst2m(st, c(16), qx)
      st = " 4.590062735154278588407978252478287205347213340644341084689962143" //  &
           "111930858436518669786421571299766271527706531603537599776303515851" //  &
           "07346286911988982005532291493494947163957826550954358278107733999478261M-10"
      call fmst2m(st, c(17), qx)
      st = " 1.442221874911031367580345522072474831788307406190652461104238910" //  &
           "857027803132223315927216471971838450273509423200923289440756059767" //  &
           "68857423403274844425475990232160708382227977333807182882605816718263351M-10"
      call fmst2m(st, c(18), qx)
      st = " 4.547809165468029773462079480806624058657045422294384456641178682" //  &
           "659691101645601195358296330035349908208769392426188702234370516180" //  &
           "56888377164494448967006811680025457321926050295945478985302205704218490M-11"
      call fmst2m(st, c(19), qx)
      st = " 1.438587332730565760193417246729718970937052978750282449255687568" //  &
           "655719501289180489881937394774257940434077254947095313349728878573" //  &
           "86843008158160916187514601728862636178280076324418505631445853717950171M-11"
      call fmst2m(st, c(20), qx)
      st = " 4.563265937212529367600208240284116509275473219057499398885563766" //  &
           "090388563517935169737964577745895815190180995118452252225828163120" //  &
           "99722426850021624306978846433211406278468453662456948824141382999031282M-12"
      call fmst2m(st, c(21), qx)
      st = " 1.451073916840454711281216045224320082808166284993163778021566315" //  &
           "255587037332552553079272066121649499425851990060321384124955433677" //  &
           "67207993278060823840271886615031403999360286605743411932260491743002791M-12"
      call fmst2m(st, c(22), qx)
      st = " 4.624528056444812082051687967994458694688921677653576433580975534" //  &
           "968450053554049283580808625060631085218986361103614972923204710045" //  &
           "87054803107018718005909662543849301887854984204280816281128477629296891M-13"
      call fmst2m(st, c(23), qx)
      st = " 1.476781612022755183419973250511459966182209498276769571800718539" //  &
           "731445227020086180343751505787486916705816774093130509272233480605" //  &
           "44047487934404934553435264532664986314948239961478420907068538648968405M-13"
      call fmst2m(st, c(24), qx)
      st = " 4.724507827870744254820277464047378923678173249594725356053537843" //  &
           "069856328276686251584801735153843799291487544822727471278651677292" //  &
           "03640042606725210618105758740751314683086483423378587429797730710810703M-14"
      call fmst2m(st, c(25), qx)
      st = " 1.513978913019171763487041148572556877568791963643984495346043449" //  &
           "018701962532639151560210080671482947559816365848586253646530778070" //  &
           "18537123717716793256274213468254921216965019092087180696648092689644960M-14"
      call fmst2m(st, c(26), qx)
      st = " 4.858996725976554852006318671090915519699354289999749614013042503" //  &
           "935984106218549522233834213516072290014623125419558504921174284920" //  &
           "78107160688407534237846157628451620609106027079137343790816294845243811M-15"
      call fmst2m(st, c(27), qx)
      st = " 1.561654519392582828714942943686889037831993268563190525220343034" //  &
           "296584463347814354645233174014087011036651133377861482059644157593" //  &
           "18350440790655464091846868252936233878726656395056209922850191735361446M-15"
      call fmst2m(st, c(28), qx)
      st = " 5.025614514474191003429454120021263907058345057163756484675204032" //  &
           "160626854269473972760278335161149373855516115547324556053250680761" //  &
           "35960353957624688528998376864715123324194768194244608331227956016708835M-16"
      call fmst2m(st, c(29), qx)
      st = " 1.619268063222415588245007073271189318378938728336204453480653557" //  &
           "646832121167874868009309695437374462682430335955717169955384406157" //  &
           "35461655626485084754177259606520323581270018242949002547200222070367875M-16"
      call fmst2m(st, c(30), qx)
      st = " 5.223211739191891688145554861633126404312733249590231268939276354" //  &
           "483256718224458681957003067572062210319658187678206505904762786890" //  &
           "39036962584739426283467796928036615339321696596679043636072535930177735M-17"
      call fmst2m(st, c(31), qx)
      st = " 1.686605565375918423742481404695259319639157222117507057462225591" //  &
           "850533083720983505743619854637504171953994487105802289063236646168" //  &
           "31565771482245546699030298377683203899275714959867483319947682463166471M-17"
      call fmst2m(st, c(32), qx)
      st = " 5.451517284342611284349867604595522641598896765349022422637246200" //  &
           "744471171937423465939660935482207447703449379192989322923063888266" //  &
           "31229372543901089934035916918836653287495719335136501890625959613216773M-18"
      call fmst2m(st, c(33), qx)
      st = " 1.763692929460761010585031266299209488371094586913873180122443276" //  &
           "358212007822366334544290589814884405499150265809186554929224793099" //  &
           "67159580614375385516830687382686358909934655641565142758100304193688125M-18"
      call fmst2m(st, c(34), qx)
      st = " 5.710924940930289429222525846887709139266580644631501378754425400" //  &
           "402344096734033498368417722870024289649356569956325790061028789490" //  &
           "90201209337135311180824855625236387835485476090642686407138148182122938M-19"
      call fmst2m(st, c(35), qx)
      st = " 1.850743092341469168679255116939946915034455019205428394047707184" //  &
           "730616709166372869327273711967997594444383081358747754694208065117" //  &
           "59243078812287887751986055564202797220696526499221359781019466183552083M-19"
      call fmst2m(st, c(36), qx)
      st = " 6.002362311111352855438751511526624123122881372177829574698482082" //  &
           "268472189497794035844163044963208202280717860883655584808569201908" //  &
           "84840540664364095292197489013673097320200190188150543497148096517991518M-20"
      call fmst2m(st, c(37), qx)
      st = " 1.948123521680466000278613877664857969433940710389346300112405920" //  &
           "570813255255307791273062459813736293577657819726099571791897412896" //  &
           "04499052083706223596278073126974722712855926508631000226750654451336437M-20"
      call fmst2m(st, c(38), qx)
      st = " 6.327210499275762922454617564886905374837540270134647521961777337" //  &
           "241208973850468966202699863294902233722101674486074157046009900783" //  &
           "94943168708628546063295850691161365924829349560770067069849204243333875M-21"
      call fmst2m(st, c(39), qx)
      st = " 2.056336517258456819404872718846500024771970712636992752800634217" //  &
           "390177588265180513218328462256818578504975537617618012477658735253" //  &
           "91357901005319898451317799466679533736509835947206121997945730419581125M-21"
      call fmst2m(st, c(40), qx)
      st = " 6.687256410663997968707038300952324368643567824691228269512829884" //  &
           "600241200120276396209386234811912763595929600746527477568692380093" //  &
           "65846941054535500737409129245379236794232295378392955072876104303576437M-22"
      call fmst2m(st, c(41), qx)
      st = " 2.176007902867600569564968838424519571170445852508011400529276121" //  &
           "985778848606677081067574991228552820893084306450020295730062213612" //  &
           "47319852047491615671942139635029927212587004293525094112235574131058548M-22"
      call fmst2m(st, c(42), qx)
      st = " 7.084666872547745583697885218008349498259999765144828626416539742" //  &
           "112817790036483006355449086393842354631309401157315763399808881211" //  &
           "63034428362049804231045013084677403365104232875460124915055150115352532M-23"
      call fmst2m(st, c(43), qx)
      st = " 2.307881457325186109702251558024026338622462538196464637417250145" //  &
           "271014677258724350821337105472668901649544195158107332539530013289" //  &
           "58690754615380156771062458199324618311119940721724411263802909784747175M-23"
      call fmst2m(st, c(44), qx)
      st = " 7.521978024882350363251147127637517006885196169534728483482110729" //  &
           "767330760893859561440994301232670866451144204592673539313561020703" //  &
           "16229680624073031879503528876975581601231458676853213367966509358616500M-24"
      call fmst2m(st, c(45), qx)
      st = " 2.452817457661126560656022558232578383346781683732614004543641047" //  &
           "950608697083659342320485224577786541964544409466877827518882696166" //  &
           "77785583812635059733861275531662340097681814492066607106278651398864552M-24"
      call fmst2m(st, c(46), qx)
      st = " 8.002095926418321660462882983562136934827167736984869734245484961" //  &
           "990362339894468819446499270621544724743989273983343985659243797090" //  &
           "02617723679997529884675116233201816776147675793642923747702696525736417M-25"
      call fmst2m(st, c(47), qx)
      st = " 2.611794321654760040868482915030344896471378127607902926579083608" //  &
           "600355795254414772701179436107007717915331779124504018381582369712" //  &
           "35303338971473297210813756554582658474866145972030534849911654352767572M-25"
      call fmst2m(st, c(48), qx)
      st = " 8.528305842439874174397891979909201174136636691345390271985961340" //  &
           "951635472717713994160270983358301811012414732109357429143927205677" //  &
           "24451493207732247380061110874133984404716199859823728402868897884262789M-26"
      call fmst2m(st, c(49), qx)
      st = " 2.785912715941407608332964765121774292928933289953979801676819715" //  &
           "042211815722358756877838540023159292634878096952517082899902453482" //  &
           "75453420374439979087786662261117071847545271472089893478013180932399900M-26"
      call fmst2m(st, c(50), qx)
      st = " 9.104288632359302486087921738156084451459177031330022615977426375" //  &
           "389281113948847333526780396722062239770555955153203912544147152689" //  &
           "10635505098052873178484650793531962248685195239569728214014565219560910M-27"
      call fmst2m(st, c(51), qx)
      st = " 2.976401736830878380813487190839719864305643062243346972314080928" //  &
           "571659774700309771395429511816849731798335554291299072632159561785" //  &
           "13853498257646786277128193242849488156599291079190249617494763928122532M-27"
      call fmst2m(st, c(52), qx)
      st = " 9.734143269753073619444573395909866046087281775327043563820191216" //  &
           "592074666762884461637185638436344417629043795119832288445119716594" //  &
           "54681757554722607199255640890946515559342596226071714786376672991314824M-28"
      call fmst2m(st, c(53), qx)
      st = " 3.184626928899218981583942072541398262319779552845939844429551688" //  &
           "572650417481499150961066174605543822869303332888433674715027707880" //  &
           "04490731942311456494319892555319423931924782646792891555889559629511546M-28"
      call fmst2m(st, c(54), qx)
      st = " 1.042241493677369606594579977699800680670958579629702706075164525" //  &
           "911994152904008645633144958538688068689955477642378460321912420061" //  &
           "44713093711611925694102923080704525452321573189336778639403115171327402M-28"
      call fmst2m(st, c(55), qx)
      st = " 3.412100013470891170294585716908258368140834550044525411190398041" //  &
           "104754921079862028936399162559763428726672165337980689582820113040" //  &
           "13416198464826440959995204574451765227502181269455928284526174312187664M-29"
      call fmst2m(st, c(56), qx)
      st = " 1.117412841751556843302074248615568735696721287113186281328504084" //  &
           "312562222725968138902580374246217663276066641488490501477225640253" //  &
           "42579986440180416098324496187285052304475776686406646945052809161071102M-29"
      call fmst2m(st, c(57), qx)
      st = " 3.660490274490043678026226644620183224238038689661082986523077162" //  &
           "981414308819425679643969633533180026092880760915904811622562886923" //  &
           "84487396264603185012812742600008480127678888705848700357490206046685979M-30"
      call fmst2m(st, c(58), qx)
      st = " 1.199482671814381161791341850793296252666044625258418739613110049" //  &
           "104551626086380287997089537812232630867438710978470875637869385419" //  &
           "01607003246251775392139826953129400440619709892748008039595593739769704M-30"
      call fmst2m(st, c(59), qx)
      st = " 3.931637604707211006390296608348190956772148951812063256727344243" //  &
           "900822542438555764328768554173091304365555553142603137727525766441" //  &
           "84525659723982712681986023184076666876842449810082867584381453291908627M-31"
      call fmst2m(st, c(60), qx)
      st = " 1.289061499462497744696303533633690434193534414239284689686070597" //  &
           "676814880055275326028949838642762828605994974529472129232550363697" //  &
           "60950396038294052993668381573708577221742561680239596349647149571718672M-31"
      call fmst2m(st, c(61), qx)
      st = " 4.227567257903962351790508597715893632841769835136110706800940837" //  &
           "829652461572432184043919015812076564236545988931174492991859433101" //  &
           "25778000859246543191517786955778130308647637177926547762610318839215217M-32"
      call fmst2m(st, c(62), qx)
      st = " 1.386820999018780266062944049316369528834057757206382128765313047" //  &
           "270244006158501294298057326510552601141951742736581362353221200763" //  &
           "47128739854666116108186922912060771673278920840786086509429347218298547M-32"
      call fmst2m(st, c(63), qx)
      st = " 4.550506387724437506082055927268146785006102873281969302732936243" //  &
           "298895572505202160358438794407807710437237187496655791039130216893" //  &
           "87511924875421792179416180376854086009363053011270507639350841775560466M-33"
      call fmst2m(st, c(64), qx)
      st = " 1.493499528613739965372638972965391238482547633295265869054828367" //  &
           "829416466398480374395870941759362578697731625235707888992530344564" //  &
           "64118616870137110287959590352137938213456367349222761768780656871967062M-33"
      call fmst2m(st, c(65), qx)
      st = " 4.902902483647573629190444872668433339026722693539103782664050983" //  &
           "225694025564768841074155141457059295428474046880275907189034299237" //  &
           "32944103681204447082846734232378539796234753927604216121433267289535418M-34"
      call fmst2m(st, c(66), qx)
      st = " 1.609908275928169570082165607481456370083831087969406562557256167" //  &
           "364188362846846549047875066952892162692919458759129310778349489953" //  &
           "22770448873819282967830858947780630728913545194644474976588962028982890M-34"
      call fmst2m(st, c(67), qx)
      st = " 5.287443841783967253336743861164853484418810262590989794938834387" //  &
           "073299404536655202675616502143848847208164288382903044431016858516" //  &
           "20009538336266282148044005430788026679223320414557498337146361309107021M-35"
      call fmst2m(st, c(68), qx)
      st = " 1.736938072243109805185530725881959995611305822994512775248040487" //  &
           "238177289693647144646295113799732566680032754548503116064306224752" //  &
           "78198414114124592660116717229603109916607439068859873993478598764324167M-35"
      call fmst2m(st, c(69), qx)
      st = " 5.707082233953717693925573957068774870416069447922801957662691273" //  &
           "270987710445603289113054181853887859043710418144298938936434365836" //  &
           "22910905014974542359781276508954019188261527426571788239315967868621528M-36"
      call fmst2m(st, c(70), qx)
      st = " 1.875566930504197126372674019737550486762741857855257836323427280" //  &
           "225964790637523226088657691476666774290875901414134481518247331060" //  &
           "71906874659900660807946217987043810912477339050139457949133330400430348M-36"
      call fmst2m(st, c(71), qx)
      st = " 6.165057963933168318023358517808802281756068067015463002715232153" //  &
           "371564234012532194529099415076087246371078651694171463516031915534" //  &
           "01898954460353148685542639895937235904606585101085654511370630295486436M-37"
      call fmst2m(st, c(72), qx)
      st = " 2.026868371192165401197185010283739193718905421948964225522412850" //  &
           "262737204848695188406921800082238582127540011428039129914658458542" //  &
           "37634642867581786423872725394317163245280102057930986208119247853710652M-37"
      call fmst2m(st, c(73), qx)
      st = " 6.664927525630725280315186707639828112376671188813408419458083523" //  &
           "173661970136566062651079390703015968881216092673504456192083877599" //  &
           "15804352132821230683566017780795660498858012885579266098347848714173428M-38"
      call fmst2m(st, c(74), qx)
      st = " 2.192020608118261066539037933528189571558724587838583580744609163" //  &
           "952034074131032109073883254528947795371825396404707207594960566130" //  &
           "08388120561413633077336889145268058079508281341166298919160705693687869M-38"
      call fmst2m(st, c(75), qx)
      st = " 7.210594104883918757684569353059178987815466143353338512729476387" //  &
           "590176795023385801954403484227849398454243048187188857331730164109" //  &
           "61130821394037069074892323683471141755158288684895958165035966426280590M-39"
      call fmst2m(st, c(76), qx)
      st = " 2.372316675010334396327093341566291045560598544381746314200798914" //  &
           "361335388290174563770200693760939384221618459565684611293948349762" //  &
           "99760715272696457406804603245507893941691344795060823654575302742922341M-39"
      call fmst2m(st, c(77), qx)
      st = " 7.806341195078978788896796569353844545546683670636287097360101000" //  &
           "674819867286255396945996712341079701193140494784764939652507657527" //  &
           "10776509577749635871445825212032538401033636476215858432876024174293608M-40"
      call fmst2m(st, c(78), qx)
      st = " 2.569175583075068496597802624641121843008905917144485747977702000" //  &
           "084716234785945953181138133105853830584529894491272387561559175918" //  &
           "06056635101515773378678277304459406269213364274389438074596955963853941M-40"
      call fmst2m(st, c(79), qx)
      st = " 8.456869627337005555483543945000411129981141780087868584229158532" //  &
           "975156474362982393176600086105992624536940685475408780825634971862" //  &
           "82928746682884903136048829786952212289839035702247341347744500864695940M-41"
      call fmst2m(st, c(80), qx)
      st = " 2.784154609752488682347830682317399839437808496760216533359957844" //  &
           "108419936184123983123382869988781032193042150722634481595940148079" //  &
           "47471887024692990616525022991390619756225607915282611367773077871045722M-41"
      call fmst2m(st, c(81), qx)
      st = " 9.167338349011185351110270732877594395344097568799016206592150045" //  &
           "211148681681966966935859814202597754161577071431235188923674247559" //  &
           "93097788462831296346214350780525347998671878506396254329112437194116937M-42"
      call fmst2m(st, c(82), qx)
      st = " 3.018962829751912207860422524685002365325324396585948666388970238" //  &
           "468900826307200635678324473325455973126327818463443937367696783407" //  &
           "31216822788529908321030119923263022821575928202721712476375757572174960M-42"
      call fmst2m(st, c(83), qx)
      st = " 9.943409320108569385064969631771335447816687861933253786118347289" //  &
           "942417796521205611575152291429262471820315825809582098019324351274" //  &
           "19736007449168383766428225696036997597572676990996005739875078089934258M-43"
      call fmst2m(st, c(84), qx)
      st = " 3.275476011303678103893551709440913333007415558028940493123054436" //  &
           "102576111138063293549771997379461070822607505834700351586923416924" //  &
           "36130515829060972565436000080016114747837549174742969323583514548979337M-43"
      call fmst2m(st, c(85), qx)
      st = " 1.079129693640085894851434181915227380977317782277815512357487683" //  &
           "235378082315776477576402633427103515916665364561427248912637998286" //  &
           "84497336603622824659763899982809691142662878118295489894583048485526949M-43"
      call fmst2m(st, c(86), qx)
      st = " 3.555753013510719060083393999120543994047683529242126292544972222" //  &
           "356576357296720319402739291176562890757829588273748247638519856640" //  &
           "67480610895714757344602846046498898788815371622608783151322531494411842M-44"
      call fmst2m(st, c(87), qx)
      st = " 1.171782243084804960250703836375832017652851729860152530408648875" //  &
           "579920584019031061094655011368498851035103058003948560022564877979" //  &
           "17046691205570131651535433024120306105982182247803947139577240760760240M-44"
      call fmst2m(st, c(88), qx)
      st = " 3.862053834876472821052586382551496075098455346933359196501245526" //  &
           "180729685642432233621061970152222441386142907366726076208958805328" //  &
           "70627198276478969445218445704378235779473329084661077747371015095013204M-45"
      call fmst2m(st, c(89), qx)
      st = " 1.273047375197605743053349834215496117644063043473174035166207181" //  &
           "768692059655110422250456339545311971995535730478050915338536261677" //  &
           "65444071293612365602178273688293636174364964871538328370023554265881805M-45"
      call fmst2m(st, c(90), qx)
      st = " 4.196859478667449972989243439715623246016537566511261080114559563" //  &
           "758135987775813449384022624930316510736358259866183402630340459291" //  &
           "72668526906989173105067164347823743598675043393233726870416684054894389M-46"
      call fmst2m(st, c(91), qx)
      st = " 1.383747146950471434825293091024083280747013661478053604841911598" //  &
           "022310276318757265593640560735257184999994184693906229160627176389" //  &
           "15615636692838842344470182112269725385554047172321124664394879685510285M-46"
      call fmst2m(st, c(92), qx)
      st = " 4.562893817897541724781950430442496378260377512288497109803666040" //  &
           "621854629198431249084998659248405128970881921614143709856471314566" //  &
           "71187340235712918767373708561614114398918238461996856137728111624669887M-47"
      call fmst2m(st, c(93), qx)
      st = " 1.504784131433391793257248428485220036318516611757628814861273953" //  &
           "241786001999746507693533747202375916340889614020197821617964401281" //  &
           "09223232430673952549932990159444752780504141754928914375319317506618075M-47"
      call fmst2m(st, c(94), qx)
      st = " 4.963147661567547539987958807734897162902530398116312148944960055" //  &
           "796268377992054321453624007551095855206124470724586679336263613115" //  &
           "89091300344790164050318056261092913116282166570730942288235067198317928M-48"
      call fmst2m(st, c(95), qx)
      st = " 1.637149402252630927456890226306016168030553715912510338166421018" //  &
           "082250171874970269061229738963393420354696075864382273796383465054" //  &
           "54500820509537840793087307985392209620656037379007014938893681782187286M-48"
      call fmst2m(st, c(96), qx)
      st = " 5.400905244543393186874620589431418037639831941879628434368248998" //  &
           "722906347036053715166862260092049668825631280975790017953688626636" //  &
           "15617148734065300820447033765217546328421226646834925099741473350545005M-49"
      call fmst2m(st, c(97), qx)
      st = " 1.781931322178944118647377674747852837095476406297808108639777839" //  &
           "710695191748931947375083891115191186633327477558489708276330078077" //  &
           "84355945700557484952518727190790584478520941307748997078811897348262566M-49"
      call fmst2m(st, c(98), qx)
      st = " 5.879773386313522948360905422632431077145168395771420120384935880" //  &
           "807587039058575601777312600437920559716301465154041152414856698220" //  &
           "03215044402130085493835602372831521053966369492752843371900098859590805M-50"
      call fmst2m(st, c(99), qx)
      st = " 1.940325217483255139116418908036918257576300407306275798031334364" //  &
           "409600080862034828483316076995017274377332356098893076821893973234" //  &
           "40382503373462356947628021148992374363794778068565614630007284818985556M-50"
      call fmst2m(st, c(100), qx)
      st = " 6.403713589053133873710962618711106281414140108122214547412024301" //  &
           "692917083153216025874647060197659674432573844849077628829246217574" //  &
           "60249742706649007645817489620506941120553080709097100788465375868770515M-51"
      call fmst2m(st, c(101), qx)
      st = " 2.113644027759240612416047225977851974737748960538792675174058961" //  &
           "161021976645079782965719680309463063367873086114357869089879642560" //  &
           "91741774488093918815994311848793042306225840389086585033999559719325383M-51"
      call fmst2m(st, c(102), qx)
      st = " 6.977077373185528123141201643198765846940778946562652437177053180" //  &
           "068202610894634761485494475059094517798144344611412525007119040744" //  &
           "47619138364742657951321893292966244857904586187576743960389378098756527M-52"
      call fmst2m(st, c(103), qx)
      st = " 2.303330030250272718045226178470266630636882414669936525013604526" //  &
           "663877295122333165527547705932002051525319167095677157791507288736" //  &
           "64026571366295683502084852088545059435402597033343652161501470364354290M-52"
      call fmst2m(st, c(104), qx)
      st = " 7.604645179238802714709378571216485567328230281028063584140295724" //  &
           "376585957946481904384646230934323963536666254241381678030728396763" //  &
           "58178737195689600607109967321748886837389095954530241223910865091320330M-53"
      call fmst2m(st, c(105), qx)
      st = " 2.510967747861821044453112929896090858886255004999542279673792434" //  &
           "537208309423086735805390141224743694821441092754412288490320556507" //  &
           "90129078122051056660926795028903236517945321893911606739679056323908271M-53"
      call fmst2m(st, c(106), qx)
      st = " 8.291669198546705061835867356103780154660596199979498029660459478" //  &
           "188005146704679300246430992623307755626947749069085299081605791921" //  &
           "74019998848391467377542111031322996337770209654839668772234104877607677M-54"
      call fmst2m(st, c(107), qx)
      st = " 2.738298161248419586570035179837181952253572874107137240705415238" //  &
           "006265247194645939919863261646299211192029639655806078478918931977" //  &
           "00593190887265237361465699889511989159926295238433577049420127008639310M-54"
      call fmst2m(st, c(108), qx)
      st = " 9.043920532563515029285236381202044755606494352793597664587001938" //  &
           "974036674170391738386361814188362066318933595609565234700634164118" //  &
           "70487847122956051574723330382189769818956900012640799709823774379723508M-55"
      call fmst2m(st, c(109), qx)
      st = " 2.987234357725506677158331533521097034607039220763832901730464971" //  &
           "787758443274701147417241273125203557371693807601776736455273977366" //  &
           "05803089099448475489215616434095538698506543339535511526713482057801648M-55"
      call fmst2m(st, c(110), qx)
      st = " 9.867741121615743267416100354228158234050959334204884456346592478" //  &
           "319239204688512319808683885900238794688432245788378036339502910311" //  &
           "95256267366461853050971201508370739481479021507935296576188223198846781M-56"
      call fmst2m(st, c(111), qx)
      st = " 3.259878763390904147253084369202388245824453621447959285540458582" //  &
           "736012876275248713545534462435398177897630905297446122213135317168" //  &
           "82679622090783961983706156224847005117892642811444666243882001638133683M-56"
      call fmst2m(st, c(112), qx)
      st = " 1.077010092919706009412412261729007614456466446787757717767031010" //  &
           "139026034411384632610387807051427675075586800080476142293720773922" //  &
           "20272670887152593395631417854201652294534598158204732976231392133784649M-56"
      call fmst2m(st, c(113), qx)
      st = " 3.558542119880893194099946299932858465278352616190909402621150713" //  &
           "569585013772896155460681917876143100438779403865861290242704606012" //  &
           "88545096496889803741553260243082158570103416935736970008787448980973697M-57"
      call fmst2m(st, c(114), qx)
      st = " 1.175866091786728245112848768043708292858352425382756439383320272" //  &
           "578862130652141603853077265569964741389836105657992359851950676535" //  &
           "04338748169984545024264075261487170842373741152762109550508117751868574M-57"
      call fmst2m(st, c(115), qx)
      st = " 3.885764383777977106238860501037171757872128590510931610888692650" //  &
           "910285334868201439319749230933970529786352570062128138073985716014" //  &
           "24775116761936632328170508559558303761107738144547614997375397249406443M-58"
      call fmst2m(st, c(116), qx)
      st = " 1.284184240792720746713802455067655929838349505783919451560002320" //  &
           "126603715783906155689196669126320213369826150934215436793861556561" //  &
           "85972584789613262065820990433273679374866590546774541475968702317884481M-58"
      call fmst2m(st, c(117), qx)
      st = " 4.244337744992888045444183568112374868793650501308024498979691533" //  &
           "890762987246535790550234061933625766554201413681894303054318079987" //  &
           "15016824304537959514257416420938167100044999559848904364273216745412168M-59"
      call fmst2m(st, c(118), qx)
      st = " 1.402890347084483369665088764818551961487912000082962187928218261" //  &
           "785089551297393342668713450909249794752403435631477836303274921114" //  &
           "55362046946784217832779503423966063510800253866244156993968505509787734M-59"
      call fmst2m(st, c(119), qx)
      st = " 4.637331980640374010893092224461382977846892054658359797965131441" //  &
           "456865261185257586124099243621668370219467668437596174204742705530" //  &
           "83668639386769597559944266590300361763651777592096905886759195912398458M-60"
      call fmst2m(st, c(120), qx)
      st = " 1.533002307649710027030813938667476629444482989777771349009392774" //  &
           "898001472950267391452028201567335345539750749325735733749863033002" //  &
           "69548753895579308292780126786018722213349444264135999363029954583214006M-60"
      call fmst2m(st, c(121), qx)
      st = " 5.068122383213521254015903956436646089688648450514341540538884175" //  &
           "869469050644753957457320055403310802554634158264858859825705672789" //  &
           "91662731199394270951038339532656379827609414997054764442302975300731162M-61"
      call fmst2m(st, c(122), qx)
      st = " 1.675639378731841475760363897846833007051598415558153712467179977" //  &
           "432925958506220080221518370999946501032024092613108461163906099341" //  &
           "82913060234132996850622927932164528031237880466865308048851412708423659M-61"
      call fmst2m(st, c(123), qx)
      st = " 5.540420526452055898116485439538895779663375849440317942175183295" //  &
           "232404269513749797742436944684450241469393462030971608777003451754" //  &
           "24373370189591105970695273793446260615786377827169998532420885870021362M-62"
      call fmst2m(st, c(124), qx)
      st = " 1.832032387413479669586574511502151686557921294324566012744100766" //  &
           "650543443902590363016386993218294974037346220641170740186656299364" //  &
           "35042400328594920807120027126914313294894904628053322733053994091135028M-62"
      call fmst2m(st, c(125), qx)
      st = " 6.058308159436109652922013909249826504043342021872382519752917607" //  &
           "688622870375413804432273155114051562335231336139713200850863559312" //  &
           "92844948695425942146384859065918295663347978412467638683301971137894309M-63"
      call fmst2m(st, c(126), qx)
      st = " 2.003534981860760581951442341610686092565547269730489837317963845" //  &
           "620455952950683642101005961045434369116586359058385158147557980542" //  &
           "11638367930496346396938524050401454422736023568038546321742832881166705M-63"
      call fmst2m(st, c(127), qx)
      st = " 6.626274549383244408116266205294449505997555094384610044245319246" //  &
           "030550314415978028317676220529142615194623162680155029534077714720" //  &
           "63797428182476797631017411639144206566456794143210250637764789933866701M-64"
      call fmst2m(st, c(128), qx)
      st = " 2.191636026669393443536074125395262735461777636080096892966692835" //  &
           "413006758477349117295402033106637857465621733449271837481434101507" //  &
           "59193133722553066298412025354918228064474978225340425161474540247412694M-64"
      call fmst2m(st, c(129), qx)
      st = " 7.249257626675685867142261929211249822372411007081385395432760399" //  &
           "456066369908496028419563900512609131853389393280859633882497500591" //  &
           "28369747912197909028518904445517467819162688494876358555633787825066496M-65"
      call fmst2m(st, c(130), qx)
      st = " 2.397973260732415138001223113122005679063725787264243397335901198" //  &
           "698321759116583811702053382300628630291425464911847398771216167493" //  &
           "18664813035306053986440746004247939745287869514463237143921611339050020M-65"
      call fmst2m(st, c(131), qx)
      st = " 7.932689322119858073349921363235515368474949336836316506068072766" //  &
           "546624999168511473276482943408448126386413211956579156398290157039" //  &
           "88529011287347733351088257288781160869062308105566110665892110886142277M-66"
      call fmst2m(st, c(132), qx)
      st = " 2.624348347167471822677772594888450230485642320545658876475286310" //  &
           "055771115343647866370773378641890749683248791810064619124781313040" //  &
           "39655556535083837498441324798836325222767712349195699260834872702802847M-66"
      call fmst2m(st, c(133), qx)
      st = " 8.682545526698351997704083743124967023750577000605836108664866495" //  &
           "160128302689923574758622135053769717872441667362682928425542104432" //  &
           "66558278030150559101531475636719213636150787481043024038745922498650758M-67"
      call fmst2m(st, c(134), qx)
      st = " 2.872743458216244845484563580154599626121124250656149184804291244" //  &
           "427536302457588668570923419780410649470498203175250876036620935134" //  &
           "64093415505201626499567870169234200516491544807537627932184985980888123M-67"
      call fmst2m(st, c(135), qx)
      st = " 9.505401148509633647613758343551012792444980481501235466486933914" //  &
           "265907192633387738944843898328544931131135589195243791819300008378" //  &
           "30106163188879275241944204168059306729141838253133216063222884137562944M-68"
      call fmst2m(st, c(136), qx)
      st = " 3.145339552791508936206896052221534466211147212254477273131941831" //  &
           "512277630670890754387204205624927221141107680833883854535942453092" //  &
           "60656013674364311521617359444957869733091866905428746679446531471773156M-68"
      call fmst2m(st, c(137), qx)
      st = " 1.040849079063856819895496485119313778206922325391046796592400903" //  &
           "438704272609812766874547219070728506140021601572906667448239089200" //  &
           "17410157182972609752570220147431398012450147044399178635448118006623721M-68"
      call fmst2m(st, c(138), qx)
      st = " 3.444536520642979399033002670688986667656937918697573314979061458" //  &
           "919964194677753822933252127653285396401597050249715424969440622451" //  &
           "73896561346967424455299327210221686160915541794905027119226479284135693M-69"
      call fmst2m(st, c(139), qx)
      st = " 1.139977562784224133216265743521281955028156700765266508712800967" //  &
           "848831883748374530246175200161064830753252846881090666971108606926" //  &
           "84608508079113604819022125345471848395222113457719457394701080327610407M-69"
      call fmst2m(st, c(140), qx)
      st = " 3.772975385101451028879155185726947819831206176127486435982734889" //  &
           "252802708561571080135558366656253315506022065599884895931599609988" //  &
           "98731864477490133149597217959601291802546927566215903357984266276909864M-70"
      call fmst2m(st, c(141), qx)
      st = " 1.248801711970198579225912046586232268562301776030667048611621632" //  &
           "465628194502888533349817467748088996697006070450714611279370044918" //  &
           "58919189486279287758063253685579639080251285807174486835285307209688606M-70"
      call fmst2m(st, c(142), qx)
      st = " 4.133562776218372917707434109108607724393370061767622907143777544" //  &
           "878888798728408345872714164317266154909605719593487267350335578853" //  &
           "93934162223974482538311480054078977999291506457599828857537063130739588M-71"
      call fmst2m(st, c(143), qx)
      st = " 1.368285826387100294053441225148146980381219160778152569563356532" //  &
           "725964967014895839699806485363534911338607141236453063094587484467" //  &
           "66893839721308893253877636532577439328086482952402541207429714733339152M-71"
      call fmst2m(st, c(144), qx)
      st = " 4.529497908040056144676469409188309794321421988959637669575342522" //  &
           "116514782664298860106021153887341542873949848678983271520138033675" //  &
           "79495262187662834453100157981375055331539396277574179995789688030466410M-72"
      call fmst2m(st, c(145), qx)
      st = " 1.499491316588603061306884181776653655545748070661401693040695069" //  &
           "053696590521220167504120163356893714569898088385033607285458815124" //  &
           "35872442007725124320485376254435248066997500475451183595538404386947583M-72"
      call fmst2m(st, c(146), qx)
      st = " 4.964302317957733490235530469745361589786652164074076392491530822" //  &
           "224428024784809035798407669056637309772933378074926314581475254129" //  &
           "86616192319821312175154821971972127073013580628971532023157018109185362M-73"
      call fmst2m(st, c(147), qx)
      st = " 1.643586578242763114833507846160154608374622266203265530676336751" //  &
           "694818277497961440503117616606491252858317008970780154993421364483" //  &
           "78099010504715300393033107665724003113140293042459780949957368683890959M-73"
      call fmst2m(st, c(148), qx)
      st = " 5.441852652794830894311470706477538221849565053218214215349180811" //  &
           "064294636030553844028448630827867613349267037250477900533924480506" //  &
           "82460851565237813605665759673888889710736177209599734575799006709861746M-74"
      call fmst2m(st, c(149), qx)
      st = " 1.801857878369844007118484883880761798414766692597217574900046197" //  &
           "360262152730609587228705384643316107409543482294232641569660175011" //  &
           "79519154781224338457932814908298988696375455365226741142441036489254992M-74"
      call fmst2m(st, c(150), qx)
      st = " 5.966416815794185453763830530254737531064047428340471319398688069" //  &
           "007552470288020366752010161084016011730287854271568912859552337203" //  &
           "41453128747443716412531087761908717466819377449540627696187031359721010M-75"
      call fmst2m(st, c(151), qx)
      st = " 1.975721357861671060279948825620105307975444162740595055137362881" //  &
           "848246417197234999961571849669754470375412457219647332906833168922" //  &
           "68071772240997929407621098946132582262214118221958928604276333611006417M-75"
      call fmst2m(st, c(152), qx)
      st = " 6.542693821241263641717538449532346497940622472878710087928587547" //  &
           "135890790293782933631752384033436259896798958027902059478261401316" //  &
           "51898760968041471004067759299223993845873964885693255185054469449588983M-76"
      call fmst2m(st, c(153), qx)
      st = " 2.166736265476002894293516585134968365492470343594290484160425853" //  &
           "634757103189631345447367869704134537187600769397997799583921963715" //  &
           "66991272921221434244459511112119776440312273606272563588060032932425347M-76"
      call fmst2m(st, c(154), qx)
      st = " 7.175857739425902058446366213267163717870002184056285139492810907" //  &
           "165151388326241994224874557956711286862577806517065215553936524682" //  &
           "13250466673505382651861797375923534026910443196181011966541606084919661M-77"
      call fmst2m(st, c(155), qx)
      st = " 2.376619550450886365485623751880291284047099214872959375092451724" //  &
           "342950586001550942436415678973426556922327249108654045209317268184" //  &
           "82082947451080863768578126711240615665895962605984771627264126442044223M-77"
      call fmst2m(st, c(156), qx)
      st = " 7.871606154359623630068573317612764902762392638995019862408631291" //  &
           "008061939353640535233024537980362873819209185759931590349366135182" //  &
           "14586054502659862300174333186280592070419277216786077915707312111770211M-78"
      call fmst2m(st, c(157), qx)
      st = " 2.607261954081141160150797999367222244498208263011867403220673096" //  &
           "800582313576057737826578818707489920864730296871775420774049041364" //  &
           "79431809641123667403151516016216413258555378265536018764789936965838617M-78"
      call fmst2m(st, c(158), qx)
      st = " 8.636213600520341807753750476732474442820999819309686673192125811" //  &
           "444182648267187160168499080611902341484327275294303024770270222135" //  &
           "59223769662625003083305590998863860730206646251762971580585644914132026M-79"
      call fmst2m(st, c(159), qx)
      st = " 2.860745755172363223898311967180521130986380848162555027528393662" //  &
           "915983444061966784564310775020004680613450195420353857249494047775" //  &
           "73818249551580545509645629320363387364925214204842915131007525800466880M-79"
      call fmst2m(st, c(160), qx)
      st = " 9.476590493324598214557576012349336522703693594124571054279111616" //  &
           "798531592192686914431167230715058815630334239433475110837262090138" //  &
           "33301645943249512127076707890530532222551337127599066189782985037412169M-80"
      call fmst2m(st, c(161), qx)
      st = " 3.139364340381194056746408425980351704553046571903970795447364975" //  &
           "882887158738580119004810652625014397096678884159435971472598704137" //  &
           "54339572525201214956186891250608510839418632104354221549889413573604846M-80"
      call fmst2m(st, c(162), qx)
      st = " 1.040034812150826026710373679719002963399053176200107466780745572" //  &
           "000065388516270021753222010998681619656807884101412895225381983273" //  &
           "03585371769586543699202508103518904235084186177627200599704020839402387M-80"
      call fmst2m(st, c(163), qx)
      st = " 3.445643788223265129236923220146442325334098948153988879546081638" //  &
           "282932221486522368247949883425191269877715114051526159278376683546" //  &
           "54478379087683377717562788666572331232941361970188301510421846831598762M-81"
      call fmst2m(st, c(164), qx)
      st = " 1.141587032865869378324299022323731794401778416670178670987733185" //  &
           "814446261010130113286467916958273916598065282809528144498877625408" //  &
           "51786835211126241486118129987351739916755135907809166050772678111097018M-81"
      call fmst2m(st, c(165), qx)
      st = " 3.782366675158000172438186031560392817938018879105893232376963665" //  &
           "758045582935962507746785156805849115039876109316259116490068195664" //  &
           "22154600940352929680886350387924367311407243398433694317491879496500728M-82"
      call fmst2m(st, c(166), qx)
      st = " 1.253239257637571101011205444147249909041208363526150999161557930" //  &
           "530122175707904339132697555874221097743565894565280785124100424739" //  &
           "12341727673603475533755872933253879415498534305672767854397632835354647M-82"
      call fmst2m(st, c(167), qx)
      st = " 4.152598333838791095457780574441131208990623618377645706663873970" //  &
           "409219842573498216786365580094065012089293058629821760308697172924" //  &
           "25649947447826939431820718042482922400940273337175959594512550863844028M-83"
      call fmst2m(st, c(168), qx)
      st = " 1.376008915348001441142775089390756952291415569331728264389528531" //  &
           "840532583703944779638084800244642630871018954424019239838171107774" //  &
           "08455142709222529998017403722473530832343485779953472597270935996990435M-83"
      call fmst2m(st, c(169), qx)
      st = " 4.559715817525503407894512559569944355041250549999373143331298588" //  &
           "042902011136449984273691723063087171534265607563490346238292992622" //  &
           "43694334064073133108518335548127416155718965768703096927698154664008186M-84"
      call fmst2m(st, c(170), qx)
      st = " 1.511016937693380717359102098553590521576253151812935620881255183" //  &
           "676747573506694189735416802045982192198119977018955499638830448943" //  &
           "99139906962195905603908709462882471176378436053656496936740374119626233M-84"
      call fmst2m(st, c(171), qx)
      st = " 5.007439851661721308524939431791288925473304269198627995505717966" //  &
           "042698143618956580402359781596868665105789229557574207071195578504" //  &
           "34784490998580851675508563655209200033656690762499193037679456058834741M-85"
      call fmst2m(st, c(172), qx)
      st = " 1.659498369200591197022274845367449670587666822869779371596678693" //  &
           "434849663818573237359515507605355977016921178742109368988856546946" //  &
           "53987167820516459592809407463255771494757163532540963217681912265486931M-85"
      call fmst2m(st, c(173), qx)
      st = " 5.499870074123138278587253453863123198782240874965235399880295435" //  &
           "189868323747896824633224719144787009990778913499316775325760318709" //  &
           "84151200565534853443611640092085568829894647596561585415506088061475496M-86"
      call fmst2m(st, c(174), qx)
      st = " 1.822814104787822173171970582684126136729373783986451680232463776" //  &
           "995284747235440436579147791215434063408671873139502336867256882493" //  &
           "52907684446136684618467464533340860151713404827732293178363163584088691M-86"
      call fmst2m(st, c(175), qx)
      st = " 6.041524022149206216514749478207951898414628220569359023936273098" //  &
           "431129999705544414314317322005670901754042242107672777454004410860" //  &
           "23728922114946882252911249911639377024536952401619252235639914064675297M-87"
      call fmst2m(st, c(176), qx)
      st = " 2.002463416328745336974658582823885810920380274053175588795927666" //  &
           "714050828711674000372182654975669270167646317724425684411171485274" //  &
           "63888736139146918349514677140009027878433312540016907441088200168772901M-87"
      call fmst2m(st, c(177), qx)
      st = " 6.637378732657623720229439419358377518409139927005258254140285180" //  &
           "914849963099373381335080302807182958739736822642496046941955995156" //  &
           "47580543357281795983541588632113533651700800850371216214989020246965499M-88"
      call fmst2m(st, c(178), qx)
      st = " 2.200102767530555026604991024957956952823900377482112800591761008" //  &
           "660084843014248387788035100004987819764909462237889078992186315330" //  &
           "60158332375064476625052936559137839280476740402400480416136592265795082M-88"
      call fmst2m(st, c(179), qx)
      st = " 7.292933318740382159132169272746181235841016457994964554263454208" //  &
           "492201073732473833848574569619679758849986320998185690723690770932" //  &
           "41462402016226262443880472321890006685113024701301315267987027615012503M-89"
      call fmst2m(st, c(180), qx)
      st = " 2.417513092202831923304643749980362419472891672259150932920867637" //  &
           "832384236931175709234025174145241123797309720555077484497334156484" //  &
           "70273284353674851435852469743857826682908838509841004308849506350039697M-89"
      call fmst2m(st, c(181), qx)
      st = " 8.014099523920820532691698949493969623669374514095447937521752186" //  &
           "098803953643697356090844942590659454999844318173870304557001940555" //  &
           "42525475893078866822127874440270390910047929036227162217460866884004221M-90"
      call fmst2m(st, c(182), qx)
      st = " 2.657079598189421611225399332494614836172370837056707080573411081" //  &
           "077314111961101307612637519570469581636094934124837596398237792257" //  &
           "42836805118176886050043438632186029854385799944806006391590874149011746M-90"
      call fmst2m(st, c(183), qx)
      st = " 8.808801832338891822547417575762619398673718065912507825752674890" //  &
           "111044965171749095170501464417801064468367983054179217820785485005" //  &
           "97684256880162841894825031174637280632623961080123218247631394854404406M-91"
      call fmst2m(st, c(184), qx)
      st = " 2.917871827472767744801985504187470385461224411949197505438209784" //  &
           "552995184888997609387528889784137922680585612807183342956402094608" //  &
           "01943529407670923901992925226137852941513101357366936300944346484030974M-91"
      call fmst2m(st, c(185), qx)
      st = " 9.673909686763801191886681572020182885252222531903039060187477306" //  &
           "277095817639315200476096440352681128855627885542339760940019503157" //  &
           "11902076792371625818162067652299279665268178569377108196296372219380510M-92"
      call fmst2m(st, c(186), qx)
      st = " 3.225317339965144219466139388048879231367171359221844461940917969" //  &
           "250112356759739827102732375554724422636709224874307206769709880215" //  &
           "16808317218174915989091357841379986431733603301918969106178493014736385M-92"
      call fmst2m(st, c(187), qx)
      st = " 1.069410576590312480755235192735211157086107353088423400669923656" //  &
           "677428694478915259443669100953558846603833879903904822845298497420" //  &
           "71143211982703738257538091316334035362562254796294606412951506359364815M-92"
      call fmst2m(st, c(188), qx)
      st = " 3.436230247075590625300285568770398628374034305782922085529568066" //  &
           "268230300872273810320168642643487560176713818087616304872506761508" //  &
           "46310739710431810178913824922315129263580429076241251322833952169352928M-93"
      call fmst2m(st, c(189), qx)
      st = " 1.139260014627810596016761865641404521146852141822567620126418127" //  &
           "549772266075482248466335323616377804969776249070578213315603095439" //  &
           "66803478295001515092190429139446518480363880483757347561526976211621457M-93"
      call fmst2m(st, c(190), qx)
      st = " 4.343070458433874603042514728830057473477940614398096372223763568" //  &
           "372476710887610850250214061613248238834003723272762897566055896217" //  &
           "49542103193171278645483518744915143059042740324768324837960269146747307M-94"
      call fmst2m(st, c(191), qx)
      st = " 1.440667367566540553672654836910082201055609375400592746447756244" //  &
           "176284526124155943246633922603816785133029633668454281491778597874" //  &
           "45028943290797079216498815025085467176654584077190605132981537168513742M-94"
      call fmst2m(st, c(192), qx)
      st = " 2.384816222561370113514027430584139466337689187141928475880205055" //  &
           "969980605519512189876139389796445441195296187421190296481218115986" //  &
           "36517542721807591974162349259651427967273755554095270040863620533051177M-95"
      call fmst2m(st, c(193), qx)
      st = " 7.891080859500628750618564157769100520532680589132484946442038829" //  &
           "299825933371426348457257350822254140519284945880389565858120333678" //  &
           "80845449586455112014663973071181240064800376338635797974159751681049875M-96"
      call fmst2m(st, c(194), qx)
      st = " 1.059066626703749406081450817511793688125712964427249229411570236" //  &
           "550112600348902027013047427990927965524515088187243012802502472093" //  &
           "22261048153901594967680556527547070843534915035469463356163636215773539M-95"
      call fmst2m(st, c(195), qx)
      st = " 3.516498583838005375775193339944623281315914658931041130875008620" //  &
           "636983702886095342086986357214180450129972642316547945003279723791" //  &
           "81126461652035134771983947459420613651499692168433361308886876030693800M-96"
      call fmst2m(st, c(196), qx)

      qx%ndig = ndsave

      end subroutine fmlngm_c

      subroutine fmlngm_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)

!  Method selection for computing ln(gamma(ma)).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(15), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc
      type(fm_settings) :: qx

      double precision :: x, z
      integer :: kfl, nmethd
      logical, external :: fmcomp

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      call fmeq(mxy(1), mxy(13), qx)
      n_acc = nint(qx%ndig*qx%alogm2)

!             Near zero Gamma(x) is about 1/x.

      if (mxy(13)%mp(2) < (-qx%ndig-3)) then
          call fmln(mxy(13), mresult, qx)
          qx%ndigli = 0
          call fmnegate(mresult, qx)
          return
      endif

!             Check for special cases.

      if (mxy(1)%mp(1) < 0) then
          kfl = 0
          if (mxy(1)%mp(2) <= ndsave) then
              call fmint(mxy(13), mxy(9), qx)
              if (fmcomp(mxy(13), '==', mxy(9), qx)) kfl = -4
              call fmi2m(2, mxy(10), qx)
              mxy(9)%mp(1) = 1
              call fmmod(mxy(9), mxy(10), mxy(5), qx)
              call fmeq(mxy(5), mxy(10), qx)
              if (mxy(10)%mp(3) == 0) kfl = -4
          else
              kfl = -4
          endif
          if (kfl /= 0) then
              call fmunknown(mresult, qx)
              qx%kflag = -4
              retry = .false.
              return
          else
              call fmi2m(1, mxy(5), qx)
              call fmsub_r2(mxy(5), mxy(13), qx)
          endif
      endif

!             Determine which method to use.

!             nmethd = 1 means use the polynomial approximation,
!                    = 2 means use the asymptotic series.

      nmethd = 1
      call fmnint(mxy(13), mxy(2), qx)
      call fmsub(mxy(13), mxy(2), mxy(6), qx)
      call fmm2dp(mxy(6), z, qx)
      z = max(abs(z), 1.0d-50)
      if (qx%kflag /= 0 .or. abs(z) >= 1) then
          nmethd = 2
      else
          if (190*log(z) - 90*qx%dlogtn >= -qx%ndig*qx%dlogmb .or. -190*qx%dlogtn >= -qx%ndig*qx%dlogmb) then
              nmethd = 2
          endif
      endif
      call fmm2dp(mxy(13), x, qx)
      if (qx%kflag /= 0) then
          nmethd = 2
      else if (nmethd == 1) then
          if (x > 35 - 8*log(z) + qx%ndig*qx%dlogmb/(2.5*qx%dlogtn) .or. x > 250) nmethd = 2
      endif

      if (nmethd == 1) then
          call fmlngm_m1(mxy, mresult, ndsave, numtry, retry, n_acc, z, qx)
      else if (nmethd == 2) then
          call fmlngm_m2(mxy, mresult, retry, n_acc, qx)
          qx%ndg2pi = 0
          qx%numbrn = 0
      endif

      return
      end subroutine fmlngm_m

      subroutine fmlngm_m1(mxy, mresult, ndsave, numtry, retry, n_acc, z, qx)

!  Method 1 for computing ln(gamma(ma)).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(15), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      double precision :: z
      intent (in) :: numtry, ndsave, z
      intent (inout) :: mxy, mresult, retry, n_acc
      type(fm_settings) :: qx

      integer :: j, j2, k, k0, k1, k2, kl, krsave, ksign, lshift, ndsav1, nterm
      type(multi) :: mjsums(ljsums), c(0:196)
      integer :: ndig_c
      real (kind(1.0d0)) :: mbase_c
      logical, external :: fmcomp

      ndig_c = 0
      mbase_c = 0

!             Method 1.  Use the polynomial c(0) + c(1)*(x-3) + ... + c(196)*(x-3)**196

      if (mxy(1)%mp(1) > 0 .and. ndsave+qx%ngrd52 < qx%ndig .and. numtry == 0)  &
          call fmndig(ndsave + qx%ngrd52, qx)
      n_acc = nint(qx%ndig*qx%alogm2)
      call fmm2i(mxy(2), lshift, qx)
      lshift = lshift - 3
      if (ndig_c < qx%ndig .or. mbase_c /= qx%mbase) then
          call fmlngm_c(ndig_c, mbase_c, c, qx)
      endif
      j2 = 0.42*log(z) + 7.9
      j2 = max(2, min(j2+mod(j2, 2), ljsums))
      ndsav1 = qx%ndig
      do j = 1, j2
         call fmeq(c(j+1), mjsums(j), qx)
      enddo
      call fmipwr(mxy(6), j2, mxy(5), qx)
      call fmeq(mxy(5), mxy(7), qx)
      nterm = j2 + 1
      kl = 1
      do while (kl == 1)
         if (nterm > j2+1) call fmcsmpy_r1(mxy(7), mxy(5), qx)
         do j = 1, j2
            nterm = nterm + 1
            call fmeq(mxy(7), mxy(4), qx)
            call fmcsmpy_r1(mxy(4), c(nterm), qx)
            call fmndig(ndsav1, qx)
            call fmcsaddnn_r1(mjsums(j), mxy(4), qx)
            if (qx%kflag /= 0 .or. nterm == 196) then
                kl = 0
                exit
            endif
            call fmndig(ndsav1 - int(mjsums(j)%mp(2)-mxy(4)%mp(2)), qx)
            call fmndig(min(ndsav1, qx%ndig), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         enddo
      enddo
      qx%kflag = 0
      call fmcsnsums(j2, mjsums, qx)
      call fmndig(ndsav1, qx)
      if (nterm == 196) then
          call fmlngm_m2(mxy, mresult, retry, n_acc, qx)
          qx%ndg2pi = 0
          qx%numbrn = 0
          return
      endif
      call fmeq(mjsums(j2), mxy(8), qx)
      call fmeq(mxy(6), mxy(3), qx)
      call fmnegate(mxy(3), qx)
      do j = 2, j2
         call fmcsmpy_r1(mxy(8), mxy(3), qx)
         call fmcsadd_r1(mxy(8), mjsums(j2-j+1), qx)
      enddo
      call fmsqr(mxy(6), mxy(3), qx)
      call fmcsmpy_r1(mxy(8), mxy(3), qx)
      call fmadd(mxy(8), c(0), mxy(10), qx)
      call fmmpy(mxy(6), c(1), mxy(3), qx)
      call fmadd_r1(mxy(10), mxy(3), qx)

!             Recover from using a shifted argument.

      if (lshift < 0) then
          call fmeq(mxy(13), mxy(3), qx)
          call fmeq(mxy(13), mxy(14), qx)
          do j = 2, -lshift
             call fmaddi(mxy(14), 1, qx)
             call fmmpy_r1(mxy(3), mxy(14), qx)
          enddo
          call fmln(mxy(3), mxy(4), qx)
          qx%ndigli = 0
          call fmsub(mxy(10), mxy(4), mxy(3), qx)
          call fmcancel(mxy(10), mxy(4), mxy(3), k, qx)
          n_acc = n_acc - k
          call fmeq(mxy(3), mxy(10), qx)
      endif
      if (lshift > 0) then
          if (mod(lshift, 4) == 0) then
              call fmi2m(1, mxy(3), qx)
              call fmeq(mxy(6), mxy(14), qx)
              call fmaddi(mxy(14), 3, qx)
          else
              call fmeq(mxy(6), mxy(3), qx)
              call fmaddi(mxy(3), 3, qx)
              call fmeq(mxy(3), mxy(14), qx)
              do j = 1, mod(lshift, 4)-1
                 call fmaddi(mxy(14), 1, qx)
                 call fmmpy_r1(mxy(3), mxy(14), qx)
              enddo
              call fmaddi(mxy(14), 1, qx)
          endif
          lshift = lshift - mod(lshift, 4)

!             The product z*(z+1)*...*(z+lshift-1) is computed four terms at a time to reduce
!             the number of fmmpy calls.

!             mxy(14) is z
!             mxy(6) is z**2
!             mxy(7) is z**3
!             mxy(8) is (z+k)*...*(z+k+3)
!             mxy(11) is the current product

          call fmi2m(1, mxy(11), qx)
          if (lshift > 0) then
              call fmsqr(mxy(14), mxy(6), qx)
              call fmmpy(mxy(14), mxy(6), mxy(7), qx)
              call fmsqr(mxy(6), mxy(8), qx)
              call fmcsmpyi(mxy(7), 6, mxy(12), qx)
              call fmcsadd_r1(mxy(8), mxy(12), qx)
              call fmcsmpyi(mxy(6), 11, mxy(12), qx)
              call fmcsadd_r1(mxy(8), mxy(12), qx)
              call fmcsmpyi(mxy(14), 6, mxy(12), qx)
              call fmcsadd_r1(mxy(8), mxy(12), qx)
              call fmeq(mxy(8), mxy(11), qx)
              call fmcsmpyi_r1(mxy(7), 16, qx)
              do k = 0, lshift-8, 4
                 call fmcsadd_r1(mxy(8), mxy(7), qx)
                 k2 = 24*(2*k + 7)
                 call fmcsmpyi(mxy(6), k2, mxy(12), qx)
                 call fmcsadd_r1(mxy(8), mxy(12), qx)
                 if (k <= sqrt(real(intmax)/49.0)) then
                     k1 = 8*(6*k*k + 42*k + 79)
                     call fmcsmpyi(mxy(14), k1, mxy(12), qx)
                     call fmcsadd_r1(mxy(8), mxy(12), qx)
                 else
                     k1 = 48*k
                     call fmcsmpyi(mxy(14), k1, mxy(12), qx)
                     call fmcsmpyi_r1(mxy(12), k, qx)
                     call fmcsadd_r1(mxy(8), mxy(12), qx)
                     k1 = 336*k + 632
                     call fmcsmpyi(mxy(14), k1, mxy(12), qx)
                     call fmcsadd_r1(mxy(8), mxy(12), qx)
                 endif
                 if (k <= (real(intmax)/17.0)**0.3333) then
                     k0 = 8*(2*k + 7)*(k*k + 7*k + 15)
                     call fmaddi(mxy(8), k0, qx)
                 else if (k <= sqrt(real(intmax)*0.9)) then
                     k0 = 8*(2*k + 7)
                     call fmi2m(k0, mxy(12), qx)
                     k0 = k*k + 7*k + 15
                     call fmcsmpyi_r1(mxy(12), k0, qx)
                     call fmcsadd_r1(mxy(8), mxy(12), qx)
                 else
                     k0 = 8*(2*k + 7)
                     call fmi2m(k0, mxy(12), qx)
                     call fmcsmpyi(mxy(12), k, mxy(9), qx)
                     call fmcsmpyi_r1(mxy(9), k, qx)
                     call fmcsadd_r1(mxy(8), mxy(9), qx)
                     k0 = 7*k + 15
                     call fmcsmpyi_r1(mxy(12), k0, qx)
                     call fmcsadd_r1(mxy(8), mxy(12), qx)
                 endif
                 call fmcsmpy_r1(mxy(11), mxy(8), qx)
              enddo
          endif
          call fmmpy_r1(mxy(11), mxy(3), qx)
          call fmln(mxy(11), mxy(4), qx)
          qx%ndigli = 0
          call fmadd(mxy(10), mxy(4), mxy(3), qx)
          call fmcancel(mxy(10), mxy(4), mxy(3), k, qx)
          n_acc = n_acc - k
          call fmeq(mxy(3), mxy(10), qx)
      endif

!             Use the reflection formula if ma was negative.

      if (mxy(1)%mp(1) < 0) then

!             Reduce the argument before multiplying by pi.

          call fmnint(mxy(13), mxy(6), qx)
          call fmdivi(mxy(6), 2, mxy(7), qx)
          call fmint(mxy(7), mxy(2), qx)
          call fmmpyi(mxy(2), 2, mxy(8), qx)
          ksign = -1
          if (fmcomp(mxy(6), '==', mxy(8), qx)) ksign = 1
          call fmsub(mxy(13), mxy(6), mxy(9), qx)
          call fmcancel(mxy(13), mxy(6), mxy(9), k, qx)
          n_acc = n_acc - k
          call fmpi(mxy(11), qx)
          qx%ndigpi = 0
          call fmmpy_r1(mxy(11), mxy(9), qx)
          krsave = qx%krad
          qx%krad = 1
          call fmsin(mxy(11), mxy(3), qx)
          mxy(3)%mp(1) = ksign*mxy(3)%mp(1)
          qx%krad = krsave
          call fmpi(mxy(11), qx)
          qx%ndigpi = 0
          call fmdiv_r2(mxy(11), mxy(3), qx)
          call fmln(mxy(3), mxy(4), qx)
          qx%ndigli = 0
          call fmsub(mxy(4), mxy(10), mxy(3), qx)
          call fmcancel(mxy(4), mxy(10), mxy(3), k, qx)
          n_acc = n_acc - k
          call fmeq(mxy(3), mxy(10), qx)
      endif

      call fmeq(mxy(10), mresult, qx)

      return
      end subroutine fmlngm_m1

      subroutine fmlngm_m2(mxy, mresult, retry, n_acc, qx)

!  Method 2 for computing ln(gamma(ma)).

      use fmvals_parallel
      implicit none

      type(multi) :: mbern(lmbern)
      integer :: ndbern(lmbern)
      type(multi) :: m_ln_2pi
      type(multi) :: mxy(15), mresult
      logical :: retry
      integer :: n_acc
      intent (inout) :: mxy, mresult, retry, n_acc
      type(fm_settings) :: qx

      integer :: inta, j, j2, k, k0, k1, k2, kl, krsave, ksign, kwrnsv, lshift,  &
                 ndenom, ndig2, ndmb, ndsav1, ndsv, nmxdif, nterm
      character(155) :: string
      character :: st2(155)
      type(multi) :: mjsums(ljsums)
      logical, external :: fmcomp
      qx%ndg2pi = 0
      qx%mbs2pi = 0

!             Method 2.  Use the b(2n)/(2n*(2n-1)*x**(2n-1) asymptotic series.
!                        To speed the asymptotic series calculation,
!                        increase the argument by lshift.

      n_acc = nint(qx%ndig*qx%alogm2)
      kwrnsv = qx%kwarn
      qx%kwarn = 0
      call fmm2i(mxy(13), inta, qx)
      qx%kwarn = kwrnsv

      if (qx%kflag == -4) then
          lshift = 0
      else
          lshift = max(0, int(real(qx%ndig)*qx%alogmb/4.46-real(inta)))
      endif
      if (lshift > 0) lshift = 4*(lshift/4 + 1)
      if (qx%kflag == 0) then
          if (lshift > 0 .or. inta <= 10) then
              if (inta <= 2) then
                  call fmi2m(0, mresult, qx)
                  return
              endif
              inta = inta - 1
              call fmfcti(inta, mxy(13), qx)
              call fmln(mxy(13), mresult, qx)
              qx%ndigli = 0
              return
          endif
      endif

      if (lshift /= 0) then
          call fmi2m(lshift, mxy(5), qx)
          call fmadd(mxy(13), mxy(5), mxy(12), qx)
      else
          call fmeq(mxy(13), mxy(12), qx)
      endif

!             Sum the asymptotic series.

!       mxy(13) is z
!       mxy(12) is z + lshift
!       mxy(9)  is x**j2 = (1/(z+lshift)**2)**j2
!       mxy(10) is the current power of x
!       mxy(11) is the current term in the sum
!       mjsums  is the partial sum

      j2 = int(0.3*qx%alogmb + 0.2*sqrt(real(qx%ndig)))
      j2 = max(1, min(ljsums, j2))
      ndsav1 = qx%ndig
      call fmi2m(1, mxy(10), qx)
      j = -2*j2
      call fmipwr(mxy(12), j, mxy(9), qx)
      if (abs(mxy(9)%mp(2)) >= qx%mexpab) then
          j2 = 1
          call fmipwr(mxy(12), -2, mxy(9), qx)
      endif
      nterm = 0
      do j = 1, j2
         nterm = 2*j
         call fmbern(nterm, mxy(10), mxy(11), mbern, ndbern, qx)
         if (qx%kflag == -11) then
             call fmunknown(mresult, qx)
             qx%kflag = -4
             retry = .false.
             return
         endif
         ndenom = nterm*(nterm-1)
         call fmcsdivi(mxy(11), ndenom, mjsums(j), qx)
      enddo

      ndig2 = qx%ndig
      kl = 1
      do while (kl == 1)
         call fmcsmpy_r1(mxy(10), mxy(9), qx)

         nmxdif = min(ndsav1, qx%ngrd22)
         do j = 1, j2
            nterm = nterm + 2
            call fmbern(nterm, mxy(10), mxy(11), mbern, ndbern, qx)
            if (qx%kflag == -11) then
                call fmunknown(mresult, qx)
                qx%kflag = -4
                retry = .false.
                return
            endif
            ndenom = nterm*(nterm-1)
            if (nterm <= mxbase/(nterm-1)) then
                call fmcsdivi_r1(mxy(11), ndenom, qx)
            else
                call fmcsdivi_r1(mxy(11), nterm, qx)
                ndenom = nterm - 1
                call fmcsdivi_r1(mxy(11), ndenom, qx)
            endif
            call fmndig(ndsav1, qx)
            call fmcsadd_r1(mjsums(j), mxy(11), qx)
            nmxdif = max(nmxdif, ndsav1-int(mjsums(j)%mp(2)-mxy(11)%mp(2)))
            call fmndig(ndig2, qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
         enddo
         if (kl == 1) then
             ndig2 = nmxdif
             call fmndig(ndig2, qx)
         else
             exit
         endif
      enddo

!             Put the j2 concurrent sums back together.

      call fmndig(ndsav1, qx)
      if (j2 > 1) then
          call fmsqr(mxy(12), mxy(11), qx)
          call fmi2m(1, mxy(5), qx)
          call fmdiv_r2(mxy(5), mxy(11), qx)
          call fmeq(mjsums(j2), mxy(9), qx)
          do j = j2-1, 1, -1
             call fmcsmpy_r1(mxy(9), mxy(11), qx)
             call fmcsadd_r1(mxy(9), mjsums(j), qx)
          enddo
          call fmeq(mxy(9), mjsums(1), qx)
      endif

!             Add the log terms to the asymptotic series.

!       mxy(10) is the current sum as the log terms are added
!       mxy(11) is now ln(z+lshift)

      call fmdiv(mjsums(1), mxy(12), mxy(10), qx)
      call fmln(mxy(12), mxy(11), qx)
      qx%ndigli = 0
      if (qx%mbase /= qx%mbs2pi .or. qx%ndig > qx%ndg2pi) then
          ndmb = int(150.0*2.302585/qx%alogmb)
          if (ndmb >= qx%ndig) then
              ndsv = qx%ndig
              call fmndig(ndmb, qx)
              string = '1.837877066409345483560659472811235279722794'//  &
              '94727556682563430308096553139185452079538948659727190'//  &
              '8395244011293249268674892733725763681587144311751830445'
              k = min(int((qx%ndig-1) * qx%dlogmb / qx%dlogtn + 2), len(string))
              do j = 1, k
                 st2(j) = string(j:j)
              enddo
              call fminp(st2, m_ln_2pi, 1, k, qx)
              qx%mbs2pi = qx%mbase
              qx%ndg2pi = qx%ndig
              if (abs(m_ln_2pi%mp(2)) > 10) qx%ndg2pi = 0
              call fmndig(ndsv, qx)
          else
              ndsv = qx%ndig
              call fmndig(qx%ndig + 2, qx)
              call fmpi(mxy(9), qx)
              qx%ndigpi = 0
              call fmmpyi(mxy(9), 2, mxy(5), qx)
              call fmln(mxy(5), m_ln_2pi, qx)
              qx%ndigli = 0
              qx%mbs2pi = qx%mbase
              qx%ndg2pi = qx%ndig
              if (abs(m_ln_2pi%mp(2)) > 10) qx%ndg2pi = 0
              call fmndig(ndsv, qx)
          endif
      endif
      call fmsub(m_ln_2pi, mxy(11), mxy(5), qx)
      call fmcancel(m_ln_2pi, mxy(11), mxy(5), k, qx)
      n_acc = n_acc - k
      call fmcsdivi(mxy(5), 2, mxy(9), qx)
      call fmadd(mxy(10), mxy(9), mxy(3), qx)
      call fmcancel(mxy(10), mxy(9), mxy(3), k, qx)
      n_acc = n_acc - k
      call fmeq(mxy(3), mxy(10), qx)
      call fmsub(mxy(10), mxy(12), mxy(3), qx)
      call fmcancel(mxy(10), mxy(12), mxy(3), k, qx)
      n_acc = n_acc - k
      call fmeq(mxy(3), mxy(10), qx)
      call fmmpy(mxy(11), mxy(12), mxy(9), qx)
      call fmadd(mxy(10), mxy(9), mxy(3), qx)
      call fmcancel(mxy(10), mxy(9), mxy(3), k, qx)
      n_acc = n_acc - k
      call fmeq(mxy(3), mxy(10), qx)

!             Now the log of gamma of the shifted argument has been computed.  Reverse the shifting.
!             The product ma*(ma+1)*...*(ma+lshift-1) is computed four terms at a time to reduce
!             the number of fmmpy calls.

!             mxy(13) is z
!             mxy(6) is z**2
!             mxy(7) is z**3
!             mxy(8) is (z+k)*...*(z+k+3)
!             mxy(11) is the current product

      if (lshift > 0) then
          call fmsqr(mxy(13), mxy(6), qx)
          call fmmpy(mxy(13), mxy(6), mxy(7), qx)
          call fmsqr(mxy(6), mxy(8), qx)
          call fmcsmpyi(mxy(7), 6, mxy(12), qx)
          call fmcsadd_r1(mxy(8), mxy(12), qx)
          call fmcsmpyi(mxy(6), 11, mxy(12), qx)
          call fmcsadd_r1(mxy(8), mxy(12), qx)
          call fmcsmpyi(mxy(13), 6, mxy(12), qx)
          call fmcsadd_r1(mxy(8), mxy(12), qx)
          call fmeq(mxy(8), mxy(11), qx)
          call fmcsmpyi_r1(mxy(7), 16, qx)
          do k = 0, lshift-8, 4
             call fmcsadd_r1(mxy(8), mxy(7), qx)
             k2 = 24*(2*k + 7)
             call fmcsmpyi(mxy(6), k2, mxy(12), qx)
             call fmcsadd_r1(mxy(8), mxy(12), qx)
             if (k <= sqrt(real(intmax)/49.0)) then
                 k1 = 8*(6*k*k + 42*k + 79)
                 call fmcsmpyi(mxy(13), k1, mxy(12), qx)
                 call fmcsadd_r1(mxy(8), mxy(12), qx)
             else
                 k1 = 48*k
                 call fmcsmpyi(mxy(13), k1, mxy(12), qx)
                 call fmcsmpyi_r1(mxy(12), k, qx)
                 call fmcsadd_r1(mxy(8), mxy(12), qx)
                 k1 = 336*k + 632
                 call fmcsmpyi(mxy(13), k1, mxy(12), qx)
                 call fmcsadd_r1(mxy(8), mxy(12), qx)
             endif
             if (k <= (real(intmax)/17.0)**0.3333) then
                 k0 = 8*(2*k + 7)*(k*k + 7*k + 15)
                 call fmaddi(mxy(8), k0, qx)
             else if (k <= sqrt(real(intmax)*0.9)) then
                 k0 = 8*(2*k + 7)
                 call fmi2m(k0, mxy(12), qx)
                 k0 = k*k + 7*k + 15
                 call fmcsmpyi_r1(mxy(12), k0, qx)
                 call fmcsadd_r1(mxy(8), mxy(12), qx)
             else
                 k0 = 8*(2*k + 7)
                 call fmi2m(k0, mxy(12), qx)
                 call fmcsmpyi(mxy(12), k, mxy(9), qx)
                 call fmcsmpyi_r1(mxy(9), k, qx)
                 call fmcsadd_r1(mxy(8), mxy(9), qx)
                 k0 = 7*k + 15
                 call fmcsmpyi_r1(mxy(12), k0, qx)
                 call fmcsadd_r1(mxy(8), mxy(12), qx)
             endif
             call fmcsmpy_r1(mxy(11), mxy(8), qx)
          enddo
          call fmln(mxy(11), mxy(4), qx)
          qx%ndigli = 0
          call fmsub(mxy(10), mxy(4), mxy(3), qx)
          call fmcancel(mxy(10), mxy(4), mxy(3), k, qx)
          n_acc = n_acc - k
          call fmeq(mxy(3), mxy(10), qx)
      endif

!             Use the reflection formula if ma was negative.

      if (mxy(1)%mp(1) < 0) then

!             Reduce the argument before multiplying by pi.

          call fmnint(mxy(13), mxy(6), qx)
          call fmdivi(mxy(6), 2, mxy(7), qx)
          call fmint(mxy(7), mxy(2), qx)
          call fmmpyi(mxy(2), 2, mxy(8), qx)
          ksign = -1
          if (fmcomp(mxy(6), '==', mxy(8), qx)) ksign = 1
          call fmsub(mxy(13), mxy(6), mxy(9), qx)
          call fmcancel(mxy(13), mxy(6), mxy(9), k, qx)
          n_acc = n_acc - k
          call fmpi(mxy(11), qx)
          qx%ndigpi = 0
          call fmmpy_r1(mxy(11), mxy(9), qx)
          krsave = qx%krad
          qx%krad = 1
          call fmsin(mxy(11), mxy(3), qx)
          mxy(3)%mp(1) = ksign*mxy(3)%mp(1)
          qx%krad = krsave
          call fmpi(mxy(11), qx)
          qx%ndigpi = 0
          call fmdiv_r2(mxy(11), mxy(3), qx)
          call fmln(mxy(3), mxy(4), qx)
          qx%ndigli = 0
          call fmsub(mxy(4), mxy(10), mxy(3), qx)
          call fmcancel(mxy(4), mxy(10), mxy(3), k, qx)
          n_acc = n_acc - k
          call fmeq(mxy(3), mxy(10), qx)
      endif

      call fmeq(mxy(10), mresult, qx)

      return
      end subroutine fmlngm_m2

      subroutine fmlngm_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = ln(gamma(ma)).

!  kresult = 1 is returned if a special case gives the value of ln(gamma(ma)).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      double precision :: b, xe, xf, ye, yf, ze, zf
      integer :: j
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMLNGM   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if ((malocal%mp(2) == qx%mexpun .or. (malocal%mp(2) == qx%munkno .and.  &
          malocal%mp(5) < 0 .and. malocal%mp(4) < -ndsave)) .and. malocal%mp(1) > 0) then
          call fmln(malocal, mresult, qx)
          qx%ndigli = 0
          call fmnegate(mresult, qx)
          kresult = 1
          return
      endif
      if ((malocal%mp(2) == qx%mexpov .or. (malocal%mp(2) == qx%munkno .and.  &
          malocal%mp(5) < 0 .and. malocal%mp(4) > ndsave)) .and. malocal%mp(1) > 0) then
          call fmovun_xexf(malocal, xe, xf, qx)
          b = qx%mbase
          ye = ceiling( log( xe*log(b) + log(xf) - 1 ) / log(b) )
          yf = ( xe*log(b) + log(xf) - 1 ) / b**ye
          ze = xe + ye
          zf = xf * yf
          if (zf < 1/b) then
              ze = ze - 1
              zf = zf * b
          endif
          if (ze == ze + 1.0d0) zf = 1.0d0 - epsilon(zf)
          if (ze > qx%mxexp0) then
              call fmoverflow(1, mresult, qx)
          else
              call fmunknown(mresult, qx)
          endif
          mresult%mp(4) = ze
          mresult%mp(5) = -zf*maxint
          kresult = 1
          return
      endif

      return
      end subroutine fmlngm_sc

      subroutine fmlni(ival, ma, qx)

!  ma = ln(ival)

!  Compute the natural logarithm of an integer ival.

!  If ival has only powers of 2, 3, 5, and 7 in its factorization then fmlni is faster than fmln.
!  Otherwise, if ival >= mxbase (i.e., ival does not fit in 1/2 word) then fmln is usually faster.

!  Use fmln instead of fmlni if 10*ival would cause integer overflow.

      use fmvals_parallel
      implicit none

      type(multi) :: mln2, mln3, mln5, mln7
      integer :: ival
      type(multi) :: ma
      intent (in) :: ival
      intent (inout) :: ma
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(6), mresult

      call fmalloc(ma, qx%ndig+2, qx)
      call fmenteri(kovun, mxsave, ndsave, qx)
      call fmlni_sc(ival, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, ma, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call fmlni_m1(ival, mxy, mresult, mln2, mln3, mln5, mln7, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, ma, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmlni

      subroutine fmlni2(int1, int2, ma, qx)

!  ma = ln(1 - int1/int2)

!  Taylor series for computing the logarithm of a rational number near 1.

      use fmvals_parallel
      implicit none

      integer :: int1, int2
      type(multi) :: ma
      intent (in) :: int1, int2
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: j, ndsave
      type(multi) :: mxy(2)

      call fmalloc(ma, qx%ndig+2, qx)

      call fmi2m(int1, mxy(2), qx)
      call fmdivi_r1(mxy(2), int2, qx)
      call fmeq(mxy(2), ma, qx)
      ndsave = qx%ndig
      j = 1

      qx%kflag = 0
      do while (qx%kflag /= 1)
         j = j + 1
         if (int1 /= 1) call fmmpyi_r1(mxy(2), int1, qx)
         call fmdivi_r1(mxy(2), int2, qx)
         call fmdivi(mxy(2), j, mxy(1), qx)
         qx%ndig = ndsave
         call fmadd_r1(ma, mxy(1), qx)
         call fmndig(ndsave - int(ma%mp(2)-mxy(1)%mp(2)), qx)
         if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
      enddo

      qx%ndig = ndsave
      call fmnegate(ma, qx)

      return
      end subroutine fmlni2

      subroutine fmlni3(mln2, mln3, mln5, mln7, qx)

!  Binary splitting version.  faster for large ndig.

!  Compute the four saved constants ln(2), ln(3), ln(5), ln(7).

      use fmvals_parallel
      implicit none

      type(multi) :: mln2, mln3, mln5, mln7
      real (kind(1.0d0)) :: mxsave
      integer :: k, ndsave, n
      type(multi) :: mxy(6)
      type(fm_settings) :: qx

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      ndsave = qx%ndig
      if (qx%ncall == 1) then
          k = max(qx%ngrd52-1, 2)
          call fmndig(max(qx%ndig+k, 3), qx)
      endif
      mxsave = qx%mxexp
      qx%mxexp = qx%mxexp2

!             Determine k, the number of terms to sum in the series for
!             Ln( (n+1) / (n-1) ) = (2/n)*( 1 + 1/(3*d) + 1/(5*d**2) + ...), with d = n**2.
!             Four calls are made:  n = 251, 449, 4801, 8549.

      n = 251
      k = qx%ndig*qx%dlogmb/log(dble(n)**2) + 10
      call fmlni3_qbt(0, k, n, mxy(1), mxy(2), mxy(3), qx)
      call imi2fm(mxy(1), mxy(4), qx)
      call imi2fm(mxy(2), mxy(5), qx)
      call imi2fm(mxy(3), mxy(6), qx)
      call fmdiv(mxy(6), mxy(5), mxy(2), qx)
      call fmdiv(mxy(2), mxy(4), mxy(1), qx)
      call fmmpyi(mxy(1), 2, mxy(2), qx)
      call fmdivi(mxy(2), n, mln2, qx)

      n = 449
      k = qx%ndig*qx%dlogmb/log(dble(n)**2) + 10
      call fmlni3_qbt(0, k, n, mxy(1), mxy(2), mxy(3), qx)
      call imi2fm(mxy(1), mxy(4), qx)
      call imi2fm(mxy(2), mxy(5), qx)
      call imi2fm(mxy(3), mxy(6), qx)
      call fmdiv(mxy(6), mxy(5), mxy(2), qx)
      call fmdiv(mxy(2), mxy(4), mxy(1), qx)
      call fmmpyi(mxy(1), 2, mxy(2), qx)
      call fmdivi(mxy(2), n, mln3, qx)

      n = 4801
      k = qx%ndig*qx%dlogmb/log(dble(n)**2) + 10
      call fmlni3_qbt(0, k, n, mxy(1), mxy(2), mxy(3), qx)
      call imi2fm(mxy(1), mxy(4), qx)
      call imi2fm(mxy(2), mxy(5), qx)
      call imi2fm(mxy(3), mxy(6), qx)
      call fmdiv(mxy(6), mxy(5), mxy(2), qx)
      call fmdiv(mxy(2), mxy(4), mxy(1), qx)
      call fmmpyi(mxy(1), 2, mxy(2), qx)
      call fmdivi(mxy(2), n, mln5, qx)

      n = 8749
      k = qx%ndig*qx%dlogmb/log(dble(n)**2) + 10
      call fmlni3_qbt(0, k, n, mxy(1), mxy(2), mxy(3), qx)
      call imi2fm(mxy(1), mxy(4), qx)
      call imi2fm(mxy(2), mxy(5), qx)
      call imi2fm(mxy(3), mxy(6), qx)
      call fmdiv(mxy(6), mxy(5), mxy(2), qx)
      call fmdiv(mxy(2), mxy(4), mxy(1), qx)
      call fmmpyi(mxy(1), 2, mxy(2), qx)
      call fmdivi(mxy(2), n, mln7, qx)

!             Get Ln(2).

      call fmmpyi_r1(mln2, 72, qx)
      call fmmpyi(mln3, 27, mxy(3), qx)
      call fmadd_r1(mln2, mxy(3), qx)
      call fmmpyi(mln5, -19, mxy(3), qx)
      call fmadd_r1(mln2, mxy(3), qx)
      call fmmpyi(mln7, 31, mxy(3), qx)
      call fmadd_r1(mln2, mxy(3), qx)

!             Get Ln(3).

      call fmmpyi_r1(mln3, 3, qx)
      call fmmpyi(mln2, 19, mxy(3), qx)
      call fmadd_r1(mln3, mxy(3), qx)
      call fmadd_r1(mln3, mln5, qx)
      call fmsub_r1(mln3, mln7, qx)
      call fmdivi_r1(mln3, 12, qx)

!             Get Ln(5).

      call fmadd_r1(mln5, mln2, qx)
      call fmmpyi(mln3, 27, mxy(3), qx)
      call fmsub_r2(mxy(3), mln5, qx)
      call fmmpyi(mln7, 4, mxy(3), qx)
      call fmadd_r1(mln5, mxy(3), qx)
      call fmdivi_r1(mln5, 18, qx)

!             Get Ln(7).

      call fmadd_r2(mln2, mln7, qx)
      call fmmpyi(mln3, 7, mxy(3), qx)
      call fmadd_r1(mln7, mxy(3), qx)
      call fmmpyi(mln5, -4, mxy(3), qx)
      call fmadd_r1(mln7, mxy(3), qx)

      qx%mxexp = mxsave
      qx%ndig = ndsave

      return
      end subroutine fmlni3

      recursive subroutine fmlni3_qbt(a, b, n, mq, mb, mt, qx)

!  This routine does the binary splitting for computing the constant Ln( (n+1) / (n-1) ).

      use fmvals_parallel
      implicit none

      type(multi) :: mq, mb, mt
      integer :: a, b, n
      intent (in) :: a, b, n
      intent (inout) :: mq, mb, mt
      type(fm_settings) :: qx

      type(multi) :: mxy(6)
      integer :: j, km, result_size
      real (kind(0.0d0)) :: da, db

      da = a
      db = b
      result_size = ( (db - da + 1)*log(dble(n)**2) ) / qx%dlogmb + 7
      result_size = max(5, result_size)
      call fmalloc(mq, result_size, qx)
      j = result_size
      result_size = ( (db+1.5d0)*log(db+2) - db + 1/(12*(db+2)) -          &
                      ( (da+0.5d0)*log(da+1) - da + 1/(12*(da+1)) ) - 1 +  &
                      (db-da+1)*log(2.0d0) ) / qx%dlogmb + 7
      call fmalloc(mb, result_size, qx)
      result_size = result_size + j
      call fmalloc(mt, result_size, qx)

      if (b-a < 6) then
          call fmalloc(mxy(1), result_size, qx)
          call fmalloc(mxy(2), result_size, qx)
          call fmalloc(mxy(3), result_size, qx)
          call fmalloc(mxy(4), result_size, qx)
          call fmalloc(mxy(5), result_size, qx)
          call imi2m(n, mxy(2), qx)
          call imsqr(mxy(2), mxy(1), qx)
          call imi2m(b-a+1, mxy(2), qx)
          call impwr(mxy(1), mxy(2), mq, qx)

          call imi2m(1, mb, qx)
          do j = a+1, b, 2
             call immpyi(mb, 2*j-1, mxy(1), qx)
             call immpyi(mxy(1), 2*j+1, mb, qx)
          enddo
          if (mod(b-a, 2) == 0) then
              call immpyi(mb, 2*b+1, mxy(1), qx)
              call imeq(mxy(1), mb, qx)
          endif

!             mt is the sum
!             mxy(2) is (n*n)**(j+1)

          call imdivi(mb, 2*b+1, mxy(1), qx)
          call immpyi(mxy(1), n, mxy(2), qx)
          call immpyi(mxy(2), n, mt, qx)
          call imi2m(n, mxy(1), qx)
          call imsqr(mxy(1), mxy(2), qx)
          do j = 1, b-a
             call imdivi(mb, 2*b+1-2*j, mxy(3), qx)
             call immpyi(mxy(2), n, mxy(4), qx)
             call immpyi(mxy(4), n, mxy(2), qx)
             call immpy(mxy(2), mxy(3), mxy(4), qx)
             call imadd(mt, mxy(4), mxy(5), qx)
             call imeq(mxy(5), mt, qx)
          enddo
          return
      endif

      km = a/2 + b/2 + mod(a, 2)*mod(b, 2)
      call fmlni3_qbt(a, km-1, n, mxy(1), mxy(2), mxy(3), qx)
      call fmlni3_qbt(km, b, n, mxy(4), mxy(5), mxy(6), qx)
      call immpy(mxy(1), mxy(4), mq, qx)
      call immpy(mxy(2), mxy(5), mb, qx)
      call immpy(mxy(5), mxy(4), mt, qx)
      call immpy(mxy(3), mt, mxy(1), qx)
      call immpy(mxy(2), mxy(6), mxy(3), qx)
      call imadd(mxy(1), mxy(3), mt, qx)

      return
      end subroutine fmlni3_qbt

      subroutine fmlni4(ival, nt, ma, qx)

!  Binary splitting version.  Faster for large ndig.

!  ma = ln(ival/nt).

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: ival, nt
      intent (in) :: ival, nt
      intent (inout) :: ma
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: a, b, k, ndsave, level_of_recursion
      type(multi) :: mxy(7)

      call fmalloc(ma, qx%ndig+2, qx)
      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      ndsave = qx%ndig
      if (qx%ncall == 1) then
          k = max(qx%ngrd52-1, 2)
          call fmndig(max(qx%ndig+k, 3), qx)
      endif
      mxsave = qx%mxexp
      qx%mxexp = qx%mxexp2

!             Determine k, the number of terms to sum in the series for
!             Ln( (b+a) / (b-a) ) = (2*a/b)*( 1 + 1/(3*d) + 1/(5*d**2) + ...), with d = (b/a)**2.

      a = abs(ival - nt)
      b = ival + nt
      call fmgcdi(a, b)
      if (ival-nt < 0) a = -a
      k = qx%ndig*qx%dlogmb/log(dble(b)**2/dble(a)**2) + 10
      level_of_recursion = 0
      call fmlni4_pqbt(0, k, a, b, mxy(1), mxy(2), mxy(3), mxy(4), level_of_recursion, qx)
      call imi2fm(mxy(2), mxy(5), qx)
      call imi2fm(mxy(3), mxy(6), qx)
      call imi2fm(mxy(4), mxy(7), qx)
      call fmdiv(mxy(7), mxy(6), mxy(2), qx)
      call fmdiv(mxy(2), mxy(5), mxy(1), qx)
      call fmmpyi(mxy(1), 2*a, mxy(2), qx)
      call fmdivi(mxy(2), b, mxy(3), qx)

      call fmequ(mxy(3), ma, qx%ndig, ndsave, qx)
      qx%mxexp = mxsave
      qx%ndig = ndsave

      return
      end subroutine fmlni4

      recursive subroutine fmlni4_pqbt(a, b, c, d, mp, mq, mb, mt, level_of_recursion, qx)

!  This routine does the binary splitting for computing the constant Ln( (b+a) / (b-a) ).

      use fmvals_parallel
      implicit none

      type(multi) :: mp, mq, mb, mt
      integer :: a, b, c, d, level_of_recursion
      intent (in) :: a, b, c, d
      intent (inout) :: mp, mq, mb, mt, level_of_recursion
      type(fm_settings) :: qx

      type(multi) :: mxy(8)
      integer :: j, km, result_size
      real (kind(0.0d0)) :: da, db

      da = a
      db = b
      result_size = ( (db - da + 1)*log(dble(c)**2) ) / qx%dlogmb + 7
      result_size = max(5, result_size)
      call fmalloc(mp, result_size, qx)
      result_size = ( (db - da + 1)*log(dble(d)**2) ) / qx%dlogmb + 7
      result_size = max(5, result_size)
      call fmalloc(mq, result_size, qx)
      j = result_size
      result_size = ( (db+1.5d0)*log(db+2) - db + 1/(12*(db+2)) -          &
                      ( (da+0.5d0)*log(da+1) - da + 1/(12*(da+1)) ) - 1 +  &
                      (db-da+1)*log(2.0d0) ) / qx%dlogmb + 7
      call fmalloc(mb, result_size, qx)
      result_size = result_size + j
      call fmalloc(mt, result_size, qx)
      level_of_recursion = level_of_recursion + 1

      if (b-a < 6) then
          call fmalloc(mxy(1), result_size, qx)
          call fmalloc(mxy(2), result_size, qx)
          call fmalloc(mxy(3), result_size, qx)
          call fmalloc(mxy(4), result_size, qx)
          call fmalloc(mxy(5), result_size, qx)
          call imi2m(c, mxy(2), qx)
          call imsqr(mxy(2), mxy(1), qx)
          call imi2m(b-a+1, mxy(2), qx)
          call impwr(mxy(1), mxy(2), mp, qx)

          call imi2m(d, mxy(2), qx)
          call imsqr(mxy(2), mxy(1), qx)
          call imi2m(b-a+1, mxy(2), qx)
          call impwr(mxy(1), mxy(2), mq, qx)

          call imi2m(1, mb, qx)
          do j = a+1, b, 2
             call immpyi(mb, 2*j-1, mxy(1), qx)
             call immpyi(mxy(1), 2*j+1, mb, qx)
          enddo
          if (mod(b-a, 2) == 0) then
              call immpyi(mb, 2*b+1, mxy(1), qx)
              call imeq(mxy(1), mb, qx)
          endif

          call imi2m(d, mxy(1), qx)
          call imsqr(mxy(1), mxy(2), qx)
          call imi2m(b-a+1, mxy(1), qx)
          call impwr(mxy(2), mxy(1), mxy(3), qx)

          call imi2m(1, mxy(4), qx)
          call imi2m(0, mt, qx)

          do j = a, b
             call imdivi(mb, 2*j+1, mxy(1), qx)
             call immpy(mxy(1), mxy(3), mxy(2), qx)
             call immpy(mxy(2), mxy(4), mxy(1), qx)
             call imadd(mt, mxy(1), mxy(5), qx)
             call imeq(mxy(5), mt, qx)
             call imdivi(mxy(3), d, mxy(5), qx)
             call imdivi(mxy(5), d, mxy(3), qx)
             call immpyi(mxy(4), c, mxy(5), qx)
             call immpyi(mxy(5), c, mxy(4), qx)
          enddo
      else

          km = a/2 + b/2 + mod(a, 2)*mod(b, 2)
          call fmlni4_pqbt(a, km-1, c, d, mxy(1), mxy(2), mxy(3), mxy(4), level_of_recursion, qx)
          call fmlni4_pqbt(km, b, c, d, mxy(5), mxy(6), mxy(7), mxy(8), level_of_recursion, qx)

!             mp is not needed in fmlni4, so this multiplication can be skipped at the top level
!             of the recursion.

          if (level_of_recursion > 1) then
              call immpy(mxy(1), mxy(5), mp, qx)
          else
              call imi2m(0, mp, qx)
          endif
          call immpy(mxy(2), mxy(6), mq, qx)
          call immpy(mxy(3), mxy(7), mb, qx)
          call immpy(mxy(6), mxy(7), mt, qx)
          call immpy(mxy(4), mt, mxy(5), qx)
          call immpy(mxy(1), mxy(3), mt, qx)
          call immpy(mxy(8), mt, mxy(2), qx)
          call imadd(mxy(5), mxy(2), mt, qx)
      endif

      level_of_recursion = level_of_recursion - 1

      return
      end subroutine fmlni4_pqbt

      subroutine fmlni_m1(ival, mxy, mresult, mln2, mln3, mln5, mln7, qx)

!  Method 1 for computing ln(ival).

      use fmvals_parallel
      implicit none

      type(multi) :: mln2, mln3, mln5, mln7
      type(multi) :: mxy(6), mresult
      integer :: ival
      intent (in) :: ival
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      character(155) :: string
      character :: st2(155)
      integer :: int2, j, k, k2, k3, k5, k7, n, nd, ndsave, ndmb, ndsv, nt
      qx%ndigli = 0
      qx%mbsli = 0

!             Increase the working precision.

      ndsave = qx%ndig
      if (qx%ncall == 1) then
          k = qx%ngrd52
          call fmndig(max(qx%ndig+k, 3), qx)
      endif

!             Find integers k2, k3, k5, and k7 such that
!                nt = 2**k2 * 3**k3 * 5**k5 * 7**k7
!             is a good approximation of ival.

      int2 = ival
      if (ival > intmax/100) int2 = ival/100
      nt = 0
      k2 = 0
      k3 = 0
      k5 = 0
      k7 = 0
      call fmlni_m1b(k2, k3, k5, k7, int2, nt, qx)

!             If ival was too close to the integer overflow limit, restore nt to an
!             approximation of ival.

      if (int2 /= ival) then
          if (nt <= int2) then
              nt = nt*100
              k2 = k2 + 2
              k5 = k5 + 2
          else if (nt <= ival/98) then
              nt = nt*98
              k2 = k2 + 1
              k7 = k7 + 2
          else
              nt = nt*70
              k2 = k2 + 1
              k5 = k5 + 1
              k7 = k7 + 1
          endif
      endif

!             Compute ln(nt) as a linear combination of ln(2), ln(3), ln(5), and ln(7).

      if (qx%mbase /= qx%mbsli .or. qx%ndig > qx%ndigli) then
          ndmb = int(150.0*2.302585/qx%alogmb)
          if (ndmb >= qx%ndig) then
              ndsv = qx%ndig
              call fmndig(ndmb, qx)
              string = '0.693147180559945309417232121458176568075500'//  &
              '13436025525412068000949339362196969471560586332699641'//  &
              '8687542001481020570685733685520235758130557032670751635'
              k = min(int(qx%ndig * qx%dlogmb / qx%dlogtn + 2), len(string))
              do j = 1, k
                 st2(j) = string(j:j)
              enddo
              call fminp(st2, mln2, 1, k, qx)
              string = '1.098612288668109691395245236922525704647490'//  &
              '55782274945173469433363749429321860896687361575481373'//  &
              '2088787970029065957865742368004225930519821052801870767'
              k = min(int((qx%ndig-1) * qx%dlogmb / qx%dlogtn + 2), len(string))
              do j = 1, k
                 st2(j) = string(j:j)
              enddo
              call fminp(st2, mln3, 1, k, qx)
              string = '1.609437912434100374600759333226187639525601'//  &
              '35426851772191264789147417898770765776463013387809317'//  &
              '9610799966303021715562899724005229324676199633616617464'
              k = min(int((qx%ndig-1) * qx%dlogmb / qx%dlogtn + 2), len(string))
              do j = 1, k
                 st2(j) = string(j:j)
              enddo
              call fminp(st2, mln5, 1, k, qx)
              string = '1.945910149055313305105352743443179729637084'//  &
              '72958186118845939014993757986275206926778765849858787'//  &
              '1526993061694205851140911723752257677786843148958095164'
              k = min(int((qx%ndig-1) * qx%dlogmb / qx%dlogtn + 2), len(string))
              do j = 1, k
                 st2(j) = string(j:j)
              enddo
              call fminp(st2, mln7, 1, k, qx)
              qx%mbsli = qx%mbase
              qx%ndigli = qx%ndig
              if (abs(mln2%mp(2)) > 10 .or. abs(mln3%mp(2)) > 10 .or.  &
                  abs(mln5%mp(2)) > 10 .or. abs(mln7%mp(2)) > 10) qx%ndigli = 0
          else
              ndsv = qx%ndig
              call fmndig(qx%ndig + 2 + qx%ndig/100, qx)
              qx%mbsli = qx%mbase
              qx%ndigli = qx%ndig

!                 If precision is high, use the binary splitting method.

              if (qx%ndig < 40) then

                  call fmlni2(1, 126, mln2, qx)
                  call fmlni2(1, 225, mln3, qx)
                  call fmlni2(1, 2401, mln5, qx)
                  call fmlni2(1, 4375, mln7, qx)

!                    Get Ln(2).

                  call fmmpyi_r1(mln2, -72, qx)
                  call fmmpyi(mln3, -27, mxy(3), qx)
                  call fmadd_r1(mln2, mxy(3), qx)
                  call fmmpyi(mln5, 19, mxy(3), qx)
                  call fmadd_r1(mln2, mxy(3), qx)
                  call fmmpyi(mln7, -31, mxy(3), qx)
                  call fmadd_r1(mln2, mxy(3), qx)

!                    Get Ln(3).

                  call fmmpyi_r1(mln3, -3, qx)
                  call fmmpyi(mln2, 19, mxy(3), qx)
                  call fmadd_r1(mln3, mxy(3), qx)
                  call fmsub_r1(mln3, mln5, qx)
                  call fmadd_r1(mln3, mln7, qx)
                  call fmdivi_r1(mln3, 12, qx)

!                    Get Ln(5).

                  call fmsub_r1(mln5, mln2, qx)
                  call fmmpyi(mln3, 27, mxy(3), qx)
                  call fmadd_r1(mln5, mxy(3), qx)
                  call fmmpyi(mln7, -4, mxy(3), qx)
                  call fmadd_r1(mln5, mxy(3), qx)
                  call fmdivi_r1(mln5, 18, qx)

!                    Get Ln(7).

                  call fmsub_r2(mln2, mln7, qx)
                  call fmmpyi(mln3, 7, mxy(3), qx)
                  call fmadd_r1(mln7, mxy(3), qx)
                  call fmmpyi(mln5, -4, mxy(3), qx)
                  call fmadd_r1(mln7, mxy(3), qx)
              else
                  call fmlni3(mln2, mln3, mln5, mln7, qx)
              endif
          endif
          if (abs(mln2%mp(2)) > 10 .or. abs(mln3%mp(2)) > 10 .or.  &
              abs(mln5%mp(2)) > 10 .or. abs(mln7%mp(2)) > 10) qx%ndigli = 0
          call fmndig(ndsv, qx)
      endif

!             If nt /= ival then the final step is to compute ln(ival/nt) and then use
!             ln(ival) = ln(ival/nt) + ln(nt).

      if (nt /= ival) then
          nd = nt - ival
          if (qx%ndig < 40) then
              call fmlni2(nd, nt, mxy(3), qx)
          else
              if (ival == nt-1) then
                  n = 2*ival + 1
                  k = qx%ndig*qx%dlogmb/log(dble(n)**2) + 10
                  call fmlni3_qbt(0, k, n, mxy(1), mxy(2), mxy(3), qx)
                  call imi2fm(mxy(1), mxy(4), qx)
                  call imi2fm(mxy(2), mxy(5), qx)
                  call imi2fm(mxy(3), mxy(6), qx)
                  call fmdiv(mxy(6), mxy(5), mxy(2), qx)
                  call fmdiv(mxy(2), mxy(4), mxy(1), qx)
                  call fmmpyi(mxy(1), -2, mxy(2), qx)
                  call fmdivi(mxy(2), n, mxy(3), qx)
              else if (ival == nt+1) then
                  n = 2*ival - 1
                  k = qx%ndig*qx%dlogmb/log(dble(n)**2) + 10
                  call fmlni3_qbt(0, k, n, mxy(1), mxy(2), mxy(3), qx)
                  call imi2fm(mxy(1), mxy(4), qx)
                  call imi2fm(mxy(2), mxy(5), qx)
                  call imi2fm(mxy(3), mxy(6), qx)
                  call fmdiv(mxy(6), mxy(5), mxy(2), qx)
                  call fmdiv(mxy(2), mxy(4), mxy(1), qx)
                  call fmmpyi(mxy(1), 2, mxy(2), qx)
                  call fmdivi(mxy(2), n, mxy(3), qx)
              else if (ival == nt-2) then
                  n = ival + 1
                  k = qx%ndig*qx%dlogmb/log(dble(n)**2) + 10
                  call fmlni3_qbt(0, k, n, mxy(1), mxy(2), mxy(3), qx)
                  call imi2fm(mxy(1), mxy(4), qx)
                  call imi2fm(mxy(2), mxy(5), qx)
                  call imi2fm(mxy(3), mxy(6), qx)
                  call fmdiv(mxy(6), mxy(5), mxy(2), qx)
                  call fmdiv(mxy(2), mxy(4), mxy(1), qx)
                  call fmmpyi(mxy(1), -2, mxy(2), qx)
                  call fmdivi(mxy(2), n, mxy(3), qx)
              else if (ival == nt+2) then
                  n = ival - 1
                  k = qx%ndig*qx%dlogmb/log(dble(n)**2) + 10
                  call fmlni3_qbt(0, k, n, mxy(1), mxy(2), mxy(3), qx)
                  call imi2fm(mxy(1), mxy(4), qx)
                  call imi2fm(mxy(2), mxy(5), qx)
                  call imi2fm(mxy(3), mxy(6), qx)
                  call fmdiv(mxy(6), mxy(5), mxy(2), qx)
                  call fmdiv(mxy(2), mxy(4), mxy(1), qx)
                  call fmmpyi(mxy(1), 2, mxy(2), qx)
                  call fmdivi(mxy(2), n, mxy(3), qx)
              else
                  call fmlni4(ival, nt, mxy(3), qx)
              endif
          endif
      endif

      call fmmpyi(mln2, k2, mxy(2), qx)
      call fmmpyi(mln3, k3, mxy(1), qx)
      call fmadd_r1(mxy(2), mxy(1), qx)
      call fmmpyi(mln5, k5, mxy(1), qx)
      call fmadd_r1(mxy(2), mxy(1), qx)
      call fmmpyi(mln7, k7, mxy(1), qx)
      if (nt /= ival) call fmadd_r1(mxy(2), mxy(3), qx)
      call fmadd(mxy(2), mxy(1), mxy(3), qx)
      call fmequ(mxy(3), mresult, qx%ndig, ndsave, qx)
      qx%ndig = ndsave

      return
      end subroutine fmlni_m1

      subroutine fmlni_m1b(k2, k3, k5, k7, int2, nt, qx)

!  Find values k2, k3, k5, k7, such that  nt = 2**k2 * 3**k3 * 5**k5 * 7**k7
!  is a good approximation of ival.
!  kdelta = abs(ival - nt).

      use fmvals_parallel
      implicit none

      integer :: k2, k3, k5, k7, int2, nt
      intent (in) :: int2
      intent (inout) :: k2, k3, k5, k7, nt
      type(fm_settings) :: qx

      integer :: j2, j3, j5, j7, jtemp2, jtemp3, jtemp5, jtemp7, kdelta, last
      double precision :: xval

      xval = int2
      last = int(log(dble(xval))/qx%dlogtw + 2.0d0)
      kdelta = int2

      jtemp7 = 1
      do j7 = 1, last
         if (jtemp7 > int2 .and. abs(jtemp7-int2) > kdelta) exit

         jtemp5 = jtemp7
         do j5 = 1, last
            if (jtemp5 > int2 .and. abs(jtemp5-int2) > kdelta) exit

            jtemp3 = jtemp5
            do j3 = 1, last
               if (jtemp3 > int2 .and. abs(jtemp3-int2) > kdelta) exit

               jtemp2 = jtemp3
               do j2 = 1, last
                  if (abs(jtemp2-int2) <= kdelta) then
                      if (abs(jtemp2-int2) == kdelta .and. jtemp2 < int2) exit
                      kdelta = abs(jtemp2-int2)
                      nt = jtemp2
                      k2 = j2 - 1
                      k3 = j3 - 1
                      k5 = j5 - 1
                      k7 = j7 - 1
                      if (kdelta == 0) return
                  endif
                  if (jtemp2 > int2) exit

                  jtemp2 = 2*jtemp2
               enddo

               jtemp3 = 3*jtemp3
            enddo

            jtemp5 = 5*jtemp5
         enddo

         jtemp7 = 7*jtemp7
      enddo

      return
      end subroutine fmlni_m1b

      subroutine fmlni_sc(ival, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = ln(ival).

!  kresult = 1 is returned if a special case gives the value of ln(ival).

      use fmvals_parallel
      implicit none

      type(multi) :: mresult
      integer :: ival, kresult, ndsave
      intent (in) :: ival, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j

      kresult = 0

      qx%namest(qx%ncall) = 'FMLNI    '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inpi(ival, qx)
      call fmndig(j, qx)

      if (ival <= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (ival == 1) then
          call fmi2m(0, mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine fmlni_sc

      subroutine fmlog10(ma, mb, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      call fmlg10(ma, mb, qx)
      qx%ndigli = 0

      return
      end subroutine fmlog10

      subroutine fmm2dp(ma, x, qx)

!  x = ma

!  Convert an fm number to double precision.

!  If kflag = -4 is returned for a value of ma that is in the range of the machine's double
!  precision number system, change the definition of dpmax in routine fmset to reflect the
!  current machine's range.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      double precision :: x
      intent (in) :: ma
      intent (inout) :: x
      type(fm_settings) :: qx

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMM2DP'
      if (qx%ntrace /= 0) call fmntr_inp1(ma, qx)

      if (ma%mp(2) == qx%mexpov .or. (ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0)) then

!             Here no valid result can be returned.
!             Set x to some value that the user is likely to recognize as wrong.

          x = dble(qx%runkno)
          qx%kflag = -4
          if (ma%mp(2) /= qx%munkno) call fmwarn(qx)
          if (qx%ntrace /= 0) call fmntr_outd(x, qx)
          qx%ncall = qx%ncall - 1
          return
      endif

      call fmm2dp2(ma, x, qx)

      if (qx%ntrace /= 0) call fmntr_outd(x, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmm2dp

      subroutine fmm2dp2(ma, x, qx)

!  x = ma

!  Internal routine for conversion to double precision.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      double precision :: x
      intent (in) :: ma
      intent (inout) :: x
      type(fm_settings) :: qx

      double precision :: aq(2), xq(2), yq(2), y1(2), y2(2), xbase, pmax, dlogdp,  &
                          a1, a2, c, c1, c2, c21, c22, q1, q2, t, xe, xf, xmax, ye, yf, z1, z2
      real (kind(1.0d0)) :: ma1
      integer :: j, k, ke, kl, kwrnsv, ncase

!             Check to see if ma is in range for single or double precision.

      if (ma%mp(2) == qx%munkno) then
          if (ma%mp(5) < 0) then
              call fmovun_xexf(ma, xe, xf, qx)
              if (xe > 0) then
                  ye = aint( log(huge(x)) / log(qx%mbase) + 1 )
                  yf = exp( log(huge(x)) - ye*log(qx%mbase) )
                  if (xe > ye .or. (xe == ye .and. xf > yf)) then
                      qx%kflag = -4
                      x = dble(qx%runkno)
                  else
                      qx%kflag = 0
                      x = dble(qx%mbase)**xe * xf
                      if (ma%mp(1) < 0) x = -x
                  endif
              else if (xe <= 0) then
                  ye = aint( log(tiny(x)) / log(qx%mbase) )
                  yf = exp( log(tiny(x)) - ye*log(qx%mbase) )
                  if (xe < ye .or. (xe == ye .and. xf <= yf)) then
                      qx%kflag = -4
                      x = dble(qx%runkno)
                  else
                      qx%kflag = 0
                      x = dble(qx%mbase)**xe * xf
                      if (ma%mp(1) < 0) x = -x
                  endif
              endif
          else
              qx%kflag = -4
              x = dble(qx%runkno)
          endif
          return
      endif
      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      pmax = dpmax
      if (qx%ncall > 0) then
          if (qx%namest(qx%ncall) == 'FMM2SP') pmax = dble(spmax)
      endif
      dlogdp = log(pmax)
      ma1 = ma%mp(2)
      ncase = 0
      x = dble(qx%runkno)
      if (ma%mp(2)-1 > log(huge(x))/qx%dlogmb) then
          qx%kflag = -4
          x = dble(qx%runkno)
          call fmwarn(qx)
          return
      else if (ma%mp(2) < log(tiny(x))/qx%dlogmb) then
          qx%kflag = -10
          x = 0.0d0
          call fmwarn(qx)
          return
      endif
      if (ma%mp(2) > log(huge(x))/qx%dlogmb) then
          a1 = 0.0d0
          t = 1.0d0
          c = epsilon(t)/qx%mbase
          do j = 3, qx%ndig+2
             t = t/qx%mbase
             a2 = ma%mp(j)*t
             a1 = a1 + a2
             if (a2 < c) exit
          enddo
          if (ma%mp(2) + log(a1)/qx%dlogmb >= (log(huge(x))/qx%dlogmb)*(1.0d0-5*epsilon(t))) then
              qx%kflag = -4
              x = dble(qx%runkno)
              call fmwarn(qx)
              return
          else
              x = dble(qx%mbase)**ma%mp(2) * a1
              return
          endif
      else if (ma%mp(2)-1 < log(tiny(x))/qx%dlogmb) then
          a1 = 0.0d0
          t = 1.0d0
          c = epsilon(t)/qx%mbase
          do j = 3, qx%ndig+2
             t = t/qx%mbase
             a2 = ma%mp(j)*t
             a1 = a1 + a2
             if (a2 < c) exit
          enddo
          if (ma%mp(2) + log(a1)/qx%dlogmb <= (log(tiny(x))/qx%dlogmb)*(1.0d0+5*epsilon(t))) then
              qx%kflag = -10
              x = 0.0d0
              call fmwarn(qx)
              return
          else
              x = dble(qx%mbase)**ma%mp(2) * a1
              return
          endif
      endif
      if (dble(ma%mp(2)-1)*qx%dlogmb > dlogdp) then
          qx%kflag = -4
          x = dble(qx%runkno)
          call fmwarn(qx)
          return
      else if (dble(ma%mp(2)+1)*qx%dlogmb > dlogdp) then
          ma1 = ma1 - 2
          ncase = 1
      else if (dble(ma%mp(2)+1)*qx%dlogmb < -dlogdp) then
          qx%kflag = -10
          x = 0.0d0
          call fmwarn(qx)
          return
      else if (dble(ma%mp(2)-1)*qx%dlogmb < -dlogdp) then
          ma1 = ma1 + 2
          ncase = 2
      endif

!             Try fmm2i2 first so that small integers will be converted quickly.

      kwrnsv = qx%kwarn
      qx%kwarn = 0
      call fmm2i2(ma, j, qx)
      qx%kwarn = kwrnsv
      if (qx%kflag == 0) then
          x = j
          return
      endif
      qx%kflag = 0
      k = -2*log(epsilon(1.0d0))/qx%dlogmb + 1
      ke = ma%mp(2)
      kl = 0
      if (ke <= 0) then
          kl = 1
      else
          if (ke < k) then
              do j = ke+1, k
                 if (j > qx%ndig) exit
                 if (ma%mp(j+2) /= 0) then
                     kl = 1
                     exit
                 endif
              enddo
          endif
      endif
      if (kl == 0) then
          xmax = dble(radix(1.0d0))**digits(1.0d0)
          x = 0
          do j = 1, ke
             x = qx%mbase*x + ma%mp(j+2)
             if (x > xmax) then
                 kl = 1
                 exit
             endif
          enddo
          if (kl == 0) then
              if (ma%mp(1) < 0) x = -x
              return
          endif
      endif
      if (ma%mp(2) == 0) then
          k = 1
          do j = 4, qx%ndig+2
             if (ma%mp(j) /= 0) then
                 k = 0
                 exit
             endif
          enddo
          if (k == 1) then
              z1 = ma%mp(3)
              z2 = qx%mbase
              x = ma%mp(1) * (z1 / z2)
              return
          endif
      else if (ma%mp(2) == 1) then
          k = 1
          do j = 5, qx%ndig+2
             if (ma%mp(j) /= 0) then
                 k = 0
                 exit
             endif
          enddo
          if (k == 1) then
              q1 = ma%mp(3)
              z1 = ma%mp(4)
              z2 = qx%mbase
              q2 = z1 / z2
              x = ma%mp(1) * (q1 + q2)
              return
          endif
      endif

!             General case.
!             In order to get the correctly rounded x, the arithmetic for computing x is done
!             with simulated quadruple-precision using the arrays of length 2.

      xbase = qx%mbase
      xq = (/ 0.0d0 , 0.0d0 /)
      yq = (/ 1.0d0 , 0.0d0 /)
      c = radix(x)**(digits(x) - digits(x)/2) + 1
      k = (log(dble(radix(x)))/qx%dlogmb)*digits(x) + qx%ngrd52
      do j = 2, min(k+1, qx%ndig+1)
         z1 = yq(1) / xbase
         t = xbase*c
         a1 = (xbase - t) + t
         a2 = xbase - a1
         t = z1*c
         c1 = (z1 - t) + t
         c2 = z1 - c1
         t = c2*c
         c21 = (c2 - t) + t
         c22 = c2 - c21
         q1 = xbase*z1
         q2 = ((((a1*c1 - q1) + a1*c2) + c1*a2) + c21*a2) + c22*a2
         z2 = ((((yq(1)-q1) - q2) + yq(2))) / xbase
         yq(1) = z1 + z2
         yq(2) = (z1-yq(1)) + z2
         t = yq(1)*c
         a1 = (yq(1) - t) + t
         a2 = yq(1) - a1
         t = dble(ma%mp(j+1))*c
         c1 = (dble(ma%mp(j+1)) - t) + t
         c2 = dble(ma%mp(j+1)) - c1
         t = c2*c
         c21 = (c2 - t) + t
         c22 = c2 - c21
         q1 = yq(1)*dble(ma%mp(j+1))
         q2 = ((((a1*c1 - q1) + a1*c2) + c1*a2) + c21*a2) + c22*a2
         z2 = yq(2)*dble(ma%mp(j+1)) + q2
         aq(1) = q1 + z2
         aq(2) = (q1-aq(1)) + z2
         z1 = xq(1) + aq(1)
         q1 = xq(1) - z1
         z2 = (((q1+aq(1)) + (xq(1)-(q1+z1))) + xq(2)) + aq(2)
         xq(1) = z1 + z2
         xq(2) = (z1-xq(1)) + z2
      enddo

      y1 = (/ xbase , 0.0d0 /)
      k = abs(ma1)
      if (mod(k, 2) == 0) then
          y2 = (/ 1.0d0 , 0.0d0 /)
      else
          y2 = (/ xbase , 0.0d0 /)
      endif

      do
         k = k/2
         t = y1(1)*c
         a1 = (y1(1) - t) + t
         a2 = y1(1) - a1
         t = y1(1)*c
         c1 = (y1(1) - t) + t
         c2 = y1(1) - c1
         t = c2*c
         c21 = (c2 - t) + t
         c22 = c2 - c21
         q1 = y1(1)*y1(1)
         q2 = ((((a1*c1 - q1) + a1*c2) + c1*a2) + c21*a2) + c22*a2
         z2 = ((y1(1) + y1(2))*y1(2) + y1(2)*y1(1)) + q2
         y1(1) = q1 + z2
         y1(2) = (q1-y1(1)) + z2
         if (mod(k, 2) == 1) then
             t = y1(1)*c
             a1 = (y1(1) - t) + t
             a2 = y1(1) - a1
             t = y2(1)*c
             c1 = (y2(1) - t) + t
             c2 = y2(1) - c1
             t = c2*c
             c21 = (c2 - t) + t
             c22 = c2 - c21
             q1 = y1(1)*y2(1)
             q2 = ((((a1*c1 - q1) + a1*c2) + c1*a2) + c21*a2) + c22*a2
             z2 = ((y1(1) + y1(2))*y2(2) + y1(2)*y2(1)) + q2
             y2(1) = q1 + z2
             y2(2) = (q1-y2(1)) + z2
         endif
         if (k <= 1) exit
      enddo

      if (ma1 < 0) then
          z1 = xq(1) / y2(1)
          t = y2(1)*c
          a1 = (y2(1) - t) + t
          a2 = y2(1) - a1
          t = z1*c
          c1 = (z1 - t) + t
          c2 = z1 - c1
          t = c2*c
          c21 = (c2 - t) + t
          c22 = c2 - c21
          q1 = y2(1)*z1
          q2 = ((((a1*c1 - q1) + a1*c2) + c1*a2) + c21*a2) + c22*a2
          z2 = ((((xq(1)-q1) - q2) + xq(2)) - z1*y2(2)) / (y2(1) + y2(2))
          aq(1) = z1 + z2
          aq(2) = (z1-aq(1)) + z2
      else
          t = xq(1)*c
          a1 = (xq(1) - t) + t
          a2 = xq(1) - a1
          t = y2(1)*c
          c1 = (y2(1) - t) + t
          c2 = y2(1) - c1
          t = c2*c
          c21 = (c2 - t) + t
          c22 = c2 - c21
          q1 = xq(1)*y2(1)
          q2 = ((((a1*c1 - q1) + a1*c2) + c1*a2) + c21*a2) + c22*a2
          z2 = ((xq(1) + xq(2))*y2(2) + xq(2)*y2(1)) + q2
          aq(1) = q1 + z2
          aq(2) = (q1-aq(1)) + z2
      endif

      x = aq(1) + aq(2)

      if (ma%mp(1) < 0) x = -x

!             Check the result if it is near overflow or underflow.

      if (ncase == 1) then
          if (x <= pmax/(xbase*xbase)) then
              x = x*xbase*xbase
          else
              qx%kflag = -4
              x = dble(qx%runkno)
              call fmwarn(qx)
          endif
      else if (ncase == 2) then
          if (x >= (1.0d0/pmax)*xbase*xbase) then
              x = x/(xbase*xbase)
          else
              qx%kflag = -10
              x = 0.0d0
              call fmwarn(qx)
          endif
      endif

      return
      end subroutine fmm2dp2

      subroutine fmm2i(ma, ival, qx)

!  ival = ma

!  Convert an fm number to integer.

!  kflag =  0 is returned if the conversion is exact.
!        = -4 is returned if ma is larger than intmax in magnitude.  ival = iunkno is returned
!             as an indication that ival could not be computed without integer overflow.
!        =  2 is returned if ma is smaller than intmax in magnitude but ma is not an integer.
!             The next integer toward zero is returned in ival.
!  It is sometimes convenient to call fmm2i to see if an fm number can be represented as a one-word
!  integer, by checking kflag upon return.  To avoid an unwanted error message being printed in the
!  kflag=-4 case, set kwarn=0 before the call to fmm2i and reset it after the call.

!  This routine performs the trace printing for the conversion.
!  fmm2i2 is used to do the arithmetic.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ma
      intent (inout) :: ival
      type(fm_settings) :: qx

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMM2I'
      if (qx%ntrace /= 0) call fmntr_inp1(ma, qx)

      call fmm2i2(ma, ival, qx)

      if (qx%ntrace /= 0) call fmntr_outi(ival, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmm2i

      subroutine fmm2i2(ma, ival, qx)

!  ival = ma.  Internal fm to integer conversion routine.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ma
      intent (inout) :: ival
      type(fm_settings) :: qx

      integer :: j, ka, kb, large, n1

      qx%kflag = 0
      n1 = qx%ndig + 1
      large = int(intmax/qx%mbase)
      ival = 0
      if (ma%mp(2) <= 0) then
          if (ma%mp(3) /= 0) qx%kflag = 2
          return
      endif
      if (ma%mp(2) == qx%munkno .and. ma%mp(5) < 0 .and. ma%mp(4) < 0) then
          qx%kflag = 2
          return
      endif
      if (ma%mp(2) == qx%munkno .and. ma%mp(5) < 0 .and. ma%mp(4) >= 0) then
          qx%kflag = -4
          ival = qx%iunkno
          return
      endif

      kb = int(ma%mp(2)) + 1
      ival = int(abs(ma%mp(3)))
      if (kb >= 3) then
          do j = 3, kb
             if (ival > large) then
                 qx%kflag = -4
                 if (ma%mp(2) /= qx%munkno) call fmwarn(qx)
                 ival = qx%iunkno
                 return
             endif
             if (j <= n1) then
                 ival = ival*int(qx%mbase)
                 if (ival > intmax-ma%mp(j+1)) then
                     qx%kflag = -4
                     if (ma%mp(2) /= qx%munkno) call fmwarn(qx)
                     ival = qx%iunkno
                     return
                 else
                     ival = ival + int(ma%mp(j+1))
                 endif
             else
                 ival = ival*int(qx%mbase)
             endif
          enddo
      endif

      if (ma%mp(1) < 0) ival = -ival

!             Check to see if ma is an integer.

      ka = kb + 1
      if (ka <= n1) then
          do j = ka, n1
             if (ma%mp(j+1) /= 0) then
                 qx%kflag = 2
                 return
             endif
          enddo
      endif

      return
      end subroutine fmm2i2

      subroutine fmm2sp(ma, x, qx)

!  x = ma

!  Convert an fm number to single precision.

!  ma is converted and the result is returned in x.

!  If kflag = -4 is returned for a value of ma that is in the range of the machine's single
!  precision number system, change the definition of spmax in routine fmset to reflect the
!  current machine's range.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      real :: x
      intent (in) :: ma
      intent (inout) :: x
      type(fm_settings) :: qx

      double precision :: y

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMM2SP'
      if (qx%ntrace /= 0) call fmntr_inp1(ma, qx)

      if (ma%mp(2) == qx%mexpov .or. (ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0)) then

!             Here no valid result can be returned.
!             Set x to some value that the user is likely to recognize as wrong.

          x = qx%runkno
          qx%kflag = -4
          if (ma%mp(2) /= qx%munkno) call fmwarn(qx)
          y = dble(x)
          if (qx%ntrace /= 0) call fmntr_outd(y, qx)
          qx%ncall = qx%ncall - 1
          return
      endif

      call fmm2dp2(ma, y, qx)
      if (abs(y) <= dble(huge(x))) then
          x = y
      else
          x = qx%runkno
          qx%kflag = -4
          call fmwarn(qx)
      endif

      if (qx%ntrace /= 0) call fmntr_outr(x, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmm2sp

      subroutine fmmax(ma, mb, mc, qx)

!  mc = max(ma,mb)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: kwrnsv
      logical, external :: fmcomp

      call fmalloc(mc, qx%ndig+2, qx)

      qx%kflag = 0
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMMAX'
      if (qx%ntrace /= 0) call fmntr_inp2(ma, mb, qx)

      kwrnsv = qx%kwarn
      qx%kwarn = 0
      if ((ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == qx%munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc, qx)
          qx%kflag = -4
      else if (fmcomp(ma, '<', mb, qx)) then
          call fmeq(mb, mc, qx)
      else
          call fmeq(ma, mc, qx)
      endif

      qx%kwarn = kwrnsv
      if (qx%ntrace /= 0) call fmntr_out1(mc, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmmax

      subroutine fmmin(ma, mb, mc, qx)

!  mc = min(ma,mb)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: kwrnsv
      logical, external :: fmcomp

      call fmalloc(mc, qx%ndig+2, qx)

      qx%kflag = 0
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMMIN'
      if (qx%ntrace /= 0) call fmntr_inp2(ma, mb, qx)

      kwrnsv = qx%kwarn
      qx%kwarn = 0
      if ((ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == qx%munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc, qx)
          qx%kflag = -4
      else if (fmcomp(ma, '>', mb, qx)) then
          call fmeq(mb, mc, qx)
      else
          call fmeq(ma, mc, qx)
      endif

      qx%kwarn = kwrnsv
      if (qx%ntrace /= 0) call fmntr_out1(mc, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmmin

      subroutine fmmod(ma, mb, mc, qx)

!  mc = ma(mod mb).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      type(multi) :: mresult
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave

      call fmalloc(mc, qx%ndig+2, qx)
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMMOD'
      if (qx%ntrace /= 0) call fmntr_inp2(ma, mb, qx)
      qx%ncall = qx%ncall - 1

      call fmenter2(ma, mb, kovun, mxsave, ndsave, qx)
      call fmmod2(ma, mb, mresult, ndsave, qx)

      call fmexit1(mresult, mc, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmmod

      subroutine fmmod2(ma, mb, mc, ndsave, qx)

!  mc = ma(mod mb).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      integer :: ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mc
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mvb, mvc, mvy, mvz
      integer :: j, kb, ke, kl, kn, kwrnsv, ntrsav
      type(multi) :: mxy(4)
      logical, external :: fmcomp

      call fmalloc(mc, qx%ndig+2, qx)
      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      call fmequ(mb, mxy(2), ndsave, qx%ndig, qx)

      if ((mxy(1)%mp(2) == qx%munkno .and. mxy(1)%mp(5) >= 0)  .or.  &
          (mxy(2)%mp(2) == qx%munkno .and. mxy(2)%mp(5) >= 0)) then
          call fmunknown(mc, qx)
          return
      endif
      kwrnsv = qx%kwarn
      qx%kwarn = 0

      mxy(1)%mp(1) = 1
      mxy(2)%mp(1) = 1
      if (fmcomp(mxy(2), '>', mxy(1), qx)) then
          call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      else

!             Special cases when mb is a small integer.

          call fmequ(ma, mxy(2), ndsave, qx%ndig, qx)
          call fmequ(mb, mxy(3), ndsave, qx%ndig, qx)
          mxy(2)%mp(1) = 1
          mxy(3)%mp(1) = 1

          call fmm2i(mxy(3), kb, qx)
          kl = 0
          do while (kl == 0)
             if (qx%kflag == 0 .and. kb < mxbase) then
                 if (kb == 1 .or. kb == -1) then
                     if (mxy(2)%mp(2) >= qx%ndig) then
                         call fmi2m(0, mc, qx)
                         if (qx%kflag == 1) qx%kflag = 0
                         qx%kwarn = kwrnsv
                         return
                     else
                         call fmint(mxy(2), mxy(3), qx)
                         call fmsub(mxy(2), mxy(3), mc, qx)
                         if (ma%mp(1) < 0) call fmnegate(mc, qx)
                         if (qx%kflag == 1) qx%kflag = 0
                         qx%kwarn = kwrnsv
                         return
                     endif
                 else if (mxy(2)%mp(2) == qx%mexpov .or. kb == 0) then
                     call fmunknown(mc, qx)
                     if (qx%kflag == 1) qx%kflag = 0
                     qx%kwarn = kwrnsv
                     return
                 else if (mxy(2)%mp(2) > qx%ndig.and.mod(int(qx%mbase), kb) == 0) then
                     call fmi2m(0, mc, qx)
                     if (qx%kflag == 1) qx%kflag = 0
                     qx%kwarn = kwrnsv
                     return
                 endif
                 if (mxy(2)%mp(2) < qx%ndig) then
                     do j = int(mxy(2)%mp(2))+1, qx%ndig+1
                        if (mxy(2)%mp(j+1) /= 0) then
                            kl = 1
                            exit
                        endif
                     enddo
                     if (kl == 1) exit
                 endif
                 ke = min(int(mxy(2)%mp(2)), qx%ndig)
                 mvb = kb
                 mvc = mod(mxy(2)%mp(3), mvb)
                 do j = 3, ke+1
                    mvc = mod(mvc*qx%mbase+mxy(2)%mp(j+1), mvb)
                 enddo
                 if (mvc == 0) then
                     call fmi2m(0, mc, qx)
                     if (qx%kflag == 1) qx%kflag = 0
                     qx%kwarn = kwrnsv
                     return
                 endif
                 kn = int(mxy(2)%mp(2)) - ke
                 mvy = mod(qx%mbase, mvb)
                 mvz = 1
                 if (mod(kn, 2) == 1) mvz = mvy

                 if (mvy /= 1) then
                     do
                        kn = kn/2
                        mvy = mod(mvy*mvy, mvb)
                        if (mod(kn, 2) == 1) mvz = mod(mvz*mvy, mvb)
                        if (kn <= 1) exit
                     enddo
                 endif
                 mvz = mod(mvz*mvc, mvb)
                 ke = int(mvz)
                 call fmi2m(ke, mc, qx)
                 if (ma%mp(1) < 0) call fmnegate(mc, qx)
                 if (qx%kflag == 1) qx%kflag = 0
                 qx%kwarn = kwrnsv
                 return
             endif
             if (ma%mp(2)-mb%mp(2) > 3*10**5) then
                 call fmunknown(mc, qx)
                 if (qx%kflag == 1) qx%kflag = 0
                 qx%kwarn = kwrnsv
                 return
             else
                 kl = 1
             endif
          enddo

!             General case.

          if (ma%mp(3) /= 0) then
              call fmndig(qx%ndig + int(ma%mp(2)-mb%mp(2)), qx)
              if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
          endif
          if (mb%mp(3) == 0) then
              call fmunknown(mc, qx)
              return
          endif

          call fmequ(ma, mxy(2), ndsave, qx%ndig, qx)
          call fmequ(mb, mxy(3), ndsave, qx%ndig, qx)

          mxy(2)%mp(1) = 1
          mxy(3)%mp(1) = 1
          call fmdiv(mxy(2), mxy(3), mxy(1), qx)
          call fmint(mxy(1), mxy(4), qx)
          call fmmpy_r1(mxy(4), mxy(3), qx)
          call fmsub(mxy(2), mxy(4), mxy(1), qx)

!             Due to rounding, mxy(1) may not be between 0 and mb here.

          ntrsav = qx%ntrace
          qx%ntrace = 0
          if (fmcomp(mxy(1), '>=', mxy(3), qx)) then
              qx%ntrace = ntrsav
              call fmsub_r1(mxy(1), mxy(3), qx)
          endif
          qx%ntrace = ntrsav
          if (mxy(1)%mp(1) < 0) call fmadd_r1(mxy(1), mxy(3), qx)
          if (ma%mp(1) < 0) call fmnegate(mxy(1), qx)
      endif

      call fmeq(mxy(1), mc, qx)
      if (qx%kflag == 1) qx%kflag = 0
      qx%kwarn = kwrnsv

      return
      end subroutine fmmod2

      subroutine fmmove(mw, ma, qx)

!  Move a result from a work area (mw) to ma.

!  If the first digit of mw is 0, then mw is shifted and the exponent adjusted when it is
!  moved to ma.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mw
      type(fm_settings) :: qx

      integer :: j, n1, n2
      intent (in) :: mw
      intent (inout) :: ma

      if (mw%mp(3) /= 0) then
          n1 = qx%ndig + 1

!             Major (Inner Loop)

          do j = 2, n1+1
             ma%mp(j) = mw%mp(j)
          enddo
      else
          n2 = qx%ndig + 2
          do j = 3, n2
             ma%mp(j) = mw%mp(j+1)
          enddo
          if (ma%mp(3) /= 0) then
              ma%mp(2) = mw%mp(2) - 1
          else
              ma%mp(2) = 0
          endif
      endif

      ma%mp(1) = 1
      if (abs(ma%mp(2)) > qx%mxexp) call fmtrap(ma, qx)

      return
      end subroutine fmmove

      subroutine fmmpy(ma, mb, mc, qx)

!  mc = ma * mb

!  When one of the numbers ma, mb is known to have more zero digits (base mbase) than the other,
!  it is faster if mb is the one with more zero digits.

!  This routine performs the trace printing for multiplication.
!  fmmpy2 is used to do the arithmetic.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: kovun

      qx%ncall = qx%ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == qx%mexpov .or. abs(mb%mp(2)) == qx%mexpov) kovun = 1
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) kovun = 2
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMMPY'
          call fmntr_inp2(ma, mb, qx)
      endif

      call fmmpy2(ma, mb, mc, qx)

      if ((abs(mc%mp(2)) == qx%mexpov .and. kovun == 0) .or.  &
          (abs(mc%mp(2)) == qx%munkno .and. kovun < 2)) then
          qx%namest(qx%ncall) = 'FMMPY'
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) then
          call fmntr_out1(mc, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmmpy

      subroutine fmmpy2(ma, mb, mc, qx)

!  Internal multiplication routine.  mc = ma * mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      logical :: retry
      integer :: kresult, kr_retry

      call fmalloc(mc, qx%ndig+2, qx)
      call fmalloc(qx%mwa, 2*qx%ndig+30, qx)
      call fmmpy_sc(ma, mb, mc, kresult, qx)
      if (kresult > 0) then
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      kr_retry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fmmpy_m1(ma, mb, mc, kr_retry, retry, qx)
      enddo

      return
      end subroutine fmmpy2

      subroutine fmmpy2_r1(ma, mb, qx)

!  Internal multiplication routine.  ma = ma * mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: mb
      intent (inout) :: ma
      type(fm_settings) :: qx

      logical :: retry
      integer :: kresult, kr_retry

      call fmalloc(qx%mwa, 2*qx%ndig+30, qx)
      call fmmpy_r1_sc(ma, mb, kresult, qx)
      if (kresult > 0) then
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      kr_retry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fmmpy_r1_m1(ma, mb, kr_retry, retry, qx)
      enddo

      return
      end subroutine fmmpy2_r1

      subroutine fmmpy2_r2(ma, mb, qx)

!  Internal multiplication routine.  mb = ma * mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      logical :: retry
      integer :: kresult, kr_retry

      call fmalloc(qx%mwa, 2*qx%ndig+30, qx)
      call fmmpy_r2_sc(ma, mb, kresult, qx)
      if (kresult > 0) then
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      kr_retry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fmmpy_r2_m1(ma, mb, kr_retry, retry, qx)
      enddo

      return
      end subroutine fmmpy2_r2

      subroutine fmmpy3(ma, mb, nguard, kshift, qx)

!  Internal multiplication of ma*mb.  the result is returned in mwa.  Both ma and mb are positive.

!  nguard is the number of guard digits that will be used.
!  kshift = 1 is returned if a left shift is pending (i.e., first digit of mwa = 0).
!             The shift will be done in fmmove.  kshift = 0 is returned if no shift is pending.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: nguard, kshift
      intent (in) :: ma, mb, nguard
      intent (inout) :: kshift
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: maxmwa, mbj, mbkj, mbnorm, mbp1, mk, mkt, mmax, mt
      integer :: j, jm1, k, kb, ki, kj, kl, knz, kwa, l, n1, nmethd, nzda, nzdb
      real :: c

      n1 = qx%ndig + 1
      qx%mwa%mp(2) = ma%mp(2) + mb%mp(2)

!             Check for using an fft-based method if precision is very high.

      c = 900
      if (qx%ndig >= c) then
          nzda = 2
          nzdb = qx%ndig
          do j = qx%ndig, 2, -1
             if (ma%mp(j+2) /= 0) then
                 nzda = j
                 exit
             endif
          enddo
          do j = 2, qx%ndig
             if (mb%mp(j+2) == 0) nzdb = nzdb - 1
          enddo
          c = 0.9 * c / log(c)
          if (real(nzda)*nzdb < c*qx%ndig*log(real(qx%ndig))) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          nmethd = 1
      endif
      if (nmethd == 2) then
          call fmmpyfft(ma, mb, qx)
          if (qx%mwa%mp(3) == 0) then
              kshift = 1
          else
              kshift = 0
          endif
          return
      endif

      l = n1 + nguard
      qx%mwa%mp(l+2) = 0

!             The multiplication loop begins here.

!             mbnorm is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             maxmwa is an upper bound on the size of values in mwa divided by (mbase-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      mbp1 = qx%mbase + 1
      mbnorm = (maxint/(mbp1*mbp1))
      mmax = intmax - qx%mbase
      mmax = min((maxint/mbp1 - mbp1), mmax)
      if (mbnorm >= 2) then
          mbj = mb%mp(3)

!             Count the trailing zeros in ma.

          knz = n1
          if (ma%mp(n1+1) /= 0) then
              knz = n1
          else
              do j = qx%ndig, 2, -1
                 if (ma%mp(j+1) /= 0) then
                     knz = j
                     exit
                 endif
              enddo
          endif

          qx%mwa%mp(3) = 0
          do k = qx%ndig+2, l
             qx%mwa%mp(k+1) = 0
          enddo

!             (Inner Loop)

          do k = 3, n1+1
             qx%mwa%mp(k+1) = ma%mp(k)*mbj
          enddo
          maxmwa = mbj
          do j = 3, n1
             mbj = mb%mp(j+1)
             if (mbj /= 0) then
                 maxmwa = maxmwa + mbj
                 jm1 = j - 1
                 kl = min(knz, l-jm1)

!                       Major (Inner Loop)

                 do k = j+2, j+kl
                    qx%mwa%mp(k) = qx%mwa%mp(k) + ma%mp(k-jm1)*mbj
                 enddo
             endif

             if (maxmwa > mmax) then
                 maxmwa = 0
                 jm1 = j - 1
                 kl = min(knz, l-jm1)

!                       Here normalization is only required for the range of digits currently
!                       changing in mwa.

                 do kb = jm1+kl, jm1+2, -1
                    mkt = int (qx%mwa%mp(kb+1)/qx%mbase)
                    qx%mwa%mp(kb) = qx%mwa%mp(kb) + mkt
                    qx%mwa%mp(kb+1) = qx%mwa%mp(kb+1) - mkt*qx%mbase
                 enddo
             endif
          enddo

!             Perform the final normalization.  (Inner Loop)

          do kb = l+1, 4, -1
             mkt = int (qx%mwa%mp(kb)/qx%mbase)
             qx%mwa%mp(kb-1) = qx%mwa%mp(kb-1) + mkt
             qx%mwa%mp(kb) = qx%mwa%mp(kb) - mkt*qx%mbase
          enddo

      else

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          do j = 2, l
             qx%mwa%mp(j+1) = 0
          enddo
          kj = qx%ndig + 2
          do j = 2, n1
             kj = kj - 1
             mbkj = mb%mp(kj+1)
             if (mbkj == 0) cycle
             kl = l - kj + 1
             if (kl > n1) kl = n1
             ki = kl + 2
             kwa = kl+ kj + 1
             mk = 0
             do k = 2, kl
                mt = ma%mp(ki-k+1)*mbkj + qx%mwa%mp(kwa-k+1) + mk
                mk = int (mt/qx%mbase)
                qx%mwa%mp(kwa-k+1) = mt - qx%mbase*mk
             enddo
             qx%mwa%mp(kwa-kl) = mk
          enddo

      endif

!             Set kshift = 1 if a shift left is necessary.

      if (qx%mwa%mp(3) == 0) then
          kshift = 1
      else
          kshift = 0
      endif

      return
      end subroutine fmmpy3

      subroutine fmmpy_m1(ma, mb, mc, kr_retry, retry, qx)

!  Method 1 for computing mc = ma * mb.

      use fmvals_parallel
      implicit none

      type(multi) :: mpma, mpmb
      type(multi) :: ma, mb, mc
      integer :: kr_retry
      logical :: retry
      intent (in) :: ma, mb
      intent (inout) :: mc, kr_retry, retry
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mr, ms, mt1, mt2
      double precision :: err
      integer :: j, jrssav, k, kl, kshift, kt, kt1, kt2, l, n1, nguard

      qx%kflag = 0
      jrssav = qx%jrsign

!             nguard is the number of guard digits used.

      if (qx%ncall > 1) then
          nguard = qx%ngrd22
          if (nguard > qx%ndig) nguard = qx%ndig
      else
          nguard = qx%ngrd52
          if (nguard > qx%ndig) nguard = qx%ndig
          if (kr_retry >= 1) then
              nguard = qx%ndig + 2
          else if (qx%mbase < 10**6) then
              nguard = min(nguard+1, qx%ndig+2)
          endif
      endif
      if (ma%mp(3)*mb%mp(3) < qx%mbase .and. nguard < 3) nguard = 3

      n1 = qx%ndig + 1

      if (qx%mbase*qx%mbase <= mxbase/(4*qx%mbase)) then

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2**24) while
!             doing the operation.

          if (qx%ndigl /= qx%ndig .or. qx%mbasel /= qx%mbase .or. qx%nguarl /= nguard) then
              qx%mbasel = qx%mbase
              qx%ndigl = qx%ndig
              qx%nguarl = nguard
              do j = 2, 1000
                 mr = qx%mbase*qx%mbasel
                 if (4*mr > mxbase) then
                     qx%n21 = j - 1
                     call fmndig((qx%ndigl-1)/qx%n21 + 1, qx)
                     if (qx%ndig < 3) qx%ndig = 3
                     qx%ngrdn = (qx%ndigl+nguard-1)/qx%n21 + 2 - qx%ndig
                     if (qx%ngrdn < 1) qx%ngrdn = 1
                     exit
                 endif
                 qx%mbase = mr
              enddo
              qx%mbasen = qx%mbase
              qx%ndign = qx%ndig
          else
              qx%mbase = qx%mbasen
              call fmndig(qx%ndign, qx)
          endif
          if (qx%mblogs /= qx%mbase) call fmcons(qx)
          j = qx%ndig
          call fmndig(qx%ndig + qx%ngrdn + 5, qx)
          call fmalloc(mpma, qx%ndig+2, qx)
          call fmalloc(mpmb, qx%ndig+2, qx)
          call fmndig(j, qx)
          mpma%mp(1) = ma%mp(1)
          mpmb%mp(1) = mb%mp(1)
          mpma%mp(2) = 0
          mpmb%mp(2) = 0
          l = 2 - qx%n21
          do j = 2, qx%ndigl+2-qx%n21, qx%n21
             mt1 = ma%mp(j+1)
             mt2 = mb%mp(j+1)
             do k = j+1, j+qx%n21-1
                mt1 = mt1*qx%mbasel + ma%mp(k+1)
                mt2 = mt2*qx%mbasel + mb%mp(k+1)
             enddo
             mpma%mp(3+j/qx%n21) = mt1
             mpmb%mp(3+j/qx%n21) = mt2
             l = j
          enddo
          do j = 3+l/qx%n21, qx%ndig+qx%ngrdn+1
             mpma%mp(j+1) = 0
             mpmb%mp(j+1) = 0
          enddo
          if (l+qx%n21 <= qx%ndigl+1) then
              mt1 = 0
              mt2 = 0
              do j = l+qx%n21, l+2*qx%n21-1
                 if (j <= qx%ndigl+1) then
                     mt1 = mt1*qx%mbasel + ma%mp(j+1)
                     mt2 = mt2*qx%mbasel + mb%mp(j+1)
                 else
                     mt1 = mt1*qx%mbasel
                     mt2 = mt2*qx%mbasel
                 endif
              enddo
              mpma%mp(3+(l+qx%n21)/qx%n21) = mt1
              mpmb%mp(3+(l+qx%n21)/qx%n21) = mt2
          endif
          call fmmpy3(mpma, mpmb, qx%ngrdn, kshift, qx)
          if (qx%mwa%mp(3) == 0) then
              do j = 3, 1+qx%ndig+qx%ngrdn
                 qx%mwa%mp(j) = qx%mwa%mp(j+1)
              enddo
              qx%mwa%mp(qx%ndig+qx%ngrdn+2) = 0
              kshift = 0
          endif
          if (qx%mbasel == 2 .and. qx%mbase < intmax) then
              do j = 1+qx%ndig+qx%ngrdn, 2, -1
                 kt1 = qx%mwa%mp(j+1)
                 kt = 2 + (j-2)*qx%n21
                 kt2 = qx%n21 + kt - 1
                 do k = kt, min(1+(j-1)*qx%n21, qx%ndigl+nguard+2)
                    qx%mwa%mp(k+1) = ibits(kt1, kt2-k, 1)
                 enddo
              enddo
          else
              ms = qx%mbasel**(qx%n21-1)
              do j = 1+qx%ndig+qx%ngrdn, 2, -1
                 mr = ms
                 mt1 = qx%mwa%mp(j+1)
                 do k = 2+(j-2)*qx%n21, min(1+(j-1)*qx%n21, qx%ndigl+nguard+2)
                    qx%mwa%mp(k+1) = aint (mt1/mr)
                    mt1 = mt1 - qx%mwa%mp(k+1)*mr
                    mr = aint (mr/qx%mbasel)
                 enddo
              enddo
          endif
          kshift = 0
          if (qx%mwa%mp(3) == 0) kshift = 1
          qx%mwa%mp(2) = ma%mp(2) + mb%mp(2)
          call fmndig(qx%ndigl, qx)
          qx%mbase = qx%mbasel
          if (qx%mblogs /= qx%mbase) call fmcons(qx)
      else

!             This is the normal case, where the base is not small.

          call fmmpy3(ma, mb, nguard, kshift, qx)
      endif

!             The multiplication is complete.
!             Round the result, move it to mc, and append the correct sign.

      if ((ma%mp(1) > 0 .and. mb%mp(1) > 0) .or. (ma%mp(1) < 0 .and. mb%mp(1) < 0)) then
          qx%jrsign = 1
      else
          qx%jrsign = -1
      endif

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      if (qx%ncall >= 1) then
          kl = min(nguard, int(3*qx%dlogtn/qx%dlogmb + 1.5))
          err = 0
          do j = kl, 1, -1
             err = (err + qx%mwa%mp(j+kshift+qx%ndig+2)) / qx%mbase
          enddo
          if ( (qx%kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
               (qx%kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) kr_retry = kr_retry + 1
      endif
      if (kr_retry == 1 .and. nguard < qx%ndig+2) then
          kr_retry = 2
          retry = .true.
          return
      endif
      mr = 2*qx%mwa%mp(kshift+qx%ndig+3) + 1
      if (qx%kround == -1 .or. qx%kround == 2) then
          call fmrnd(qx%mwa, qx%ndig, nguard, kshift, qx)
      else if (mr >= qx%mbase) then
          if (mr-1 > qx%mbase .and. qx%mwa%mp(kshift+n1+1) < qx%mbase-1) then
              if (qx%kround /= 0) then
                  qx%mwa%mp(kshift+n1+1) = qx%mwa%mp(kshift+n1+1) + 1
                  qx%mwa%mp(kshift+n1+2) = 0
              endif
          else
              call fmrnd(qx%mwa, qx%ndig, nguard, kshift, qx)
          endif
      endif
      call fmmove(qx%mwa, mc, qx)

      mc%mp(1) = 1
      if (ma%mp(1)*mb%mp(1) < 0 .and. mc%mp(2) /= qx%munkno .and.  &
          mc%mp(3) /= 0) mc%mp(1) = -1
      qx%jrsign = jrssav

      return
      end subroutine fmmpy_m1

      subroutine fmmpy_r1(ma, mb, qx)

!  ma = ma * mb

!  When one of the numbers ma, mb is known to have more zero digits (base mbase) than the other,
!  it is faster if mb is the one with more zero digits.

!  This routine performs the trace printing for multiplication.
!  fmmpy2_r1 is used to do the arithmetic.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: mb
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: kovun

      qx%ncall = qx%ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == qx%mexpov .or. abs(mb%mp(2)) == qx%mexpov) kovun = 1
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) kovun = 2
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMMPY_R1'
          call fmntr_inp2(ma, mb, qx)
      endif

      call fmmpy2_r1(ma, mb, qx)

      if ((abs(ma%mp(2)) == qx%mexpov .and. kovun == 0) .or.  &
          (abs(ma%mp(2)) == qx%munkno .and. kovun < 2)) then
          qx%namest(qx%ncall) = 'FMMPY_R1'
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) then
          call fmntr_out1(ma, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmmpy_r1

      subroutine fmmpy_r1_m1(ma, mb, kr_retry, retry, qx)

!  Method 1 for computing ma = ma * mb.

      use fmvals_parallel
      implicit none

      type(multi) :: mpma, mpmb
      type(multi) :: ma, mb
      integer :: kr_retry
      logical :: retry
      intent (in) :: mb
      intent (inout) :: ma, kr_retry, retry
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mr, ms, mt1, mt2
      double precision :: err
      integer :: j, jrssav, k, kl, kshift, kt, kt1, kt2, l, n1, nguard

      qx%kflag = 0
      jrssav = qx%jrsign

!             nguard is the number of guard digits used.

      if (qx%ncall > 1) then
          nguard = qx%ngrd22
          if (nguard > qx%ndig) nguard = qx%ndig
      else
          nguard = qx%ngrd52
          if (nguard > qx%ndig) nguard = qx%ndig
          if (kr_retry >= 1) then
              nguard = qx%ndig + 2
          else if (qx%mbase < 10**6) then
              nguard = min(nguard+1, qx%ndig+2)
          endif
      endif
      if (ma%mp(3)*mb%mp(3) < qx%mbase .and. nguard < 3) nguard = 3

      n1 = qx%ndig + 1

      if (qx%mbase*qx%mbase <= mxbase/(4*qx%mbase)) then

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2**24) while
!             doing the operation.

          if (qx%ndigl /= qx%ndig .or. qx%mbasel /= qx%mbase .or. qx%nguarl /= nguard) then
              qx%mbasel = qx%mbase
              qx%ndigl = qx%ndig
              qx%nguarl = nguard
              do j = 2, 1000
                 mr = qx%mbase*qx%mbasel
                 if (4*mr > mxbase) then
                     qx%n21 = j - 1
                     call fmndig((qx%ndigl-1)/qx%n21 + 1, qx)
                     if (qx%ndig < 3) qx%ndig = 3
                     qx%ngrdn = (qx%ndigl+nguard-1)/qx%n21 + 2 - qx%ndig
                     if (qx%ngrdn < 1) qx%ngrdn = 1
                     exit
                 endif
                 qx%mbase = mr
              enddo
              qx%mbasen = qx%mbase
              qx%ndign = qx%ndig
          else
              qx%mbase = qx%mbasen
              call fmndig(qx%ndign, qx)
          endif
          if (qx%mblogs /= qx%mbase) call fmcons(qx)
          j = qx%ndig
          call fmndig(qx%ndig + qx%ngrdn + 5, qx)
          call fmalloc(mpma, qx%ndig+2, qx)
          call fmalloc(mpmb, qx%ndig+2, qx)
          call fmndig(j, qx)
          mpma%mp(1) = ma%mp(1)
          mpmb%mp(1) = mb%mp(1)
          mpma%mp(2) = 0
          mpmb%mp(2) = 0
          l = 2 - qx%n21
          do j = 2, qx%ndigl+2-qx%n21, qx%n21
             mt1 = ma%mp(j+1)
             mt2 = mb%mp(j+1)
             do k = j+1, j+qx%n21-1
                mt1 = mt1*qx%mbasel + ma%mp(k+1)
                mt2 = mt2*qx%mbasel + mb%mp(k+1)
             enddo
             mpma%mp(3+j/qx%n21) = mt1
             mpmb%mp(3+j/qx%n21) = mt2
             l = j
          enddo
          do j = 3+l/qx%n21, qx%ndig+qx%ngrdn+1
             mpma%mp(j+1) = 0
             mpmb%mp(j+1) = 0
          enddo
          if (l+qx%n21 <= qx%ndigl+1) then
              mt1 = 0
              mt2 = 0
              do j = l+qx%n21, l+2*qx%n21-1
                 if (j <= qx%ndigl+1) then
                     mt1 = mt1*qx%mbasel + ma%mp(j+1)
                     mt2 = mt2*qx%mbasel + mb%mp(j+1)
                 else
                     mt1 = mt1*qx%mbasel
                     mt2 = mt2*qx%mbasel
                 endif
              enddo
              mpma%mp(3+(l+qx%n21)/qx%n21) = mt1
              mpmb%mp(3+(l+qx%n21)/qx%n21) = mt2
          endif
          call fmmpy3(mpma, mpmb, qx%ngrdn, kshift, qx)
          if (qx%mwa%mp(3) == 0) then
              do j = 3, 1+qx%ndig+qx%ngrdn
                 qx%mwa%mp(j) = qx%mwa%mp(j+1)
              enddo
              qx%mwa%mp(qx%ndig+qx%ngrdn+2) = 0
              kshift = 0
          endif
          if (qx%mbasel == 2 .and. qx%mbase < intmax) then
              do j = 1+qx%ndig+qx%ngrdn, 2, -1
                 kt1 = qx%mwa%mp(j+1)
                 kt = 2 + (j-2)*qx%n21
                 kt2 = qx%n21 + kt - 1
                 do k = kt, min(1+(j-1)*qx%n21, qx%ndigl+nguard+2)
                    qx%mwa%mp(k+1) = ibits(kt1, kt2-k, 1)
                 enddo
              enddo
          else
              ms = qx%mbasel**(qx%n21-1)
              do j = 1+qx%ndig+qx%ngrdn, 2, -1
                 mr = ms
                 mt1 = qx%mwa%mp(j+1)
                 do k = 2+(j-2)*qx%n21, min(1+(j-1)*qx%n21, qx%ndigl+nguard+2)
                    qx%mwa%mp(k+1) = aint (mt1/mr)
                    mt1 = mt1 - qx%mwa%mp(k+1)*mr
                    mr = aint (mr/qx%mbasel)
                 enddo
              enddo
          endif
          kshift = 0
          if (qx%mwa%mp(3) == 0) kshift = 1
          qx%mwa%mp(2) = ma%mp(2) + mb%mp(2)
          call fmndig(qx%ndigl, qx)
          qx%mbase = qx%mbasel
          if (qx%mblogs /= qx%mbase) call fmcons(qx)
      else

!             This is the normal case, where the base is not small.

          call fmmpy3(ma, mb, nguard, kshift, qx)
      endif

!             The multiplication is complete.
!             Round the result, move it to mc, and append the correct sign.

      if ((ma%mp(1) > 0 .and. mb%mp(1) > 0) .or. (ma%mp(1) < 0 .and. mb%mp(1) < 0)) then
          qx%jrsign = 1
      else
          qx%jrsign = -1
      endif

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      if (qx%ncall >= 1) then
          kl = min(nguard, int(3*qx%dlogtn/qx%dlogmb + 1.5))
          err = 0
          do j = kl, 1, -1
             err = (err + qx%mwa%mp(j+kshift+qx%ndig+2)) / qx%mbase
          enddo
          if ( (qx%kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
               (qx%kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) kr_retry = kr_retry + 1
      endif
      if (kr_retry == 1 .and. nguard < qx%ndig+2) then
          kr_retry = 2
          retry = .true.
          return
      endif
      mr = 2*qx%mwa%mp(kshift+qx%ndig+3) + 1
      if (qx%kround == -1 .or. qx%kround == 2) then
          call fmrnd(qx%mwa, qx%ndig, nguard, kshift, qx)
      else if (mr >= qx%mbase) then
          if (mr-1 > qx%mbase .and. qx%mwa%mp(kshift+n1+1) < qx%mbase-1) then
              if (qx%kround /= 0) then
                  qx%mwa%mp(kshift+n1+1) = qx%mwa%mp(kshift+n1+1) + 1
                  qx%mwa%mp(kshift+n1+2) = 0
              endif
          else
              call fmrnd(qx%mwa, qx%ndig, nguard, kshift, qx)
          endif
      endif
      k = ma%mp(1) * mb%mp(1)
      call fmmove(qx%mwa, ma, qx)

      if (k < 0 .and. ma%mp(2) /= qx%munkno .and. ma%mp(3) /= 0) then
          ma%mp(1) = -1
      else
          ma%mp(1) = 1
      endif
      qx%jrsign = jrssav

      return
      end subroutine fmmpy_r1_m1

      subroutine fmmpy_r1_sc(ma, mb, kresult, qx)

!  Check for special cases for ma = ma * mb.

!  kresult = 1 is returned if a special case gives the value of ma.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: kresult
      intent (in) :: mb
      intent (inout) :: ma, kresult
      type(fm_settings) :: qx

      integer :: jrssav
      type(multi) :: mxy

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      jrssav = qx%jrsign
      kresult = 0
      qx%kflag = 0
      if ( (ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) .or.  &
           (mb%mp(2) == qx%munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(ma, qx)
          qx%kflag = -4
          kresult = 1
          return
      endif
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) then
          call fmovun_mpy(ma, mb, mxy, qx)
          call fmeq(mxy, ma, qx)
          kresult = 1
          return
      endif
      if (abs(ma%mp(2)) == qx%mexpov .or. abs(mb%mp(2)) == qx%mexpov) then
          call fmovun_mpy(ma, mb, mxy, qx)
          call fmeq(mxy, ma, qx)
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0 .or. mb%mp(3) == 0) then
          call fmi2m2(0, ma, qx)
          qx%jrsign = jrssav
          kresult = 1
          return
      endif

      return
      end subroutine fmmpy_r1_sc

      subroutine fmmpy_r2(ma, mb, qx)

!  mb = ma * mb

!  When one of the numbers ma, mb is known to have more zero digits (base mbase) than the other,
!  it is faster if mb is the one with more zero digits.

!  This routine performs the trace printing for multiplication.
!  fmmpy2_r2 is used to do the arithmetic.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      integer :: kovun

      qx%ncall = qx%ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == qx%mexpov .or. abs(mb%mp(2)) == qx%mexpov) kovun = 1
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) kovun = 2
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMMPY_R2'
          call fmntr_inp2(ma, mb, qx)
      endif

      call fmmpy2_r2(ma, mb, qx)

      if ((abs(mb%mp(2)) == qx%mexpov .and. kovun == 0) .or.  &
          (abs(mb%mp(2)) == qx%munkno .and. kovun < 2)) then
          qx%namest(qx%ncall) = 'FMSUB'
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) then
          call fmntr_out1(mb, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmmpy_r2

      subroutine fmmpy_r2_m1(ma, mb, kr_retry, retry, qx)

!  Method 1 for computing mb = ma * mb.

      use fmvals_parallel
      implicit none

      type(multi) :: mpma, mpmb
      type(multi) :: ma, mb
      integer :: kr_retry
      logical :: retry
      intent (in) :: ma
      intent (inout) :: mb, kr_retry, retry
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mr, ms, mt1, mt2
      double precision :: err
      integer :: j, jrssav, k, kl, kshift, kt, kt1, kt2, l, n1, nguard

      qx%kflag = 0
      jrssav = qx%jrsign

!             nguard is the number of guard digits used.

      if (qx%ncall > 1) then
          nguard = qx%ngrd22
          if (nguard > qx%ndig) nguard = qx%ndig
      else
          nguard = qx%ngrd52
          if (nguard > qx%ndig) nguard = qx%ndig
          if (kr_retry >= 1) then
              nguard = qx%ndig + 2
          else if (qx%mbase < 10**6) then
              nguard = min(nguard+1, qx%ndig+2)
          endif
      endif
      if (ma%mp(3)*mb%mp(3) < qx%mbase .and. nguard < 3) nguard = 3

      n1 = qx%ndig + 1

      if (qx%mbase*qx%mbase <= mxbase/(4*qx%mbase)) then

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2**24) while
!             doing the operation.

          if (qx%ndigl /= qx%ndig .or. qx%mbasel /= qx%mbase .or. qx%nguarl /= nguard) then
              qx%mbasel = qx%mbase
              qx%ndigl = qx%ndig
              qx%nguarl = nguard
              do j = 2, 1000
                 mr = qx%mbase*qx%mbasel
                 if (4*mr > mxbase) then
                     qx%n21 = j - 1
                     call fmndig((qx%ndigl-1)/qx%n21 + 1, qx)
                     if (qx%ndig < 3) qx%ndig = 3
                     qx%ngrdn = (qx%ndigl+nguard-1)/qx%n21 + 2 - qx%ndig
                     if (qx%ngrdn < 1) qx%ngrdn = 1
                     exit
                 endif
                 qx%mbase = mr
              enddo
              qx%mbasen = qx%mbase
              qx%ndign = qx%ndig
          else
              qx%mbase = qx%mbasen
              call fmndig(qx%ndign, qx)
          endif
          if (qx%mblogs /= qx%mbase) call fmcons(qx)
          j = qx%ndig
          call fmndig(qx%ndig + qx%ngrdn + 5, qx)
          call fmalloc(mpma, qx%ndig+2, qx)
          call fmalloc(mpmb, qx%ndig+2, qx)
          call fmndig(j, qx)
          mpma%mp(1) = ma%mp(1)
          mpmb%mp(1) = mb%mp(1)
          mpma%mp(2) = 0
          mpmb%mp(2) = 0
          l = 2 - qx%n21
          do j = 2, qx%ndigl+2-qx%n21, qx%n21
             mt1 = ma%mp(j+1)
             mt2 = mb%mp(j+1)
             do k = j+1, j+qx%n21-1
                mt1 = mt1*qx%mbasel + ma%mp(k+1)
                mt2 = mt2*qx%mbasel + mb%mp(k+1)
             enddo
             mpma%mp(3+j/qx%n21) = mt1
             mpmb%mp(3+j/qx%n21) = mt2
             l = j
          enddo
          do j = 3+l/qx%n21, qx%ndig+qx%ngrdn+1
             mpma%mp(j+1) = 0
             mpmb%mp(j+1) = 0
          enddo
          if (l+qx%n21 <= qx%ndigl+1) then
              mt1 = 0
              mt2 = 0
              do j = l+qx%n21, l+2*qx%n21-1
                 if (j <= qx%ndigl+1) then
                     mt1 = mt1*qx%mbasel + ma%mp(j+1)
                     mt2 = mt2*qx%mbasel + mb%mp(j+1)
                 else
                     mt1 = mt1*qx%mbasel
                     mt2 = mt2*qx%mbasel
                 endif
              enddo
              mpma%mp(3+(l+qx%n21)/qx%n21) = mt1
              mpmb%mp(3+(l+qx%n21)/qx%n21) = mt2
          endif
          call fmmpy3(mpma, mpmb, qx%ngrdn, kshift, qx)
          if (qx%mwa%mp(3) == 0) then
              do j = 3, 1+qx%ndig+qx%ngrdn
                 qx%mwa%mp(j) = qx%mwa%mp(j+1)
              enddo
              qx%mwa%mp(qx%ndig+qx%ngrdn+2) = 0
              kshift = 0
          endif
          if (qx%mbasel == 2 .and. qx%mbase < intmax) then
              do j = 1+qx%ndig+qx%ngrdn, 2, -1
                 kt1 = qx%mwa%mp(j+1)
                 kt = 2 + (j-2)*qx%n21
                 kt2 = qx%n21 + kt - 1
                 do k = kt, min(1+(j-1)*qx%n21, qx%ndigl+nguard+2)
                    qx%mwa%mp(k+1) = ibits(kt1, kt2-k, 1)
                 enddo
              enddo
          else
              ms = qx%mbasel**(qx%n21-1)
              do j = 1+qx%ndig+qx%ngrdn, 2, -1
                 mr = ms
                 mt1 = qx%mwa%mp(j+1)
                 do k = 2+(j-2)*qx%n21, min(1+(j-1)*qx%n21, qx%ndigl+nguard+2)
                    qx%mwa%mp(k+1) = aint (mt1/mr)
                    mt1 = mt1 - qx%mwa%mp(k+1)*mr
                    mr = aint (mr/qx%mbasel)
                 enddo
              enddo
          endif
          kshift = 0
          if (qx%mwa%mp(3) == 0) kshift = 1
          qx%mwa%mp(2) = ma%mp(2) + mb%mp(2)
          call fmndig(qx%ndigl, qx)
          qx%mbase = qx%mbasel
          if (qx%mblogs /= qx%mbase) call fmcons(qx)
      else

!             This is the normal case, where the base is not small.

          call fmmpy3(ma, mb, nguard, kshift, qx)
      endif

!             The multiplication is complete.
!             Round the result, move it to mc, and append the correct sign.

      if ((ma%mp(1) > 0 .and. mb%mp(1) > 0) .or. (ma%mp(1) < 0 .and. mb%mp(1) < 0)) then
          qx%jrsign = 1
      else
          qx%jrsign = -1
      endif

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      if (qx%ncall >= 1) then
          kl = min(nguard, int(3*qx%dlogtn/qx%dlogmb + 1.5))
          err = 0
          do j = kl, 1, -1
             err = (err + qx%mwa%mp(j+kshift+qx%ndig+2)) / qx%mbase
          enddo
          if ( (qx%kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
               (qx%kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) kr_retry = kr_retry + 1
      endif
      if (kr_retry == 1 .and. nguard < qx%ndig+2) then
          kr_retry = 2
          retry = .true.
          return
      endif
      mr = 2*qx%mwa%mp(kshift+qx%ndig+3) + 1
      if (qx%kround == -1 .or. qx%kround == 2) then
          call fmrnd(qx%mwa, qx%ndig, nguard, kshift, qx)
      else if (mr >= qx%mbase) then
          if (mr-1 > qx%mbase .and. qx%mwa%mp(kshift+n1+1) < qx%mbase-1) then
              if (qx%kround /= 0) then
                  qx%mwa%mp(kshift+n1+1) = qx%mwa%mp(kshift+n1+1) + 1
                  qx%mwa%mp(kshift+n1+2) = 0
              endif
          else
              call fmrnd(qx%mwa, qx%ndig, nguard, kshift, qx)
          endif
      endif
      k = ma%mp(1) * mb%mp(1)
      call fmmove(qx%mwa, mb, qx)

      if (k < 0 .and. mb%mp(2) /= qx%munkno .and. mb%mp(3) /= 0) then
          mb%mp(1) = -1
      else
          mb%mp(1) = 1
      endif
      qx%jrsign = jrssav

      return
      end subroutine fmmpy_r2_m1

      subroutine fmmpy_r2_sc(ma, mb, kresult, qx)

!  Check for special cases for mb = ma * mb.

!  kresult = 1 is returned if a special case gives the value of mb.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: kresult
      intent (in) :: ma
      intent (inout) :: mb, kresult
      type(fm_settings) :: qx

      integer :: jrssav
      type(multi) :: mxy

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      jrssav = qx%jrsign
      kresult = 0
      qx%kflag = 0
      if ( (ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) .or.  &
           (mb%mp(2) == qx%munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mb, qx)
          qx%kflag = -4
          kresult = 1
          return
      endif
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) then
          call fmovun_mpy(ma, mb, mxy, qx)
          call fmeq(mxy, mb, qx)
          kresult = 1
          return
      endif
      if (abs(ma%mp(2)) == qx%mexpov .or. abs(mb%mp(2)) == qx%mexpov) then
          call fmovun_mpy(ma, mb, mxy, qx)
          call fmeq(mxy, mb, qx)
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0 .or. mb%mp(3) == 0) then
          call fmi2m2(0, mb, qx)
          qx%jrsign = jrssav
          kresult = 1
          return
      endif

      return
      end subroutine fmmpy_r2_sc

      subroutine fmmpy_sc(ma, mb, mc, kresult, qx)

!  Check for special cases for mc = ma * mb.

!  kresult = 1 is returned if a special case gives the value of mc.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      integer :: kresult
      intent (in) :: ma, mb
      intent (inout) :: mc, kresult
      type(fm_settings) :: qx

      integer :: jrssav

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      jrssav = qx%jrsign
      kresult = 0
      qx%kflag = 0
      if ( (ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) .or.  &
           (mb%mp(2) == qx%munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc, qx)
          qx%kflag = -4
          kresult = 1
          return
      endif
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) then
          call fmovun_mpy(ma, mb, mc, qx)
          kresult = 1
          return
      endif
      if (abs(ma%mp(2)) == qx%mexpov .or. abs(mb%mp(2)) == qx%mexpov) then
          call fmovun_mpy(ma, mb, mc, qx)
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0 .or. mb%mp(3) == 0) then
          call fmi2m2(0, mc, qx)
          qx%jrsign = jrssav
          kresult = 1
          return
      endif

      return
      end subroutine fmmpy_sc

      subroutine fmmpyd(ma, mb, mc, md, me, qx)

!  Double multiplication routine.  md = ma * mb,   me = ma * mc

!  It is usually slightly faster to do two multiplications by the same factor with one call.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md, me
      intent (in) :: ma, mb, mc
      intent (inout) :: md, me
      type(fm_settings) :: qx

      integer :: kovun

      qx%ncall = qx%ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == qx%mexpov .or. abs(mb%mp(2)) == qx%mexpov .or.  &
          abs(mc%mp(2)) == qx%mexpov) kovun = 1
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno .or.  &
          mc%mp(2) == qx%munkno) kovun = 2
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMMPYD'
          call fmntr_inp3(ma, mb, mc, qx)
      endif

      call fmmpyd2(ma, mb, mc, md, me, qx)

      if ((abs(md%mp(2)) == qx%mexpov .and. kovun == 0) .or.  &
          (abs(me%mp(2)) == qx%mexpov .and. kovun == 0) .or.  &
          (abs(md%mp(2)) == qx%munkno .and. kovun < 2)  .or.  &
          (abs(me%mp(2)) == qx%munkno .and. kovun < 2)) then
          qx%namest(qx%ncall) = 'FMMPYD'
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) then
          call fmntr_out2(md, me, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmmpyd

      subroutine fmmpyd2(ma, mb, mc, md, me, qx)

!  Double multiplication routine.  md = ma * mb,   me = ma * mc

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md, me
      intent (in) :: ma, mb, mc
      intent (inout) :: md, me
      type(fm_settings) :: qx

      integer :: jrssav, kresult

      call fmalloc(md, qx%ndig+2, qx)
      call fmalloc(me, qx%ndig+2, qx)
      call fmalloc(qx%mwa, 2*qx%ndig+30, qx)
      call fmalloc(qx%mwd, 2*qx%ndig+30, qx)
      call fmmpyd_sc(ma, mb, mc, md, me, kresult, qx)
      if (kresult > 0) then
          return
      endif
      jrssav = qx%jrsign

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      call fmmpyd_m1(ma, mb, mc, md, me, qx)
      qx%jrsign = jrssav

      return
      end subroutine fmmpyd2

      subroutine fmmpyd3(k, ma, mb, mc, mw, mr, qx)

!  Round from the work area mw to mr.

!  k = 1 for rounding mw = ma * mb
!  k = 2 for rounding mw = ma * mc

      use fmvals_parallel
      implicit none

      integer :: k
      type(multi) :: ma, mb, mc, mw, mr
      intent (in) :: k, ma, mb, mc
      intent (inout) :: mw, mr
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mlr
      double precision :: err
      integer :: j, kl, n1, nguard

      if (qx%ncall > 1) then
          nguard = qx%ngrd21
          if (nguard > qx%ndig) nguard = qx%ndig
      else
          nguard = qx%ngrd52 - 1
      endif
      n1 = qx%ndig + 1

      if (k == 1) then
          qx%jrsign = ma%mp(1) * mb%mp(1)
      else
          qx%jrsign = ma%mp(1) * mc%mp(1)
      endif
      if (mw%mp(3) == 0) then
          if (qx%ncall >= 1) then
              kl = min(nguard, int(3*qx%dlogtn/qx%dlogmb + 1.5))
              err = 0
              do j = kl, 1, -1
                 err = (err + mw%mp(j+qx%ndig+3)) / qx%mbase
              enddo
              if ( (qx%kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
                   (qx%kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) then
                  if (k == 1) then
                      call fmmpy2(ma, mb, mr, qx)
                  else
                      call fmmpy2(ma, mc, mr, qx)
                  endif
                  return
              endif
          endif
          mlr = 2*mw%mp(qx%ndig+4) + 1
          if (qx%kround == -1 .or. qx%kround == 2) then
              call fmrnd(mw, qx%ndig, nguard, 1, qx)
          else if (mlr >= qx%mbase) then
              if (mlr-1 > qx%mbase .and. mw%mp(n1+2) < qx%mbase-1) then
                  if (qx%kround /= 0) then
                      mw%mp(n1+2) = mw%mp(n1+2) + 1
                      mw%mp(n1+3) = 0
                  endif
              else
                  call fmrnd(mw, qx%ndig, nguard, 1, qx)
              endif
          endif
      else
          if (qx%ncall >= 1) then
              kl = min(nguard, int(3*qx%dlogtn/qx%dlogmb + 1.5))
              err = 0
              do j = kl, 1, -1
                 err = (err + mw%mp(j+qx%ndig+2)) / qx%mbase
              enddo
              if ( (qx%kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
                   (qx%kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) then
                  if (k == 1) then
                      call fmmpy2(ma, mb, mr, qx)
                  else
                      call fmmpy2(ma, mc, mr, qx)
                  endif
                  return
              endif
          endif
          mlr = 2*mw%mp(qx%ndig+3) + 1
          if (qx%kround == -1 .or. qx%kround == 2) then
              call fmrnd(mw, qx%ndig, nguard, 0, qx)
          else if (mlr >= qx%mbase) then
              if (mlr-1 > qx%mbase .and. mw%mp(n1+1) < qx%mbase-1) then
                  if (qx%kround /= 0) then
                      mw%mp(n1+1) = mw%mp(n1+1) + 1
                      mw%mp(n1+2) = 0
                  endif
              else
                  call fmrnd(mw, qx%ndig, nguard, 0, qx)
              endif
          endif
      endif
      call fmmove(mw, mr, qx)

      return
      end subroutine fmmpyd3

      subroutine fmmpyd_m1(ma, mb, mc, md, me, qx)

!  Method 1 for computing  md = ma * mb,   me = ma * mc

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md, me
      intent (in) :: ma, mb, mc
      intent (inout) :: md, me
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: maxmwa, mbj, mbkj, mbnorm, mbp1, mcj, mckj, mkb, mkc, mkt,  &
                            mmax, mt, mtemp
      integer :: j, jm1, k, kb, ki, kj, kl, knz, kwa, l, n1, nguard

      qx%kflag = 0

!             nguard is the number of guard digits used.

      if (qx%ncall > 1) then
          nguard = qx%ngrd22
          if (nguard > qx%ndig) nguard = qx%ndig
      else
          nguard = qx%ngrd52
          if (nguard > qx%ndig) nguard = qx%ndig
          if (qx%mbase < 10**6) nguard = min(nguard+1, qx%ndig+2)
      endif
      if ((ma%mp(3)*mb%mp(3) < qx%mbase .or.  &
           ma%mp(3)*mc%mp(3) < qx%mbase) .and. nguard < 3) nguard = 3

      n1 = qx%ndig + 1
      qx%mwa%mp(2) = ma%mp(2) + mb%mp(2)
      qx%mwd%mp(2) = ma%mp(2) + mc%mp(2)
      l = qx%ndig + 1 + nguard
      qx%mwa%mp(l+2) = 0
      qx%mwd%mp(l+2) = 0

!             The multiplication loop begins here.

!             mbnorm is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             maxmwa is an upper bound on the size of values in mwa divided by (mbase-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      mbp1 = qx%mbase + 1
      mbnorm = (maxint/(mbp1*mbp1))
      mmax = intmax - qx%mbase
      mmax = min((maxint/mbp1 - mbp1), mmax)
      if (mbnorm >= 2) then
          mbj = mb%mp(3)
          mcj = mc%mp(3)

!             Count the trailing zeros in ma.

          knz = n1
          if (ma%mp(n1+1) /= 0) then
              knz = n1
          else
              do j = qx%ndig, 2, -1
                 if (ma%mp(j+1) /= 0) then
                     knz = j
                     exit
                 endif
              enddo
          endif

          qx%mwa%mp(3) = 0
          qx%mwd%mp(3) = 0
          do k = qx%ndig+2, l
             qx%mwa%mp(k+1) = 0
             qx%mwd%mp(k+1) = 0
          enddo

!             (Inner Loop)

          do k = 2, n1
             mtemp = ma%mp(k+1)
             qx%mwa%mp(k+2) = mtemp*mbj
             qx%mwd%mp(k+2) = mtemp*mcj
          enddo
          if (mbj > mcj) then
              maxmwa = mbj
          else
              maxmwa = mcj
          endif
          do j = 3, n1
             mbj = mb%mp(j+1)
             mcj = mc%mp(j+1)
             if (mbj > mcj) then
                 maxmwa = maxmwa + mbj
             else
                 maxmwa = maxmwa + mcj
             endif
             jm1 = j - 1
             kl = min(knz, l-jm1)

!                       Major (Inner Loop)

             do k = j+2, j+kl
                mtemp = ma%mp(k-jm1)
                qx%mwa%mp(k) = qx%mwa%mp(k) + mtemp*mbj
                qx%mwd%mp(k) = qx%mwd%mp(k) + mtemp*mcj
             enddo

             if (maxmwa > mmax) then
                 maxmwa = 0

!                       Here normalization is only required for the range of digits currently
!                       changing in mwa.

                 do kb = jm1+kl, jm1+2, -1
                    mkt = int (qx%mwa%mp(kb+1)/qx%mbase)
                    qx%mwa%mp(kb) = qx%mwa%mp(kb) + mkt
                    qx%mwa%mp(kb+1) = qx%mwa%mp(kb+1) - mkt*qx%mbase
                    mkt = int (qx%mwd%mp(kb+1)/qx%mbase)
                    qx%mwd%mp(kb) = qx%mwd%mp(kb) + mkt
                    qx%mwd%mp(kb+1) = qx%mwd%mp(kb+1) - mkt*qx%mbase
                 enddo
             endif
          enddo

!             Perform the final normalization.  (Inner Loop)

          do kb = l+1, 4, -1
             mkt = int (qx%mwa%mp(kb)/qx%mbase)
             qx%mwa%mp(kb-1) = qx%mwa%mp(kb-1) + mkt
             qx%mwa%mp(kb) = qx%mwa%mp(kb) - mkt*qx%mbase
             mkt = int (qx%mwd%mp(kb)/qx%mbase)
             qx%mwd%mp(kb-1) = qx%mwd%mp(kb-1) + mkt
             qx%mwd%mp(kb) = qx%mwd%mp(kb) - mkt*qx%mbase
          enddo

      else

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          do j = 2, l
             qx%mwa%mp(j+1) = 0
             qx%mwd%mp(j+1) = 0
          enddo
          kj = qx%ndig + 2
          do j = 2, n1
             kj = kj - 1
             mbkj = mb%mp(kj+1)
             mckj = mc%mp(kj+1)
             kl = l - kj + 1
             if (kl > n1) kl = n1
             ki = kl + 2
             kwa = kl+ kj + 1
             mkb = 0
             mkc = 0
             do k = 2, kl
                mt = ma%mp(ki-k+1)*mbkj + qx%mwa%mp(kwa-k+1) + mkb
                mkb = int (mt/qx%mbase)
                qx%mwa%mp(kwa-k+1) = mt - qx%mbase*mkb
                mt = ma%mp(ki-k+1)*mckj + qx%mwd%mp(kwa-k+1) + mkc
                mkc = int (mt/qx%mbase)
                qx%mwd%mp(kwa-k+1) = mt - qx%mbase*mkc
             enddo
             qx%mwa%mp(kwa-kl) = mkb
             qx%mwd%mp(kwa-kl) = mkc
          enddo

      endif

!             The multiplications are complete.
!             Round, affix the sign, and return.

      call fmmpyd3(1, ma, mb, mc, qx%mwa, md, qx)
      call fmmpyd3(2, ma, mb, mc, qx%mwd, me, qx)

      md%mp(1) = ma%mp(1)*mb%mp(1)
      me%mp(1) = ma%mp(1)*mc%mp(1)

      return
      end subroutine fmmpyd_m1

      subroutine fmmpyd_sc(ma, mb, mc, md, me, kresult, qx)

!  Check for special cases for  md = ma * mb  and  me = ma * mc.

!  kresult = 1 is returned if a special case gives the values of md, me.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md, me
      integer :: kresult
      intent (in) :: ma, mb, mc
      intent (inout) :: md, me, kresult
      type(fm_settings) :: qx

      integer :: kb, kc, kovun

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      kresult = 0
      kc = 3100
      if (qx%ndig >= kc .or.                                             &
          abs(ma%mp(2)) > qx%mexpab .or. abs(mb%mp(2)) > qx%mexpab .or.  &
          abs(mc%mp(2)) > qx%mexpab .or. qx%mbase*qx%mbase <= mxbase/(4*qx%mbase)) then
          kovun = 0
          if (ma%mp(2) == qx%mexpov .or. ma%mp(2) == qx%mexpun .or.  &
              mb%mp(2) == qx%mexpov .or. mb%mp(2) == qx%mexpun .or.  &
              mc%mp(2) == qx%mexpov .or. mc%mp(2) == qx%mexpun) kovun = 1
          if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno .or.  &
              mc%mp(2) == qx%munkno) kovun = 2
          qx%ncall = qx%ncall + 1
          call fmmpy2(ma, mb, md, qx)
          kb = qx%kflag
          call fmmpy2(ma, mc, me, qx)
          qx%ncall = qx%ncall - 1
          if (((qx%kflag < 0 .or. kb < 0) .and. kovun == 0) .or.  &
              ((qx%kflag == -4 .or. kb == -4) .and. kovun == 1)) then
              if (qx%kflag == -4 .or. kb == -4) then
                  qx%kflag = -4
              else if (qx%kflag == -5 .or. kb == -5) then
                  qx%kflag = -5
              else
                  qx%kflag = min(qx%kflag, kb)
              endif
          endif
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0) then
          call fmi2m2(0, md, qx)
          call fmi2m2(0, me, qx)
          kresult = 1
          return
      endif
      if (mb%mp(3) == 0) then
          call fmmpy2(ma, mc, me, qx)
          call fmi2m2(0, md, qx)
          kresult = 1
          return
      endif
      if (mc%mp(3) == 0) then
          call fmmpy2(ma, mb, md, qx)
          call fmi2m2(0, me, qx)
          kresult = 1
          return
      endif
      qx%kflag = 0

      return
      end subroutine fmmpyd_sc

      subroutine fmmpye(ma, mb, mc, md, me, mf, mg, qx)

!  Triple multiplication routine.

!      me = ma * mb,   mf = ma * mc,   mg = ma * md

!  It is usually slightly faster to do three multiplications that have a common factor with
!  one call.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md, me, mf, mg
      intent (in) :: ma, mb, mc, md
      intent (inout) :: me, mf, mg
      type(fm_settings) :: qx

      integer :: kovun

      qx%ncall = qx%ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == qx%mexpov .or. abs(mb%mp(2)) == qx%mexpov .or.  &
          abs(mc%mp(2)) == qx%mexpov .or. abs(md%mp(2)) == qx%mexpov) kovun = 1
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno .or.  &
          mc%mp(2) == qx%munkno .or. md%mp(2) == qx%munkno) kovun = 2
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMMPYE'
          call fmntr_inp4(ma, mb, mc, md, qx)
      endif

      call fmmpye2(ma, mb, mc, md, me, mf, mg, qx)

      if ((abs(me%mp(2)) == qx%mexpov .and. kovun == 0) .or.  &
          (abs(mf%mp(2)) == qx%mexpov .and. kovun == 0) .or.  &
          (abs(mg%mp(2)) == qx%mexpov .and. kovun == 0) .or.  &
          (abs(me%mp(2)) == qx%munkno .and. kovun < 2)  .or.  &
          (abs(mf%mp(2)) == qx%munkno .and. kovun < 2)  .or.  &
          (abs(mg%mp(2)) == qx%munkno .and. kovun < 2)) then
          qx%namest(qx%ncall) = 'FMMPYE'
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) then
          call fmntr_out3(me, mf, mg, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmmpye

      subroutine fmmpye2(ma, mb, mc, md, me, mf, mg, qx)

!  Triple multiplication routine.  me = ma * mb,   mf = ma * mc,   mg = ma * md

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md, me, mf, mg
      intent (in) :: ma, mb, mc, md
      intent (inout) :: me, mf, mg
      type(fm_settings) :: qx

      integer :: jrssav, kresult

      call fmalloc(me, qx%ndig+2, qx)
      call fmalloc(mf, qx%ndig+2, qx)
      call fmalloc(mg, qx%ndig+2, qx)
      call fmalloc(qx%mwa, 2*qx%ndig+30, qx)
      call fmalloc(qx%mwd, 2*qx%ndig+30, qx)
      call fmalloc(qx%mwe, 2*qx%ndig+30, qx)
      call fmmpye_sc(ma, mb, mc, md, me, mf, mg, kresult, qx)
      if (kresult > 0) then
          return
      endif
      jrssav = qx%jrsign

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      call fmmpye_m1(ma, mb, mc, md, me, mf, mg, qx)
      qx%jrsign = jrssav

      return
      end subroutine fmmpye2

      subroutine fmmpye3(k, ma, mb, mc, md, mw, mr, qx)

!  Round from the work area mw to mr.

!  k = 1 for rounding mw = ma * mb
!  k = 2 for rounding mw = ma * mc
!  k = 3 for rounding mw = ma * md

      use fmvals_parallel
      implicit none

      integer :: k
      type(multi) :: ma, mb, mc, md, mw, mr
      intent (in) :: k, ma, mb, mc, md
      intent (inout) :: mw, mr
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mlr
      double precision :: err
      integer :: j, kl, n1, nguard

      if (qx%ncall > 1) then
          nguard = qx%ngrd21
          if (nguard > qx%ndig) nguard = qx%ndig
      else
          nguard = qx%ngrd52 - 1
      endif
      n1 = qx%ndig + 1

      if (k == 1) then
          qx%jrsign = ma%mp(1) * mb%mp(1)
      else if (k == 2) then
          qx%jrsign = ma%mp(1) * mc%mp(1)
      else
          qx%jrsign = ma%mp(1) * md%mp(1)
      endif
      if (mw%mp(3) == 0) then
          if (qx%ncall >= 1) then
              kl = min(nguard, int(3*qx%dlogtn/qx%dlogmb + 1.5))
              err = 0
              do j = kl, 1, -1
                 err = (err + mw%mp(j+qx%ndig+3)) / qx%mbase
              enddo
              if ( (qx%kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
                   (qx%kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) then
                  if (k == 1) then
                      call fmmpy2(ma, mb, mr, qx)
                  else if (k == 2) then
                      call fmmpy2(ma, mc, mr, qx)
                  else
                      call fmmpy2(ma, md, mr, qx)
                  endif
                  return
              endif
          endif
          mlr = 2*mw%mp(qx%ndig+4) + 1
          if (qx%kround == -1 .or. qx%kround == 2) then
              call fmrnd(mw, qx%ndig, nguard, 1, qx)
          else if (mlr >= qx%mbase) then
              if (mlr-1 > qx%mbase .and. mw%mp(n1+2) < qx%mbase-1) then
                  if (qx%kround /= 0) then
                      mw%mp(n1+2) = mw%mp(n1+2) + 1
                      mw%mp(n1+3) = 0
                  endif
              else
                  call fmrnd(mw, qx%ndig, nguard, 1, qx)
              endif
          endif
      else
          if (qx%ncall >= 1) then
              kl = min(nguard, int(3*qx%dlogtn/qx%dlogmb + 1.5))
              err = 0
              do j = kl, 1, -1
                 err = (err + mw%mp(j+qx%ndig+2)) / qx%mbase
              enddo
              if ( (qx%kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
                   (qx%kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) then
                  if (k == 1) then
                      call fmmpy2(ma, mb, mr, qx)
                  else if (k == 2) then
                      call fmmpy2(ma, mc, mr, qx)
                  else
                      call fmmpy2(ma, md, mr, qx)
                  endif
                  return
              endif
          endif
          mlr = 2*mw%mp(qx%ndig+3) + 1
          if (qx%kround == -1 .or. qx%kround == 2) then
              call fmrnd(mw, qx%ndig, nguard, 0, qx)
          else if (mlr >= qx%mbase) then
              if (mlr-1 > qx%mbase .and. mw%mp(n1+1) < qx%mbase-1) then
                  if (qx%kround /= 0) then
                      mw%mp(n1+1) = mw%mp(n1+1) + 1
                      mw%mp(n1+2) = 0
                  endif
              else
                  call fmrnd(mw, qx%ndig, nguard, 0, qx)
              endif
          endif
      endif
      call fmmove(mw, mr, qx)

      return
      end subroutine fmmpye3

      subroutine fmmpye_m1(ma, mb, mc, md, me, mf, mg, qx)

!  Method 1 for computing  me = ma * mb,   mf = ma * mc,   mg = ma * md

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md, me, mf, mg
      intent (in) :: ma, mb, mc, md
      intent (inout) :: me, mf, mg
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: maxmwa, maxj, mbj, mbkj, mbnorm, mbp1, mcj, mckj, mdj, mdkj,  &
                            mkb, mkc, mkd, mkt, mmax, mt, mtemp
      integer :: j, jm1, k, kb, ki, kj, kl, knz, kwa, l, n1, nguard

      qx%kflag = 0

!             nguard is the number of guard digits used.

      if (qx%ncall > 1) then
          nguard = qx%ngrd22
          if (nguard > qx%ndig) nguard = qx%ndig
      else
          nguard = qx%ngrd52
          if (nguard > qx%ndig) nguard = qx%ndig
          if (qx%mbase < 10**6) nguard = min(nguard+1, qx%ndig+2)
      endif
      if ((ma%mp(3)*mb%mp(3) < qx%mbase .or.  &
           ma%mp(3)*mc%mp(3) < qx%mbase .or.  &
           ma%mp(3)*md%mp(3) < qx%mbase) .and. nguard < 3) nguard = 3

      n1 = qx%ndig + 1
      qx%mwa%mp(2) = ma%mp(2) + mb%mp(2)
      qx%mwd%mp(2) = ma%mp(2) + mc%mp(2)
      qx%mwe%mp(2) = ma%mp(2) + md%mp(2)
      l = qx%ndig + 1 + nguard
      qx%mwa%mp(l+2) = 0
      qx%mwd%mp(l+2) = 0
      qx%mwe%mp(l+2) = 0

!             The multiplication loop begins here.

!             mbnorm is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             maxmwa is an upper bound on the size of values in mwa divided by (mbase-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      mbp1 = qx%mbase + 1
      mbnorm = (maxint/(mbp1*mbp1))
      mmax = intmax - qx%mbase
      mmax = min((maxint/mbp1 - mbp1), mmax)
      if (mbnorm >= 2) then
          mbj = mb%mp(3)
          mcj = mc%mp(3)
          mdj = md%mp(3)

!             Count the trailing zeros in ma.

          knz = n1
          if (ma%mp(n1+1) /= 0) then
              knz = n1
          else
              do j = qx%ndig, 2, -1
                 if (ma%mp(j+1) /= 0) then
                     knz = j
                     exit
                 endif
              enddo
          endif

          qx%mwa%mp(3) = 0
          qx%mwd%mp(3) = 0
          qx%mwe%mp(3) = 0
          do k = qx%ndig+2, l
             qx%mwa%mp(k+1) = 0
             qx%mwd%mp(k+1) = 0
             qx%mwe%mp(k+1) = 0
          enddo

!             (Inner Loop)

          do k = 2, n1
             mtemp = ma%mp(k+1)
             qx%mwa%mp(k+2) = mtemp*mbj
             qx%mwd%mp(k+2) = mtemp*mcj
             qx%mwe%mp(k+2) = mtemp*mdj
          enddo
          maxmwa = mbj
          if (mcj > maxmwa) maxmwa = mcj
          if (mdj > maxmwa) maxmwa = mdj
          do j = 3, n1
             mbj = mb%mp(j+1)
             mcj = mc%mp(j+1)
             mdj = md%mp(j+1)
             maxj = mbj
             if (mcj > maxj) maxj = mcj
             if (mdj > maxj) maxj = mdj
             maxmwa = maxmwa + maxj
             jm1 = j - 1
             kl = min(knz, l-jm1)

!                       Major (Inner Loop)

             do k = j+2, j+kl
                mtemp = ma%mp(k-jm1)
                qx%mwa%mp(k) = qx%mwa%mp(k) + mtemp*mbj
                qx%mwd%mp(k) = qx%mwd%mp(k) + mtemp*mcj
                qx%mwe%mp(k) = qx%mwe%mp(k) + mtemp*mdj
             enddo

             if (maxmwa > mmax) then
                 maxmwa = 0

!                       Here normalization is only required for the range of digits currently
!                       changing in mwa.

                 do kb = jm1+kl, jm1+2, -1
                    mkt = int (qx%mwa%mp(kb+1)/qx%mbase)
                    qx%mwa%mp(kb) = qx%mwa%mp(kb) + mkt
                    qx%mwa%mp(kb+1) = qx%mwa%mp(kb+1) - mkt*qx%mbase
                    mkt = int (qx%mwd%mp(kb+1)/qx%mbase)
                    qx%mwd%mp(kb) = qx%mwd%mp(kb) + mkt
                    qx%mwd%mp(kb+1) = qx%mwd%mp(kb+1) - mkt*qx%mbase
                    mkt = int (qx%mwe%mp(kb+1)/qx%mbase)
                    qx%mwe%mp(kb) = qx%mwe%mp(kb) + mkt
                    qx%mwe%mp(kb+1) = qx%mwe%mp(kb+1) - mkt*qx%mbase
                 enddo
             endif
          enddo

!             Perform the final normalization.  (Inner Loop)

          do kb = l+1, 4, -1
             mkt = int (qx%mwa%mp(kb)/qx%mbase)
             qx%mwa%mp(kb-1) = qx%mwa%mp(kb-1) + mkt
             qx%mwa%mp(kb) = qx%mwa%mp(kb) - mkt*qx%mbase
             mkt = int (qx%mwd%mp(kb)/qx%mbase)
             qx%mwd%mp(kb-1) = qx%mwd%mp(kb-1) + mkt
             qx%mwd%mp(kb) = qx%mwd%mp(kb) - mkt*qx%mbase
             mkt = int (qx%mwe%mp(kb)/qx%mbase)
             qx%mwe%mp(kb-1) = qx%mwe%mp(kb-1) + mkt
             qx%mwe%mp(kb) = qx%mwe%mp(kb) - mkt*qx%mbase
          enddo

      else

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          do j = 2, l
             qx%mwa%mp(j+1) = 0
             qx%mwd%mp(j+1) = 0
             qx%mwe%mp(j+1) = 0
          enddo
          kj = qx%ndig + 2
          do j = 2, n1
             kj = kj - 1
             mbkj = mb%mp(kj+1)
             mckj = mc%mp(kj+1)
             mdkj = md%mp(kj+1)
             kl = l - kj + 1
             if (kl > n1) kl = n1
             ki = kl + 2
             kwa = kl+ kj + 1
             mkb = 0
             mkc = 0
             mkd = 0
             do k = 2, kl
                mt = ma%mp(ki-k+1)*mbkj + qx%mwa%mp(kwa-k+1) + mkb
                mkb = int (mt/qx%mbase)
                qx%mwa%mp(kwa-k+1) = mt - qx%mbase*mkb
                mt = ma%mp(ki-k+1)*mckj + qx%mwd%mp(kwa-k+1) + mkc
                mkc = int (mt/qx%mbase)
                qx%mwd%mp(kwa-k+1) = mt - qx%mbase*mkc
                mt = ma%mp(ki-k+1)*mdkj + qx%mwe%mp(kwa-k+1) + mkd
                mkd = int (mt/qx%mbase)
                qx%mwe%mp(kwa-k+1) = mt - qx%mbase*mkd
             enddo
             qx%mwa%mp(kwa-kl) = mkb
             qx%mwd%mp(kwa-kl) = mkc
             qx%mwe%mp(kwa-kl) = mkd
          enddo

      endif

!             Round, affix the sign, and return.

      call fmmpye3(1, ma, mb, mc, md, qx%mwa, me, qx)
      call fmmpye3(2, ma, mb, mc, md, qx%mwd, mf, qx)
      call fmmpye3(3, ma, mb, mc, md, qx%mwe, mg, qx)

      me%mp(1) = ma%mp(1)*mb%mp(1)
      mf%mp(1) = ma%mp(1)*mc%mp(1)
      mg%mp(1) = ma%mp(1)*md%mp(1)

      return
      end subroutine fmmpye_m1

      subroutine fmmpye_sc(ma, mb, mc, md, me, mf, mg, kresult, qx)

!  Check for special cases for  me = ma * mb,   mf = ma * mc,   mg = ma * md.

!  kresult = 1 is returned if a special case gives the values of md, me.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md, me, mf, mg
      integer :: kresult
      intent (in) :: ma, mb, mc, md
      intent (inout) :: me, mf, mg, kresult
      type(fm_settings) :: qx

      integer :: kb, kc, kj, kovun

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      kresult = 0
      kc = 1000
      if (qx%ndig >= kc .or.                                             &
          abs(ma%mp(2)) > qx%mexpab .or. abs(mb%mp(2)) > qx%mexpab .or.  &
          abs(mc%mp(2)) > qx%mexpab .or. abs(md%mp(2)) > qx%mexpab .or.  &
          qx%mbase*qx%mbase <= mxbase/(4*qx%mbase)) then
          kovun = 0
          if (ma%mp(2) == qx%mexpov .or. ma%mp(2) == qx%mexpun .or.  &
              mb%mp(2) == qx%mexpov .or. mb%mp(2) == qx%mexpun .or.  &
              mc%mp(2) == qx%mexpov .or. mc%mp(2) == qx%mexpun .or.  &
              md%mp(2) == qx%mexpov .or. md%mp(2) == qx%mexpun) kovun = 1
          if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno .or.  &
              mc%mp(2) == qx%munkno .or. md%mp(2) == qx%munkno) kovun = 2
          qx%ncall = qx%ncall + 1
          call fmmpy2(ma, mb, me, qx)
          kb = qx%kflag
          call fmmpy2(ma, mc, mf, qx)
          kj = qx%kflag
          call fmmpy2(ma, md, mg, qx)
          qx%ncall = qx%ncall - 1
          if (((qx%kflag < 0 .or. kb < 0 .or. kj < 0) .and. kovun == 0)  &
              .or. ((qx%kflag == -4 .or. kb == -4 .or. kj == -4) .and.   &
              kovun == 1)) then
              if (qx%kflag == -4 .or. kb == -4 .or. kj == -4) then
                  qx%kflag = -4
              else if (qx%kflag == -5 .or. kb == -5 .or. kj == -5) then
                  qx%kflag = -5
              else
                  qx%kflag = min(qx%kflag, kb)
                  qx%kflag = min(qx%kflag, kj)
              endif
          endif
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0) then
          call fmi2m2(0, me, qx)
          call fmi2m2(0, mf, qx)
          call fmi2m2(0, mg, qx)
          kresult = 1
          return
      endif
      if (mb%mp(3) == 0 .or. mc%mp(3) == 0 .or. md%mp(3) == 0) then
          call fmmpy2(ma, mb, me, qx)
          call fmmpy2(ma, mc, mf, qx)
          call fmmpy2(ma, md, mg, qx)
          kresult = 1
          return
      endif
      qx%kflag = 0

      return
      end subroutine fmmpye_sc

      recursive subroutine fmmpyfft(ma, mb, qx)

!  Internal multiplication routine ma*mb for very high precision.
!  The result is returned in the internal work area mwa.
!  Fast Fourier transforms are used, and the number of digits carried is usually raised slightly,
!  because the fft needs for n to have only small prime factors.

!  Use one of two methods, depending on the base mbase.  When precision is high enough, the size of
!  the digits being convolved using fft's must be reduced in order to keep the convolution products
!  from being too big to exactly recover the integer results.  The fft operation has double
!  precision rounding errors, but the result of the convolution of two lists of integers is really
!  an integer.

!  For example, assume double precision carries 53 bits giving about 16 significant digit accuracy,
!  all the (positive) numbers in the two lists are less than k, and there are n numbers in each
!  list.  Then the convolution is an integer less than n*k*k.  A typical case might have ma and mb
!  in base 10**7 with 50,000 digits for about 350,000 significant digit precision.  This means
!  k = 10**7 and n = 5*10**4, so n*k*k = 5*10**18.  That is too big for this double precision.

!  Method 1:  If the base is a power of a small base ( mbase = b**l for 2 <= b <= 19 ), then change
!             ma and mb to a base that is a smaller power of b to reduce the size of the individual
!             digits.  Changing to this smaller base is a fast o(n) operation.

!             In the example above, ma and mb could be changed to numbers with about 120,000 digits
!             in base 10**3.  Then n*k*k = 1.2*10**11, so even after losing 2 or 3 digits to
!             rounding in the fft the results could be reliably rounded to the nearest integer.

!             This is the method used for the default FM power-of-ten base chosen in fmset.
!             It is faster than method 2.

!  Method 2:  Here a fast change to a smaller base is not available, so each of ma and mb is split
!             into two pieces.  Each piece is a number with the same base and precision as ma and
!             mb have, but has artificially small digits.

!             Suppose the base is near 10**7 but not a power, say mbase = b = 12345678, and ma or
!             mb is
!                       x = 1234567/b + 2345678/b**2 + ... + 9876543/b**n

!             Let k = sqrt(b) = 3513 be the upper bound on the size of the digits in the two
!             pieces, x1 and x2.  We write x = x1 + k*x2 by defining the digits of x1 to be the
!             digits of x mod k, and the digits of x2 to be the digits of x / k.  That gives

!                       x1 = 1504/b + 2507/b**2 + ... + 1500/b**n
!                       x2 =  351/b +  667/b**2 + ... + 2811/b**n

!             Now, x*y = ( x1 + k*x2 ) ( y1 + k*y2 )
!                      =   x1*y1 + k*(x1*y2 + x2*y1) + k**2*x2*y2

!             Since the digits of x1 and x2 are formed one at a time from the corresponding digits
!             of x, generating x1 and x2 is a fast o(n) operation.

!             The terms in these products are still written in base b, but the digits are small,
!             no more than k.  These four multiplications are reduced to three, computing
!             x1*y1, x2*y2, and (x1+x2)*(y1+y2).
!             Then x1*y2 + x2*y1 = (x1+x2)*(y1+y2) - x1*y1 - x2*y2.  See Knuth, v 2, section 4.3.3.

!             Method 2 is recursive, since if n is large enough n*k*k may still be too large for
!             the double precision rounding errors.  In that case another splitting is done, giving
!             digits less than sqrt(aint(sqrt(b))) = 59 in this example.

!             For b = 12345678 and 53-bit double precision, the first splitting is done for all n,
!             since b**2 > 10**14 is already too close to 16-digit integers.
!             A second splitting is done for n larger than about 4*10**5 (about 2.8 million decimal
!             digits), and a third for n > 1.4*10**9 (about 10 billion decimals).

      use fmvals_parallel
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      type(multi) :: mxy(8)
      integer :: j, k, l, ndsave
      double precision :: b, bl, d, dmax


!             Check to see if the base is a power of a small integer.

      do j = 2, 19
         if (j == 2 .or. j == 10) then
             b = 12 - j
         else
             b = j
         endif
         bl = 1
         do l = 1, 100
            bl = bl*b
            if (qx%mbase == bl) then
                call fmmpyfft1(ma, mb, b, l, qx)
                qx%mwa%mp(2) = ma%mp(2) + mb%mp(2)
                return
            endif
            if (qx%mbase < bl) exit
         enddo
      enddo

!             Use method 2.

!             Find the maximum size of the digits in ma and mb.

      dmax = 0
      do j = 1, qx%ndig
         d = ma%mp(j+2)
         if (d > dmax) dmax = d
         d = mb%mp(j+2)
         if (d > dmax) dmax = d
      enddo

!             Check to see if splitting is needed.

      if (dmax**2 > 1/(4.0d3*qx%ndig*epsilon(1.0d0))) then
          k = int(sqrt(dmax))
          ndsave = qx%ndig
          call fmndig(2*qx%ndig + 2, qx)
          call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
          call fmequ(ma, mxy(2), ndsave, qx%ndig, qx)
          call fmequ(mb, mxy(3), ndsave, qx%ndig, qx)
          call fmequ(mb, mxy(4), ndsave, qx%ndig, qx)
          call fmi2m2(0, mxy(5), qx)
          call fmi2m2(0, mxy(6), qx)
          call fmi2m2(0, mxy(7), qx)
          call fmi2m2(0, mxy(8), qx)
          do j = 1, qx%ndig
             l = mxy(1)%mp(j+2)
             mxy(1)%mp(j+2) = mod(l, k)
             mxy(2)%mp(j+2) = l/k
             l = mxy(3)%mp(j+2)
             mxy(3)%mp(j+2) = mod(l, k)
             mxy(4)%mp(j+2) = l/k
          enddo

!             Normalize any of these having a zero leading digit.

          if (mxy(1)%mp(3) == 0) call fmmpyfft_norm(mxy(1), qx)
          if (mxy(2)%mp(3) == 0) call fmmpyfft_norm(mxy(2), qx)
          if (mxy(3)%mp(3) == 0) call fmmpyfft_norm(mxy(3), qx)
          if (mxy(4)%mp(3) == 0) call fmmpyfft_norm(mxy(4), qx)

          qx%ndig = ndsave
          call fmmpyfft(mxy(1), mxy(3), qx)
          call fmndig(2*qx%ndig + 2, qx)
          call fmmove(qx%mwa, mxy(5), qx)
          qx%ndig = ndsave
          call fmmpyfft(mxy(2), mxy(4), qx)
          call fmndig(2*qx%ndig + 2, qx)
          call fmmove(qx%mwa, mxy(6), qx)
          call fmadd2(mxy(1), mxy(2), mxy(7), qx)
          call fmadd2(mxy(3), mxy(4), mxy(8), qx)
          qx%ndig = ndsave
          call fmmpyfft(mxy(7), mxy(8), qx)
          call fmndig(2*qx%ndig + 2, qx)
          call fmmove(qx%mwa, mxy(7), qx)
          qx%ksub = 1
          call fmadd2(mxy(7), mxy(5), mxy(1), qx)
          call fmadd2(mxy(1), mxy(6), mxy(2), qx)
          qx%ksub = 0
          call fmmpyffti(mxy(6), k, mxy(3), qx)
          call fmadd2(mxy(3), mxy(2), mxy(4), qx)
          call fmmpyffti(mxy(4), k, mxy(3), qx)
          call fmadd2(mxy(3), mxy(5), mxy(4), qx)
          qx%mwa%mp(1) = mxy(4)%mp(1)
          qx%mwa%mp(2) = mxy(4)%mp(2)
          if (qx%mwa%mp(3) == 0) qx%mwa%mp(2) = qx%mwa%mp(2) + 1
          qx%ndig = ndsave
      else
          call fmmpyfft2(ma, mb, qx)
          qx%mwa%mp(2) = ma%mp(2) + mb%mp(2)
      endif

      return
      end subroutine fmmpyfft

      subroutine fmmpyfft1(ma, mb, b, l, qx)

      use fmvals_parallel
      implicit none

!  Internal multiplication routine ma*mb for very high precision.
!  The base for the arithmetic (mbase) is a power of b, b**l, for 2 <= b <= 19.  This includes the
!  usual case where the default base chosen in fmset is a power of 10.
!  Fast Fourier transforms are used, and the number of digits carried is usually raised slightly,
!  because the fft needs for n to have only small prime factors.

      complex (kind(0.0d0)), dimension(:), allocatable  :: cx, cy, cz, roots_of_unity
      type(multi) :: ma, mb
      real (kind(0.0d0)) :: b
      integer :: l
      intent (in) :: ma, mb, b, l
      type(fm_settings) :: qx

      integer :: bestdiff, bestk, bestm, diff, j, j2, k, k2, ka, n, n2, nd, nd1,  &
                 num, numar, numai, numbr, numbi
      real (kind(0.0d0)) :: base, c, d, t, t2, theta, tma, tmb
      complex (kind(0.0d0)) :: ci, h1, h2, st, w

!             Initialize guard digits in mwa.

      nd1 = size(qx%mwa%mp)-2
      do j = 2*qx%ndig, min(2*qx%ndig+30, nd1)
         qx%mwa%mp(j+2) = 0
      enddo

!             If the base and/or number of digits is too large, rounding errors in the fft
!             calculation will cause the result to be wrong.
!             Reduce the base if necessary.

      nd = qx%ndig
      base = qx%mbase
      if (qx%mbase**2 > 1/(1.0d3*nd*epsilon(1.0d0))) then
          base = 1/sqrt(1.0d3*nd*epsilon(1.0d0))
          k = log(base)/log(b)
          base = b**k
          nd = qx%ndig*dble(l)/k + 1
      endif

!             Choose the number of digits to use for the fft.
!             Make the size of the array m*2**k where m is a small integer.

      k = 0
      k2 = 1
      do j = 1, 100
         k = k + 1
         k2 = 2*k2
         if (k2 > nd) exit
      enddo
      bestm = 1
      bestk = k
      bestdiff = 2**k - nd
      do j = 3, 15, 2
         k = 0
         k2 = j
         do j2 = 1, 100
            k = k + 1
            k2 = 2*k2
            if (k2 > nd) exit
         enddo
         diff = k2 - nd
         if (diff < bestdiff) then
             bestdiff = diff
             bestm = j
             bestk = k
         endif
      enddo
      n = bestm * 2**bestk
      n2 = n*2
      j = 0
      if (.not. allocated(cx)) then
          allocate(cx(n), stat=j)
      else if (size(cx) /= n) then
          deallocate(cx)
          allocate(cx(n), stat=j)
      endif
      if (j /= 0) then
          call fmdefine_error
      endif
      j = 0
      if (.not. allocated(cy)) then
          allocate(cy(n), stat=j)
      else if (size(cy) /= n) then
          deallocate(cy)
          allocate(cy(n), stat=j)
      endif
      if (j /= 0) then
          call fmdefine_error
      endif
      j = 0
      if (.not. allocated(cz)) then
          allocate(cz(n), stat=j)
      else if (size(cz) /= n) then
          deallocate(cz)
          allocate(cz(n), stat=j)
      endif
      if (j /= 0) then
          call fmdefine_error
      endif
      j = 0
      if (.not. allocated(roots_of_unity)) then
          allocate(roots_of_unity(0:n-1), stat=j)
      else if (size(roots_of_unity) /= n) then
          deallocate(roots_of_unity)
          allocate(roots_of_unity(0:n-1), stat=j)
      endif
      if (j /= 0) then
          call fmdefine_error
      endif
      call fmfft_init(n, roots_of_unity)
!     n_roots_of_unity = n

!             Pad the lists of digits with zeros, then pack the length 2*n real arrays into
!             length n complex arrays to speed up the fft operations.

      if (base == qx%mbase) then
          do j = qx%ndig/2, n
             cx(j) = 0
             cy(j) = 0
          enddo
          do j = 2, qx%ndig, 2
             cx(j/2) = cmplx( ma%mp(j+1) , ma%mp(j+2) , kind(0.0d0) )
             cy(j/2) = cmplx( mb%mp(j+1) , mb%mp(j+2) , kind(0.0d0) )
          enddo
          if (mod(qx%ndig, 2) == 1) then
              cx(qx%ndig/2+1) = ma%mp(qx%ndig+2)
              cy(qx%ndig/2+1) = mb%mp(qx%ndig+2)
          endif
      else
          do j = qx%ndig/2, n
             cx(j) = 0
             cy(j) = 0
          enddo
          d = qx%mbase/base
          c = qx%mbase*d
          tma = ma%mp(3)*qx%mbase + ma%mp(4)
          numar = tma/c
          tma = tma - c*numar
          tmb = mb%mp(3)*qx%mbase + mb%mp(4)
          numbr = tmb/c
          tmb = tmb - c*numbr
          k = 0
          do j = 3, qx%ndig
             do
                if (c >= base) then
                    c = c/base
                else
                    tma = tma*qx%mbase + ma%mp(j+2)
                    tmb = tmb*qx%mbase + mb%mp(j+2)
                    c = c*qx%mbase
                    exit
                endif
                numai = tma/c
                tma = tma - c*numai
                numbi = tmb/c
                tmb = tmb - c*numbi
                if (numar < 0) then
                    numar = numai
                    numbr = numbi
                else
                    k = k + 1
                    cx(k) = cmplx( dble(numar) , dble(numai) , kind(0.0d0) )
                    cy(k) = cmplx( dble(numbr) , dble(numbi) , kind(0.0d0) )
                    numar = -1
                endif
             enddo
          enddo
          do
             if (c >= base) then
                 c = c/base
             else
                 numai = tma*(base/c)
                 numbi = tmb*(base/c)
                 if (numar < 0) then
                     k = k + 1
                     cx(k) = cmplx( dble(numai) , 0.0d0 , kind(0.0d0) )
                     cy(k) = cmplx( dble(numbi) , 0.0d0 , kind(0.0d0) )
                 else
                     k = k + 1
                     cx(k) = cmplx( dble(numar) , dble(numai) , kind(0.0d0) )
                     cy(k) = cmplx( dble(numbr) , dble(numbi) , kind(0.0d0) )
                 endif
                 exit
             endif
             numai = tma/c
             tma = tma - c*numai
             numbi = tmb/c
             tmb = tmb - c*numbi
             if (numar < 0) then
                 numar = numai
                 numbr = numbi
             else
                 k = k + 1
                 cx(k) = cmplx( dble(numar) , dble(numai) , kind(0.0d0) )
                 cy(k) = cmplx( dble(numbr) , dble(numbi) , kind(0.0d0) )
                 numar = -1
             endif
          enddo
      endif

!             Transform.

      call fmfft(cx, n, cz, roots_of_unity)
      if (qx%ksqr /= 1) then
          call fmfft(cy, n, cz, roots_of_unity)
      endif

!             Unpack the two transforms.

      theta = acos(-1.0d0)/n
      w = cmplx( cos(theta) , sin(theta) , kind(0.0d0) )
      st = cmplx( -2*sin(theta/2)**2 , sin(theta) , kind(0.0d0) )
      ci = cmplx( 0.0d0 , 1.0d0 , kind(0.0d0) )
      do j = 2, n/2
         h1 = 0.5d0*(cx(j)+conjg(cx(n+2-j)))
         h2 = -0.5d0*ci*(cx(j)-conjg(cx(n+2-j)))
         cx(j) = h1 + w*h2
         cx(n+2-j) = conjg(h1 - w*h2)
         if (qx%ksqr /= 1) then
             h1 = 0.5d0*(cy(j)+conjg(cy(n+2-j)))
             h2 = -0.5d0*ci*(cy(j)-conjg(cy(n+2-j)))
             cy(j) = h1 + w*h2
             cy(n+2-j) = conjg(h1 - w*h2)
         endif
         w = w + st*w
      enddo
      cx(1) = cmplx( real(cx(1))+aimag(cx(1)) , real(cx(1))-aimag(cx(1)) , kind(0.0d0) )
      if (qx%ksqr /= 1) then
          cy(1) = cmplx( real(cy(1))+aimag(cy(1)) , real(cy(1))-aimag(cy(1)) , kind(0.0d0) )
      endif

!             Multiply.

      if (qx%ksqr /= 1) then
          cz(1) = cmplx( real(cx(1))*real(cy(1)) , aimag(cx(1))*aimag(cy(1)) , kind(0.0d0) )
          do j = 2, n
             cz(j) = cx(j)*cy(j)
          enddo
      else
          cz(1) = cmplx( real(cx(1))*real(cx(1)) , aimag(cx(1))*aimag(cx(1)) , kind(0.0d0) )
          do j = 2, n
             cz(j) = cx(j)*cx(j)
          enddo
      endif

!             Pack the product for input to the final fft.

      theta = -acos(-1.0d0)/n
      w = cmplx( cos(theta) , sin(theta) , kind(0.0d0) )
      st = cmplx( -2*sin(theta/2)**2 , sin(theta) , kind(0.0d0) )
      ci = cmplx( 0.0d0 , 1.0d0 , kind(0.0d0) )
      do j = 2, n/2
         h1 = 0.5d0*(cz(j)+conjg(cz(n+2-j)))
         h2 = 0.5d0*ci*(cz(j)-conjg(cz(n+2-j)))
         cz(j) = h1 + w*h2
         cz(n+2-j) = conjg(h1 - w*h2)
         w = w + st*w
      enddo
      cz(1) = 0.5d0 * cmplx( real(cz(1))+aimag(cz(1)) , real(cz(1))-aimag(cz(1)) , kind(0.0d0) )

!             Transform the product to get the convolution of the original inputs.

      call fmfft(cz, n, cy, roots_of_unity)
      t = 1.0d0/n
      do j = 1, n
         cz(j) = cz(j)*t
      enddo

!             Normalize the digits.

!             The cz array holds the result in scrambled order, with unnormalized digits.
!             The leading two digits of the convolution are in cz(1), then the next two
!             are in cz(n), then cz(n-1), ..., cz(2).
!             The imaginary part of cz(2) is zero (up to roundoff), for a total of 2*n-1
!             digits in the convolution.
!             These digits can be as big as n*base**2 here.
!
!             First normalize and unscramble.

      if (base == qx%mbase) then
          d = aint( 0.5d0+real(cz(2)) , kind(0.0d0) )
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          ka = n2
          if (ka <= size(qx%mwa%mp)-3) then
              qx%mwa%mp(ka+2) = t2
          endif
          do j = 3, n
             d = aint( 0.5d0+aimag(cz(j)) , kind(0.0d0) ) + t
             t = aint( d/base, kind(0.0d0) )
             t2 = d - t*base
             ka = ka - 1
             if (ka <= size(qx%mwa%mp)-3) then
                 qx%mwa%mp(ka+2) = t2
             endif
             d = aint( 0.5d0+real(cz(j)) , kind(0.0d0) ) + t
             t = aint( d/base, kind(0.0d0) )
             t2 = d - t*base
             ka = ka - 1
             if (ka <= size(qx%mwa%mp)-3) then
                 qx%mwa%mp(ka+2) = t2
             endif
          enddo
          d = aint( 0.5d0+aimag(cz(1)) , kind(0.0d0) ) + t
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          ka = ka - 1
          qx%mwa%mp(ka+2) = t2
          d = aint( 0.5d0+real(cz(1)) , kind(0.0d0) ) + t
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          ka = ka - 1
          qx%mwa%mp(ka+2) = t2
          ka = ka - 1
          qx%mwa%mp(ka+2) = t
      else
          ci = cmplx( 0.0d0 , 1.0d0 , kind(0.0d0) )
          d = aint( 0.5d0+real(cz(2)) , kind(0.0d0) )
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          ka = n
          cx(ka) = ci*t2
          do j = 3, n
             d = aint( 0.5d0+aimag(cz(j)) , kind(0.0d0) ) + t
             t = aint( d/base, kind(0.0d0) )
             t2 = d - t*base
             cx(ka) = t2 + cx(ka)
             d = aint( 0.5d0+real(cz(j)) , kind(0.0d0) ) + t
             t = aint( d/base, kind(0.0d0) )
             t2 = d - t*base
             ka = ka - 1
             cx(ka) = ci*t2
          enddo
          d = aint( 0.5d0+aimag(cz(1)) , kind(0.0d0) ) + t
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          cx(ka) = t2 + cx(ka)
          d = aint( 0.5d0+real(cz(1)) , kind(0.0d0) ) + t
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          ka = ka - 1
          cx(ka) = t + ci*t2
          tma = 0
          c = 1
          k = 0
          do j = 1, n2
             if (mod(j, 2) == 1) then
                 num = real(cx((j+1)/2))
             else
                 num = aimag(cx((j+1)/2))
             endif
             tma = tma*base + num
             c = c*base
             if (c < qx%mbase) cycle
             c = c/qx%mbase
             num = tma/c
             tma = tma - c*num
             k = k + 1
             if (k <= size(qx%mwa%mp)-3 .and. k <= 2*qx%ndig+2) then
                 qx%mwa%mp(k+2) = num
             else
                 exit
             endif
          enddo
          k = k + 1
          if (k <= size(qx%mwa%mp)-3 .and. k <= 2*qx%ndig+2) qx%mwa%mp(k+2) = tma*(qx%mbase/c)
      endif

      return
      end subroutine fmmpyfft1

      subroutine fmmpyfft2(ma, mb, qx)
      use fmvals_parallel
      implicit none

!  Internal multiplication routine ma*mb for very high precision.
!  Fast Fourier transforms are used, and the number of digits carried is usually raised slightly,
!  because the fft needs for n to have only small prime factors.
!  This routine is used for method 2 of fmmpyfft, where the base is not a power of a small number
!  and a different kind of splitting is used to avoid fft convolutions becoming too large.

      complex (kind(0.0d0)), dimension(:), allocatable  :: cx, cy, cz, roots_of_unity
      type(multi) :: ma, mb
      intent (in) :: ma, mb
      type(fm_settings) :: qx

      integer :: bestdiff, bestk, bestm, diff, j, j2, k, k2, ka, n, n2, nd, nd1,  &
                 num, numar, numai, numbr, numbi
      real (kind(0.0d0)) :: base, c, d, t, t2, theta, tma, tmb
      complex (kind(0.0d0)) :: ci, h1, h2, st, w

      nd = qx%ndig
      base = qx%mbase

!             Initialize guard digits in mwa.

      nd1 = size(qx%mwa%mp)-2
      do j = 2*qx%ndig, min(2*qx%ndig+30, nd1)
         qx%mwa%mp(j+2) = 0
      enddo

!             Choose the number of digits to use for the fft.  Make the size of the array have no
!             prime factors other than 2, 3, or 5.

      k = 0
      k2 = 1
      do j = 1, 100
         k = k + 1
         k2 = 2*k2
         if (k2 > nd) exit
      enddo
      bestm = 1
      bestk = k
      bestdiff = 2**k - nd
      do j = 3, 15, 2
         k = 0
         k2 = j
         do j2 = 1, 100
            k = k + 1
            k2 = 2*k2
            if (k2 > nd) exit
         enddo
         diff = k2 - nd
         if (diff < bestdiff) then
             bestdiff = diff
             bestm = j
             bestk = k
         endif
      enddo
      n = bestm * 2**bestk
      n2 = n*2
      j = 0
      if (.not. allocated(cx)) then
          allocate(cx(n), stat=j)
      else if (size(cx) /= n) then
          deallocate(cx)
          allocate(cx(n), stat=j)
      endif
      if (j /= 0) then
          call fmdefine_error
      endif
      j = 0
      if (.not. allocated(cy)) then
          allocate(cy(n), stat=j)
      else if (size(cy) /= n) then
          deallocate(cy)
          allocate(cy(n), stat=j)
      endif
      if (j /= 0) then
          call fmdefine_error
      endif
      j = 0
      if (.not. allocated(cz)) then
          allocate(cz(n), stat=j)
      else if (size(cz) /= n) then
          deallocate(cz)
          allocate(cz(n), stat=j)
      endif
      if (j /= 0) then
          call fmdefine_error
      endif
      j = 0
      if (.not. allocated(roots_of_unity)) then
          allocate(roots_of_unity(0:n-1), stat=j)
      else if (size(roots_of_unity) /= n) then
          deallocate(roots_of_unity)
          allocate(roots_of_unity(0:n-1), stat=j)
      endif
      if (j /= 0) then
          call fmdefine_error
      endif
      call fmfft_init(n, roots_of_unity)
!     n_roots_of_unity = n

!             Pad the lists of digits with zeros, then pack the length 2*n real arrays into
!             length n complex arrays to speed up the fft operations.

      if (base == qx%mbase) then
          do j = qx%ndig/2, n
             cx(j) = 0
             cy(j) = 0
          enddo
          do j = 2, qx%ndig, 2
             cx(j/2) = cmplx( ma%mp(j+1) , ma%mp(j+2) , kind(0.0d0) )
             cy(j/2) = cmplx( mb%mp(j+1) , mb%mp(j+2) , kind(0.0d0) )
          enddo
          if (mod(qx%ndig, 2) == 1) then
              cx(qx%ndig/2+1) = ma%mp(qx%ndig+2)
              cy(qx%ndig/2+1) = mb%mp(qx%ndig+2)
          endif
      else
          do j = qx%ndig/2, n
             cx(j) = 0
             cy(j) = 0
          enddo
          d = qx%mbase/base
          c = qx%mbase*d
          tma = ma%mp(3)*qx%mbase + ma%mp(4)
          numar = tma/c
          tma = tma - c*numar
          tmb = mb%mp(3)*qx%mbase + mb%mp(4)
          numbr = tmb/c
          tmb = tmb - c*numbr
          k = 0
          do j = 3, qx%ndig
             do
                if (c >= base) then
                    c = c/base
                else
                    tma = tma*qx%mbase + ma%mp(j+2)
                    tmb = tmb*qx%mbase + mb%mp(j+2)
                    c = c*qx%mbase
                    exit
                endif
                numai = tma/c
                tma = tma - c*numai
                numbi = tmb/c
                tmb = tmb - c*numbi
                if (numar < 0) then
                    numar = numai
                    numbr = numbi
                else
                    k = k + 1
                    cx(k) = cmplx( dble(numar) , dble(numai) , kind(0.0d0) )
                    cy(k) = cmplx( dble(numbr) , dble(numbi) , kind(0.0d0) )
                    numar = -1
                endif
             enddo
          enddo
          do
             if (c >= base) then
                 c = c/base
             else
                 numai = tma*(base/c)
                 numbi = tmb*(base/c)
                 if (numar < 0) then
                     k = k + 1
                     cx(k) = cmplx( dble(numai) , 0.0d0 , kind(0.0d0) )
                     cy(k) = cmplx( dble(numbi) , 0.0d0 , kind(0.0d0) )
                 else
                     k = k + 1
                     cx(k) = cmplx( dble(numar) , dble(numai) , kind(0.0d0) )
                     cy(k) = cmplx( dble(numbr) , dble(numbi) , kind(0.0d0) )
                 endif
                 exit
             endif
             numai = tma/c
             tma = tma - c*numai
             numbi = tmb/c
             tmb = tmb - c*numbi
             if (numar < 0) then
                 numar = numai
                 numbr = numbi
             else
                 k = k + 1
                 cx(k) = cmplx( dble(numar) , dble(numai) , kind(0.0d0) )
                 cy(k) = cmplx( dble(numbr) , dble(numbi) , kind(0.0d0) )
                 numar = -1
             endif
          enddo
      endif

!             Transform.

      call fmfft(cx, n, cz, roots_of_unity)
      if (qx%ksqr /= 1) then
          call fmfft(cy, n, cz, roots_of_unity)
      endif

!             Unpack the two transforms.

      theta = acos(-1.0d0)/n
      w = cmplx( cos(theta) , sin(theta) , kind(0.0d0) )
      st = cmplx( -2*sin(theta/2)**2 , sin(theta) , kind(0.0d0) )
      ci = cmplx( 0.0d0 , 1.0d0 , kind(0.0d0) )
      do j = 2, n/2
         h1 = 0.5d0*(cx(j)+conjg(cx(n+2-j)))
         h2 = -0.5d0*ci*(cx(j)-conjg(cx(n+2-j)))
         cx(j) = h1 + w*h2
         cx(n+2-j) = conjg(h1 - w*h2)
         if (qx%ksqr /= 1) then
             h1 = 0.5d0*(cy(j)+conjg(cy(n+2-j)))
             h2 = -0.5d0*ci*(cy(j)-conjg(cy(n+2-j)))
             cy(j) = h1 + w*h2
             cy(n+2-j) = conjg(h1 - w*h2)
         endif
         w = w + st*w
      enddo
      cx(1) = cmplx( real(cx(1))+aimag(cx(1)) , real(cx(1))-aimag(cx(1)) , kind(0.0d0) )
      if (qx%ksqr /= 1) then
          cy(1) = cmplx( real(cy(1))+aimag(cy(1)) , real(cy(1))-aimag(cy(1)) , kind(0.0d0) )
      endif

!             Multiply.

      if (qx%ksqr /= 1) then
          cz(1) = cmplx( real(cx(1))*real(cy(1)) , aimag(cx(1))*aimag(cy(1)) , kind(0.0d0) )
          do j = 2, n
             cz(j) = cx(j)*cy(j)
          enddo
      else
          cz(1) = cmplx( real(cx(1))*real(cx(1)) , aimag(cx(1))*aimag(cx(1)) , kind(0.0d0) )
          do j = 2, n
             cz(j) = cx(j)*cx(j)
          enddo
      endif

!             Pack the product for input to the final fft.

      theta = -acos(-1.0d0)/n
      w = cmplx( cos(theta) , sin(theta) , kind(0.0d0) )
      st = cmplx( -2*sin(theta/2)**2 , sin(theta) , kind(0.0d0) )
      ci = cmplx( 0.0d0 , 1.0d0 , kind(0.0d0) )
      do j = 2, n/2
         h1 = 0.5d0*(cz(j)+conjg(cz(n+2-j)))
         h2 = 0.5d0*ci*(cz(j)-conjg(cz(n+2-j)))
         cz(j) = h1 + w*h2
         cz(n+2-j) = conjg(h1 - w*h2)
         w = w + st*w
      enddo
      cz(1) = 0.5d0 * cmplx( real(cz(1))+aimag(cz(1)) , real(cz(1))-aimag(cz(1)) , kind(0.0d0) )

!             Transform the product to get the convolution of the original inputs.

      call fmfft(cz, n, cy, roots_of_unity)
      t = 1.0d0/n
      do j = 1, n
         cz(j) = cz(j)*t
      enddo

!             Normalize the digits.

!             The cz array holds the result in scrambled order, with unnormalized digits.
!             The leading two digits of the convolution are in cz(1), then the next two
!             are in cz(n), then cz(n-1), ..., cz(2).
!             The imaginary part of cz(2) is zero (up to roundoff), for a total of 2*n-1
!             digits in the convolution.
!             These digits can be as big as n*base**2 here.
!
!             First normalize and unscramble.

      if (base == qx%mbase) then
          d = aint( 0.5d0+real(cz(2)) , kind(0.0d0) )
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          ka = n2
          if (ka <= size(qx%mwa%mp)-3) then
              qx%mwa%mp(ka+2) = t2
          endif
          do j = 3, n
             d = aint( 0.5d0+aimag(cz(j)) , kind(0.0d0) ) + t
             t = aint( d/base, kind(0.0d0) )
             t2 = d - t*base
             ka = ka - 1
             if (ka <= size(qx%mwa%mp)-3) then
                 qx%mwa%mp(ka+2) = t2
             endif
             d = aint( 0.5d0+real(cz(j)) , kind(0.0d0) ) + t
             t = aint( d/base, kind(0.0d0) )
             t2 = d - t*base
             ka = ka - 1
             if (ka <= size(qx%mwa%mp)-3) then
                 qx%mwa%mp(ka+2) = t2
             endif
          enddo
          d = aint( 0.5d0+aimag(cz(1)) , kind(0.0d0) ) + t
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          ka = ka - 1
          qx%mwa%mp(ka+2) = t2
          d = aint( 0.5d0+real(cz(1)) , kind(0.0d0) ) + t
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          ka = ka - 1
          qx%mwa%mp(ka+2) = t2
          ka = ka - 1
          qx%mwa%mp(ka+2) = t
      else
          ci = cmplx( 0.0d0 , 1.0d0 , kind(0.0d0) )
          d = aint( 0.5d0+real(cz(2)) , kind(0.0d0) )
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          ka = n
          cx(ka) = ci*t2
          do j = 3, n
             d = aint( 0.5d0+aimag(cz(j)) , kind(0.0d0) ) + t
             t = aint( d/base, kind(0.0d0) )
             t2 = d - t*base
             cx(ka) = t2 + cx(ka)
             d = aint( 0.5d0+real(cz(j)) , kind(0.0d0) ) + t
             t = aint( d/base, kind(0.0d0) )
             t2 = d - t*base
             ka = ka - 1
             cx(ka) = ci*t2
          enddo
          d = aint( 0.5d0+aimag(cz(1)) , kind(0.0d0) ) + t
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          cx(ka) = t2 + cx(ka)
          d = aint( 0.5d0+real(cz(1)) , kind(0.0d0) ) + t
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          ka = ka - 1
          cx(ka) = t + ci*t2
          tma = 0
          c = 1
          k = 0
          do j = 1, n2
             if (mod(j, 2) == 1) then
                 num = real(cx((j+1)/2))
             else
                 num = aimag(cx((j+1)/2))
             endif
             tma = tma*base + num
             c = c*base
             if (c < qx%mbase) cycle
             c = c/qx%mbase
             num = tma/c
             tma = tma - c*num
             k = k + 1
             if (k <= size(qx%mwa%mp)-3 .and. k <= 2*qx%ndig+2) then
                 qx%mwa%mp(k+2) = num
             else
                 exit
             endif
          enddo
          k = k + 1
          if (k <= size(qx%mwa%mp)-3 .and. k <= 2*qx%ndig+2) qx%mwa%mp(k+2) = tma*(qx%mbase/c)
      endif

      return
      end subroutine fmmpyfft2

      subroutine fmmpyfft_norm(ma, qx)

!  Normalize a number formed by the x1,x2 splitting done in fmmpyfft.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: j, kz

      kz = 0
      do j = 1, qx%ndig
         if (ma%mp(j+2) == 0) then
             kz = j
         else
             exit
         endif
      enddo
      if (kz == 0) return
      if (kz == qx%ndig) then
          call fmi2m2(0, ma, qx)
          return
      endif
      do j = 1, qx%ndig-kz
         ma%mp(j+2) = ma%mp(j+kz+2)
      enddo
      do j = qx%ndig-kz+1, qx%ndig
         ma%mp(j+2) = 0
      enddo
      ma%mp(2) = ma%mp(2) - kz

      return
      end subroutine fmmpyfft_norm

      subroutine fmmpyffti(ma, ival, mb, qx)

!  mb = ma * ival

!  Multiply fm number ma by one word integer ival.

!  This routine is used during fft-based multiplication.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mcarry, mkt, mlr, mval
      integer :: j, jrssav, ka, kb, kc, kshift, n1, nguard
      type(multi) :: mxy

      call fmalloc(mb, qx%ndig+2, qx)
      call fmalloc(qx%mwa, 2*qx%ndig+30, qx)

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      jrssav = qx%jrsign
      qx%ncall = qx%ncall + 1
      qx%kflag = 0
      n1 = qx%ndig + 1

!             Check for special cases.

      if (ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) then
          call fmunknown(mb, qx)
          qx%kflag = -4
          qx%ncall = qx%ncall - 1
          qx%jrsign = jrssav
          return
      endif

      if (ma%mp(3) == 0) then
          call fmeq(ma, mb, qx)
          qx%ncall = qx%ncall - 1
          qx%jrsign = jrssav
          return
      endif

      if (abs(ma%mp(2)) >= qx%mexpov) then
          call fmi2m(ival, mxy, qx)
          call fmovun_mpy(ma, mxy, mb, qx)
          if (ma%mp(2) /= qx%munkno .and. mxy%mp(2) /= qx%munkno .and.  &
              mb%mp(2) == qx%munkno) then
              qx%kflag = -4
          endif
          qx%ncall = qx%ncall - 1
          qx%jrsign = jrssav
          return
      endif

      if (ival == 0) then
          call fmi2m2(0, mb, qx)
          qx%ncall = qx%ncall - 1
          qx%jrsign = jrssav
          return
      endif

      if (abs(ival) == 1) then
          do j = 1, qx%ndig+2
             mb%mp(j) = ma%mp(j)
          enddo
          if (ma%mp(2) == qx%mexpov) qx%kflag = -5
          if (ma%mp(2) == qx%mexpun) qx%kflag = -6
          mb%mp(1) = ma%mp(1)*ival
          qx%ncall = qx%ncall - 1
          qx%jrsign = jrssav
          return
      endif

      mval = abs(ival)

!             To leave room for the normalization, shift the product to the right kshift
!             places in mwa.

      kshift = int((log(dble(ma%mp(3)+1)*dble(mval)))/qx%dlogmb)
      qx%mwa%mp(2) = ma%mp(2) + kshift
      ka = 2 + kshift
      kb = n1 + kshift
      kc = qx%ndig + 5
      do j = kb, kc
         qx%mwa%mp(j+1) = 0
      enddo

      mcarry = 0

!             This is the main multiplication loop.

      do j = kb, ka, -1
         mkt = ma%mp(j-kshift+1)*mval + mcarry
         mcarry = int (mkt/qx%mbase)
         qx%mwa%mp(j+1) = mkt - mcarry*qx%mbase
      enddo

!             Resolve the final carry.

      do j = ka-1, 2, -1
         mkt = int (mcarry/qx%mbase)
         qx%mwa%mp(j+1) = mcarry - mkt*qx%mbase
         mcarry = mkt
      enddo

!             Now the first significant digit in the product is in
!             mwa%mp(3) or mwa%mp(4).
!             Round the result and move it to mb.

      if ((ma%mp(1) > 0 .and. ival > 0) .or. (ma%mp(1) < 0 .and. ival < 0)) then
          qx%jrsign = 1
      else
          qx%jrsign = -1
      endif
      if (qx%mwa%mp(3) == 0) then
          mlr = 2*qx%mwa%mp(qx%ndig+4) + 1
          if (qx%kround == -1 .or. qx%kround == 2) then
              nguard = kshift - 1
              call fmrnd(qx%mwa, qx%ndig, nguard, 1, qx)
          else if (mlr >= qx%mbase) then
              if (mlr-1 > qx%mbase .and. qx%mwa%mp(n1+2) < qx%mbase-1) then
                  if (qx%kround /= 0) then
                      qx%mwa%mp(n1+2) = qx%mwa%mp(n1+2) + 1
                      qx%mwa%mp(n1+3) = 0
                  endif
              else
                  nguard = kshift - 1
                  call fmrnd(qx%mwa, qx%ndig, nguard, 1, qx)
              endif
          endif
      else
          mlr = 2*qx%mwa%mp(qx%ndig+3) + 1
          if (qx%kround == -1 .or. qx%kround == 2) then
              call fmrnd(qx%mwa, qx%ndig, kshift, 0, qx)
          else if (mlr >= qx%mbase) then
              if (mlr-1 > qx%mbase .and. qx%mwa%mp(n1+1) < qx%mbase-1) then
                  if (qx%kround /= 0) then
                      qx%mwa%mp(n1+1) = qx%mwa%mp(n1+1) + 1
                      qx%mwa%mp(n1+2) = 0
                  endif
              else
                  call fmrnd(qx%mwa, qx%ndig, kshift, 0, qx)
              endif
          endif
      endif
      call fmmove(qx%mwa, mb, qx)

!             Put the sign on the result.

      mb%mp(1) = qx%jrsign
      qx%ncall = qx%ncall - 1
      qx%jrsign = jrssav

      return
      end subroutine fmmpyffti

      subroutine fmmpyi(ma, ival, mb, qx)

!  mb = ma * ival

!  Multiply fm number ma by one word integer ival.

!  This routine is faster than fmmpy when ival*mbase is a one word integer.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      type(fm_settings) :: qx

      qx%kflag = 0
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMMPYI'
      if (qx%ntrace /= 0) then
          call fmntr_inp1i(ma, ival, qx)
          call fmmpyi2(ma, ival, mb, qx)
          call fmntr_out1(mb, qx)
      else
          call fmmpyi2(ma, ival, mb, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmmpyi

      subroutine fmmpyi2(ma, ival, mb, qx)

!  mb = ma * ival

!  Internal routine for multiplying by an integer.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mcarry, mkt, mlr, mval
      integer :: j, jrssav, ka, kb, kc, kshift, n1, nguard, nmval, nv2
      type(multi) :: mxy(1)

      call fmalloc(mb, qx%ndig+2, qx)
      call fmalloc(qx%mwa, 2*qx%ndig+30, qx)

      if (ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) then
          call fmunknown(mb, qx)
          qx%kflag = -4
          return
      endif

!             Check for special cases.

      if (abs(ma%mp(2)) >= qx%mexpov) then
          call fmi2m(ival, mxy(1), qx)
          call fmovun_mpy(ma, mxy(1), mb, qx)
          if (ma%mp(2) /= qx%munkno .and. mxy(1)%mp(2) /= qx%munkno .and.  &
              mb%mp(2) == qx%munkno) then
              qx%kflag = -4
              call fmwarn(qx)
          endif
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      jrssav = qx%jrsign
      qx%kflag = 0
      n1 = qx%ndig + 1
      if (ma%mp(3) == 0) then
          call fmeq(ma, mb, qx)
          qx%jrsign = jrssav
          return
      endif

      if (ival == 0) then
          call fmi2m2(0, mb, qx)
          qx%jrsign = jrssav
          return
      endif

      if (abs(ival) == 1) then
          do j = 1, qx%ndig+2
             mb%mp(j) = ma%mp(j)
          enddo
          if (ma%mp(2) == qx%mexpov) qx%kflag = -5
          if (ma%mp(2) == qx%mexpun) qx%kflag = -6
          mb%mp(1) = ma%mp(1)*ival
          qx%jrsign = jrssav
          return
      endif

      mval = abs(ival)
      nmval = int(mval)
      nv2 = nmval - 1

!             To leave room for the normalization, shift the product to the right kshift
!             places in mwa.

      kshift = int((log(dble(ma%mp(3)+1)*dble(mval)))/qx%dlogmb)

!             If ival is too big use fmmpy.

      if (kshift > qx%ndig .or. mval > maxint/qx%mbase .or.  &
          nmval /= abs(ival) .or. nv2 /= abs(ival)-1) then
          call fmi2m2(ival, mxy(1), qx)
          call fmmpy2(ma, mxy(1), mb, qx)
          qx%jrsign = jrssav
          return
      endif

      qx%mwa%mp(2) = ma%mp(2) + kshift
      ka = 2 + kshift
      kb = n1 + kshift
      kc = qx%ndig + 5
      do j = kb, kc
         qx%mwa%mp(j+1) = 0
      enddo

      mcarry = 0

!             This is the main multiplication loop.

      do j = kb, ka, -1
         mkt = ma%mp(j-kshift+1)*mval + mcarry
         mcarry = int (mkt/qx%mbase)
         qx%mwa%mp(j+1) = mkt - mcarry*qx%mbase
      enddo

!             Resolve the final carry.

      do j = ka-1, 2, -1
         mkt = int (mcarry/qx%mbase)
         qx%mwa%mp(j+1) = mcarry - mkt*qx%mbase
         mcarry = mkt
      enddo

!             Now the first significant digit in the product is in
!             mwa%mp(3) or mwa%mp(4).
!             Round the result and move it to mb.

      if ((ma%mp(1) > 0 .and. ival > 0) .or. (ma%mp(1) < 0 .and. ival < 0)) then
          qx%jrsign = 1
      else
          qx%jrsign = -1
      endif
      if (qx%mwa%mp(3) == 0) then
          mlr = 2*qx%mwa%mp(qx%ndig+4) + 1
          if (qx%kround == -1 .or. qx%kround == 2) then
              nguard = kshift - 1
              call fmrnd(qx%mwa, qx%ndig, nguard, 1, qx)
          else if (mlr >= qx%mbase) then
              if (mlr-1 > qx%mbase .and. qx%mwa%mp(n1+2) < qx%mbase-1) then
                  if (qx%kround /= 0) then
                      qx%mwa%mp(n1+2) = qx%mwa%mp(n1+2) + 1
                      qx%mwa%mp(n1+3) = 0
                  endif
              else
                  nguard = kshift - 1
                  call fmrnd(qx%mwa, qx%ndig, nguard, 1, qx)
              endif
          endif
      else
          mlr = 2*qx%mwa%mp(qx%ndig+3) + 1
          if (qx%kround == -1 .or. qx%kround == 2) then
              call fmrnd(qx%mwa, qx%ndig, kshift, 0, qx)
          else if (mlr >= qx%mbase) then
              if (mlr-1 > qx%mbase .and. qx%mwa%mp(n1+1) < qx%mbase-1) then
                  if (qx%kround /= 0) then
                      qx%mwa%mp(n1+1) = qx%mwa%mp(n1+1) + 1
                      qx%mwa%mp(n1+2) = 0
                  endif
              else
                  call fmrnd(qx%mwa, qx%ndig, kshift, 0, qx)
              endif
          endif
      endif
      call fmmove(qx%mwa, mb, qx)

      if (qx%kflag < 0) then
          qx%namest(qx%ncall) = 'FMMPYI'
          call fmwarn(qx)
      endif

!             Put the sign on the result.

      mb%mp(1) = qx%jrsign
      qx%jrsign = jrssav

      return
      end subroutine fmmpyi2

      subroutine fmmpyi2_r1(ma, ival, qx)

!  ma = ma * ival

!  Internal routine for multiplying by an integer.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ival
      intent (inout) :: ma
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mcarry, mkt, mlr, mval
      integer :: j, jrssav, ka, kb, kc, kshift, n1, nguard, nmval, nv2
      type(multi) :: mxy(2)

      call fmalloc(qx%mwa, 2*qx%ndig+30, qx)

      if (ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) then
          call fmunknown(ma, qx)
          qx%kflag = -4
          return
      endif

!             Check for special cases.

      if (abs(ma%mp(2)) >= qx%mexpov) then
          call fmi2m(ival, mxy(1), qx)
          call fmovun_mpy(ma, mxy(1), mxy(2), qx)
          call fmeq(mxy(2), ma, qx)
          if (ma%mp(2) /= qx%munkno .and. mxy(1)%mp(2) /= qx%munkno .and.  &
              ma%mp(2) == qx%munkno) then
              qx%kflag = -4
              call fmwarn(qx)
          endif
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      jrssav = qx%jrsign
      qx%kflag = 0
      n1 = qx%ndig + 1
      if (ma%mp(3) == 0) then
          qx%jrsign = jrssav
          return
      endif

      if (ival == 0) then
          call fmi2m2(0, ma, qx)
          qx%jrsign = jrssav
          return
      endif

      if (abs(ival) == 1) then
          if (ma%mp(2) == qx%mexpov) qx%kflag = -5
          if (ma%mp(2) == qx%mexpun) qx%kflag = -6
          ma%mp(1) = ma%mp(1)*ival
          qx%jrsign = jrssav
          return
      endif

      mval = abs(ival)
      nmval = int(mval)
      nv2 = nmval - 1

!             To leave room for the normalization, shift the product to the right kshift
!             places in mwa.

      kshift = int((log(dble(ma%mp(3)+1)*dble(mval)))/qx%dlogmb)

!             If ival is too big use fmmpy.

      if (kshift > qx%ndig .or. mval > maxint/qx%mbase .or.  &
          nmval /= abs(ival) .or. nv2 /= abs(ival)-1) then
          call fmi2m2(ival, mxy(1), qx)
          call fmmpy2_r1(ma, mxy(1), qx)
          qx%jrsign = jrssav
          return
      endif

      qx%mwa%mp(2) = ma%mp(2) + kshift
      ka = 2 + kshift
      kb = n1 + kshift
      kc = qx%ndig + 5
      do j = kb, kc
         qx%mwa%mp(j+1) = 0
      enddo

      mcarry = 0

!             This is the main multiplication loop.

      do j = kb, ka, -1
         mkt = ma%mp(j-kshift+1)*mval + mcarry
         mcarry = int (mkt/qx%mbase)
         qx%mwa%mp(j+1) = mkt - mcarry*qx%mbase
      enddo

!             Resolve the final carry.

      do j = ka-1, 2, -1
         mkt = int (mcarry/qx%mbase)
         qx%mwa%mp(j+1) = mcarry - mkt*qx%mbase
         mcarry = mkt
      enddo

!             Now the first significant digit in the product is in
!             mwa%mp(3) or mwa%mp(4).
!             Round the result and move it to ma.

      if ((ma%mp(1) > 0 .and. ival > 0) .or. (ma%mp(1) < 0 .and. ival < 0)) then
          qx%jrsign = 1
      else
          qx%jrsign = -1
      endif
      if (qx%mwa%mp(3) == 0) then
          mlr = 2*qx%mwa%mp(qx%ndig+4) + 1
          if (qx%kround == -1 .or. qx%kround == 2) then
              nguard = kshift - 1
              call fmrnd(qx%mwa, qx%ndig, nguard, 1, qx)
          else if (mlr >= qx%mbase) then
              if (mlr-1 > qx%mbase .and. qx%mwa%mp(n1+2) < qx%mbase-1) then
                  if (qx%kround /= 0) then
                      qx%mwa%mp(n1+2) = qx%mwa%mp(n1+2) + 1
                      qx%mwa%mp(n1+3) = 0
                  endif
              else
                  nguard = kshift - 1
                  call fmrnd(qx%mwa, qx%ndig, nguard, 1, qx)
              endif
          endif
      else
          mlr = 2*qx%mwa%mp(qx%ndig+3) + 1
          if (qx%kround == -1 .or. qx%kround == 2) then
              call fmrnd(qx%mwa, qx%ndig, kshift, 0, qx)
          else if (mlr >= qx%mbase) then
              if (mlr-1 > qx%mbase .and. qx%mwa%mp(n1+1) < qx%mbase-1) then
                  if (qx%kround /= 0) then
                      qx%mwa%mp(n1+1) = qx%mwa%mp(n1+1) + 1
                      qx%mwa%mp(n1+2) = 0
                  endif
              else
                  call fmrnd(qx%mwa, qx%ndig, kshift, 0, qx)
              endif
          endif
      endif
      call fmmove(qx%mwa, ma, qx)

      if (qx%kflag < 0) then
          qx%namest(qx%ncall) = 'FMMPYI'
          call fmwarn(qx)
      endif

!             Put the sign on the result.

      ma%mp(1) = qx%jrsign
      qx%jrsign = jrssav

      return
      end subroutine fmmpyi2_r1

      subroutine fmmpyi_r1(ma, ival, qx)

!  ma = ma * ival

!  Multiply fm number ma by one word integer ival.

!  This routine is faster than fmmpy when ival*mbase is a one word integer.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ival
      intent (inout) :: ma
      type(fm_settings) :: qx

      qx%kflag = 0
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMMPYI_R1'
      if (qx%ntrace /= 0) then
          call fmntr_inp1i(ma, ival, qx)
          call fmmpyi2_r1(ma, ival, qx)
          call fmntr_out1(ma, qx)
      else
          call fmmpyi2_r1(ma, ival, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmmpyi_r1

      subroutine fmnegate(ma, qx)

!  Change the sign of ma.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx

      ma%mp(1) = -ma%mp(1)
      if (ma%mp(3) == 0) ma%mp(1) = 1
      if (ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) ma%mp(1) = 1

      end subroutine fmnegate

      subroutine fmnint(ma, mb, qx)

!  mb = nint(ma)  --  mb is returned as the nearest integer to ma.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: ma2
      double precision :: x, xe, xf, ye, yf
      integer :: kwrnsv, ndsave
      type(multi) :: mxy(3)

      call fmalloc(mb, qx%ndig+2, qx)

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      qx%ncall = qx%ncall + 1
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMNINT'
          call fmntr_inp1(ma, qx)
      endif

      if (ma%mp(2) == qx%munkno .and. ma%mp(5) < 0) then
          qx%kflag = -4
          if (ma%mp(4) > qx%ndig) then
              call fmeq(ma, mb, qx)
          else if (ma%mp(4) < -qx%ndig) then
              call fmi2m(0, mb, qx)
              qx%kflag = 0
          else
              call fmovun_xexf(ma, xe, xf, qx)
              call fmst2m('1.0E+12', mb, qx)
              call fmovun_xexf(mb, ye, yf, qx)
              if (xe > ye .or. (xe == ye .and. xf > yf)) then
                  call fmeq(ma, mb, qx)
              else
                  call fmunknown(mb, qx)
                  x = dble(qx%mbase)**xe * xf
                  if (aint(x) == 0) then
                      mb%mp(4) = 0
                      mb%mp(5) = -maxint * (1/dble(qx%mbase))
                  else
                      x = anint(x)
                      call fmdpm2(x, mxy(1), qx)
                      call fmovun_xexf(mxy(1), ye, yf, qx)
                      qx%kflag = -4
                      mb%mp(4) = ye
                      mb%mp(5) = -maxint * yf
                  endif
                  mb%mp(1) = ma%mp(1)
              endif
          endif
      else if (ma%mp(2) > qx%mexpab) then
          call fmeq(ma, mb, qx)
      else if (ma%mp(2) == qx%mexpun) then
          call fmi2m(0, mb, qx)
      else
          kwrnsv = qx%kwarn
          qx%kwarn = 0
          ndsave = qx%ndig
          call fmndig(qx%ndig + qx%ngrd22, qx)
          call fmequ(ma, mxy(2), ndsave, qx%ndig, qx)
          if (ndsave > int(ma%mp(2))) then
              ma2 = ma%mp(1)
              mxy(2)%mp(1) = 1
              call fmi2m(1, mxy(1), qx)
              call fmdivi_r1(mxy(1), 2, qx)
              call fmadd(mxy(2), mxy(1), mxy(3), qx)
              call fmint(mxy(3), mxy(2), qx)
              if (ma2 < 0) call fmnegate(mxy(2), qx)
              call fmequ(mxy(2), mb, qx%ndig, ndsave, qx)
          else
              call fmequ(mxy(2), mb, qx%ndig, ndsave, qx)
          endif
          qx%kwarn = kwrnsv
          qx%ndig = ndsave
      endif

      if (qx%ntrace /= 0) then
          call fmntr_out1(mb, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmnint

      subroutine fmnorm2(x, n, mb, qx)

!  mb = sqrt( x(1)**2 + x(2)**2 + ... + x(n)**2 )

      use fmvals_parallel
      implicit none

      integer :: n
      type(multi) :: x(n), mb
      intent (in) :: x, n
      intent (inout) :: mb
      type(fm_settings) :: qx

      integer :: j, kl, ndsave
      real (kind(1.0d0)) :: mxsave
      type(multi) :: mxy(2)

      call fmalloc(mb, qx%ndig+2, qx)
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMNORM2  '
      ndsave = qx%ndig
      call fmndig(qx%ndig + qx%ngrd52, qx)
      mxsave = qx%mxexp
      qx%mxexp = qx%mxexp2

!             Check for special cases.

      kl = 0
      do j = 1, n
         if (x(j)%mp(2) == qx%munkno .and. x(j)%mp(5) >= 0) then
             call fmunknown(mxy(2), qx)
             kl = 1
             exit
         endif
      enddo

      if (kl == 0) then
          call fmi2m(0, mxy(2), qx)
          do j = 1, n
             call fmequ(x(j), mxy(1), ndsave, qx%ndig, qx)
             call fmsqr_r1(mxy(1), qx)
             call fmadd_r1(mxy(2), mxy(1), qx)
          enddo
          call fmsqrt_r1(mxy(2), qx)
      endif

      qx%mxexp = mxsave
      call fmequ(mxy(2), mb, qx%ndig, ndsave, qx)
      qx%ndig = ndsave
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmnorm2

      function fmnterms(y, c1, c2, jn, conv, qx)

!  Internal routine for estimating the number of terms needed in a series.

!  y  is the effective argument used in the series.
!  c1, c2, jn describe the coefficients in the series.
!  conv = 1 for convergent series,
!       = 2 for asymptotic series.

      use fmvals_parallel
      implicit none
      double precision :: y
      integer :: c1, c2, jn, conv
      intent (in) :: y, c1, c2, jn, conv
      type(fm_settings) :: qx

      double precision :: a, b, c, fb, fc, tol, z, fmnterms
      double precision, external :: fmdplg

      if (conv == 1) then

!             Convergent series.

          z = y*log(y) - fmdplg(y+1, qx)
          c = 1
          if (c2 == 1) then
              c = (sqrt(4*y + jn**2) - jn)/2
              z = c*log(y) - fmdplg(c+1, qx) - fmdplg(c+jn+1,qx)
          else if (c2 == -1) then
              z = (y*y/2)*log(y) + fmdplg(y*y/4+1, qx) - fmdplg(y*y/2+1,qx)
          endif
          if (abs(y) < 1) z = 0
          tol = z - qx%ndig*qx%dlogmb
          a = y/c1
          if (c2 == 1) then
              a = c
          endif
          if (a < 1) a = 1
          b = 2*a
          fb = c1*b*log(y) - fmdplg(c1*b+1, qx)
          if (c2 == 0) then
              fb = c1*b*log(y) - fmdplg(c1*b+1, qx)
          else if (c2 == 1) then
              fb = c1*b*log(y) - fmdplg(c1*b+1, qx) - fmdplg(c1*(b+jn)+1,qx)
          else if (c2 == -1) then
              fb = c1*b*log(y) + fmdplg(b+1, qx) - fmdplg(c1*b+1,qx)
          endif
          do while (fb > tol)
             a = b
             b = 2*b
             if (c2 == 0) then
                 fb = c1*b*log(y) - fmdplg(c1*b+1, qx)
             else if (c2 == 1) then
                 fb = c1*b*log(y) - fmdplg(c1*b+1, qx) - fmdplg(c1*(b+jn)+1,qx)
             else if (c2 == -1) then
                 fb = c1*b*log(y) + fmdplg(b+1, qx) - fmdplg(c1*b+1,qx)
             endif
          enddo
          do while (b-a > 1)
             c = (a+b)/2
             fc = c1*c*log(y) - fmdplg(c1*c+1, qx)
             if (c2 == 0) then
                 fc = c1*c*log(y) - fmdplg(c1*c+1, qx)
             else if (c2 == 1) then
                 fc = c1*c*log(y) - fmdplg(c1*c+1, qx) - fmdplg(c1*(c+jn)+1,qx)
             else if (c2 == -1) then
                 fc = c1*c*log(y) + fmdplg(c+1, qx) - fmdplg(c1*c+1,qx)
             else
                 fc = c1*c*log(y) - fmdplg(c1*c+1, qx)
             endif
             if (fc < tol) then
                 b = c
             else
                 a = c
             endif
          enddo
          fmnterms = (a+b)/2
      else

!             Asymptotic series.

          tol = -qx%ndig*qx%dlogmb
          a = 1
          b = y/c1
          if (c2 == 1) then
              b = y/2
          endif
          fb = fmdplg(c1*b+1, qx) - c1*b*log(y)
          if (c2 == 0) then
              fb = fmdplg(c1*b+1, qx) - c1*b*log(y)
          else if (c2 == 1) then
              if (-c1*b + jn >= 0) then
                  fb = fmdplg(c1*b+jn+1, qx) - c1*b*log(y) - fmdplg(c1*b+1,qx) - fmdplg(-c1*b+jn+1,qx)
              else
                  fb = fmdplg(c1*b+jn+1, qx) + fmdplg(c1*b-jn+1,qx) - c1*b*log(y) - fmdplg(c1*b+1,qx)
              endif
          endif
          do while (b-a > 1)
             if (abs(fb)/1.0d10 > abs(tol) .and. b/1.0d10 > a*1.1) then
                 c = b/1.0d10
             else if (abs(fb)/1.0d2 > abs(tol) .and. b/1.0d2 > a*1.1) then
                 c = b/1.0d2
             else
                 c = (a+b)/2
             endif
             fc = fmdplg(c1*c+1, qx) - c1*c*log(y)
             if (c2 == 0) then
                 fc = fmdplg(c1*c+1, qx) - c1*c*log(y)
             else if (c2 == 1) then
                 if (-c1*c + jn >= 0) then
                     fc = fmdplg(c1*c+jn+1, qx) - c1*c*log(y) - fmdplg(c1*c+1,qx) - fmdplg(-c1*c+jn+1,qx)
                 else
                     fc = fmdplg(c1*c+jn+1, qx) + fmdplg(c1*c-jn+1,qx) - c1*c*log(y) - fmdplg(c1*c+1,qx)
                 endif
             endif
             if (fc < tol) then
                 b = c
             else
                 a = c
             endif
          enddo
          fmnterms = (a+b)/2
      endif

      return
      end function fmnterms

      subroutine fmntr_inp1(ma, qx)

!  Print FM numbers in base 10 format using fmout for conversion.
!  This is used for tracing input values to the fm routines.

!  ma  -  the fm number to be printed.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx

      character(9) :: name

      if (abs(qx%ntrace) <= 1) return
      if (qx%ncall > qx%lvltrc) return

      name = qx%namest(qx%ncall)
      if (qx%kround == 1) then
          write (qx%kw, "(' Input to ', a)") trim(name)
      else if (qx%kround == 2) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (qx%kround == 0) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (qx%kround == -1) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (qx%kw, "(' Input to ', a)") trim(name)
      endif

!             Check for base mbase internal format trace.

      if (qx%ntrace < 0) then
          call fmntrj(ma, qx%ndig, qx)
      endif

!             Check for base 10 trace using fmout.

      if (qx%ntrace > 0) then
          call fmprnt(ma, qx)
      endif

      return
      end subroutine fmntr_inp1

      subroutine fmntr_inp1i(ma, ival, qx)

!  Print fm numbers in base 10 format using fmout for conversion.
!  This is used for tracing input values to the fm routines.

!  ma   -  the fm number to be printed.
!  ival -  the integer to be printed.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(fm_settings) :: qx

      character(9) :: name

      if (abs(qx%ntrace) <= 1) return
      if (qx%ncall > qx%lvltrc) return

      name = qx%namest(qx%ncall)
      if (qx%kround == 1) then
          write (qx%kw, "(' Input to ', a)") trim(name)
      else if (qx%kround == 2) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (qx%kround == 0) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (qx%kround == -1) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (qx%kw, "(' Input to ', a)") trim(name)
      endif

!             Check for base mbase internal format trace.

      if (qx%ntrace < 0) then
          call fmntrj(ma, qx%ndig, qx)
      endif

!             Check for base 10 trace using fmout.

      if (qx%ntrace > 0) then
          call fmprnt(ma, qx)
      endif

      write (qx%kw, "(1x, i20)") ival

      return
      end subroutine fmntr_inp1i

      subroutine fmntr_inp1ii(ma, k, n, qx)

!  Internal routine for trace output of integer variables.

!  k,n     Integers to be printed.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: k, n
      intent (in) :: ma, k, n
      type(fm_settings) :: qx

      character(9) :: name

      if (abs(qx%ntrace) <= 1) return
      if (qx%ncall > qx%lvltrc) return

      name = qx%namest(qx%ncall)
      if (qx%kround == 1) then
          write (qx%kw, "(' Input to ', a)") trim(name)
      else if (qx%kround == 2) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (qx%kround == 0) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (qx%kround == -1) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (qx%kw, "(' Input to ', a)") trim(name)
      endif

!             Check for base mbase internal format trace.

      if (qx%ntrace < 0) then
          call fmntrj(ma, qx%ndig, qx)
      endif

!             Check for base 10 trace using fmout.

      if (qx%ntrace > 0) then
          call fmprnt(ma, qx)
      endif

      write (qx%kw, "(1x, i20)") k
      write (qx%kw, "(1x, i20)") n

      return
      end subroutine fmntr_inp1ii

      subroutine fmntr_inp2(ma, mb, qx)

!  Print fm numbers in base 10 format using fmout for conversion.
!  This is used for tracing input values to the FM routines.

!  mb, mb  -  the two fm numbers to be printed.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma, mb
      type(fm_settings) :: qx

      character(9) :: name

      if (abs(qx%ntrace) <= 1) return
      if (qx%ncall > qx%lvltrc) return

      name = qx%namest(qx%ncall)
      if (qx%kround == 1) then
          write (qx%kw, "(' Input to ', a)") trim(name)
      else if (qx%kround == 2) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (qx%kround == 0) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (qx%kround == -1) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (qx%kw, "(' Input to ', a)") trim(name)
      endif

!             Check for base mbase internal format trace.

      if (qx%ntrace < 0) then
          call fmntrj(ma, qx%ndig, qx)
          call fmntrj(mb, qx%ndig, qx)
      endif

!             Check for base 10 trace using fmout.

      if (qx%ntrace > 0) then
          call fmprnt(ma, qx)
          call fmprnt(mb, qx)
      endif

      return
      end subroutine fmntr_inp2

      subroutine fmntr_inp3(ma, mb, mc, qx)

!  Print fm numbers in base 10 format using fmout for conversion.
!  This is used for tracing input values to the fm routines.

!  mb, mb, mc  -  the fm numbers to be printed.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb, mc
      type(fm_settings) :: qx

      character(9) :: name

      if (abs(qx%ntrace) <= 1) return
      if (qx%ncall > qx%lvltrc) return

      name = qx%namest(qx%ncall)
      if (qx%kround == 1) then
          write (qx%kw, "(' Input to ', a)") trim(name)
      else if (qx%kround == 2) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (qx%kround == 0) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (qx%kround == -1) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (qx%kw, "(' Input to ', a)") trim(name)
      endif

!             Check for base mbase internal format trace.

      if (qx%ntrace < 0) then
          call fmntrj(ma, qx%ndig, qx)
          call fmntrj(mb, qx%ndig, qx)
          call fmntrj(mc, qx%ndig, qx)
      endif

!             Check for base 10 trace using fmout.

      if (qx%ntrace > 0) then
          call fmprnt(ma, qx)
          call fmprnt(mb, qx)
          call fmprnt(mc, qx)
      endif

      return
      end subroutine fmntr_inp3

      subroutine fmntr_inp4(ma, mb, mc, md, qx)

!  Print fm numbers in base 10 format using fmout for conversion.
!  This is used for tracing input values to the fm routines.

!  mb, mb, mc, md  -  the fm numbers to be printed.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc, md
      type(fm_settings) :: qx

      character(9) :: name

      if (abs(qx%ntrace) <= 1) return
      if (qx%ncall > qx%lvltrc) return

      name = qx%namest(qx%ncall)
      if (qx%kround == 1) then
          write (qx%kw, "(' Input to ', a)") trim(name)
      else if (qx%kround == 2) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (qx%kround == 0) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (qx%kround == -1) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (qx%kw, "(' Input to ', a)") trim(name)
      endif

!             Check for base mbase internal format trace.

      if (qx%ntrace < 0) then
          call fmntrj(ma, qx%ndig, qx)
          call fmntrj(mb, qx%ndig, qx)
          call fmntrj(mc, qx%ndig, qx)
          call fmntrj(md, qx%ndig, qx)
      endif

!             Check for base 10 trace using fmout.

      if (qx%ntrace > 0) then
          call fmprnt(ma, qx)
          call fmprnt(mb, qx)
          call fmprnt(mc, qx)
          call fmprnt(md, qx)
      endif

      return
      end subroutine fmntr_inp4

      subroutine fmntr_inpd(x, qx)

!  Internal routine for trace output of double precision variables.

!  x     Value to be printed.

      use fmvals_parallel
      implicit none

      double precision :: x
      intent (in) :: x
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return
      if (abs(qx%ntrace) == 1) return

      name = qx%namest(qx%ncall)
      if (qx%kround == 1) then
          write (qx%kw, "(' Input to ', a)") trim(name)
      else if (qx%kround == 2) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (qx%kround == 0) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (qx%kround == -1) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (qx%kw, "(' Input to ', a)") trim(name)
      endif

      write (qx%kw, "(1x, es30.20)") x

      return
      end subroutine fmntr_inpd

      subroutine fmntr_inpi(n, qx)

!  Internal routine for trace output of integer variables.

!  n     Integer to be printed.

      use fmvals_parallel
      implicit none

      integer :: n
      intent (in) :: n
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return
      if (abs(qx%ntrace) == 1) return

      name = qx%namest(qx%ncall)
      if (qx%kround == 1) then
          write (qx%kw, "(' Input to ', a)") trim(name)
      else if (qx%kround == 2) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (qx%kround == 0) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (qx%kround == -1) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (qx%kw, "(' Input to ', a)") trim(name)
      endif

      write (qx%kw, "(1x, i20)") n

      return
      end subroutine fmntr_inpi

      subroutine fmntr_inpi1(ival, ma, qx)

!  Print fm numbers in base 10 format using fmout for conversion.
!  This is used for tracing input values to the fm routines.

!  ival -  the integer to be printed.
!  ma   -  the fm number to be printed.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(fm_settings) :: qx

      character(9) :: name

      if (abs(qx%ntrace) <= 1) return
      if (qx%ncall > qx%lvltrc) return

      name = qx%namest(qx%ncall)
      if (qx%kround == 1) then
          write (qx%kw, "(' Input to ', a)") trim(name)
      else if (qx%kround == 2) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (qx%kround == 0) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (qx%kround == -1) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (qx%kw, "(' Input to ', a)") trim(name)
      endif

      write (qx%kw, "(1x, i20)") ival

!             Check for base mbase internal format trace.

      if (qx%ntrace < 0) then
          call fmntrj(ma, qx%ndig, qx)
      endif

!             Check for base 10 trace using fmout.

      if (qx%ntrace > 0) then
          call fmprnt(ma, qx)
      endif

      return
      end subroutine fmntr_inpi1

      subroutine fmntr_inpii(n1, n2, qx)

!  Internal routine for trace output of integer variables.

!  n1, n2     Integers to be printed.

      use fmvals_parallel
      implicit none

      integer :: n1, n2
      intent (in) :: n1, n2
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return
      if (abs(qx%ntrace) == 1) return

      name = qx%namest(qx%ncall)
      if (qx%kround == 1) then
          write (qx%kw, "(' Input to ', a)") trim(name)
      else if (qx%kround == 2) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (qx%kround == 0) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (qx%kround == -1) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (qx%kw, "(' Input to ', a)") trim(name)
      endif

      write (qx%kw, "(1x, i20)") n1
      write (qx%kw, "(1x, i20)") n2

      return
      end subroutine fmntr_inpii

      subroutine fmntr_inpr(x, qx)

!  Internal routine for trace output of single precision variables.

!  x     Value to be printed.

      use fmvals_parallel
      implicit none

      real :: x
      intent (in) :: x
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return
      if (abs(qx%ntrace) == 1) return

      name = qx%namest(qx%ncall)
      if (qx%kround == 1) then
          write (qx%kw, "(' Input to ', a)") trim(name)
      else if (qx%kround == 2) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (qx%kround == 0) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (qx%kround == -1) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (qx%kw, "(' Input to ', a)") trim(name)
      endif

      write (qx%kw, "(1x, es20.10)") x

      return
      end subroutine fmntr_inpr

      subroutine fmntr_inpz(z, qx)

!  Internal routine for trace input of double precision variables.

!  z     Value to be printed.

      use fmvals_parallel
      implicit none

      complex :: z
      intent (in) :: z
      type(fm_settings) :: qx

      character(9) :: name
      double precision :: zreal, zimag

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return
      if (abs(qx%ntrace) == 1) return

      name = qx%namest(qx%ncall)
      if (qx%kround == 1) then
          write (qx%kw, "(' Input to ', a)") trim(name)
      else if (qx%kround == 2) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (qx%kround == 0) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (qx%kround == -1) then
          write (qx%kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (qx%kw, "(' Input to ', a)") trim(name)
      endif

      zreal = dble(z)
      zimag = dble(aimag(z))
      if (zimag >= 0.0d0) then
          write (qx%kw, "(1x, es20.10, ' +', es20.10, ' i')") zreal, zimag
      else
          write (qx%kw, "(1x, es20.10, ' -', es20.10, ' i')") zreal, abs(zimag)
      endif

      return
      end subroutine fmntr_inpz

      subroutine fmntr_out1(ma, qx)

!  Print fm numbers in base 10 format using fmout for conversion.
!  This is used for tracing output values from the fm routines.

!  ma  -  the fm number to be printed.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return

      name = qx%namest(qx%ncall)
      if (qx%kflag == 0) then
          write (qx%kw,                                                   &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10, 5X, 'NDIG =', I10)"                                &
                ) name, qx%ncall, int(qx%mbase), qx%ndig
      else
          write (qx%kw,                                                  &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"            &
                ) name, qx%ncall, int(qx%mbase), qx%ndig, qx%kflag
      endif

!             Check for base mbase internal format trace.

      if (qx%ntrace < 0) then
          call fmntrj(ma, qx%ndig, qx)
      endif

!             Check for base 10 trace using fmout.

      if (qx%ntrace > 0) then
          call fmprnt(ma, qx)
      endif

      return
      end subroutine fmntr_out1

      subroutine fmntr_out2(ma, mb, qx)

!  Print fm numbers in base 10 format using fmout for conversion.
!  This is used for tracing output values from the fm routines.

!  ma, mb  -  the fm numbers to be printed.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma, mb
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return

      name = qx%namest(qx%ncall)
      if (qx%kflag == 0) then
          write (qx%kw,                                                   &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10, 5X, 'NDIG =', I10)"                                &
                ) name, qx%ncall, int(qx%mbase), qx%ndig
      else
          write (qx%kw,                                                  &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"            &
                ) name, qx%ncall, int(qx%mbase), qx%ndig, qx%kflag
      endif

!             Check for base mbase internal format trace.

      if (qx%ntrace < 0) then
          call fmntrj(ma, qx%ndig, qx)
          call fmntrj(mb, qx%ndig, qx)
      endif

!             Check for base 10 trace using fmout.

      if (qx%ntrace > 0) then
          call fmprnt(ma, qx)
          call fmprnt(mb, qx)
      endif

      return
      end subroutine fmntr_out2

      subroutine fmntr_out3(ma, mb, mc, qx)

!  Print fm numbers in base 10 format using fmout for conversion.
!  This is used for tracing output values from the fm routines.

!  ma, mb, mc  -  the fm numbers to be printed.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb, mc
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return

      name = qx%namest(qx%ncall)
      if (qx%kflag == 0) then
          write (qx%kw,                                                   &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10, 5X, 'NDIG =', I10)"                                &
                ) name, qx%ncall, int(qx%mbase), qx%ndig
      else
          write (qx%kw,                                                  &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"            &
                ) name, qx%ncall, int(qx%mbase), qx%ndig, qx%kflag
      endif

!             Check for base mbase internal format trace.

      if (qx%ntrace < 0) then
          call fmntrj(ma, qx%ndig, qx)
          call fmntrj(mb, qx%ndig, qx)
          call fmntrj(mc, qx%ndig, qx)
      endif

!             Check for base 10 trace using fmout.

      if (qx%ntrace > 0) then
          call fmprnt(ma, qx)
          call fmprnt(mb, qx)
          call fmprnt(mc, qx)
      endif

      return
      end subroutine fmntr_out3

      subroutine fmntr_outd(x, qx)

!  Internal routine for trace output of double precision variables.

!  x     Value to be printed.

      use fmvals_parallel
      implicit none

      double precision :: x
      intent (in) :: x
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return

      name = qx%namest(qx%ncall)
      if (qx%kflag == 0) then
          write (qx%kw,                                                   &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10, 5X, 'NDIG =', I10)"                                &
                ) name, qx%ncall, int(qx%mbase), qx%ndig
      else
          write (qx%kw,                                                  &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"            &
                ) name, qx%ncall, int(qx%mbase), qx%ndig, qx%kflag
      endif

      write (qx%kw, "(1x, es30.20)") x

      return
      end subroutine fmntr_outd

      subroutine fmntr_outi(n, qx)

!  Internal routine for trace output of integer variables.

!  n     Integer to be printed.

      use fmvals_parallel
      implicit none

      integer :: n
      intent (in) :: n
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return

      name = qx%namest(qx%ncall)
      if (qx%kflag == 0) then
          write (qx%kw,                                                   &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10, 5X, 'NDIG =', I10)"                                &
                ) name, qx%ncall, int(qx%mbase), qx%ndig
      else
          write (qx%kw,                                                  &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"            &
                ) name, qx%ncall, int(qx%mbase), qx%ndig, qx%kflag
      endif

      write (qx%kw, "(1x, i20)") n

      return
      end subroutine fmntr_outi

      subroutine fmntr_outr(x, qx)

!  Internal routine for trace output of real variables.

!  x     Value to be printed.

      use fmvals_parallel
      implicit none

      real :: x
      intent (in) :: x
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return

      name = qx%namest(qx%ncall)
      if (qx%kflag == 0) then
          write (qx%kw,                                                   &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10, 5X, 'NDIG =', I10)"                                &
                ) name, qx%ncall, int(qx%mbase), qx%ndig
      else
          write (qx%kw,                                                  &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"            &
                ) name, qx%ncall, int(qx%mbase), qx%ndig, qx%kflag
      endif

      write (qx%kw, "(1x, es20.10)") x

      return
      end subroutine fmntr_outr

      subroutine fmntr_outz(z, qx)

!  Internal routine for trace output of double precision variables.

!  z     Value to be printed.

      use fmvals_parallel
      implicit none

      complex :: z
      intent (in) :: z
      type(fm_settings) :: qx

      character(9) :: name
      double precision :: zreal, zimag

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return

      name = qx%namest(qx%ncall)
      if (qx%kflag == 0) then
          write (qx%kw,                                                   &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10, 5X, 'NDIG =', I10)"                                &
                ) name, qx%ncall, int(qx%mbase), qx%ndig
      else
          write (qx%kw,                                                  &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"            &
                ) name, qx%ncall, int(qx%mbase), qx%ndig, qx%kflag
      endif

      zreal = dble(z)
      zimag = dble(aimag(z))
      if (zimag >= 0.0d0) then
          write (qx%kw, "(1x, es20.10, ' +', es20.10, ' i')") zreal, zimag
      else
          write (qx%kw, "(1x, es20.10, ' -', es20.10, ' i')") zreal, abs(zimag)
      endif

      return
      end subroutine fmntr_outz

      subroutine fmntrj(ma, nd, qx)

!  Print trace output in internal base mbase format.  The number to be printed is in ma.

!  nd is the number of base mbase digits to be printed.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: nd
      intent (in) :: ma, nd
      type(fm_settings) :: qx

      character(99) :: form
      character(40), external :: fmfi
      character(40) :: st1, st2
      integer :: j, l, n

      l = int(log10(dble(qx%mbase-1))) + 2
      n = (qx%kswide-23)/l
      if (n > 10) n = 5*(n/5)
      if (nd <= n) then
          write (form, "(' (1x, i19, i', i2, ', ', i3, 'i', i2, ') ')") l+2, n-1, l
      else
          write (form, "(' (1x, i19, i', i2, ', ', i3, 'i', i2, '/"  //  &
                      "(22x, ', i3, 'i', i2, ')) ')"                     &
                ) l+2, n-1, l, n, l
      endif

      st1 = fmfi(int(ma%mp(1)))
      st2 = fmfi(int(ma%mp(2)))
      write (qx%kw, "(A, A, A, A, A)") '            Sign = ', trim(st1),  &
                 '   Exponent = ', trim(st2), '   Digits:'
      write (form,*) '(13X, ', n, 'I', l, ')'
      if (ma%mp(5) < 0) then
          if (nd+2 >= 6) then
              write (qx%kw, form) int(ma%mp(3)), 0, 0, (int(ma%mp(j)), j=6, nd+2)
          else if (nd+2 == 5) then
              write (qx%kw, form) int(ma%mp(3)), 0, 0
          else
              write (qx%kw, form) int(ma%mp(3)), 0
          endif
      else
          write (qx%kw, form) (int(ma%mp(j)), j=3, nd+2)
      endif

      return
      end subroutine fmntrj

      subroutine fmout(ma, line, lb, qx)

!  Convert a floating multiple precision number to a character array for output.

!  ma   is an fm number to be converted to an a1 character array in base 10 format.
!  line is the character(1) array in which the result is returned.
!  lb   is the length of line.

! jform1 and jform2 (in module fmvals) determine the format of line.

! jform1 = 0  normal setting  ( .314159m+6 )
!        = 1  es  format      ( 3.14159m+5 )
!        = 2  f   format      ( 314159.000 )

! jform2 = number of significant digits to display (if jform1 = 0, 1)
!        = number of digits after the decimal point (if jform1 = 2)

!          If jform2 == 0 and jform1 /= 2 then a default number of digits is chosen.
!          The default is roughly the full precision of ma.

!          If jform2 == 0 and jform1 == 2 then the number is returned in integer format with no
!          decimal point.  Rounding is done as with other settings, so the value displayed is the
!          nearest integer to ma.

!  If jform1 == 2 and ma is too large or too small to display in the requested format, it is
!  converted using jform1=0, jform2=0.

!  line should be dimensioned at least log10(mbase)*ndig + 15 on a 32-bit machine to allow for up to
!  10 digit exponents.  Replace 15 by 20 if 48-bit integers are used, 25 for 64-bit integers, ....

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: lb
      character :: line(lb)
      intent (in) :: ma, lb
      intent (inout) :: line
      type(fm_settings) :: qx

      type(multi) :: mxy(2), mresult
      integer :: j, jfsave, kovun, kresult, ndsave, npower
      real (kind(1.0d0)) :: mbsave, mxsave

      jfsave = qx%jform2
      if (qx%jform2 == 0 .and. qx%jform1 /= 2 .and. abs(ma%mp(2)) < qx%mexpov) then
          qx%jform2 = max( 1.5d0 + (qx%ndig-1)*log10(dble(qx%mbase)) , 5.0d0 )
      endif
      j = qx%ntrace
      qx%ntrace = 0
      mbsave = qx%mbase
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmout_sc(ma, mxy, mresult, mbsave, ndsave, npower, line, lb, kresult, qx)
      if (kresult > 0) then
          qx%ntrace = j
          qx%mbase = mbsave
          qx%jform2 = jfsave
          call fmexit0(mxsave, ndsave, qx)
          return
      endif

      call fmout_m1(mxy, mresult, npower, mbsave, ndsave, line, lb, qx)

      qx%ntrace = j
      qx%mbase = mbsave
      qx%jform2 = jfsave
      call fmexit0(mxsave, ndsave, qx)
      call fmcons(qx)

      return
      end subroutine fmout

      subroutine fmout_err(line, lb)

      implicit none

      integer :: lb
      character :: line(lb)
      intent (in) :: lb
      intent (inout) :: line

      integer :: j

      do j = 1, lb
         line(j) = '*'
      enddo

      return
      end subroutine fmout_err

      subroutine fmout_m1(mxy, mx, npower, mbsave, ndsave, line, lb, qx)

!  Method 1 for fmout.

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(2), mx
      integer :: lb, ndsave, npower
      real (kind(1.0d0)) :: mbsave
      character :: line(lb)
      intent (in) :: mx, npower, mbsave, ndsave, lb
      intent (inout) :: mxy, line
      type(fm_settings) :: qx

      integer :: i, j, jd, jf1, jf2, jp, k, k0, k1, k2, k1sav, kd, kd1, kde, kdig, kdpt,  &
                 ke, ke2, kmid, kpt, kpt1, ksh, nd, ndg, nlz, ntz
      character :: numb(10) = (/ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' /), temp

      kdpt = 0
      jf1 = qx%jform1
      jf2 = qx%jform2
      k1 = 1
      jp = 10
      kd1 = mx%mp(3)
      ke = mx%mp(2)
      do j = 1, npower
         if (kd1 < jp) exit
         k1 = k1 + 1
         jp = 10 * jp
      enddo
      k0 = k1
      k1sav = k1

!             nd is the number of base ten digits to display in the current output format.

      if (jf1 <= 1) then
          nd = min( jf2, k1 + npower*(qx%ndig-1) )
      else
          if (ke >= 1) then
              if (k1 + npower*(ke-1) + jf2 + 3 > lb) then
                  jf1 = 0
                  nd = max( 1.5d0 + (ndsave-1)*log10(dble(mbsave)) , 5.0d0 )
                  jf2 = nd
              else
                  nd = min( k1 + npower*(ke-1) + jf2, k1 + npower*(qx%ndig-1) )
              endif
          else
              if (npower - k1 + npower*(-ke) >= jf2) then
                  jf1 = 0
                  nd = max( 1.5d0 + (ndsave-1)*log10(dble(mbsave)) , 5.0d0 )
                  jf2 = nd
              else
                  nd = min( jf2 - (npower - k1 + npower*(-ke)), k1 + npower*(qx%ndig-1) )
              endif
          endif
      endif

      k = abs(k1-npower+ke*npower)
      if (k == 0) k = 1
      kdig = max( 1.0d0, log10(dble(k)) + 1 )
      k = lb - kdig - 4
      if (nd > k) then
          nd = k
          if (nd <= 0) then
              call fmout_err(line, lb)
              return
          endif
      endif
!             Shift mx if necessary to put the nd'th significant decimal at the right
!             end of a word boundary in base mbase.

      i = ceiling(dble(nd - k1)/dble(npower) + 1)
      ksh = k1 + npower*(i-1) - nd
      if (ksh >= k1) then
          ksh = npower - ksh
          call fmmpyi2(mx, 10**ksh, mxy(1), qx)
          k1 = k1 + ksh
          i = ceiling(dble(nd - k1)/dble(npower) + 1)
      else
          call fmdivi2(mx, 10**ksh, mxy(1), qx)
          k1 = k1 - ksh
      endif

      call fmalloc(mxy(2), i+4, qx)
      if (i <= 2) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+2, qx)
          do j = qx%ndig+4, 5, -1
             mxy(1)%mp(j) = mxy(1)%mp(j-2)
          enddo
          mxy(1)%mp(3) = 1
          mxy(1)%mp(4) = 0
          call fmequ(mxy(1), mxy(2), qx%ndig+2, i+2, qx)
          if (mxy(2)%mp(4) > 0) then
              do j = 3, i+2
                 mxy(2)%mp(j) = mxy(2)%mp(j+1)
              enddo
          else
              do j = 3, i+2
                 mxy(2)%mp(j) = mxy(2)%mp(j+2)
              enddo
          endif
      else
          call fmequ(mxy(1), mxy(2), qx%ndig, i, qx)
      endif
      mxy(2)%mp(3+i) = 0

      k2 = 1
      jp = 10
      kd1 = mxy(2)%mp(3)
      do j = 1, npower
         if (kd1 < jp) exit
         k2 = k2 + 1
         jp = 10 * jp
      enddo

!             Check to see if rounding has caused the base mbase exponent of mx (ke) to change.

      if (k2 /= k1) then
          if (k0 == npower) then
              ke = ke + 1
          endif
          k1 = k2
          k1sav = k1sav + 1
          if (k1sav > npower) k1sav = 1
      endif

!             The first nd decimal digits have been rounded in mxy(2).
!             Build the output line.

      if (mx%mp(1) < 0) then
          line(1) = '-'
      endif
      if (jf1 == 2) then

!               Fixed format.

          kpt = 2
          if (ke >= 1) then
              ke2 = ke
              if (k1-k1sav < 0) ke2 = ke + 1
              do j = 1, ke2
                 kd = npower
                 if (j == 1) kd = k1
                 if (j > qx%ndig) exit
                 kdig = mxy(2)%mp(j+2)
                 if (lb < kpt+kd-1) then
                     call fmout_err(line, lb)
                     return
                 endif
                 do jd = 1, kd
                    ndg = mod(kdig, 10)
                    line(kpt+kd-jd) = numb(ndg+1)
                    kdig = kdig / 10
                 enddo
                 kpt = kpt + kd
              enddo
              ksh = k1 - k1sav
              if (lb < kpt) then
                  call fmout_err(line, lb)
                  return
              endif
              if (ksh > 0) then
                  do j = kpt, kpt-ksh+1, -1
                     line(j) = line(j-1)
                  enddo
                  line(kpt-ksh) = '.'
                  kdpt = kpt - ksh
              else if (ksh < 0) then
                  ksh = npower + ksh
                  do j = kpt, kpt-ksh+1, -1
                     line(j) = line(j-1)
                  enddo
                  line(kpt-ksh) = '.'
                  kdpt = kpt - ksh
              else
                  line(kpt) = '.'
                  kdpt = kpt
              endif
              kpt = kpt + 1
              if (lb < kpt) then
                  call fmout_err(line, lb)
                  return
              endif
              if (jf2 == 0) then
                  do j = kpt, 1, -1
                     if (line(j) /= '.') then
                         line(j) = ' '
                     else
                         line(j) = ' '
                         return
                     endif
                  enddo
              endif
              j = ke2 + 1
              do while (kpt <= nd+2)
                 kd = npower
                 kdig = mxy(2)%mp(j+2)
                 if (lb < kpt+kd-1) then
                     call fmout_err(line, lb)
                     return
                 endif
                 do jd = 1, kd
                    ndg = mod(kdig, 10)
                    line(kpt+kd-jd) = numb(ndg+1)
                    kdig = kdig / 10
                 enddo
                 j = j + 1
                 kpt = kpt + kd
              enddo
          else
              nlz = max(0, npower - k1sav - npower*ke)
              if (lb < kpt+nlz) then
                  call fmout_err(line, lb)
                  return
              endif
              line(kpt) = '.'
              kdpt = kpt
              kpt = kpt + 1
              do j = 1, nlz
                 line(kpt) = '0'
                 kpt = kpt + 1
              enddo
              do j = 1, i
                 kd = npower
                 if (j == 1) kd = k1
                 kdig = mxy(2)%mp(j+2)
                 if (lb < kpt+kd-1) then
                     call fmout_err(line, lb)
                     return
                 endif
                 do jd = 1, kd
                    ndg = mod(kdig, 10)
                    line(kpt+kd-jd) = numb(ndg+1)
                    kdig = kdig / 10
                 enddo
                 kpt = kpt + kd
              enddo
          endif
          ntz = jf2 - (kpt-kdpt-1)
          if (ntz > 0) then
              if (lb < kpt+ntz-1) then
                  call fmout_err(line, lb)
                  return
              endif
              do j = 1, ntz
                 line(kpt) = '0'
                 kpt = kpt + 1
              enddo
          endif
      else
!
!               Exponential format.
!
          if (nd > jf2) jf2 = nd
          kpt = 2
          line(kpt) = '.'
          kpt = 3
          kde = (ke-1) * npower + k1sav - 1
          if (jf1 == 0) kde = kde + 1
          j = 1
          do while (kpt <= nd+2)
             kd = npower
             if (j == 1) kd = k1
             kdig = mxy(2)%mp(j+2)
             if (lb < kpt+kd-1) then
                 call fmout_err(line, lb)
                 return
             endif
             do jd = 1, kd
                ndg = mod(kdig, 10)
                line(kpt+kd-jd) = numb(ndg+1)
                kdig = kdig / 10
             enddo
             j = j + 1
             kpt = kpt + kd
          enddo
          jd = jf2
          do while (kpt-1 > jd+2)
              kpt = kpt - 1
              line(kpt) = ' '
          enddo
          if (jd > kpt-3) then
              if (lb < jd+2) then
                  call fmout_err(line, lb)
                  return
              endif
              do j = kpt-2, jd
                 line(kpt) = '0'
                 kpt = kpt + 1
              enddo
          endif
          if (lb < kpt+1) then
              call fmout_err(line, lb)
              return
          endif
          line(kpt) = qx%cmchar
          kpt = kpt + 1
          if (kde < 0) then
              line(kpt) = '-'
          else
              line(kpt) = '+'
          endif
          kpt = kpt + 1
          kdig = abs(kde)
          kpt1 = kpt
          do while (kdig >= 0)
             ndg = mod(kdig, 10)
             if (lb < kpt) then
                 call fmout_err(line, lb)
                 return
             endif
             line(kpt) = numb(ndg+1)
             kdig = kdig / 10
             if (kdig == 0) exit
             kpt = kpt + 1
          enddo
          kmid = (kpt+kpt1)/2
          if (mod(kpt+kpt1, 2) == 0) kmid = kmid - 1
          do j = kpt1, kmid
             temp = line(j)
             line(j) = line(kpt+kpt1-j)
             line(kpt+kpt1-j) = temp
          enddo
      endif
      if (jf1 == 1) then
          line(2) = line(3)
          line(3) = '.'
      endif

      return
      end subroutine fmout_m1

      subroutine fmout_sc(ma, mxy, mresult, mbsave, ndsave, npower, line, lb, kresult, qx)

!  Check for special cases.

!  mresult is returned as ma with its precision adjusted to the current output format,
!          and converted to a power of ten base if the original base is not a power of ten.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(2), mresult
      integer :: ndsave, npower, lb, kresult
      real (kind(1.0d0)) :: mbsave
      character :: line(lb)
      intent (in) :: ma, mbsave, ndsave, lb
      intent (inout) :: mxy, mresult, npower, line, kresult
      type(fm_settings) :: qx

      integer :: j, k, kwrnsv, new_mbase, new_ndig
      character :: nunkno(12) = (/ ' ', ' ', ' ', 'U', 'N', 'K', 'N', 'O', 'W', 'N', ' ', ' ' /)
      character :: nexpov(12) = (/ ' ', ' ', ' ', 'O', 'V', 'E', 'R', 'F', 'L', 'O', 'W', ' ' /)
      character :: nexpun(12) = (/ ' ', ' ', ' ', 'U', 'N', 'D', 'E', 'R', 'F', 'L', 'O', 'W' /)

      qx%namest(qx%ncall) = 'FMOUT    '
      call fmcons(qx)
      kresult = 0

      qx%kflag = 0
      kwrnsv = qx%kwarn
      qx%kwarn = 0
      do j = 1, lb
         line(j) = ' '
      enddo

!             Check for special values overflow, underflow, unknown.

      if (ma%mp(2) == qx%munkno) then
          if (lb < 12) then
              call fmout_err(line, lb)
              qx%kwarn = kwrnsv
              kresult = 1
              return
          endif
          do j = 1, 12
             line(j) = nunkno(j)
          enddo
          qx%kwarn = kwrnsv
          kresult = 1
          return
      endif
      if (ma%mp(2) == qx%mexpov) then
          if (lb < 12) then
              call fmout_err(line, lb)
              qx%kwarn = kwrnsv
              kresult = 1
              return
          endif
          do j = 1, 12
             line(j) = nexpov(j)
          enddo
          line(2) = '+'
          if (ma%mp(1) < 0) line(2) = '-'
          qx%kwarn = kwrnsv
          kresult = 1
          return
      endif
      if (ma%mp(2) == qx%mexpun) then
          if (lb < 12) then
              call fmout_err(line, lb)
              qx%kwarn = kwrnsv
              kresult = 1
              return
          endif
          do j = 1, 12
             line(j) = nexpun(j)
          enddo
          line(2) = '+'
          if (ma%mp(1) < 0) line(2) = '-'
          qx%kwarn = kwrnsv
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0 .and. qx%jform1 == 2 .and. qx%jform2 == 0) then
          line(2) = '0'
          qx%kwarn = kwrnsv
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0) then
          if (qx%jform1 == 0) then
              if (lb < 5+qx%jform2) then
                  call fmout_err(line, lb)
                  qx%kwarn = kwrnsv
                  kresult = 1
                  return
              endif
              line(2) = '.'
              do j = 3, 2+qx%jform2
                 line(j) = '0'
              enddo
              line(3+qx%jform2) = qx%cmchar
              line(5+qx%jform2) = '0'
          else if (qx%jform1 == 1) then
              if (lb < 5+qx%jform2) then
                  call fmout_err(line, lb)
                  qx%kwarn = kwrnsv
                  kresult = 1
                  return
              endif
              line(2) = '0'
              line(3) = '.'
              do j = 4, 2+qx%jform2
                 line(j) = '0'
              enddo
              line(3+qx%jform2) = qx%cmchar
              line(5+qx%jform2) = '0'
          else if (qx%jform1 == 2) then
              if (qx%jform2 <= 0) then
                  line(2) = '0'
              else
                  if (lb < 2+qx%jform2) then
                      call fmout_err(line, lb)
                      qx%kwarn = kwrnsv
                      kresult = 1
                      return
                  endif
                  line(2) = '.'
                  do j = 3, 2+qx%jform2
                     line(j) = '0'
                  enddo
              endif
          endif
          qx%kwarn = kwrnsv
          kresult = 1
          return
      endif

!             Check to see if the current base is a power of ten.

      npower = 0
      k = int(log10(dble(mxbase)))
      do j = 1, k
         if (10.0d0**j == mbsave) then
             if (qx%mblogs /= qx%mbase) call fmcons(qx)
             npower = j
             exit
         endif
      enddo

!             If the current base is not a power of ten, convert ma to a power of ten base.

      if (npower == 0) then
          call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
          npower = int(log10(dble(mxbase/4)))
          new_mbase = 10**npower
          new_ndig = max(3, int(2 * ndsave * log(dble(mbsave)) / log(dble(new_mbase))) )
          call fmchangebase(mxy(1), mresult, new_mbase, new_ndig, qx)
          call fmndig(new_ndig, qx)
          qx%mbase = new_mbase
      else
          call fmequ(ma, mresult, ndsave, qx%ndig, qx)
      endif

      qx%kwarn = kwrnsv

      return
      end subroutine fmout_sc

      subroutine fmoverflow(k, ma, qx)

!  Set ma to fm's special value for overflowed results.

!  k = -1 returns ma = -overflow

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: k
      intent (in) :: k
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: j
      double precision :: d

      call fmalloc(ma, qx%ndig+2, qx)
      do j = 5, qx%ndig+2
         ma%mp(j) = 0
      enddo
      ma%mp(1) = k
      ma%mp(2) = qx%mexpov
      ma%mp(3) = 1
      if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
          d = 1.0d+10
      else
          d = 4
      endif
      ma%mp(4) = huge(qx%mbase)/d
      ma%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))

      end subroutine fmoverflow

      subroutine fmovun_add(ma, mb, mc, qx)

!  Internal addition routine.  mc = ma + mb

!  One or both arguments are overflow, underflow, or unknown, and this routine tries to track
!  exceptional operations for better error handling.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: j
      logical :: abs_ma_gt_abs_mb
      double precision :: xe, xf, ye, yf

      call fmalloc(mc, qx%ndig+2, qx)

      if ((ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == qx%munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc, qx)
          qx%kflag = -4
          return
      endif
      qx%kflag = 0
      if (ma%mp(3) == 0) then
          do j = 1, qx%ndig+2
             mc%mp(j) = mb%mp(j)
          enddo
          qx%kflag = 1
          return
      endif
      if (mb%mp(3) == 0) then
          do j = 1, qx%ndig+2
             mc%mp(j) = ma%mp(j)
          enddo
          qx%kflag = 1
          return
      endif
      if (qx%kround /= 1) then
          call fmovun_xexf(ma, xe, xf, qx)
          call fmovun_xexf(mb, ye, yf, qx)
          if (abs(ma%mp(2)) < qx%mexpov .and. mb%mp(5) < 0) then
              if (xe > ye + qx%ndig) then
                  do j = 1, qx%ndig+2
                     mc%mp(j) = ma%mp(j)
                  enddo
                  if (ma%mp(1) > 0 .and. mb%mp(1) > 0) then
                      if (qx%kround == 2) call fmovun_rnd(mc, 1, qx)
                  else if (ma%mp(1) < 0 .and. mb%mp(1) > 0) then
                      if (qx%kround == 0 .or. qx%kround == 2) call fmovun_rnd(mc, -1, qx)
                  else if (ma%mp(1) > 0 .and. mb%mp(1) < 0) then
                      if (qx%kround == -1 .or. qx%kround == 0) call fmovun_rnd(mc, -1, qx)
                  else if (ma%mp(1) < 0 .and. mb%mp(1) < 0) then
                      if (qx%kround == -1) call fmovun_rnd(mc, 1, qx)
                  endif
                  qx%kflag = 1
                  return
              endif
          endif

          if (abs(mb%mp(2)) < qx%mexpov .and. ma%mp(5) < 0) then
              if (ye > xe + qx%ndig) then
                  do j = 1, qx%ndig+2
                     mc%mp(j) = mb%mp(j)
                  enddo
                  if (mc%mp(1) > 0 .and. ma%mp(1) > 0) then
                      if (qx%kround == 2) call fmovun_rnd(mc, 1, qx)
                  else if (mc%mp(1) < 0 .and. ma%mp(1) > 0) then
                      if (qx%kround == 0 .or. qx%kround == 2) call fmovun_rnd(mc, -1, qx)
                  else if (mc%mp(1) > 0 .and. ma%mp(1) < 0) then
                      if (qx%kround == -1 .or. qx%kround == 0) call fmovun_rnd(mc, -1, qx)
                  else if (mc%mp(1) < 0 .and. ma%mp(1) < 0) then
                      if (qx%kround == -1) call fmovun_rnd(mc, 1, qx)
                  endif
                  qx%kflag = 1
                  return
              endif
          endif
      endif
      do j = 2, qx%ndig+2
         mc%mp(j) = 0
      enddo
      mc%mp(1) = 1

      abs_ma_gt_abs_mb = .true.
      call fmovun_xexf(ma, xe, xf, qx)
      call fmovun_xexf(mb, ye, yf, qx)
      if (ye > xe) then
          abs_ma_gt_abs_mb = .false.
      else if (ye == xe) then
          if (yf > xf) then
              abs_ma_gt_abs_mb = .false.
          endif
      endif

      if (abs_ma_gt_abs_mb) then
          if (ma%mp(1) > 0) then
              if (mb%mp(1) > 0) then
                  call fmovun_addp(ma, mb, mc, qx)
                  mc%mp(1) = 1
              else
                  call fmovun_subp(ma, mb, mc, qx)
                  mc%mp(1) = 1
              endif
          else
              if (mb%mp(1) > 0) then
                  call fmovun_subp(ma, mb, mc, qx)
                  mc%mp(1) = -1
              else
                  call fmovun_addp(ma, mb, mc, qx)
                  mc%mp(1) = -1
              endif
          endif
      else
          if (ma%mp(1) > 0) then
              if (mb%mp(1) > 0) then
                  call fmovun_addp(mb, ma, mc, qx)
                  mc%mp(1) = 1
              else
                  call fmovun_subp(mb, ma, mc, qx)
                  mc%mp(1) = -1
              endif
          else
              if (mb%mp(1) > 0) then
                  call fmovun_subp(mb, ma, mc, qx)
                  mc%mp(1) = 1
              else
                  call fmovun_addp(mb, ma, mc, qx)
                  mc%mp(1) = -1
              endif
          endif
      endif

      if (mc%mp(2) == qx%munkno .and. qx%kflag /= 1) qx%kflag = -4
      if (mc%mp(2) == qx%mexpov .and. qx%kflag /= 1) qx%kflag = -5
      if (mc%mp(2) == qx%mexpun .and. qx%kflag /= 1) qx%kflag = -6

      return
      end subroutine fmovun_add

      subroutine fmovun_addp(ma, mb, mc, qx)

!  Internal addition routine.  mc = ma + mb

!  The arguments are such that abs(ma) >= abs(mb) and both ma and mb are treated as positive,
!  meaning the sign bits are ignored.

!  One or both arguments are overflow, underflow, or unknown, and this routine tries to track
!  exceptional operations for better error handling.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: j
      double precision :: b, d, xe, xf, ye, yf, ze, zf

      call fmovun_xexf(ma, xe, xf, qx)
      call fmovun_xexf(mb, ye, yf, qx)


      if (xe-ye > qx%ndig) then
          do j = 1, qx%ndig+2
             mc%mp(j) = ma%mp(j)
          enddo
          qx%kflag = 1
          return
      endif
      b = qx%mbase
      if (ye-xe < log(epsilon(b)/b) / log(b)) then
          ze = xe
          zf = xf
      else
          ze = xe
          zf = xf + yf*b**(ye-xe)
      endif
      if (zf >= 1.0d0) then
          ze = ze + 1
          zf = zf / b
      endif
      if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
          d = 1.0d+10
      else
          d = 4
      endif
      if (ze > huge(qx%mbase)/d) then
          ze = huge(qx%mbase)/d
          zf = 1.0d0 - epsilon(1.0d0)
      else if (ze < -huge(qx%mbase)/d) then
          ze = -huge(qx%mbase)/d
          zf = 1.0d0 - epsilon(1.0d0)
      else if (ze == ze + 1.0d0) then
          zf = 1.0d0 - epsilon(1.0d0)
      endif
      mc%mp(4) = ze
      if (zf == 0) zf = 1.0d0 / b
      mc%mp(5) = -zf*maxint
      if (mc%mp(4) >= -qx%mxexp0 .and. mc%mp(4) <= qx%mxexp0+1) then
          mc%mp(1) = 1
          mc%mp(2) = qx%munkno
          mc%mp(3) = 1
          do j = 4, qx%ndig
             mc%mp(j+2) = 0
          enddo
          qx%kflag = -4
          return
      else if (mc%mp(4) < -qx%mxexp0) then
          mc%mp(2) = qx%mexpun
          qx%kflag = -6
      else if (mc%mp(4) > qx%mxexp0+1) then
          mc%mp(2) = qx%mexpov
          qx%kflag = -5
      endif
      mc%mp(3) = 1

      end subroutine fmovun_addp

      subroutine fmovun_div(ma, mb, mc, qx)

!  Internal division routine.  mc = ma / mb

!  One or both arguments are overflow, underflow, or unknown, and this routine tries to track
!  exceptional operations for better error handling.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: j
      double precision :: d, xe, xf, ye, yf, ze, zf

      call fmalloc(mc, qx%ndig+2, qx)

      if ((ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == qx%munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc, qx)
          qx%kflag = -4
          return
      endif
      if (ma%mp(3) == 0) then
          do j = 2, qx%ndig+2
             mc%mp(j) = 0
          enddo
          mc%mp(1) = 1
          qx%kflag = 0
          return
      endif
      if (mb%mp(3) == 0) then
          call fmunknown(mc, qx)
          qx%kflag = -4
          return
      endif
      do j = 2, qx%ndig+2
         mc%mp(j) = 0
      enddo
      mc%mp(1) = 1
      call fmovun_xexf(ma, xe, xf, qx)
      call fmovun_xexf(mb, ye, yf, qx)
      if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
          d = 1.0d+10
      else
          d = 4
      endif


      if ((xe ==  huge(qx%mbase)/d .and. ye ==  huge(qx%mbase)/d) .or.  &
          (xe == -huge(qx%mbase)/d .and. ye == -huge(qx%mbase)/d) ) then
          call fmunknown(mc, qx)
          qx%kflag = -4
          return
      endif
      mc%mp(1) = ma%mp(1) * mb%mp(1)
      ze = xe - ye
      zf = xf / yf
      if (xf/yf >= 1) then
          ze = xe - ye + 1
          zf = (xf / yf) / qx%mbase
      endif
      if (ze > huge(qx%mbase)/d) then
          ze = huge(qx%mbase)/d
          zf = 1.0d0 - epsilon(1.0d0)
      else if (ze < -huge(qx%mbase)/d) then
          ze = -huge(qx%mbase)/d
          zf = 1.0d0 - epsilon(1.0d0)
      else if (ze == ze + 1.0d0) then
          zf = 1.0d0 - epsilon(1.0d0)
      endif
      if (zf == 0) zf = -epsilon(1.0d0)
      if (zf >= 1) then
          zf = zf / qx%mbase
          ze = ze + 1
      else if (zf < 1.0d0/qx%mbase) then
          zf = zf * qx%mbase
          ze = ze - 1
      endif
      mc%mp(4) = ze
      mc%mp(5) = -zf*maxint
      if (mc%mp(4) >= -qx%mxexp0 .and. mc%mp(4) <= qx%mxexp0+1) then
          mc%mp(1) = ma%mp(1) * mb%mp(1)
          mc%mp(2) = qx%munkno
          mc%mp(3) = 1
          do j = 4, qx%ndig
             mc%mp(j+2) = 0
          enddo
          qx%kflag = -4
          return
      else if (mc%mp(4) < -qx%mxexp0) then
          mc%mp(2) = qx%mexpun
          qx%kflag = -6
      else if (mc%mp(4) > qx%mxexp0+1) then
          mc%mp(2) = qx%mexpov
          qx%kflag = -5
      endif
      mc%mp(3) = 1

      return
      end subroutine fmovun_div

      subroutine fmovun_frac(ma, xf, qx)

!  xf is a double precision approximation to the fractional part of fm number ma.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      double precision :: xf
      intent (in) :: ma
      intent (inout) :: xf
      type(fm_settings) :: qx

      double precision :: eps, t
      integer :: j, nd1

      xf = 0
      eps = epsilon(xf) / qx%mbase
      t = 1.0d0 / qx%mbase
      nd1 = size(ma%mp)-2
      do j = 1, min(qx%ndig, nd1)
         xf = xf + ma%mp(2+j)*t
         t = t / qx%mbase
         if (t < eps) exit
      enddo

      end subroutine fmovun_frac

      subroutine fmovun_mpy(ma, mb, mc, qx)

!  Internal multiplication routine.  mc = ma * mb

!  One or both arguments are overflow, underflow, or unknown, and this routine tries to track
!  exceptional operations for better error handling.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: j
      double precision :: d, xe, xf, ye, yf, ze, zf

      call fmalloc(mc, qx%ndig+2, qx)

      if ((ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == qx%munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc, qx)
          qx%kflag = -4
          return
      endif
      if (ma%mp(3) == 0 .or. mb%mp(3) == 0) then
          do j = 2, qx%ndig+2
             mc%mp(j) = 0
          enddo
          mc%mp(1) = 1
          qx%kflag = 0
          return
      endif
      do j = 2, qx%ndig+2
         mc%mp(j) = 0
      enddo
      mc%mp(1) = 1
      call fmovun_xexf(ma, xe, xf, qx)
      call fmovun_xexf(mb, ye, yf, qx)
      if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
          d = 1.0d+10
      else
          d = 4
      endif

      if ((xe == huge(qx%mbase)/d .and. ye == -huge(qx%mbase)/d) .or.  &
          (xe == -huge(qx%mbase)/d .and. ye == huge(qx%mbase)/d) ) then
          call fmunknown(mc, qx)
          qx%kflag = -4
          return
      endif

      mc%mp(1) = ma%mp(1) * mb%mp(1)
      ze = xe + ye
      zf = xf * yf
      if (zf < 1.0d0/qx%mbase) then
          ze = ze - 1
          zf = zf * qx%mbase
      endif
      if (ze > huge(qx%mbase)/d) then
          ze = huge(qx%mbase)/d
          zf = 1.0d0 - epsilon(1.0d0)
      else if (ze < -huge(qx%mbase)/d) then
          ze = -huge(qx%mbase)/d
          zf = 1.0d0 - epsilon(1.0d0)
      else if (ze == ze + 1.0d0) then
          zf = 1.0d0 - epsilon(1.0d0)
      endif
      if (zf == 0) zf = -epsilon(1.0d0)
      mc%mp(4) = ze
      mc%mp(5) = -zf*maxint
      if (mc%mp(4) >= -qx%mxexp0 .and. mc%mp(4) <= qx%mxexp0+1) then
          mc%mp(1) = ma%mp(1) * mb%mp(1)
          mc%mp(2) = qx%munkno
          mc%mp(3) = 1
          do j = 4, qx%ndig
             mc%mp(j+2) = 0
          enddo
          qx%kflag = -4
          return
      else if (mc%mp(4) < -qx%mxexp0) then
          mc%mp(2) = qx%mexpun
          qx%kflag = -6
      else if (mc%mp(4) > qx%mxexp0+1) then
          mc%mp(2) = qx%mexpov
          qx%kflag = -5
      endif
      mc%mp(3) = 1

      end subroutine fmovun_mpy

      subroutine fmovun_pwr(ma, mb, mc, qx)

!  Internal power routine.  mc = ma**mb

!  One or both arguments are overflow, underflow, or unknown, or both are representable numbers
!  but mc is overflow or underflow.  This routine tries to track exceptional operations for better
!  error handling.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: i, j, k, kl
      double precision :: xe, xf, ye, yf
      real (kind(1.0d0)) :: m2
      type(multi) :: mxy(3)
      logical, external :: fmcomp

      call fmalloc(mc, qx%ndig+2, qx)

      kl = 0
      if (( ma%mp(3) == 0 .and. mb%mp(3) == 0 ) .or.  &
          ( ma%mp(3) == 0 .and. mb%mp(1) < 0 )) then
          call fmunknown(mc, qx)
          qx%kflag = -4
          return
      endif
      if ((ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == qx%munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc, qx)
          qx%kflag = -4
          return
      endif
      if (ma%mp(3) == 0) then
          call fmi2m(0, mc, qx)
          return
      endif
      if (mb%mp(3) == 0) then
          call fmi2m(1, mc, qx)
          return
      endif
      call fmovun_xexf(ma, xe, xf, qx)
      call fmovun_xexf(mb, ye, yf, qx)
      if (ma%mp(1) < 0 .and. mb%mp(2) == qx%munkno) then
          m2 = 2
          if (ye <= qx%ndig .or. mod(qx%mbase, m2) /= 0) then
              call fmunknown(mc, qx)
              return
          endif
      endif
      do j = 2, qx%ndig+2
         mc%mp(j) = 0
      enddo
      mc%mp(1) = 1

      call fmovun_pwr2(ma, mb, mc, mxy, kl, qx)
      if (ma%mp(1) < 0) then
          call fmovun_pwr3(mb, k, qx)
          if (k == 0) then
              do i = 2, qx%ndig
                 mc%mp(i+2) = 0
              enddo
              mc%mp(1) = 1
              mc%mp(2) = qx%munkno
              mc%mp(3) = 1
              qx%kflag = -4
          else if (k == 1) then
              mc%mp(1) = -1
          endif
      endif

      if (mb%mp(1) < 0) then
          call fmi2m(1, mxy(1), qx)
          call fmdiv_r2(mxy(1), mc, qx)
      endif

      if (kl /= 1 .and. qx%kround /= 1) then
          call fmi2m(1, mxy(1), qx)
          call fmabs(mc, mxy(2), qx)
          if (fmcomp(mxy(1), '==', mxy(2), qx)) then
              call fmtiny(mxy(2), qx)
              call fmovun_xexf(ma, xe, xf, qx)
              if (xe >= 1 .and. mb%mp(1) > 0) then
                  call fmadd(mxy(1), mxy(2), mc, qx)
              else if (xe >= 1 .and. mb%mp(1) < 0) then
                  call fmsub(mxy(1), mxy(2), mc, qx)
              else if (ma%mp(1) > 0 .and. mb%mp(1) > 0) then
                  call fmsub(mxy(1), mxy(2), mc, qx)
              else if (ma%mp(1) > 0 .and. mb%mp(1) < 0) then
                  call fmadd(mxy(1), mxy(2), mc, qx)
              else
                  call fmunknown(mc, qx)
                  qx%kflag = -4
              endif
          endif
      endif
      end subroutine fmovun_pwr

      subroutine fmovun_pwr2(ma, mb, mc, mxy, kl, qx)

!  Return  mc = abs(ma) ** abs(mb)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      type(multi) :: mxy(3)
      integer :: kl
      intent (in) :: ma, mb
      intent (inout) :: mc, mxy, kl
      type(fm_settings) :: qx

      integer :: k
      double precision :: alg, b, d, t, ue, uf, xe, xf, ye, yf, z1, z2
      logical, external :: fmcomp

      b = qx%mbase
      if (ma%mp(2) == 1 .and. ma%mp(3) == 1) then
          call fmi2m(1, mxy(1), qx)
          call fmabs(ma, mxy(2), qx)
          if (fmcomp(mxy(1), '==', mxy(2), qx)) then
              call fmi2m(1, mc, qx)
              kl = 1
              return
          endif
      endif
      if (mb%mp(2) == 1 .and. mb%mp(3) == 1) then
          call fmi2m(1, mxy(1), qx)
          call fmabs(mb, mxy(2), qx)
          if (fmcomp(mxy(1), '==', mxy(2), qx)) then
              call fmeq(ma, mc, qx)
              return
          endif
      endif
      call fmovun_xe(ma, xe, qx)
      if (xe > 0) then
          call fmabs(ma, mxy(1), qx)
      else
          call fmi2m(1, mxy(1), qx)
          call fmdiv(mxy(1), ma, mxy(2), qx)
          call fmabs(mxy(2), mxy(1), qx)
      endif
      call fmi2m(1, mxy(2), qx)
      call fmsub_r2(mxy(1), mxy(2), qx)
      call fmm2dp(mxy(2), t, qx)
      if (qx%kflag == -10) then
          alg = tiny(t) * 10.0d8
      else if (abs(t) < 1.0e-3) then
          alg = t
          do k = 1, 20
             if (k > log(epsilon(t)*(k+1)) / log(t)) exit
             alg = alg + (-1)**k * t**(k+1)/(k+1)
          enddo
      else
          call fmovun_xexf(mxy(1), xe, xf, qx)
          alg = xe + log(xf) / log(b)
      endif
      call fmovun_xexf(mb, ye, yf, qx)
      z1 = ye + log(yf)/log(b) + log(alg)/log(b)
      if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
          d = 1.0d+10
      else
          d = 4
      endif
      z2 = log(huge(qx%mbase)/d)/log(b)
      if (abs(z1) >= z2) then
          if (z1 > 0) then
              call fmovun_xe(ma, xe, qx)
              if (xe > 0) then
                  call fmoverflow(1, mc, qx)
                  mc%mp(4) = huge(qx%mbase)/d
                  qx%kflag = -5
              else
                  call fmunderflow(1, mc, qx)
                  mc%mp(4) = -huge(qx%mbase)/d
                  qx%kflag = -6
              endif
              mc%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
          else
              call fmi2m(1, mc, qx)
          endif
          return
      endif
      if (z1 < -qx%ndig) then
          call fmi2m(1, mc, qx)
          return
      endif
      ue = b**ye * yf * alg
      if (ue == ue + 1) then
          uf = 1.0d0 - epsilon(1.0d0)
      else
          z1 = aint(ue)
          if (ue - z1 == 0) then
              ue = z1 + 1
              uf = 1/b
          else
              z1 = z1 + 1
              uf = b**( ue - z1 )
              ue = z1
          endif
      endif
      if (uf == 0) then
          ue = ue + 1
          uf = 1/b
      endif
      call fmovun_xe(ma, xe, qx)
      if (xe <= 0) then
          ue = -ue + 1
          uf = (1.0d0/uf)/b
      endif
      if (ue > qx%mxexp0+1) then
          call fmoverflow(1, mc, qx)
          qx%kflag = -5
      else if (ue < -qx%mxexp0) then
          call fmunderflow(1, mc, qx)
          qx%kflag = -6
      else
          call fmunknown(mc, qx)
          qx%kflag = -4
      endif
      mc%mp(4) = ue
      mc%mp(5) = -maxint * uf

      return
      end subroutine fmovun_pwr2

      subroutine fmovun_pwr3(mb, k, qx)

!  Return  k  as a code for determining the sign of ma**mb.

      use fmvals_parallel
      implicit none

      type(multi) :: mb
      integer :: k
      intent (in) :: mb
      intent (inout) :: k
      type(fm_settings) :: qx

      integer :: i, km, l, lb, lmb
      double precision :: ye

      k = 0
      call fmovun_xe(mb, ye, qx)
      if (ye <= 0) then
          return
      else if (ye <= qx%ndig) then
          l = ye + 2
          do i = l+1, qx%ndig+2
             if (mb%mp(i) /= 0) then
                 k = 0
                 return
             endif
          enddo
          lb = qx%mbase
          lmb = mb%mp(l)
          if (mod(lb, 2) == 0) then
              if (mod(lmb, 2) == 0) then
                  k = 2
                  return
              else
                  k = 1
                  return
              endif
          else
              km = 0
              do i = 3, l
                 lmb = mb%mp(i)
                 km = km + mod(lmb, 2)
              enddo
              k = 2 - mod(km, 2)
              return
          endif
      else if (ye > qx%ndig) then
          l = qx%ndig + 2
          lb = qx%mbase
          lmb = mb%mp(l)
          if (mod(lb, 2) == 0) then
              k = 2
              return
          else
              km = 0
              do i = 3, l
                 lmb = mb%mp(i)
                 km = km + mod(lmb, 2)
              enddo
              k = 2 - mod(km, 2)
              return
          endif
      endif

      end subroutine fmovun_pwr3

      subroutine fmovun_rnd(ma, nd, qx)

!  Internal routine for directed rounding of ma.

!  add nd to the last digit of ma and re-normalize. nd is plus or minus 1.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: nd
      intent (in) :: nd
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: j

      ma%mp(qx%ndig+2) = ma%mp(qx%ndig+2) + nd

      if (ma%mp(qx%ndig+2) >= qx%mbase) then
          do j = qx%ndig+1, 3, -1
             ma%mp(j+1) = ma%mp(j+1) - qx%mbase
             ma%mp(j) = ma%mp(j) + 1
             if (ma%mp(j) < qx%mbase) exit
          enddo
          if (ma%mp(3) >= qx%mbase) then
              ma%mp(2) = ma%mp(2) + 1
              ma%mp(3) = 1
              do j = 4, qx%ndig+2
                 ma%mp(j) = 0
              enddo
          endif
      else if (ma%mp(qx%ndig+2) < 0) then
          do j = qx%ndig+1, 3, -1
             ma%mp(j+1) = ma%mp(j+1) + qx%mbase
             ma%mp(j) = ma%mp(j) - 1
             if (ma%mp(j) >= 0) exit
          enddo
          if (ma%mp(3) <= 0) then
              ma%mp(2) = ma%mp(2) - 1
              ma%mp(3) = 1
              do j = 3, qx%ndig+2
                 ma%mp(j) = qx%mbase - 1
              enddo
          endif
      endif
      if (ma%mp(2) < -qx%mxexp) then
          ma%mp(4) = ma%mp(2)
          ma%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
          ma%mp(2) = qx%mexpun
          ma%mp(3) = 1
      else if (ma%mp(2) > qx%mxexp+1 .and. ma%mp(2) /= qx%munkno) then
          ma%mp(4) = ma%mp(2)
          ma%mp(5) = -maxint * (1.0d0/qx%mbase)
          ma%mp(2) = qx%mexpov
          ma%mp(3) = 1
      endif

      end subroutine fmovun_rnd

      subroutine fmovun_sub(ma, mb, mc, qx)

!  Internal subtraction routine.  mc = ma - mb

!  One or both arguments are overflow, underflow, or unknown, and this routine tries to track
!  exceptional operations for better error handling.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: j
      logical :: abs_ma_gt_abs_mb
      double precision :: xe, xf, ye, yf

      call fmalloc(mc, qx%ndig+2, qx)

      if ((ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == qx%munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc, qx)
          qx%kflag = -4
          return
      endif
      qx%kflag = 0
      if (ma%mp(3) == 0) then
          do j = 2, qx%ndig+2
             mc%mp(j) = mb%mp(j)
          enddo
          mc%mp(1) = -mb%mp(1)
          if (mc%mp(2) == qx%munkno .and. qx%kflag /= 1) qx%kflag = -4
          if (mc%mp(2) == qx%mexpov .and. qx%kflag /= 1) qx%kflag = -5
          if (mc%mp(2) == qx%mexpun .and. qx%kflag /= 1) qx%kflag = -6
          return
      endif
      if (mb%mp(3) == 0) then
          do j = 1, qx%ndig+2
             mc%mp(j) = ma%mp(j)
          enddo
          qx%kflag = 1
          return
      endif
      if (qx%kround /= 1) then
          call fmovun_xexf(ma, xe, xf, qx)
          call fmovun_xexf(mb, ye, yf, qx)
          if (abs(ma%mp(2)) < qx%mexpov .and. mb%mp(5) < 0) then
              if (xe > ye + qx%ndig) then
                  do j = 1, qx%ndig+2
                     mc%mp(j) = ma%mp(j)
                  enddo
                  if (ma%mp(1) > 0 .and. mb%mp(1) > 0) then
                      if (qx%kround == 0 .or. qx%kround == -1) call fmovun_rnd(mc, -1, qx)
                  else if (ma%mp(1) < 0 .and. mb%mp(1) > 0) then
                      if (qx%kround == -1) call fmovun_rnd(mc, 1, qx)
                  else if (ma%mp(1) > 0 .and. mb%mp(1) < 0) then
                      if (qx%kround == 2) call fmovun_rnd(mc, 1, qx)
                  else if (ma%mp(1) < 0 .and. mb%mp(1) < 0) then
                      if (qx%kround == 0 .or. qx%kround == 2) call fmovun_rnd(mc, -1, qx)
                  endif
                  qx%kflag = 1
                  return
              endif
          endif

          if (abs(mb%mp(2)) < qx%mexpov .and. ma%mp(5) < 0) then
              if (ye > xe + qx%ndig) then
                  do j = 1, qx%ndig+2
                     mc%mp(j) = mb%mp(j)
                  enddo
                  mc%mp(1) = -mb%mp(1)
                  if (mc%mp(1) > 0 .and. ma%mp(1) > 0) then
                      if (qx%kround == 2) call fmovun_rnd(mc, 1, qx)
                  else if (mc%mp(1) < 0 .and. ma%mp(1) > 0) then
                      if (qx%kround == 0 .or. qx%kround == 2) call fmovun_rnd(mc, -1, qx)
                  else if (mc%mp(1) > 0 .and. ma%mp(1) < 0) then
                      if (qx%kround == -1 .or. qx%kround == 0) call fmovun_rnd(mc, -1, qx)
                  else if (mc%mp(1) < 0 .and. ma%mp(1) < 0) then
                      if (qx%kround == -1) call fmovun_rnd(mc, 1, qx)
                  endif
                  if (mc%mp(2) == qx%munkno .and. qx%kflag /= 1) qx%kflag = -4
                  if (mc%mp(2) == qx%mexpov .and. qx%kflag /= 1) qx%kflag = -5
                  if (mc%mp(2) == qx%mexpun .and. qx%kflag /= 1) qx%kflag = -6
                  return
              endif
          endif
      endif
      do j = 2, qx%ndig+2
         mc%mp(j) = 0
      enddo
      mc%mp(1) = 1

      abs_ma_gt_abs_mb = .true.
      call fmovun_xexf(ma, xe, xf, qx)
      call fmovun_xexf(mb, ye, yf, qx)
      if (ye > xe) then
          abs_ma_gt_abs_mb = .false.
      else if (ye == xe) then
          if (yf > xf) then
              abs_ma_gt_abs_mb = .false.
          endif
      endif

      if (abs_ma_gt_abs_mb) then
          if (ma%mp(1) > 0) then
              if (mb%mp(1) > 0) then
                  call fmovun_subp(ma, mb, mc, qx)
                  mc%mp(1) = 1
              else
                  call fmovun_addp(ma, mb, mc, qx)
                  mc%mp(1) = 1
              endif
          else
              if (mb%mp(1) > 0) then
                  call fmovun_addp(ma, mb, mc, qx)
                  mc%mp(1) = -1
              else
                  call fmovun_subp(ma, mb, mc, qx)
                  mc%mp(1) = -1
              endif
          endif
      else
          if (ma%mp(1) > 0) then
              if (mb%mp(1) > 0) then
                  call fmovun_subp(mb, ma, mc, qx)
                  mc%mp(1) = -1
                  if (qx%kflag == 1) qx%kflag = 0
              else
                  call fmovun_addp(mb, ma, mc, qx)
                  mc%mp(1) = 1
                  if (qx%kflag == 1) qx%kflag = 0
              endif
          else
              if (mb%mp(1) > 0) then
                  call fmovun_addp(mb, ma, mc, qx)
                  mc%mp(1) = -1
                  if (qx%kflag == 1) qx%kflag = 0
              else
                  call fmovun_subp(mb, ma, mc, qx)
                  mc%mp(1) = 1
                  if (qx%kflag == 1) qx%kflag = 0
              endif
          endif
      endif

      if (mc%mp(2) == qx%munkno .and. qx%kflag /= 1) qx%kflag = -4
      if (mc%mp(2) == qx%mexpov .and. qx%kflag /= 1) qx%kflag = -5
      if (mc%mp(2) == qx%mexpun .and. qx%kflag /= 1) qx%kflag = -6

      return
      end subroutine fmovun_sub

      subroutine fmovun_subp(ma, mb, mc, qx)

!  Internal subtraction routine.  mc = ma - mb

!  The arguments are such that abs(ma) >= abs(mb) and both ma and mb are treated as positive,
!  meaning the sign bits are ignored.

!  One or both arguments are overflow, underflow, or unknown, and this routine tries to track
!  exceptional operations for better error handling.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: j, k
      double precision :: b, d, xe, xf, ye, yf, ze, zf

      call fmovun_xexf(ma, xe, xf, qx)
      call fmovun_xexf(mb, ye, yf, qx)


      if (xe-ye > qx%ndig) then
          do j = 1, qx%ndig+2
             mc%mp(j) = ma%mp(j)
          enddo
          qx%kflag = 1
          return
      endif
      b = qx%mbase
      if (xe == ye .and. xf == yf .and.  &
          (abs(ma%mp(2)) >= qx%mexpov .or. abs(mb%mp(2)) >= qx%mexpov)) then
          ze = 0
          zf = 0
          call fmunknown(mc, qx)
          qx%kflag = -4
          return
      else if (ye-xe < log(epsilon(b)/b) / log(b)) then
          ze = xe
          zf = xf
      else
          ze = xe
          zf = xf - yf*b**(ye-xe)
      endif
      if (zf > 0 .and. zf < 1.0d0/b) then
          k = -log(epsilon(b)/b)/log(b) + 1
          do j = 1, k
             ze = ze - 1
             zf = zf * b
             if (zf >= 1.0d0/b) exit
          enddo
      endif
      if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
          d = 1.0d+10
      else
          d = 4
      endif
      if (ze > huge(qx%mbase)/d) then
          ze = huge(qx%mbase)/d
          zf = 1.0d0 - epsilon(1.0d0)
      else if (ze < -huge(qx%mbase)/d) then
          ze = -huge(qx%mbase)/d
          zf = 1.0d0 - epsilon(1.0d0)
      else if (ze == ze + 1.0d0) then
          zf = 1.0d0 - epsilon(1.0d0)
      endif
      mc%mp(4) = ze
      if (zf == 0) zf = 1.0d0 / b
      mc%mp(5) = -zf*maxint
      if (mc%mp(4) >= -qx%mxexp0 .and. mc%mp(4) <= qx%mxexp0+1) then
          mc%mp(1) = 1
          mc%mp(2) = qx%munkno
          mc%mp(3) = 1
          do j = 4, qx%ndig
             mc%mp(j+2) = 0
          enddo
          qx%kflag = -4
          return
      else if (mc%mp(4) < -qx%mxexp0) then
          mc%mp(2) = qx%mexpun
          qx%kflag = -6
      else if (mc%mp(4) > qx%mxexp0+1) then
          mc%mp(2) = qx%mexpov
          qx%kflag = -5
      endif
      mc%mp(3) = 1

      return
      end subroutine fmovun_subp

      subroutine fmovun_xe(ma, xe, qx)

!  Return the over/underflow/unknown tracking exponent of ma in xe.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      double precision :: xe
      intent (in) :: ma
      intent (inout) :: xe
      type(fm_settings) :: qx

      if (abs(ma%mp(2)) >= qx%mexpov) then
          xe = ma%mp(4)
      else
          xe = ma%mp(2)
      endif

      end subroutine fmovun_xe

      subroutine fmovun_xexf(ma, xe, xf, qx)

!  Return the over/underflow/unknown tracking information of ma in xe, xf.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      double precision :: xe, xf
      intent (in) :: ma
      intent (inout) :: xe, xf
      type(fm_settings) :: qx

      double precision :: d

      if (ma%mp(3) == 0) then
          if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          xe = -huge(qx%mbase)/d
          xf = 1.0d0 - epsilon(1.0d0)
      else if (abs(ma%mp(2)) >= qx%mexpov) then
          xe = ma%mp(4)
          xf = ma%mp(5)
          if (xf >= 0) xf = 1.0d0 / qx%mbase
          xf = -xf/maxint
      else
          xe = ma%mp(2)
          call fmovun_frac(ma, xf, qx)
      endif

      end subroutine fmovun_xexf

      subroutine fmpgam(n, ma, mb, qx)

!  mb = polygamma(n,ma)      (nth derivative of psi)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: n
      intent (in) :: n, ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, numtry, n_acc
      logical :: retry
      type(multi) :: mxy(13), mresult, mretry

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmpgam_sc(n, ma, mxy, ndsave, mresult, kresult, qx)
      qx%numbrn = 0
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fmpgam_m1(n, ma, mxy, mresult, ndsave, retry, n_acc, qx)
         qx%numbrn = 0
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry, qx)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmpgam

      subroutine fmpgam_m1(n, ma, mxy, mresult, ndsave, retry, n_acc, qx)

!  Method 1 for computing polygamma(n,ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mbern(lmbern)
      integer :: ndbern(lmbern)
      type(multi) :: ma, mxy(13), mresult
      integer :: n, ndsave, n_acc
      logical :: retry
      intent (in) :: n, ma, ndsave
      intent (inout) :: mxy, mresult, retry, n_acc
      type(fm_settings) :: qx

      double precision :: xe
      integer :: iextra, inta, j, j2, jn, jnc, jstart, k, kfl, kl, krflct, krsave,  &
                 kwrnsv, lshift, n1, nbot, nc, ndig2, ndsav1, ndsv2, nmxdif, nterm, ntop

!             Set the coefficients used in computing various derivatives of cot(pi*x)
!             for the reflection formula.

      integer :: kgcd(14) = (/ 1, 2, 2, 8, 8, 16, 16, 128, 128, 256, 256, 1024, 1024, 2048 /)
      integer :: kcoeff(56) = (/                                                            &
                           1,        1,                     3, 1,               3, 2,       &
                          15,  15,   2,                    45,  60, 17,                     &
                         315, 525, 231, 17,               315, 630, 378, 62,                &
                        2835,      6615,      5040,      1320,       62,                    &
                       14175,     37800,     34965,     12720,     1382,                    &
                      155925,    467775,    509355,    238425,    42306,     1382,          &
                      467775,   1559250,   1954260,   1121670,   280731,    21844,          &
                     6081075,  22297275,  31621590,  21531510,  7012005,   907725,  21844,  &
                    42567525, 170270100, 269594325, 212612400, 85630545, 15839460, 929569 /)
      type(multi) :: mjsums(ljsums)
      logical, external :: fmcomp

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      call fmeq(mxy(1), mxy(13), qx)
      n_acc = nint(qx%ndig*qx%alogm2)
      retry = .true.

      if (n == 0) then
          call fmpsi(mxy(1), mresult, qx)
          return
      endif
      if (n < 0 .or. ma%mp(3) == 0) then
          call fmunknown(mresult, qx)
          qx%kflag = -4
          retry = .false.
          return
      endif

!             Near zero pgam(x) is about n!/(-x)**(n+1).

      call fmovun_xe(mxy(13), xe, qx)
      if (xe < (-qx%ndig-1)) then
          call fmfcti(n, mxy(12), qx)
          call fmnegate(mxy(13), qx)
          call fmipwr(mxy(13), n+1, mxy(11), qx)
          call fmdiv(mxy(12), mxy(11), mresult, qx)
          return
      endif

!             Check for special cases.

      krflct = 0
      call fmdp2m(-0.5d0, mxy(5), qx)
      if (fmcomp(mxy(13), '<=', mxy(5), qx)) then
          krflct = 1
          kfl = 0
          call fmovun_xe(ma, xe, qx)
          if (xe <= ndsave) then
              call fmint(mxy(13), mxy(9), qx)
              if (fmcomp(mxy(13), '==', mxy(9), qx)) kfl = -4
          else
              kfl = -4
          endif
          if (kfl /= 0) then
              call fmunknown(mresult, qx)
              qx%kflag = -4
              retry = .false.
              return
          else
              call fmi2m(1, mxy(4), qx)
              call fmsub_r2(mxy(4), mxy(13), qx)
          endif
      endif
      call fmovun_xe(ma, xe, qx)
      if (xe > qx%ndig+3) then
          call fmipwr(mxy(13), -n, mxy(10), qx)
          call fmfcti(n-1, mxy(9), qx)
          call fmmpy_r1(mxy(10), mxy(9), qx)
          if (mod(n-1, 2) == 1) call fmnegate(mxy(10), qx)
          if (qx%kround /= 1) then
              if (mxy(10)%mp(2) /= qx%mexpun) then
                  call fmmpyi(mxy(10), n, mxy(4), qx)
                  call fmdivi_r1(mxy(4), 2, qx)
                  call fmdiv_r1(mxy(4), mxy(13), qx)
                  call fmadd_r1(mxy(10), mxy(4), qx)
              endif
          endif
          call fmeq(mxy(10), mresult, qx)
          return
      endif

!             To speed the asymptotic series calculation, increase the argument by lshift.

      iextra = 0
      kwrnsv = qx%kwarn
      qx%kwarn = 0
      call fmm2i(mxy(13), inta, qx)
      qx%kwarn = kwrnsv

      if (qx%kflag == -4) then
          lshift = 0
      else
          lshift = max(0, int(real(qx%ndig)*qx%alogmb/4.46-real(inta)))
          lshift = lshift + (7*n)/20
      endif
      if (lshift > 0) lshift = 4*(lshift/4 + 1)

      if (lshift /= 0) then
          call fmi2m(lshift, mxy(4), qx)
          call fmadd(mxy(13), mxy(4), mxy(12), qx)
      else
          call fmeq(mxy(13), mxy(12), qx)
      endif

!             Sum the asymptotic series.

      j2 = int(0.3*qx%alogmb + 0.2*sqrt(real(qx%ndig)))
      j2 = max(1, min(ljsums, j2))

!             mxy(13) is z
!             mxy(12) is z + lshift
!             mxy(9) is x**j2 = (1/(z+lshift)**2)**j2
!             mxy(10) is the current power of x times the quotient of factorials in each term
!             mxy(11) is the current term in the sum
!             mxy(8) is (n+1)!
!             mjsums holds the partial sums

      ndsav1 = qx%ndig
      call fmfcti(n+1, mxy(8), qx)
      call fmdivi(mxy(8), 2, mxy(10), qx)
      j = -2*j2
      call fmipwr(mxy(12), j, mxy(9), qx)
      call fmovun_xe(mxy(9), xe, qx)
      if (abs(xe) >= qx%mexpab) then
          j2 = 1
          call fmipwr(mxy(12), -2, mxy(9), qx)
      endif

      nterm = 2
      do j = 1, j2
         nterm = 2*j
         call fmbern(nterm, mxy(10), mjsums(j), mbern, ndbern, qx)
         if (qx%kflag == -11) then
             call fmunknown(mresult, qx)
             qx%kflag = -4
             retry = .false.
             return
         endif
         ntop = (n+nterm)*(n+nterm+1)
         call fmcsmpyi_r1(mxy(10), ntop, qx)
         nbot = (nterm+1)*(nterm+2)
         call fmcsdivi_r1(mxy(10), nbot, qx)
      enddo

      ndig2 = qx%ndig
      kl = 1
      do while (kl == 1)
         call fmcsmpy_r1(mxy(10), mxy(9), qx)
         nmxdif = min(ndsav1, qx%ngrd22)
         do j = 1, j2
            nterm = nterm + 2
            call fmbern(nterm, mxy(10), mxy(11), mbern, ndbern, qx)
            if (qx%kflag == -11) then
                call fmunknown(mresult, qx)
                qx%kflag = -4
                retry = .false.
                return
            endif
            call fmndig(ndsav1, qx)
            call fmcsadd_r1(mjsums(j), mxy(11), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            else
                nmxdif = max(nmxdif, ndsav1-int(mjsums(j)%mp(2)-mxy(11)%mp(2)))
                call fmndig(ndig2, qx)
                if (n+nterm > intmax/(n+nterm+1) .or. n+nterm > mxbase/(n+nterm+1)) then
                    call fmcsmpyi_r1(mxy(10), n+nterm, qx)
                    call fmcsmpyi_r1(mxy(10), n+nterm+1, qx)
                    call fmcsdivi_r1(mxy(10), nterm+1, qx)
                    call fmcsdivi_r1(mxy(10), nterm+2, qx)
                else
                    ntop = (n+nterm)*(n+nterm+1)
                    call fmcsmpyi_r1(mxy(10), ntop, qx)
                    nbot = (nterm+1)*(nterm+2)
                    call fmcsdivi_r1(mxy(10), nbot, qx)
                endif
            endif
         enddo
         if (kl == 0) exit
         ndig2 = nmxdif
         call fmndig(ndig2, qx)
      enddo

!             Put the j2 concurrent sums back together.

      call fmndig(ndsav1, qx)
      if (j2 > 1) then
          call fmi2m(1, mxy(9), qx)
          call fmsqr(mxy(12), mxy(11), qx)
          call fmdiv_r2(mxy(9), mxy(11), qx)
          call fmeq(mjsums(j2), mxy(9), qx)
          do j = j2-1, 1, -1
             call fmmpy_r1(mxy(9), mxy(11), qx)
             call fmadd_r1(mxy(9), mjsums(j), qx)
          enddo
          call fmeq(mxy(9), mjsums(1), qx)
      endif
      call fmipwr(mxy(12), n+2, mxy(6), qx)
      call fmdiv_r1(mjsums(1), mxy(6), qx)

!             Add the initial terms to the asymptotic series.

      call fmdivi(mxy(8), n+1, mxy(9), qx)
      call fmdivi(mxy(9), n, mxy(8), qx)
      call fmmpyi(mxy(12), 2, mxy(7), qx)
      call fmi2m(n, mxy(10), qx)
      call fmadd(mxy(7), mxy(10), mxy(3), qx)
      call fmcancel(mxy(7), mxy(10), mxy(3), k, qx)
      n_acc = n_acc - k
      call fmeq(mxy(3), mxy(7), qx)
      call fmmpy_r1(mxy(7), mxy(8), qx)
      call fmmpyi_r1(mxy(6), 2, qx)
      call fmdiv_r1(mxy(6), mxy(12), qx)
      call fmdiv(mxy(7), mxy(6), mxy(10), qx)
      call fmadd(mjsums(1), mxy(10), mxy(3), qx)
      call fmcancel(mjsums(1), mxy(10), mxy(3), k, qx)
      n_acc = n_acc - k
      call fmeq(mxy(3), mxy(10), qx)
      if (mod(n-1, 2) == 1) call fmnegate(mxy(10), qx)

!             Now pgam of the shifted argument has been computed.  Reverse the shifting.
!             The sum 1/(ma)**(n+1) + ... + 1/(ma+lshift-1)**(n+1) is computed.

!             mxy(13) is z
!             mxy(9) is n!
!             mxy(10) is the sum of the asymptotic series
!             mxy(11) is the sum 1/(ma)**(n+1) + ... + 1/(ma+lshift-1)**(n+1)

      if (lshift > 0) then
          call fmi2m(1, mxy(6), qx)
          call fmeq(mxy(13), mxy(7), qx)
          n1 = -(n + 1)
          call fmipwr(mxy(7), n1, mxy(11), qx)
          do k = 1, lshift-1
             call fmadd_r1(mxy(7), mxy(6), qx)
             call fmipwr(mxy(7), n1, mxy(12), qx)
             call fmadd_r1(mxy(11), mxy(12), qx)
          enddo
          call fmmpy_r2(mxy(9), mxy(11), qx)
          if (mod(n+1, 2) == 1) call fmnegate(mxy(11), qx)
          call fmadd(mxy(10), mxy(11), mxy(3), qx)
          call fmcancel(mxy(10), mxy(11), mxy(3), k, qx)
          n_acc = n_acc - k
          call fmeq(mxy(3), mxy(10), qx)
      endif

!             Use the reflection formula if ma was less than -1/2.

      if (krflct == 1) then

!             mxy(11) is cot(Pi*z)
!             mxy(9) is mxy(11)**2

!             Reduce the argument before multiplying by Pi.

          call fmmpyi(mxy(13), 2, mxy(5), qx)
          call fmint(mxy(5), mxy(9), qx)
          if (fmcomp(mxy(5), '==', mxy(9), qx)) then
              call fmi2m(0, mxy(11), qx)
              call fmeq(mxy(11), mxy(9), qx)
              call fmi2m(1, mxy(5), qx)
          else
              call fmnint(mxy(13), mxy(5), qx)
              call fmsub(mxy(13), mxy(5), mxy(9), qx)
              ndsv2 = qx%ndig

              kl = 1
              do while (kl == 1)
                 call fmpi(mxy(11), qx)
                 qx%ndigpi = 0
                 call fmmpy_r1(mxy(11), mxy(9), qx)
                 krsave = qx%krad
                 qx%krad = 1
                 call fmtan(mxy(11), mxy(2), qx)
                 call fmeq(mxy(2), mxy(11), qx)
                 qx%krad = krsave
                 if ((mxy(11)%mp(2) < 0 .or. mxy(11)%mp(2) > 1) .and.  &
                     ndsv2 == qx%ndig) then
                     iextra = int(max(-mxy(11)%mp(2), mxy(11)%mp(2)))
                     if (abs(mxy(11)%mp(2)) >= qx%mexpov) iextra = 0
                     if (iextra > 0) then
                         call fmequ_r1(mxy(9), qx%ndig, qx%ndig+iextra, qx)
                         call fmndig(qx%ndig + iextra, qx)
                         cycle
                     else
                         kl = 0
                     endif
                 else
                     exit
                 endif
              enddo

              call fmndig(ndsv2, qx)
              call fmi2m(1, mxy(5), qx)
              call fmdiv_r2(mxy(5), mxy(11), qx)
              call fmsqr(mxy(11), mxy(9), qx)
          endif
          nc = (n+1)/2

!             For n up to 14, use the stored coefficients to compute the Nth derivative
!             of Cot(Pi*z).  For larger n, the coefficients are generated from a recurrence
!             relation and stored as FM numbers.

          if (n <= 14) then
              jstart = (n*n + 4 - mod(n, 2))/4
              if (n <= 2) then
                  call fmi2m(1, mxy(6), qx)
              else
                  call fmmpyi(mxy(9), kcoeff(jstart), mxy(6), qx)
              endif
              do j = 2, nc
                 call fmi2m(kcoeff(jstart+j-1), mxy(7), qx)
                 call fmadd_r1(mxy(6), mxy(7), qx)
                 if (j < nc) call fmmpy_r1(mxy(6), mxy(9), qx)
              enddo
              if (mod(n, 2) == 0) call fmmpy_r1(mxy(6), mxy(11), qx)
              if (n > 1) call fmmpyi_r1(mxy(6), kgcd(n), qx)
          else
              if (nc > ljsums) then
                  qx%kflag = -12
                  write (qx%kw,                                                      &
                         "(' For PGAM(', I5, ',*) with NDIG =', I5, ', ', I7, "  //  &
                         "' elements are needed'/' in array MJSUMS.', "          //  &
                         "'  The current dimension of MJSUMS IS', I7/)"              &
                        ) n, qx%ndig, nc*(qx%ndig+3), ljsums
                  call fmunknown(mresult, qx)
                  return
              endif

              do j = 1, 7
                 call fmi2m(kcoeff(j+49), mjsums(j), qx)
                 call fmmpyi_r1(mjsums(j), kgcd(14), qx)
              enddo
              do jn = 15, n
                 jnc = (jn+1)/2
                 do k = jnc, 2, -1
                    if (k == jnc .and. mod(jn, 2) == 1) then
                        call fmeq(mjsums(k-1), mjsums(k), qx)
                    else
                        call fmadd_r2(mjsums(k-1), mjsums(k), qx)
                        call fmmpyi_r1(mjsums(k), jn-2*(k-1), qx)
                    endif
                 enddo
                 call fmmpyi_r1(mjsums(1), jn, qx)
              enddo

!             mjsums now has the coefficients needed for the polynomial in Cot**2 that defines
!             the Nth derivative of Cot.

              call fmeq(mjsums(1), mxy(6), qx)
              do j = 2, nc
                 call fmmpy_r1(mxy(6), mxy(9), qx)
                 call fmadd_r1(mxy(6), mjsums(j), qx)
              enddo
              if (mod(n, 2) == 0) call fmmpy_r1(mxy(6), mxy(11), qx)
          endif

!             To complete the calculation of the nth derivative of cot, multiply the polynomial
!             in cot**2 by csc**2.

          call fmadd(mxy(9), mxy(5), mxy(7), qx)
          call fmmpy_r1(mxy(6), mxy(7), qx)

          call fmpi(mxy(5), qx)
          qx%ndigpi = 0
          call fmipwr(mxy(5), n+1, mxy(7), qx)
          call fmmpy_r1(mxy(6), mxy(7), qx)
          if (mod(n, 2) == 1) call fmnegate(mxy(10), qx)
          call fmadd(mxy(10), mxy(6), mxy(3), qx)
          call fmcancel(mxy(10), mxy(6), mxy(3), k, qx)
          n_acc = n_acc - k
          call fmeq(mxy(3), mxy(10), qx)
      endif

      call fmeq(mxy(10), mresult, qx)

      return
      end subroutine fmpgam_m1

      subroutine fmpgam_sc(n, ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = polygamma(n,ma).

!  kresult = 1 is returned if a special case gives the value of polygamma(n,ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mbern(lmbern)
      integer :: ndbern(lmbern)
      type(multi) :: ma, mxy(13), mresult
      integer :: n, kresult, ndsave
      intent (in) :: n, ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      double precision :: xe, ye
      integer :: j, k, krsave, nds
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMPGAM   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inpi1(n, ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (n == 0) then
          call fmpsi(malocal, mresult, qx)
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (qx%kround /= 1 .and. n >= 0) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          krsave = qx%kround
          qx%kround = 1
          nds = qx%ndig
          call fmndig(qx%ndig + qx%ngrd52, qx)
          call fmequ(malocal, mxy(1), nds, qx%ndig, qx)
          call fmi2m(0, mxy(2), qx)
          call fmsub(mxy(2), mxy(1), mxy(3), qx)
          call fmipwr(mxy(3), -n-1, mxy(4), qx)
          if (n >= 2) then
              call fmi2m(n, mxy(6), qx)
              call fmfact(mxy(6), mxy(7), qx)
              call fmmpy_r1(mxy(4), mxy(7), qx)
          endif
          if (mod(n, 2) == 1) then
              call fmi2m(1, mxy(2), qx)
              call fmbern(n+1, mxy(2), mxy(3), mbern, ndbern, qx)
              call fmabs(mxy(3), mxy(6), qx)
              call fmpi(mxy(7), qx)
              qx%ndigpi = 0
              call fmipwr(mxy(7), n+1, mxy(8), qx)
              call fmmpy(mxy(6), mxy(8), mxy(7), qx)
              call fmi2m(2, mxy(2), qx)
              call fmipwr(mxy(2), n-1, mxy(6), qx)
              call fmmpy(mxy(6), mxy(7), mxy(8), qx)
              call fmdivi(mxy(8), (n+1)/2, mxy(5), qx)
          else
              call fmi2m(1, mxy(2), qx)
              call fmbern(n, mxy(2), mxy(3), mbern, ndbern, qx)
              call fmabs(mxy(3), mxy(6), qx)
              call fmpi(mxy(7), qx)
              qx%ndigpi = 0
              call fmipwr(mxy(7), n, mxy(8), qx)
              call fmmpy(mxy(6), mxy(8), mxy(7), qx)
              call fmi2m(2, mxy(2), qx)
              call fmipwr(mxy(2), n-2, mxy(6), qx)
              call fmmpy(mxy(6), mxy(7), mxy(8), qx)
              call fmdivi(mxy(8), n/2, mxy(10), qx)
              call fmi2m(1, mxy(2), qx)
              call fmbern(n+2, mxy(2), mxy(3), mbern, ndbern, qx)
              call fmabs(mxy(3), mxy(6), qx)
              call fmpi(mxy(7), qx)
              qx%ndigpi = 0
              call fmipwr(mxy(7), n+2, mxy(8), qx)
              call fmmpy(mxy(6), mxy(8), mxy(7), qx)
              call fmi2m(2, mxy(2), qx)
              call fmipwr(mxy(2), n, mxy(6), qx)
              call fmmpy(mxy(6), mxy(7), mxy(8), qx)
              call fmdivi(mxy(8), (n+2)/2, mxy(11), qx)
              call fmmpy(mxy(10), mxy(11), mxy(9), qx)
              call fmsqrt(mxy(9), mxy(10), qx)
              call fmi2m(0, mxy(8), qx)
              call fmsub(mxy(8), mxy(10), mxy(5), qx)
          endif
          call fmovun_xe(mxy(4), xe, qx)
          call fmovun_xe(mxy(5), ye, qx)
          if (xe - ye > ndsave+1 .and. abs(mxy(4)%mp(2)) < qx%mexpov .and.  &
              abs(mxy(5)%mp(2)) < qx%mexpov) then
              call fmequ(mxy(4), mxy(6), qx%ndig, nds, qx)
              call fmequ(mxy(6), mxy(8), nds, qx%ndig, qx)
              call fmsub(mxy(4), mxy(8), mxy(6), qx)
              if (mxy(6)%mp(3) == 0) then
                  call fmequ(mxy(4), mxy(6), qx%ndig, nds, qx)
                  call fmequ(mxy(5), mxy(7), qx%ndig, nds, qx)
                  call fmndig(nds, qx)
                  qx%kround = krsave
                  call fmadd(mxy(6), mxy(7), mresult, qx)
              else
                  qx%kround = krsave
                  call fmequ(mxy(4), mresult, qx%ndig, nds, qx)
              endif
              if (qx%kflag == 1) qx%kflag = 0
              qx%ntrace = j
              qx%kwarn = k
              call fmndig(nds, qx)
              qx%kround = krsave
              kresult = 1
              return
          endif
          qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          call fmndig(nds, qx)
          qx%kround = krsave
      endif

      return
      end subroutine fmpgam_sc

      subroutine fmpi(ma, qx)

!  ma = pi

      use fmvals_parallel
      implicit none

      type(multi) :: mpisav
      type(multi) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx

      character(155) :: string
      character :: st2(155)
      integer :: j, k, ndmb, ndsave, ndsv
      type(multi) :: mxy(1)
      qx%ndigpi = 0
      qx%mbspi = 0

      call fmalloc(ma, qx%ndig+2, qx)

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      qx%kflag = 0
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMPI'
      if (abs(qx%ntrace) >= 2 .and. qx%ncall <= qx%lvltrc) then
          write (qx%kw, "(' Input to FMPI')")
      endif

!             Increase the working precision.

      ndsave = qx%ndig
      if (qx%ncall == 1) then
          k = qx%ngrd52
          call fmndig(max(qx%ndig+k, 3), qx)
      endif

!             Check to see if pi has previously been computed in base mbase with
!             sufficient precision.

      if (qx%mbspi == qx%mbase .and. qx%ndigpi >= qx%ndig) then
          call fmequ(mpisav, ma, qx%ndigpi, ndsave, qx)
      else
          ndmb = int(150.0*2.302585/qx%alogmb)
          if (ndmb >= qx%ndig) then
              ndsv = qx%ndig
              call fmndig(ndmb, qx)
              string = '3.141592653589793238462643383279502884197169'//  &
              '39937510582097494459230781640628620899862803482534211'//  &
              '7067982148086513282306647093844609550582231725359408128'
              k = min(int((qx%ndig-1) * qx%dlogmb / qx%dlogtn + 3), len(string))
              do j = 1, k
                 st2(j) = string(j:j)
              enddo
              call fminp(st2, mpisav, 1, k, qx)
              qx%mbspi = qx%mbase
              qx%ndigpi = qx%ndig
              if (abs(mpisav%mp(2)) > 10) qx%ndigpi = 0
          else
              ndsv = qx%ndig
              call fmndig(qx%ndig + 2 + qx%ndig/100, qx)
              call fmpi2(mxy(1), qx)
              call fmeq(mxy(1), mpisav, qx)
              qx%mbspi = qx%mbase
              qx%ndigpi = qx%ndig
              if (abs(mpisav%mp(2)) > 10) qx%ndigpi = 0
          endif
          call fmequ(mpisav, ma, qx%ndig, ndsave, qx)
          call fmndig(ndsv, qx)
      endif

      qx%ndig = ndsave
      if (qx%ntrace /= 0) call fmntr_out1(ma, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmpi

      subroutine fmpi2(mpi, qx)

!  Internal routine to compute pi.
!  The formula used is due to s. Ramanujan.  For low to moderate precision, this routine uses
!  the series
!                                                (4n)!(1103+26390n)
!  1/pi = (sqrt(8)/9801) * sum(n=0 to infinity) --------------------
!                                               ((n!)**4)(396**(4n))
!
!  For higher precision, see routine fmpi3.
!
!  The result is returned in mpi.

      use fmvals_parallel
      implicit none

      type(multi) :: mpi
      intent (inout) :: mpi
      type(fm_settings) :: qx

      double precision :: x
      real (kind(1.0d0)) :: mx
      integer :: nstack(49), j, k, kst, large, n, ndigrd, ndsave, nmethd
      type(multi) :: mxy(4)

      call fmalloc(mpi, qx%ndig+2, qx)

!             Check for using binary splitting if precision is high.

      if (qx%ndig >= 100) then
          nmethd = 2
      else
          nmethd = 1
      endif
      if (nmethd == 2) then
          call fmpi3(mpi, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      ndsave = qx%ndig
      n = -1
      call fmi2m(1103, mpi, qx)
      call fmi2m(0, mxy(1), qx)
      call fmi2m(1, mxy(2), qx)
      call fmi2m(26390, mxy(3), qx)
      call fmi2m(1103, mxy(4), qx)
      mx = mxbase**2/qx%mbase
      if (mx > qx%mxexp2) mx = qx%mxexp2

      do
         n = n + 1
         large = int(mx)/(4*n + 3)
         j = 4*n + 1
         if (j > large) then
             call fmmpyi_r1(mxy(2), j, qx)
             j = j + 1
             call fmmpyi_r1(mxy(2), j, qx)
             j = j + 1
             call fmmpyi_r1(mxy(2), j, qx)
         else if (j*(j+1) > large) then
             k = j*(j+1)
             call fmmpyi_r1(mxy(2), k, qx)
             j = j + 2
             call fmmpyi_r1(mxy(2), j, qx)
         else
             k = j*(j+1)*(j+2)
             call fmmpyi_r1(mxy(2), k, qx)
         endif

         j = n + 1
         large = int(mxbase)/j
         if (j > large) then
             call fmdivi_r1(mxy(2), j, qx)
             call fmdivi_r1(mxy(2), j, qx)
             call fmdivi_r1(mxy(2), j, qx)
         else if (j*j > large) then
             k = j*j
             call fmdivi_r1(mxy(2), k, qx)
             call fmdivi_r1(mxy(2), j, qx)
         else
             k = j*j*j
             call fmdivi_r1(mxy(2), k, qx)
         endif

!             Break 4/396**4 into 1/(2178*2178*1296).

         j = 2178
         large = int(mxbase)/j
         if (j > large) then
             call fmdivi_r1(mxy(2), j, qx)
             call fmdivi_r1(mxy(2), j, qx)
             call fmdivi_r1(mxy(2), 1296, qx)
         else
             k = j*j
             call fmdivi_r1(mxy(2), k, qx)
             call fmdivi_r1(mxy(2), 1296, qx)
         endif

         ndigrd = qx%ndig
         qx%ndig = ndsave
         call fmadd_r2(mxy(3), mxy(4), qx)
         call fmndig(ndigrd, qx)
         call fmmpy(mxy(2), mxy(4), mxy(1), qx)

         qx%ndig = ndsave
         call fmadd_r1(mpi, mxy(1), qx)
         call fmndig(max(qx%ngrd22, ndsave - int(mpi%mp(2) - mxy(1)%mp(2))), qx)
         if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         if (qx%kflag == 1) exit
      enddo

      qx%ndig = ndsave
      call fmi2m(8, mxy(2), qx)
      x = 8
      x = sqrt(x)
      call fmdpm(x, mxy(4), qx)
      call fmdig(nstack, kst, qx)
      do j = 1, kst
         call fmndig(nstack(j), qx)
         call fmdiv(mxy(2), mxy(4), mxy(1), qx)
         call fmadd_r1(mxy(4), mxy(1), qx)
         call fmdivi_r1(mxy(4), 2, qx)
      enddo
      call fmi2m(9801, mxy(3), qx)
      call fmmpy_r1(mpi, mxy(4), qx)
      call fmdiv_r2(mxy(3), mpi, qx)

      return
      end subroutine fmpi2

      subroutine fmpi3(mpi, qx)
      use fmvals_parallel
      implicit none

!  Internal pi routine for very high precision.

!  The algorithm used is Chudnovskys' Ramanujan-style series with binary splitting.

!                                                  (-1)**n*(6n)!(13591409+545140134*n)
!  1/pi = (12/640320**(3/2)) * sum(n=0 to infinity) -----------------------------------
!                                                     (n!)**3*(3*n)!*(640320**(3n))
!  The result is returned in mpi.

      type(multi) :: mpi
      intent (inout) :: mpi
      type(fm_settings) :: qx

      integer :: k, level_of_recursion
      type(multi) :: mxy(4)

      call fmalloc(qx%mwa, 2*qx%ndig+230, qx)

!             Determine k, the number of terms to sum in the series for pi.

      k = qx%ndig*qx%dlogmb/3.2654441d+1 + 10
      level_of_recursion = 0
      call fmpi3_pqt(0, k, mxy(1), mxy(2), mxy(3), level_of_recursion, qx)

      if (mxy(2)%mp(2) >= qx%ndig .and. mxy(3)%mp(2) >= qx%ndig) then
          call fmdiv(mxy(2), mxy(3), mxy(1), qx)
          call fmi2m(640320, mxy(2), qx)
          call fmsqrt(mxy(2), mxy(3), qx)
          call fmmpyi_r1(mxy(3), 53360, qx)
          call fmmpy(mxy(1), mxy(3), mpi, qx)
      else
          if (mxy(2)%mp(2) >= qx%ndig) then
              call fmeq(mxy(2), mxy(1), qx)
          else
              call imi2fm(mxy(2), mxy(1), qx)
          endif
          if (mxy(3)%mp(2) >= qx%ndig) then
              call fmeq(mxy(3), mxy(4), qx)
          else
              call imi2fm(mxy(3), mxy(4), qx)
          endif
          call fmdiv(mxy(1), mxy(4), mxy(3), qx)
          call fmi2m(640320, mxy(1), qx)
          call fmsqrt(mxy(1), mxy(2), qx)
          call fmmpyi_r1(mxy(2), 53360, qx)
          call fmmpy(mxy(2), mxy(3), mpi, qx)
      endif

      return
      end subroutine fmpi3

      recursive subroutine fmpi3_pqt(a, b, mp, mq, mt, level_of_recursion, qx)

!  This routine does the binary splitting for computing the constant pi.

      use fmvals_parallel
      implicit none

      type(multi) :: mp, mq, mt
      integer :: a, b, level_of_recursion
      intent (in) :: a, b
      intent (inout) :: mp, mq, mt, level_of_recursion
      type(fm_settings) :: qx

      type(multi) :: mxy(6)
      integer :: j, ka, km, result_size
      real (kind(0.0d0)) :: da, db

      da = a
      db = b
      level_of_recursion = level_of_recursion + 1

      if (b-a < 10) then
          result_size = ( (db-da)*4.276666 + 3*( (db+0.5d0)*log(db+1) - db + 1/(12*(db+1)) -  &
                        ( (da+0.5d0)*log(da+1) - da + 1/(12*(da+1)) ) ) ) * 1.01 / qx%dlogmb + 15
          result_size = max(5, result_size) + 5*log(dble(qx%ndig))/qx%dlogmb + 15
          call fmalloc(mp, result_size, qx)
          result_size = ( (db-da)*36.93111 + 3*( (db+0.5d0)*log(db+1) - db + 1/(12*(db+1)) -  &
                        ( (da+0.5d0)*log(da+1) - da + 1/(12*(da+1)) ) ) ) * 1.01 / qx%dlogmb + 15
          result_size = max(5, result_size) + 5*log(dble(qx%ndig))/qx%dlogmb + 15
          call fmalloc(mq, result_size, qx)
          call fmalloc(mt, result_size, qx)
          call fmalloc(mxy(1), result_size, qx)
          call fmalloc(mxy(2), result_size, qx)
          call fmalloc(mxy(3), result_size, qx)
          call fmalloc(mxy(4), result_size, qx)
          call fmalloc(mxy(5), result_size, qx)
          call imi2m(1, mp, qx)
          ka = a
          if (ka == 0) ka = 1
          do j = ka, b
             call immpyi(mp, -(6*j-5), mxy(2), qx)
             call immpyi(mxy(2), 2*j-1, mxy(1), qx)
             call immpyi(mxy(1), 6*j-1, mp, qx)
          enddo

          call imi2m(640320, mxy(1), qx)
          call imsqr(mxy(1), mxy(3), qx)
          call immpy(mxy(3), mxy(1), mxy(2), qx)
          call imdivi(mxy(2), 24, mxy(1), qx)
          call imi2m(1, mq, qx)
          do j = ka, b
             call immpyi(mq, j, mxy(3), qx)
             call immpyi(mxy(3), j, mxy(2), qx)
             call immpyi(mxy(2), j, mxy(3), qx)
             call immpy(mxy(3), mxy(1), mq, qx)
          enddo

          call imi2m(0, mt, qx)
          if (a == 0) then
              call immpyi(mq, 13591409, mt, qx)
          endif
          call imeq(mq, mxy(2), qx)
          do j = ka, b
             call immpyi(mxy(2), -(6*j-5), mxy(3), qx)
             call immpyi(mxy(3), 2*j-1, mxy(4), qx)
             call immpyi(mxy(4), 6*j-1, mxy(2), qx)
             call imdivi(mxy(2), j, mxy(3), qx)
             call imdivi(mxy(3), j, mxy(4), qx)
             call imdivi(mxy(4), j, mxy(3), qx)
             call imdiv(mxy(3), mxy(1), mxy(2), qx)
             call imi2m(545140134, mxy(3), qx)
             call immpyi(mxy(3), j, mxy(4), qx)
             call imi2m(13591409, mxy(3), qx)
             call imadd(mxy(3), mxy(4), mxy(5), qx)
             call immpy(mxy(2), mxy(5), mxy(3), qx)
             call imadd(mt, mxy(3), mxy(4), qx)
             call imeq(mxy(4), mt, qx)
          enddo
      else
          km = a/2 + b/2 + mod(a, 2)*mod(b, 2)
          call fmpi3_pqt(a, km-1, mxy(1), mxy(2), mxy(3), level_of_recursion, qx)
          call fmpi3_pqt(km, b, mxy(4), mxy(5), mxy(6), level_of_recursion, qx)

!             mp is not needed in fmpi3, so this multiplication can be skipped at the top level
!             of the recursion.

          if (level_of_recursion > 1) then
              call im_or_fm_mpy(mxy(1), mxy(4), mp, qx)
          else
              call imi2m(0, mp, qx)
          endif
          call im_or_fm_mpy(mxy(2), mxy(5), mq, qx)

          call im_or_fm_mpy(mxy(5), mxy(3), mxy(2), qx)
          call im_or_fm_mpy(mxy(1), mxy(6), mxy(4), qx)
          call im_or_fm_add(mxy(2), mxy(4), mt, qx)
      endif

      level_of_recursion = level_of_recursion - 1

      return
      end subroutine fmpi3_pqt

      subroutine fmpoch(ma, n, mb, qx)

!  mb = ma*(ma+1)*(ma+2)*...*(ma+n-1)       (pochhammer's symbol)

!  mb = gamma(ma+n)/gamma(ma)

!  For negative n, pochhammer(ma,n) = 1/pochhammer(ma+n,-n).


      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: n
      intent (in) :: ma, n
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(15), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmpoch_sc(ma, n, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call fmpoch_m1(ma, n, mxy, mresult, ndsave, qx)
         if (n < 0) then
             call fmi2m(1, mxy(6), qx)
             call fmdiv_r2(mxy(6), mresult, qx)
         endif
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmpoch

      subroutine fmpoch_m1(ma, n, mxy, mresult, ndsave, qx)

!  Method 1 for computing ma*(ma+1)*(ma+2)*...*(ma+n-1).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(15), mresult
      integer :: n, ndsave
      intent (in) :: ma, n, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: ma2, mas, mbsign
      real :: t
      double precision :: xe
      integer :: iextra, j, jr, k, k0, k1, k2, klast, km08, kmb, lt, nt
      logical, external :: fmcomp

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

      ma2 = ma%mp(3)
      mas = ma%mp(1)
      nt = n
      call fmeq(mxy(1), mxy(13), qx)

!             Check for special cases.

      iextra = 0
      if (n == 0) then
          call fmi2m(1, mresult, qx)
          return
      endif
      if (nt < 0) then
          call fmaddi(mxy(1), nt, qx)
          call fmeq(mxy(1), mxy(13), qx)
          nt = -nt
          ma2 = mxy(1)%mp(3)
          mas = mxy(1)%mp(1)
      endif
      if (ma2 == 0) then
          if (nt > 0) then
              call fmi2m(0, mresult, qx)
              return
          else
              call fmunknown(mresult, qx)
              qx%kflag = -4
              return
          endif
      endif
      if (nt == 0) then
          call fmi2m(1, mresult, qx)
          return
      else if (nt == 1) then
          call fmeq(mxy(1), mresult, qx)
          return
      endif
      call fmi2m(1, mxy(4), qx)
      jr = qx%kround
      qx%kround = 1
      call fmadd(mxy(1), mxy(4), mxy(5), qx)
      qx%kround = jr
      if (fmcomp(mxy(5), '==', mxy(4), qx)) then
          t = qx%ndig
          j = int(15.21*sqrt(t)*qx%alogmt + 42.87*sqrt(t) + 30.0)
          if (nt <= j) then
              k1 = nt - 1
              call fmfcti(k1, mresult, qx)
              call fmmpy_r2(mxy(1), mresult, qx)
              return
          endif
      endif

!             For large values of ma, the result is ma**nt.

      lt = qx%ndig + 3 + int(2.0d0*log(dble(nt))/qx%dlogmb)
      call fmovun_xe(mxy(1), xe, qx)
      if (xe > lt) then
          call fmipwr(mxy(13), nt, mxy(11), qx)
          if (qx%kround /= 1 .and. nt > 1) then
              if (abs(mxy(11)%mp(2)) /= qx%mexpov) then
                  call fmdiv(mxy(11), mxy(13), mxy(8), qx)
                  if (mod(nt, 2) == 0) then
                      call fmmpyi_r1(mxy(8), nt-1, qx)
                      call fmmpyi_r1(mxy(8), nt/2, qx)
                  else
                      call fmmpyi_r1(mxy(8), (nt-1)/2, qx)
                      call fmmpyi_r1(mxy(8), nt, qx)
                  endif
                  call fmadd_r1(mxy(11), mxy(8), qx)
              endif
          endif
          call fmeq(mxy(11), mresult, qx)
          return
      endif

      mbsign = 1
      if (mas < 0) then
          call fmint(mxy(13), mxy(8), qx)
          call fmi2m(nt, mxy(9), qx)
          jr = qx%kround
          qx%kround = 1
          call fmadd(mxy(13), mxy(9), mxy(10), qx)
          qx%kround = jr
          if (fmcomp(mxy(13), '==', mxy(8), qx)) then

!                  If ma is a negative integer and ma+nt is positive, then the result is zero.

              if (mxy(10)%mp(1)*mxy(10)%mp(3) > 0) then
                  call fmi2m(0, mresult, qx)
                  return
              endif
          endif

!                  If ma is negative and ma+nt-1 is negative, then use the reflection formula
!                  Pochhammer(ma,nt) = (-1)**nt*Pochhammer(-ma-(nt-1),nt).

          call fmi2m(1, mxy(11), qx)
          if (fmcomp(mxy(10), '<', mxy(11), qx)) then

!                 Extra guard digits may be required to insure the reflection formula is accurate.

              iextra = max(int(mxy(13)%mp(2)), iextra)
              if (abs(mxy(13)%mp(2)) >= qx%mexpov) iextra = 0
              if (iextra > 0) then
                  call fmequ_r1(mxy(13), qx%ndig, qx%ndig+iextra, qx)
              endif
              call fmndig(qx%ndig + iextra, qx)
              call fmi2m(nt-1, mxy(11), qx)
              call fmnegate(mxy(13), qx)
              call fmsub_r1(mxy(13), mxy(11), qx)
              if (mod(nt, 2) == 1) mbsign = -1
          endif
      endif

!             If nt is large enough, it is faster to use two calls to fmlngm.
!             The formula below gives a rough approximation of where to change methods.

      t = qx%ndig
      j = int(15.21*sqrt(t)*qx%alogmt + 42.87*sqrt(t) + 25.03)
      if (nt > j) then
          call fmi2m(nt, mxy(4), qx)
          call fmadd(mxy(13), mxy(4), mxy(14), qx)

!             Compute iextra, the number of extra digits required to compensate for
!             cancellation error.

          if (max(mxy(13)%mp(2), mxy(14)%mp(2)) > iextra) then
              iextra = int(max(mxy(13)%mp(2), mxy(14)%mp(2)))
              if (abs(mxy(13)%mp(2)) >= qx%mexpov .or. abs(mxy(14)%mp(2)) >= qx%mexpov)  &
                  iextra = 0
          endif
          if (iextra > 0) then
              call fmequ_r1(mxy(13), qx%ndig, qx%ndig+iextra, qx)
          endif
          call fmndig(qx%ndig + iextra, qx)

          call fmi2m(-1, mxy(15), qx)
          if (iextra > 0) then
              call fmi2m(nt, mxy(4), qx)
              call fmadd(mxy(13), mxy(4), mxy(14), qx)
          endif
          call fmi2m(2, mxy(9), qx)
          kmb = 0
          if (mxy(13)%mp(1) < 0) then
              call fmmod(mxy(13), mxy(9), mxy(8), qx)
              if (fmcomp(mxy(8), '>', mxy(15), qx)) kmb = 1
          endif
          km08 = 0
          if (mxy(14)%mp(1) < 0) then
              call fmmod(mxy(14), mxy(9), mxy(8), qx)
              if (fmcomp(mxy(8), '>', mxy(15), qx)) km08 = 1
          endif
          call fmi2m(1, mxy(15), qx)
          if (mxy(13)%mp(1) < 0 .and. kmb == 1) then
              call fmeq(mxy(13), mxy(15), qx)
              call fmi2m(1, mxy(4), qx)
              call fmadd(mxy(13), mxy(4), mxy(2), qx)
              call fmlngm(mxy(2), mxy(13), qx)
          else
              call fmlngm(mxy(13), mxy(3), qx)
              call fmeq(mxy(3), mxy(13), qx)
          endif
          if (mxy(14)%mp(1) < 0 .and. km08 == 1) then
              call fmi2m(-1, mxy(7), qx)
              call fmadd_r1(mxy(14), mxy(7), qx)
              call fmmpy(mxy(15), mxy(14), mxy(2), qx)
              call fmlngm(mxy(2), mxy(14), qx)
          else
              call fmlngm(mxy(14), mxy(3), qx)
              call fmeq(mxy(3), mxy(14), qx)
          endif

          call fmsub(mxy(14), mxy(13), mxy(11), qx)
          call fmexp(mxy(11), mxy(2), qx)
          qx%ndige = 0
          call fmmpy(mxy(2), mxy(15), mxy(11), qx)
      else

!             Compute the product z*(z+1)*...*(z+nt-1) four terms at a time to reduce the number
!             of fmmpy calls.

!             mxy(13) is z
!             mxy(6) is z**2
!             mxy(7) is z**3
!             mxy(8) is (z+k)*...*(z+k+3)
!             mxy(11) is the current product

!             If mxy(13) is negative and mxy(13)+nt is positive, extra digits are required when
!             mxy(13) is close to an integer.

          if (mxy(13)%mp(1) < 0) then
              call fmi2m(nt, mxy(8), qx)
              call fmadd(mxy(13), mxy(8), mxy(9), qx)
              if (mxy(9)%mp(1)*mxy(9)%mp(3) > 0) then
                  call fmnint(mxy(13), mxy(10), qx)
                  if (mxy(10)%mp(3) /= 0) then
                      call fmsub(mxy(13), mxy(10), mxy(9), qx)
                      iextra = max(iextra, qx%ndig-ndsave)
                      if (max(mxy(13)%mp(2), mxy(9)%mp(2)) > iextra) then
                          iextra = int(max(mxy(13)%mp(2), mxy(9)%mp(2)))
                          if (abs(mxy(13)%mp(2)) >= qx%mexpov .or.  &
                              abs(mxy(9)%mp(2)) >= qx%mexpov) iextra = 0
                      endif
                      if (iextra > 0) then
                          call fmequ_r1(mxy(13), qx%ndig, qx%ndig+iextra, qx)
                      endif
                      call fmndig(qx%ndig + iextra, qx)
                  endif
              endif
          endif

          call fmi2m(1, mxy(11), qx)
          if (nt >= 4) then
              call fmsqr(mxy(13), mxy(6), qx)
              call fmmpy(mxy(13), mxy(6), mxy(7), qx)
              call fmsqr(mxy(6), mxy(8), qx)
              call fmcsmpyi(mxy(7), 6, mxy(12), qx)
              call fmcsadd_r1(mxy(8), mxy(12), qx)
              call fmcsmpyi(mxy(6), 11, mxy(12), qx)
              call fmcsadd_r1(mxy(8), mxy(12), qx)
              call fmcsmpyi(mxy(13), 6, mxy(12), qx)
              call fmcsadd_r1(mxy(8), mxy(12), qx)
              call fmeq(mxy(8), mxy(11), qx)
              call fmcsmpyi_r1(mxy(7), 16, qx)
              do k = 0, nt-8, 4
                 call fmcsadd_r1(mxy(8), mxy(7), qx)
                 k2 = 24*(2*k + 7)
                 call fmcsmpyi(mxy(6), k2, mxy(12), qx)
                 call fmcsadd_r1(mxy(8), mxy(12), qx)
                 if (k <= sqrt(real(intmax)/49.0)) then
                     k1 = 8*(6*k*k + 42*k + 79)
                     call fmcsmpyi(mxy(13), k1, mxy(12), qx)
                     call fmcsadd_r1(mxy(8), mxy(12), qx)
                 else
                     k1 = 48*k
                     call fmcsmpyi(mxy(13), k1, mxy(12), qx)
                     call fmcsmpyi_r1(mxy(12), k, qx)
                     call fmcsadd_r1(mxy(8), mxy(12), qx)
                     k1 = 336*k + 632
                     call fmcsmpyi(mxy(13), k1, mxy(12), qx)
                     call fmcsadd_r1(mxy(8), mxy(12), qx)
                 endif
                 if (k <= (real(intmax)/17.0)**0.3333) then
                     k0 = 8*(2*k + 7)*(k*k + 7*k + 15)
                     call fmaddi(mxy(8), k0, qx)
                 else if (k <= sqrt(real(intmax)*0.9)) then
                     k0 = 8*(2*k + 7)
                     call fmi2m(k0, mxy(12), qx)
                     k0 = k*k + 7*k + 15
                     call fmcsmpyi_r1(mxy(12), k0, qx)
                     call fmcsadd_r1(mxy(8), mxy(12), qx)
                 else
                     k0 = 8*(2*k + 7)
                     call fmi2m(k0, mxy(12), qx)
                     call fmcsmpyi(mxy(12), k, mxy(9), qx)
                     call fmcsmpyi_r1(mxy(9), k, qx)
                     call fmcsadd_r1(mxy(8), mxy(9), qx)
                     k0 = 7*k + 15
                     call fmcsmpyi_r1(mxy(12), k0, qx)
                     call fmcsadd_r1(mxy(8), mxy(12), qx)
                 endif
                 call fmcsmpy_r1(mxy(11), mxy(8), qx)
              enddo
          endif

          klast = (nt/4)*4
          do j = klast, nt-1
             call fmi2m(j, mxy(9), qx)
             call fmcsadd_r1(mxy(9), mxy(13), qx)
             call fmcsmpy_r1(mxy(11), mxy(9), qx)
          enddo
      endif

!             If the reflection formula was used, multiply by (-1)**nt.

      mxy(11)%mp(1) = mbsign*mxy(11)%mp(1)

      call fmeq(mxy(11), mresult, qx)

      return
      end subroutine fmpoch_m1

      subroutine fmpoch_sc(ma, n, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = ma*(ma+1)*(ma+2)*...*(ma+n-1).

!  kresult = 1 is returned if a special case gives the value of ma*(ma+1)*(ma+2)*...*(ma+n-1).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(15), mresult
      integer :: n, kresult, ndsave
      intent (in) :: ma, n, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      type(multi) :: malocal
      double precision :: xe, ye
      integer :: j, k, k1, krsave, nds, nt

      kresult = 0

      qx%namest(qx%ncall) = 'FMPOCH   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1i(ma, n, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      call fmovun_xe(malocal, xe, qx)
      if (qx%kround /= 1 .and. xe < -ndsave .and. n /= 0 .and. n /= 1) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          krsave = qx%kround
          qx%kround = 1
          nds = qx%ndig
          call fmndig(qx%ndig + qx%ngrd52, qx)
          call fmequ(malocal, mxy(1), nds, qx%ndig, qx)
          nt = abs(n) - 1
          if (n < 0) nt = nt + 1
          call fmi2m(nt, mxy(2), qx)
          call fmfact(mxy(2), mxy(3), qx)
          call fmmpy(mxy(1), mxy(3), mxy(4), qx)
          if (nt <= 20) then
              call fmi2m(1, mxy(2), qx)
              call fmi2m(1, mxy(5), qx)
              do k1 = 2, nt
                 call fmdivi(mxy(2), k1, mxy(6), qx)
                 call fmadd_r1(mxy(5), mxy(6), qx)
              enddo
          else
              call fmi2m(nt, mxy(7), qx)
              call fmln(mxy(7), mxy(5), qx)
              qx%ndigli = 0
              call fmeulr(mxy(6), qx)
              qx%ndgeul = 0
              call fmadd_r1(mxy(5), mxy(6), qx)
              call fmi2m(1, mxy(2), qx)
              call fmdiv(mxy(2), mxy(7), mxy(8), qx)
              call fmdivi(mxy(8), 2, mxy(6), qx)
              call fmadd_r1(mxy(5), mxy(6), qx)
              call fmsqr(mxy(8), mxy(9), qx)
              call fmdivi(mxy(9), 12, mxy(6), qx)
              call fmsub_r1(mxy(5), mxy(6), qx)
              call fmsqr(mxy(9), mxy(8), qx)
              call fmdivi(mxy(8), 120, mxy(6), qx)
              call fmadd_r1(mxy(5), mxy(6), qx)
          endif
          if (n > 0) then
              call fmeq(mxy(4), mxy(6), qx)
              call fmmpy(mxy(4), mxy(5), mxy(8), qx)
              call fmmpy(mxy(1), mxy(8), mxy(7), qx)
          else
              if (mod(nt, 2) == 0) then
                  call fmi2m(1, mxy(2), qx)
              else
                  call fmi2m(-1, mxy(2), qx)
              endif
              call fmdiv(mxy(2), mxy(3), mxy(6), qx)
              call fmmpy(mxy(6), mxy(5), mxy(8), qx)
              call fmmpy(mxy(1), mxy(8), mxy(7), qx)
          endif
          call fmovun_xe(mxy(6), xe, qx)
          call fmovun_xe(mxy(7), ye, qx)
          if (xe - ye > ndsave+1 .and. xe < qx%mexpov) then
              call fmequ(mxy(6), mxy(10), qx%ndig, nds, qx)
              call fmequ(mxy(6), mxy(9), qx%ndig, nds, qx)
              call fmequ(mxy(9), mxy(8), nds, qx%ndig, qx)
              call fmsub(mxy(6), mxy(8), mxy(9), qx)
              if (mxy(9)%mp(3) == 0) then
                  call fmequ(mxy(6), mxy(8), qx%ndig, nds, qx)
                  call fmequ(mxy(7), mxy(9), qx%ndig, nds, qx)
                  call fmndig(nds, qx)
                  qx%kround = krsave
                  call fmadd(mxy(8), mxy(9), mresult, qx)
              else
                  qx%kround = krsave
                  call fmequ(mxy(6), mresult, qx%ndig, nds, qx)
              endif
              qx%kflag = 0
              qx%ntrace = j
              qx%kwarn = k
              call fmndig(nds, qx)
              qx%kround = krsave
              kresult = 1
              return
          endif
          qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          call fmndig(nds, qx)
          qx%kround = krsave
      endif

      return
      end subroutine fmpoch_sc

      subroutine fmpower(ma, mb, mc, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      call fmpwr(ma, mb, mc, qx)

      return
      end subroutine fmpower

      subroutine fmprint(ma, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx

      call fmprnt(ma, qx)

      return
      end subroutine fmprint

      subroutine fmprnt(ma, qx)

!  Print ma in base 10 format.

!  fmprnt can be called directly by the user for easy output in m format.
!  ma is converted using fmout and printed.

      use fmvals_parallel
      implicit none

      character :: cmbuff(lmbuff)
      type(multi) :: ma
      type(fm_settings) :: qx

      character(20) :: form
      integer :: j, k, ksave, l, last, lb, nd, nexp
      intent (in) :: ma

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMPRNT'
      ksave = qx%kflag
      nd = int(real(qx%ndig)*log10(real(qx%mbase))) + 1
      if (nd < 2) nd = 2
      nexp = int(2.0*log10(real(mxbase))) + 16
      lb = max(qx%jform2+nexp, nd+nexp)
      if (lb+50 > lmbuff) then
          write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                              " Raise its size (lmbuff) or change the format being used."
          stop
      endif
      call fmout(ma, cmbuff, lb, qx)
      qx%kflag = ksave
      last = lb + 1
      write (form, "(' (6X, ', I3, 'A1) ')") qx%kswide-7
      do j = 1, lb
         if (cmbuff(last-j) /= ' ' .or. j == lb) then
             l = last - j
             write (qx%kw, form) (cmbuff(k), k=1, l)
             qx%ncall = qx%ncall - 1
             return
         endif
      enddo
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmprnt

      subroutine fmpsi(ma, mb, qx)

!  mb = psi(ma)      derivative of ln(gamma(ma))

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(13), mresult, mretry

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmpsi_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      n_acc = nint(qx%ndig*qx%alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmpsi_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry, qx)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmpsi

      subroutine fmpsi_c(ndig_c, mbase_c, c, qx)

!  Initialize the constants used in the psi polynomial.

      use fmvals_parallel
      implicit none

      integer :: ndig_c
      real (kind(1.0d0)) :: mbase_c
      type(multi) :: c(0:196)
      intent (inout) :: ndig_c, mbase_c, c
      type(fm_settings) :: qx

      integer :: ndsave
      character(220) :: st

      ndsave = qx%ndig
      call fmndig(max(qx%ndig, nint(210*qx%dlogtn/qx%dlogmb)), qx)
      ndig_c = qx%ndig
      mbase_c = qx%mbase

      st = " 9.227843350984671393934879099175975689578406640600764011942327651" //  &
           "151322732223353290630529367082532504853685527501929175190394959855" //  &
           "13457163775826002355076463746499666257062662262326057207404741752905084M-1"
      call fmst2m(st, c(0), qx)
      st = " 3.949340668482264364724151666460251892189499012067984377355582293" //  &
           "700074704032008738336289006197587053040043189623371906796287246870" //  &
           "05007787935102946330866276831733309367762605095251006872140054796811559M-1"
      call fmst2m(st, c(1), qx)
      st = " 7.705690315959428539973816151144999076498629234049888179227155534" //  &
           "183820578631309018645587360933525814619915779526071941849199599867" //  &
           "32832137763968372079001614539417829493600667191915755222424942439615639M-2"
      call fmst2m(st, c(2), qx)
      st = " 1.982323371113819151600369654116790277475095191872690768297621544" //  &
           "412061618696884655690963594169991723299081390804274241458407157457" //  &
           "00453492820035147162192070877834809108370293261887348261752736042355062M-2"
      call fmst2m(st, c(3), qx)
      st = " 5.677755143369926331365486457034168057080919501912811974192677903" //  &
           "803589786281484560043106557133336379620341466556609042800961779155" //  &
           "97084183511072180087644866286337180353598363962365128888981335276775240M-3"
      call fmst2m(st, c(4), qx)
      st = " 1.718061984449139714517929790920527901817490032853561842408664004" //  &
           "332182901957897882773977938535170530279191162254558867398181448333" //  &
           "10185379291633807265673175253040965355618769627954139226236853166325794M-3"
      call fmst2m(st, c(5), qx)
      st = " 5.367773819228268397975498497967595998635605652387064172831365716" //  &
           "014783173557353460969689138513239689614536514910748872867774198403" //  &
           "35440315798301033984562121069463585243906583353964676997567696691427804M-4"
      call fmst2m(st, c(6), qx)
      st = " 1.711061979443393786852385086524652589607906498500203291102026525" //  &
           "829525747488143952872303723719711245236484702826900263542995480733" //  &
           "83970966270581799604618992754222287297459333028151505628361773822843426M-4"
      call fmst2m(st, c(7), qx)
      st = " 5.526782608221441785276923241206048560585139488875654859661590978" //  &
           "505339025839895039306912716958615740860476584706026142537397072243" //  &
           "01530691324987642510909294868767654539697941540782602296415448362507489M-5"
      call fmst2m(st, c(8), qx)
      st = " 1.801262781808533714595890031901700601953156447751725778899463629" //  &
           "146515191295439704196861038565275400689206320530767736809020353629" //  &
           "38073190695949842873953621603334722352596732052178932328832066541508011M-5"
      call fmst2m(st, c(9), qx)
      st = " 5.907354119464558702282526469936468606435758208617119141436100054" //  &
           "059798219814702591843023560629835506072948141298603299797940044724" //  &
           "48291452340594666101827864743680486809340363559802370626936931930763706M-6"
      call fmst2m(st, c(10), qx)
      st = " 1.945928308048298637998047739670960416088458003404533040952133252" //  &
           "019681940913049042808551900699474542980945266314269501249317870278" //  &
           "74908804736762623987426734001119677345511898921612599921683514419564006M-6"
      call fmst2m(st, c(11), qx)
      st = " 6.430350784891467518365263573957142751058955098451367026716208967" //  &
           "268298442098128927139532681355390234484052117973406407648522438051" //  &
           "09390967296839296849960667716105732496299638299238322412706670233440209M-7"
      call fmst2m(st, c(12), qx)
      st = " 2.129788087048292585451051353337474816961691545494827552022528629" //  &
           "410231774208766597829719984675128804906172087285080543161655047327" //  &
           "58375412105018997048159105561567647701210317140138410056728113033026445M-7"
      call fmst2m(st, c(13), qx)
      st = " 7.065818202049355172851064506258762794870685817750656993289333226" //  &
           "715634227957307233434701754849436696844424928325302977575887819043" //  &
           "21794404770003433234833231074275648790842338915961498517998739808022623M-8"
      call fmst2m(st, c(14), qx)
      st = " 2.347034615187173257148763672202323738899047153115310520358878708" //  &
           "702795315178628560484632246234627121875727895643809584057710305127" //  &
           "87278924224408794242543715977424052595827644319888981305672643671262471M-8"
      call fmst2m(st, c(15), qx)
      st = " 7.803106649762273600293563029213088249090262679095379843972935643" //  &
           "290282459342081738636916671209602661597101103726013919619715976946" //  &
           "82488687750381269409404895538941410178728305136626722016628210197601304M-9"
      call fmst2m(st, c(16), qx)
      st = " 2.595999374839856461644621939730454697218953331143174429987630039" //  &
           "542650045638001968668989649549309210492316961761661920993360907581" //  &
           "83943362125894719965856782417889275088010359200837997812612518790010306M-9"
      call fmst2m(st, c(17), qx)
      st = " 8.640837414389256569577951013532585711448386302359330467618239497" //  &
           "053413093126642271180763027067164825596661845609758534245303980743" //  &
           "08087916612539453037312942192048368911659495539677311896754022319241514M-10"
      call fmst2m(st, c(18), qx)
      st = " 2.877174665461131520386834493459437941874105957500564898511375137" //  &
           "311439002578360979763874789548515880868154509894190626699457757147" //  &
           "73686016316321832375029203457725272356560152718132192583462548282779007M-10"
      call fmst2m(st, c(19), qx)
      st = " 9.582858468146311671960437304596644669478493760020748737659683908" //  &
           "789815983387663856449725613266381211899380089748749729674239142554" //  &
           "09417096385045411044655577509743953184783848043803078810843691683066120M-11"
      call fmst2m(st, c(20), qx)
      st = " 3.192362617049000364818675299493504182177965826984960311647445893" //  &
           "562291482131615616774398545467628898736874378132707045074901954090" //  &
           "87857585211733812448598150553069088798592369166325857786128311238584878M-11"
      call fmst2m(st, c(21), qx)
      st = " 1.063641452982306778871888232638725499778451985860322579723624373" //  &
           "042743512317431335223585983763945149600366863053831443772337083310" //  &
           "55022604714614305141359222385085339434173650339778299984225419876751487M-11"
      call fmst2m(st, c(22), qx)
      st = " 3.544275868854612440207935801227503918837302795864246972321724495" //  &
           "355468544848206832825003613889968600093960257823513222253360353453" //  &
           "05713971042571842928244634878395967156692305652444148244943360077022711M-12"
      call fmst2m(st, c(23), qx)
      st = " 1.181126956967686063705069366011844730919543312398681339013384460" //  &
           "767464082069171562896200433788460949822871886205681867819662919323" //  &
           "00910010651681302654526439685187828766124647111195799560742489176171727M-12"
      call fmst2m(st, c(24), qx)
      st = " 3.936345173849846585066306986288647881678859105474359687899712967" //  &
           "448625102584861794056546209745855663655522551206324259480980022982" //  &
           "48196521666063662466312955017462793017857218058858813422030279362129550M-13"
      call fmst2m(st, c(25), qx)
      st = " 1.311929116013669810041706041194547190318825658299932395783521476" //  &
           "062715708679008371003135237649339518303948243863280796328717056928" //  &
           "61088933385870034244218462559681704119429612455202721574336572434693909M-13"
      call fmst2m(st, c(26), qx)
      st = " 4.372632654299231920401840242323289305929581151976933470616960496" //  &
           "030436497373880193006652887239443630902623173458012149767003641260" //  &
           "91381234213835299457171231108226264358946266150962591099913744278927353M-14"
      call fmst2m(st, c(27), qx)
      st = " 1.457428209197515390994541694806166533046920066577489380555809169" //  &
           "326581787738147452100480717196733318418099673508724121255442697420" //  &
           "79428502647711159673409529291257489352915130912350484504348941167745402M-14"
      call fmst2m(st, c(28), qx)
      st = " 4.857804189667246764735021219813567955136816185008613360441960672" //  &
           "940496363503624604027929086312123388047291007867151509866153218472" //  &
           "06384966879455254262531778810269062220190874499923455125800419069661498M-15"
      call fmst2m(st, c(29), qx)
      st = " 1.619195639149486423325122007106269185336947307372971693371175669" //  &
           "889809582649582191406670950947339285199094038180244016830476463936" //  &
           "02101458401269222147875016156102854033684337727151883392617646517180429M-15"
      call fmst2m(st, c(30), qx)
      st = " 5.397137809202938955975940495024829822845303110776022583879121893" //  &
           "921705867907147218379583534840013350252782358738567325002357267738" //  &
           "61010468743185749436896970436317859962951219444890985968097249049622718M-16"
      call fmst2m(st, c(31), qx)
      st = " 1.799000703833061723835456309516522471727635932565177399470291246" //  &
           "245675486739349743760088108709128457742138295133686476564611083127" //  &
           "88305692939487359678233270751804270008374154159339121093086571227836484M-16"
      call fmst2m(st, c(32), qx)
      st = " 5.996555960166587435989106305417312260461721595507168812416307139" //  &
           "617920826596045537450588005370606978697110903751234286759364296538" //  &
           "88342574088876310757201262943137995532500249048583561327234609512080698M-17"
      call fmst2m(st, c(33), qx)
      st = " 1.998823729325601300227884046410698198743303225621025482564048890" //  &
           "140820433856911724428946203004508501377274799484714026521360076321" //  &
           "81570423267997358911300788282146663959893146975667195154844645417775406M-17"
      call fmst2m(st, c(34), qx)
      st = " 6.662675132429289007245318420983808894124038069139542218571745865" //  &
           "030220152998942329578185363084791339999779092891491916899149034423" //  &
           "33275083724236395937279776479045434110852072326963373822046800189057081M-18"
      call fmst2m(st, c(35), qx)
      st = " 2.220874055111200556512338059264850925555466107705796942638438370" //  &
           "439334710114183793262340326636387034843865608526952566379170604706" //  &
           "27391000045814717730873567070447343919893162122347939701787863570280570M-18"
      call fmst2m(st, c(36), qx)
      st = " 7.402869382385770801058732735126460283848974699479515940427142498" //  &
           "169090369970169606837637347292197915595099714959178372809210169004" //  &
           "97096397918083614643468550094209927318490673314894967308013075647465808M-19"
      call fmst2m(st, c(37), qx)
      st = " 2.467612094717547539757300850305893096186640705352512533565093161" //  &
           "524071499801682896819052946685011871151619653049568921247943861305" //  &
           "74027835796362386640519365699573759086773066188473623555158872217826510M-19"
      call fmst2m(st, c(38), qx)
      st = " 8.225346069033827277619490875386000099087882850547971011202536869" //  &
           "560710353060722052873313849027274314019902150470472049910634941015" //  &
           "65431604021316042692200940962539817779136949003756418974351775701389418M-20"
      call fmst2m(st, c(39), qx)
      st = " 2.741775128372239167169885703390452991143862808123403590500260252" //  &
           "686098892049313322445848356272884233074331136306076265803163875838" //  &
           "39997245835097889674208425702496742768010046284312175596063967715214956M-20"
      call fmst2m(st, c(40), qx)
      st = " 9.139233192043922392172869121382982198915872580533647882222959712" //  &
           "340271164148043740483814963159921847750954087090085242066261297172" //  &
           "38743378565324605175470969019495974103495135080039518080872470260574797M-21"
      call fmst2m(st, c(41), qx)
      st = " 3.046406755195530600990090643743590284251799899012276309359112089" //  &
           "108511649715687692732843107149352212491463042497645778261917818921" //  &
           "00104801732363345270093806101054860184893098558607015592900408049840396M-21"
      call fmst2m(st, c(42), qx)
      st = " 1.015467841223081888268990685530571588993883516806444440463590063" //  &
           "919246457993838714361388326407974316725799445869567226317393205847" //  &
           "41823934922206879509013719077372316295552261963694116207153809783055715M-21"
      call fmst2m(st, c(43), qx)
      st = " 3.384890111197057663463016207436882653098338276290627817566949828" //  &
           "395298842402236802648447435554701889903014892066703092691102459316" //  &
           "42305364341869125221913232186873905776329877020426296097438946487577807M-22"
      call fmst2m(st, c(44), qx)
      st = " 1.128296030524118217901770376786986056339519574517002442090074882" //  &
           "057280000658483297467423203305781809303690428354763800658686040236" //  &
           "71779144955091790824204211870513439500061673502868286865350206893118470M-22"
      call fmst2m(st, c(45), qx)
      st = " 3.760985085416611180417555002274204359368768836382888775095377932" //  &
           "135470299750400345139854657192126020629674958772171673259844584632" //  &
           "29740983608860531344547744626628209787912508838546108351215194899892193M-23"
      call fmst2m(st, c(46), qx)
      st = " 1.253661274394284819616871799214565550306261501251793404757960132" //  &
           "128170781722119090896566129331363704599359253979761928823159537461" //  &
           "94504254386899126662346756986738717779547048333427719023221981595254954M-23"
      call fmst2m(st, c(47), qx)
      st = " 4.178869862795538345454967070155508575326951978759241233273121057" //  &
           "066301381631679857138532781845567887396083218733585140280524330791" //  &
           "93670559242093402244963076978237398106292624308475677695772071716993274M-24"
      call fmst2m(st, c(48), qx)
      st = " 1.392956357970703804166482382560887146464466644976989900838409857" //  &
           "521105907861179378438919270011579646317439048476258541449951226731" //  &
           "38419505723140506483598868257584439349831369024815848605796104120125198M-24"
      call fmst2m(st, c(49), qx)
      st = " 4.643187202503244267904840086459603070244180285978311534148487451" //  &
           "448533368113912140098658002328251742282983537128133995397515041612" //  &
           "48378614922938242264999090255128209599611777303756393485557336865892384M-25"
      call fmst2m(st, c(50), qx)
      st = " 1.547728903152056758023013339236654329438934392366540425603322082" //  &
           "857263082844161081125623346144761860535134488231475517768722978006" //  &
           "97598742236912925627747252856046998990338903727397536889459369962969529M-25"
      call fmst2m(st, c(51), qx)
      st = " 5.159095932969129018305623899832229004426259340923333088824701344" //  &
           "793799573384328764667708388371262541343393211413511112875917018796" //  &
           "26630534722311094084888639746029822030436534231881230203368649013498048M-26"
      call fmst2m(st, c(52), qx)
      st = " 1.719698541605578250055328719172355061652680958536807515991957911" //  &
           "829231225440009541518975734286993664349423799759754184346111779848" //  &
           "98079517451175822251033508127845088987176652373067048423597073312187144M-26"
      call fmst2m(st, c(53), qx)
      st = " 5.732328215225532836270189877348903743690272187963364883413404892" //  &
           "515967840972047550982297271962784377794755127033081531768642894199" //  &
           "64735397060888178165089361563869938931990240827823701959473704067979558M-27"
      call fmst2m(st, c(54), qx)
      st = " 1.910776007543699055364968001468624686158867348024934230266622903" //  &
           "018662755804722736204383531033467520086936412589269186167968820789" //  &
           "31707316415310370070101583553225900248595006769483528789991489268005919M-27"
      call fmst2m(st, c(55), qx)
      st = " 6.369253197983874006821823217108741793471311336545161803572473280" //  &
           "581604669538018391744708133203440680673579856484395859330652484509" //  &
           "72888929728309163536568371996260645727875086529584444740409818707168597M-28"
      call fmst2m(st, c(56), qx)
      st = " 2.123084359204225333255211453879706270058062440003428132183384754" //  &
           "529220299115266894193502387449244415133870841331224790006731846829" //  &
           "83950869831354206398680371015186352923965072680137000319344572605758909M-28"
      call fmst2m(st, c(57), qx)
      st = " 7.076947763704848854568916919680447890729663289024670563717349289" //  &
           "716854593909643699182828273092172522117888394772977756940206908939" //  &
           "88161833503128621124125052157189818939182888192518392960394844544910580M-29"
      call fmst2m(st, c(58), qx)
      st = " 2.358982562824326603834177965008914574063289371087237954036406546" //  &
           "340493525463133458597261132503854782619333331885562197138535071408" //  &
           "23201579847913351266307691059142085404786612749993269600147335936631424M-29"
      call fmst2m(st, c(59), qx)
      st = " 7.863275146721236242647451555165511648580559926859636607085030645" //  &
           "828570768337179488776594015720853254496569344629950772241890794413" //  &
           "09501208585846001333592788550065884722420498762308117260230188148248777M-30"
      call fmst2m(st, c(60), qx)
      st = " 2.621091699900456658110115330583854052361897297784388638216583319" //  &
           "454384526174907954107229789803487469826658513137203063896172131706" //  &
           "68596675776534544455338620395186907938046711829117294010990223395191200M-30"
      call fmst2m(st, c(61), qx)
      st = " 8.736972293818315676196547510693128031654563870400207411221472197" //  &
           "802537238798558154077761157016481387194295979174198832797107057716" //  &
           "55476119097180397397991205334340641881095558538017176052985551441032265M-31"
      call fmst2m(st, c(62), qx)
      st = " 2.912324088143640003892515793451613942403905838900460353749079195" //  &
           "711293166403329382629400828420996934679831800044190489170302330372" //  &
           "89702647828398182289986576193569329546458981411599932131292250327217139M-31"
      call fmst2m(st, c(63), qx)
      st = " 9.707746935989309774922153324275043050136559616419228148856384390" //  &
           "891207031590122433573161121435856761535255587985039419083521928281" //  &
           "47684192432450134453307134064460958883080711047615861323976659104916668M-32"
      call fmst2m(st, c(64), qx)
      st = " 3.235915639207398595265693615961166003757636977735808496558273648" //  &
           "928958056872747435108942393361659134982792854945130370217146958406" //  &
           "96083858500218202729498941860260710013473689957089195606216847161948489M-32"
      call fmst2m(st, c(65), qx)
      st = " 1.078638544871873611955050957012575767956166828939502396913361632" //  &
           "134006203107387187862076294858437749004255229312668679921800233056" //  &
           "74417612290238598612397811829199658493331617719065112441605814593748378M-32"
      call fmst2m(st, c(66), qx)
      st = " 3.595461812413097732268985825592100369404790978561873060558407383" //  &
           "209843595084925537819419221457817216101556873881028197503043710989" //  &
           "71993446117511506289219252721788791857419650690058381970466123873747686M-33"
      call fmst2m(st, c(67), qx)
      st = " 1.198487269847745765578016200858552396971801017866213814921147936" //  &
           "194342329888616529805943628521815471009477410250705796740507122991" //  &
           "05724055220198767971701073860808057115160815984757015916251499607980512M-33"
      call fmst2m(st, c(68), qx)
      st = " 3.994957563767602385747901769948142409291248613545961370363883891" //  &
           "289691397311922302379137927297721501329041681797620724073370767562" //  &
           "18203408450216245071443700831249773241142322486002435752961943222542254M-34"
      call fmst2m(st, c(69), qx)
      st = " 1.331652520657979959724598554013660845601546719077233063789633368" //  &
           "960435001352641490522946960948433409671303505299895763210435682642" //  &
           "64618257123231948431647534610234863412519330901304158646595801812800221M-34"
      call fmst2m(st, c(70), qx)
      st = " 4.438841734031881188976818132822337642864369008251133361954967150" //  &
           "427526248489023180060951578854782817826656197035293616050385245228" //  &
           "69777224342488088789975020608283234140930896389710286843599614310829011M-35"
      call fmst2m(st, c(71), qx)
      st = " 1.479613910970280742873945057507129611414800958022743884631361380" //  &
           "691798159539547487537052914060034185767422767130178282321602757860" //  &
           "83348663879834983529553026971940768027904120497673742153199914849116728M-35"
      call fmst2m(st, c(72), qx)
      st = " 4.932046368966736707433238163653472803158736679721922230398981807" //  &
           "148509857901058886361798749120231700519606437174141329665127637580" //  &
           "60684029229789780624847253236488984529122857484143590545454988280087620M-36"
      call fmst2m(st, c(73), qx)
      st = " 1.644015456088695799904278450146142178669043440878937685558456872" //  &
           "964025555598274081805412440896705440428517289000442501284221387694" //  &
           "55648732942491166386921283069386388704660866255758554699458240090291278M-36"
      call fmst2m(st, c(74), qx)
      st = " 5.480051519711778255840272708324976030739754268948537269674402054" //  &
           "568534364217773209485346648013194520472068667682265478950114643548" //  &
           "57817502762576875030228023959898997369951420244275748984693326649040707M-37"
      call fmst2m(st, c(75), qx)
      st = " 1.826683839757957485171861873006044105081660879173944661934615164" //  &
           "058228248983434414103054534197242809510738787922754612090096010008" //  &
           "32972234391112427466530639806131521397347115826207673334357276487387067M-37"
      call fmst2m(st, c(76), qx)
      st = " 6.088946132161603455339501324095998745526413263096303935940878780" //  &
           "526359496483279209617877435619263014735196336319313697924877016533" //  &
           "09653632325766553783756318556864993407257715531353455924785891667301524M-38"
      call fmst2m(st, c(77), qx)
      st = " 2.029648710629304112312264073466486255977035674544143740902384580" //  &
           "066925825480897303013099124850654602496048781418796500497911435814" //  &
           "55895496319542786203501573229289360635504754435873888697991558050538067M-38"
      call fmst2m(st, c(78), qx)
      st = " 6.765495701869604444386835156000328903984913424070294867383326826" //  &
           "380125179490385914541280070377395224806865489400873522529357739540" //  &
           "13593097642976584317974244356761507356447028338622758884083690956549688M-39"
      call fmst2m(st, c(79), qx)
      st = " 2.255165233899515832701742852677093869944624882375775392021565853" //  &
           "727820148309140426329940190201858812882180125645736863330093959501" //  &
           "39799185623421035440349003272811535983000708934970150324591131369976675M-39"
      call fmst2m(st, c(80), qx)
      st = " 7.517217446189171987910422000959627404182160006415193289405563037" //  &
           "073141918979212912887404738051712797448922513382013488736054976966" //  &
           "44850928549751713769786767895881754130344984097285305963557272547145616M-40"
      call fmst2m(st, c(81), qx)
      st = " 2.505739148694087132524150695488551963220019249166337393102845297" //  &
           "929187685834976527612995960496060104814687111155509389611886823768" //  &
           "45665657833105762416203034605047428562380070279581109059970215759343049M-40"
      call fmst2m(st, c(82), qx)
      st = " 8.352463828891198283454574490687921776166017804023933180339411723" //  &
           "551630949077812713723188475201183251308083861018090692334062700224" //  &
           "19315941542359676555596601655478811403243506810721773017251413934374514M-41"
      call fmst2m(st, c(83), qx)
      st = " 2.784154609608126388309518953024776333056303224324599419154596270" //  &
           "687189694467353799519873714017939494084666475975688987152456659642" //  &
           "26654762776582515405508388836892873507912509482458807279902034848895589M-41"
      call fmst2m(st, c(84), qx)
      st = " 9.280515365304738695722333964470955476404932927589213406274394075" //  &
           "824251507915677707145886824360137294712999378365268640074244947377" //  &
           "75283581062718625871709431187118953937401911092491908328625126927814924M-42"
      call fmst2m(st, c(85), qx)
      st = " 3.093505121754325582272552779234873274821484670440649874514125833" //  &
           "450221430848146677414227286193944601969620041844899866725992046638" //  &
           "96302520509550456127533362858925937984066799183063861137995551939093475M-42"
      call fmst2m(st, c(86), qx)
      st = " 1.031168373914628365020619376010732175534509522276934226759611010" //  &
           "510330113936747333958108874337789248731979567783939919999577683507" //  &
           "22523295728071715108784714082583918137083993400414421602035476389181042M-42"
      call fmst2m(st, c(87), qx)
      st = " 3.437227913040060810736801880470831506837625258770689684886108518" //  &
           "300849420221764767894609466818173933155866849989575822424072255004" //  &
           "78234006087579117395941989824600255765731792341982892120664183263431722M-43"
      call fmst2m(st, c(88), qx)
      st = " 1.145742637677845168748014850793946505879656739125856631649586463" //  &
           "591822853689599347930344326959430427527959142809100423533805439264" //  &
           "43279388738637495289806414123857142554621616733197424850302473869617722M-43"
      call fmst2m(st, c(89), qx)
      st = " 3.819142125587379475420211530141217153875049185525247582904249203" //  &
           "019903748875977266231256469090038860233530356197288111009590135316" //  &
           "90898695851949084954771545562975566659699180249151895098720201541444897M-44"
      call fmst2m(st, c(90), qx)
      st = " 1.273047375194433720039269643742156618287252568559809316454558670" //  &
           "180525454213261685018950248687574295353166212229651718103175620816" //  &
           "43760967542155803486826726482394407727128624904626495857158860946505910M-44"
      call fmst2m(st, c(91), qx)
      st = " 4.243491250644713804047213900311521631782151086428302312117409417" //  &
           "778324805156532130172471108085960753421387148016192082165090341252" //  &
           "19545466280371097678329835612276755167203138210639186157532227100590980M-45"
      call fmst2m(st, c(92), qx)
      st = " 1.414497083547388285661813522776106834139405615052171085969597516" //  &
           "047278841879024411976249475067654110853871648213868458414159189231" //  &
           "79891226179605118296023118379963942164595272691469246552143553753880550M-45"
      call fmst2m(st, c(93), qx)
      st = " 4.714990278489170162988560867348152304757403878210496541497712053" //  &
           "006454958803147191193828617164924983154190125072717651655296406044" //  &
           "51236582999806300249260089437863523751237893569424876357019027689437850M-46"
      call fmst2m(st, c(94), qx)
      st = " 1.571663426162525690358614617253775521309331567276009924639764177" //  &
           "358960165102899050236124157794756906336803102013665429067943394214" //  &
           "57838273206825762014705848617755003448485196508751247061517100802618351M-46"
      call fmst2m(st, c(95), qx)
      st = " 5.238878087207091391268381971748475496510636983623239581337201528" //  &
           "761219196441713174722639342282806574120757748535810991181068549199" //  &
           "89053413431795493494028007267927630087829683052755847961739807896841957M-47"
      call fmst2m(st, c(96), qx)
      st = " 1.746292695735365236274430121252895780353566878171851946466982282" //  &
           "916481274302755866597786442055146506112819565744487880483609437125" //  &
           "77321479855945945213560009077900564250744371125376843314616795699839063M-47"
      call fmst2m(st, c(97), qx)
      st = " 5.820975652450387718877296368406106766373716711813705919181086521" //  &
           "999505975590854145900097731105648953941956782748776332821329494966" //  &
           "87768367928768066507060035439222042970126325626238817880646490785855621M-48"
      call fmst2m(st, c(98), qx)
      st = " 1.940325217483255139116418908036918257576300407306275798031334364" //  &
           "409601786683742364221787811915022144162851994955921858529462196970" //  &
           "10653973717672741870614055497821682510355774493997650251816154517127732M-48"
      call fmst2m(st, c(99), qx)
      st = " 6.467750724943665212448072244898217344228281509203436692886144544" //  &
           "710488376123702904475209151820097662127258578415899891069730495416" //  &
           "37336243969682934496722083054141458419645859035208215900305459742433866M-49"
      call fmst2m(st, c(100), qx)
      st = " 2.155916908314425424664368170497409014232503939749568528677540140" //  &
           "384039734094541956602791846039169318650021459160866243512075243331" //  &
           "45679505658773347404938241005432513933656138666470399349344701169458177M-49"
      call fmst2m(st, c(101), qx)
      st = " 7.186389694381093966835437692494728822349002314959532010292364775" //  &
           "394946247059389433028322727013522877670270796020110428790305813054" //  &
           "79391776953852548570365845653848831536967043669276608555999675341559488M-50"
      call fmst2m(st, c(102), qx)
      st = " 2.395463231460283626767035225609077295862357711256733986014148707" //  &
           "753272199463531514035780844426290282772850231675309468999618270293" //  &
           "06226615257093166993337223904134396989045750924820301622864539591983840M-50"
      call fmst2m(st, c(103), qx)
      st = " 7.984877438200742850444847499777309845694641795079466763347310518" //  &
           "973477267679513036692556925499430697000376845097566527468301532263" //  &
           "68593074139587048157403440914703927108798266764367635240248126118737063M-51"
      call fmst2m(st, c(104), qx)
      st = " 2.661625812733530307120299705689856310419430305299514816454219978" //  &
           "167720121577781636596013737099879504260242494410428404547299997096" //  &
           "29214426445076866714408263418452627026007712187686306994919339537176315M-51"
      call fmst2m(st, c(105), qx)
      st = " 8.872086042444974416164378071031044765486837933978062891736690757" //  &
           "063302976670153482438120949026393088923322321063932750682909484640" //  &
           "80118939886335367290880449750827102760828907286267653373299382121005954M-52"
      call fmst2m(st, c(106), qx)
      st = " 2.957362014148293153495637994224156508433858704035708219961848704" //  &
           "752814743630032704058576844386754167614614033997051904620347311738" //  &
           "61904345412997662020042929619746892567448362596680832152684925750243880M-52"
      call fmst2m(st, c(107), qx)
      st = " 9.857873380494231381920907655510228783611078844545021454399920772" //  &
           "141062619227406263790226964711069068688447840761328895136653289698" //  &
           "66981214088475384265075552305006338119605469313298818722398857563732976M-53"
      call fmst2m(st, c(108), qx)
      st = " 3.285957793498057344874164686873206738067743142840216191903487618" //  &
           "019941680979531742712197349882728018267551869210987929616034749064" //  &
           "30303538626114994902987549690732156800575304242342439460223044767290112M-53"
      call fmst2m(st, c(109), qx)
      st = " 1.095319264499347502683187139319325563979656486096742174653628128" //  &
           "976581637422575945930267442158932925061363256302618217044235776727" //  &
           "78289678865564842523041070219617158649346807209669750276034200426122137M-53"
      call fmst2m(st, c(110), qx)
      st = " 3.651064214997812644923454493506674835323388056021714399807493703" //  &
           "605967302048397979154313095594794645711111183057404193592791956678" //  &
           "66172552061879738476243285533776439739119193738969145723129786576511450M-54"
      call fmst2m(st, c(111), qx)
      st = " 1.217021404999267790636025855753778604335807084870166221152973014" //  &
           "506916159759972779875308117306931009803008009678064932776645093318" //  &
           "00842098229392080507684746488956996056988713932200497206909259105378943M-54"
      call fmst2m(st, c(112), qx)
      st = " 4.056738016664218241273938781923458650417321982457636718798922936" //  &
           "477302304740685369168107498238001936713766023175775737524892409160" //  &
           "01634272341340971077361157145530586562647498591786411480985240150120553M-55"
      call fmst2m(st, c(113), qx)
      st = " 1.352246005554737481879776083250264536787105289190169898749791140" //  &
           "348233188200740056915744202769004512689087720776827335229272164151" //  &
           "84364840446652924162659286494044457495071328336364564380197269062778195M-55"
      call fmst2m(st, c(114), qx)
      st = " 4.507486685182453443237078181203119239131669164992680684219261837" //  &
           "277644454396847551795676165306867658683702735066801164086167252711" //  &
           "19484010084871947031012001315393818015815520382515662702573278448350109M-56"
      call fmst2m(st, c(115), qx)
      st = " 1.502495561727483273655148872429157437910868921767186291387141573" //  &
           "512573119402964065902228084442655668385002115354783777594857713998" //  &
           "29523050153288241379342972449409357035473017504499197092941874010814147M-56"
      call fmst2m(st, c(116), qx)
      st = " 5.008318539091607893624136610372602345176507591543467689236137943" //  &
           "884673550591046086592830872513439140608629637038740043915787148541" //  &
           "52394870950686380101306680838055095132070888200259040353691065606620624M-57"
      call fmst2m(st, c(117), qx)
      st = " 1.669439513030535209901455630134076834170615280098683744729402670" //  &
           "296396657337808597037921736436660468249832659227172779367140247404" //  &
           "03362990043020714217884143429674645399729964793508983794394882884002423M-57"
      call fmst2m(st, c(118), qx)
      st = " 5.564798376768448813071710669353659573416270465590122350543315121" //  &
           "413388656111319238743752535035180158976403027283093627581775200347" //  &
           "08950549480561185545001882864566882001602568174009919346046996759045750M-58"
      call fmst2m(st, c(119), qx)
      st = " 1.854932792256149132707284865787646721627824417634136205769228907" //  &
           "351320889807301200265876310886504825399338639660085162561571671143" //  &
           "80178781198866361165024767169800779385647991333075996890986127709064413M-58"
      call fmst2m(st, c(120), qx)
      st = " 6.183109307520495929899402826852708229420151109621107470264900121" //  &
           "134345986789710812316854495785567736467232785746686941727193331941" //  &
           "56103871513252933011548432169303614875570158457053586066135942237566488M-59"
      call fmst2m(st, c(121), qx)
      st = " 2.061036435840165015185247594351604598673466050924812223481238383" //  &
           "744650549307488207514436927186243454249400309582767262472952477865" //  &
           "39488089477469737100729325446476505038057243548633416390135776998909246M-59"
      call fmst2m(st, c(122), qx)
      st = " 6.870121452800549313664441945028230766782586053733765495536930184" //  &
           "148735432170307184364193773249356218482192867580453706078982702322" //  &
           "36906147589341063176294087284637487815185909131173012735635871205970777M-60"
      call fmst2m(st, c(123), qx)
      st = " 2.290040484266849586983218139377689608197401631939278155837315152" //  &
           "749176998379162942186288612171254733497127165504629660957484257215" //  &
           "03960145633908464981886082313132803826782445898913850664341670496286810M-60"
      call fmst2m(st, c(124), qx)
      st = " 7.633468280889498162681737525654781395094610920374961079941892134" //  &
           "693686042107521045090976432509818240749828811152884417434183792443" //  &
           "40208045334338980097933050903816256868615301460865703415771912193724986M-61"
      call fmst2m(st, c(125), qx)
      st = " 2.544489426963165939078331773845571337558244149440634270398446661" //  &
           "730902552806699411443989280898922405978534154707887233634737588764" //  &
           "69277444899419995451128654151512085551424867809084295696469106990521519M-61"
      call fmst2m(st, c(126), qx)
      st = " 8.481631423210552842388820742776895367676872160158770358942482422" //  &
           "735183525513672190915958631633045631581296672220414159119266677730" //  &
           "00882790484855601476924199497856972658319507003728226425960873810966916M-62"
      call fmst2m(st, c(127), qx)
      st = " 2.827210474403517542161535621759888928745745898925998679999176972" //  &
           "500449767039313885942472306882332999282623012200216004408023722942" //  &
           "35548228163002484117039136830425719490113419540684925428659006215127579M-62"
      call fmst2m(st, c(128), qx)
      st = " 9.424034914678391627284940507974624769084040519392748443016620129" //  &
           "151493273032159506798645125157903918497199981418255987213825116544" //  &
           "91313520782402912277192097971388451766192404480480266469096595803740649M-63"
      call fmst2m(st, c(129), qx)
      st = " 3.141344971559463830781602278189827439570491126580879213267566098" //  &
           "634582653573961371388430476987677106802274861280003439184958337497" //  &
           "55871137194361985101053142410164165629409400589300651854575488722127625M-63"
      call fmst2m(st, c(130), qx)
      st = " 1.047114990519821265682189619947088028639202210810159318824710297" //  &
           "418144878455534152843738752328520535580617712220747998447348456148" //  &
           "87128390653434870273058245640426383654361423379776610643883264096972007M-63"
      call fmst2m(st, c(131), qx)
      st = " 3.490383301732737524161437551201638806706639111674055435356822668" //  &
           "242340068122359401431212212101510842260288841134358619348306937471" //  &
           "32292385947826289933592114188205257470612591292887863954967567373067619M-64"
      call fmst2m(st, c(132), qx)
      st = " 1.163461100577579167692347221578745581156399690416630219259420060" //  &
           "140471624651128200456995286998175955667309375958539555927592191244" //  &
           "69108542176232753118949875989033621399852815112398485508138602381100101M-64"
      call fmst2m(st, c(133), qx)
      st = " 3.878203668591930541404160833208709487069318555519787588536748926" //  &
           "079489227092349654317217820179356059640911818309293644987827038914" //  &
           "23113705652681321350172045452704473329699236304435049788227394174622197M-65"
      call fmst2m(st, c(134), qx)
      st = " 1.292734556197310176075471134722937741048543949863716607618949311" //  &
           "134596575499614268058353886586544618677755951138400973297684683800" //  &
           "49929217081801053935564115665217627139106390261578300958135297518693689M-65"
      call fmst2m(st, c(135), qx)
      st = " 4.309115187324367242603447591543502614635432074915146455974961100" //  &
           "783991800140039817841446475586229840527592677387439828807409996406" //  &
           "58572000140795436674747033557343891137764503605700790270107002153194098M-66"
      call fmst2m(st, c(136), qx)
      st = " 1.436371729108122411455785149464652955014483913555925454567566343" //  &
           "033751539926464502402671954114290440329353433043868042553216356430" //  &
           "95760927792248401840769385171665086466412488627981015154342470344616262M-66"
      call fmst2m(st, c(137), qx)
      st = " 4.787905763693741364655873712257673345968093702500400380413759009" //  &
           "343709671855218190105116076110599847270179980048633459127967075496" //  &
           "95329570740860986232312515609865359747150038120760918167660196395395859M-67"
      call fmst2m(st, c(138), qx)
      st = " 1.595968587897913786502772040929797311513936155534630802777161042" //  &
           "323085710283013809416229252137018873920387828320283701537288724338" //  &
           "18222527779868222288064331588809401461453186408435455724607829956650895M-67"
      call fmst2m(st, c(139), qx)
      st = " 5.319895292993045950719608811875781719400488218015940339624963833" //  &
           "904468790238424394665705538673163852924018058746539220799914498871" //  &
           "87123883979205073632821149986880853121193839902134978166092188353175974M-68"
      call fmst2m(st, c(140), qx)
      st = " 1.773298430997681982500795106152343395146291244985375992301024831" //  &
           "172880492620523208419431056495256021417076918908947764372774801634" //  &
           "66308162036559401365955897830840212263006984532789801526556111330540563M-68"
      call fmst2m(st, c(141), qx)
      st = " 5.910994769992273272321630775993113357374306776150164446878995429" //  &
           "199988365546454090281139320572057370171863201292260358152263114701" //  &
           "84849003352679924628129743645300899848128310062948455843231411729916686M-69"
      call fmst2m(st, c(142), qx)
      st = " 1.970331589997424423436955364217490328008758498727308342596972914" //  &
           "838317948717210312982993577885955575234727205227508863543462414701" //  &
           "19790327280248261234206607030131137515730415891713737174983639027604997M-69"
      call fmst2m(st, c(143), qx)
      st = " 6.567771966658081409780880644570952852212869394142774498275969597" //  &
           "051352302027804591436366292098249004955749719212407233759626410804" //  &
           "23094265521905707737671802871297906382006218125926665760693315871567840M-70"
      call fmst2m(st, c(144), qx)
      st = " 2.189257322219360469508050905240435788723932139126639198455650265" //  &
           "181880562634665346793855787464756222043343074562742957750457331886" //  &
           "51136835170527293161085727720893207671856322049649329515124067695351675M-70"
      call fmst2m(st, c(145), qx)
      st = " 7.297524407397868230646229744835872327874966073160276767231213689" //  &
           "623218792935837978230418401268856718201925396539510384196175753170" //  &
           "66652198429614667985969715027449338257278758408128943199367755324652975M-71"
      call fmst2m(st, c(146), qx)
      st = " 2.432508135799289409953591617661733991864335564333111377209692880" //  &
           "074976374750213242253051652321561734041852268969020358465621089424" //  &
           "14424996317706067303976880419998421002358404179645130678096779653358570M-71"
      call fmst2m(st, c(147), qx)
      st = " 8.108360452664298032524092931381732192579715420011362584102530122" //  &
           "399082594247638810857284958385615023239610775424662458807879174869" //  &
           "99208578767507795046313489342326234225642585624250987626962498888032182M-72"
      call fmst2m(st, c(148), qx)
      st = " 2.702786817554766010677727150378738299179197264006681328494022283" //  &
           "461713062938474709283827967021738008108993688482511856757752986924" //  &
           "83022205593730217582984347916302439090400201412445704126518051302925734M-72"
      call fmst2m(st, c(149), qx)
      st = " 9.009289391849220035183332673115118436689105231658609100131576105" //  &
           "746817524522178460300592879017536531814751063263253522537492214691" //  &
           "66287676119612980647194230638456363682773535596502263016913065096674627M-73"
      call fmst2m(st, c(150), qx)
      st = " 3.003096463949740011625527637203839580670438558448697439316922582" //  &
           "080500699241877972753395936644410394325148621157014967621235051277" //  &
           "19702357955843408402299203602763881244696185804277033716869763248333675M-73"
      call fmst2m(st, c(151), qx)
      st = " 1.001032154649913337182941137354579752756157403350587184082572655" //  &
           "668720365134577993101924383011283318540511319882434333492124758136" //  &
           "56328900549930706700593452010716708224185836746712866383541238461850333M-73"
      call fmst2m(st, c(152), qx)
      st = " 3.336773848833044457211857959630261241457227305512566083673355396" //  &
           "481818433800591390918626541367515865084768432579659244905807486980" //  &
           "29134378942434319177868848768173954755492210535184756504211022367766391M-74"
      call fmst2m(st, c(153), qx)
      st = " 1.112257949611014819054635753320402681213887420341206221531310860" //  &
           "985682956261502881389306545840511198169923612506852778221149565252" //  &
           "81459361368566900183720441504615495296290954141555036222396831117077406M-74"
      call fmst2m(st, c(154), qx)
      st = " 3.707526498703382730161873261392491115828186807291897198915909604" //  &
           "155674067990161834342683376529820781124868349247913942628339699553" //  &
           "19187594923162356418905498458595704597809148916916571510786341062302288M-75"
      call fmst2m(st, c(155), qx)
      st = " 1.235842166234460910044062971858447900664274034201950858925878124" //  &
           "083887957837752863211714821751135044697824600808010987957735653910" //  &
           "85021760966460551881259692413828184054079514253554146831394157759200228M-75"
      call fmst2m(st, c(156), qx)
      st = " 4.119473887448203032928247987246026060335598144698999438082486484" //  &
           "981872504026407021712061503540785866057593612250257886109051123261" //  &
           "20553540800492774307915913243657294990555992068366814198248544293239073M-76"
      call fmst2m(st, c(157), qx)
      st = " 1.373157962482734344300829830088785762819828470154677406792486349" //  &
           "582215434835624433211455183472833063222300779138846503724376654756" //  &
           "97153990917671843512951431419776274311910081550489091472125204982219742M-76"
      call fmst2m(st, c(158), qx)
      st = " 4.577193208275781160871184364111765898905714315410964770181334551" //  &
           "559734462338946414187167832153901075953527960902149729732952392999" //  &
           "05739092117020357910064590291184764747354548289282230511803212990314666M-77"
      call fmst2m(st, c(159), qx)
      st = " 1.525731069425260387008576333292791990843668717239246139931723054" //  &
           "113730949750810518714216058816633073359740920341684018573316882922" //  &
           "19161413294992398162552504179370639600545735768135221710078494678533369M-77"
      call fmst2m(st, c(160), qx)
      st = " 5.085770231417534313032798702697681197383439273915544588375043156" //  &
           "982436257501835267954582765438953697752001176322824202363456833480" //  &
           "84822237757173265524313083452491401792161623828870993995239601500752613M-78"
      call fmst2m(st, c(161), qx)
      st = " 1.695256743805844769784622112797766089615978935755501503220932068" //  &
           "343174291091693715417344263720144349029281513168498097220402832110" //  &
           "79996411923403065677514822313169241774858920814773828257766665033772313M-78"
      call fmst2m(st, c(162), qx)
      st = " 5.650855812686156039255381634430268704055968949073218709347085199" //  &
           "742155287063313738806948673339105867918184157411397848315417982770" //  &
           "28216209989585045629974649193921980908524940232212434747464651403766044M-79"
      call fmst2m(st, c(163), qx)
      st = " 1.883618604228718704942922337070948507896675501998486050379053659" //  &
           "203222058229334282486849245788565645787611354772468558241052640628" //  &
           "68090996198582244338892337657054683701568414292331480633193743238899042M-79"
      call fmst2m(st, c(164), qx)
      st = " 6.278728680762256512149009149976440283047018296660977205232840187" //  &
           "711671745561355189005624289121525977497317264018845068610009630166" //  &
           "24422122072055952477161863795374233113339410369040977100353306447007727M-80"
      call fmst2m(st, c(165), qx)
      st = " 2.092909560254085021920435547839978227290505174219696260063426880" //  &
           "879036670946017746113568504819405540190923727599189799888162522342" //  &
           "82688033004648088111864002916433340227047169032122354503266913856888244M-80"
      call fmst2m(st, c(166), qx)
      st = " 6.976365200849595928568515913272594158672772019779337814697530205" //  &
           "514328112647957246760099455857571687826289491085647676946101437355" //  &
           "54833971648944261391739603826369822509790583940615701556419202194043338M-81"
      call fmst2m(st, c(167), qx)
      st = " 2.325455066949873863606967397576505711197188840184692731505571050" //  &
           "057010126988203224760379663164013876837099897428308506101979830146" //  &
           "10509395537389044680077986544130564059305007513097257902320076380128891M-81"
      call fmst2m(st, c(168), qx)
      st = " 7.751516889786273230333744396009595784689618339833872888076148749" //  &
           "510954270591897268986918218161521302808459344904049745958883339834" //  &
           "97636368620176777364813719377132199681517454923842508307735464876551893M-82"
      call fmst2m(st, c(169), qx)
      st = " 2.583838963261950823751464199102541531987080961128181249653133059" //  &
           "486343391931814427787289188223115323267471180053604447425299309852" //  &
           "43333277896763688823725567334545875021894956285785557169534759498102028M-82"
      call fmst2m(st, c(170), qx)
      st = " 8.612796544966339593464148319279864385495846603731409332903857040" //  &
           "341111578596179250787433586544432993469429659882790724588244062567" //  &
           "78136790746398664694553035857800597304056454220060017665421505719967290M-83"
      call fmst2m(st, c(171), qx)
      st = " 2.870932181657563853682489496869596716118149568767000014172109841" //  &
           "753698478327036128411797178375480340579847035333592372289787795793" //  &
           "96627619330877369349750053557082939116418335842754914658257204585102926M-83"
      call fmst2m(st, c(172), qx)
      st = " 9.569773927459502329189843968932453842109493094807395751883972275" //  &
           "108106634425357758674379648287072224301747951696615265196165041805" //  &
           "20236585969398304163224702023392754793840706634155432621406698219669058M-84"
      call fmst2m(st, c(173), qx)
      st = " 3.189924642457193947274983048068918789864588583187967339730200869" //  &
           "383977309483707594218810831491599791827472770895338811393310795354" //  &
           "69234531929746996008196354596059905584934184315535092321474774208305020M-84"
      call fmst2m(st, c(174), qx)
      st = " 1.063308229833233763649833968823830359312501010885534593366422641" //  &
           "631138341936187529001129656673501820789940104427992740873815715203" //  &
           "53412492554104141309331928436306992144198744553482555692829414468432600M-84"
      call fmst2m(st, c(175), qx)
      st = " 3.544360766480896268661948406666249396818945618937640720661704673" //  &
           "296436347072454208561096669377429691244542539862734276732737789906" //  &
           "87985432036327462359694991859663225608649510569830536167392892074714882M-85"
      call fmst2m(st, c(176), qx)
      st = " 1.181453391991692193233905477505817491959791629667967979777058345" //  &
           "391387128260137859898575835696679473316746285686162580343604354886" //  &
           "33746615556680423641254628884245686047585862162458511355057706178924765M-85"
      call fmst2m(st, c(177), qx)
      st = " 3.938177969065104259816577437558454136986820863927184608342465808" //  &
           "644130213208017150749164656763736226904608349061342579349394401954" //  &
           "11955443745482049001748543874113465084785050139876732361231723529022225M-86"
      call fmst2m(st, c(178), qx)
      st = " 1.312728231460229835781775849221721497298632770454454059027673781" //  &
           "147657857867325372034109920647863595009065024284231880168892910826" //  &
           "53488283009582034319652319525792167583043745345137953029043134270740314M-86"
      call fmst2m(st, c(179), qx)
      st = " 4.375760815315077535413782421712416021566276398233684094737691912" //  &
           "768825492780444215747826165057411744207345952312538488710400858828" //  &
           "27700668026171627589196059317745967100234000846254430975531508363872519M-87"
      call fmst2m(st, c(180), qx)
      st = " 1.458563929048378339389356324275832391447007080182288931684002700" //  &
           "009472184445323295339567304943041273340490012950372985830518037286" //  &
           "27460201464773612755677066535469683435847032008950889605333804095236722M-87"
      call fmst2m(st, c(181), qx)
      st = " 4.861879359454319859107850617575234255777767433683221708284430699" //  &
           "990829575672698923326870227967687183467108336363217071248382357963" //  &
           "22818905179326628057052156616846776700350617514896748728636343647107755M-88"
      call fmst2m(st, c(182), qx)
      st = " 1.620837575639336717669585897558965566795189581102158562505695709" //  &
           "761058058214152430539033470517727442776271455644632399079159816470" //  &
           "13032790990474394168725899077889253682309738675257461400762111892656053M-88"
      call fmst2m(st, c(183), qx)
      st = " 5.402795219201229254205870902900594939962067229843983888917879564" //  &
           "569447106085277432976440651841249190437245953800537313805443864980" //  &
           "06342541344494885255739000367067646594242251182208803771724906930826406M-89"
      call fmst2m(st, c(184), qx)
      st = " 1.799216964519093606731219963783752545188788013842673930468641591" //  &
           "448479933065901726577672674840349510506058583228709079379586399536" //  &
           "92651555915483777543359909186871398885320260440340033124792023837781809M-89"
      call fmst2m(st, c(185), qx)
      st = " 5.997366309057088767075298231986828202847652039333576421385057338" //  &
           "145629178278871106675461140725723229061908016307033578803459780175" //  &
           "07666172639242691690123978056031089958911595034842389306632163036435150M-90"
      call fmst2m(st, c(186), qx)
      st = " 2.011301294926252140726390741032210138299321852132295904710257720" //  &
           "158209117243470457856408196331997445864262615242552875300814542975" //  &
           "47170830674630176097026011113551746496002275896336822879606882224230602M-90"
      call fmst2m(st, c(187), qx)
      st = " 6.704482593621562564692937104577317810644610039525202376129260569" //  &
           "861749723553513086341477081381278126242511169725032335903896422492" //  &
           "18854955408659222455853625926956312559220163444056344847372949727294762M-91"
      call fmst2m(st, c(188), qx)
      st = " 2.160351395289544486253226495324951606774126604957407637555483550" //  &
           "521132050784441566021695109519541771023447038718264653048827134039" //  &
           "73414393141529555898480576201941789130545638907969682039980597723815399M-91"
      call fmst2m(st, c(189), qx)
      st = " 7.200419569439204992397584876133276247439864059745857658513848169" //  &
           "634972230829808411159889094321665351721254003922021586700615812024" //  &
           "99355813646045295572813794504886619128172862586448322114482098387570581M-92"
      call fmst2m(st, c(190), qx)
      st = " 2.784319712626698759566047586489485590648301900234226820496273235" //  &
           "253278946132569789086775657480520424132403062835830911025372468898" //  &
           "94806632232823225075878972837000029411691959653897178979682691313860829M-92"
      call fmst2m(st, c(191), qx)
      st = " 9.284263699802481030477812401350944543556932743559221880685236144" //  &
           "608807942910647790463633201299242608070391986248492383364489375260" //  &
           "66506636257311455988821088223165685964257289358894735278070005979762986M-93"
      call fmst2m(st, c(192), qx)
      st = " 1.469128321729119845643781712942080844517377977136622326900618953" //  &
           "248797751416855621723808444613828590416570423767280724666117572301" //  &
           "34285990191248448522554726873193884488157002183510418398417800853692970M-93"
      call fmst2m(st, c(193), qx)
      st = " 4.886379978539319342120523930953291961277105452075509621364036950" //  &
           "981474984583217822110836621562995692449070713522036826314376565947" //  &
           "22694606242271109407828035720163781683675686187162678102051578537829111M-94"
      call fmst2m(st, c(194), qx)
      st = " 7.046670647920504479063475010556879295393094797174920722994400551" //  &
           "715505897095883223398696557122758497726817737906295249088240133320" //  &
           "85226292447629611992116676332110323776745430326383013890000067486498923M-94"
      call fmst2m(st, c(195), qx)
      st = " 2.351541158501990523752731749555092275030088173405523455954546630" //  &
           "113446321330723773662111826297238234224538212221014494477821368974" //  &
           "29678996883123994564079639022862654561283884722866834645277830050207084M-94"
      call fmst2m(st, c(196), qx)

      qx%ndig = ndsave

      end subroutine fmpsi_c

      subroutine fmpsi_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)

!  Method selection for computing psi(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc
      type(fm_settings) :: qx

      integer :: k, kfl, krflct, krsave, nmethd
      double precision :: x, xe, z
      logical, external :: fmcomp

      retry = .true.

      n_acc = nint(qx%ndig*qx%alogm2)
      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      call fmeq(mxy(1), mxy(11), qx)

!             Near zero Psi(x) is about -1/x.

      call fmovun_xe(mxy(11), xe, qx)
      if (xe < (-qx%ndig-1)) then
          call fmi2m(-1, mxy(3), qx)
          call fmdiv(mxy(3), mxy(11), mresult, qx)
          return
      endif

!             Check for special cases.

      krflct = 0
      call fmdpm(dble(-0.5), mxy(4), qx)
      if (fmcomp(mxy(11), '<=', mxy(4), qx)) then
          krflct = 1
          kfl = 0
          call fmovun_xe(mxy(1), xe, qx)
          if (xe <= ndsave) then
              call fmint(mxy(11), mxy(7), qx)
              if (fmcomp(mxy(11), '==', mxy(7), qx)) kfl = -4
          else
              kfl = -4
          endif
          if (kfl /= 0) then
              call fmunknown(mresult, qx)
              qx%kflag = -4
              retry = .false.
              return
          else
              call fmi2m(1, mxy(3), qx)
              call fmsub_r2(mxy(3), mxy(11), qx)
          endif
      endif

!             Determine which method to use.

!             nmethd = 1 means use the polynomial approximation,
!                    = 2 means use the asymptotic series.

      nmethd = 1
      call fmnint(mxy(11), mxy(2), qx)
      call fmsub(mxy(11), mxy(2), mxy(6), qx)
      call fmm2dp(mxy(6), z, qx)
      z = max(abs(z), 1.0d-50)
      if (qx%kflag /= 0 .or. abs(z) >= 1) then
          nmethd = 2
      else
          if (190*log(z) - 90*qx%dlogtn >= -qx%ndig*qx%dlogmb .or. -190*qx%dlogtn >= -qx%ndig*qx%dlogmb) then
              nmethd = 2
          endif
      endif
      call fmm2dp(mxy(11), x, qx)
      if (qx%kflag /= 0) then
          nmethd = 2
      else if (nmethd == 1) then
          if (x > 35 - 8*log(z) + qx%ndig*qx%dlogmb/(2.5*qx%dlogtn) .or. x > 250) nmethd = 2
      endif

      if (nmethd == 1) then
          call fmpsi_m1(mxy, mresult, ndsave, numtry, retry, n_acc, z, qx)
      else if (nmethd == 2) then
          call fmpsi_m2(mxy, mresult, retry, n_acc, qx)
          qx%numbrn = 0
      endif

!             Use the reflection formula if ma was less than -1/2.

      if (krflct == 1) then

!             Reduce the argument before multiplying by Pi.

          call fmnint(mxy(11), mxy(4), qx)
          call fmsub(mxy(11), mxy(4), mxy(7), qx)
          call fmcancel(mxy(11), mxy(4), mxy(7), k, qx)
          n_acc = n_acc - k
          call fmpi(mxy(9), qx)
          qx%ndigpi = 0
          call fmmpy_r1(mxy(9), mxy(7), qx)
          krsave = qx%krad
          qx%krad = 1
          call fmtan(mxy(9), mxy(2), qx)
          qx%krad = krsave
          call fmpi(mxy(9), qx)
          qx%ndigpi = 0
          call fmdiv_r2(mxy(9), mxy(2), qx)
          call fmadd(mxy(8), mxy(2), mxy(3), qx)
          call fmcancel(mxy(8), mxy(2), mxy(3), k, qx)
          n_acc = n_acc - k
          call fmeq(mxy(3), mresult, qx)
      endif

      return
      end subroutine fmpsi_m

      subroutine fmpsi_m1(mxy, mresult, ndsave, numtry, retry, n_acc, z, qx)

!  Method 1 for computing psi(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(13), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      double precision :: z
      intent (in) :: numtry, ndsave, z
      intent (inout) :: mxy, mresult, retry, n_acc
      type(fm_settings) :: qx

      integer :: j, j2, k, k0, k0b, k1, k1b, k2, kl, lshift, ndsav1, nterm
      integer :: ndig_c
      real (kind(1.0d0)) :: mbase_c
      type(multi) :: mjsums(ljsums), c(0:196)

      ndig_c = 0
      mbase_c = 0

!             Method 1.  Use the polynomial c(0) + c(1)*(x-3) + ... + c(196)*(x-3)**196

      if (mxy(1)%mp(1) > 0 .and. ndsave+qx%ngrd52 < qx%ndig .and. numtry <= 0) call fmndig(ndsave + qx%ngrd52, qx)
      n_acc = nint(qx%ndig*qx%alogm2)
      call fmm2i(mxy(2), lshift, qx)
      lshift = lshift - 3
      if (ndig_c < qx%ndig .or. mbase_c /= qx%mbase) then
          call fmpsi_c(ndig_c, mbase_c, c, qx)
      endif
      j2 = 0.42*log(z) + 7.9
      j2 = max(2, min(j2+mod(j2, 2), ljsums))
      ndsav1 = qx%ndig
      do j = 1, j2
         call fmeq(c(j), mjsums(j), qx)
      enddo
      call fmipwr(mxy(6), j2, mxy(5), qx)
      call fmeq(mxy(5), mxy(7), qx)
      nterm = j2
      kl = 1
      do while (kl == 1)
         if (nterm > j2) call fmcsmpy_r1(mxy(7), mxy(5), qx)
         do j = 1, j2
            nterm = nterm + 1
            call fmeq(mxy(7), mxy(4), qx)
            call fmcsmpy_r1(mxy(4), c(nterm), qx)
            call fmndig(ndsav1, qx)
            call fmcsaddnn_r1(mjsums(j), mxy(4), qx)
            if (qx%kflag /= 0 .or. nterm == 196) then
                kl = 0
                exit
            endif
            call fmndig(max(qx%ngrd22, ndsav1-int(mjsums(j)%mp(2) - mxy(4)%mp(2))), qx)
            call fmndig(min(ndsav1, qx%ndig), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         enddo
      enddo
      qx%kflag = 0
      call fmcsnsums(j2, mjsums, qx)
      call fmndig(ndsav1, qx)
      if (nterm == 196) then
          call fmpsi_m2(mxy, mresult, retry, n_acc, qx)
          qx%numbrn = 0
          return
      endif
      call fmeq(mjsums(j2), mxy(8), qx)
      call fmeq(mxy(6), mxy(3), qx)
      call fmnegate(mxy(3), qx)
      do j = 2, j2
         call fmcsmpy_r1(mxy(8), mxy(3), qx)
         call fmcsadd_r1(mxy(8), mjsums(j2-j+1), qx)
      enddo
      call fmcsmpy_r1(mxy(8), mxy(6), qx)
      call fmadd_r1(mxy(8), c(0), qx)

!             Now Psi of the shifted argument has been computed.  Reverse the shifting.
!             The sum 1/(ma-lshift) + ... + 1/(ma-1) is computed.

!             mxy(11) is z
!             mxy(4) is z**2
!             mxy(5) is 16*z**3
!             mxy(6) is the current four-term numerator
!             mxy(7) is the current four-term denominator
!             mxy(9) is the current sum

      if (lshift < 0) then
          call fmi2m(-1, mxy(4), qx)
          call fmeq(mxy(11), mxy(5), qx)
          if (mxy(8)%mp(1) > 0) then
              call fmeq(mxy(8), mxy(12), qx)
              call fmi2m(0, mxy(13), qx)
          else
              call fmeq(mxy(8), mxy(13), qx)
              call fmi2m(0, mxy(12), qx)
          endif
          do j = 1, -lshift
             call fmcsdiv(mxy(4), mxy(5), mxy(7), qx)
             if (mxy(7)%mp(1) > 0) then
                 call fmadd_r1(mxy(12), mxy(7), qx)
             else
                 call fmadd_r1(mxy(13), mxy(7), qx)
             endif

             call fmcsadd_r1(mxy(8), mxy(7), qx)
             call fmsub_r1(mxy(5), mxy(4), qx)
          enddo
          call fmadd(mxy(12), mxy(13), mxy(8), qx)
          call fmcancel(mxy(12), mxy(13), mxy(8), k, qx)
          n_acc = n_acc - k
      endif
      if (lshift > 0) then
          call fmaddi(mxy(11), -lshift, qx)
          if (mod(lshift, 4) /= 0) then
              call fmi2m(1, mxy(4), qx)
              call fmeq(mxy(11), mxy(5), qx)
              do j = 1, mod(lshift, 4)
                 call fmcsdiv(mxy(4), mxy(5), mxy(7), qx)
                 call fmcsadd_r1(mxy(8), mxy(7), qx)
                 call fmcsadd_r1(mxy(5), mxy(4), qx)
              enddo
              call fmaddi(mxy(11), mod(lshift, 4), qx)
          endif
          lshift = lshift - mod(lshift, 4)
      endif
      if (lshift > 0) then
          call fmsqr(mxy(11), mxy(4), qx)
          call fmmpy(mxy(11), mxy(4), mxy(5), qx)
          call fmsqr(mxy(4), mxy(6), qx)
          call fmcsmpyi(mxy(5), 6, mxy(10), qx)
          call fmcsadd_r1(mxy(6), mxy(10), qx)
          call fmcsmpyi(mxy(4), 11, mxy(10), qx)
          call fmcsadd_r1(mxy(6), mxy(10), qx)
          call fmcsmpyi(mxy(11), 6, mxy(10), qx)
          call fmadd(mxy(6), mxy(10), mxy(7), qx)
          call fmcsmpyi(mxy(5), 4, mxy(6), qx)
          call fmcsmpyi(mxy(4), 18, mxy(10), qx)
          call fmcsadd_r1(mxy(6), mxy(10), qx)
          call fmcsmpyi(mxy(11), 22, mxy(10), qx)
          call fmcsadd_r1(mxy(6), mxy(10), qx)
          call fmi2m(6, mxy(10), qx)
          call fmcsadd_r1(mxy(6), mxy(10), qx)
          call fmcsdiv(mxy(6), mxy(7), mxy(9), qx)
          call fmcsmpyi_r1(mxy(5), 16, qx)
          do k = 4, lshift-4, 4
             call fmcsadd_r1(mxy(7), mxy(5), qx)

             call fmcsmpyi(mxy(4), 48, mxy(10), qx)
             call fmcsadd_r1(mxy(6), mxy(10), qx)

             k2 = 8*(6*k - 3)
             call fmcsmpyi(mxy(4), k2, mxy(10), qx)
             call fmcsadd_r1(mxy(7), mxy(10), qx)

             k1 = 16*(6*k - 3)
             call fmcsmpyi(mxy(11), k1, mxy(10), qx)
             call fmcsadd_r1(mxy(6), mxy(10), qx)

             if (k <= sqrt(real(intmax)/49.0)) then
                 k1 = 8*(6*k*k - 6*k + 7)
                 call fmcsmpyi(mxy(11), k1, mxy(10), qx)
                 call fmcsadd_r1(mxy(7), mxy(10), qx)

                 call fmi2m(k1, mxy(10), qx)
                 call fmcsadd_r1(mxy(6), mxy(10), qx)
             else
                 k1 = 48*k
                 call fmcsmpyi(mxy(11), k1, mxy(10), qx)
                 call fmcsmpyi_r1(mxy(10), k, qx)
                 call fmcsadd_r1(mxy(7), mxy(10), qx)
                 k1b = 8*(-6*k + 7)
                 call fmcsmpyi(mxy(11), k1b, mxy(10), qx)
                 call fmcsadd_r1(mxy(7), mxy(10), qx)

                 call fmi2m(k1, mxy(10), qx)
                 call fmcsmpyi_r1(mxy(10), k, qx)
                 call fmcsadd_r1(mxy(6), mxy(10), qx)
                 call fmi2m(k1b, mxy(10), qx)
                 call fmcsadd_r1(mxy(6), mxy(10), qx)
             endif
             if (k <= (real(intmax)/17.0)**0.3333) then
                 k0 = 8*(2*k - 1)*(k*k - k + 3)
                 call fmi2m(k0, mxy(10), qx)
                 call fmcsadd_r1(mxy(7), mxy(10), qx)
             else if (k <= sqrt(real(intmax)*0.9)) then
                 k0 = 8*(2*k - 1)
                 call fmi2m(k0, mxy(10), qx)
                 k0b = k*k - k + 3
                 call fmcsmpyi_r1(mxy(10), k0b, qx)
                 call fmcsadd_r1(mxy(7), mxy(10), qx)
             else
                 k0 = 8*(2*k - 1)
                 call fmi2m(k0, mxy(10), qx)
                 call fmcsmpyi_r1(mxy(10), k, qx)
                 call fmcsmpyi_r1(mxy(10), k, qx)
                 call fmcsadd_r1(mxy(7), mxy(10), qx)
                 k0b = -k + 3
                 call fmi2m(k0, mxy(10), qx)
                 call fmcsmpyi_r1(mxy(10), k0b, qx)
                 call fmcsadd_r1(mxy(7), mxy(10), qx)
             endif
             call fmcsdiv(mxy(6), mxy(7), mxy(10), qx)
             call fmcsadd_r1(mxy(9), mxy(10), qx)
          enddo
          call fmadd(mxy(8), mxy(9), mxy(3), qx)
          call fmcancel(mxy(8), mxy(9), mxy(3), k, qx)
          n_acc = n_acc - k
          call fmeq(mxy(3), mxy(8), qx)
      endif

      call fmeq(mxy(8), mresult, qx)

      return
      end subroutine fmpsi_m1

      subroutine fmpsi_m2(mxy, mresult, retry, n_acc, qx)

!  Method 2 for computing psi(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mbern(lmbern)
      integer :: ndbern(lmbern)
      type(multi) :: mxy(13), mresult
      logical :: retry
      integer :: n_acc
      intent (inout) :: mxy, mresult, retry, n_acc
      type(fm_settings) :: qx

      integer :: inta, j, j2, k, k0, k0b, k1, k1b, k2, kl, kwrnsv, lshift, ndenom,  &
                 ndig2, ndsav1, nmxdif, nterm
      double precision :: xe
      type(multi) :: mjsums(ljsums)


!             Method 2.  Use the b(2n)/(2n*x**(2n) asymptotic series.
!                        To speed the asymptotic series calculation,
!                        increase the argument by lshift.

      n_acc = nint(qx%ndig*qx%alogm2)
      kwrnsv = qx%kwarn
      qx%kwarn = 0
      call fmm2i(mxy(11), inta, qx)
      qx%kwarn = kwrnsv

      if (qx%kflag == -4) then
          lshift = 0
      else
          lshift = max(0, int(real(qx%ndig)*qx%alogmb/4.46-real(inta)))
      endif
      if (lshift > 0) lshift = 4*(lshift/4 + 1)

      if (lshift /= 0) then
          call fmi2m(lshift, mxy(3), qx)
          call fmadd(mxy(11), mxy(3), mxy(10), qx)
      else
          call fmeq(mxy(11), mxy(10), qx)
      endif

!             Sum the asymptotic series.

      j2 = int(0.3*qx%alogmb + 0.2*sqrt(real(qx%ndig)))
      j2 = max(1, min(ljsums, j2))

!             mxy(11) is z
!             mxy(10) is z + lshift
!             mxy(7) is x**j2 = (1/(z+lshift)**2)**j2
!             mxy(8) is the current power of x
!             mxy(9) is the current term in the sum
!             mjsums is the partial sum

      ndsav1 = qx%ndig
      call fmi2m(1, mxy(8), qx)
      j = -2*j2
      call fmipwr(mxy(10), j, mxy(7), qx)
      call fmovun_xe(mxy(7), xe, qx)
      if (abs(xe) >= qx%mexpab) then
          j2 = 1
          call fmipwr(mxy(10), -2, mxy(7), qx)
      endif
      nterm = 2
      do j = 1, j2
         nterm = 2*j
         call fmbern(nterm, mxy(8), mxy(9), mbern, ndbern, qx)
         if (qx%kflag == -11) then
             call fmunknown(mresult, qx)
             qx%kflag = -4
             retry = .false.
             return
         endif
         ndenom = nterm
         call fmdivi(mxy(9), ndenom, mjsums(j), qx)
      enddo

      ndig2 = qx%ndig
      kl = 1
      do while (kl == 1)
         call fmmpy_r1(mxy(8), mxy(7), qx)
         nmxdif = min(ndsav1, qx%ngrd22)
         do j = 1, j2
            nterm = nterm + 2
            call fmbern(nterm, mxy(8), mxy(9), mbern, ndbern, qx)
            if (qx%kflag == -11) then
                call fmunknown(mresult, qx)
                qx%kflag = -4
                retry = .false.
                return
            endif
            ndenom = nterm
            call fmdivi_r1(mxy(9), ndenom, qx)
            call fmndig(ndsav1, qx)
            call fmadd_r1(mjsums(j), mxy(9), qx)
            nmxdif = max(nmxdif, ndsav1-int(mjsums(j)%mp(2)-mxy(9)%mp(2)))
            call fmndig(ndig2, qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
         enddo
         if (kl == 0) exit
         ndig2 = nmxdif
         call fmndig(ndig2, qx)
      enddo

!             Put the j2 concurrent sums back together.

      call fmndig(ndsav1, qx)
      call fmi2m(1, mxy(7), qx)
      call fmsqr(mxy(10), mxy(9), qx)
      call fmdiv_r2(mxy(7), mxy(9), qx)
      if (j2 > 1) then
          call fmeq(mjsums(j2), mxy(7), qx)
          do j = j2-1, 1, -1
             call fmmpy_r1(mxy(7), mxy(9), qx)
             call fmadd_r1(mxy(7), mjsums(j), qx)
          enddo
          call fmeq(mxy(7), mjsums(1), qx)
      endif

!             Add the log term to the asymptotic series.

!             mxy(8) is the current sum as the log terms are added
!             mxy(9) is now ln(z+lshift)

      call fmmpy(mjsums(1), mxy(9), mxy(8), qx)
      call fmln(mxy(10), mxy(9), qx)
      qx%ndigli = 0
      call fmi2m(1, mxy(4), qx)
      call fmdiv(mxy(4), mxy(10), mxy(5), qx)
      call fmdivi_r1(mxy(5), 2, qx)
      call fmsub(mxy(9), mxy(5), mxy(3), qx)
      call fmcancel(mxy(9), mxy(5), mxy(3), k, qx)
      n_acc = n_acc - k
      call fmeq(mxy(3), mxy(5), qx)
      call fmsub(mxy(5), mxy(8), mxy(3), qx)
      call fmcancel(mxy(5), mxy(8), mxy(3), k, qx)
      n_acc = n_acc - k
      call fmeq(mxy(3), mxy(8), qx)

!             Now Psi of the shifted argument has been computed.  Reverse the shifting.
!             The sum 1/(ma) + ... + 1/(ma+lshift-1) is computed.

!             mxy(11) is z
!             mxy(4) is z**2
!             mxy(5) is 16*z**3
!             mxy(6) is the current four-term numerator
!             mxy(7) is the current four-term denominator
!             mxy(9) is the current sum

      if (lshift > 0) then
          call fmsqr(mxy(11), mxy(4), qx)
          call fmmpy(mxy(11), mxy(4), mxy(5), qx)
          call fmsqr(mxy(4), mxy(6), qx)
          call fmmpyi(mxy(5), 6, mxy(10), qx)
          call fmadd_r1(mxy(6), mxy(10), qx)
          call fmmpyi(mxy(4), 11, mxy(10), qx)
          call fmadd_r1(mxy(6), mxy(10), qx)
          call fmmpyi(mxy(11), 6, mxy(10), qx)
          call fmadd(mxy(6), mxy(10), mxy(7), qx)
          call fmmpyi(mxy(5), 4, mxy(6), qx)
          call fmmpyi(mxy(4), 18, mxy(10), qx)
          call fmadd_r1(mxy(6), mxy(10), qx)
          call fmmpyi(mxy(11), 22, mxy(10), qx)
          call fmadd_r1(mxy(6), mxy(10), qx)
          call fmi2m(6, mxy(10), qx)
          call fmadd_r1(mxy(6), mxy(10), qx)
          call fmdiv(mxy(6), mxy(7), mxy(9), qx)
          call fmmpyi_r1(mxy(5), 16, qx)
          do k = 4, lshift-4, 4
             call fmadd_r1(mxy(7), mxy(5), qx)

             call fmmpyi(mxy(4), 48, mxy(10), qx)
             call fmadd_r1(mxy(6), mxy(10), qx)

             k2 = 8*(6*k - 3)
             call fmmpyi(mxy(4), k2, mxy(10), qx)
             call fmadd_r1(mxy(7), mxy(10), qx)

             k1 = 16*(6*k - 3)
             call fmmpyi(mxy(11), k1, mxy(10), qx)
             call fmadd_r1(mxy(6), mxy(10), qx)

             if (k <= sqrt(real(intmax)/49.0)) then
                 k1 = 8*(6*k*k - 6*k + 7)
                 call fmmpyi(mxy(11), k1, mxy(10), qx)
                 call fmadd_r1(mxy(7), mxy(10), qx)

                 call fmi2m(k1, mxy(10), qx)
                 call fmadd_r1(mxy(6), mxy(10), qx)
             else
                 k1 = 48*k
                 call fmmpyi(mxy(11), k1, mxy(10), qx)
                 call fmmpyi_r1(mxy(10), k, qx)
                 call fmadd_r1(mxy(7), mxy(10), qx)
                 k1b = 8*(-6*k + 7)
                 call fmmpyi(mxy(11), k1b, mxy(10), qx)
                 call fmadd_r1(mxy(7), mxy(10), qx)

                 call fmi2m(k1, mxy(10), qx)
                 call fmmpyi_r1(mxy(10), k, qx)
                 call fmadd_r1(mxy(6), mxy(10), qx)
                 call fmi2m(k1b, mxy(10), qx)
                 call fmadd_r1(mxy(6), mxy(10), qx)
             endif
             if (k <= (real(intmax)/17.0)**0.3333) then
                 k0 = 8*(2*k - 1)*(k*k - k + 3)
                 call fmi2m(k0, mxy(10), qx)
                 call fmadd_r1(mxy(7), mxy(10), qx)
             else if (k <= sqrt(real(intmax)*0.9)) then
                 k0 = 8*(2*k - 1)
                 call fmi2m(k0, mxy(10), qx)
                 k0b = k*k - k + 3
                 call fmmpyi_r1(mxy(10), k0b, qx)
                 call fmadd_r1(mxy(7), mxy(10), qx)
             else
                 k0 = 8*(2*k - 1)
                 call fmi2m(k0, mxy(10), qx)
                 call fmmpyi_r1(mxy(10), k, qx)
                 call fmmpyi_r1(mxy(10), k, qx)
                 call fmadd_r1(mxy(7), mxy(10), qx)
                 k0b = -k + 3
                 call fmi2m(k0, mxy(10), qx)
                 call fmmpyi_r1(mxy(10), k0b, qx)
                 call fmadd_r1(mxy(7), mxy(10), qx)
             endif
             call fmdiv(mxy(6), mxy(7), mxy(10), qx)
             call fmadd_r1(mxy(9), mxy(10), qx)
          enddo
          call fmsub(mxy(8), mxy(9), mxy(3), qx)
          call fmcancel(mxy(8), mxy(9), mxy(3), k, qx)
          n_acc = n_acc - k
          call fmeq(mxy(3), mxy(8), qx)
      endif

      call fmeq(mxy(8), mresult, qx)

      return
      end subroutine fmpsi_m2

      subroutine fmpsi_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = psi(ma).

!  kresult = 1 is returned if a special case gives the value of psi(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j, k, krsave, nds
      double precision :: xe, ye
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMPSI    '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      call fmovun_xe(malocal, xe, qx)
      if (qx%kround /= 1 .and. xe < -ndsave) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          krsave = qx%kround
          qx%kround = 1
          nds = qx%ndig
          call fmndig(qx%ndig + qx%ngrd52, qx)
          call fmequ(malocal, mxy(1), nds, qx%ndig, qx)
          call fmi2m(0, mxy(2), qx)
          call fmsub(mxy(2), mxy(1), mxy(3), qx)
          call fmi2m(1, mxy(2), qx)
          call fmdiv(mxy(2), mxy(3), mxy(4), qx)
          call fmeulr(mxy(6), qx)
          qx%ndgeul = 0
          call fmmpyi(mxy(6), -1, mxy(5), qx)
          call fmovun_xe(mxy(4), xe, qx)
          call fmovun_xe(mxy(5), ye, qx)
          if (xe - ye > ndsave+1 .and. xe < qx%mexpov) then
              call fmequ(mxy(4), mxy(6), qx%ndig, nds, qx)
              call fmequ(mxy(6), mxy(8), nds, qx%ndig, qx)
              call fmsub(mxy(4), mxy(8), mxy(6), qx)
              if (mxy(6)%mp(3) == 0) then
                  call fmequ(mxy(4), mxy(6), qx%ndig, nds, qx)
                  call fmequ(mxy(5), mxy(7), qx%ndig, nds, qx)
                  call fmndig(nds, qx)
                  qx%kround = krsave
                  call fmadd(mxy(6), mxy(7), mresult, qx)
              else
                  qx%kround = krsave
                  call fmequ(mxy(4), mresult, qx%ndig, nds, qx)
              endif
              qx%kflag = 0
              qx%ntrace = j
              qx%kwarn = k
              call fmndig(nds, qx)
              qx%kround = krsave
              kresult = 1
              return
          endif
          qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          call fmndig(nds, qx)
          qx%kround = krsave
      endif

      return
      end subroutine fmpsi_sc

      subroutine fmpwr(ma, mb, mc, qx)

!  mc = ma**mb

!  If mb can be expressed exactly as a one word integer, then fmipwr is used.  This is much faster
!  when mb is small, and using fmipwr allows ma to be negative.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(4), mresult

      call fmalloc(mc, qx%ndig+2, qx)
      call fmenter2(ma, mb, kovun, mxsave, ndsave, qx)
      call fmpwr_sc(ma, mb, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mc, kovun, mxsave, ndsave, qx)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmpwr_m1(ma, mb, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mc, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmpwr

      subroutine fmpwr_m1(ma, mb, mxy, mresult, ndsave, qx)

!  Method 1 for computing ma**mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mxy(4), mresult
      integer :: ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: iextra, intmb, j, kfl, kwrnsv
      type(multi) :: malocal, mblocal
      logical, external :: fmcomp

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)
      call fmequ(mb, mblocal, ndsave, qx%ndig, qx)

      kwrnsv = qx%kwarn
      qx%kwarn = 0
      call fmm2i2(mblocal, intmb, qx)
      qx%kwarn = kwrnsv
      kfl = qx%kflag

!             If the exponent is large or the base is very large, raise the precision.

      if (malocal%mp(2) /= 0) then
          j = int(log(abs(real(malocal%mp(2))))/qx%alogmb)
          iextra = max(0, int(mblocal%mp(2))+j)
          if (abs(malocal%mp(2)) >= qx%mexpov .or. abs(mblocal%mp(2)) >= qx%mexpov) then
              iextra = 0
          endif
      else
          iextra = max(0, int(mblocal%mp(2)))
          if (abs(mblocal%mp(2)) >= qx%mexpov) iextra = 0
      endif
      if (mblocal%mp(2)-qx%ndig > log(qx%alogmb*real(qx%mxexp2))) then
          iextra = 0
      endif
      call fmndig(qx%ndig + iextra, qx)

!             If the exponent is a small integer, call fmipwr.

      kwrnsv = qx%kwarn
      qx%kwarn = 0

      call fmequ(malocal, mxy(2), ndsave, qx%ndig, qx)

      if (kfl == 0) then
          call fmipwr(mxy(2), intmb, mxy(4), qx)
      else if (mxy(2)%mp(3) == 0) then
          call fmunknown(mxy(4), qx)
      else
          call fmequ(mblocal, mxy(1), ndsave, qx%ndig, qx)
          if (mxy(2)%mp(1) < 0) then
              call fmint(mxy(1), mxy(3), qx)
              if (fmcomp(mxy(1), '==', mxy(3), qx)) then
                  call fmi2m(2, mxy(3), qx)
                  call fmmod(mxy(1), mxy(3), mxy(4), qx)
                  j = -1
                  if (mxy(4)%mp(3) == 0) j = 1
                  call fmnegate(mxy(2), qx)
                  call fmln(mxy(2), mxy(3), qx)
                  qx%ndigli = 0
                  call fmmpy_r1(mxy(3), mxy(1), qx)
                  call fmexp(mxy(3), mxy(4), qx)
                  qx%ndige = 0
                  if (j == -1) call fmnegate(mxy(4), qx)
              else
                  call fmunknown(mxy(4), qx)
              endif
          else
              call fmln(mxy(2), mxy(3), qx)
              qx%ndigli = 0
              call fmmpy_r1(mxy(3), mxy(1), qx)
              call fmexp(mxy(3), mxy(4), qx)
              qx%ndige = 0
          endif
      endif
      qx%kwarn = kwrnsv
      call fmeq(mxy(4), mresult, qx)

      return
      end subroutine fmpwr_m1

      subroutine fmpwr_sc(ma, mb, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = ma**mb

!  kresult = 1 is returned if a special case gives the value of ma**mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mxy(4), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      type(multi) :: malocal, mblocal
      double precision :: b, x
      integer :: j, k, kc, kd, kwn, kx
      logical, external :: fmcomp

      kresult = 0

      qx%namest(qx%ncall) = 'FMPWR    '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp2(ma, mb, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)
      call fmequ(mb, mblocal, ndsave, qx%ndig, qx)

      if ((malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) .or.  &
          (mblocal%mp(2) == qx%munkno .and. mblocal%mp(5) >= 0)) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif
      if (malocal%mp(3) == 0) then
          if (mblocal%mp(3) == 0) then
              call fmunknown(mresult, qx)
              kresult = 1
              return
          else if (mblocal%mp(1) > 0) then
              call fmi2m(0, mresult, qx)
              qx%kflag = 0
              kresult = 1
              return
          else
              call fmunknown(mresult, qx)
              kresult = 1
              return
          endif
      endif
      if (mblocal%mp(3) == 0) then
          call fmi2m(1, mresult, qx)
          qx%kflag = 0
          kresult = 1
          return
      endif
      if (abs(malocal%mp(2)) >= qx%mexpov .or. mblocal%mp(2) >= qx%mexpov) then
          call fmovun_pwr(malocal, mblocal, mresult, qx)
          qx%kflag = 0
          kresult = 1
          return
      endif
      k = qx%ntrace
      qx%ntrace = 0
      call fmi2m(1, mxy(4), qx)
      call fmabs(malocal, mxy(3), qx)
      qx%ntrace = k

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (qx%kround /= 1 .and. malocal%mp(1) >= 0 .and. malocal%mp(3) > 0 .and.  &
          malocal%mp(2) /= qx%munkno .and. mblocal%mp(2) /= qx%munkno) then
          j = qx%ntrace
          qx%ntrace = 0
          kwn = qx%kwarn
          qx%kwarn = 0
          b = qx%mbase
          kc = 0
          kd = nint(log10(b))
          if (10.0d0**kd == b) then
              kc = 10
          else
              kd = nint(log(b)/log(2.0d0))
              if (2.0d0**kd == b) kc = 2
          endif
          if (kc > 0) then
              call fmm2dp(malocal, x, qx)
              if (qx%kflag == 0 .and. x > 0) then
                  kx = nint(log(x)/log(dble(kc)))
                  call fmi2m(kc, mxy(2), qx)
                  call fmipwr(mxy(2), kx, mxy(3), qx)
                  if (fmcomp(mxy(3), '==', malocal, qx)) then
                      call fmmpyi(mblocal, kx, mxy(3), qx)
                      call fmint(mxy(3), mxy(4), qx)
                      if (fmcomp(mxy(3), '==', mxy(4), qx)) then
                          call fmm2i(mxy(3), kd, qx)
                          if (qx%kflag == 0) then
                              call fmipwr(mxy(2), kd, mresult, qx)
                              qx%ntrace = j
                              qx%kwarn = kwn
                              kresult = 1
                              return
                          endif
                      endif
                  endif
              endif
          endif
          if (mblocal%mp(2) == qx%mexpun) then
              call fmeq(mblocal, mxy(3), qx)
              if (malocal%mp(2) <= 0) call fmnegate(mxy(3), qx)
          else
              call fmln(malocal, mxy(1), qx)
              qx%ndigli = 0
              call fmmpy(mxy(1), mblocal, mxy(3), qx)
          endif
          qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = kwn
          if (mxy(3)%mp(2) < -ndsave) then
              j = qx%ntrace
              qx%ntrace = 0
              kwn = qx%kwarn
              qx%kwarn = 0
              call fmi2m(1, mxy(1), qx)
              call fmsub(malocal, mxy(1), mxy(2), qx)
              if (mxy(2)%mp(3) == 0) then
                  call fmi2m(1, mxy(2), qx)
              else
                  call fmadd(mxy(1), mxy(3), mxy(2), qx)
              endif
              if (mxy(2)%mp(2) /= qx%munkno) then
                  qx%kflag = 0
                  qx%ntrace = j
                  qx%kwarn = kwn
                  call fmeq(mxy(2), mresult, qx)
                  kresult = 1
                  return
              endif
          endif
      endif

      return
      end subroutine fmpwr_sc

      subroutine fmrational_power(ma, ival, jval, mb, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: ival, jval
      intent (in) :: ma, ival, jval
      intent (inout) :: mb
      type(fm_settings) :: qx

      call fmrpwr(ma, ival, jval, mb, qx)

      return
      end subroutine fmrational_power

      subroutine fmrdc(ma, jsin, jcos, jswap, qx)

!  Reduce ma using various trigonometric identities to an equivalent angle between 0 and 45 degrees.
!  The reduction is done in radians if krad (in module fmvals) is 1, in degrees if krad is 0.
!  jsin and jcos are returned +1 or -1 and jswap is returned to indicate that the sin and cos
!  functions have been interchanged as follows:

!  jswap = 0 means   sin(ma) = jsin*sin(returned value of ma)
!                    cos(ma) = jcos*cos(returned value of ma)

!  jswap = 1 means   sin(ma) = jsin*cos(returned value of ma)
!                    cos(ma) = jcos*sin(returned value of ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: jsin, jcos, jswap
      intent (inout) :: ma
      intent (inout) :: jsin, jcos, jswap
      type(fm_settings) :: qx

      double precision :: x
      integer :: j, ndsave, ndsv
      logical, external :: fmcomp
      type(multi) :: mxy(6)
      qx%ndigpi = 0
      qx%mbspi = 0

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      jsin = 1
      jcos = 1
      jswap = 0
      ndsave = qx%ndig
      if (qx%krad == 0) then
          call fmi2m(360, mxy(2), qx)
          call fmeq(ma, mxy(4), qx)
          call fmmod(mxy(4), mxy(2), ma, qx)
      endif

      if (abs(ma%mp(2)) < qx%mexpov) then
          call fmndig(qx%ndig + max(0, int(ma%mp(2))), qx)
          if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
      endif

!             If ma is less than 1/mbase, no reduction is needed.

      if (ma%mp(2) < 0) then
          qx%ndig = ndsave
          if (ma%mp(1) < 0) then
              ma%mp(1) = 1
              jsin = -1
          endif
          return
      endif

      j = 1
      if (qx%krad == 1) then
          do
             if (qx%mbspi /= qx%mbase .or. qx%ndigpi < qx%ndig) then
                 ndsv = qx%ndig
                 call fmndig(qx%ndig + 2, qx)
                 call fmpi(mxy(4), qx)
                 qx%ndigpi = 0
                 call fmndig(ndsv, qx)
             endif
             call fmequ(ma, mxy(4), ndsave, qx%ndig, qx)
             if (ma%mp(1) < 0) jsin = -1
             mxy(4)%mp(1) = 1
             if (mxy(4)%mp(2) == 0) then
                 call fmm2dp(mxy(4), x, qx)
                 if (x <= 0.75) then
                     qx%ndig = ndsave
                     call fmeq(mxy(4), ma, qx)
                     return
                 endif
             endif
             call fmpi(mxy(6), qx)
             qx%ndigpi = 0
             call fmmpyi(mxy(6), 2, mxy(2), qx)
             if (fmcomp(mxy(4), '>=', mxy(2), qx)) then
                 call fmdiv(mxy(4), mxy(2), mxy(1), qx)
                 call fmint(mxy(1), mxy(5), qx)
                 call fmmpy_r1(mxy(5), mxy(2), qx)
                 call fmsub_r1(mxy(4), mxy(5), qx)
             endif
             call fmeq(mxy(6), mxy(3), qx)
             if (fmcomp(mxy(4), '>=', mxy(3), qx)) then
                 jsin = -jsin
                 call fmsub_r2(mxy(2), mxy(4), qx)
             endif
             call fmdivi_r1(mxy(2), 4, qx)
             if (fmcomp(mxy(4), '>=', mxy(2), qx)) then
                 jcos = -jcos
                 call fmsub_r2(mxy(3), mxy(4), qx)
             endif
             call fmdivi_r1(mxy(3), 4, qx)
             if (fmcomp(mxy(4), '>=', mxy(3), qx)) then
                 jswap = 1
                 call fmsub_r2(mxy(2), mxy(4), qx)
             endif

!             If the reduced argument is close to zero, then cancellation has produced an
!             inaccurate value.
!             Raise ndig and do the reduction again.

             if (j == 1 .and. (mxy(4)%mp(2) < 0 .or. mxy(4)%mp(3) == 0)) then
                 j = 2
                 if (mxy(4)%mp(3) == 0) then
                     call fmndig(2*qx%ndig, qx)
                 else
                     call fmndig(qx%ndig - int(mxy(4)%mp(2)), qx)
                     if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                 endif
                 jsin = 1
                 jcos = 1
                 jswap = 0
             else
                 exit
             endif
          enddo
      else
          call fmequ(ma, mxy(4), ndsave, qx%ndig, qx)
          if (ma%mp(1) < 0) jsin = -1
          mxy(4)%mp(1) = 1
          if (mxy(4)%mp(2) == 0) then
              call fmm2dp(mxy(4), x, qx)
              if (x <= 44.0) then
                  qx%ndig = ndsave
                  call fmeq(mxy(4), ma, qx)
                  return
              endif
          endif
          call fmi2m(360, mxy(2), qx)
          if (fmcomp(mxy(4), '>=', mxy(2), qx)) then
              call fmdiv(mxy(4), mxy(2), mxy(1), qx)
              call fmint(mxy(1), mxy(5), qx)
              call fmmpy_r1(mxy(5), mxy(2), qx)
              call fmsub_r1(mxy(4), mxy(5), qx)
          endif
          call fmi2m(180, mxy(3), qx)
          if (fmcomp(mxy(4), '>=', mxy(3), qx)) then
              jsin = -jsin
              call fmsub_r2(mxy(2), mxy(4), qx)
          endif
          call fmi2m(90, mxy(2), qx)
          if (fmcomp(mxy(4), '>=', mxy(2), qx)) then
              jcos = -jcos
              call fmsub_r2(mxy(3), mxy(4), qx)
          endif
          call fmi2m(45, mxy(3), qx)
          if (fmcomp(mxy(4), '>=', mxy(3), qx)) then
              jswap = 1
              call fmsub_r2(mxy(2), mxy(4), qx)
          endif
      endif

!             Round the result and return.

      call fmequ(mxy(4), ma, qx%ndig, ndsave, qx)
      qx%ndig = ndsave

      return
      end subroutine fmrdc

      subroutine fmread(kread, ma, qx)

!  Read ma on unit kread.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  Only one number is allowed on the line(s).

      use fmvals_parallel
      implicit none

      character :: cmbuff(lmbuff)
      type(multi) :: ma
      integer :: kread
      intent (in) :: kread
      intent (inout) :: ma
      type(fm_settings) :: qx

      character :: line(132)
      integer :: j, jstat, kamper, lb, ndsave
      type(multi) :: mxy(1)

      call fmalloc(ma, qx%ndig+2, qx)

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMREAD'
      ndsave = qx%ndig
      call fmndig(max(qx%ndig+qx%ngrd52, 3), qx)
      lb = 0
      kamper = 0

      do
         read (kread, "(132A1)", iostat=jstat) line
         if (jstat /= 0) then
             qx%kflag = -4
             call fmwarn(qx)
             qx%ndig = ndsave
             call fmunknown(ma, qx)
             qx%ncall = qx%ncall - 1
             return
         endif

!             Scan the line and look for '&'

         do j = 1, 132
            if (line(j) == '&') then
                kamper = 1
                exit
            endif
            if (line(j) /= ' ') then
                lb = lb + 1
                if (lb > lmbuff) then
                    write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                                        " Raise its size (lmbuff) or change the format being used."
                    stop
                endif
                cmbuff(lb) = line(j)
            endif
         enddo
         if (kamper == 0) exit
         kamper = 0
      enddo

      qx%ncall = qx%ncall - 1
      call fminp(cmbuff, mxy(1), 1, lb, qx)
      qx%ncall = qx%ncall + 1

      call fmequ(mxy(1), ma, qx%ndig, ndsave, qx)
      qx%ndig = ndsave
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmread

      subroutine fmrnd(mw, nd, nguard, kshift, qx)

!  Round mw to nd digits (base mbase).

!  mw is non-negative and has nd+nguard+kshift digits.

!  nguard is the number of guard digits carried.
!  kshift is 1 if a left shift is pending when the first digit of mw is 0.

!  Round to position mw%mp(nd+2+kshift) using the guard digits
!  mw%mp(nd+3+kshift), ..., mw%mp(nd+2+nguard+kshift).

!  This routine is designed to be called only from within the fm package.
!  The user should call fmequ to round numbers.

      use fmvals_parallel
      implicit none

      type(multi) :: mw
      integer :: nd, nguard, kshift
      intent (in) :: nd, kshift, nguard
      intent (inout) :: mw
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: m2, mkt
      integer :: j, k, kb, kl, kup, l

      l = nd + 2 + kshift
      kup = 0
      do while (kup == 0)
         kup = -1
         if (qx%kround == -1) then
             if (qx%jrsign == 1) return
             kl = 0
             do j = nd+2+kshift, nd+1+nguard+kshift
                if (mw%mp(j+1) > 0) then
                    mw%mp(kshift+nd+2) = mw%mp(kshift+nd+2) + 1
                    mw%mp(kshift+nd+3) = 0
                    if (mw%mp(kshift+nd+2) < qx%mbase) return
                    l = nd + 2 + kshift
                    kl = 1
                    exit
                endif
             enddo
             if (kl == 0) then
                 return
             else
                 exit
             endif
         endif

         if (qx%kround == 2) then
             if (qx%jrsign == -1) return
             kl = 0
             do j = nd+2+kshift, nd+1+nguard+kshift
                if (mw%mp(j+1) > 0) then
                    mw%mp(kshift+nd+2) = mw%mp(kshift+nd+2) + 1
                    mw%mp(kshift+nd+3) = 0
                    if (mw%mp(kshift+nd+2) < qx%mbase) return
                    l = nd + 2 + kshift
                    kl = 1
                    exit
                endif
             enddo
             if (kl == 0) then
                 return
             else
                 exit
             endif
         endif

         if (qx%kround == 0) return
         l = nd + 2 + kshift
         if (2*(mw%mp(l+1)+1) < qx%mbase) return
         if (2*mw%mp(l+1) > qx%mbase) then
             mw%mp(l) = mw%mp(l) + 1
             mw%mp(l+1) = 0
             if (mw%mp(l) < qx%mbase) return
             exit
         endif

!             If the first guard digit gives a value close to 1/2 then further guard digits must
!             be examined.

         m2 = 2
         if (int(qx%mbase-aint (qx%mbase/m2)*m2) == 0) then
             if (2*mw%mp(l+1) < qx%mbase) return
             if (2*mw%mp(l+1) == qx%mbase) then
                 if (nguard >= 2) then
                     kl = 0
                     do j = 2, nguard
                        if (mw%mp(j+l) > 0) then
                            kl = 1
                            exit
                        endif
                     enddo
                     if (kl == 1) then
                         kup = 1
                         exit
                     endif
                 endif

!                       Round to even.

                 if (int(mw%mp(l)-aint (mw%mp(l)/m2)*m2) == 0) return
                 kup = 1
             endif
         else
             if (2*mw%mp(l+1)+1 == qx%mbase) then
                 if (nguard >= 2) then
                     kl = 0
                     do j = 2, nguard
                        if (2*(mw%mp(j+l)+1) < qx%mbase) return
                        if (2*mw%mp(j+l) > qx%mbase) then
                            kl = 1
                            exit
                        endif
                     enddo
                     if (kl == 1) then
                         kup = 1
                         exit
                     endif
                     if (nguard <= qx%ndig) return
                     m2 = 2
                     if (int(mw%mp(l)-aint (mw%mp(l)/m2)*m2) == 0) then
                         return
                     else
                         kup = 1
                     endif
                 endif
             endif
         endif
      enddo

!             Round up.

      if (kup == 1) then
          mw%mp(l) = mw%mp(l) + 1
          mw%mp(l+1) = 0
      endif

!             Check whether there was a carry in the rounded digit.

      kb = l - 1
      if (kb >= 3) then
          k = kb + 1
          do j = 3, kb
             k = k - 1
             if (mw%mp(k+1) < qx%mbase) return
             mkt = aint (mw%mp(k+1)/qx%mbase)
             mw%mp(k) = mw%mp(k) + mkt
             mw%mp(k+1) = mw%mp(k+1) - mkt*qx%mbase
          enddo
      endif

!             If there is a carry in the first digit then the exponent must be adjusted and the
!             number shifted right.

      if (mw%mp(3) >= qx%mbase) then
          if (kb >= 4) then
              k = kb + 1
              do j = 4, kb
                 k = k - 1
                 mw%mp(k+1) = mw%mp(k)
              enddo
          endif

          mkt = aint (mw%mp(3)/qx%mbase)
          if (kb >= 3) mw%mp(4) = mw%mp(3) - mkt*qx%mbase
          mw%mp(3) = mkt
          mw%mp(2) = mw%mp(2) + 1
      endif

      return
      end subroutine fmrnd

      subroutine fmrpwr(ma, ival, jval, mb, qx)

!  mb = ma**(ival/jval)   rational exponentiation.

!  This routine is faster than fmpwr when ival and jval are small integers.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: ival, jval
      intent (in) :: ma, ival, jval
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: ival2, jval2, kovun, kresult, ndsave
      type(multi) :: mxy(3), mresult
      logical :: retry

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmrpwr_sc(ma, ival, jval, ival2, jval2, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call fmrpwr_m1(ma, ival, jval, ival2, jval2, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmrpwr

      subroutine fmrpwr_m1(ma, ival, jval, ival2, jval2, mxy, mresult, ndsave, qx)

!  Method 1 for computing ma**(ival/jval).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(3), mresult
      integer :: ival, jval, ival2, jval2, ndsave
      intent (in) :: ma, ival, jval, ival2, jval2, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: x, f
      real (kind(1.0d0)) :: ma1
      integer :: nstack(49), ijsign, invert, j, kst, l, lval

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      ijsign = 1
      if (ival > 0 .and. jval < 0) ijsign = -1
      if (ival < 0 .and. jval > 0) ijsign = -1

!             Invert ma if ma > 1 and ival or jval is large.

      invert = 0
      if (ma%mp(2) > 0) then
          if (ival > 5 .or. jval > 5) then
              invert = 1
              call fmi2m(1, mxy(2), qx)
              call fmdiv_r2(mxy(2), mxy(1), qx)
          endif
      endif

!             Generate the first approximation to abs(ma)**(1/jval2).

      ma1 = mxy(1)%mp(2)
      mxy(1)%mp(2) = 0
      mxy(1)%mp(1) = 1
      call fmm2dp(mxy(1), x, qx)
      l = int(ma1/jval2)
      f = ma1/dble(jval2) - l
      x = x**(1.0d0/jval2) * dble(qx%mbase)**f
      call fmdpm(x, mresult, qx)
      mresult%mp(2) = mresult%mp(2) + l
      mxy(1)%mp(2) = ma1

!             Initialize.

      call fmi2m(0, mxy(3), qx)
      call fmdig(nstack, kst, qx)

!             Newton iteration.

      do j = 1, kst
         call fmndig(nstack(j), qx)
         if (j < kst) call fmndig(qx%ndig + 1, qx)
         lval = jval2 - 1
         call fmipwr(mresult, lval, mxy(3), qx)
         call fmdiv_r2(mxy(1), mxy(3), qx)
         call fmmpyi_r1(mresult, lval, qx)
         call fmadd_r1(mresult, mxy(3), qx)
         call fmdivi_r1(mresult, jval2, qx)
      enddo

      if (ma%mp(1) < 0) call fmnegate(mresult, qx)
      call fmipwr(mresult, ijsign*ival2, mxy(3), qx)
      call fmeq(mxy(3), mresult, qx)
      if (invert == 1) then
          call fmi2m(1, mxy(2), qx)
          call fmdiv_r2(mxy(2), mresult, qx)
      endif

      return
      end subroutine fmrpwr_m1

      subroutine fmrpwr_sc(ma, ival, jval, ival2, jval2, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = ma**(ival/jval)

!  kresult = 1 is returned if a special case gives the value of rpwr(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(3), mresult
      integer :: ival, jval, ival2, jval2, kresult, ndsave
      intent (in) :: ma, ival, jval, ndsave
      intent (inout) :: ival2, jval2, mxy, mresult, kresult
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: ma2
      double precision :: b, xe, xe1, xf, xf1, ye, yf, z1, z2
      integer :: ijsign, j

      kresult = 0

      qx%namest(qx%ncall) = 'FMRPWR   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1ii(ma, ival, jval, qx)
      call fmndig(j, qx)

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)

      if (mxy(1)%mp(2) == qx%munkno .and. mxy(1)%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

!             Use gcd-reduced positive exponents.

      ijsign = 1
      ival2 = abs(ival)
      jval2 = abs(jval)
      if (ival > 0 .and. jval < 0) ijsign = -1
      if (ival < 0 .and. jval > 0) ijsign = -1
      if (ival2 > 0 .and. jval2 > 0) call fmgcdi(ival2, jval2)
      ma2 = ma%mp(3)

      if ((ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) .or. jval2 == 0 .or.  &
          (ijsign <= 0 .and. ma2 == 0)) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (ival2 == 0) then
          call fmi2m2(1, mresult, qx)
          kresult = 1
          return
      endif

      if (jval2 == 1) then
          call fmipwr(mxy(1), ijsign*ival2, mresult, qx)
          kresult = 1
          return
      endif

      if (ma2 == 0) then
          call fmeq(ma, mresult, qx)
          kresult = 1
          return
      endif

      if (ma%mp(1) < 0) then
          if (mod(jval2, 2) == 0) then
              jval2 = 0
              call fmunknown(mresult, qx)
              kresult = 1
              return
          else
              mxy(1)%mp(1) = 1
          endif
      endif

      call fmi2m(ival2, mxy(2), qx)
      call fmdivi_r1(mxy(2), jval2, qx)
      if (abs(ma%mp(2)) >= qx%mexpov) then
          if (ijsign == -1) call fmmpyi_r1(mxy(2), ijsign, qx)
          call fmovun_pwr(mxy(1), mxy(2), mresult, qx)
          if (ma%mp(1) < 0 .and. mod(ival2, 2) /= 0 .and. mod(jval2, 2) /= 0) then
              if (mresult%mp(2) /= qx%munkno .or. mresult%mp(5) < 0) mresult%mp(1) = -1
          endif
          kresult = 1
          return
      else
          if (size(ma%mp) >= 5) then
              if (ma%mp(5) < 0) then
                  xe = ma%mp(4)
                  xf = ma%mp(5)
                  xf = -xf/maxint
              else
                  xe = abs(ma%mp(2))
                  call fmovun_frac(ma, xf, qx)
              endif
          else
              xe = abs(ma%mp(2))
              call fmovun_frac(ma, xf, qx)
          endif
          if (size(mxy(2)%mp) >= 5) then
              if (mxy(2)%mp(5) < 0) then
                  ye = mxy(2)%mp(4)
                  yf = mxy(2)%mp(5)
                  yf = -yf/maxint
              else
                  ye = abs(mxy(2)%mp(2))
                  call fmovun_frac(mxy(2), yf, qx)
              endif
          else
              ye = abs(mxy(2)%mp(2))
              call fmovun_frac(mxy(2), yf, qx)
          endif
          b = qx%mbase
          xe1 = xe
          xf1 = xf
          if (xe <= 0) then
              xe1 = -xe
              xf1 = 1.0d0/xf
          endif
          z1 = ye*log(b) + log(yf) + log(xe1*log(b) + log(xf1))
          z2 = log(dble(qx%mxexp2)) + log(log(b))
          if (z1 >= z2 .and. mxy(2)%mp(2) > 0) then
              if (ijsign == -1) call fmmpyi_r1(mxy(2), ijsign, qx)
              call fmovun_pwr(mxy(1), mxy(2), mresult, qx)
              if (ma%mp(1) < 0 .and. mod(ival2, 2) /= 0 .and. mod(jval2, 2) /= 0) then
                  if (mresult%mp(2) /= qx%munkno) mresult%mp(1) = -1
              endif
              kresult = 1
              return
          endif
      endif

      return
      end subroutine fmrpwr_sc

      subroutine fms(ma, mb, qx)

!  mb = s(ma)    Fresnel Sine Integral.

!  Integral from 0 to ma of sin(pi*t**2/2) dt.


      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(16), mresult, mretry

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fms_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      n_acc = nint(qx%ndig*qx%alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fms_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)
         if (ma%mp(1) == -1) call fmnegate(mresult, qx)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry, qx)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fms

      subroutine fms_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)

!  Method selection for computing s(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(16), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc
      type(fm_settings) :: qx

      double precision :: x, xe, y
      integer :: iextra, jr, kflagx, nmethd
      logical, external :: fmcomp

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      call fmeq(mxy(1), mxy(13), qx)
      mxy(1)%mp(1) = 1
      n_acc = nint(qx%ndig*qx%alogm2)

!             Check for special cases.

      if (mxy(1)%mp(3) == 0) then
          call fmeq(mxy(1), mresult, qx)
          retry = .false.
          return
      endif
      call fmovun_xe(mxy(1), xe, qx)
      if (4*xe < -qx%ndig) then
          call fmsqr(mxy(1), mxy(11), qx)
          call fmmpy_r2(mxy(1), mxy(11), qx)
          call fmpi(mxy(3), qx)
          qx%ndigpi = 0
          call fmdivi(mxy(3), 6, mxy(4), qx)
          call fmmpy_r1(mxy(11), mxy(4), qx)
          call fmeq(mxy(11), mresult, qx)
          return
      endif
      call fmint(mxy(1), mxy(8), qx)
      if (xe > qx%ndig .and. fmcomp(mxy(1), '==', mxy(8), qx) .and. mxy(1)%mp(2) /= qx%mexpov) then
          call fmi2m(1, mxy(8), qx)
          if (mxy(1)%mp(1) < 0) then
              call fmdivi(mxy(8), -2, mxy(11), qx)
          else
              call fmdivi(mxy(8), 2, mxy(11), qx)
          endif
          call fmpi(mxy(6), qx)
          qx%ndigpi = 0
          call fmmpy_r1(mxy(6), mxy(1), qx)
          call fmdiv_r2(mxy(8), mxy(6), qx)
          jr = qx%kround
          if (qx%kround == -1 .and. ma%mp(1) < 0) qx%kround =  2
          if (qx%kround ==  2 .and. ma%mp(1) < 0) qx%kround = -1
          call fmsub_r1(mxy(11), mxy(6), qx)
          qx%kround = jr
          call fmeq(mxy(11), mresult, qx)
          retry = .false.
          return
      endif
      call fmovun_xe(mxy(1), xe, qx)
      if (xe > qx%ndig) then
          call fmi2m(1, mxy(8), qx)
          if (mxy(1)%mp(1) < 0) then
              call fmdivi(mxy(8), -2, mxy(11), qx)
          else
              call fmdivi(mxy(8), 2, mxy(11), qx)
          endif
          call fmeq(mxy(11), mresult, qx)
          return
      endif

!             x is a double precision approximation to the input argument to this function.

      call fmm2dp(mxy(1), x, qx)
      kflagx = qx%kflag
      call fmovun_xe(mxy(1), xe, qx)
      if (qx%kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif

!             If ma is large in magnitude, use more guard digits.

      iextra = min(max(int(mxy(1)%mp(2)), 0) , int(2.0+qx%alogmx/qx%alogmb))
      if (abs(mxy(1)%mp(2)) >= qx%mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
      endif
      call fmndig(qx%ndig + iextra, qx)
      n_acc = nint(qx%ndig*qx%alogm2)

!             Determine which method to use.

!             nmethd = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      if (kflagx == 0) then
          if (abs(x) < sqrt(huge(x)/(4*log(huge(x))))) then
              y = (qx%dppi*x*x-1)/2
              y = (2*y+1.5)*log(2*y+2) - (2*y+1) - y*qx%dlogtw - (y+0.5)*log(y+1) + y - y*log(qx%dppi*x*x)
              if (y <= -(qx%ndig+1)*qx%dlogmb) then
                  nmethd = 2
              else
                  nmethd = 1
              endif
          else
              nmethd = 2
          endif
      else
          call fmovun_xe(mxy(1), xe, qx)
          if (xe <= 0) then
              nmethd = 1
          else
              nmethd = 2
          endif
      endif

      if (nmethd == 1) then
          call fms_m1(mxy, mresult, ndsave, numtry, n_acc, kflagx, x, qx)
      else if (nmethd == 2) then
          call fms_m2(mxy, mresult, ndsave, numtry, n_acc, qx)
      endif

      return
      end subroutine fms_m

      subroutine fms_m1(mxy, mresult, ndsave, numtry, n_acc, kflagx, x, qx)

!  Method 1 for computing s(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(16), mresult
      integer :: ndsave, numtry, n_acc, kflagx
      double precision :: x
      intent (in) :: numtry, ndsave, kflagx, x
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      double precision :: xe
      integer :: iextra, j, j2, k, kl, large, nbot, ndsav1, nterm
      type(multi) :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 1.  Use x times the series (-1)**n*(pi*x*x/2)**(2*n+1)/((4*n+3)*(2*n+1)!).

!             mxy(6) is the current term
!             mxy(9) is pi*x*x/2

      iextra = 0
      if (kflagx == 0) then
          iextra = max(0.0d0, (0.096*x*x + 0.033*abs(x) - 0.5)*log(1.0e7)/qx%alogmb)*1.02
          if (iextra > 0) then
              call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
          endif
      endif
      call fmndig(qx%ndig + iextra, qx)
      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig-1), qx)
      endif
      n_acc = nint(qx%ndig*qx%alogm2)

      if (kflagx == 0) then
          j2 = int(0.68*sqrt(fmnterms(3.14159d0*x*x/2, 2, 0, 0, 1, qx)) - 1.6)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums.

      call fmsqr(mxy(1), mxy(4), qx)
      call fmcsdivi(mxy(4), 2, mxy(9), qx)
      call fmpi(mxy(3), qx)
      qx%ndigpi = 0
      call fmcsmpy_r1(mxy(9), mxy(3), qx)
      call fmi2m(1, mxy(6), qx)
      call fmcsdivi(mxy(6), 3, mjsums(1), qx)
      nterm = 0
      do j = 2, j2
         nterm = nterm + 2
         nbot = nterm*(nterm+1)
         large = int(intmax/nterm)
         if (nterm > large .or. nbot > mxbase) then
             call fmcsdivi_r1(mxy(6), nterm, qx)
             call fmcsdivi_r1(mxy(6), nterm+1, qx)
         else
             call fmcsdivi_r1(mxy(6), nbot, qx)
         endif
         call fmcsdivi(mxy(6), 2*nterm+3, mjsums(j), qx)
      enddo
      call fmovun_xe(mxy(1), xe, qx)
      if (xe < -qx%ndig) then
          kl = 0
      else
          call fmipwr(mxy(9), 2*j2, mxy(7), qx)
          kl = 1
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(6), mxy(7), qx)
         do j = 1, j2
            nterm = nterm + 2
            large = int(intmax/nterm)
            if (nterm > large .or. nterm > mxbase/(nterm-1)) then
                call fmcsdivi_r1(mxy(6), nterm, qx)
                call fmcsdivi_r1(mxy(6), nterm+1, qx)
            else
                nbot = nterm*(nterm+1)
                call fmcsdivi_r1(mxy(6), nbot, qx)
            endif
            call fmcsdivi(mxy(6), 2*nterm+3, mxy(2), qx)
            call fmndig(ndsav1, qx)
            call fmcsaddnn_r1(mjsums(j), mxy(2), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            call fmndig(ndsav1 - int(mjsums(j)%mp(2)-mxy(6)%mp(2)), qx)
            call fmndig(min(ndsav1, qx%ndig), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         enddo
         if (kl == 0) exit
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmcsnsums(j2, mjsums, qx)
      call fmsqr(mxy(9), mxy(8), qx)
      mxy(8)%mp(1) = -1
      if (mjsums(1)%mp(1) > 0) then
          call fmeq(mjsums(1), mxy(15), qx)
          call fmi2m(0, mxy(16), qx)
      else
          call fmeq(mjsums(1), mxy(16), qx)
          call fmi2m(0, mxy(15), qx)
      endif
      call fmeq(mxy(8), mxy(12), qx)
      do j = 1, j2-1
         call fmmpy(mxy(12), mjsums(j+1), mxy(3), qx)
         if (mxy(3)%mp(1) > 0) then
             call fmadd_r1(mxy(15), mxy(3), qx)
         else
             call fmadd_r1(mxy(16), mxy(3), qx)
         endif
         call fmmpy_r1(mxy(12), mxy(8), qx)
      enddo
      call fmadd(mxy(15), mxy(16), mxy(11), qx)
      call fmcancel(mxy(15), mxy(16), mxy(11), k, qx)
      n_acc = n_acc - k
      call fmcsmpy_r1(mxy(11), mxy(1), qx)
      call fmcsmpy_r1(mxy(11), mxy(9), qx)

      call fmeq(mxy(11), mresult, qx)

      return
      end subroutine fms_m1

      subroutine fms_m2(mxy, mresult, ndsave, numtry, n_acc, qx)

!  Method 2 for computing s(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(16), mresult
      integer :: ndsave, numtry, n_acc
      intent (in) :: ndsave, numtry
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      integer :: krsave

!             Method 2.  Use the two n!/x**n asymptotic series for f(x) and g(x).
!                        Then s(x) = 0.5 - f(x)*cos(pi*x*x/2) - g(x)*sin(pi*x*x/2).

      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig-1), qx)
      endif
      n_acc = nint(qx%ndig*qx%alogm2)
      call fmfgfi(mxy(1), mxy(12), mxy(13), qx)
      call fmsqr(mxy(1), mxy(4), qx)
      krsave = qx%krad
      qx%krad = 0
      call fmmpyi(mxy(4), 90, mxy(7), qx)
      call fmcssn(mxy(7), mxy(14), mxy(10), qx)
      qx%krad = krsave
      if (mxy(1)%mp(2) == qx%munkno .and. mxy(1)%mp(5) < 0 .and.        &
          ( (mxy(14)%mp(2) == qx%munkno .and. mxy(14)%mp(5) >= 0) .or.  &
            (mxy(10)%mp(2) == qx%munkno .and. mxy(10)%mp(5) >= 0) )) then
          call fmunknown(mxy(11), qx)
          mxy(11)%mp(4) = 0
          mxy(11)%mp(5) = -maxint * 0.5d0
      else
          call fmmpy(mxy(12), mxy(14), mxy(11), qx)
          call fmmpy(mxy(13), mxy(10), mxy(7), qx)
          call fmi2m(1, mxy(4), qx)
          call fmdivi(mxy(4), 2, mxy(5), qx)
          call fmsub(mxy(5), mxy(11), mxy(6), qx)
          call fmsub(mxy(6), mxy(7), mxy(11), qx)
      endif

      call fmeq(mxy(11), mresult, qx)

      return
      end subroutine fms_m2

      subroutine fms_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = s(ma).

!  kresult = 1 is returned if a special case gives the value of s(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMS      '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine fms_sc

      subroutine fmsetvar(string, qx)

!  Change the value of one of the internal fm variables.
!  string must have the format  ' variablename = value ', with no embedded blanks in variablename.

      use fmvals_parallel
      implicit none
      character(*) :: string
      intent (in) :: string
      type(fm_settings) :: qx

      character(9) :: varname
      integer :: ival, j, kpteq, kpt1, kpt2
      double precision :: dval
      real (kind(1.0d0)) :: mval

      character(52) :: letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'

!             Find the equal sign.

      kpteq = index(string, '=')
      if (kpteq <= 0) then
          write (qx%kw,*) ' '
          write (qx%kw,*) ' Cannot find the equal sign in FMSETVAR.'
          write (qx%kw,*) ' Input string:  ', string
          return
      endif

!             Find the variable name.

      kpt1 = 0
      kpt2 = 0
      do j = 1, kpteq-1
         if (kpt1 == 0 .and. string(j:j) /= ' ') kpt1 = j
      enddo
      do j = kpteq-1, 1, -1
         if (kpt2 == 0 .and. string(j:j) /= ' ') kpt2 = j
      enddo
      if (kpt1 == 0) then
          write (qx%kw,*) ' '
          write (qx%kw,*) ' Cannot find the variable name in FMSETVAR.'
          write (qx%kw,*) ' Input string:  ', string
          return
      endif

!             Convert any lower case letters to upper case in the variable name, for name matching.

      varname = ' '
      do j = kpt1, kpt2
         ival = index(letters, string(j:j))
         if (ival > 26 .and. ival <= 52) then
             varname(j-kpt1+1:j-kpt1+1) = letters(ival-26:ival-26)
         else
             varname(j-kpt1+1:j-kpt1+1) = string(j:j)
         endif
      enddo

!             cmchar is a special case, since the value is a character.

      if (varname == 'CMCHAR') then
          kpt1 = 0
          kpt2 = 0
          do j = kpteq+1, len(string)
             if (kpt1 == 0 .and. string(j:j) /= ' ') kpt1 = j
          enddo
          do j = len(string), kpteq+1, -1
             if (kpt2 == 0 .and. string(j:j) /= ' ') kpt2 = j
          enddo
          if (kpt1 == kpt2 .and. index(letters, string(kpt1:kpt2)) > 0) then
              qx%cmchar = string(kpt1:kpt2)
              return
          else
              write (qx%kw,*) ' '
              write (qx%kw,*) ' Only a single letter is allowed after the equal sign in FMSETVAR.'
              write (qx%kw,*) ' Input string:  ', string
              return
          endif
      endif

!             Convert the value after the equal sign.

      if (kpteq+1 <= len(string)) then
          if (index(string(kpteq+1:len(string)), '=') /= 0) then
              write (qx%kw,*) ' '
              write (qx%kw,*) ' Only a single equal sign is allowed in FMSETVAR.'
              write (qx%kw,*) ' Input string:  ', string
              return
          endif
          call fmst2d(string(kpteq+1:len(string)), dval, qx)
          if (qx%kflag /= 0) then
              write (qx%kw,*) ' '
              write (qx%kw,*) ' Invalid value after the equal sign in FMSETVAR.'
              write (qx%kw,*) ' Input string:  ', string
              return
          endif
      else
          write (qx%kw,*) ' '
          write (qx%kw,*) ' Cannot find a value after the equal sign in FMSETVAR.'
          write (qx%kw,*) ' Input string:  ', string
          return
      endif

!             Check the list of variable names.

      if (varname == 'JFORM1') then
          qx%jform1 = nint(dval)
          if (qx%jform1 < 0 .or. qx%jform1 > 2) then
              write (qx%kw,*) ' '
              write (qx%kw,*) ' FMSETVAR:  Input string:  ', string
              write (qx%kw,*) '            ', qx%jform1, ' is an invalid value for JFORM1'
              qx%jform1 = 1
              write (qx%kw,*) '            Valid values are 0, 1, 2.  JFORM1 was set to ', qx%jform1
          endif
      else if (varname == 'JFORM2') then
          qx%jform2 = nint(dval)
          if (qx%jform2 < 0) then
              write (qx%kw,*) ' '
              write (qx%kw,*) ' FMSETVAR:  Input string:  ', string
              write (qx%kw,*) '            ', qx%jform2, ' is an invalid value for JFORM2'
              qx%jform2 = 1
              write (qx%kw,*) '            It should be nonnegative.  JFORM2 was set to ', qx%jform2
          endif
      else if (varname == 'JFORMZ') then
          qx%jformz = nint(dval)
          if (qx%jformz < 1 .or. qx%jformz > 3) then
              write (qx%kw,*) ' '
              write (qx%kw,*) ' FMSETVAR:  Input string:  ', string
              write (qx%kw,*) '            ', qx%jformz, ' is an invalid value for JFORMZ'
              qx%jformz = 1
              write (qx%kw,*) '            Valid values are 1, 2, 3.  JFORMZ was set to ', qx%jformz
          endif
      else if (varname == 'JPRNTZ') then
          qx%jprntz = nint(dval)
          if (qx%jprntz < 1 .or. qx%jprntz > 2) then
              write (qx%kw,*) ' '
              write (qx%kw,*) ' FMSETVAR:  Input string:  ', string
              write (qx%kw,*) '            ', qx%jprntz, ' is an invalid value for JPRNTZ'
              qx%jprntz = 1
              write (qx%kw,*) '            Valid values are 1, 2.  JPRNTZ was set to ', qx%jprntz
          endif
      else if (varname == 'KESWCH') then
          qx%keswch = nint(dval)
          if (qx%keswch < 0 .or. qx%keswch > 1) then
              write (qx%kw,*) ' '
              write (qx%kw,*) ' FMSETVAR:  Input string:  ', string
              write (qx%kw,*) '            ', qx%keswch, ' is an invalid value for KESWCH'
              qx%keswch = 1
              write (qx%kw,*) '            Valid values are 0, 1.  KESWCH was set to ', qx%keswch
          endif
      else if (varname == 'KRAD') then
          qx%krad = nint(dval)
          if (qx%krad < 0 .or. qx%krad > 1) then
              write (qx%kw,*) ' '
              write (qx%kw,*) ' FMSETVAR:  Input string:  ', string
              write (qx%kw,*) '            ', qx%krad, ' is an invalid value for KRAD'
              qx%krad = 1
              write (qx%kw,*) '            Valid values are 0, 1.  KRAD was set to ', qx%krad
          endif
      else if (varname == 'KROUND') then
          qx%kround = nint(dval)
          if (qx%kround < -1 .or. qx%kround > 2) then
              write (qx%kw,*) ' '
              write (qx%kw,*) ' FMSETVAR:  Input string:  ', string
              write (qx%kw,*) '            ', qx%kround, ' is an invalid value for KROUND'
              qx%kround = 1
              write (qx%kw,*) '            Valid values are -1, 0, 1, 2.  KROUND was set to ', qx%kround
          endif
      else if (varname == 'KRPERF') then
          write (qx%kw,*) ' '
          write (qx%kw,*) ' FMSETVAR:  Input string:  ', string
          write (qx%kw,*) '            KRPERF is no longer used.  Now perfect rounding is ',  &
                       'always done.'
          write (qx%kw,*) ' '
      else if (varname == 'KSWIDE') then
          qx%kswide = nint(dval)
          if (qx%kswide < 10) then
              write (qx%kw,*) ' '
              write (qx%kw,*) ' FMSETVAR:  Input string:  ', string
              write (qx%kw,*) '            ', qx%kswide, ' is an invalid value for KSWIDE'
              qx%kswide = 80
              write (qx%kw,*) '            It should be 10 or more.  KSWIDE was set to ', qx%kswide
          endif
      else if (varname == 'KW') then
!         kw = nint(dval)
      else if (varname == 'KWARN') then
          qx%kwarn = nint(dval)
          if (qx%kwarn < 0 .or. qx%kwarn > 2) then
              write (qx%kw,*) ' '
              write (qx%kw,*) ' FMSETVAR:  Input string:  ', string
              write (qx%kw,*) '            ', qx%kwarn, ' is an invalid value for KWARN'
              qx%kwarn = 1
              write (qx%kw,*) '            Valid values are 0, 1, 2.  KWARN was set to ', qx%kwarn
          endif
      else if (varname == 'LVLTRC') then
          qx%lvltrc = nint(dval)
          if (qx%lvltrc < 0) then
              write (qx%kw,*) ' '
              write (qx%kw,*) ' FMSETVAR:  Input string:  ', string
              write (qx%kw,*) '            ', qx%lvltrc, ' is an invalid value for LVLTRC'
              qx%lvltrc = 1
              write (qx%kw,*) '            It should be nonnegative.  LVLTRC was set to ', qx%lvltrc
          endif
      else if (varname == 'NDIG') then
          ival = qx%ndig
          call fmndig(nint(dval), qx)
          if (qx%ndig < 3) then
              write (qx%kw,*) ' '
              write (qx%kw,*) ' FMSETVAR:  Input string:  ', string
              write (qx%kw,*) '            ', qx%ndig, ' is an invalid value for NDIG'
              call fmndig(ival, qx)
              write (qx%kw,*) '            It should be > 2.  NDIG was not changed from ', qx%ndig
              qx%kflag = -1
          endif
      else if (varname == 'NTRACE') then
          qx%ntrace = nint(dval)
          if (qx%ntrace < -2 .or. qx%ntrace > 2) then
              write (qx%kw,*) ' '
              write (qx%kw,*) ' FMSETVAR:  Input string:  ', string
              write (qx%kw,*) '            ', qx%ntrace, ' is an invalid value for NTRACE'
              qx%ntrace = 0
              write (qx%kw,*) '            Valid values are -2, -1, 0, 1, 2.  NTRACE was set to ',  &
                           qx%ntrace
          endif
      else if (varname == 'MBASE') then
          mval = qx%mbase
          qx%mbase = aint (0.5 + dval)
          if (qx%mbase < 2) then
              write (qx%kw,*) ' '
              write (qx%kw,*) ' FMSETVAR:  Input string:  ', string
              write (qx%kw,*) '            ', qx%mbase, ' is an invalid value for MBASE'
              qx%mbase = mval
              write (qx%kw,*) '            It should be > 1.  MBASE was not changed from ', qx%mbase
              qx%kflag = -2
          endif
          if (qx%mbase > mxbase) then
              write (qx%kw,*) ' '
              write (qx%kw,*) ' FMSETVAR:  Input string:  ', string
              write (qx%kw,*) '            ', qx%mbase, ' is an invalid value for MBASE'
              qx%mbase = mval
              write (qx%kw,*) '            It should be <= ', mxbase,  &
                           '.  MBASE was not changed from ', qx%mbase
              qx%kflag = -2
          endif
      else if (varname == 'MXEXP') then
          qx%mxexp = aint (dval)
          if (qx%mxexp < 10 .or. qx%mxexp > qx%mxexp2/2.01d0) then
              write (qx%kw,*) ' '
              write (qx%kw,*) ' FMSETVAR:  Input string:  ', string
              write (qx%kw,*) '            ', qx%mxexp, ' is an invalid value for MXEXP'
              qx%mxexp = int(qx%mxexp2/2.01d0)
              write (qx%kw,*) '            Valid values are 10 to ',  &
                           int(qx%mxexp2/2.01d0), '  MXEXP was set to ', qx%mxexp
          endif
      else
          write (qx%kw,*) ' Variable name not recognized in FMSETVAR.'
          write (qx%kw,*) ' Input string:  ', string
          return
      endif

      call fmcons(qx)

      return
      end subroutine fmsetvar

      subroutine fmshi(ma, mb, qx)

!  mb = hyperbolic sine integral(ma)

!  Integral from 0 to ma of sinh(t) / t  dt.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(12), mresult, mretry

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmshi_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      n_acc = nint(qx%ndig*qx%alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmshi_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)
         if (ma%mp(1) == -1) mresult%mp(1) = -1
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry, qx)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmshi

      subroutine fmshi_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)

!  Method selection for computing shi(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(12), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc
      type(fm_settings) :: qx

      double precision :: d, x, xe, y
      integer :: iextra, kflagx, nmethd

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      mxy(1)%mp(1) = 1
      n_acc = nint(qx%ndig*qx%alogm2)

!             x is a double precision approximation to the input argument to this function.

      call fmm2dp(mxy(1), x, qx)
      kflagx = qx%kflag
      call fmovun_xe(mxy(1), xe, qx)
      if (qx%kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif

!             Check for special cases.

      if (mxy(1)%mp(3) == 0) then
          call fmi2m(0, mresult, qx)
          retry = .false.
          return
      else if (mxy(1)%mp(2) == qx%mexpun) then
          call fmeq(mxy(1), mresult, qx)
          retry = .false.
          return
      else if (mxy(1)%mp(2) == qx%mexpov) then
          call fmoverflow(1, mxy(8), qx)
          if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          mxy(8)%mp(4) = huge(qx%mbase)/d
          mxy(8)%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
          qx%kflag = -5
          call fmeq(mxy(8), mresult, qx)
          retry = .false.
          return
      endif

!             If ma is large in magnitude, use more guard digits.

      iextra = min(max(int(mxy(1)%mp(2)), 0) , int(2.0+qx%alogmx/qx%alogmb))
      if (abs(mxy(1)%mp(2)) >= qx%mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
      endif
      call fmndig(qx%ndig + iextra, qx)

!             Determine which method to use.

!             nmethd = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      nmethd = 1
      if (kflagx /= 0) then
          call fmovun_xe(mxy(1), xe, qx)
          if (xe <= 0) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          y = (qx%ndig+5)*qx%dlogmb
          if (abs(x) > y+(qx%dlogtp+log(y))/2.0d0) nmethd = 2
      endif

      if (nmethd == 1) then
          call fmshi_m1(mxy, mresult, ndsave, numtry, kflagx, x, qx)
      else if (nmethd == 2) then
          call fmshi_m2(mxy, mresult, ndsave, numtry, qx)
      endif
      if (ma%mp(1) == -1) call fmnegate(mresult, qx)

      return
      end subroutine fmshi_m

      subroutine fmshi_m1(mxy, mresult, ndsave, numtry, kflagx, x, qx)

!  Method 1 for computing shi(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(12), mresult
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: numtry, ndsave, kflagx, x
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: xe
      integer :: j, j2, kl, large, nbot, ndsav1, nterm
      type(multi) :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 1.  Use the x**(2*n+1)/((2*n+1)*(2*n+1)!) series.

      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig-1), qx)
      endif
      if (kflagx == 0) then
          j2 = int(0.62*sqrt(fmnterms(x, 2, 0, 0, 1, qx)) - 1.3)
          j2 = max(1, min(ljsums, j2))
      else
          j2 = 2
      endif
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums.

      call fmeq(mxy(1), mxy(7), qx)
      call fmeq(mxy(1), mjsums(1), qx)
      nterm = 1
      do j = 2, j2
         nterm = nterm + 2
         nbot = nterm*(nterm-1)
         large = int(intmax/nterm)
         if (nterm > large .or. nbot > mxbase) then
             call fmcsdivi_r1(mxy(7), nterm, qx)
             call fmcsdivi_r1(mxy(7), nterm-1, qx)
         else
             call fmcsdivi_r1(mxy(7), nbot, qx)
         endif
         call fmcsdivi(mxy(7), nterm, mjsums(j), qx)
      enddo
      call fmovun_xe(mxy(1), xe, qx)
      if (xe < -qx%ndig) then
          kl = 0
      else
          kl = 1
          call fmipwr(mxy(1), 2*j2, mxy(5), qx)
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(7), mxy(5), qx)
         do j = 1, j2
            nterm = nterm + 2
            large = int(intmax/nterm)
            if (nterm > large .or. nterm > mxbase/(nterm-1)) then
                call fmcsdivi_r1(mxy(7), nterm, qx)
                call fmcsdivi_r1(mxy(7), nterm-1, qx)
            else
                nbot = nterm*(nterm-1)
                call fmcsdivi_r1(mxy(7), nbot, qx)
            endif
            call fmcsdivi(mxy(7), nterm, mxy(4), qx)
            call fmndig(ndsav1, qx)
            call fmcsaddnn_r1(mjsums(j), mxy(4), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            call fmndig(ndsav1 - int(mjsums(j)%mp(2)-mxy(4)%mp(2)), qx)
            call fmndig(min(ndsav1, qx%ndig), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         enddo
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmcsnsums(j2, mjsums, qx)
      call fmeq(mjsums(j2), mxy(8), qx)
      if (j2 >= 2) then
          call fmsqr(mxy(1), mxy(6), qx)
          do j = 2, j2
             call fmcsmpy_r1(mxy(8), mxy(6), qx)
             call fmadd_r1(mxy(8), mjsums(j2-j+1), qx)
          enddo
      endif

      call fmeq(mxy(8), mresult, qx)

      return
      end subroutine fmshi_m1

      subroutine fmshi_m2(mxy, mresult, ndsave, numtry, qx)

!  Method 2 for computing shi(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(12), mresult
      integer :: ndsave, numtry
      intent (in) :: ndsave, numtry
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

!             Method 2.  Use the two n!/x**n asymptotic series for f(x) and g(x).
!                        Then Shi(x) = f(x)*cosh(x) + g(x)*sinh(x).

      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig-2), qx)
      endif
      call fmfhgh(mxy(1), mxy(9), mxy(10), qx)
      call fmchsh(mxy(1), mxy(11), mxy(12), qx)
      if (mxy(11)%mp(2) < qx%mexpov) then
          call fmmpy(mxy(9), mxy(11), mxy(2), qx)
          call fmmpy(mxy(10), mxy(12), mxy(3), qx)
          call fmadd(mxy(2), mxy(3), mxy(8), qx)
      else
          call fmadd(mxy(9), mxy(10), mxy(5), qx)
          call fmdivi_r1(mxy(5), 2, qx)
          call fmln(mxy(5), mxy(8), qx)
          qx%ndigli = 0
          call fmadd(mxy(1), mxy(8), mxy(5), qx)
          call fmexp(mxy(5), mxy(8), qx)
          qx%ndige = 0
      endif

      call fmeq(mxy(8), mresult, qx)

      return
      end subroutine fmshi_m2

      subroutine fmshi_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = shi(ma).

!  kresult = 1 is returned if a special case gives the value of shi(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(12), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j, k, kl, krsave, nds
      double precision :: xe, ye
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMSHI    '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      k = 0
      if (qx%kround /= 1) then
          j = qx%ntrace
          qx%ntrace = 0
          kl = qx%kwarn
          qx%kwarn = 0
          call fmsqr(malocal, mxy(1), qx)
          call fmdivi(mxy(1), 18, mxy(2), qx)
          call fmovun_xe(mxy(2), xe, qx)
          if (xe < -qx%ndig) k = 1
          qx%ntrace = j
          qx%kwarn = kl
      endif
      if (qx%kround /= 1 .and. k == 1) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          krsave = qx%kround
          qx%kround = 1
          nds = qx%ndig
          call fmndig(qx%ndig + qx%ngrd52, qx)
          call fmequ(malocal, mxy(1), nds, qx%ndig, qx)
          call fmsqr(mxy(1), mxy(2), qx)
          call fmmpy(mxy(1), mxy(2), mxy(3), qx)
          call fmdivi(mxy(3), 18, mxy(5), qx)
          call fmeq(mxy(1), mxy(4), qx)
          call fmovun_xe(mxy(4), xe, qx)
          call fmovun_xe(mxy(5), ye, qx)
          if (xe - ye > qx%ndig .and. mxy(4)%mp(2) > qx%mexpun) then
              call fmequ(mxy(4), mxy(10), qx%ndig, nds, qx)
              call fmequ(mxy(4), mxy(6), qx%ndig, nds, qx)
              call fmequ(mxy(6), mxy(8), nds, qx%ndig, qx)
              call fmsub(mxy(4), mxy(8), mxy(6), qx)
              if (mxy(6)%mp(3) == 0) then
                  call fmequ(mxy(4), mxy(6), qx%ndig, nds, qx)
                  call fmequ(mxy(5), mxy(7), qx%ndig, nds, qx)
                  call fmndig(nds, qx)
                  qx%kround = krsave
                  call fmadd(mxy(6), mxy(7), mxy(9), qx)
                  if (mxy(9)%mp(2) >= qx%mexpov) then
                      if (mxy(6)%mp(1) > 0) then
                          if (mxy(7)%mp(1) < 0 .and. (qx%kround == -1 .or. qx%kround == 0)) then
                              call fmeq(mxy(6), mxy(1), qx)
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2), qx)
                              call fmsub(mxy(1), mxy(2), mxy(3), qx)
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mxy(9), qx)
                          else if (mxy(7)%mp(1) > 0 .and. qx%kround == 2) then
                              call fmeq(mxy(6), mxy(1), qx)
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2), qx)
                              call fmadd(mxy(1), mxy(2), mxy(3), qx)
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mxy(9), qx)
                          else
                              qx%kround = krsave
                              call fmeq(mxy(10), mxy(9), qx)
                          endif
                      else
                          if (mxy(7)%mp(1) < 0 .and. qx%kround == -1) then
                              call fmeq(mxy(6), mxy(1), qx)
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2), qx)
                              call fmadd(mxy(1), mxy(2), mxy(3), qx)
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mxy(9), qx)
                          else if (mxy(7)%mp(1) > 0 .and. (qx%kround == 2 .or. qx%kround == 0)) then
                              call fmeq(mxy(6), mxy(1), qx)
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2), qx)
                              call fmsub(mxy(1), mxy(2), mxy(3), qx)
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mxy(9), qx)
                          else
                              qx%kround = krsave
                              call fmeq(mxy(10), mxy(9), qx)
                          endif
                      endif
                  endif
                  call fmequ(mxy(9), mresult, qx%ndig, nds, qx)
              else
                  qx%kround = krsave
                  call fmequ(mxy(4), mresult, qx%ndig, nds, qx)
              endif
              if (ma%mp(1) == -1) mresult%mp(1) = -1
              qx%kflag = 0
              qx%ntrace = j
              qx%kwarn = k
              call fmndig(nds, qx)
              qx%kround = krsave
              kresult = 1
              return
          endif
          qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          call fmndig(nds, qx)
          qx%kround = krsave
      endif

      return
      end subroutine fmshi_sc

      subroutine fmsi(ma, mb, qx)

!  mb = sine integral(ma)

!  Integral from 0 to ma of sin(t) / t  dt.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(13), mresult, mretry

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmenter_sp(ndsave, qx)
      call fmsi_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      n_acc = nint(qx%ndig*qx%alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmsi_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)
         if (ma%mp(1) < 0) mresult%mp(1) = -1
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry, qx)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmsi

      subroutine fmsi_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc, qx)

!  Method selection for computing shi(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc
      type(fm_settings) :: qx

      double precision :: x, xe, y
      integer :: iextra, kflagx, nmethd

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      mxy(1)%mp(1) = 1
      n_acc = nint(qx%ndig*qx%alogm2)

!             x is a double precision approximation to the input argument to this function.

      call fmm2dp(mxy(1), x, qx)
      kflagx = qx%kflag
      call fmovun_xe(mxy(1), xe, qx)
      if (qx%kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif

!             Check for special cases.

      if (mxy(1)%mp(3) == 0) then
          call fmi2m(0, mresult, qx)
          retry = .false.
          return
      else if (mxy(1)%mp(2) == qx%mexpun) then
          call fmeq(mxy(1), mresult, qx)
          retry = .false.
          return
      else if (xe > qx%ndig) then
          call fmpi(mresult, qx)
          qx%ndigpi = 0
          call fmdivi_r1(mresult, 2, qx)
          return
      endif

!             If ma is large in magnitude, use more guard digits.

      iextra = min(max(int(mxy(1)%mp(2)), 0) , int(2.0+qx%alogmx/qx%alogmb))
      if (abs(mxy(1)%mp(2)) >= qx%mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
      endif
      call fmndig(qx%ndig + iextra, qx)
      n_acc = nint(qx%ndig*qx%alogm2)

!             Determine which method to use.

!             nmethd = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      nmethd = 1
      if (kflagx /= 0) then
          call fmovun_xe(mxy(1), xe, qx)
          if (xe <= 0) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          y = (qx%ndig+5)*qx%dlogmb
          if (abs(x) > y+(qx%dlogtp+log(y))/2.0d0) nmethd = 2
      endif

      if (nmethd == 1) then
          call fmsi_m1(mxy, mresult, numtry, n_acc, kflagx, x, qx)
      else if (nmethd == 2) then
          call fmsi_m2(mxy, mresult, n_acc, qx)
      endif

      return
      end subroutine fmsi_m

      subroutine fmsi_m1(mxy, mresult, numtry, n_acc, kflagx, x, qx)

!  Method 1 for computing shi(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(13), mresult
      integer :: numtry, n_acc, kflagx
      double precision :: x
      intent (in) :: numtry, kflagx, x
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      double precision :: xe, y
      integer :: iextra, j, j2, k, kl, large, nbot, ndsav1, nterm
      type(multi) :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 1.  Use the (-1)**n*x**(2*n+1)/((2*n+1)*(2*n+1)!) series.

      iextra = 0
      if (kflagx == 0) then
          y = nint(abs(x)/2)
          y = 2*y*log(abs(x)+1.0e-9) - log(2*y+1.0e-9) - (2*y+0.5)*log(2*y+1) + 2*y
          y = 1.03*y/qx%dlogmb - 7/qx%alogmt
          iextra = max(0, int(y+1))
          if (abs(x) < 5 .and. numtry <= 0) then
              call fmndig(qx%ndig - 2, qx)
              iextra = 0
          endif
      endif
      if (iextra > 0) then
          call fmequ_r1(mxy(1), qx%ndig, qx%ndig+iextra, qx)
      endif
      call fmndig(qx%ndig + iextra, qx)
      n_acc = nint(qx%ndig*qx%alogm2)

      if (kflagx == 0) then
          j2 = int(0.64*sqrt(fmnterms(x, 2, 0, 0, 1, qx)) - 1.4)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums.

      call fmeq(mxy(1), mxy(7), qx)
      call fmeq(mxy(1), mjsums(1), qx)
      nterm = 1
      do j = 2, j2
         nterm = nterm + 2
         large = int(intmax/nterm)
         nbot = nterm*(nterm-1)
         if (nterm > large .or. nbot > mxbase) then
             call fmcsdivi_r1(mxy(7), nterm, qx)
             nbot = nterm - 1
             call fmcsdivi_r1(mxy(7), nbot, qx)
         else
             call fmcsdivi_r1(mxy(7), nbot, qx)
         endif
         call fmcsdivi(mxy(7), nterm, mjsums(j), qx)
      enddo
      call fmovun_xe(mxy(1), xe, qx)
      if (xe < -qx%ndig) then
          kl = 0
      else
          kl = 1
          call fmipwr(mxy(1), 2*j2, mxy(5), qx)
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(7), mxy(5), qx)
         do j = 1, j2
            nterm = nterm + 2
            large = int(intmax/nterm)
            if (nterm > large .or. nterm > mxbase/(nterm-1)) then
                call fmcsdivi_r1(mxy(7), nterm, qx)
                nbot = nterm - 1
                call fmcsdivi_r1(mxy(7), nbot, qx)
            else
                nbot = nterm*(nterm-1)
                call fmcsdivi_r1(mxy(7), nbot, qx)
            endif
            call fmcsdivi(mxy(7), nterm, mxy(4), qx)
            call fmndig(ndsav1, qx)
            call fmcsaddnn_r1(mjsums(j), mxy(4), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            call fmndig(ndsav1 - int(mjsums(j)%mp(2)-mxy(4)%mp(2)), qx)
            call fmndig(min(ndsav1, qx%ndig), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         enddo
         if (kl == 0) exit
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmcsnsums(j2, mjsums, qx)
      call fmsqr(mxy(1), mxy(5), qx)
      mxy(5)%mp(1) = -1
      call fmsqr(mxy(1), mxy(5), qx)
      mxy(5)%mp(1) = -1
      if (mjsums(1)%mp(1) > 0) then
          call fmeq(mjsums(1), mxy(12), qx)
          call fmi2m(0, mxy(13), qx)
      else
          call fmeq(mjsums(1), mxy(13), qx)
          call fmi2m(0, mxy(12), qx)
      endif
      call fmeq(mxy(5), mxy(7), qx)
      do j = 1, j2-1
         call fmmpy(mxy(7), mjsums(j+1), mxy(3), qx)
         if (mxy(3)%mp(1) > 0) then
             call fmadd_r1(mxy(12), mxy(3), qx)
         else
             call fmadd_r1(mxy(13), mxy(3), qx)
         endif
         call fmmpy_r1(mxy(7), mxy(5), qx)
      enddo
      call fmadd(mxy(12), mxy(13), mxy(8), qx)
      call fmcancel(mxy(12), mxy(13), mxy(8), k, qx)
      n_acc = n_acc - k

      call fmeq(mxy(8), mresult, qx)

      return
      end subroutine fmsi_m1

      subroutine fmsi_m2(mxy, mresult, n_acc, qx)

!  Method 2 for computing shi(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(13), mresult
      integer :: n_acc
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      integer :: krsave

!             Method 2.  Use the two n!/x**n asymptotic series for f(x) and g(x).
!                        Then Si(x) = pi/2 - f(x)*cos(x) - g(x)*sin(x).

      call fmfxgx(mxy(1), mxy(10), mxy(11), qx)
      n_acc = nint(qx%ndig*qx%alogm2)
      krsave = qx%krad
      qx%krad = 1
      call fmcssn(mxy(1), mxy(12), mxy(13), qx)
      qx%krad = krsave
      if (mxy(1)%mp(2) == qx%munkno .and. mxy(1)%mp(5) < 0 .and.        &
          ( (mxy(12)%mp(2) == qx%munkno .and. mxy(12)%mp(5) >= 0) .or.  &
            (mxy(13)%mp(2) == qx%munkno .and. mxy(13)%mp(5) >= 0) )) then
          call fmunknown(mxy(8), qx)
          mxy(8)%mp(4) = 1
          mxy(8)%mp(5) = -maxint * (1.570796326794897d0) / qx%mbase
      else
          call fmpi(mxy(9), qx)
          qx%ndigpi = 0
          if (mxy(12)%mp(2) == qx%munkno .or. mxy(13)%mp(2) == qx%munkno) then
              call fmmpyi(mxy(9), 2, mxy(8), qx)
              call fmdiv(mxy(1), mxy(8), mxy(3), qx)
              call fmint(mxy(3), mxy(2), qx)
              call fmmpy(mxy(2), mxy(8), mxy(3), qx)
              call fmsub(mxy(1), mxy(3), mxy(8), qx)
              krsave = qx%krad
              qx%krad = 1
              call fmcssn(mxy(8), mxy(12), mxy(13), qx)
              qx%krad = krsave
          endif
          call fmdivi(mxy(9), 2, mxy(2), qx)
          call fmmpy(mxy(10), mxy(12), mxy(3), qx)
          call fmsub_r1(mxy(2), mxy(3), qx)
          call fmmpy(mxy(11), mxy(13), mxy(3), qx)
          call fmsub(mxy(2), mxy(3), mxy(8), qx)
      endif

      call fmeq(mxy(8), mresult, qx)

      return
      end subroutine fmsi_m2

      subroutine fmsi_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = shi(ma).

!  kresult = 1 is returned if a special case gives the value of shi(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      integer :: j, k, kl, krsave, nds
      double precision :: xe, ye
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMSI     '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      k = 0
      if (qx%kround /= 1) then
          j = qx%ntrace
          qx%ntrace = 0
          kl = qx%kwarn
          qx%kwarn = 0
          call fmsqr(malocal, mxy(1), qx)
          call fmdivi(mxy(1), 18, mxy(2), qx)
          call fmovun_xe(mxy(2), xe, qx)
          if (xe < -qx%ndig) k = 1
          qx%ntrace = j
          qx%kwarn = kl
      endif
      if (qx%kround /= 1 .and. k == 1) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          krsave = qx%kround
          qx%kround = 1
          nds = qx%ndig
          call fmndig(qx%ndig + qx%ngrd52, qx)
          call fmequ(malocal, mxy(1), nds, qx%ndig, qx)
          call fmsqr(mxy(1), mxy(2), qx)
          call fmmpy(mxy(1), mxy(2), mxy(3), qx)
          call fmdivi(mxy(3), -18, mxy(5), qx)
          call fmeq(mxy(1), mxy(4), qx)
          call fmovun_xe(mxy(4), xe, qx)
          call fmovun_xe(mxy(5), ye, qx)
          if (xe - ye > qx%ndig .and. mxy(4)%mp(2) > qx%mexpun) then
              call fmequ(mxy(4), mxy(10), qx%ndig, nds, qx)
              call fmequ(mxy(4), mxy(6), qx%ndig, nds, qx)
              call fmequ(mxy(6), mxy(8), nds, qx%ndig, qx)
              call fmsub(mxy(4), mxy(8), mxy(6), qx)
              if (mxy(6)%mp(3) == 0) then
                  call fmequ(mxy(4), mxy(6), qx%ndig, nds, qx)
                  call fmequ(mxy(5), mxy(7), qx%ndig, nds, qx)
                  call fmndig(nds, qx)
                  qx%kround = krsave
                  call fmadd(mxy(6), mxy(7), mresult, qx)
                  if (mresult%mp(2) >= qx%mexpov) then
                      if (mxy(6)%mp(1) > 0) then
                          if (mxy(7)%mp(1) < 0 .and. (qx%kround == -1 .or. qx%kround == 0)) then
                              call fmeq(mxy(6), mxy(1), qx)
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2), qx)
                              call fmsub(mxy(1), mxy(2), mxy(3), qx)
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mresult, qx)
                          else if (mxy(7)%mp(1) > 0 .and. qx%kround == 2) then
                              call fmeq(mxy(6), mxy(1), qx)
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2), qx)
                              call fmadd(mxy(1), mxy(2), mxy(3), qx)
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mresult, qx)
                          else
                              qx%kround = krsave
                              call fmeq(mxy(10), mresult, qx)
                          endif
                      else
                          if (mxy(7)%mp(1) < 0 .and. qx%kround == -1) then
                              call fmeq(mxy(6), mxy(1), qx)
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2), qx)
                              call fmadd(mxy(1), mxy(2), mxy(3), qx)
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mresult, qx)
                          else if (mxy(7)%mp(1) > 0 .and. (qx%kround == 2 .or. qx%kround == 0)) then
                              call fmeq(mxy(6), mxy(1), qx)
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2), qx)
                              call fmsub(mxy(1), mxy(2), mxy(3), qx)
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mresult, qx)
                          else
                              qx%kround = krsave
                              call fmeq(mxy(10), mresult, qx)
                          endif
                      endif
                  endif
              else
                  qx%kround = krsave
                  call fmequ(mxy(4), mresult, qx%ndig, nds, qx)
              endif
              qx%ntrace = j
              qx%kwarn = k
              call fmndig(nds, qx)
              qx%kround = krsave
              if (ma%mp(1) < 0) mresult%mp(1) = -1
              kresult = 1
              return
          endif
          qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          call fmndig(nds, qx)
          qx%kround = krsave
      endif

      return
      end subroutine fmsi_sc

      subroutine fmsign(ma, mb, mc, qx)

!  mc = sign(ma, mb)

!  mc is set to abs(ma) if mb is positive or zero, or -abs(ma) if mb is negative.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: kwrnsv

      call fmalloc(mc, qx%ndig+2, qx)

      qx%kflag = 0
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMSIGN'
      if (qx%ntrace /= 0) call fmntr_inp2(ma, mb, qx)

      kwrnsv = qx%kwarn
      qx%kwarn = 0
      if ((ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == qx%munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc, qx)
          qx%kflag = -4
      else if (mb%mp(1) >= 0) then
          call fmeq(ma, mc, qx)
          mc%mp(1) = 1
      else
          call fmeq(ma, mc, qx)
          if (mc%mp(3) /= 0) mc%mp(1) = -1
      endif

      qx%kwarn = kwrnsv
      if (qx%ntrace /= 0) call fmntr_out1(mc, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmsign

      subroutine fmsin(ma, mb, qx)

!  mb = sin(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(6), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmsin_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call fmsin_m1(ma, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmsin

      subroutine fmsin2(ma, mb, qx)

!  Internal subroutine for mb = sin(ma) where 0 <= ma <= 1.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: maxv
      integer :: j, j2, k, k2, kl, ks, kthree, kwrnsv, l, l2, large, n2, nbot, ndsav1, ndsave, nterm
      real :: alog3, alogt, b, t, tj
      type(multi) :: mxy(3), mjsums(ljsums)

      call fmalloc(mb, qx%ndig+2, qx)

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      if (ma%mp(3) == 0) then
          call fmeq(ma, mb, qx)
          return
      endif
      ndsave = qx%ndig
      kwrnsv = qx%kwarn
      qx%kwarn = 0

!             Use the direct series
!                  sin(x) = x - x**3/3! + x**5/5! - ...

!             The argument will be divided by 3**k2 before the series is summed.  The series will be
!             added as j2 concurrent series.

      b = real(qx%mbase)
      k = qx%ngrd52
      t = max(qx%ndig-k, 2)
      alog3 = log(3.0)
      alogt = log(t)
      tj = 0.55*(qx%ndig*qx%alogmt)**0.3333
      j2 = int(tj)
      j2 = max(2, min(j2+mod(j2, 2), ljsums))
      k2 = max(1, int(0.62*(qx%ndig*qx%alogmt)**0.3333 - 0.8))

      tj = -(real(ma%mp(2))*qx%alogmb +  &
             log(real(ma%mp(3))/b + real(ma%mp(4))/(b*b)))/alog3 - 0.3
      if (tj >= k2) then
          l = k2
      else if (tj > 0) then
          l = int(tj)
      else
          l = 0
      endif
      k2 = k2 - l
      if (k2 <= 0) then
          k2 = 0
          j2 = int(.43*sqrt(t*qx%alogmb/(alogt+real(l)*alog3)) + .33)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      endif

      n2 = int(t*qx%alogmb/(alogt+real(l)*alog3))
      l2 = int((log(1+real(n2)/3.0d0**k2)+k2*log(3.0d0))/qx%alogmb)
      call fmndig(qx%ndig + l2, qx)
      ndsav1 = qx%ndig

!             Divide the argument by 3**k2.

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      kthree = 1
      maxv = mxbase/3
      if (k2 > 0) then
          do j = 1, k2
             kthree = 3*kthree
             if (kthree > maxv) then
                 call fmcsdivi_r1(mxy(1), kthree, qx)
                 kthree = 1
             endif
          enddo
          if (kthree > 1) call fmcsdivi_r1(mxy(1), kthree, qx)
      endif

!             Split into j2 concurrent sums and reduce ndig while computing each term in the sum
!             as the terms get smaller.

      call fmi2m(1, mjsums(1), qx)
      call fmi2m(1, mxy(2), qx)
      nterm = 3
      do j = 2, j2
         nbot = nterm*(nterm-1)
         call fmcsdivi_r1(mxy(2), nbot, qx)
         call fmeq(mxy(2), mjsums(j), qx)
         nterm = nterm + 2
      enddo
      ks = 0
      if (mxy(1)%mp(2) < -qx%ndig) then
          ks = 1
      else
          call fmipwr(mxy(1), 2*j2, mxy(3), qx)
          if (mxy(3)%mp(2) < -qx%ndig) ks = 1
      endif

      if (ks == 0) then
          kl = 1
          do while (kl == 1)
             call fmcsmpy_r1(mxy(2), mxy(3), qx)
             do j = 1, j2
                large = int(intmax/nterm)
                if (nterm > large .or. nterm > mxbase/(nterm-1)) then
                    call fmcsdivi_r1(mxy(2), nterm, qx)
                    nbot = nterm - 1
                    call fmcsdivi_r1(mxy(2), nbot, qx)
                else
                    nbot = nterm*(nterm-1)
                    call fmcsdivi_r1(mxy(2), nbot, qx)
                endif
                call fmndig(ndsav1, qx)
                call fmcsaddnn_r1(mjsums(j), mxy(2), qx)
                if (qx%kflag /= 0) then
                     kl = 0
                     exit
                 endif
                call fmndig(ndsav1 - int(mjsums(j)%mp(2)-mxy(2)%mp(2)), qx)
                if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                nterm = nterm + 2
             enddo
          enddo
      endif

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmcsnsums(j2, mjsums, qx)
      call fmsqr(mxy(1), mxy(2), qx)
      call fmnegate(mxy(2), qx)
      call fmeq(mjsums(j2), mxy(3), qx)
      do j = 2, j2
         call fmcsmpy_r1(mxy(3), mxy(2), qx)
         call fmadd_r1(mxy(3), mjsums(j2-j+1), qx)
      enddo
      call fmcsmpy_r1(mxy(3), mxy(1), qx)

!             Reverse the effect of reducing the argument to compute sin(ma).

      call fmndig(ndsav1, qx)
      if (k2 > 0) then
          call fmi2m(3, mxy(1), qx)
          do j = 1, k2
             call fmsqr(mxy(3), mxy(2), qx)
             call fmcsmpyi_r1(mxy(2), -4, qx)
             call fmadd_r2(mxy(1), mxy(2), qx)
             call fmcsmpy_r1(mxy(3), mxy(2), qx)
          enddo
      endif

      call fmequ(mxy(3), mb, ndsav1, ndsave, qx)
      qx%ndig = ndsave
      qx%kwarn = kwrnsv

      return
      end subroutine fmsin2

      subroutine fmsin_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing sin(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(6), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: jcos, jsin, jswap, kwrnsv, ndsv

      qx%ndigpi = 0
      qx%mbspi = 0
      call fmequ(ma, mxy(6), ndsave, qx%ndig, qx)
      mxy(6)%mp(1) = 1
      call fmeq(mxy(6), mxy(5), qx)
      if (ma%mp(2) > 3*10**5 .and. qx%krad == 1) then
          call fmunknown(mresult, qx)
          return
      endif

!             Reduce the argument, convert to radians if the input is in degrees, and evaluate
!             the function.

      kwrnsv = qx%kwarn
      qx%kwarn = 0
      call fmrdc(mxy(6), jsin, jcos, jswap, qx)
      if (qx%kround /= 1 .and. qx%krad /= 1) then
          call fmi2m(30, mxy(1), qx)
          call fmsub(mxy(6), mxy(1), mxy(2), qx)
          if (mxy(2)%mp(3) == 0 .and. jswap == 0) then
              call fmst2m('0.5', mxy(1), qx)
              call fmmpyi(mxy(1), jsin, mresult, qx)
              if (ma%mp(1) < 0) call fmnegate(mresult, qx)
              return
          endif
      endif
      qx%kwarn = kwrnsv
      if (mxy(6)%mp(2) == qx%munkno) then
          if (qx%krad /= 1 .or. jswap == 0) then
              call fmeq(mxy(5), mresult, qx)
              call fmrdc(mresult, jsin, jcos, jswap, qx)
              if (ma%mp(1) < 0) call fmnegate(mresult, qx)
              return
          endif
          if (qx%mbspi /= qx%mbase .or. qx%ndigpi < qx%ndig) then
              ndsv = qx%ndig
              call fmndig(qx%ndig + 2, qx)
              call fmpi(mxy(3), qx)
              qx%ndigpi = 0
              call fmndig(ndsv, qx)
          endif
          call fmpi(mxy(4), qx)
          qx%ndigpi = 0
          call fmdiv(mxy(5), mxy(4), mxy(3), qx)
          call fmmpyi_r1(mxy(3), 2, qx)
          call fmnint(mxy(3), mxy(2), qx)
          call fmmpy(mxy(2), mxy(4), mxy(1), qx)
          call fmdivi_r1(mxy(1), 2, qx)
          call fmsub_r2(mxy(5), mxy(1), qx)
          if (mxy(1)%mp(3) == 0) call fmulp(mxy(5), mxy(1), qx)
          call fmi2m(1, mxy(3), qx)
          call fmsqr_r1(mxy(1), qx)
          call fmdivi_r1(mxy(1), 2, qx)
          call fmsub_r2(mxy(3), mxy(1), qx)
          call fmsub_r1(mxy(1), mxy(3), qx)
          if (mxy(1)%mp(3) == 0) then
              call fmi2m(jsin, mxy(6), qx)
          else
              call fmeq(mxy(5), mxy(6), qx)
              call fmrdc(mxy(6), jsin, jcos, jswap, qx)
          endif
          call fmeq(mxy(6), mresult, qx)
          if (ma%mp(1) < 0) call fmnegate(mresult, qx)
          return
      endif
      if (qx%krad == 0) then
          if (qx%mbspi /= qx%mbase .or. qx%ndigpi < qx%ndig) then
              ndsv = qx%ndig
              call fmndig(qx%ndig + 2, qx)
              call fmpi(mxy(4), qx)
              qx%ndigpi = 0
              call fmndig(ndsv, qx)
          endif
          call fmpi(mxy(4), qx)
          qx%ndigpi = 0
          call fmmpy_r1(mxy(6), mxy(4), qx)
          call fmdivi_r1(mxy(6), 180, qx)
      endif
      if (mxy(6)%mp(2) /= qx%munkno) then
          if (jswap == 0) then
              if (mxy(6)%mp(2) < 0 .or. qx%ndig <= 50) then
                  call fmsin2(mxy(6), mxy(4), qx)
                  call fmeq(mxy(4), mxy(6), qx)
              else
                  call fmcos2(mxy(6), mxy(4), qx)
                  call fmi2m(1, mxy(2), qx)
                  call fmsqr_r1(mxy(4), qx)
                  call fmsub_r2(mxy(2), mxy(4), qx)
                  call fmsqrt(mxy(4), mxy(6), qx)
              endif
          else
              call fmcos2(mxy(6), mxy(4), qx)
              call fmeq(mxy(4), mxy(6), qx)
          endif
      endif
      call fmeq(mxy(6), mresult, qx)
      if (jsin == -1) call fmnegate(mresult, qx)
      if (ma%mp(1) < 0) call fmnegate(mresult, qx)

      return
      end subroutine fmsin_m1

      subroutine fmsin_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = sin(ma).

!  kresult = 1 is returned if a special case gives the value of sin(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(6), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      double precision :: b, pi, x, xe, xf
      integer :: j, k
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMSIN    '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (malocal%mp(2) == qx%munkno) then
          if (malocal%mp(5) < 0) then
              call fmovun_xexf(malocal, xe, xf, qx)
              if (2*xe < -ndsave) then
                  if (qx%krad == 1) then
                      call fmeq(malocal, mresult, qx)
                  else
                      call fmpi(mxy(2), qx)
                      qx%ndigpi = 0
                      call fmmpy_r2(malocal, mxy(2), qx)
                      call fmdivi(mxy(2), 180, mresult, qx)
                  endif
              else
                  call fmunknown(mresult, qx)
                  if (xe*qx%dlogmb+log(xf) < log(1.0d+12)) then
                      b = qx%mbase
                      if (qx%krad == 1) then
                          x = sin(xf*b**xe)
                      else
                          pi = acos(-1.0d0)
                          x = sin(pi*xf*b**xe/180.0d0)
                      endif
                      if (malocal%mp(1) < 0) x = -x
                      if (x < 0) then
                          mresult%mp(1) = -1
                          x = -x
                      endif
                      if (x == 1.0d0) then
                          xe = 1
                          xf = 1/b
                      else
                          xe = 0
                          xf = x
                      endif
                      do j = 1, 5
                         if (xf >= 1) then
                             xe = xe + 1
                             xf = xf / b
                         else if (xf < 1.0d0/b) then
                             xe = xe - 1
                             xf = xf * b
                         else
                             exit
                         endif
                      enddo
                      mresult%mp(4) = xe
                      mresult%mp(5) = -xf*maxint
                  endif
              endif
          else
              call fmunknown(mresult, qx)
          endif
          kresult = 1
          return
      endif
      if (malocal%mp(2) == qx%mexpun) then
          call fmeq(malocal, mresult, qx)
          if (qx%krad == 0) then
              call fmdivi(mresult, 180, mxy(2), qx)
              call fmpi(mxy(1), qx)
              qx%ndigpi = 0
              call fmmpy(mxy(2), mxy(1), mresult, qx)
          endif
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (qx%kround /= 1 .and. malocal%mp(2) < -ndsave .and. qx%krad == 1) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          call fmsqr(malocal, mxy(1), qx)
          call fmmpy(mxy(1), malocal, mxy(2), qx)
          call fmdivi(mxy(2), -6, mxy(3), qx)
          if (mxy(3)%mp(2) > qx%mexpun) then
              call fmadd(malocal, mxy(3), mresult, qx)
          else if (malocal%mp(2) == qx%mexpun) then
              call fmeq(malocal, mresult, qx)
          else if (malocal%mp(1) < 0 .and. (qx%kround == 2 .or. qx%kround == 0)) then
              call fmeq(malocal, mxy(1), qx)
              mxy(1)%mp(2) = 0
              call fmulp(mxy(1), mxy(2), qx)
              call fmsub(mxy(1), mxy(2), mxy(3), qx)
              mxy(3)%mp(2) = malocal%mp(2) + mxy(3)%mp(2)
              call fmeq(mxy(3), mresult, qx)
          else if (malocal%mp(1) >= 0 .and. (qx%kround == -1 .or. qx%kround == 0)) then
              call fmeq(malocal, mxy(1), qx)
              mxy(1)%mp(2) = 0
              call fmulp(mxy(1), mxy(2), qx)
              call fmsub(mxy(1), mxy(2), mxy(3), qx)
              mxy(3)%mp(2) = malocal%mp(2) + mxy(3)%mp(2)
              call fmeq(mxy(3), mresult, qx)
          else
              call fmeq(malocal, mresult, qx)
          endif
          if (qx%kflag > 0) qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          kresult = 1
      endif

      return
      end subroutine fmsin_sc

      subroutine fmsinh(ma, mb, qx)

!  mb = sinh(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(5), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmsinh_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call fmsinh_m1(ma, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmsinh

      subroutine fmsinh_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing sinh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: nmethd

      call fmequ(ma, mxy(3), ndsave, qx%ndig, qx)
      mxy(3)%mp(1) = 1

!             Use a series for small arguments, fmexp for large ones.

      if (qx%mbase > 99) then
          if (mxy(3)%mp(2) <= 0) then
              nmethd = 1
          else if (mxy(3)%mp(2) >= 2) then
              nmethd = 2
          else if (abs(mxy(3)%mp(3)) < 10) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          if (mxy(3)%mp(2) <= 0) then
              nmethd = 1
          else
              nmethd = 2
          endif
      endif

      if (nmethd == 1) then
          if (mxy(3)%mp(2) < 0 .or. qx%ndig <= 50) then
              call fmsinh2(mxy(3), mxy(4), qx)
              call fmeq(mxy(4), mxy(3), qx)
          else
              call fmcosh2(mxy(3), mxy(4), qx)
              call fmi2m(1, mxy(2), qx)
              call fmsqr_r1(mxy(4), qx)
              call fmsub_r1(mxy(4), mxy(2), qx)
              call fmsqrt(mxy(4), mxy(3), qx)
          endif
      else
          call fmexp(mxy(3), mxy(5), qx)
          qx%ndige = 0
          call fmeq(mxy(5), mxy(3), qx)
          if (mxy(3)%mp(2) == qx%mexpov) then
              if (ma%mp(1) < 0) call fmnegate(mxy(3), qx)
              call fmeq(mxy(3), mresult, qx)
              return
          else if (mxy(3)%mp(2) == qx%mexpun) then
              mxy(3)%mp(2) = qx%mexpov
              if (ma%mp(1) < 0) call fmnegate(mxy(3), qx)
              call fmeq(mxy(3), mresult, qx)
              return
          endif
          if (int(mxy(3)%mp(2)) <= (qx%ndig+1)/2) then
              call fmi2m(1, mxy(1), qx)
              call fmdiv_r1(mxy(1), mxy(3), qx)
              call fmsub_r1(mxy(3), mxy(1), qx)
          endif
          call fmdivi_r1(mxy(3), 2, qx)
      endif
      if (ma%mp(1) < 0) call fmnegate(mxy(3), qx)
      call fmeq(mxy(3), mresult, qx)

      return
      end subroutine fmsinh_m1

      subroutine fmsinh_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = sinh(ma).

!  kresult = 1 is returned if a special case gives the value of sinh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      double precision :: xe
      integer :: j, k
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMSINH   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0) then
          call fmi2m(0, mresult, qx)
          kresult = 1
          return
      endif
      if (malocal%mp(2) == qx%munkno) then
          if (malocal%mp(5) < 0) then
              call fmovun_xe(malocal, xe, qx)
              if (2*xe < -ndsave) then
                  call fmeq(malocal, mxy(1), qx)
                  call fmsqr(malocal, mxy(2), qx)
                  call fmmpy_r1(mxy(2), mxy(1), qx)
                  call fmdivi_r1(mxy(2), 6, qx)
                  call fmadd(mxy(1), mxy(2), mresult, qx)
              else
                  call fmexp(malocal, mxy(2), qx)
                  qx%ndige = 0
                  call fmi2m(1, mxy(1), qx)
                  call fmdiv_r1(mxy(1), mxy(2), qx)
                  call fmsub_r2(mxy(2), mxy(1), qx)
                  call fmdivi(mxy(1), 2, mresult, qx)
              endif
          else
              call fmunknown(mresult, qx)
          endif
          kresult = 1
          return
      endif
      if (malocal%mp(2) == qx%mexpov) then
          k = malocal%mp(1)
          call fmabs(malocal, mxy(1), qx)
          call fmexp(mxy(1), mresult, qx)
          qx%ndige = 0
          if (k < 0) mresult%mp(1) = -1
          kresult = 1
          return
      endif
      if (malocal%mp(2) == qx%mexpun) then
          call fmeq(malocal, mresult, qx)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (qx%kround /= 1 .and. malocal%mp(2) < -ndsave) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          call fmsqr(malocal, mxy(1), qx)
          call fmmpy(mxy(1), malocal, mxy(2), qx)
          call fmdivi(mxy(2), 6, mxy(3), qx)
          if (mxy(3)%mp(2) > qx%mexpun) then
              call fmadd(malocal, mxy(3), mresult, qx)
          else if (malocal%mp(2) == qx%mexpun) then
              call fmeq(malocal, mresult, qx)
          else if (malocal%mp(1) < 0 .and. qx%kround == -1) then
              call fmeq(malocal, mxy(1), qx)
              mxy(1)%mp(2) = 0
              call fmulp(mxy(1), mxy(2), qx)
              call fmadd(mxy(1), mxy(2), mresult, qx)
              mresult%mp(2) = malocal%mp(2) + mresult%mp(2)
          else if (malocal%mp(1) >= 0 .and. qx%kround == 2) then
              call fmeq(malocal, mxy(1), qx)
              mxy(1)%mp(2) = 0
              call fmulp(mxy(1), mxy(2), qx)
              call fmadd(mxy(1), mxy(2), mresult, qx)
              mresult%mp(2) = malocal%mp(2) + mresult%mp(2)
          else
              call fmeq(malocal, mresult, qx)
          endif
          if (qx%kflag > 0) qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          kresult = 1
          return
      endif

      return
      end subroutine fmsinh_sc

      subroutine fmsinh2(ma, mb, qx)

!  Internal subroutine for mb = sinh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: maxv
      integer :: j, j2, k, k2, kl, kthree, kwrnsv, l, l2, large, n2, nbot, ndsav1, ndsave, nterm
      real :: alog3, alogt, b, t, tj
      type(multi) :: mxy(3), mjsums(ljsums)

      call fmalloc(mb, qx%ndig+2, qx)

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      if (ma%mp(3) == 0) then
          call fmeq(ma, mb, qx)
          return
      endif
      ndsave = qx%ndig
      kwrnsv = qx%kwarn
      qx%kwarn = 0

!             Use the direct series
!                  sinh(x) = x + x**3/3! + x**5/5! - ...

!             The argument will be divided by 3**k2 before the series is summed.
!             The series will be added as j2 concurrent series.

      b = real(qx%mbase)
      k = qx%ngrd52
      t = max(qx%ndig-k, 2)
      alog3 = log(3.0)
      alogt = log(t)
      tj = 0.67*(qx%ndig*qx%alogmt)**0.3333 - 0.3
      j2 = int(tj)
      j2 = max(2, min(j2, ljsums))
      k2 = max(2, int(0.6*(qx%ndig*qx%alogmt)**0.3333 - 0.8))

      tj = -(real(ma%mp(2))*qx%alogmb +  &
             log(real(ma%mp(3))/b + real(ma%mp(4))/(b*b)))/alog3 - 0.3
      if (tj >= k2) then
          l = k2
      else if (tj > 0) then
          l = int(tj)
      else
          l = 0
      endif
      k2 = k2 - l
      if (k2 <= 0) then
          k2 = 0
          j2 = int(.43*sqrt(t*qx%alogmb/(alogt+real(l)*alog3)) + .33)
          j2 = max(1, min(j2, ljsums))
      endif

      n2 = int(t*qx%alogmb/(alogt+real(l)*alog3))
      l2 = int(log(real(n2)+3.0d0**k2)/qx%alogmb)
      call fmndig(qx%ndig + l2, qx)
      ndsav1 = qx%ndig

!             Divide the argument by 3**k2.

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      kthree = 1
      maxv = mxbase/3
      if (k2 > 0) then
          do j = 1, k2
             kthree = 3*kthree
             if (kthree > maxv) then
                 call fmcsdivi_r1(mxy(1), kthree, qx)
                 kthree = 1
             endif
          enddo
          if (kthree > 1) call fmcsdivi_r1(mxy(1), kthree, qx)
      endif

!             Split into j2 concurrent sums and reduce ndig while computing each term in the sum
!             as the terms get smaller.

      call fmeq(mxy(1), mxy(2), qx)
      nterm = 1
      do j = 1, j2
         nbot = nterm*(nterm-1)
         if (nbot > 1) call fmcsdivi_r1(mxy(2), nbot, qx)
         nterm = nterm + 2
         call fmeq(mxy(2), mjsums(j), qx)
      enddo
      call fmsqr_r1(mxy(1), qx)

      kl = 1
      if (mxy(1)%mp(2) < -qx%ndig) then
          kl = 0
      else
          call fmipwr(mxy(1), j2, mxy(3), qx)
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(2), mxy(3), qx)
         do j = 1, j2
            large = int(intmax/nterm)
            if (nterm > large .or. nterm > mxbase/(nterm-1)) then
                call fmcsdivi_r1(mxy(2), nterm, qx)
                nbot = nterm - 1
                call fmcsdivi_r1(mxy(2), nbot, qx)
            else
                nbot = nterm*(nterm-1)
                call fmcsdivi_r1(mxy(2), nbot, qx)
            endif
            call fmndig(ndsav1, qx)
            call fmcsaddnn_r1(mjsums(j), mxy(2), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            call fmndig(ndsav1 - int(mjsums(j)%mp(2)-mxy(2)%mp(2)), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
            nterm = nterm + 2
         enddo
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call fmcsnsums(j2, mjsums, qx)
      call fmeq(mjsums(j2), mxy(3), qx)
      do j = 2, j2
         call fmcsmpy_r1(mxy(3), mxy(1), qx)
         call fmadd_r1(mxy(3), mjsums(j2-j+1), qx)
      enddo

!             Reverse the effect of reducing the argument to compute sinh(ma).

      call fmndig(ndsav1, qx)
      if (k2 > 0) then
          call fmi2m(3, mxy(1), qx)
          do j = 1, k2
             call fmsqr(mxy(3), mxy(2), qx)
             call fmcsmpyi_r1(mxy(2), 4, qx)
             call fmadd_r2(mxy(1), mxy(2), qx)
             call fmcsmpy_r1(mxy(3), mxy(2), qx)
          enddo
      endif

      call fmequ(mxy(3), mb, ndsav1, ndsave, qx)
      qx%ndig = ndsave
      qx%kwarn = kwrnsv

      return
      end subroutine fmsinh2

      subroutine fmsp2m(x, ma, qx)

!  ma = x

!  Convert a single precision number to fm format.

!  This version tries to convert the single precision machine number to fm with accuracy of nearly
!  full fm precision.
!  If conversion to fm with approximately double precision accuracy is good enough, it is faster to
!  call fmdpm(dble(x), ma)

      use fmvals_parallel
      implicit none

      real :: x
      type(multi) :: ma
      intent (in) :: x
      intent (inout) :: ma
      type(fm_settings) :: qx

      double precision :: xdp, y, yt
      integer :: j, k

      call fmalloc(ma, qx%ndig+2, qx)

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMSP2M'
      xdp = dble(x)
      if (qx%ntrace /= 0) call fmntr_inpd(xdp, qx)

!             Check for x = + or - Infinity, or Nan.  Return unknown if so.

      if (x > huge(x) .or. x < -huge(x) .or. (.not.(x == x))) then
          do j = 2, qx%ndig
             ma%mp(j+2) = 0
          enddo
          qx%kflag = -4
          ma%mp(2) = qx%munkno
          ma%mp(3) = 1
          ma%mp(1) = 1
          call fmwarn(qx)
          if (qx%ntrace /= 0) call fmntr_out1(ma, qx)
          qx%ncall = qx%ncall - 1
          return
      endif

!             Check to see if x is exactly a small integer.  If so, converting as an integer
!             is better.  Also see if x is exactly a small integer divided by a small power of two.

      y = qx%mxexp2
      if (abs(xdp) < y) then
          k = int(xdp)
          y = k
          if (y == xdp) then
              call fmi2m2(k, ma, qx)
              if (qx%ntrace /= 0) call fmntr_out1(ma, qx)
              qx%ncall = qx%ncall - 1
              return
          endif
      endif
      if (abs(xdp) < 1.0d0) then
          y = 4096.0d0 * xdp
          k = int(y)
          yt = k
          if (y == yt) then
              call fmi2m2(k, ma, qx)
              call fmdivi_r1(ma, 4096, qx)
              if (qx%ntrace /= 0) call fmntr_out1(ma, qx)
              qx%ncall = qx%ncall - 1
              return
          endif
      endif

      call fmdp2m2(xdp, ma, qx)

      if (qx%ntrace /= 0) call fmntr_out1(ma, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmsp2m

      subroutine fmsqr(ma, mb, qx)

!  mb = ma**2

!  This routine performs the trace printing for squaring.
!  fmsqr2 is used to do the arithmetic.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      integer :: kovun

      qx%ncall = qx%ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == qx%mexpov) kovun = 1
      if (ma%mp(2) == qx%munkno) kovun = 2
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMSQR    '
          call fmntr_inp1(ma, qx)
      endif

      call fmsqr2(ma, mb, qx)

      if ((abs(mb%mp(2)) == qx%mexpov .and. kovun == 0) .or.  &
          (abs(mb%mp(2)) == qx%munkno .and. kovun < 2)) then
          qx%namest(qx%ncall) = 'FMSQR    '
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) then
          call fmntr_out1(mb, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmsqr

      subroutine fmsqr2(ma, mb, qx)

!  Internal squaring routine.  mb = ma**2

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      logical :: retry
      integer :: kresult, kr_retry

      call fmalloc(qx%mwa, 2*qx%ndig+30, qx)
      call fmalloc(mb, qx%ndig+2, qx)
      call fmsqr_sc(ma, mb, kresult, qx)
      if (kresult > 0) then
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      kr_retry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fmsqr_m1(ma, mb, kr_retry, retry, qx)
      enddo

      return
      end subroutine fmsqr2

      subroutine fmsqr2_r1(ma, qx)

!  ma = ma**2.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      intent (inout) :: ma
      type(multi) :: mxy(1)
      type(fm_settings) :: qx

      call fmsqr2(ma, mxy(1), qx)
      call fmeq(mxy(1), ma, qx)

      return
      end subroutine fmsqr2_r1

      subroutine fmsqr_m1(ma, mb, kr_retry, retry, qx)

!  Method 1 for computing ma**2

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: kr_retry
      logical :: retry
      intent (in) :: ma
      intent (inout) :: mb, kr_retry, retry
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: maxmax, maxmwa, mbj, mbkj, mbnorm, mbp1, mk, mka, mkt, mmax, mr, mt
      double precision :: err
      real :: c
      integer :: j, jm1, jrssav, k, kb, ki, kj, kl, knz, kshift, kwa, l, n1, nguard, nmethd, nzda

      qx%kflag = 0
      jrssav = qx%jrsign
      if (qx%mblogs /= qx%mbase) call fmcons(qx)

!             Check for using an fft-based method if precision is very high.

      c = 1300
      if (qx%ndig >= c) then
          nzda = 0
          do j = 2, qx%ndig
             if (ma%mp(j+2) == 0) nzda = nzda + 1
          enddo
          if (qx%ndig-nzda < 50 .or. real(nzda)/qx%ndig > 0.8) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          nmethd = 1
      endif
      if (nmethd == 2) then
          qx%ksqr = 1
          call fmmpy2(ma, ma, mb, qx)
          qx%ksqr = 0
          return
      endif

      maxmax = 0
      n1 = qx%ndig + 1
      qx%mwa%mp(2) = ma%mp(2) + ma%mp(2)

!             nguard is the number of guard digits used.

      if (qx%ncall > 1) then
          nguard = qx%ngrd22
          if (nguard > qx%ndig) nguard = qx%ndig
      else
          nguard = qx%ngrd52
          if (nguard > qx%ndig) nguard = qx%ndig
          if (kr_retry >= 1) then
              nguard = qx%ndig + 2
          else if (qx%mbase < 10**6) then
              nguard = min(nguard+1, qx%ndig+2)
          endif
      endif
      if (ma%mp(3)*ma%mp(3) < qx%mbase .and. nguard < 3) nguard = 3

      l = n1 + nguard
      qx%mwa%mp(l+2) = 0

!             The multiplication loop begins here.

!             mbnorm is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             maxmwa is an upper bound on the size of values in mwa divided by (mbase-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      mbp1 = qx%mbase + 1
      mbnorm = (maxint/(mbp1*mbp1))
      mmax = intmax - qx%mbase
      mmax = min((maxint/mbp1 - mbp1), mmax)
      if (mbnorm >= 2) then
          mbj = ma%mp(3)

!             Count the trailing zeros in ma.

          knz = n1
          if (ma%mp(n1+1) /= 0) then
              knz = n1
          else
              do j = qx%ndig, 2, -1
                 if (ma%mp(j+1) /= 0) then
                     knz = j
                     exit
                 endif
              enddo
          endif

          qx%mwa%mp(3) = 0
          qx%mwa%mp(4) = 0
          do k = qx%ndig+2, l
             qx%mwa%mp(k+1) = 0
          enddo

!             (Inner Loop)

          do k = 4, n1+1
             qx%mwa%mp(k+1) = ma%mp(k)*mbj
          enddo
          maxmwa = mbj
          do j = 3, min(l/2, n1)
             mbj = ma%mp(j+1)
             if (mbj /= 0) then
                 maxmwa = maxmwa + mbj
                 jm1 = j - 1
                 kl = min(knz, l-jm1)

!                       Major (Inner Loop)

                 do k = 2*j+1, jm1+kl+1
                    qx%mwa%mp(k) = qx%mwa%mp(k) + ma%mp(k-jm1)*mbj
                 enddo
             endif

             if (maxmwa > mmax) then
                 maxmax = max(maxmax, maxmwa)
                 maxmwa = 0
                 jm1 = j - 1
                 kl = min(knz, l-jm1)

!                       Normalization is only required for the range of digits currently
!                       changing in mwa.

                 do kb = jm1+kl, 2*j, -1
                    mkt = int (qx%mwa%mp(kb+1)/qx%mbase)
                    qx%mwa%mp(kb) = qx%mwa%mp(kb) + mkt
                    qx%mwa%mp(kb+1) = qx%mwa%mp(kb+1) - mkt*qx%mbase
                 enddo
             endif
          enddo

!             Double mwa, add the square terms, and perform the final normalization.  (Inner Loop)

          if (2*max(maxmax, maxmwa)+qx%mbase > mmax) then
              do kb = l+1, 5, -1
                 mkt = int (qx%mwa%mp(kb)/qx%mbase)
                 qx%mwa%mp(kb-1) = qx%mwa%mp(kb-1) + mkt
                 qx%mwa%mp(kb) = qx%mwa%mp(kb) - mkt*qx%mbase
              enddo
          endif

          do j = 4, l, 2
             if (j/2 <= n1) then
                 mka = ma%mp(1+j/2)
                 qx%mwa%mp(j) = 2*qx%mwa%mp(j) + mka*mka
                 qx%mwa%mp(j+1) = 2*qx%mwa%mp(j+1)
             else
                 qx%mwa%mp(j) = 2*qx%mwa%mp(j)
                 qx%mwa%mp(j+1) = 2*qx%mwa%mp(j+1)
             endif
          enddo
          if (mod(l, 2) == 1) then
              if ((l+1)/2 <= n1) then
                  mka = ma%mp(1+(l+1)/2)
                  qx%mwa%mp(l+1) = 2*qx%mwa%mp(l+1) + mka*mka
              else
                  qx%mwa%mp(l+1) = 2*qx%mwa%mp(l+1)
              endif
          endif

          do kb = l+1, 4, -1
             mkt = int (qx%mwa%mp(kb)/qx%mbase)
             qx%mwa%mp(kb-1) = qx%mwa%mp(kb-1) + mkt
             qx%mwa%mp(kb) = qx%mwa%mp(kb) - mkt*qx%mbase
          enddo

      else

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          do j = 2, l
             qx%mwa%mp(j+1) = 0
          enddo
          kj = qx%ndig + 2
          do j = 2, n1
             kj = kj - 1
             mbkj = ma%mp(kj+1)
             if (mbkj == 0) cycle
             kl = l - kj + 1
             if (kl > n1) kl = n1
             ki = kl + 2
             kwa = kl+ kj + 1
             mk = 0
             do k = 2, kl
                mt = ma%mp(ki-k+1)*mbkj + qx%mwa%mp(kwa-k+1) + mk
                mk = int (mt/qx%mbase)
                qx%mwa%mp(kwa-k+1) = mt - qx%mbase*mk
             enddo
             qx%mwa%mp(kwa-kl) = mk
          enddo

      endif

!             Set kshift = 1 if a shift left is necessary.

      if (qx%mwa%mp(3) == 0) then
          kshift = 1
      else
          kshift = 0
      endif

!             The multiplication is complete.  Round the result and move it to mb.

      qx%jrsign = 1

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      if (qx%ncall >= 1) then
          kl = min(nguard, int(3*qx%dlogtn/qx%dlogmb + 1.5))
          err = 0
          do j = kl, 1, -1
             err = (err + qx%mwa%mp(j+kshift+qx%ndig+2)) / qx%mbase
          enddo
          if ( (qx%kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
               (qx%kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) kr_retry = kr_retry + 1
      endif
      if (kr_retry == 1 .and. nguard < qx%ndig+2) then
          kr_retry = 2
          retry = .true.
          return
      endif
      mr = 2*qx%mwa%mp(kshift+qx%ndig+3) + 1
      if (qx%kround == -1 .or. qx%kround == 2) then
          call fmrnd(qx%mwa, qx%ndig, nguard, kshift, qx)
      else if (mr >= qx%mbase) then
          if (mr-1 > qx%mbase .and. qx%mwa%mp(kshift+n1+1) < qx%mbase-1) then
              if (qx%kround /= 0) then
                  qx%mwa%mp(kshift+n1+1) = qx%mwa%mp(kshift+n1+1) + 1
                  qx%mwa%mp(kshift+n1+2) = 0
              endif
          else
              call fmrnd(qx%mwa, qx%ndig, nguard, kshift, qx)
          endif
      endif
      call fmmove(qx%mwa, mb, qx)

      mb%mp(1) = 1
      qx%ksqr = 0
      qx%jrsign = jrssav

      return
      end subroutine fmsqr_m1

      subroutine fmsqr_r1(ma, qx)

!  ma = ma**2    faster than using fmmpy.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx

      qx%ncall = qx%ncall + 1
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMSQR_R1'
          call fmntr_inp1(ma, qx)

          call fmsqr2_r1(ma, qx)

          qx%namest(qx%ncall) = 'FMSQR_R1'
          call fmntr_out1(ma, qx)
      else
          call fmsqr2_r1(ma, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmsqr_r1

      subroutine fmsqr_sc(ma, mb, kresult, qx)

!  Check for special cases for mb = ma**2

!  kresult = 1 is returned if a special case gives the value of ma.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: kresult
      intent (in) :: ma
      intent (inout) :: mb, kresult
      type(fm_settings) :: qx

      type(multi) :: mxy(1)

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      kresult = 0
      qx%kflag = 0
      if (ma%mp(2) == qx%munkno .and. ma%mp(5) >= 0) then
          call fmunknown(mb, qx)
          qx%kflag = -4
          kresult = 1
          return
      endif
      if (ma%mp(2) == qx%munkno) then
          call fmeq(ma, mxy(1), qx)
          call fmovun_mpy(ma, mxy(1), mb, qx)
          kresult = 1
          return
      endif
      if (abs(ma%mp(2)) == qx%mexpov) then
          call fmeq(ma, mxy(1), qx)
          call fmovun_mpy(ma, mxy(1), mb, qx)
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0) then
          call fmi2m2(0, mb, qx)
          kresult = 1
          return
      endif

      return
      end subroutine fmsqr_sc

      subroutine fmsqrt(ma, mb, qx)

!  mb = sqrt(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(4), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmsqrt_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call fmsqrt_m(ma, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmsqrt

      subroutine fmsqrt_m(ma, mxy, mresult, ndsave, qx)

!  Method selection for computing sqrt(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: km4, nmethd
      nmethd = 1
      if (qx%mbase >= 1000 .and. qx%mbase <= mxbase/1.5d0 .and. qx%ndig*qx%alogmt < 1400) then
          nmethd = 4
      else if (qx%ndig*qx%alogmt > 50000) then
          nmethd = 3
      else if (qx%ndig*qx%alogmt > 2750) then
          nmethd = 2
      endif

      if (nmethd == 1) then
          call fmsqrt_m1(ma, mxy, mresult, ndsave, qx)
      else if (nmethd == 2) then
          call fmsqrt_m2(ma, mxy, mresult, ndsave, qx)
      else if (nmethd == 3) then
          call fmsqrt_m3(ma, mxy, mresult, ndsave, qx)
      else if (nmethd == 4) then
          call fmsqrt_m4(ma, mxy, mresult, ndsave, km4, qx)
          if (km4 > 0) then
              call fmsqrt_m1(ma, mxy, mresult, ndsave, qx)
          endif
      endif

      return
      end subroutine fmsqrt_m

      subroutine fmsqrt_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing sqrt(ma).

!  Ordinary Newton iteration.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: x, xb
      real (kind(1.0d0)) :: ma1, mke
      integer :: nstack(49), j, kma1, kst

      call fmequ(ma, mxy(2), ndsave, qx%ndig, qx)

!             Generate the first approximation.

      ma1 = ma%mp(2)
      mxy(2)%mp(2) = 0
      call fmm2dp(mxy(2), x, qx)
      x = sqrt(x)
      mke = ma1/2
      kma1 = int(abs(ma1))
      if (mod(kma1, 2) == 1) then
          xb = qx%mbase
          x = x*sqrt(xb)
          mke = (ma1-1)/2
      endif
      call fmdpm(x, mxy(3), qx)
      mxy(3)%mp(2) = mxy(3)%mp(2) + mke

!             Initialize.

      call fmi2m(0, mxy(1), qx)
      mxy(2)%mp(2) = ma1
      call fmdig(nstack, kst, qx)

!             Newton iteration.

      do j = 1, kst
         call fmndig(nstack(j), qx)
         call fmcsdiv(mxy(2), mxy(3), mxy(1), qx)
         call fmcsadd_r1(mxy(3), mxy(1), qx)
         call fmcsdivi_r1(mxy(3), 2, qx)
      enddo
      mxy(3)%mp(1) = 1
      call fmeq(mxy(3), mresult, qx)

      return
      end subroutine fmsqrt_m1

      subroutine fmsqrt_m2(ma, mxy, mresult, ndsave, qx)

!  Method 2 for computing sqrt(ma).

!  Modified Newton iteration.
!                              x2 = x1 - (x1**2 - a) / (2*x1)
!                              where the square is done at full current precision,
!                              and the division is done at half current precision.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: x, xb
      real (kind(1.0d0)) :: ma1, mke
      integer :: nstack(49), j, kma1, kst

      call fmequ(ma, mxy(2), ndsave, qx%ndig, qx)

!             Generate the first approximation.

      ma1 = ma%mp(2)
      mxy(2)%mp(2) = 0
      call fmm2dp(mxy(2), x, qx)
      x = sqrt(x)
      mke = ma1/2
      kma1 = int(abs(ma1))
      if (mod(kma1, 2) == 1) then
          xb = qx%mbase
          x = x*sqrt(xb)
          mke = (ma1-1)/2
      endif
      call fmdpm(x, mxy(3), qx)
      mxy(3)%mp(2) = mxy(3)%mp(2) + mke

!             Initialize.

      call fmi2m(0, mxy(1), qx)
      call fmi2m(0, mxy(4), qx)
      mxy(2)%mp(2) = ma1
      call fmdig(nstack, kst, qx)

!             Newton iteration.

      do j = 1, kst
         call fmndig(nstack(j), qx)
         call fmsqr(mxy(3), mxy(1), qx)
         call fmsub_r1(mxy(1), mxy(2), qx)
         if (j > 1) call fmndig(nstack(j-1), qx)
         call fmadd(mxy(3), mxy(3), mxy(4), qx)
         call fmdiv_r2(mxy(1), mxy(4), qx)
         call fmndig(nstack(j), qx)
         call fmsub_r1(mxy(3), mxy(4), qx)
      enddo
      mxy(3)%mp(1) = 1
      call fmeq(mxy(3), mresult, qx)

      return
      end subroutine fmsqrt_m2

      subroutine fmsqrt_m3(ma, mxy, mresult, ndsave, qx)

!  Method 3 for computing sqrt(ma).

!  Karp's method.  Newton iteration for 1/sqrt(a)
!                  x2 = x1 + (1 - a*x1**2)*x1/2
!                  where a*x1**2 is done at full current precision,
!                  and *x1/2 is done at half current precision.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: x, xb
      real (kind(1.0d0)) :: ma1, mke
      integer :: nstack(49), j, kma1, kst

      call fmequ(ma, mxy(2), ndsave, qx%ndig, qx)

!             Generate the first approximation to 1/sqrt(a).

      ma1 = ma%mp(2)
      mxy(2)%mp(2) = 0
      call fmm2dp(mxy(2), x, qx)
      x = 1.0d0/sqrt(x)
      mke = -ma1/2
      kma1 = int(abs(ma1))
      if (mod(kma1, 2) == 1) then
          xb = qx%mbase
          x = x*sqrt(xb)
          mke = -(ma1+1)/2
      endif
      call fmdpm(x, mxy(3), qx)
      mxy(3)%mp(2) = mxy(3)%mp(2) + mke

!             Initialize.

      call fmi2m(1, mxy(1), qx)
      call fmi2m(0, mxy(4), qx)
      mxy(2)%mp(2) = ma1
      call fmdig(nstack, kst, qx)

!             Newton iteration for 1/sqrt(a).

      do j = 1, kst-1
         call fmndig(nstack(j), qx)
         call fmsqr(mxy(3), mxy(4), qx)
         call fmmpy_r2(mxy(2), mxy(4), qx)
         call fmsub_r2(mxy(1), mxy(4), qx)
         if (j > 1) call fmndig(nstack(j-1), qx)
         call fmmpy_r2(mxy(3), mxy(4), qx)
         call fmdivi_r1(mxy(4), 2, qx)
         call fmndig(nstack(j), qx)
         call fmadd_r1(mxy(3), mxy(4), qx)
      enddo

!             Karp's method for speeding up the last iteration and getting sqrt(a).
!             For the last iteration, combine a*x1 to get
!             a*x1 + x1*(a - (a*x1)**2)/2
!             where only the square, -, and + need full precision.

      call fmndig(nstack(kst), qx)
      if (kst > 1) call fmndig(nstack(kst-1), qx)
      call fmmpy(mxy(2), mxy(3), mxy(4), qx)
      call fmndig(nstack(kst), qx)
      call fmsqr(mxy(4), mxy(1), qx)
      call fmsub_r2(mxy(2), mxy(1), qx)
      if (kst > 1) call fmndig(nstack(kst-1), qx)
      call fmmpy_r2(mxy(3), mxy(1), qx)
      call fmdivi_r1(mxy(1), 2, qx)
      call fmndig(nstack(kst), qx)
      call fmadd(mxy(4), mxy(1), mxy(3), qx)
      mxy(3)%mp(1) = 1
      call fmeq(mxy(3), mresult, qx)

      return
      end subroutine fmsqrt_m3

      subroutine fmsqrt_m4(ma, mxy, mresult, ndsave, km4, qx)

!  Method 4 for computing sqrt(ma).

!  Direct method.  This is the old-fashioned sqrt algorithm that uses two digits at a time
!                  from ma and is a bit like long division.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: ndsave, km4
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, km4
      type(fm_settings) :: qx

      double precision :: dc, dp, x
      real (kind(1.0d0)) :: mke
      integer :: j, jpt, k, kl, kn

      km4 = 0
      call fmequ(ma, mxy(2), ndsave, qx%ndig, qx)

      call fmi2m(1, mxy(1), qx)
      call fmi2m(1, mxy(3), qx)
      call fmi2m(1, mxy(4), qx)
      mxy(1)%mp(3) = mxy(2)%mp(3)
      mxy(1)%mp(2) = 1
      dc = mxy(1)%mp(3)
      jpt = 2
      kn = max(1, int(min(1000.0d0, maxint/(2*qx%mbase**2)-5)))
      if (mod(int(abs(mxy(2)%mp(2))), 2) == 0) then
          mxy(1)%mp(2) = 1
          mxy(1)%mp(3) = mxy(2)%mp(3) * qx%mbase + mxy(2)%mp(4)
          dc = mxy(1)%mp(3)
          jpt = 3
      endif
      x = int(sqrt(dc))
      mke = 2
      if (mod(mxy(2)%mp(2), mke) == 0) then
          mxy(3)%mp(2) = mxy(2)%mp(2) / 2
      else
          mxy(3)%mp(2) = (mxy(2)%mp(2)+1) / 2
      endif
      mxy(3)%mp(3) = x
      mxy(4)%mp(2) = 1
      mke = x
      mxy(4)%mp(3) = mke*mke
      mxy(1)%mp(3) = mxy(1)%mp(3) - mxy(4)%mp(3)
      dp = mxy(3)%mp(3)
      do j = 2, qx%ndig
         mxy(1)%mp(2) = mxy(1)%mp(2) + 2
         if (jpt <= qx%ndig) then
             mxy(1)%mp(j+2) = mxy(2)%mp(jpt+2)
         endif
         if (jpt+1 <= qx%ndig) then
             mxy(1)%mp(j+3) = mxy(2)%mp(jpt+3)
         endif
         jpt = jpt + 2
         dc = mxy(1)%mp(3)
         if (qx%ndig >= 4) then
             dc = ((dc*qx%mbase + mxy(1)%mp(4))*qx%mbase + mxy(1)%mp(5))*qx%mbase +  &
                   mxy(1)%mp(6)
         else if (qx%ndig == 3) then
             dc = ((dc*qx%mbase + mxy(1)%mp(4))*qx%mbase + mxy(1)%mp(5))*qx%mbase
         else
             dc = ((dc*qx%mbase + mxy(1)%mp(4))*qx%mbase)*qx%mbase
         endif
         if (j <= 4) then
             dp = mxy(3)%mp(3)
             if (qx%ndig >= 3) then
                 dp = (dp*qx%mbase + mxy(3)%mp(4))*qx%mbase + mxy(3)%mp(5)
             else
                 dp = (dp*qx%mbase + mxy(3)%mp(4))*qx%mbase
             endif
         endif
         if (j <= 2) then
             dc = dc*dble(qx%mbase)**int(mxy(1)%mp(2)-4)
             dp = dp*dble(qx%mbase)**(j-4)
             x = floor(dp*qx%mbase*(sqrt(1+dc/(dp*qx%mbase)**2)-1))
         else
             if (int(mxy(1)%mp(2))-j-1 /= 0) then
                 dc = dc*dble(qx%mbase)**(int(mxy(1)%mp(2))-j-1)
             endif
             x = floor(dc/(2.0d0*dp))
         endif
         if (abs(2.0d0 * x * qx%mbase) >= maxint) then
             km4 = 1
             call fmeq(mxy(3), mresult, qx)
             return
         endif
         mxy(4)%mp(2) = j
         kl = min(j, qx%ndig/2+2+qx%ndig/10)
         do k = 3, kl+1
            mke = x
            mxy(4)%mp(k) = 2 * mke * mxy(3)%mp(k)
         enddo
         mke = x
         mxy(4)%mp(j+2) = mke * mke
         mxy(3)%mp(j+2) = x
         if (j == qx%ndig) exit
         if (mxy(1)%mp(2) - mxy(4)%mp(2) /= 1) then
             km4 = 1
             call fmeq(mxy(3), mresult, qx)
             return
         endif
         mxy(1)%mp(2) = mxy(1)%mp(2) - 1
         mxy(1)%mp(3) = mxy(1)%mp(3) * qx%mbase + mxy(1)%mp(4) -  &
                                  mxy(4)%mp(3)
         kl = min(j, qx%ndig/2+2+qx%ndig/10)
         do k = 4, kl+2
            mxy(1)%mp(k) = mxy(1)%mp(k+1) - mxy(4)%mp(k)
         enddo
         mxy(1)%mp(j+3) = 0
         if (mod(j, kn) == 0) then
             do k = j+2, 4, -1
                if (mod(mxy(1)%mp(k), qx%mbase) == 0) then
                    kl = mxy(1)%mp(k) / qx%mbase
                else if (mxy(1)%mp(k) > 0) then
                    kl = mxy(1)%mp(k) / qx%mbase
                else
                    kl = mxy(1)%mp(k) / qx%mbase - 1
                endif
                mxy(1)%mp(k-1) = mxy(1)%mp(k-1) + kl
                mxy(1)%mp(k) = mxy(1)%mp(k) - kl*qx%mbase
             enddo
         endif
      enddo
      do k = qx%ndig+2, 4, -1
         if (mxy(3)%mp(k) >= 0 .and. mxy(3)%mp(k) < qx%mbase) cycle
         if (mod(mxy(3)%mp(k), qx%mbase) == 0) then
             kl = mxy(3)%mp(k) / qx%mbase
         else if (mxy(3)%mp(k) > 0) then
             kl = mxy(3)%mp(k) / qx%mbase
         else
             kl = mxy(3)%mp(k) / qx%mbase - 1
         endif
         mxy(3)%mp(k-1) = mxy(3)%mp(k-1) + kl
         mxy(3)%mp(k) = mxy(3)%mp(k) - kl*qx%mbase
      enddo
      mxy(3)%mp(1) = 1
      call fmeq(mxy(3), mresult, qx)

      return
      end subroutine fmsqrt_m4

      subroutine fmsqrt_r1(ma, qx)

!  ma = sqrt(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(4), mresult

      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmsqrt_r1_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, ma, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call fmsqrt_m(ma, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, ma, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmsqrt_r1

      subroutine fmsqrt_r1_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = sqrt(ma).

!  kresult = 1 is returned if a special case gives the value of sqrt(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      double precision :: xe, xf
      integer :: j
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMSQRT_R1'
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      if (malocal%mp(1) < 0 .or. (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0)) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif
      if (malocal%mp(3) == 0) then
          call fmi2m(0, mresult, qx)
          kresult = 1
          return
      endif
      if (abs(malocal%mp(2)) >= qx%mexpov) then
          call fmovun_xexf(malocal, xe, xf, qx)
          if (mod(xe, 2.0d0) == 0) then
              xe = xe/2
              xf = sqrt(xf)
          else
              xe = (xe+1)/2
              xf = sqrt(xf/qx%mbase)
          endif
          if (xe >= -qx%mxexp0 .and. xe <= qx%mxexp0+1) then
              call fmunknown(mresult, qx)
              mresult%mp(4) = xe
              mresult%mp(5) = -xf*maxint
          else if (xe < -qx%mxexp0) then
              call fmunderflow(1, mresult, qx)
              mresult%mp(4) = xe
              mresult%mp(5) = -xf*maxint
          else
              call fmoverflow(1, mresult, qx)
              mresult%mp(4) = xe
              mresult%mp(5) = -xf*maxint
          endif
          kresult = 1
          return
      endif

      return
      end subroutine fmsqrt_r1_sc

      subroutine fmsqrt_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = sqrt(ma).

!  kresult = 1 is returned if a special case gives the value of sqrt(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      double precision :: xe, xf
      integer :: j
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMSQRT   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      if (malocal%mp(1) < 0 .or. (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0)) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif
      if (malocal%mp(3) == 0) then
          call fmi2m(0, mresult, qx)
          kresult = 1
          return
      endif
      if (abs(malocal%mp(2)) >= qx%mexpov) then
          call fmovun_xexf(malocal, xe, xf, qx)
          if (mod(xe, 2.0d0) == 0) then
              xe = xe/2
              xf = sqrt(xf)
          else
              xe = (xe+1)/2
              xf = sqrt(xf/qx%mbase)
          endif
          if (xe >= -qx%mxexp0 .and. xe <= qx%mxexp0+1) then
              call fmunknown(mresult, qx)
              mresult%mp(4) = xe
              mresult%mp(5) = -xf*maxint
          else if (xe < -qx%mxexp0) then
              call fmunderflow(1, mresult, qx)
              mresult%mp(4) = xe
              mresult%mp(5) = -xf*maxint
          else
              call fmoverflow(1, mresult, qx)
              mresult%mp(4) = xe
              mresult%mp(5) = -xf*maxint
          endif
          kresult = 1
          return
      endif

      return
      end subroutine fmsqrt_sc

      subroutine fmst2d(string, x, qx)

!  string contains a free-format number that is converted to double precision and returned in x.

!  This routine is used mostly by the fm routines that control fomatting and printing of fm numbers.

!  The input number may be in integer or any real format. The convention is made that if
!  no digits appear before 'e' then 1.0 is assumed.  For example, 'e6' is converted as '1.0e+6'.

      use fmvals_parallel
      implicit none

      character(*) :: string
      double precision :: x
      intent (in) :: string
      intent (inout) :: x
      type(fm_settings) :: qx

      integer :: j, jstate, kdigfl, kerr, kexp, kpt, ksign, ksignx, kstart, kstop, ktype, kval, n2
      double precision :: f1, f2

      integer :: jtrans(8, 4) = reshape(  (/    &
                   2, 9, 7, 7, 7, 7, 9, 9,      &
                   3, 3, 3, 5, 5, 8, 8, 8,      &
                   4, 4, 4, 9, 9, 9, 9, 9,      &
                   6, 6, 6, 6, 6, 9, 9, 9   /)  &
        , (/ 8, 4 /) )

      character :: kblank = ' '

      jstate = 1
      ksign = 1
      f1 = 0.0d0
      f2 = 0.0d0
      n2 = 0
      ksignx = 1
      kexp = 0
      kstart = 1
      kstop = len(string)
      kerr = 0
      qx%kflag = 0

!             kdigfl will be 1 if any digits are found before 'e'.

      kdigfl = 0

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      if (qx%lhash == 0) call fmhtbl(qx)

!             Scan the number.

      do j = kstart, kstop
         if (string(j:j) == kblank) cycle
         kpt = ichar(string(j:j))
         if (kpt < lhash1 .or. kpt > lhash2) then
             write (qx%kw,                                                      &
                "(/' Error in input conversion.'/"                          //  &
                "' ICHAR function was out of range for the current', "      //  &
                "' dimensions.'/' ICHAR(''', A, ''') gave the value ', "    //  &
                "I12, ', which is outside the currently'/' dimensioned', "  //  &
                "' bounds of (', I5, ':', I5, ') for variables KHASHT ', "  //  &
                "'and KHASHV.'/' Re-define the two parameters ', "          //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain', "   //  &
                "' all possible output values from ICHAR.'//)"                  &
                   ) string(j:j), kpt, lhash1, lhash2
             ktype = 5
             kval  = 0
         else
             ktype = qx%khasht(kpt)
             kval  = qx%khashv(kpt)
         endif
         if (ktype >= 5) then
             kerr = 1
             exit
         endif

         jstate = jtrans(jstate, ktype)

         select case (jstate)

!             State 2.  Sign of the number.

         case (2)
             ksign = kval

!             State 3.  Digits before a decimal point.

         case (3)
             kdigfl = 1
             f1 = 10.0d0*f1 + kval

!             State 4.  Decimal point

         case (4)
             cycle

!             State 5.  Digits after a decimal point.

         case (5)
             kdigfl = 1
             f2 = 10.0d0*f2 + kval
             n2 = n2 + 1

!             State 6.  Precision indicator.

         case (6)
             if (kdigfl == 0) f1 = 1.0d0

!             State 7.  Sign of the exponent.

         case (7)
             ksignx = kval

!             State 8.  Digits of the exponent.

         case (8)
             kexp = 10*kexp + kval

         case default
             kerr = 1
             exit

         end select

      enddo

      if (kerr == 0) then

!             Form the number and return.

          kexp = ksignx*kexp
          x = ksign*(f1 + f2/10.0d0**n2)*10.0d0**kexp
      else

!             Error in converting the number.

          x = -1.0d+31
          qx%kflag = -4
      endif

      return
      end subroutine fmst2d

      subroutine fmst2m(string, ma, qx)

!  ma = string

!  Convert a character string to fm format.
!  This is often more convenient than using fminp, which converts an array of character(1) values.

!  The default convention is that if no digits appear before 'e' then 1.0 is assumed.
!  For example, 'e6' is converted as '1.0e+6'.
!  Change variable keswch in module fmvals to zero if 'e6' should be converted as '0.0e+6' and
!  zero returned in ma.

      use fmvals_parallel
      implicit none

      character :: cmbuff(lmbuff)
      character(*) :: string
      type(multi) :: ma
      intent (in) :: string
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: j, lb, kfsave

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMST2M'
      lb = len(string)
      if (lb > lmbuff) then
          write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                              " Raise its size (lmbuff) or change the format being used."
          stop
      endif
      kfsave = qx%kflag

      do j = 1, lb
         cmbuff(j) = string(j:j)
      enddo
      qx%ncall = qx%ncall - 1
      call fminp(cmbuff, ma, 1, lb, qx)
      qx%ncall = qx%ncall + 1

      if (kfsave /= 0) qx%kflag = kfsave
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmst2m

      subroutine fmsub(ma, mb, mc, qx)

!  mc = ma + mb

!  This routine performs the trace printing for subtraction.  fmsub2 is used to do the arithmetic.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: kovun

      qx%ncall = qx%ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == qx%mexpov .or. abs(mb%mp(2)) == qx%mexpov) kovun = 1
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) kovun = 2
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMSUB'
          call fmntr_inp2(ma, mb, qx)
      endif

      call fmsub2(ma, mb, mc, qx)

      if ((abs(mc%mp(2)) == qx%mexpov .and. kovun == 0) .or.  &
          (abs(mc%mp(2)) == qx%munkno .and. kovun < 2)) then
          qx%namest(qx%ncall) = 'FMSUB'
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) then
          call fmntr_out1(mc, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmsub

      subroutine fmsub2(ma, mb, mc, qx)

!  Internal subtraction routine.  mc = ma - mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      logical :: retry
      integer :: jsign, kresult

      call fmalloc(mc, qx%ndig+2, qx)
      call fmalloc(qx%mwa, 2*qx%ndig+30, qx)
      qx%ksub = 1
      call fmadd_sc(ma, mb, mc, kresult, qx)
      qx%ksub = 0
      if (kresult > 0) then
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      qx%kround_retry = 0
      jsign = 1
      retry = .true.
      do while (retry)
         retry = .false.
         qx%ksub = 1
         call fmadd_m1(ma, mb, jsign, retry, qx)
         qx%ksub = 0
      enddo

!             Transfer to mc and fix the sign of the result.

      call fmmove(qx%mwa, mc, qx)
      mc%mp(1) = 1
      if (jsign < 0 .and. mc%mp(3) /= 0) mc%mp(1) = -1

      qx%kround_retry = 0

      return
      end subroutine fmsub2

      subroutine fmsub_r1(ma, mb, qx)

!  ma = ma - mb

!  This routine performs the trace printing for subtraction.  fmsub2_r1 does the arithmetic.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb
      type(fm_settings) :: qx

      integer :: kovun

      qx%ksub = 1
      qx%ncall = qx%ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == qx%mexpov .or. abs(mb%mp(2)) == qx%mexpov) kovun = 1
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) kovun = 2
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMSUB_R1'
          call fmntr_inp2(ma, mb, qx)
      endif

      call fmadd2_r1(ma, mb, qx)

      if ((abs(ma%mp(2)) == qx%mexpov .and. kovun == 0) .or.  &
          (abs(ma%mp(2)) == qx%munkno .and. kovun < 2)) then
          qx%namest(qx%ncall) = 'FMSUB_R1'
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) then
          call fmntr_out1(ma, qx)
      endif
      qx%ksub = 0
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmsub_r1

      subroutine fmsub_r2(ma, mb, qx)

!  mb = ma - mb

!  This routine performs the trace printing for subtraction.  fmsub2_r2 does the arithmetic.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      integer :: kovun

      qx%ksub = 1
      qx%ncall = qx%ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == qx%mexpov .or. abs(mb%mp(2)) == qx%mexpov) kovun = 1
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) kovun = 2
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'FMSUB_R2'
          call fmntr_inp2(ma, mb, qx)
      endif

      call fmadd2_r2(ma, mb, qx)

      if ((abs(mb%mp(2)) == qx%mexpov .and. kovun == 0) .or.  &
          (abs(mb%mp(2)) == qx%munkno .and. kovun < 2)) then
          qx%namest(qx%ncall) = 'FMSUB_R2'
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) then
          call fmntr_out1(mb, qx)
      endif
      qx%ksub = 0
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmsub_r2

      subroutine fmtan(ma, mb, qx)

!  mb = tan(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(5), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmtan_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call fmtan_m1(ma, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmtan

      subroutine fmtan_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing tan(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: jcos, jsin, jswap, kl, ndsv, ntry

      qx%ndigpi = 0
      qx%mbspi = 0
      ntry = 1
      kl = 1
      do while (kl == 1)
         call fmequ(ma, mxy(5), ndsave, qx%ndig, qx)
         mxy(5)%mp(1) = 1

!             Reduce the argument, convert to radians if the input is in degrees, and evaluate
!             the function.

         call fmrdc(mxy(5), jsin, jcos, jswap, qx)
         if (qx%kround /= 1 .and. qx%krad /= 1) then
             call fmi2m(45, mxy(1), qx)
             call fmsub(mxy(5), mxy(1), mxy(2), qx)
             if (mxy(2)%mp(3) == 0) then
                 call fmi2m(1, mxy(1), qx)
                 call fmmpyi(mxy(1), jsin/jcos, mresult, qx)
                 if (ma%mp(1) < 0) call fmnegate(mresult, qx)
                 return
             endif
         endif
         if (mxy(5)%mp(2) == qx%munkno) then
             call fmeq(mxy(5), mresult, qx)
             if (ma%mp(1) < 0) call fmnegate(mresult, qx)
             return
         endif
         if (mxy(5)%mp(3) == 0) then
             if (jswap == 1) then
                 call fmunknown(mxy(5), qx)
             endif
             call fmeq(mxy(5), mresult, qx)
             return
         endif
         if (qx%krad == 0) then
             if (qx%mbspi /= qx%mbase .or. qx%ndigpi < qx%ndig) then
                 ndsv = qx%ndig
                 call fmndig(qx%ndig + 2, qx)
                 call fmpi(mxy(4), qx)
                 qx%ndigpi = 0
                 call fmndig(ndsv, qx)
             endif
             call fmpi(mxy(4), qx)
             qx%ndigpi = 0
             call fmmpy_r1(mxy(5), mxy(4), qx)
             call fmdivi_r1(mxy(5), 180, qx)
         endif
         if (mxy(5)%mp(2) /= qx%munkno) then
             if (jswap == 0) then
                 if (mxy(5)%mp(2) < 0) then
                     call fmsin2(mxy(5), mxy(4), qx)
                     mxy(4)%mp(1) = jsin*mxy(4)%mp(1)
                     call fmsqr(mxy(4), mxy(2), qx)
                     call fmi2m(1, mxy(1), qx)
                     call fmsub_r2(mxy(1), mxy(2), qx)
                     if (mxy(2)%mp(2) < 0 .and. ntry == 1) then
                         ntry = 2
                         call fmndig(qx%ndig - int(mxy(2)%mp(2)), qx)
                         if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                         cycle
                     endif
                     call fmsqrt(mxy(2), mxy(3), qx)
                     mxy(3)%mp(1) = jcos*mxy(3)%mp(1)
                     call fmdiv(mxy(4), mxy(3), mxy(5), qx)
                 else
                     call fmcos2(mxy(5), mxy(4), qx)
                     mxy(4)%mp(1) = jcos*mxy(4)%mp(1)
                     call fmsqr(mxy(4), mxy(2), qx)
                     call fmi2m(1, mxy(1), qx)
                     call fmsub_r2(mxy(1), mxy(2), qx)
                     if (mxy(2)%mp(2) < 0 .and. ntry == 1) then
                         ntry = 2
                         call fmndig(qx%ndig - int(mxy(2)%mp(2)), qx)
                         if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                         cycle
                     endif
                     call fmsqrt(mxy(2), mxy(3), qx)
                     mxy(3)%mp(1) = jsin*mxy(3)%mp(1)
                     call fmdiv(mxy(3), mxy(4), mxy(5), qx)
                 endif
             else
                 if (mxy(5)%mp(2) < 0) then
                     call fmsin2(mxy(5), mxy(4), qx)
                     mxy(4)%mp(1) = jcos*mxy(4)%mp(1)
                     call fmsqr(mxy(4), mxy(2), qx)
                     call fmi2m(1, mxy(1), qx)
                     call fmsub_r2(mxy(1), mxy(2), qx)
                     if (mxy(2)%mp(2) < 0 .and. ntry == 1) then
                         ntry = 2
                         call fmndig(qx%ndig - int(mxy(2)%mp(2)), qx)
                         if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                         cycle
                     endif
                     call fmsqrt(mxy(2), mxy(3), qx)
                     mxy(3)%mp(1) = jsin*mxy(3)%mp(1)
                     call fmdiv(mxy(3), mxy(4), mxy(5), qx)
                 else
                     call fmcos2(mxy(5), mxy(4), qx)
                     mxy(4)%mp(1) = jsin*mxy(4)%mp(1)
                     call fmsqr(mxy(4), mxy(2), qx)
                     call fmi2m(1, mxy(1), qx)
                     call fmsub_r2(mxy(1), mxy(2), qx)
                     if (mxy(2)%mp(2) < 0 .and. ntry == 1) then
                         ntry = 2
                         call fmndig(qx%ndig - int(mxy(2)%mp(2)), qx)
                         if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
                         cycle
                     endif
                     call fmsqrt(mxy(2), mxy(3), qx)
                     mxy(3)%mp(1) = jcos*mxy(3)%mp(1)
                     call fmdiv(mxy(4), mxy(3), mxy(5), qx)
                 endif
             endif
         endif
         kl = 0
      enddo
      call fmeq(mxy(5), mresult, qx)
      if (ma%mp(1) < 0) call fmnegate(mresult, qx)

      return
      end subroutine fmtan_m1

      subroutine fmtan_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = tan(ma).

!  kresult = 1 is returned if a special case gives the value of tan(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      double precision :: b, pi, x, xe, xf
      integer :: j, k
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMTAN    '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif
      if (malocal%mp(2) == qx%munkno) then
          if (malocal%mp(5) < 0) then
              call fmovun_xexf(malocal, xe, xf, qx)
              if (2*xe < -ndsave) then
                  if (qx%krad == 1) then
                      call fmeq(malocal, mresult, qx)
                  else
                      call fmpi(mxy(2), qx)
                      qx%ndigpi = 0
                      call fmmpy_r2(malocal, mxy(2), qx)
                      call fmdivi(mxy(2), 180, mresult, qx)
                  endif
              else
                  call fmunknown(mresult, qx)
                  if (xe*qx%dlogmb+log(xf) < log(1.0d+12)) then
                      b = qx%mbase
                      if (qx%krad == 1) then
                          x = tan(xf*b**xe)
                      else
                          pi = acos(-1.0d0)
                          x = tan(pi*xf*b**xe/180.0d0)
                      endif
                      if (malocal%mp(1) < 0) x = -x
                      if (x < 0) then
                          mresult%mp(1) = -1
                          x = -x
                      endif
                      if (x == 1.0d0) then
                          xe = 1
                          xf = 1/b
                      else
                          xe = 0
                          xf = x
                      endif
                      mresult%mp(4) = xe
                      mresult%mp(5) = -xf*maxint
                  endif
              endif
          else
              call fmunknown(mresult, qx)
          endif
          kresult = 1
          return
      endif
      if (malocal%mp(2) == qx%mexpun) then
          call fmeq(malocal, mresult, qx)
          if (qx%krad == 0) then
              call fmdivi(mresult, 180, mxy(2), qx)
              call fmpi(mxy(1), qx)
              qx%ndigpi = 0
              call fmmpy(mxy(2), mxy(1), mresult, qx)
          endif
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (qx%kround /= 1 .and. malocal%mp(2) < -ndsave .and. qx%krad == 1) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          call fmsqr(malocal, mxy(1), qx)
          call fmmpy(mxy(1), malocal, mxy(2), qx)
          call fmdivi(mxy(2), 3, mxy(3), qx)
          if (mxy(3)%mp(2) > qx%mexpun) then
              call fmadd(malocal, mxy(3), mresult, qx)
          else if (malocal%mp(2) == qx%mexpun) then
              call fmeq(malocal, mresult, qx)
          else if (malocal%mp(1) < 0 .and. qx%kround == -1) then
              call fmeq(malocal, mxy(1), qx)
              mxy(1)%mp(2) = 0
              call fmulp(mxy(1), mxy(2), qx)
              call fmadd(mxy(1), mxy(2), mresult, qx)
              mresult%mp(2) = malocal%mp(2) + mresult%mp(2)
          else if (malocal%mp(1) >= 0 .and. qx%kround == 2) then
              call fmeq(malocal, mxy(1), qx)
              mxy(1)%mp(2) = 0
              call fmulp(mxy(1), mxy(2), qx)
              call fmadd(mxy(1), mxy(2), mresult, qx)
              mresult%mp(2) = malocal%mp(2) + mresult%mp(2)
          else
              call fmeq(malocal, mresult, qx)
          endif
          if (qx%kflag > 0) qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          kresult = 1
          return
      endif
      if (malocal%mp(2) > 3*10**5 .and. qx%krad == 1) then
          call fmunknown(mresult, qx)
          kresult = 1
      endif

      return
      end subroutine fmtan_sc

      subroutine fmtanh(ma, mb, qx)

!  mb = tanh(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(5), mresult

      call fmalloc(mb, qx%ndig+2, qx)
      call fmenter1(ma, kovun, mxsave, ndsave, qx)
      call fmtanh_sc(ma, mxy, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call fmtanh_m1(ma, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine fmtanh

      subroutine fmtanh_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing tanh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: k, kwrnsv
      real :: x, xt

      call fmequ(ma, mxy(5), ndsave, qx%ndig, qx)
      kwrnsv = qx%kwarn
      if (ma%mp(3) == 0) then
          qx%kwarn = kwrnsv
          if (ma%mp(1) < 0) call fmnegate(mxy(5), qx)
          call fmeq(mxy(5), mresult, qx)
          return
      endif
      mxy(5)%mp(1) = 1

      if (ma%mp(2) >= 1) then
          xt = real((qx%ndig+1)/2)*qx%alogmb
          k = int(log(xt)/qx%alogmb)
          if (ma%mp(2) > k+1) then
              call fmi2m(1, mxy(5), qx)
              qx%kwarn = kwrnsv
              if (ma%mp(1) < 0) call fmnegate(mxy(5), qx)
              call fmeq(mxy(5), mresult, qx)
              return
          else
              x = real(mxy(5)%mp(3)*qx%mbase+mxy(5)%mp(4))*  &
                  real(qx%mbase)**int(mxy(5)%mp(2)-2)
              if (x > xt+5.0) then
                  call fmi2m(1, mxy(5), qx)
                  qx%kwarn = kwrnsv
                  if (ma%mp(1) < 0) call fmnegate(mxy(5), qx)
                  call fmeq(mxy(5), mresult, qx)
                  return
              endif
          endif
      endif
      if (mxy(5)%mp(2) == 0 .and. qx%ndig < 50) then
          call fmexp2(mxy(5), mxy(3), qx)
          call fmsqr_r1(mxy(3), qx)
          call fmi2m(1, mxy(1), qx)
          call fmsub(mxy(3), mxy(1), mxy(2), qx)
          call fmadd_r2(mxy(3), mxy(1), qx)
          call fmdiv(mxy(2), mxy(1), mxy(5), qx)
          qx%kwarn = kwrnsv
          if (ma%mp(1) < 0) call fmnegate(mxy(5), qx)
          call fmeq(mxy(5), mresult, qx)
          return
      endif
      if (mxy(5)%mp(2) >= 0 .and. mxy(5)%mp(3) /= 0) then
          call fmcosh(mxy(5), mxy(4), qx)
          if (mxy(4)%mp(2) > qx%ndig) then
              if (ma%mp(1) > 0) then
                  call fmi2m(1, mxy(5), qx)
                  qx%kwarn = kwrnsv
                  if (ma%mp(1) < 0) call fmnegate(mxy(5), qx)
                  call fmeq(mxy(5), mresult, qx)
                  return
              else
                  call fmi2m(-1, mxy(5), qx)
                  qx%kwarn = kwrnsv
                  if (ma%mp(1) < 0) call fmnegate(mxy(5), qx)
                  call fmeq(mxy(5), mresult, qx)
                  return
              endif
          endif
          call fmsqr(mxy(4), mxy(2), qx)
          call fmi2m(-1, mxy(1), qx)
          call fmadd_r1(mxy(2), mxy(1), qx)
          call fmsqrt_r1(mxy(2), qx)
          call fmdiv(mxy(2), mxy(4), mxy(5), qx)
      else
          call fmsinh(mxy(5), mxy(4), qx)
          call fmsqr(mxy(4), mxy(2), qx)
          call fmi2m(1, mxy(1), qx)
          call fmadd_r1(mxy(2), mxy(1), qx)
          call fmsqrt_r1(mxy(2), qx)
          call fmdiv(mxy(4), mxy(2), mxy(5), qx)
      endif
      qx%kwarn = kwrnsv
      if (ma%mp(1) < 0) call fmnegate(mxy(5), qx)
      call fmeq(mxy(5), mresult, qx)

      return
      end subroutine fmtanh_m1

      subroutine fmtanh_sc(ma, mxy, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = tanh(ma).

!  kresult = 1 is returned if a special case gives the value of tanh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult
      type(fm_settings) :: qx

      double precision :: xe
      integer :: j, k
      logical :: lcomp
      logical, external :: fmcomp
      type(multi) :: malocal

      kresult = 0

      qx%namest(qx%ncall) = 'FMTANH   '
      j = qx%ndig
      qx%ndig = ndsave
      call fmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call fmequ(ma, malocal, ndsave, qx%ndig, qx)

      if (malocal%mp(2) == qx%munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif
      call fmovun_xe(malocal, xe, qx)
      if (2*xe < -ndsave) then
          qx%kflag = 0
          call fmndig(qx%ndig + qx%ngrd22, qx)
          call fmequ(malocal, mxy(1), qx%ndig-qx%ngrd22, qx%ndig, qx)
          call fmeq(mxy(1), mxy(3), qx)
          if (qx%kround /= 1) then
              call fmipwr(mxy(1), 3, mxy(3), qx)
              call fmdivi_r1(mxy(3), 3, qx)
              call fmsub_r2(mxy(1), mxy(3), qx)
          endif
          call fmequ(mxy(3), mresult, qx%ndig, qx%ndig-qx%ngrd22, qx)
          call fmndig(qx%ndig - qx%ngrd22, qx)
          kresult = 1
          return
      endif
      if (malocal%mp(2) >= qx%mexpov) then
          j = qx%ntrace
          qx%ntrace = 0
          call fmabs(malocal, mxy(1), qx)
          call fmmpyi(mxy(1), -2, mxy(2), qx)
          call fmexp(mxy(2), mxy(3), qx)
          qx%ndige = 0
          call fmmpyi_r1(mxy(3), 2, qx)
          if (malocal%mp(1) > 0) then
              call fmi2m(1, mxy(1), qx)
              call fmsub(mxy(1), mxy(3), mxy(2), qx)
          else
              call fmi2m(-1, mxy(1), qx)
              call fmadd(mxy(1), mxy(3), mxy(2), qx)
          endif
          qx%ntrace = j
          if (qx%kflag == 1) then
              qx%kflag = 0
              call fmeq(mxy(2), mresult, qx)
              kresult = 1
              return
          endif
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (qx%kround /= 1 .and. malocal%mp(2) < -ndsave) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          call fmsqr(malocal, mxy(1), qx)
          call fmmpy(mxy(1), malocal, mxy(2), qx)
          call fmdivi(mxy(2), -3, mxy(3), qx)
          if (mxy(3)%mp(2) > qx%mexpun) then
              call fmadd(malocal, mxy(3), mresult, qx)
          else if (malocal%mp(2) == qx%mexpun) then
              call fmeq(malocal, mresult, qx)
          else if (malocal%mp(1) < 0 .and. (qx%kround == 2 .or. qx%kround == 0)) then
              call fmeq(malocal, mxy(1), qx)
              mxy(1)%mp(2) = 0
              call fmulp(mxy(1), mxy(2), qx)
              call fmsub(mxy(1), mxy(2), mxy(3), qx)
              mxy(3)%mp(2) = malocal%mp(2) + mxy(3)%mp(2)
              call fmeq(mxy(3), mresult, qx)
          else if (malocal%mp(1) >= 0 .and. (qx%kround == -1 .or. qx%kround == 0)) then
              call fmeq(malocal, mxy(1), qx)
              mxy(1)%mp(2) = 0
              call fmulp(mxy(1), mxy(2), qx)
              call fmsub(mxy(1), mxy(2), mxy(3), qx)
              mxy(3)%mp(2) = malocal%mp(2) + mxy(3)%mp(2)
              call fmeq(mxy(3), mresult, qx)
          else
              call fmeq(malocal, mresult, qx)
          endif
          if (qx%kflag > 0) qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          kresult = 1
          return
      endif
      j = qx%ntrace
      qx%ntrace = 0
      call fmabs(malocal, mxy(1), qx)
      call fmdp2m(qx%dlogmb*qx%ndig, mxy(2), qx)
      lcomp = fmcomp(mxy(1), '>', mxy(2), qx)
      qx%ntrace = j
      if (qx%kround /= 1 .and. lcomp .and. malocal%mp(2) /= qx%munkno) then
          j = qx%ntrace
          qx%ntrace = 0
          k = qx%kwarn
          qx%kwarn = 0
          if (malocal%mp(1) < 0 .and. (qx%kround == 0 .or. qx%kround == 2)) then
              call fmi2m(-1, mxy(1), qx)
              call fmtiny(mxy(2), qx)
              call fmadd(mxy(1), mxy(2), mxy(3), qx)
          else if (malocal%mp(1) > 0 .and. (qx%kround == 0 .or. qx%kround == -1)) then
              call fmi2m(1, mxy(1), qx)
              call fmtiny(mxy(2), qx)
              call fmsub(mxy(1), mxy(2), mxy(3), qx)
          else if (malocal%mp(1) < 0) then
              call fmi2m(-1, mxy(3), qx)
          else
              call fmi2m(1, mxy(3), qx)
          endif
          call fmeq(mxy(3), mresult, qx)
          qx%kflag = 0
          qx%ntrace = j
          qx%kwarn = k
          kresult = 1
          return
      endif

      return
      end subroutine fmtanh_sc

      subroutine fmtiny(ma, qx)

!     ma = The smallest positive representable fm number using the current base and precision.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: j, n1

      call fmalloc(ma, qx%ndig+2, qx)
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMTINY'

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      qx%kflag = 0
      n1 = qx%ndig + 1
      do j = 3, n1
         ma%mp(j+1) = 0
      enddo
      ma%mp(2) = -qx%mxexp0
      ma%mp(1) = 1
      ma%mp(3) = 1

      if (qx%ntrace /= 0) call fmntr_out1(ma, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmtiny

      subroutine fmtrap(ma, qx)

!  If ma has overflowed or underflowed, replace it by the appropriate symbol.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: sign_ma
      double precision :: d, xe, xf

      if (ma%mp(2) == qx%mexpov .or. ma%mp(2) == qx%mexpun) then
          if (size(ma%mp) >= 5) then
              if (ma%mp(5) < 0) then
                  if (ma%mp(2) == qx%mexpov .and. qx%kflag /= 1) qx%kflag = -5
                  if (ma%mp(2) == qx%mexpun .and. qx%kflag /= 1) qx%kflag = -6
                  return
              endif
          endif
      endif
      if (qx%ncall <= 0) return
      sign_ma = ma%mp(1)

      if (ma%mp(2) > qx%mxexp+1) then
          xe = ma%mp(2)
          call fmovun_frac(ma, xf, qx)
          if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          if (xe > huge(qx%mbase)/d) then
              xe = huge(qx%mbase)/d
              xf = 1.0d0 - epsilon(1.0d0)
          else if (xe < -huge(qx%mbase)/d) then
              xe = -huge(qx%mbase)/d
              xf = 1.0d0 - epsilon(1.0d0)
          else if (xe == xe + 1.0d0) then
              xf = 1.0d0 - epsilon(1.0d0)
          endif

          if (sign_ma > 0) then
              call fmi2m2(0, ma, qx)
              ma%mp(2) = qx%mexpov
              ma%mp(3) = 1
          else
              call fmi2m2(0, ma, qx)
              ma%mp(2) = qx%mexpov
              ma%mp(3) = 1
              ma%mp(1) = -1
          endif
          ma%mp(4) = xe
          ma%mp(5) = -xf*maxint
          qx%kflag = -5
      endif

      if (ma%mp(2) < -qx%mxexp) then
          xe = ma%mp(2)
          call fmovun_frac(ma, xf, qx)
          if (ma%mp(1) > 0) then
              call fmi2m2(0, ma, qx)
              ma%mp(2) = qx%mexpun
              ma%mp(3) = 1
          else
              call fmi2m2(0, ma, qx)
              ma%mp(2) = qx%mexpun
              ma%mp(3) = 1
              ma%mp(1) = -1
          endif
          ma%mp(4) = xe
          ma%mp(5) = -xf*maxint
          qx%kflag = -6
      endif

      return
      end subroutine fmtrap

      subroutine fmulp(ma, mb, qx)

!  mb = The value of one Unit in the Last Place of ma at the current base and precision.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: ma1
      integer :: j, kwrnsv, n1

      call fmalloc(mb, qx%ndig+2, qx)
      call fmalloc(qx%mwa, 2*qx%ndig+30, qx)

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      qx%kflag = 0
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMULP'
      if (qx%ntrace /= 0) call fmntr_inp1(ma, qx)

      ma1 = ma%mp(2)
      n1 = qx%ndig + 1
      do j = 3, n1
         qx%mwa%mp(j+1) = 0
      enddo
      qx%mwa%mp(3) = 1
      qx%mwa%mp(2) = ma%mp(2) - qx%ndig + 1
      if (abs(ma%mp(2)) >= qx%mexpov .and. ma%mp(5) < 0) then
          call fmeq(ma, mb, qx)
          mb%mp(4) = mb%mp(4) - qx%ndig
          if (mb%mp(4) < -qx%mxexp) mb%mp(2) = qx%mexpun
          if (mb%mp(4) > 0 .and. mb%mp(4) <= qx%mxexp+1) mb%mp(2) = qx%munkno
          mb%mp(5) = -maxint*(1.0d0/qx%mbase)
      else if (ma%mp(3) == 0 .or. ma%mp(2) == qx%munkno) then
          call fmunknown(mb, qx)
      else
          kwrnsv = qx%kwarn
          if (ma1 == qx%mexpun) qx%kwarn = 0
          if (ma%mp(1) < 0) then
              call fmmove(qx%mwa, mb, qx)
              mb%mp(1) = 1
              if (mb%mp(2) /= qx%munkno .and. mb%mp(3) /= 0) mb%mp(1) = -1
          else
              call fmmove(qx%mwa, mb, qx)
              mb%mp(1) = 1
          endif
          qx%kwarn = kwrnsv
      endif

      if (mb%mp(2) == qx%munkno) qx%kflag = -4
      if (mb%mp(2) == qx%mexpov) qx%kflag = -5
      if (mb%mp(2) == qx%mexpun) qx%kflag = -6
      if (mb%mp(2) == qx%munkno .and. ma%mp(2) /= qx%munkno) call fmwarn(qx)
      if (mb%mp(2) == qx%mexpun .and. ma%mp(2) /= qx%munkno .and.  &
          ma%mp(2) /= qx%mexpun) then
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) then
          call fmntr_out1(mb, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmulp

      subroutine fmunderflow(k, ma, qx)

!  Set ma to fm's special value for underflowed results.

!  k = -1 returns ma = -undeflow

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: k
      intent (in) :: k
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: j
      double precision :: d

      call fmalloc(ma, qx%ndig+2, qx)
      do j = 5, qx%ndig+2
         ma%mp(j) = 0
      enddo
      ma%mp(1) = k
      ma%mp(2) = qx%mexpun
      ma%mp(3) = 1
      if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
          d = 1.0d+10
      else
          d = 4
      endif
      ma%mp(4) = -huge(qx%mbase)/d
      ma%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))

      end subroutine fmunderflow

      subroutine fmunknown(ma, qx)

!  Set ma to fm's special value for unknown results.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: j

      call fmalloc(ma, qx%ndig+2, qx)
      do j = 4, qx%ndig+2
         ma%mp(j) = 0
      enddo
      ma%mp(1) = 1
      ma%mp(2) = qx%munkno
      ma%mp(3) = 1

      end subroutine fmunknown

      subroutine fmvars(qx)

!  Write the values of the fm global variables in module fmvals.

      use fmvals_parallel
      implicit none

      type(fm_settings) :: qx

      write (qx%kw,*) ' '
      write (qx%kw,*) ' Current values of the FM global variables.'
      write (qx%kw,*) ' '
      write (qx%kw,*) ' ALOGM2 = ', qx%alogm2
      write (qx%kw,*) ' ALOGMB = ', qx%alogmb
      write (qx%kw,*) ' ALOGMT = ', qx%alogmt
      write (qx%kw,*) ' ALOGMX = ', qx%alogmx
      write (qx%kw,*) ' CMCHAR = ', qx%cmchar
      write (qx%kw,*) ' DLOGEB = ', qx%dlogeb
      write (qx%kw,*) ' DLOGMB = ', qx%dlogmb
      write (qx%kw,*) ' DLOGPI = ', qx%dlogpi
      write (qx%kw,*) ' DLOGTN = ', qx%dlogtn
      write (qx%kw,*) ' DLOGTP = ', qx%dlogtp
      write (qx%kw,*) ' DLOGTW = ', qx%dlogtw
      write (qx%kw,*) ' DPEPS  = ', qx%dpeps
      write (qx%kw,*) ' DPMAX  = ', dpmax
      write (qx%kw,*) ' DPPI   = ', qx%dppi
      write (qx%kw,*) ' INTMAX = ', intmax
      write (qx%kw,*) ' IUNKNO = ', qx%iunkno
      write (qx%kw,*) ' JFORM1 = ', qx%jform1
      write (qx%kw,*) ' JFORM2 = ', qx%jform2
      write (qx%kw,*) ' JFORMZ = ', qx%jformz
      write (qx%kw,*) ' JPRNTZ = ', qx%jprntz
      write (qx%kw,*) ' KESWCH = ', qx%keswch
      write (qx%kw,*) ' KFLAG  = ', qx%kflag
      write (qx%kw,*) ' KRAD   = ', qx%krad
      write (qx%kw,*) ' KROUND = ', qx%kround
      write (qx%kw,*) ' KSUB   = ', qx%ksub
      write (qx%kw,*) ' KSWIDE = ', qx%kswide
      write (qx%kw,*) ' KW     = ', qx%kw
      write (qx%kw,*) ' KWARN  = ', qx%kwarn
      write (qx%kw,*) ' LHASH  = ', qx%lhash
      write (qx%kw,*) ' LHASH1 = ', lhash1
      write (qx%kw,*) ' LHASH2 = ', lhash2
      write (qx%kw,*) ' LJSUMS = ', ljsums
      write (qx%kw,*) ' LMBERN = ', lmbern
      write (qx%kw,*) ' LMBUFF = ', lmbuff
      write (qx%kw,*) ' LMBUFZ = ', lmbufz
      write (qx%kw,*) ' LVLTRC = ', qx%lvltrc
      write (qx%kw,*) ' MAXINT = ', maxint
      write (qx%kw,*) ' MBASE  = ', qx%mbase
      write (qx%kw,*) ' MBLOGS = ', qx%mblogs
      write (qx%kw,*) ' MBS2PI = ', qx%mbs2pi
      write (qx%kw,*) ' MBSBRN = ', qx%mbsbrn
      write (qx%kw,*) ' MBSE   = ', qx%mbse
      write (qx%kw,*) ' MBSEUL = ', qx%mbseul
      write (qx%kw,*) ' MBSGAM = ', qx%mbsgam
      write (qx%kw,*) ' MBSLB  = ', qx%mbslb
      write (qx%kw,*) ' MBSLI  = ', qx%mbsli
      write (qx%kw,*) ' MBSPI  = ', qx%mbspi
      write (qx%kw,*) ' MEXPAB = ', qx%mexpab
      write (qx%kw,*) ' MEXPOV = ', qx%mexpov
      write (qx%kw,*) ' MEXPUN = ', qx%mexpun
      write (qx%kw,*) ' MUNKNO = ', qx%munkno
      write (qx%kw,*) ' MXBASE = ', mxbase
      write (qx%kw,*) ' MXEXP  = ', qx%mxexp
      write (qx%kw,*) ' MXEXP2 = ', qx%mxexp2
      write (qx%kw,*) ' NCALL  = ', qx%ncall
      write (qx%kw,*) ' NDG2PI = ', qx%ndg2pi
      write (qx%kw,*) ' NDGEUL = ', qx%ndgeul
      write (qx%kw,*) ' NDGGAM = ', qx%ndggam
      write (qx%kw,*) ' NDIG   = ', qx%ndig
      write (qx%kw,*) ' NDIGE  = ', qx%ndige
      write (qx%kw,*) ' NDIGLB = ', qx%ndiglb
      write (qx%kw,*) ' NDIGLI = ', qx%ndigli
      write (qx%kw,*) ' NDIGPI = ', qx%ndigpi
      write (qx%kw,*) ' NGRD21 = ', qx%ngrd21
      write (qx%kw,*) ' NGRD22 = ', qx%ngrd22
      write (qx%kw,*) ' NGRD52 = ', qx%ngrd52
      write (qx%kw,*) ' NTRACE = ', qx%ntrace
      write (qx%kw,*) ' NUMBRN = ', qx%numbrn
      write (qx%kw,*) ' RUNKNO = ', qx%runkno
      write (qx%kw,*) ' SPMAX  = ', spmax
      write (qx%kw,*) ' '
      write (qx%kw,*) ' RADIX(1) = ', radix(1), '    DIGITS(1) = ', digits(1)
      write (qx%kw,*) '    HUGE(1) = ', huge(1)
      write (qx%kw,*) ' RADIX(1.0) = ', radix(1.0), '    DIGITS(1.0) = ', digits(1.0)
      write (qx%kw,*) '    HUGE(1.0)    = ', huge(1.0)
      write (qx%kw,*) '    TINY(1.0)    = ', tiny(1.0)
      write (qx%kw,*) '    EPSILON(1.0) = ', epsilon(1.0)
      write (qx%kw,*) ' RADIX(1.0D0) = ', radix(1.0d0), '    DIGITS(1.0D0) = ', digits(1.0d0)
      write (qx%kw,*) '    HUGE(1.0D0)    = ', huge(1.0d0)
      write (qx%kw,*) '    TINY(1.0D0)    = ', tiny(1.0d0)
      write (qx%kw,*) '    EPSILON(1.0D0) = ', epsilon(1.0d0)
      write (qx%kw,*) ' '

      return
      end subroutine fmvars

      subroutine fmwarn(qx)

!  Called by one of the fm routines to print a warning message if any error condition arises
!  in that routine.

      use fmvals_parallel
      implicit none

      character(9) :: name
      integer :: ncs
      type(fm_settings) :: qx

      if (qx%kflag >= 0 .or. qx%ncall /= 1 .or. qx%kwarn <= 0) return
      ncs = qx%ncall
      name = qx%namest(qx%ncall)
      write (qx%kw,                                  &
             "(/' Error of type KFLAG =', I3, "  //  &
             "' in FM package in routine ', A/)"     &
            ) qx%kflag, trim(name)

      qx%ncall = qx%ncall - 1
      do while (qx%ncall > 0)
         name = qx%namest(qx%ncall)
         write (qx%kw, "( ' called from ', A)") trim(name)
         qx%ncall = qx%ncall - 1
      enddo

      if (qx%kflag == -1) then
          write (qx%kw, "(' NDIG must be at least 3'/)")
      else if (qx%kflag == -2) then
          write (qx%kw, "(' MBASE must be between 2 and', I10/)") int(mxbase)
      else if (qx%kflag == -3) then
          write (qx%kw,                                                   &
                 "(' An input argument is not a valid FM number.', "  //  &
                 "'  Its exponent is out of range.'/)"                    &
                )
          write (qx%kw, "(' UNKNOWN has been returned.'/)")
      else if (qx%kflag == -4 .or. qx%kflag == -7) then
          write (qx%kw, "(' Invalid input argument for this routine.'/)")
          write (qx%kw, "(' UNKNOWN has been returned.'/)")
      else if (qx%kflag == -5) then
          write (qx%kw, "(' The result has overflowed.'/)")
      else if (qx%kflag == -6) then
          write (qx%kw, "(' The result has underflowed.'/)")
      else if (qx%kflag == -8 .and. (name == 'FMOUT' .or. name == 'ZMOUT')) then
          write (qx%kw,                                                       &
                 "(' The result array is not big enough to hold the', "   //  &
                 "' output character string'/' in the current format.'/"  //  &
                 "' The result ''***...***'' has been returned.'/)"           &
                )
      else if (qx%kflag == -8 .and. (name == 'FMREAD' .or. name == 'ZMREAD')) then
          write (qx%kw,                                                      &
                 "(' The CMBUFF array is not big enough to hold the', "  //  &
                 "' input character string'/"                            //  &
                 "' UNKNOWN has been returned.'/)"                           &
                )
      else if (qx%kflag == -9) then
          write (qx%kw,                                             &
                 "(' Precision could not be raised enough to'"  //  &
                 ", ' provide all requested guard digits.'/)"       &
                )
          write (qx%kw,                                      &
                 "(I23, ' digits were requested (NDIG).'/)"  &
                ) qx%ndig
          write (qx%kw, "(' UNKNOWN has been returned.'/)")
      else if (qx%kflag == -10) then
          if (name == 'FMM2SP') then
              write (qx%kw,                                                   &
                     "(' An FM number was too small in magnitude to ', "  //  &
                     "'convert to single precision.'/)"                       &
                    )
          else
              write (qx%kw,                                                   &
                     "(' An FM number was too small in magnitude to ', "  //  &
                     "'convert to double precision.'/)"                       &
                    )
          endif
          write (qx%kw, "(' Zero has been returned.'/)")
      else if (qx%kflag == -11) then
          write (qx%kw, "(' UNKNOWN has been returned.'/)")
      else if (qx%kflag == -12) then
          write (qx%kw, "(' Array MJSUMS is not large enough.')")
      endif

      qx%ncall = ncs
      if (qx%kwarn >= 2) then
          stop
      endif

      return
      end subroutine fmwarn

      subroutine fmwrit(kwrite, ma, qx)

!  Write ma on unit kwrite.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  These numbers can then be read easily using fmread.

      use fmvals_parallel
      implicit none

      character :: cmbuff(lmbuff)
      integer :: kwrite
      type(multi) :: ma
      intent (in) :: ma, kwrite
      type(fm_settings) :: qx

      integer :: j, jf1sav, jf2sav, k, ksave, l, last, lb, nd, ndsave, nexp
      type(multi) :: mxy(1)

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'FMWRIT'
      ndsave = qx%ndig
      call fmndig(max(qx%ndig+qx%ngrd52, 3), qx)

      call fmequ(ma, mxy(1), ndsave, qx%ndig, qx)
      ksave = qx%kflag
      nd = int(real(qx%ndig)*log10(real(qx%mbase))) + 1
      if (nd < 2) nd = 2
      nexp = int(2.0*log10(real(mxbase))) + 16
      lb = nd + nexp

      jf1sav = qx%jform1
      jf2sav = qx%jform2
      qx%jform1 = 1
      qx%jform2 = nd + 6
      if (lb > lmbuff) then
          write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                              " Raise its size (lmbuff) or change the format being used."
          stop
      endif

      call fmout(mxy(1), cmbuff, lb, qx)

      qx%kflag = ksave
      qx%ndig = ndsave
      qx%jform1 = jf1sav
      qx%jform2 = jf2sav
      last = lb + 1
      do j = 1, lb
         if (cmbuff(last-j) /= ' ' .or. j == lb) then
             l = last - j
             if (mod(l, 73) /= 0) then
                 write (kwrite, "(4X, 73A1, ' &')") (cmbuff(k), k=1, l)
             else
                 if (l > 73) write (kwrite, "(4X, 73A1, ' &')") (cmbuff(k), k=1, l-73)
                 write (kwrite, "(4X, 73A1)") (cmbuff(k), k=l-72, l)
             endif
             qx%ncall = qx%ncall - 1
             return
         endif
      enddo
      qx%ncall = qx%ncall - 1

      return
      end subroutine fmwrit

      subroutine fmwrite(kwrite, ma, qx)

      use fmvals_parallel
      implicit none

      integer :: kwrite
      type(multi) :: ma
      intent (in) :: kwrite, ma
      type(fm_settings) :: qx

      call fmwrit(kwrite, ma, qx)

      return
      end subroutine fmwrite


      subroutine im_or_fm_add(ma, mb, mc, qx)

!  Internal routine used by binary splitting algorithms.
!  ma and mb are integers, but if they get bigger than the current precision can represent exactly,
!  it is faster to use fm routines in place of im routines.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      type(multi) :: m1, m2
      integer :: result_size

      if (max(ma%mp(2), mb%mp(2)) > qx%ndig) then
          call fmalloc(mc, qx%ndig+2, qx)
      else
          result_size = max(ma%mp(2), mb%mp(2)) + 4
          if (abs(result_size) >= qx%mexpov) result_size = 5
          result_size = max(5, result_size)
          call fmalloc(mc, result_size, qx)
      endif

      if (max(ma%mp(2), mb%mp(2)) > qx%ndig) then
          if (ma%mp(2) >= qx%ndig .and. mb%mp(2) >= qx%ndig) then
              call fmadd(ma, mb, mc, qx)
          else if (ma%mp(2) >= qx%ndig .and. mb%mp(2) < qx%ndig) then
              call imi2fm(mb, m2, qx)
              call fmadd(ma, m2, mc, qx)
          else if (ma%mp(2) < qx%ndig .and. mb%mp(2) >= qx%ndig) then
              call imi2fm(ma, m1, qx)
              call fmadd(m1, mb, mc, qx)
          else if (ma%mp(2) < qx%ndig .and. mb%mp(2) < qx%ndig) then
              call imi2fm(ma, m1, qx)
              call imi2fm(mb, m2, qx)
              call fmadd(m1, m2, mc, qx)
          endif
      else
          call imadd(ma, mb, mc, qx)
      endif

      return
      end subroutine im_or_fm_add

      subroutine im_or_fm_eq(ma, mb, qx)

!  Internal routine used by binary splitting algorithms.
!  ma is an integer, but if it gets bigger than the current precision can represent exactly,
!  it is faster to use fm routines in place of im routines.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      if (ma%mp(2) >= qx%ndig) then
          call fmeq(ma, mb, qx)
      else
          call imeq(ma, mb, qx)
      endif

      return
      end subroutine im_or_fm_eq

      subroutine im_or_fm_mpy(ma, mb, mc, qx)

!  Internal routine used by binary splitting algorithms.
!  ma and mb are integers, but if they get bigger than the current precision can represent exactly,
!  it is faster to use fm routines in place of im routines.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      type(multi) :: m1, m2
      integer :: result_size

      if (ma%mp(2)+mb%mp(2) > qx%ndig) then
          call fmalloc(mc, qx%ndig+2, qx)
      else
          if (ma%mp(2) >= qx%mexpov .or. mb%mp(2) >= qx%mexpov) then
              result_size = 5
          else
              result_size = ma%mp(2) + mb%mp(2) + 4
          endif
          result_size = max(5, result_size)
          call fmalloc(mc, result_size, qx)
      endif

      if (ma%mp(2)+mb%mp(2) > qx%ndig) then
          if (ma%mp(2) >= qx%ndig .and. mb%mp(2) >= qx%ndig) then
              call fmmpy(ma, mb, mc, qx)
          else if (ma%mp(2) >= qx%ndig .and. mb%mp(2) < qx%ndig) then
              call imi2fm(mb, m2, qx)
              call fmmpy(ma, m2, mc, qx)
          else if (ma%mp(2) < qx%ndig .and. mb%mp(2) >= qx%ndig) then
              call imi2fm(ma, m1, qx)
              call fmmpy(m1, mb, mc, qx)
          else if (ma%mp(2) < qx%ndig .and. mb%mp(2) < qx%ndig) then
              call imi2fm(ma, m1, qx)
              call imi2fm(mb, m2, qx)
              call fmmpy(m1, m2, mc, qx)
          endif
      else
          call immpy(ma, mb, mc, qx)
      endif

      return
      end subroutine im_or_fm_mpy

      subroutine im_or_fm_sqr(ma, mb, qx)

!  Internal routine used by binary splitting algorithms.
!  ma and mb are integers, but if they get bigger than the current precision can represent exactly,
!  it is faster to use fm routines in place of im routines.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      type(multi) :: m1
      integer :: result_size

      if (2*ma%mp(2) > qx%ndig) then
          call fmalloc(mb, qx%ndig+2, qx)
      else
          result_size = 2*ma%mp(2) + 4
          if (abs(result_size) >= qx%mexpov) result_size = 5
          result_size = max(5, result_size)
          call fmalloc(mb, result_size, qx)
      endif

      if (2*ma%mp(2) > qx%ndig) then
          if (ma%mp(2) >= qx%ndig) then
              call fmsqr(ma, mb, qx)
          else
              call imi2fm(ma, m1, qx)
              call fmsqr(m1, mb, qx)
          endif
      else
          call imsqr(ma, mb, qx)
      endif

      return
      end subroutine im_or_fm_sqr



!  The im routines perform integer multiple-precision arithmetic.

      subroutine imabs(ma, mb, qx)

!  mb = abs(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      integer :: kwrnsv, ndsave, result_size

      result_size = max(5, int(ma%mp(2)+3))
      if (abs(result_size) >= qx%mexpov) result_size = 5
      call fmalloc(mb, result_size, qx)

      qx%ncall = qx%ncall + 1
      mb%mp(5) = 0
      ndsave = qx%ndig
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMABS'
          call imntr_inp1(ma, qx)
      endif

      qx%kflag = 0
      kwrnsv = qx%kwarn
      qx%kwarn = 0
      call imeq(ma, mb, qx)
      mb%mp(1) = 1
      qx%kwarn = kwrnsv

      if (qx%ntrace /= 0) call imntr_out1(mb, qx)
      qx%ncall = qx%ncall - 1
      qx%ndig = ndsave

      return
      end subroutine imabs

      function imabs_greater_than(u, v)

!  Return true if abs(u) > abs(v) for IM numbers u, v.

      use fmvals_parallel
      implicit none

      logical :: imabs_greater_than
      type(multi) :: u, v
      intent (in) :: u, v

      integer :: j

      if (u%mp(2) > v%mp(2)) then
          imabs_greater_than = .true.
          return
      else if (u%mp(2) < v%mp(2)) then
          imabs_greater_than = .false.
          return
      endif

      imabs_greater_than = .false.
      do j = 1, int(u%mp(2))
         if (u%mp(j+2) > v%mp(j+2)) then
             imabs_greater_than = .true.
             return
         else if (u%mp(j+2) < v%mp(j+2)) then
             imabs_greater_than = .false.
             return
         endif
      enddo

      end function imabs_greater_than

      subroutine imadd(ma, mb, mc, qx)

!  mc = ma + mb

!  This routine performs the trace printing.  imadd2 is used to do the arithmetic.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      qx%ncall = qx%ncall + 1
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMADD'
          call imntr_inp2(ma, mb, qx)

          call imadd2(ma, mb, mc, qx)

          call imntr_out1(mc, qx)
      else
          call imadd2(ma, mb, mc, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine imadd

      subroutine imadd2(ma, mb, mc, qx)

!  mc = ma + mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: kresult, ndsave, result_size

      result_size = max(ma%mp(2), mb%mp(2)) + 4
      if (abs(result_size) >= qx%mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mc, result_size, qx)

      ndsave = qx%ndig
      qx%kflag = 0
      mc%mp(5) = 0

      call imadd_sc(ma, mb, mc, kresult, qx)
      if (kresult > 0) return

      call imadd3(ma, mb, mc, qx)

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      qx%ndig = ndsave

      return
      end subroutine imadd2

      subroutine imadd3(ma, mb, mc, qx)

!  Internal addition routine.  mc = ma + mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mbs
      integer :: j, jcomp, jsign, n1

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      if (ma%mp(3) == 0) then
          call imeq(mb, mc, qx)
          qx%kflag = 1
          if (qx%ksub == 1) then
              call fmnegate(mc, qx)
              qx%kflag = 0
          endif
          return
      endif
      if (mb%mp(3) == 0) then
          call imeq(ma, mc, qx)
          qx%kflag = 1
          return
      endif

      qx%kflag = 0
      n1 = max(ma%mp(2), mb%mp(2)) + 1

!             jsign is the sign of the result of ma + mb.

      jsign = 1
      mbs = mb%mp(1)
      if (qx%ksub == 1) mbs = -mbs

!             See which one is larger in absolute value.

      jcomp = 2
      if (ma%mp(2) > mb%mp(2)) then
          jcomp = 1
      else if (mb%mp(2) > ma%mp(2)) then
          jcomp = 3
      else
          do j = 2, n1
             if (ma%mp(j+1) > mb%mp(j+1)) then
                 jcomp = 1
                 exit
             endif
             if (mb%mp(j+1) > ma%mp(j+1)) then
                 jcomp = 3
                 exit
             endif
          enddo
      endif

      if (jcomp < 3) then
          if (ma%mp(1) < 0) jsign = -1
          if (ma%mp(1)*mbs > 0) then
              call imaddp(ma, mb, qx)
          else
              call imaddn(ma, mb, qx)
          endif
      else
          if (mbs < 0) jsign = -1
          if (ma%mp(1)*mbs > 0) then
              call imaddp(mb, ma, qx)
          else
              call imaddn(mb, ma, qx)
          endif
      endif

!             Transfer to mc and fix the sign of the result.

      call fmndig(int(qx%mwa%mp(2)), qx)
      if (qx%ndig < 3) qx%ndig = 3
      call fmmove(qx%mwa, mc, qx)
      mc%mp(1) = 1
      if (jsign < 0 .and. mc%mp(3) /= 0) mc%mp(1) = -1

      if (qx%kflag < 0) then
          if (qx%ksub == 1) then
              qx%namest(qx%ncall) = 'IMSUB'
          else
              qx%namest(qx%ncall) = 'IMADD'
          endif
          call fmwarn(qx)
      endif

      return
      end subroutine imadd3

      subroutine imadd_sc(ma, mb, mc, kresult, qx)

!  Special cases for mc = ma + mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      integer :: kresult
      intent (in) :: ma, mb
      intent (inout) :: mc, kresult
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mda, mdab, mdb

      kresult = 0
      if (ma%mp(2) <= 2) then
          if (mb%mp(2) <= 2 .and. ma%mp(2) >= 0 .and. mb%mp(2) >= 0) then
              if (ma%mp(2) <= 1) then
                  mda = ma%mp(1) * ma%mp(3)
              else
                  mda = ma%mp(1) * (ma%mp(3)*qx%mbase + ma%mp(4))
              endif
              if (mb%mp(2) <= 1) then
                  mdb = mb%mp(1) * mb%mp(3)
              else
                  mdb = mb%mp(1) * (mb%mp(3)*qx%mbase + mb%mp(4))
              endif
              mdab = mda + mdb
              if (abs(mdab) < qx%mbase) then
                  mc%mp(2) = 1
                  if (mdab == 0) mc%mp(2) = 0
                  if (mdab < 0) then
                      mc%mp(3) = -mdab
                      mc%mp(1) = -1
                  else
                      mc%mp(3) = mdab
                      mc%mp(1) = 1
                  endif
                  mc%mp(4) = 0
                  if (mda == 0 .or. mdb == 0) qx%kflag = 1
                  kresult = 1
                  return
              else if (abs(mdab) < qx%mbase*qx%mbase) then
                  mc%mp(2) = 2
                  if (mdab < 0) then
                      mc%mp(3) = aint (-mdab/qx%mbase)
                      mc%mp(4) = abs(-mdab - qx%mbase*mc%mp(3))
                      mc%mp(1) = -1
                  else
                      mc%mp(3) = aint (mdab/qx%mbase)
                      mc%mp(4) = abs(mdab - qx%mbase*mc%mp(3))
                      mc%mp(1) = 1
                  endif
                  if (mda == 0 .or. mdb == 0) qx%kflag = 1
                  kresult = 1
                  return
              endif
          endif
      endif

      if (ma%mp(2) < 0 .or. mb%mp(2) < 0 .or.  &
          ma%mp(2) >= qx%mexpov .or. mb%mp(2) >= qx%mexpov) then
          if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) then
              call imi2m2(0, mc, qx)
              mc%mp(2) = qx%munkno
              mc%mp(3) = 1
              qx%kflag = -4
              kresult = 1
              return
          endif
          if (ma%mp(2) == qx%mexpov) then
              if (ma%mp(1) == mb%mp(1) .or. mb%mp(3) == 0) then
                  mc%mp(1) = ma%mp(1)
                  mc%mp(2) = ma%mp(2)
                  mc%mp(3) = ma%mp(3)
                  mc%mp(4) = ma%mp(4)
                  qx%kflag = -5
                  kresult = 1
                  return
              else
                  qx%kflag = -4
                  qx%namest(qx%ncall) = 'IMADD'
                  call fmwarn(qx)
                  call imi2m2(0, mc, qx)
                  mc%mp(2) = qx%munkno
                  mc%mp(3) = 1
                  kresult = 1
                  return
              endif
          endif
          if (mb%mp(2) == qx%mexpov) then
              if (mb%mp(1) == ma%mp(1) .or. ma%mp(3) == 0) then
                  mc%mp(1) = mb%mp(1)
                  mc%mp(2) = mb%mp(2)
                  mc%mp(3) = mb%mp(3)
                  mc%mp(4) = mb%mp(4)
                  qx%kflag = -5
                  kresult = 1
                  return
              else
                  qx%kflag = -4
                  qx%namest(qx%ncall) = 'IMADD'
                  call fmwarn(qx)
                  call imi2m2(0, mc, qx)
                  mc%mp(2) = qx%munkno
                  mc%mp(3) = 1
                  kresult = 1
                  return
              endif
          endif
          qx%kflag = -4
          qx%namest(qx%ncall) = 'IMADD'
          call fmwarn(qx)
          call imi2m2(0, mc, qx)
          mc%mp(2) = qx%munkno
          mc%mp(3) = 1
          kresult = 1
      endif

      return
      end subroutine imadd_sc

      subroutine imaddn(ma, mb, qx)

!  Internal addition routine.  mwa = ma - mb
!  The arguments are such that ma >= mb >= 0.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma, mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mk
      integer :: j, k, kl, kp1, kp2, kpt, ksh, n1, result_size

      result_size = 2*ma%mp(2) + 30
      if (abs(result_size) >= qx%mexpov) result_size = 32
      result_size = max(32, result_size)
      call fmalloc(qx%mwa, result_size, qx)

      if (ma%mp(2) == qx%mexpov .or. mb%mp(2) == qx%mexpov) then
          qx%kflag = -4
          qx%mwa%mp(2) = qx%munkno
          qx%mwa%mp(3) = 1
          qx%mwa%mp(4) = 0
          return
      endif

      n1 = ma%mp(2) + 1
      mk = ma%mp(2) - mb%mp(2)
      k = int(mk)

!             Subtract mb from ma.

      kp1 = min(n1, k+1)
      do j = 1, kp1
         qx%mwa%mp(j+1) = ma%mp(j+1)
      enddo
      kp2 = k + 2

!             (Inner Loop)

      do j = kp2+1, n1+1
         qx%mwa%mp(j) = ma%mp(j) - mb%mp(j-k)
      enddo
      qx%mwa%mp(1+n1+1) = 0

!             Normalize.  Fix the sign of any negative digit.

      if (k > 0) then
          do j = n1, kp2, -1
             if (qx%mwa%mp(j+1) < 0) then
                 qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + qx%mbase
                 qx%mwa%mp(j) = qx%mwa%mp(j) - 1
             endif
          enddo
          kpt = kp2 - 1
          do while (qx%mwa%mp(kpt+1) < 0 .and. kpt >= 3)
             qx%mwa%mp(kpt+1) = qx%mwa%mp(kpt+1) + qx%mbase
             qx%mwa%mp(kpt) = qx%mwa%mp(kpt) - 1
             kpt = kpt - 1
          enddo
      else
          do j = n1, 3, -1
             if (qx%mwa%mp(j+1) < 0) then
                 qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + qx%mbase
                 qx%mwa%mp(j) = qx%mwa%mp(j) - 1
             endif
          enddo
      endif

!             Shift left if there are any leading zeros in the mantissa.

      ksh = 0
      kl = 1
      do j = 2, n1
         if (qx%mwa%mp(j+1) > 0) then
             ksh = j - 2
             kl = 0
             exit
         endif
      enddo
      if (kl == 1) then
          qx%mwa%mp(2) = 0
          qx%mwa%mp(4) = 0
          return
      endif

      if (ksh > 0) then
          kl = n1 - ksh
          do j = 2, kl
             qx%mwa%mp(j+1) = qx%mwa%mp(j+ksh+1)
          enddo
          do j = kl+1, n1
             qx%mwa%mp(j+1) = 0
          enddo
          qx%mwa%mp(2) = qx%mwa%mp(2) - ksh
      endif

      return
      end subroutine imaddn

      subroutine imaddp(ma, mb, qx)

!  Internal addition routine.  mwa = ma + mb
!  The arguments are such that ma >= mb >= 0.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma, mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mk
      integer :: j, k, kp2, kpt, n1, result_size

      result_size = 2*(ma%mp(2)+1) + 30
      if (abs(result_size) >= qx%mexpov) result_size = 32
      result_size = max(32, result_size)
      call fmalloc(qx%mwa, result_size, qx)

      n1 = ma%mp(2) + 1
      mk = ma%mp(2) - mb%mp(2)
      k = int(mk)

!             Add ma and mb.

      qx%mwa%mp(2) = ma%mp(2) + 1
      qx%mwa%mp(3) = 0
      do j = 2, k+1
         qx%mwa%mp(j+2) = ma%mp(j+1)
      enddo
      kp2 = k + 2

!             (Inner Loop)

      do j = kp2+1, n1+1
         qx%mwa%mp(j+1) = ma%mp(j) + mb%mp(j-k)
      enddo
      qx%mwa%mp(n1+3) = 0

!             Normalize.  Fix any digit not less than mbase.

      if (k > 0) then
          do j = n1+1, kp2, -1
             if (qx%mwa%mp(j+1) >= qx%mbase) then
                 qx%mwa%mp(j+1) = qx%mwa%mp(j+1) - qx%mbase
                 qx%mwa%mp(j) = qx%mwa%mp(j) + 1
             endif
          enddo
          kpt = kp2 - 1
          do while (qx%mwa%mp(kpt+1) >= qx%mbase .and. kpt >= 3)
             qx%mwa%mp(kpt+1) = qx%mwa%mp(kpt+1) - qx%mbase
             qx%mwa%mp(kpt) = qx%mwa%mp(kpt) + 1
             kpt = kpt - 1
          enddo
      else
          do j = n1+1, 3, -1
             if (qx%mwa%mp(j+1) >= qx%mbase) then
                 qx%mwa%mp(j+1) = qx%mwa%mp(j+1) - qx%mbase
                 qx%mwa%mp(j) = qx%mwa%mp(j) + 1
             endif
          enddo
      endif

      return
      end subroutine imaddp

      subroutine imbig(ma, qx)

!  ma = a very large im integer.

!  Before version 1.3 of fm, this routine returned the largest representable im integer.
!  Starting with version 1.3 the size of im integers is limited only by the space available
!  in the working array mwk in fmsave.f95.
!  But if this routine set ma as large as possible, it would leave no room for other
!  fm/im/zm numbers.  So a result of 10**(10**6) is returned here.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: l, result_size
      type(multi) :: mxy(2)

      l = 1.05d+6*log(10.0d0)/log(dble(qx%mbase)) + 3
      result_size = l + 3
      result_size = max(5, result_size)
      call fmalloc(ma, result_size, qx)

      qx%ncall = qx%ncall + 1
      ma%mp(5) = 0
      qx%namest(qx%ncall) = 'IMBIG'

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      qx%kflag = 0
      call imi2m(10, mxy(1), qx)
      call imi2m(10**6, mxy(2), qx)
      call impwr(mxy(1), mxy(2), ma, qx)

      if (qx%ntrace /= 0 .and. qx%ncall <= qx%lvltrc) then
          write (qx%kw,                                                   &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', I10)"  &
                ) 'IMBIG', qx%ncall, int(qx%mbase)
          write (qx%kw,*) '       1.0M+1000000'
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine imbig

      subroutine imcomb(ma, mb, mc, qx)

!  Binomial coefficients for integers.  ma, mb, mc, are all multiprecision integers.

!  mc = ma choose mb = ma! / ( mb! * (ma-mb)! )

!  This routine extends this definition to allow negative integer values for ma and/or mb.
!  The standard recurrence comb(n,k) = comb(n-1,k-1) + comb(n-1,k) can be used to define
!  comb(n,k) for all integers n,k starting from the initializing definitions
!  comb(0,k) = 0, for all k except 0,
!  comb(n,0) = 1, for all n.
!  Ex:  n = 1, k = 1 => comb(1,1) = comb(0,0)   +  comb(0,1)
!                    => comb(1,1) =         1   +          0,  so  comb(1,1)   =  1
!       n = 0, k = 0 => comb(0,0) = comb(-1,-1) + comb(-1,0)
!                    =>         1 = comb(-1,-1) +          1,  so  comb(-1,-1) =  0
!       n = 0, k = 1 => comb(0,1) = comb(-1,0)  + comb(-1,1)
!                    =>         0 =          1  + comb(-1,1),  so  comb(-1,1)  = -1

!  This definition agrees with the standard factorial definition when n and k are non-negative
!  integers.  The factorial definition is undefined when n or k is a negative integer, since
!  x! has singularities at negative integers.

!  For negative n or k, this extended definition simplifies to:
!  if k < 0,             comb(n,k) = 0
!  if k >= 0 and n < 0,  comb(n,k) = (-1)**k * comb(-n+k-1,k)

!  These extended definitions are useful in some combinatorial applications.
!  Reference:  Concrete Mathematics - Graham, Knuth, Patashnik, Addison-Wesley, 1989.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      type(multi) :: mt, mxy(3)
      integer :: j, k, kmod2, kresult, l, n

      qx%ncall = qx%ncall + 1
      call imi2m(0, mc, qx)
      mc%mp(5) = 0
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMCOMB'
          call imntr_inp2(ma, mb, qx)
      endif

      call imm2i(ma, n, qx)
      if (qx%kflag == 0) then
          call imm2i(mb, k, qx)
          if (qx%kflag == 0) then
              call imcombi(n, k, mt, qx)
              call imeq(mt, mc, qx)
              if (qx%ntrace /= 0) call imntr_out1(mc, qx)
              qx%ncall = qx%ncall - 1
              return
          endif
      endif
      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      call imcomb_sc(ma, mb, mt, mxy, l, kresult, qx)
      if (kresult == 0) then

!             Compute the binomial coefficient.

          call imeq(mxy(3), mt, qx)
          call imi2m(1, mxy(1), qx)
          do j = 2, l
             call imsub(mxy(3), mxy(1), mxy(2), qx)
             call imeq(mxy(2), mxy(3), qx)
             call immpy(mxy(3), mt, mxy(2), qx)
             call imdivi(mxy(2), j, mt, qx)
          enddo
      endif

      call immodi(mb, 2, kmod2, qx)
      if (ma%mp(1) < 0 .and. kmod2 == 1) call fmnegate(mt, qx)
      call imeq(mt, mc, qx)
      if (qx%ntrace /= 0) call imntr_out1(mc, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine imcomb

      subroutine imcomb2(ma, mb, mc, qx)

!  Binomial coefficients for integers.  ma, mb, mc, are all multiprecision integers.

!  mc = ma choose mb = ma! / ( mb! * (ma-mb)! )

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      type(multi) :: mxy(3)
      integer :: j, j1, j1fac, kmod2, kpt, kpt2, kresult, l, r
      type(multi), allocatable :: top(:)
      type(multi) :: mt

      qx%ncall = qx%ncall + 1
      call imi2m(0, mc, qx)
      mc%mp(5) = 0
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMCOMB2'
          call imntr_inp2(ma, mb, qx)
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      if (ma%mp(1) < 0) then
          call imsub(mb, ma, mxy(1), qx)
          call imi2m(1, mxy(2), qx)
          call imsub(mxy(1), mxy(2), mxy(3), qx)
      else
          call imeq(ma, mxy(3), qx)
      endif

      call imcomb2_sc(mb, mxy, mt, l, kresult, qx)
      if (kresult == 0) then

!             Compute the binomial coefficient by making a list of the numerator terms
!             n, n-1, ..., n-l+1.  Then divide out each of the denominator terms 2, 3, ..., l.

          allocate(top(l), stat=j)
          if (j /= 0) then
              call fmdefine_error
          endif
          call imi2m(1, mxy(1), qx)
          call imeq(mxy(3), top(1), qx)
          do j = 2, l
             call imsub(top(j-1), mxy(1), top(j), qx)
          enddo

          do j = l, 2, -1
             call immodi(mxy(3), j, r, qx)
             kpt = r + 1
             do while (kpt <= l)
                call immodi(top(kpt), j, r, qx)
                if (r == 0) then
                    call imdivi(top(kpt), j, mxy(2), qx)
                    call imeq(mxy(2), top(kpt), qx)
                    exit
                endif
                kpt = kpt + j
                if (kpt > l) then
                    j1 = j
                    do while (j1 > 1)
                       call imcomb2_factor(j1, j1fac)
                       call immodi(mxy(3), j1fac, r, qx)
                       kpt2 = r + 1
                       do while (kpt2 <= l)
                          call immodi(top(kpt2), j1fac, r, qx)
                          if (r == 0) then
                              call imdivi(top(kpt2), j1fac, mxy(2), qx)
                              call imeq(mxy(2), top(kpt2), qx)
                              exit
                          endif
                          kpt2 = kpt2 + j1fac
                       enddo
                    enddo
                endif
             enddo
          enddo

!             Form the product of the remaining top terms.

          call imeq(top(1), mt, qx)
          do j = 2, l
             if (top(j)%mp(2) > 1 .or.  &
                (top(j)%mp(2) == 1 .and. top(j)%mp(3) > 1)) then
                 call immpy(top(j), mt, mxy(2), qx)
                 call imeq(mxy(2), mt, qx)
             endif
          enddo

          deallocate(top)
      endif

      call imi2m(2, mxy(1), qx)
      call immod(mb, mxy(1), mxy(2), qx)
      call imm2i(mxy(2), kmod2, qx)
      if (ma%mp(1) < 0 .and. kmod2 == 1) call fmnegate(mt, qx)
      call imeq(mt, mc, qx)
      if (qx%ntrace /= 0) call imntr_out1(mc, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine imcomb2

      subroutine imcomb2_factor(j1, j1fac)

!  Return j1fac as one prime factor of j1, and return j1 with the value j1 / j1fac

      implicit none

      integer :: j1, j1fac
      intent (inout) :: j1, j1fac

      integer :: j

      if (mod(j1, 2) == 0) then
          j1fac = 2
          j1 = j1 / j1fac
          return
      endif

      if (mod(j1, 3) == 0) then
          j1fac = 3
          j1 = j1 / j1fac
          return
      endif

      do j = 5, int(sqrt(dble(j1)))+1, 6
         j1fac = j
         if (mod(j1, j1fac) == 0) then
             j1 = j1 / j1fac
             return
         endif
         j1fac = j + 2
         if (mod(j1, j1fac) == 0) then
             j1 = j1 / j1fac
             return
         endif
      enddo

      j1fac = j1
      j1 = 1

      end subroutine imcomb2_factor

      subroutine imcomb2_sc(mb, mxy, mresult, l, kresult, qx)

!  Special cases for  ma choose mb = ma! / ( mb! * (ma-mb)! )

      use fmvals_parallel
      implicit none

      type(multi) :: mb, mxy(3), mresult
      integer :: l, kresult
      intent (in) :: mb
      intent (inout) :: mxy, mresult, l, kresult
      type(fm_settings) :: qx

      kresult = 0
      call imsub(mxy(3), mb, mxy(1), qx)
      call immin(mb, mxy(1), mxy(2), qx)
      if (mxy(2)%mp(1) < 0) then
          call imi2m(0, mresult, qx)
          kresult = 1
          return
      else if (mxy(2)%mp(3) == 0) then
          call imi2m(1, mresult, qx)
          kresult = 1
          return
      endif
      call imm2i(mxy(2), l, qx)

!             If l = min(k,n-k) is too big to represent as a machine integer, return unknown,
!             since the binomial result mc would have over half a billion digits.

      if (qx%kflag /= 0) then
          call imunknown(mresult, qx)
          kresult = 1
          return
      endif
      if (l == 1) then
          call imeq(mxy(3), mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine imcomb2_sc

      subroutine imcomb_sc(ma, mb, mresult, mxy, l, kresult, qx)

!  Special cases for  ma choose mb = ma! / ( mb! * (ma-mb)! )

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mresult, mxy(3)
      integer :: l, kresult
      intent (in) :: ma, mb
      intent (inout) :: mresult, mxy, l, kresult
      type(fm_settings) :: qx

      kresult = 0
      if (ma%mp(1) < 0) then
          call imsub(mb, ma, mxy(1), qx)
          call imi2m(1, mxy(2), qx)
          call imsub(mxy(1), mxy(2), mxy(3), qx)
      else
          call imeq(ma, mxy(3), qx)
      endif
      call imsub(mxy(3), mb, mxy(1), qx)
      call immin(mb, mxy(1), mxy(2), qx)
      if (mxy(2)%mp(1) < 0) then
          call imi2m(0, mresult, qx)
          kresult = 1
          return
      else if (mxy(2)%mp(3) == 0) then
          call imi2m(1, mresult, qx)
          kresult = 1
          return
      endif
      call imm2i(mxy(2), l, qx)

!             If l = min(k,n-k) is too big to represent as a machine integer, return unknown,
!             since the binomial result mc would have over half a billion digits.

      if (qx%kflag /= 0) then
          call imunknown(mresult, qx)
          kresult = 1
          return
      endif
      if (l == 1) then
          call imeq(mxy(3), mresult, qx)
          kresult = 1
          return
      endif
      if (l > 10) then
          call imcomb2(mxy(3), mxy(2), mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine imcomb_sc

      subroutine imcombi(n, k, ma, qx)

!  Binomial coefficients for integers.
!  n, k, are machine precision integers, ma is a multiprecision integer.

!  ma = n choose k = n! / ( k! * (n-k)! )

!  See the comments in imcomb about results for negative n, etc.

      use fmvals_parallel
      implicit none

      integer :: n, k
      type(multi) :: ma
      intent (in) :: n, k
      intent (inout) :: ma
      type(fm_settings) :: qx

      type(multi) :: mxy(2)
      integer :: l, n1, nmethd
      integer :: j, kstart, kt, large, larged, ndiv, nextd, nextn, nmpy, ntd, ntn, result_size
      double precision :: cn, ck, cnk, e, logn, logk, lognk, pi

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      n1 = n
      if (n < 0) n1 = -n + k - 1
      cn = max(1, n1)
      ck = max(1, k)
      ck = min(ck, cn)
      cnk = max(1, n1-k)
      cnk = min(cnk, cn)
      e = exp(1.0d0)
      pi = acos(-1.0d0)
      logn = (log( 2*pi*cn )/2) + cn*log( cn/e ) + log( 1 + 1/(12.0d0*cn) )
      logk = (log( 2*pi*ck )/2) + ck*log( ck/e ) + log( 1 + 1/(12.0d0*ck) )
      lognk = (log( 2*pi*cnk )/2) + cnk*log( cnk/e ) + log( 1 + 1/(12.0d0*cnk) )
      l = min(k, n1-k)
      if (logn < 1.0d+10) then
          result_size = (logn - logk - lognk) / qx%dlogmb + 7
      else
          result_size = (l*log(cn) - min(logk, lognk)) / qx%dlogmb + 7
      endif
      if (abs(result_size) >= qx%mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(ma, result_size, qx)

      if (l < 0) then
          call imi2m(0, ma, qx)
          return
      else if (l == 0) then
          call imi2m(1, ma, qx)
          if (n < 0 .and. mod(k, 2) == 1) call fmnegate(ma, qx)
          return
      else if (l == 1) then
          call imi2m(n1, ma, qx)
          if (n < 0 .and. mod(k, 2) == 1) call fmnegate(ma, qx)
          return
      endif
      ma%mp(5) = 0

!             Determine which method to use.

      nmethd = 2
      if (n1 >= 2100) then
          if (n1 >= 10**7) then
              if (l >= 8) nmethd = 1
          else
              if (l > exp(10.7d0 - 0.53d0*log(cn))) nmethd = 1
          endif
      endif

      if (nmethd == 1) then
          call imfact_p(n1-l+1, n1, mxy(1), qx)
          call imfact_p(2, l, mxy(2), qx)
          call imdiv(mxy(1), mxy(2), ma, qx)
          if (n < 0 .and. mod(k, 2) == 1) call fmnegate(ma, qx)
          return
      endif

!             Find the largest value for n1 choose j using integers.

      ntn = n1
      ntd = 1
      large = int(intmax/n1)
      do j = 2, l
         if (ntn <= large) then
             ntn = (ntn*((n1+1)-j))/j
         else
             call imi2m(ntn, ma, qx)
             ntn = (n1+1) - j
             ntd = j
             exit
         endif
      enddo

      if (ntd == 1) then
          call imi2m(ntn, ma, qx)
          if (n < 0 .and. mod(k, 2) == 1) call fmnegate(ma, qx)
          return
      endif

      nextn = ntn
      nextd = ntd
      kstart = ntd + 1

!             Compute the rest of n1 choose k.

      larged = min(large, int(mxbase))
      do kt = kstart, l
         nextn = nextn - 1
         nextd = nextd + 1
         if (ntn >= large .or. ntd >= larged) then
             call immpyi(ma, ntn, mxy(1), qx)
             call imdivi(mxy(1), ntd, ma, qx)
             ntn = nextn
             ntd = nextd
             cycle
         endif
         nmpy = ntn*nextn
         ndiv = ntd*nextd
         if (nmpy <= large .and. ndiv <= larged) then
             ntn = nmpy
             ntd = ndiv
         else
             call fmgcdi(nmpy, ndiv)
             if (nmpy <= large .and. ndiv <= larged) then
                 ntn = nmpy
                 ntd = ndiv
             else
                 call immpyi(ma, ntn, mxy(1), qx)
                 call imdivi(mxy(1), ntd, ma, qx)
                 ntn = nextn
                 ntd = nextd
             endif
         endif
      enddo
      call fmgcdi(ntn, ntd)
      call immpyi(ma, ntn, mxy(1), qx)
      call imdivi(mxy(1), ntd, ma, qx)

      if (n < 0 .and. mod(k, 2) == 1) call fmnegate(ma, qx)

      return
      end subroutine imcombi

      function imcomp(ma, lrel, mb, qx)

!  Logical comparison of FM numbers ma and mb.

!  lrel is a character description of the comparison to be done:
!  lrel = 'eq' returns imcomp = .true. if ma == mb
!       = 'ne', 'ge', 'gt', 'le', 'lt' also work like a logical if.
!       = '==', '/=', '<', '<=', '>', '>=' may be used.

      use fmvals_parallel
      implicit none

      logical :: imcomp
      character(*) :: lrel
      type(multi) :: ma, mb
      intent (in) :: ma, lrel, mb
      type(fm_settings) :: qx

      character(2) :: jrel
      integer :: jcomp, kresult, ndsave, ntrsav

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'IMCOMP'

      if (qx%ncall <= qx%lvltrc .and. abs(qx%ntrace) >= 2) then
          write (qx%kw, "(' Input to IMCOMP')")
          ndsave = qx%ndig
          if (qx%ntrace > 0) then
              call imprnt(ma, qx)
              if (index('=/<>', lrel(1:1)) > 0) then
                  write (qx%kw, "(8X, A)") lrel
              else
                  write (qx%kw, "(7X, '.', A, '.')") lrel
              endif
              call imprnt(mb, qx)
          else
              call fmndig(max(3, int(ma%mp(2))), qx)
              ntrsav = qx%ntrace
              call imntrj(ma, qx%ndig, qx)
              if (index('=/<>', lrel(1:1)) > 0) then
                  write (qx%kw, "(8X, A)") lrel
              else
                  write (qx%kw, "(7X, '.', A, '.')") lrel
              endif
              call fmndig(max(3, int(mb%mp(2))), qx)
              call imntrj(mb, qx%ndig, qx)
              qx%ntrace = ntrsav
          endif
          qx%ndig = ndsave
      endif

      call imcomp_sc(ma, lrel, mb, jrel, kresult, qx)
      if (kresult == 0) then
          call imcomp_m1(ma, mb, jcomp, qx)
      else
          imcomp = .false.
          call imcomp2(0, qx)
          return
      endif

!             jcomp is 1 if ma > mb
!                      2 if ma == mb
!                      3 if ma < mb

!             Match the jcomp value to the requested comparison.

      if (jcomp == 1 .and. ma%mp(1) < 0) then
          jcomp = 3
      else if (jcomp == 3 .and. mb%mp(1) < 0) then
          jcomp = 1
      endif

      imcomp = .false.
      if (jcomp == 1 .and. (jrel == 'GT' .or. jrel == 'GE' .or. jrel == 'NE')) imcomp = .true.
      if (jcomp == 2 .and. (jrel == 'EQ' .or. jrel == 'GE' .or. jrel == 'LE')) imcomp = .true.
      if (jcomp == 3 .and. (jrel == 'NE' .or. jrel == 'LT' .or. jrel == 'LE')) imcomp = .true.

      jcomp = 0
      if (imcomp) jcomp = 1
      call imcomp2(jcomp, qx)

      return
      end function imcomp

      subroutine imcomp2(jcomp, qx)

!  Trace printing on exit from imcomp.

      use fmvals_parallel
      implicit none

      integer :: jcomp
      intent (in) :: jcomp
      type(fm_settings) :: qx

      if (qx%ntrace /= 0) then
          if (qx%ncall <= qx%lvltrc .and. abs(qx%ntrace) >= 1) then
              if (qx%kflag == 0) then
                  write (qx%kw,                                           &
                         "(' IMCOMP', 15X, 'Call level =', I2, 5X, "  //  &
                         "'MBASE =', I10)"                                &
                        ) qx%ncall, int(qx%mbase)
              else
                  write (qx%kw,                                          &
                         "(' IMCOMP', 6X, 'Call level =', I2, 4X, "  //  &
                         "'MBASE =', I10, 4X, 'KFLAG =', I3)"            &
                        ) qx%ncall, int(qx%mbase), qx%kflag
              endif
              if (jcomp == 1) then
                  write (qx%kw, "(7X, '.TRUE.')")
              else
                  write (qx%kw, "(7X, '.FALSE.')")
              endif
          endif
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine imcomp2

      subroutine imcomp_m1(ma, mb, jcomp, qx)

!  jcomp will be 1 if ma > mb
!                2 if ma == mb
!                3 if ma < mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: jcomp
      intent (in) :: ma, mb
      intent (inout) :: jcomp
      type(fm_settings) :: qx

      integer :: j, nlast

!             Check for zero.

      qx%kflag = 0
      if (ma%mp(3) == 0) then
          jcomp = 2
          if (mb%mp(3) == 0) return
          if (mb%mp(1) < 0) jcomp = 1
          if (mb%mp(1) > 0) jcomp = 3
          return
      endif
      if (mb%mp(3) == 0) then
          jcomp = 1
          if (ma%mp(1) < 0) jcomp = 3
          return
      endif

!             Check for opposite signs.

      if (ma%mp(1) > 0 .and. mb%mp(1) < 0) then
          jcomp = 1
          return
      endif
      if (mb%mp(1) > 0 .and. ma%mp(1) < 0) then
          jcomp = 3
          return
      endif

!             See which one is larger in absolute value.

      if (ma%mp(2) > mb%mp(2)) then
          jcomp = 1
          return
      endif
      if (mb%mp(2) > ma%mp(2)) then
          jcomp = 3
          return
      endif
      nlast = int(ma%mp(2)) + 1

      do j = 2, nlast
         if (abs(ma%mp(j+1)) > abs(mb%mp(j+1))) then
             jcomp = 1
             return
         endif
         if (abs(mb%mp(j+1)) > abs(ma%mp(j+1))) then
             jcomp = 3
             return
         endif
      enddo

      jcomp = 2

      return
      end subroutine imcomp_m1

      subroutine imcomp_sc(ma, lrel, mb, jrel, kresult, qx)

!  Special cases for logical comparison of FM numbers ma and mb.

      use fmvals_parallel
      implicit none

      character(*) :: lrel
      type(multi) :: ma, mb
      character(2) :: jrel
      integer :: kresult
      intent (in) :: ma, lrel, mb
      intent (inout) :: jrel, kresult
      type(fm_settings) :: qx

      kresult = 0

      jrel = lrel
      if (lrel /= 'EQ' .and. lrel /= 'NE' .and. lrel /= 'LT' .and.  &
          lrel /= 'GT' .and. lrel /= 'LE' .and. lrel /= 'GE') then
          if (lrel == 'eq' .or. lrel == '==') then
              jrel = 'EQ'
          else if (lrel == 'ne' .or. lrel == '/=') then
              jrel = 'NE'
          else if (lrel == 'lt' .or. lrel == '<') then
              jrel = 'LT'
          else if (lrel == 'gt' .or. lrel == '>') then
              jrel = 'GT'
          else if (lrel == 'le' .or. lrel == '<=') then
              jrel = 'LE'
          else if (lrel == 'ge' .or. lrel == '>=') then
              jrel = 'GE'
          else
              qx%kflag = -4
              if (qx%ncall /= 1 .or. qx%kwarn <= 0) then
                  kresult = 1
                  return
              endif
              write (qx%kw,                                                      &
                     "(/' Error of type KFLAG = -4 in FM package in', "      //  &
                     "' routine IMCOMP'//1X, A, ' is not one of the six', "  //  &
                     "' recognized comparisons.'//' .FALSE. has been', "     //  &
                     "' returned.'/)"                                            &
                    ) lrel
              if (qx%kwarn >= 2) then
                  stop
              endif
              kresult = 1
              return
          endif
      endif

      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) then
          qx%kflag = -4
          kresult = 1
          return
      endif

      if (abs(ma%mp(2)) == qx%mexpov .and. ma%mp(2) == mb%mp(2) .and.  &
          ma%mp(3) == mb%mp(3) .and. ma%mp(1) == mb%mp(1)) then
          qx%kflag = -4
          if (qx%ncall /= 1 .or. qx%kwarn <= 0) then
              kresult = 1
              return
          endif
          write (qx%kw,                                                   &
                 "(/' Error of type KFLAG = -4 in FM package in ', "  //  &
                 "'routine IMCOMP'//' Two numbers in the same ', "    //  &
                 "'overflow category cannot be compared.'//"          //  &
                 "' .FALSE. has been returned.'/)"                        &
                )
          if (qx%kwarn >= 2) then
              stop
          endif
          kresult = 1
          return
      endif

      return
      end subroutine imcomp_sc

      function imcompare(ma, lrel, mb, qx)

      use fmvals_parallel
      implicit none

      logical :: imcompare
      character(*) :: lrel
      type(multi) :: ma, mb
      intent (in) :: ma, lrel, mb
      logical, external :: imcomp
      type(fm_settings) :: qx

      imcompare = imcomp(ma, lrel, mb, qx)

      return
      end function imcompare

      subroutine imdim(ma, mb, mc, qx)

!  mc = dim(ma, mb)

!  Positive difference.  mc = ma - mb  if ma >= mb,
!                           = 0        otherwise.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: kovfl, result_size
      logical, external :: imcomp

      result_size = max(ma%mp(2), mb%mp(2)) + 3
      if (abs(result_size) >= qx%mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mc, result_size, qx)

      qx%kflag = 0
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'IMDIM'
      mc%mp(5) = 0
      if (qx%ntrace /= 0) then
          call imntr_inp2(ma, mb, qx)
      endif

      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) then
          call imunknown(mc, qx)
          qx%kflag = -4
          call imdim2(mc, qx)
          return
      endif
      if (ma%mp(2) < 0 .or. mb%mp(2) < 0) then
          qx%kflag = -4
          call fmwarn(qx)
          call imunknown(mc, qx)
          call imdim2(mc, qx)
          return
      endif
      kovfl = 0
      if (ma%mp(2) == qx%mexpov .or. mb%mp(2) == qx%mexpov) then
          kovfl = 1
          if (ma%mp(2) == qx%mexpov .and. mb%mp(2) == qx%mexpov .and.  &
              ma%mp(3) == mb%mp(3) .and. ma%mp(1) == mb%mp(1)) then
              qx%kflag = -4
              call fmwarn(qx)
              call imunknown(mc, qx)
              call imdim2(mc, qx)
              return
          endif
      endif

      if (imcomp(ma, '>=', mb, qx)) then
          call imsub(ma, mb, mc, qx)
          if (qx%kflag == 1) qx%kflag = 0
      else
          mc%mp(2) = 0
          mc%mp(3) = 0
          mc%mp(4) = 0
          mc%mp(1) = 1
      endif

      if (mc%mp(2) >= qx%mexpov) then
          if (mc%mp(2) == qx%munkno) then
              qx%kflag = -4
              call fmwarn(qx)
          else if (qx%ncall == 1 .or. mc%mp(2) >= qx%mexpov) then
              if (mc%mp(1) > 0) then
                  call imst2m('OVERFLOW', mc, qx)
              else
                  call imst2m('-OVERFLOW', mc, qx)
              endif
              qx%kflag = -5
              if (kovfl /= 1) then
                  call fmwarn(qx)
              endif
          endif
      endif

      call imdim2(mc, qx)

      return
      end subroutine imdim

      subroutine imdim2(mc, qx)

!  Check for output tracing in imdim.

      use fmvals_parallel
      implicit none

      type(multi) :: mc
      intent (inout) :: mc
      type(fm_settings) :: qx

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      if (qx%ntrace /= 0) call imntr_out1(mc, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine imdim2

      subroutine imdiv(ma, mb, mc, qx)

!  mc = int(ma/mb)

!  Use imdivr if both int(ma/mb) and mod(ma,mb) are needed.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: kl, ndsave, result_size
      type(multi) :: mxy

      if (ma%mp(2) >= qx%mexpov .or. mb%mp(2) >= qx%mexpov) then
          result_size = 5
      else
          result_size = ma%mp(2) - mb%mp(2) + 6
      endif
      result_size = max(5, result_size)
      call fmalloc(mc, result_size, qx)

      qx%ncall = qx%ncall + 1
      mc%mp(5) = 0
      qx%kflag = 0
      ndsave = qx%ndig
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMDIV'
          call imntr_inp2(ma, mb, qx)
      endif

      kl = 1
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) then
          call imunknown(mc, qx)
          qx%kflag = -4
          kl = 0
      endif

      if (kl == 1) then
          qx%krem = 0
          call imdivr(ma, mb, mc, mxy, qx)
          qx%krem = 1

          if (mc%mp(2) == qx%munkno) then
              qx%kflag = -4
              qx%namest(qx%ncall) = 'IMDIV'
              call fmwarn(qx)
          endif
      endif

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      if (qx%ntrace /= 0) call imntr_out1(mc, qx)
      qx%ncall = qx%ncall - 1
      qx%ndig = ndsave

      return
      end subroutine imdiv

      subroutine imdivi(ma, idiv, mb, qx)

!  mb = int(ma/idiv)

!  Use imdvir if both int(ma/idiv) and mod(ma,idiv) are needed.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma, idiv
      intent (inout) :: mb
      type(fm_settings) :: qx

      integer :: idiv, irem, kl, ndsave, result_size

      result_size = max(5, int(ma%mp(2)+3))
      if (abs(result_size) >= qx%mexpov) result_size = 5
      call fmalloc(mb, result_size, qx)

      qx%ncall = qx%ncall + 1
      mb%mp(5) = 0
      qx%kflag = 0
      ndsave = qx%ndig
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMDIVI'
          call imntr_inp1i(ma, idiv, qx)
      endif

      kl = 1
      if (ma%mp(2) == qx%munkno) then
          call imunknown(mb, qx)
          qx%kflag = -4
          kl = 0
      endif

      if (kl == 1) then
          call imdvir(ma, idiv, mb, irem, qx)

          if (mb%mp(2) == qx%munkno) then
              qx%kflag = -4
              qx%namest(qx%ncall) = 'IMDIVI'
              call fmwarn(qx)
          endif
      endif

      if (mb%mp(2) <= 1) mb%mp(4) = 0
      if (qx%ntrace /= 0) call imntr_out1(mb, qx)
      qx%ncall = qx%ncall - 1
      qx%ndig = ndsave

      return
      end subroutine imdivi

      subroutine imdivr(ma, mb, mc, md, qx)

!  mc = int(ma / mb),    md = remainder from the division.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md
      intent (in) :: ma, mb
      intent (inout) :: mc, md
      type(fm_settings) :: qx

      double precision :: xb, xbr, xbase, xmwa
      real (kind(1.0d0)) :: maxmwa, mb1, mbp1, mcarry, mkt, mlmax, mqd
      integer :: j, jb, jl, k, ka, kb, kl, klt, kltflg, kptmwa, kresult, lcrrct, na1, nb1, nd,  &
                 ndsave, nguard, nl, nmbwds, nmethd, ntrsav, result_size
      type(multi) :: mxy(4)
      logical, external :: imcomp

      if (ma%mp(2) >= qx%mexpov .or. mb%mp(2) >= qx%mexpov) then
          result_size = 5
      else
          result_size = ma%mp(2) - mb%mp(2) + 6
      endif
      result_size = max(5, result_size)
      call fmalloc(mc, result_size, qx)
      result_size = max(5, int(mb%mp(2)+3)) + 2
      if (abs(result_size) >= qx%mexpov) result_size = ma%mp(2) + 5
      if (abs(result_size) >= qx%mexpov) result_size = 5
      call fmalloc(md, result_size, qx)
      result_size = 2*ma%mp(2) + 30
      if (abs(result_size) >= qx%mexpov) result_size = 32
      result_size = max(32, result_size)
      call fmalloc(qx%mwa, result_size, qx)

      qx%ncall = qx%ncall + 1
      mc%mp(5) = 0
      md%mp(5) = 0
      ndsave = qx%ndig
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMDIVR'
          call imntr_inp2(ma, mb, qx)
      endif
      qx%kflag = 0
      ntrsav = qx%ntrace
      qx%ntrace = 0

      call imdivr_sc(ma, mb, mc, md, kresult, qx)
      if (kresult == 1) then
          call imdivr3(mc, md, ndsave, ntrsav, qx)
          return
      endif

      kltflg = 0
      kl = int(mb%mp(2))
      if (abs(kl) >= qx%mexpov) kl = 2
      result_size = abs(mb%mp(2)) + 4
      if (abs(result_size) >= qx%mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mxy(1), result_size, qx)

      do j = 0, kl+1
         mxy(1)%mp(j+1) = mb%mp(j+1)
      enddo
      mxy(1)%mp(1) = 1
      if (kl == 1) mxy(1)%mp(4) = 0
      if (ma%mp(2) == mxy(1)%mp(2) .and.  &
          abs(ma%mp(3)) <= mxy(1)%mp(3)) then
          klt = 1
          do j = 2, kl+1
             if (ma%mp(j+1) /= mxy(1)%mp(j+1)) then
                 klt = 0
                 exit
             endif
          enddo
          if (klt == 1) kltflg = 2
          if (kltflg == 0) then
              do j = 2, kl+1
                 if (ma%mp(j+1) < mxy(1)%mp(j+1)) then
                     kltflg = 1
                     exit
                 else if (ma%mp(j+1) > mxy(1)%mp(j+1)) then
                     exit
                 endif
              enddo
          endif
      endif
      if (ma%mp(2) < mb%mp(2) .or. kltflg >= 1) then
          if (kltflg /= 2) then
              call imeq(ma, md, qx)
              md%mp(1) = abs(md%mp(1))
              call imi2m(0, mc, qx)
          else
              call imi2m(1, mc, qx)
              call imi2m(0, md, qx)
          endif
          call imdivr2(ma, mb, mc, md, qx)
          call imdivr3(mc, md, ndsave, ntrsav, qx)
          return
      endif

      call fmndig(int(ma%mp(2)) + 2, qx)
      if (qx%ndig < 3) qx%ndig = 3
      if (abs(ma%mp(2)) >= qx%mexpov) qx%ndig = 3


!             Check for using an fft-based method if precision is very high.

      nd = 1000
      if (int(ma%mp(2))-int(mb%mp(2)) >= nd) then
          nmethd = 2
      else
          nmethd = 1
      endif
      if (nmethd == 2) then
          call imi2fm(ma, mxy(1), qx)
          mxy(1)%mp(1) = 1
          call imi2fm(mb, mxy(2), qx)
          mxy(2)%mp(1) = 1
          call fmdiv(mxy(1), mxy(2), mxy(3), qx)
          call imfm2i(mxy(3), mc, qx)
          if (qx%krem /= 1) then
              call imi2m(0, md, qx)
          else
              call imabs(ma, mxy(1), qx)
              call imabs(mb, mxy(2), qx)
              call immpy(mc, mxy(2), mxy(3), qx)
              call imsub(mxy(1), mxy(3), mxy(4), qx)
              call imeq(mxy(4), md, qx)
              if (md%mp(1) == -1) then
                  call imi2m(1, mxy(3), qx)
                  call imsub(mc, mxy(3), mxy(4), qx)
                  call imeq(mxy(4), mc, qx)
                  call imadd(md, mxy(2), mxy(4), qx)
                  call imeq(mxy(4), md, qx)
              else if (imcomp(md, '>=', mxy(2), qx)) then
                  call imi2m(1, mxy(3), qx)
                  call imadd(mc, mxy(3), mxy(4), qx)
                  call imeq(mxy(4), mc, qx)
                  call imsub(md, mxy(2), mxy(4), qx)
                  call imeq(mxy(4), md, qx)
              endif
          endif
          call imdivr2(ma, mb, mc, md, qx)
          call imdivr3(mc, md, ndsave, ntrsav, qx)
          return
      endif

!             nguard is the number of guard digits used.

      nguard = 1
      na1 = int(ma%mp(2)) + 1
      nb1 = int(mb%mp(2)) + 1

!             Copy ma into the working array.

      do j = 3, na1
         qx%mwa%mp(j+2) = ma%mp(j+1)
      enddo
      qx%mwa%mp(2) = ma%mp(2) - mb%mp(2) + 1
      qx%mwa%mp(3) = 0
      nl = na1 + nguard + 3
      do j = na1+2, nl
         qx%mwa%mp(j+1) = 0
      enddo

      mb1 = mb%mp(2)
      qx%mwa%mp(4) = ma%mp(3)

!             nmbwds is the number of words of mb used to compute the estimated quotient digit mqd.

      nmbwds = 4
      if (qx%mbase < 100) nmbwds = 7

!             xb is an approximation of mb used in estimating the quotient digits.

      xbase = dble(qx%mbase)
      xb = 0
      jl = nmbwds
      if (jl <= nb1) then
          do j = 2, jl
             xb = xb*xbase + dble(mb%mp(j+1))
          enddo
      else
          do j = 2, jl
             if (j <= nb1) then
                 xb = xb*xbase + dble(mb%mp(j+1))
             else
                 xb = xb*xbase
             endif
          enddo
      endif
      if (jl+1 <= nb1) then
          xb = xb + dble(mb%mp(jl+2))/xbase
      endif
      xbr = 1.0d0/xb

!             mlmax determines when to normalize all of mwa.

      mbp1 = qx%mbase + 1
      mlmax = maxint/mbp1
      mkt = intmax - qx%mbase
      mlmax = min(mlmax, mkt)

!             maxmwa is an upper bound on the size of values in mwa divided by mbase-1.
!             It is used to determine whether normalization can be postponed.

      maxmwa = 0

!             kptmwa points to the next digit in the quotient.

      kptmwa = 2
      ka = kptmwa + 1
      kb = ka + int(mb1) - 1
      jb = ka - 2

!             This is the start of the division loop.

!             xmwa is an approximation of the active part of mwa used in estimating quotient digits.

      klt = 1
      do while (klt == 1)
         kl = kptmwa + nmbwds - 1
         if (kl <= nl) then
             xmwa = ((dble(qx%mwa%mp(kptmwa+1))*xbase + dble(qx%mwa%mp(kptmwa+2)))*xbase  &
                    + dble(qx%mwa%mp(kptmwa+3)))*xbase + dble(qx%mwa%mp(kptmwa+4))
             do j = kptmwa+4, kl
                xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
             enddo
         else
             xmwa = dble(qx%mwa%mp(kptmwa+1))
             do j = kptmwa+1, kl
                if (j <= nl) then
                    xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
                else
                    xmwa = xmwa*xbase
                endif
             enddo
         endif

!             mqd is the estimated quotient digit.

         mqd = aint(xmwa*xbr)
         if (mqd < 0) mqd = mqd - 1

         if (mqd > 0) then
             maxmwa = maxmwa + mqd
         else
             maxmwa = maxmwa - mqd
         endif

!             See if mwa must be normalized.

         ka = kptmwa + 1
         kb = ka + int(mb1) - 1
         if (maxmwa >= mlmax) then
             do j = kb, ka, -1
                if (qx%mwa%mp(j+1) < 0) then
                    mcarry = int((-qx%mwa%mp(j+1)-1)/qx%mbase) + 1
                    qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
                    qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
                else if (qx%mwa%mp(j+1) >= qx%mbase) then
                    mcarry = -int(qx%mwa%mp(j+1)/qx%mbase)
                    qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
                    qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
                endif
             enddo
             xmwa = 0
             if (kl <= nl) then
                 do j = kptmwa, kl
                    xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
                 enddo
             else
                 do j = kptmwa, kl
                    if (j <= nl) then
                        xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
                    else
                        xmwa = xmwa*xbase
                    endif
                 enddo
             endif
             mqd = aint(xmwa*xbr)
             if (mqd < 0) mqd = mqd - 1
             if (mqd > 0) then
                 maxmwa = mqd
             else
                 maxmwa = -mqd
             endif
         endif

!             Subtract mqd*mb from mwa.

         jb = ka - 2
         if (mqd /= 0) then

!             Major (Inner Loop)

             do j = ka+1, kb+1
                qx%mwa%mp(j) = qx%mwa%mp(j) - mqd*mb%mp(j-jb)
             enddo
         endif

         qx%mwa%mp(ka+1) = qx%mwa%mp(ka+1) + qx%mwa%mp(ka)*qx%mbase
         qx%mwa%mp(kptmwa+1) = mqd

         kptmwa = kptmwa + 1
         if (kptmwa-2 >= qx%mwa%mp(2)) klt = 0
      enddo

!             Final normalization.

      kptmwa = kptmwa - 1
      do j = kptmwa, 3, -1
         if (qx%mwa%mp(j+1) < 0) then
             mcarry = int((-qx%mwa%mp(j+1)-1)/qx%mbase) + 1
             qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
             qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
         else if (qx%mwa%mp(j+1) >= qx%mbase) then
             mcarry = -int(qx%mwa%mp(j+1)/qx%mbase)
             qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
             qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
         endif
      enddo

      lcrrct = 0
      klt = 1
      do while (klt == 1)
         do j = kptmwa+int(mb1), kptmwa+2, -1
            if (qx%mwa%mp(j+1) < 0) then
                mcarry = int((-qx%mwa%mp(j+1)-1)/qx%mbase) + 1
                qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
                qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
            else if (qx%mwa%mp(j+1) >= qx%mbase) then
                mcarry = -int(qx%mwa%mp(j+1)/qx%mbase)
                qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
                qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
            endif
         enddo

!             Due to rounding, the remainder may not be between 0 and abs(mb) here.
!             Correct if necessary.

         klt = 0
         if (qx%mwa%mp(ka+1) < 0) then
             lcrrct = lcrrct - 1
             do j = ka, kb
                qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mb%mp(j-jb+1)
             enddo
             klt = 1
             cycle
         else if (qx%mwa%mp(ka+1) >= qx%mbase) then
             lcrrct = lcrrct + 1
             do j = ka, kb
                qx%mwa%mp(j+1) = qx%mwa%mp(j+1) - mb%mp(j-jb+1)
             enddo
             klt = 1
             cycle
         endif
      enddo
      if (qx%mwa%mp(3) /= 0 .or. kptmwa == 2) then
          do j = 1, int(qx%mwa%mp(2))+1
             mc%mp(j+1) = qx%mwa%mp(j+1)
          enddo
      else
          do j = 3, int(qx%mwa%mp(2))+1
             mc%mp(j) = qx%mwa%mp(j+1)
          enddo
          if (mc%mp(3) /= 0) then
              mc%mp(2) = qx%mwa%mp(2) - 1
          else
              mc%mp(2) = 0
          endif
      endif
      if (mc%mp(2) <= 1) mc%mp(4) = 0
      mc%mp(1) = 1

      if (qx%mwa%mp(kptmwa+2) /= 0) then
          do j = 1, int(mb1)
             md%mp(j+2) = qx%mwa%mp(j+kptmwa+1)
          enddo
          md%mp(2) = mb1
      else
          klt = 1
          do j = 1, int(mb1)
             if (qx%mwa%mp(j+kptmwa+1) /= 0) then
                 do k = j, int(mb1)
                    md%mp(k-j+3) = qx%mwa%mp(k+kptmwa+1)
                 enddo
                 md%mp(2) = mb1 + 1 - j
                 klt = 0
                 exit
             endif
          enddo
          if (klt == 1) then
              md%mp(2) = 0
              md%mp(3) = 0
          endif
      endif
      if (md%mp(2) <= 1) md%mp(4) = 0
      md%mp(1) = 1

!             If the remainder had to be corrected, make the corresponding adjustment in
!             the quotient.

      if (md%mp(2) > mxy(1)%mp(2) .or.    &
         (md%mp(2) == mxy(1)%mp(2) .and.  &
          abs(md%mp(3)) >= mxy(1)%mp(3))) then
          if (imcomp(md, '>=', mxy(1), qx)) then
              call imsub(md, mxy(1), mxy(3), qx)
              call imeq(mxy(3), md, qx)
              lcrrct = lcrrct + 1
          endif
      endif
      if (lcrrct /= 0) then
          call imi2m(lcrrct, mxy(2), qx)
          call imadd(mxy(2), mc, mxy(3), qx)
          call imeq(mxy(3), mc, qx)
      endif

      call imdivr2(ma, mb, mc, md, qx)
      call imdivr3(mc, md, ndsave, ntrsav, qx)

      return
      end subroutine imdivr

      subroutine imdivr2(ma, mb, mc, md, qx)

!  Fix signs for the results from imdivr.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md
      intent (in) :: ma, mb
      intent (inout) :: mc, md
      type(fm_settings) :: qx

      mc%mp(1) = 1
      md%mp(1) = 1
      if (ma%mp(1) < 0 .and. mb%mp(1) > 0) then
          if (mc%mp(2) /= qx%munkno .and. mc%mp(3) /= 0) mc%mp(1) = -1
          if (md%mp(2) /= qx%munkno .and. md%mp(3) /= 0) md%mp(1) = -1
      else if (ma%mp(1) > 0 .and. mb%mp(1) < 0) then
          if (mc%mp(2) /= qx%munkno .and. mc%mp(3) /= 0) mc%mp(1) = -1
      else if (ma%mp(1) < 0 .and. mb%mp(1) < 0) then
          if (md%mp(2) /= qx%munkno .and. md%mp(3) /= 0) md%mp(1) = -1
      endif

      return
      end subroutine imdivr2

      subroutine imdivr3(mc, md, ndsave, ntrsav, qx)

!  Check for trace output from imdiv.

      use fmvals_parallel
      implicit none

      type(multi) :: mc, md
      integer :: ndsave, ntrsav
      intent (in) :: ndsave
      intent (inout) :: mc, md, ntrsav
      type(fm_settings) :: qx


      if (mc%mp(2) <= 1) mc%mp(4) = 0
      if (md%mp(2) <= 1) md%mp(4) = 0
      qx%ntrace = ntrsav
      if (qx%ntrace /= 0) then
          call imntr_out1(mc, qx)
          if (abs(qx%ntrace) >= 1 .and. qx%ncall <= qx%lvltrc) then
              if (qx%ntrace < 0) then
                  call fmndig(max(3, int(md%mp(2))), qx)
                  ntrsav = qx%ntrace
                  call imntrj(md, qx%ndig, qx)
                  qx%ntrace = ntrsav
              else
                  call imprnt(md, qx)
              endif
          endif
      endif
      qx%ncall = qx%ncall - 1
      qx%ndig = ndsave

      return
      end subroutine imdivr3

      subroutine imdivr_sc(ma, mb, mc, md, kresult, qx)

!  mc = int(ma / mb),    md = remainder from the division.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md
      integer :: kresult
      intent (in) :: ma, mb
      intent (inout) :: mc, md, kresult
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mda, mdab, mdb, mdr

      kresult = 0
      if (qx%mblogs /= qx%mbase) call fmcons(qx)

!             Check for special cases.

      if (mb%mp(2) == 1 .and. ma%mp(2) /= qx%munkno) then
          if (mb%mp(1)*mb%mp(3) == 1) then
              call imeq(ma, mc, qx)
              md%mp(2) = 0
              md%mp(3) = 0
              md%mp(4) = 0
              md%mp(1) = 1
              kresult = 1
              return
          else if (mb%mp(1)*mb%mp(3) == -1) then
              call imeq(ma, mc, qx)
              call fmnegate(mc, qx)
              md%mp(2) = 0
              md%mp(3) = 0
              md%mp(4) = 0
              md%mp(1) = 1
              kresult = 1
              return
          endif
      endif
      if (ma%mp(2) < mb%mp(2) .and. mb%mp(2) /= qx%munkno) return
      if (ma%mp(2) < 0 .or. mb%mp(2) < 0 .or. mb%mp(3) == 0 .or.  &
          ma%mp(2) >= qx%mexpov .or. mb%mp(2) >= qx%mexpov) then
          qx%kflag = -4
          if (ma%mp(2) /= qx%munkno .and. mb%mp(2) /= qx%munkno) then
              qx%namest(qx%ncall) = 'IMDIVR'
              call fmwarn(qx)
          endif
          call imunknown(mc, qx)
          call imunknown(md, qx)
          kresult = 1
          return
      endif
      if (ma%mp(2) <= 2) then
          if (mb%mp(2) > 2) return
          if (mb%mp(3) == 0) return
          if (ma%mp(2) <= 1) then
              mda = ma%mp(1) * ma%mp(3)
          else
              mda = ma%mp(1) * (ma%mp(3)*qx%mbase + ma%mp(4))
          endif
          if (mb%mp(2) <= 1) then
              mdb = mb%mp(1) * mb%mp(3)
          else
              mdb = mb%mp(1) * (mb%mp(3)*qx%mbase + mb%mp(4))
          endif
          mdab = aint (mda / mdb)
          mdr = mda - mdab*mdb
          if (abs(mdab) < qx%mbase) then
              mc%mp(2) = 1
              if (mdab == 0) mc%mp(2) = 0
              if (mdab >= 0) then
                  mc%mp(3) = mdab
                  mc%mp(1) = 1
              else
                  mc%mp(3) = -mdab
                  mc%mp(1) = -1
              endif
              mc%mp(4) = 0
          else if (abs(mdab) < qx%mbase*qx%mbase) then
              mc%mp(2) = 2
              if (mdab >= 0) then
                  mc%mp(3) = aint (mdab/qx%mbase)
                  mc%mp(4) = abs(mdab - qx%mbase*mc%mp(3))
                  mc%mp(1) = 1
              else
                  mc%mp(3) = aint (-mdab/qx%mbase)
                  mc%mp(4) = abs(-mdab - qx%mbase*mc%mp(3))
                  mc%mp(1) = -1
              endif
          else
              return
          endif
          if (abs(mdr) < qx%mbase) then
              md%mp(2) = 1
              if (mdr == 0) md%mp(2) = 0
              if (mdr >= 0) then
                  md%mp(3) = mdr
                  md%mp(1) = 1
              else
                  md%mp(3) = -mdr
                  md%mp(1) = -1
              endif
              md%mp(4) = 0
              kresult = 1
              return
          else if (abs(mdr) < qx%mbase*qx%mbase) then
              md%mp(2) = 2
              if (mdr >= 0) then
                  md%mp(3) = aint (mdr/qx%mbase)
                  md%mp(4) = abs(mdr - qx%mbase*md%mp(3))
                  md%mp(1) = 1
              else
                  md%mp(3) = aint (-mdr/qx%mbase)
                  md%mp(4) = abs(-mdr - qx%mbase*md%mp(3))
                  md%mp(1) = -1
              endif
              kresult = 1
              return
          endif
      endif

      return
      end subroutine imdivr_sc

      subroutine imdp2m(x, ma, qx)

!  ma = x

!  Convert the integer part of a double precision to an im number.

      use fmvals_parallel
      implicit none

      double precision :: x
      type(multi) :: ma
      intent (in) :: x
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: ndsave
      type(multi) :: mxy

      qx%ncall = qx%ncall + 1
      qx%kflag = 0
      qx%namest(qx%ncall) = 'IMDP2M'
      if (qx%ntrace /= 0) call imntr_inpd(x, qx)

      ndsave = qx%ndig
      if (abs(x) < 1) then
          call imi2m(0, ma, qx)
      else
          call fmndig(max(3, int(log(abs(x))/log(dble(qx%mbase)))+2), qx)
          call fmdp2m(x, mxy, qx)
          call imfm2i(mxy, ma, qx)
      endif

      if (qx%ntrace /= 0) call imntr_out1(ma, qx)
      qx%ndig = ndsave
      qx%ncall = qx%ncall - 1

      return
      end subroutine imdp2m

      subroutine imdvir(ma, idiv, mb, irem, qx)

!  mb = int(ma / idiv),    irem = remainder from the division.

!  Division by a one word integer.  The remainder is also a one word integer.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: idiv, irem
      intent (in) :: ma, idiv
      intent (inout) :: mb, irem
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mkt, modint, mvalp
      integer :: j, ka, kl, klt, kltflg, kpt, kresult, n1, ndsave, nmval, ntrsav, nv2, result_size
      type(multi) :: mxy(3)

      result_size = max(5, int(ma%mp(2)+5))
      if (abs(result_size) >= qx%mexpov) result_size = 5
      call fmalloc(mb, result_size, qx)
      result_size = 2*ma%mp(2) + 30
      if (abs(result_size) >= qx%mexpov) result_size = 32
      result_size = max(32, result_size)
      call fmalloc(qx%mwa, result_size, qx)

      qx%ncall = qx%ncall + 1
      mb%mp(5) = 0
      qx%kflag = 0
      ndsave = qx%ndig
      kltflg = 0
      ntrsav = qx%ntrace
      qx%ntrace = 0
      mkt = abs(idiv)
      if (mkt < qx%mbase) then
          call fmalloc(mxy(1), 5, qx)
          mxy(1)%mp(2) = 1
          mxy(1)%mp(3) = abs(idiv)
          mxy(1)%mp(4) = 0
          mxy(1)%mp(5) = 0
          mxy(1)%mp(1) = 1
          if (idiv < 0) mxy(1)%mp(1) = -1
      else if (mkt < qx%mbase*qx%mbase) then
          call fmalloc(mxy(1), 6, qx)
          mxy(1)%mp(2) = 2
          mxy(1)%mp(3) = int(mkt/qx%mbase)
          mxy(1)%mp(4) = mkt - mxy(1)%mp(3)*qx%mbase
          mxy(1)%mp(5) = 0
          mxy(1)%mp(6) = 0
          mxy(1)%mp(1) = 1
          if (idiv < 0) mxy(1)%mp(1) = -1
      else
          call imi2m(idiv, mxy(1), qx)
      endif
      qx%ntrace = ntrsav
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMDVIR'
          call imntr_inp1i(ma, idiv, qx)
      endif

      call imdvir_sc(ma, idiv, mb, irem, kresult, qx)
      if (kresult == 1) then
          call imdvir3(mb, irem, ndsave, qx)
          return
      endif

      mxy(1)%mp(1) = 1
      kl = mxy(1)%mp(2)
      if (ma%mp(2) <= mxy(1)%mp(2)) then
          if (ma%mp(2) == mxy(1)%mp(2) .and.  &
              abs(ma%mp(3)) <= mxy(1)%mp(3)) then
              klt = 1
              do j = 2, kl+1
                 if (ma%mp(j+1) /= mxy(1)%mp(j+1)) then
                     if (ma%mp(j+1) < mxy(1)%mp(j+1)) kltflg = 1
                     klt = 0
                     exit
                 endif
              enddo
              if (klt == 1) kltflg = 2
          endif
          if (ma%mp(2) < mxy(1)%mp(2) .or. kltflg >= 1) then
              if (kltflg /= 2) then
                  call imm2i(ma, irem, qx)
                  irem = abs(irem)
                  call imi2m(0, mb, qx)
              else
                  call imi2m(1, mb, qx)
                  irem = 0
              endif
              call imdvir2(ma, idiv, mb, irem, qx)
              call imdvir3(mb, irem, ndsave, qx)
              return
          endif
      endif
      call fmndig(int(ma%mp(2)), qx)
      if (qx%ndig < 3) qx%ndig = 3
      if (abs(ma%mp(2)) >= qx%mexpov) qx%ndig = 3
      n1 = int(ma%mp(2)) + 1

!             if abs(idiv) >= mxbase use imdivr.

      mvalp = abs(idiv)
      nmval = int(mvalp)
      nv2 = nmval - 1
      if (abs(idiv) > mxbase .or. nmval /= abs(idiv) .or. nv2 /= abs(idiv)-1) then
          call imi2m(idiv, mxy(2), qx)
          call imdivr(ma, mxy(2), mxy(1), mxy(3), qx)
          call imeq(mxy(1), mb, qx)
          call imeq(mxy(3), mxy(2), qx)
          call imm2i(mxy(2), irem, qx)
          call imdvir3(mb, irem, ndsave, qx)
          return
      endif

!             Find the first significant digit of the quotient.

      mkt = ma%mp(3)
      klt = 1
      kpt = 2
      if (mkt >= mvalp) then
          kpt = 2
          klt = 0
      endif
      if (klt == 1) then
          do j = 3, n1
             mkt = mkt*qx%mbase + ma%mp(j+1)
             if (mkt >= mvalp) then
                 kpt = j
                 klt = 0
                 exit
             endif
          enddo
      endif
      if (klt == 1) then
          call imm2i(ma, irem, qx)
          call imi2m(0, mb, qx)
          call imdvir3(mb, irem, ndsave, qx)
          return
      endif

!             Do the rest of the division.

      ka = kpt + 1
      qx%mwa%mp(2) = ma%mp(2) + 2 - kpt
      qx%mwa%mp(3) = int (mkt/mvalp)
      modint = mkt - qx%mwa%mp(3)*mvalp
      if (ka <= n1) then
          kl = 3 - ka

!             (Inner Loop)

          do j = ka+1, n1+1
             mkt = modint*qx%mbase + ma%mp(j)
             qx%mwa%mp(kl+j) = int (mkt/mvalp)
             modint = mkt - qx%mwa%mp(kl+j)*mvalp
          enddo
      endif

      do j = 1, int(qx%mwa%mp(2))+1
         mb%mp(j+1) = qx%mwa%mp(j+1)
      enddo
      irem = int(modint)

      call imdvir2(ma, idiv, mb, irem, qx)
      call imdvir3(mb, irem, ndsave, qx)

      return
      end subroutine imdvir

      subroutine imdvir2(ma, idiv, mb, irem, qx)

!  Check for the signs of the results for imdvir.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: idiv, irem
      intent (in) :: ma, idiv
      intent (inout) :: mb, irem
      type(fm_settings) :: qx

      mb%mp(1) = 1
      if (ma%mp(1) < 0 .and. idiv > 0) then
          if (mb%mp(2) /= qx%munkno .and. mb%mp(3) /= 0) mb%mp(1) = -1
          irem = -irem
      else if (ma%mp(1) > 0 .and. idiv < 0) then
          if (mb%mp(2) /= qx%munkno .and. mb%mp(3) /= 0) mb%mp(1) = -1
      else if (ma%mp(1) < 0 .and. idiv < 0) then
          irem = -irem
      endif

      return
      end subroutine imdvir2

      subroutine imdvir3(mb, irem, ndsave, qx)

!  Output tracing for imdvir.

      use fmvals_parallel
      implicit none

      type(multi) :: mb
      integer :: irem, ndsave
      intent (in) :: ndsave
      intent (inout) :: mb, irem
      type(fm_settings) :: qx

      if (mb%mp(2) <= 1) mb%mp(4) = 0
      if (qx%ntrace /= 0 .and. qx%ncall <= qx%lvltrc) then
          call imntr_out1i(mb, irem, qx)
      endif

      qx%ncall = qx%ncall - 1
      qx%ndig = ndsave

      return
      end subroutine imdvir3

      subroutine imdvir_sc(ma, idiv, mb, irem, kresult, qx)

!  mb = int(ma / idiv),    irem = remainder from the division.

!  Division by a one word integer.  The remainder is also a one word integer.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: idiv, irem, kresult
      intent (in) :: ma, idiv
      intent (inout) :: mb, irem, kresult
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mda, mdab, mdb, mdr
      integer :: jdiv

      kresult = 0
      jdiv = abs(idiv)

      if (ma%mp(2) < 0) then
          irem = qx%iunkno
          qx%kflag = -4
          qx%namest(qx%ncall) = 'IMDVIR'
          call fmwarn(qx)
          call imunknown(mb, qx)
          kresult = 1
          return
      endif
      if (jdiv == 1 .and. ma%mp(2) /= qx%munkno) then
          if (idiv == 1) then
              call imeq(ma, mb, qx)
              irem = 0
              kresult = 1
              return
          else
              call imeq(ma, mb, qx)
              call fmnegate(mb, qx)
              irem = 0
              kresult = 1
              return
          endif
      endif
      if (ma%mp(2) >= qx%mexpov .or. idiv == 0) then
          qx%kflag = -4
          if (ma%mp(2) /= qx%munkno) then
              qx%namest(qx%ncall) = 'IMDVIR'
              call fmwarn(qx)
          endif
          call imunknown(mb, qx)
          irem = qx%iunkno
          kresult = 1
          return
      endif
      if (ma%mp(2) <= 2) then
          if (ma%mp(2) <= 1) then
              mda = ma%mp(1) * ma%mp(3)
          else
              mda = ma%mp(1) * (ma%mp(3)*qx%mbase + ma%mp(4))
          endif
          mdb = idiv
          mdab = aint (mda/mdb)
          mdr = mda - mdab*mdb
          if (abs(mdab) < qx%mbase) then
              mb%mp(2) = 1
              if (mdab == 0) mb%mp(2) = 0
              if (mdab < 0) then
                  mb%mp(3) = -mdab
                  mb%mp(1) = -1
              else
                  mb%mp(3) = mdab
                  mb%mp(1) = 1
              endif
              mb%mp(4) = 0
          else if (abs(mdab) < qx%mbase*qx%mbase) then
              mb%mp(2) = 2
              if (mdab < 0) then
                  mb%mp(3) = aint (-mdab/qx%mbase)
                  mb%mp(4) = abs(-mdab - qx%mbase*mb%mp(3))
                  mb%mp(1) = -1
              else
                  mb%mp(3) = aint (mdab/qx%mbase)
                  mb%mp(4) = abs(mdab - qx%mbase*mb%mp(3))
                  mb%mp(1) = 1
              endif
          else
              return
          endif
          irem = int(mdr)
          kresult = 1
          return
      endif

      return
      end subroutine imdvir_sc

      subroutine imeq(ma, mb, qx)

!  mb = ma

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      integer :: j, kdg, result_size

      result_size = ma%mp(2)+3
      if (abs(result_size) >= qx%mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mb, result_size, qx)

      mb%mp(5) = 0
      kdg = max(2, int(ma%mp(2))) + 2
      if (kdg > size(ma%mp)) kdg = 4
      do j = 1, kdg
         mb%mp(j) = ma%mp(j)
      enddo
      if (kdg == 4 .and. abs(ma%mp(2)) >= qx%mexpov) mb%mp(5) = ma%mp(5)

      return
      end subroutine imeq

      subroutine imfact(n, ma, qx)

!  ma = n!   (n factorial)  n is a machine precision integer and ma is an im number.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: n
      intent (in) :: n
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: j, k, ndsave, result_size

      k = max(n, 2)
      result_size = 10 + (log(2.0d0*qx%dppi*k)/2 + k*log(dble(k)) - k) / qx%dlogmb
      if (abs(result_size) >= qx%mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(ma, result_size, qx)

      qx%ncall = qx%ncall + 1
      ma%mp(5) = 0
      qx%kflag = 0
      ndsave = qx%ndig
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMFACT'
          call imntr_inpi(n, qx)
      endif

      if (n < 0) then
          call imunknown(ma, qx)
          qx%kflag = -4
      else if (n <= 12) then
          k = 1
          do j = 2, n
             k = k*j
          enddo
          call imi2m(k, ma, qx)
      else
          call imfact_p(2, n, ma, qx)
      endif

      if (ma%mp(2) <= 1) ma%mp(4) = 0
      if (qx%ntrace /= 0) call imntr_out1(ma, qx)
      qx%ncall = qx%ncall - 1
      qx%ndig = ndsave

      return
      end subroutine imfact

      recursive subroutine imfact_p(a, b, mp, qx)

!  This routine does the binary splitting for computing n!
!  mp = a * (a+1) * ... * b.

      use fmvals_parallel
      implicit none

      integer :: a, b
      type(multi) :: mp
      intent (in) :: a, b
      intent (inout) :: mp
      type(fm_settings) :: qx

      type(multi) :: mxy(2)
      integer :: j, m, result_size
      real (kind(0.0d0)) :: da, db, dla, dlb

      da = a
      db = b
      if ((db+0.5d0)*log(db+1) > 1.0d+10) then
          result_size = (b-a+1)*log(db) / qx%dlogmb + 7 + qx%ngrd52
      else
          if (a >= 2) then
              dla = (da+0.5d0)*log(da) - da + 1/(12*(da))
          else
              dla = 0
          endif
          if (b >= 2) then
              dlb = (db+0.5d0)*log(db) - db + 1/(12*(db))
          else
              dlb = 0
          endif
          result_size = ( dlb - dla ) / qx%dlogmb + 7 + qx%ngrd52
      endif
      result_size = max(5, result_size)
      call fmalloc(mp, result_size, qx)

      mp%mp(5) = 0
      if (b-a < 25) then
          call fmalloc(mxy(1), result_size, qx)
          call imi2m(a, mp, qx)
          do j = a+1, b-1, 2
             call immpyi(mp, j, mxy(1), qx)
             call immpyi(mxy(1), j+1, mp, qx)
          enddo
          if (mod(b-a, 2) == 1) then
              call immpyi(mp, b, mxy(1), qx)
              call imeq(mxy(1), mp, qx)
          endif
      else
          m = a/2 + b/2 + mod(a, 2)*mod(b, 2)
          call imfact_p(a, m, mxy(1), qx)
          call imfact_p(m+1, b, mxy(2), qx)
          call immpy(mxy(1), mxy(2), mp, qx)

      endif

      return
      end subroutine imfact_p

      subroutine imfm2i(ma, mb, qx)

!  mb = int(ma)

!  Convert from real (fm) format to integer (im) format.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      integer :: j, ntrsav, ndgsav, result_size
      type(multi) :: mxy(1)

      result_size = max(5, int(ma%mp(2)+4))
      if (abs(result_size) >= qx%mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mb, result_size, qx)

      qx%ncall = qx%ncall + 1
      mb%mp(5) = 0
      qx%kflag = 0
      ntrsav = qx%ntrace
      qx%ntrace = 0
      ndgsav = qx%ndig
      if (abs(ma%mp(2)+3) >= qx%mexpov) then
          qx%ndig = 3
          call fmeq(ma, mb, qx)
          call fmndig(ndgsav, qx)
      else
          call fmndig(min(qx%ndig, result_size-3), qx)
          if (qx%ndig < 3) qx%ndig = 3
          call fmint(ma, mxy(1), qx)
          call fmeq(mxy(1), mb, qx)
          call fmndig(ndgsav, qx)
          do j = qx%ndig+2, int(ma%mp(2))+1
             mb%mp(j+1) = 0
          enddo
          if (mb%mp(2) <= 1) mb%mp(4) = 0
      endif
      qx%ntrace = ntrsav
      qx%ncall = qx%ncall - 1

      return
      end subroutine imfm2i

      subroutine imform(form, ma, string, qx)

!  Convert an im number (ma) to a character string base 10 (string) using form format.

!  form can be one of these types:  iw,  fw.d,  ew.d,  esw.d,  1pew.d  for positive integers w,d.

      use fmvals_parallel
      implicit none

      character(*) :: form, string
      type(multi) :: ma
      intent (in) :: form, ma
      intent (inout) :: string
      type(fm_settings) :: qx

      integer :: ndsave

      qx%ncall = qx%ncall + 1
      qx%kflag = 0
      qx%namest(qx%ncall) = 'IMFORM'
      ndsave = qx%ndig
      call fmndig(int(ma%mp(2)), qx)
      if (qx%ndig < 3) qx%ndig = 3
      if (abs(ma%mp(2)) >= qx%mexpov) qx%ndig = 3

      call fmform(form, ma, string, qx)

      qx%ncall = qx%ncall - 1
      qx%ndig = ndsave

      return
      end subroutine imform

      subroutine imfprint(form, ma, qx)

      use fmvals_parallel
      implicit none

      character(*) :: form
      type(multi) :: ma
      intent (in) :: form, ma
      type(fm_settings) :: qx

      call imfprt(form, ma, qx)

      return
      end subroutine imfprint

      subroutine imfprt(form, ma, qx)

!  Print an im number (ma) on unit kw using form format.

!  form can be one of these types:  iw,  fw.d,  ew.d,  esw.d,  1pew.d  for positive integers w,d.

      use fmvals_parallel
      implicit none

      character(*) :: form
      type(multi) :: ma
      intent (in) :: form, ma
      type(fm_settings) :: qx

      integer :: ndsave

      qx%ncall = qx%ncall + 1
      qx%kflag = 0
      qx%namest(qx%ncall) = 'IMFPRT'
      ndsave = qx%ndig
      call fmndig(int(ma%mp(2)), qx)
      if (qx%ndig < 3) qx%ndig = 3
      if (abs(ma%mp(2)) >= qx%mexpov) qx%ndig = 3

      call fmfprt(form, ma, qx)

      qx%ncall = qx%ncall - 1
      qx%ndig = ndsave

      return
      end subroutine imfprt

      subroutine imgcd(ma, mb, mc, qx)

!  Lehmer's gcd algorithm for mc = gcd(ma,mb).

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: j, k
      double precision :: abcd_max, dpbase, a1, b1, c1, d1, q1a, q1b, t1, t2, t3, u1, v1
      character(25) :: st
      logical, external :: imabs_greater_than
      type(multi) :: mxy(4)
      integer :: ndsave, result_size

      result_size = max(ma%mp(2), mb%mp(2)) + 3
      if (abs(result_size) >= qx%mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mc, result_size, qx)

      qx%ncall = qx%ncall + 1
      mc%mp(5) = 0
      qx%kflag = 0
      ndsave = qx%ndig
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMGCD'
          call imntr_inp2(ma, mb, qx)
      endif

!             Check for special cases.

      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) then
          call imunknown(mc, qx)
          qx%kflag = -4
          call imgcd_tr(mc, ndsave, qx)
          return
      else if (mb%mp(3) == 0) then
          call imabs(ma, mc, qx)
          call imgcd_tr(mc, ndsave, qx)
          return
      else if (ma%mp(3) == 0) then
          call imabs(mb, mc, qx)
          call imgcd_tr(mc, ndsave, qx)
          return
      else if (mb%mp(2) == 1 .and. abs(mb%mp(3)) == 1) then
          call imi2m(1, mc, qx)
          call imgcd_tr(mc, ndsave, qx)
          return
      else if (ma%mp(2) == 1 .and. abs(ma%mp(3)) == 1) then
          call imi2m(1, mc, qx)
          call imgcd_tr(mc, ndsave, qx)
          return
      else if (ma%mp(2) < 0 .or. mb%mp(2) < 0 .or.  &
          ma%mp(2) >= qx%mexpov .or. mb%mp(2) >= qx%mexpov) then
          qx%kflag = -4
          qx%namest(qx%ncall) = 'IMGCD'
          call fmwarn(qx)
          call imunknown(mc, qx)
          call imgcd_tr(mc, ndsave, qx)
          return
      endif

      call fmalloc(mxy(1), result_size, qx)
      call fmalloc(mxy(2), result_size, qx)
      call fmalloc(mxy(3), result_size, qx)
      call fmalloc(mxy(4), result_size, qx)
      call imabs(ma, mxy(3), qx)
      call imabs(mb, mxy(4), qx)
      if (imabs_greater_than(mxy(3), mxy(4))) then
          call imeq(mxy(3), mxy(1), qx)
          call imeq(mxy(4), mxy(2), qx)
      else
          call imeq(mxy(4), mxy(1), qx)
          call imeq(mxy(3), mxy(2), qx)
      endif

      if (qx%mbase < 1000) then
          call imgcd2(ma, mb, mc, qx)
          call imgcd_tr(mc, ndsave, qx)
          return
      endif

      abcd_max = (maxint / qx%mbase) / 2
      dpbase = qx%mbase
      t1 = 1.0d-3 / epsilon(1.0d0)
      call imi2m(1, mxy(3), qx)
      t2 = dpbase
      k = 1
      do while (t2 < t1)
         mxy(3)%mp(2) = mxy(3)%mp(2) + 1
         k = k + 1
         mxy(3)%mp(k+2) = 0
         t2 = t2 * dpbase
      enddo
      mxy(3)%mp(3) = aint( dpbase * t1 / t2 )

!             mxy(1) >= mxy(2) > 0 during the algorithm.

      do while (imabs_greater_than(mxy(1), mxy(3)))

         if (mxy(1)%mp(2) == mxy(2)%mp(2)) then
             u1 = mxy(1)%mp(3)
             v1 = mxy(2)%mp(3)
             do j = 2, int(mxy(1)%mp(2))
                if (u1 < maxint / (10 * dpbase)) then
                    u1 = u1 * dpbase + mxy(1)%mp(j+2)
                    v1 = v1 * dpbase + mxy(2)%mp(j+2)
                else
                    t1 = (mxy(1)%mp(j+2) + 1.0d-2) / dpbase
                    t2 = (mxy(2)%mp(j+2) + 1.0d-2) / dpbase
                    do while (u1 < maxint / 100)
                       t1 = t1 * 10
                       k = t1
                       t1 = t1 - k
                       u1 = u1 * 10 + k

                       t2 = t2 * 10
                       k = t2
                       t2 = t2 - k
                       v1 = v1 * 10 + k
                    enddo
                    exit
                endif
             enddo
         else if (mxy(1)%mp(2) == mxy(2)%mp(2) + 1) then
             u1 = mxy(1)%mp(3)
             v1 = 0
             do j = 2, int(mxy(1)%mp(2))
                if (u1 < maxint / (10 * dpbase)) then
                    u1 = u1 * dpbase + mxy(1)%mp(j+2)
                    v1 = v1 * dpbase + mxy(2)%mp(j+1)
                else
                    t1 = (mxy(1)%mp(j+2)   + 1.0d-2) / dpbase
                    t2 = (mxy(2)%mp(j+1) + 1.0d-2) / dpbase
                    do while (u1 < maxint / 100)
                       t1 = t1 * 10
                       k = t1
                       t1 = t1 - k
                       u1 = u1 * 10 + k

                       t2 = t2 * 10
                       k = t2
                       t2 = t2 - k
                       v1 = v1 * 10 + k
                    enddo
                    exit
                endif
             enddo
         else
             u1 = 1
             v1 = 0
         endif

         a1 = 1
         b1 = 0
         c1 = 0
         d1 = 1
         q1a = 0
         q1b = 0

         do while (q1a == q1b)
            if (v1 + c1 /= 0.0d0 .and. v1 + d1 /= 0.0d0) then
                q1a = aint( (u1 + a1) / (v1 + c1) )
                q1b = aint( (u1 + b1) / (v1 + d1) )
                if (q1a == q1b) then
                    t1 = a1 - q1a*c1
                    t2 = b1 - q1a*d1
                    t3 = u1 - q1a*v1
                    if (abs(t1) > abcd_max .or. abs(t2) > abcd_max) then
                        exit
                    else
                        a1 = c1
                        c1 = t1
                        b1 = d1
                        d1 = t2
                        u1 = v1
                        v1 = t3
                    endif
                endif
            else
                exit
            endif
         enddo

         if (b1 == 0) then
             call immod(mxy(1), mxy(2), mxy(4), qx)
             call imeq(mxy(2), mxy(1), qx)
             call imeq(mxy(4), mxy(2), qx)
             if (mxy(2)%mp(3) == 0) then
                 call imeq(mxy(1), mc, qx)
                 call imgcd_tr(mc, ndsave, qx)
                 return
             endif
         else
             call imgcd_reduce_uv(mxy(1), mxy(2), mxy(4), a1, b1, c1, d1, qx)
         endif
      enddo

!             Finish the gcd using double precision.

      if (mxy(2)%mp(3) == 0) then
          call imeq(mxy(1), mc, qx)
          call imgcd_tr(mc, ndsave, qx)
          return
      endif
      u1 = 0
      do j = 1, int(mxy(1)%mp(2))
         u1 = u1 * dpbase + mxy(1)%mp(j+2)
      enddo
      v1 = 0
      do j = 1, int(mxy(2)%mp(2))
         v1 = v1 * dpbase + mxy(2)%mp(j+2)
      enddo
      do while (v1 > 0)
         t1 = mod(u1, v1)
         u1 = v1
         v1 = t1
      enddo
      if (u1 < dpbase) then
          mxy(1)%mp(2) = 1
          mxy(1)%mp(3) = u1
          mxy(1)%mp(4) = 0
      else if (u1 < dpbase*dpbase) then
          mxy(1)%mp(2) = 2
          mxy(1)%mp(3) = aint(u1/dpbase)
          mxy(1)%mp(4) = mod(u1, dpbase)
      else
          if (abs(u1) < huge(1)) then
              k = u1
              call imi2m(k, mxy(1), qx)
          else
              write (st, '(E25.16)') u1
              call imst2m(st, mxy(1), qx)
          endif
      endif

      call imeq(mxy(1), mc, qx)

      if (mc%mp(2) == qx%munkno) then
          qx%kflag = -4
          qx%namest(qx%ncall) = 'IMGCD'
          call fmwarn(qx)
      endif

      call imgcd_tr(mc, ndsave, qx)

      return
      end subroutine imgcd

      subroutine imgcd2(ma, mb, mc, qx)

!  mc is returned as the greatest common divisor of ma and mb.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: kl, ndsave, result_size
      type(multi) :: mxy(4)

      result_size = max(ma%mp(2), mb%mp(2)) + 3
      if (abs(result_size) >= qx%mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mc, result_size, qx)

      qx%ncall = qx%ncall + 1
      mc%mp(5) = 0
      qx%kflag = 0
      ndsave = qx%ndig
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMGCD2'
          call imntr_inp2(ma, mb, qx)
      endif

!             Check for special cases.

      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) then
          call imunknown(mc, qx)
          qx%kflag = -4
          call imgcd_tr(mc, ndsave, qx)
          return
      else if (mb%mp(3) == 0) then
          call imabs(ma, mc, qx)
          call imgcd_tr(mc, ndsave, qx)
          return
      else if (ma%mp(3) == 0) then
          call imabs(mb, mc, qx)
          call imgcd_tr(mc, ndsave, qx)
          return
      else if (mb%mp(2) == 1 .and. abs(mb%mp(3)) == 1) then
          call imi2m(1, mc, qx)
          call imgcd_tr(mc, ndsave, qx)
          return
      else if (ma%mp(2) == 1 .and. abs(ma%mp(3)) == 1) then
          call imi2m(1, mc, qx)
          call imgcd_tr(mc, ndsave, qx)
          return
      else if (ma%mp(2) < 0 .or. mb%mp(2) < 0 .or.  &
          ma%mp(2) >= qx%mexpov .or. mb%mp(2) >= qx%mexpov) then
          qx%kflag = -4
          qx%namest(qx%ncall) = 'IMGCD2'
          call fmwarn(qx)
          call imunknown(mc, qx)
          call imgcd_tr(mc, ndsave, qx)
          return
      endif

      call imabs(ma, mxy(3), qx)
      call imabs(mb, mxy(2), qx)
      call immax(mxy(3), mxy(2), mxy(1), qx)
      call immin(mxy(3), mxy(2), mxy(4), qx)
      call imeq(mxy(4), mxy(2), qx)
      kl = 1
      do while (kl == 1)
         call imdivr(mxy(1), mxy(2), mxy(4), mxy(3), qx)
         if (mxy(3)%mp(3) /= 0) then
             call imeq(mxy(2), mxy(1), qx)
             call imeq(mxy(3), mxy(2), qx)
         else
             kl = 0
         endif
      enddo
      call imeq(mxy(2), mc, qx)

      if (mc%mp(2) == qx%munkno) then
          qx%kflag = -4
          qx%namest(qx%ncall) = 'IMGCD2'
          call fmwarn(qx)
      endif

      call imgcd_tr(mc, ndsave, qx)

      return
      end subroutine imgcd2

      subroutine imgcd_reduce_uv(mu, mv, mv_shift, a1, b1, c1, d1, qx)

!  Return  mu = a1 * mu + b1 * mv,
!  and     mv = c1 * mu + d1 * mv.

      use fmvals_parallel
      implicit none

      type(multi) :: mu, mv, mv_shift
      double precision :: a1, b1, c1, d1
      intent (in) :: a1, b1, c1, d1
      intent (inout) :: mu, mv, mv_shift
      type(fm_settings) :: qx

      integer :: j, k, n_u, n_v
      double precision :: u1, v1

      n_u = mu%mp(2)
      n_v = mv%mp(2)
      k = n_u - n_v
      if (k == 0) then
          do j = 3, n_u+2
             u1 = mu%mp(j)
             v1 = mv%mp(j)
             mu%mp(j-1) = a1 * u1 + b1 * v1
             mv%mp(j-1) = c1 * u1 + d1 * v1
          enddo
      else
          do j = 3, k+2
             mv_shift%mp(j) = 0
          enddo
          do j = 3, n_v+2
             mv_shift%mp(j+k) = mv%mp(j)
          enddo
          n_v = n_u
          do j = 3, n_u+2
             u1 = mu%mp(j)
             v1 = mv_shift%mp(j)
             mu%mp(j-1) = a1 * u1 + b1 * v1
             mv%mp(j-1) = c1 * u1 + d1 * v1
          enddo
      endif

!             Normalize the digits in mu and mv.

      do j = n_u+1, 2, -1
         if (mu%mp(j) < 0) then
             k = (-mu%mp(j)-1) / qx%mbase + 1
             mu%mp(j) = mu%mp(j) + k * qx%mbase
             mu%mp(j-1) = mu%mp(j-1) - k
         else
             k = mu%mp(j) / qx%mbase
             mu%mp(j) = mu%mp(j) - k * qx%mbase
             mu%mp(j-1) = mu%mp(j-1) + k
         endif
      enddo

      do j = n_v+1, 2, -1
         if (mv%mp(j) < 0) then
             k = (-mv%mp(j)-1) / qx%mbase + 1
             mv%mp(j) = mv%mp(j) + k * qx%mbase
             mv%mp(j-1) = mv%mp(j-1) - k
         else
             k = mv%mp(j) / qx%mbase
             mv%mp(j) = mv%mp(j) - k * qx%mbase
             mv%mp(j-1) = mv%mp(j-1) + k
         endif
      enddo

!             Normalize the numbers if there are leading zeros.

      if (mu%mp(2) == 0) then
          mu%mp(2) = n_u - 1
      else
          do j = n_u+2, 3, -1
             mu%mp(j) = mu%mp(j-1)
          enddo
          mu%mp(2) = n_u
      endif
      k = 0
      do j = 3, n_u+2
         if (mu%mp(j) == 0) then
             k = k + 1
         else
             exit
         endif
      enddo
      if (k > 0) then
          mu%mp(2) = mu%mp(2) - k
          do j = 3, int(mu%mp(2))+2
             mu%mp(j) = mu%mp(j+k)
          enddo
          do j = 0, k-1
             mu%mp(2+n_u-j) = 0
          enddo
      endif

      if (mv%mp(2) == 0) then
          mv%mp(2) = n_v - 1
      else
          do j = n_v+2, 3, -1
             mv%mp(j) = mv%mp(j-1)
          enddo
          mv%mp(2) = n_v
      endif
      k = 0
      do j = 3, n_v+2
         if (mv%mp(j) == 0) then
             k = k + 1
         else
             exit
         endif
      enddo
      if (k > 0) then
          mv%mp(2) = mv%mp(2) - k
          do j = 3, int(mv%mp(2))+2
             mv%mp(j) = mv%mp(j+k)
          enddo
          do j = 0, k-1
             mv%mp(2+n_v-j) = 0
          enddo
      endif

      end subroutine imgcd_reduce_uv

      subroutine imgcd_tr(mc, ndsave, qx)

!  Trace output for imgcd.

      use fmvals_parallel
      implicit none

      type(multi) :: mc
      integer :: ndsave
      intent (in) :: ndsave
      intent (inout) :: mc
      type(fm_settings) :: qx

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      if (qx%ntrace /= 0) call imntr_out1(mc, qx)
      qx%ncall = qx%ncall - 1
      qx%ndig = ndsave

      return
      end subroutine imgcd_tr

      subroutine imi2fm(ma, mb, qx)

!  mb = ma

!  Convert from integer (im) format to real (fm) format.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      integer :: kdg

      call fmalloc(mb, qx%ndig+2, qx)

      qx%ncall = qx%ncall + 1
      qx%kflag = 0
      kdg = max(3, int(ma%mp(2)))
      if (ma%mp(2) >= qx%mexpov) kdg = 3
      call fmequ(ma, mb, kdg, qx%ndig, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine imi2fm

      subroutine imi2m(ival, ma, qx)

!  ma = ival

!  This routine performs the trace printing.  imi2m2 is used to do the conversion.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ival
      intent (inout) :: ma
      type(fm_settings) :: qx

      qx%ncall = qx%ncall + 1
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMI2M'
          call imntr_inpi(ival, qx)

          call imi2m2(ival, ma, qx)

          call imntr_out1(ma, qx)
      else
          call imi2m2(ival, ma, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine imi2m

      subroutine imi2m2(ival, ma, qx)

!  ma = ival

!  Convert a one word integer to im format.

      use fmvals_parallel
      implicit none

      integer :: ival
      type(multi) :: ma
      intent (in) :: ival
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: ndsave, result_size
      double precision :: dt

      qx%kflag = 0
      ndsave = qx%ndig
      if (ival == 0) then
          qx%ndig = 3
      else
          dt = log(dble(abs(ival)))/qx%dlogmb + 2
          call fmndig(max(3, int(dt)), qx)
      endif
      result_size = qx%ndig + 3
      if (abs(result_size) >= qx%mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(ma, result_size, qx)

      ma%mp(5) = 0
      call fmi2m2(ival, ma, qx)
      if (ma%mp(2) <= 1) ma%mp(4) = 0
      qx%ndig = ndsave

      return
      end subroutine imi2m2

      subroutine iminp(line, ma, la, lb, qx)

!  Convert an array of characters to multiple precision integer format.

!  line is an a1 character array of length lb to be converted to im format and returned in ma.
!  Convert the section line(la:lb)

      use fmvals_parallel
      implicit none

      integer :: la, lb
      character :: line(lb)
      type(multi) :: ma
      intent (in) :: line, la, lb
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: kfsave, ndsave


      qx%ncall = qx%ncall + 1
      qx%kflag = 0
      ndsave = qx%ndig
      qx%namest(qx%ncall) = 'IMINP'

      call fmndig(50, qx)
      qx%ncall = qx%ncall - 1
      call fminp(line, qx%mwi, la, lb, qx)
      qx%ncall = qx%ncall + 1
      if (qx%mwi%mp(2) > 50 .and. abs(qx%mwi%mp(2)) < qx%mexpov) then
          call fmndig(int(qx%mwi%mp(2) + 1), qx)
          if (qx%ndig < 3) qx%ndig = 3
          qx%ncall = qx%ncall - 1
          call fminp(line, qx%mwi, la, lb, qx)
          qx%ncall = qx%ncall + 1
      endif
      kfsave = qx%kflag
      call imfm2i(qx%mwi, ma, qx)
      qx%kflag = kfsave

      if (ma%mp(2) <= 1) ma%mp(4) = 0
      qx%ndig = ndsave
      if (qx%ntrace /= 0) call imntr_out1(ma, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine iminp

      subroutine imm2dp(ma, x, qx)

!  x = ma

!  Convert an im number to double precision.

!  If kflag = -4 is returned for a value of ma that is in the range of the machine's double
!  precision number system, change the definition of dpmax in routine fmset to reflect the
!  current machine's range.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      double precision :: x
      intent (in) :: ma
      intent (inout) :: x
      type(fm_settings) :: qx

      integer :: nd2, ndsave

      qx%ncall = qx%ncall + 1
      qx%kflag = 0
      qx%namest(qx%ncall) = 'IMM2DP'
      if (qx%ntrace /= 0) call imntr_inp1(ma, qx)

      ndsave = qx%ndig
      call fmndig(max(3, int(ma%mp(2))), qx)
      nd2 = 2 - log(epsilon(1.0d0))/qx%dlogmb
      if (qx%ndig >= nd2) call fmndig(nd2, qx)
      if (qx%ndig < 3) qx%ndig = 3
      call fmm2dp2(ma, x, qx)

      if (qx%ntrace /= 0) call imntr_outd(x, qx)
      qx%ndig = ndsave
      qx%ncall = qx%ncall - 1

      return
      end subroutine imm2dp

      subroutine imm2i(ma, ival, qx)

!  ival = ma

!  Convert an im number to a one word integer.

!  kflag =  0 is returned if the conversion is exact.
!        = -4 is returned if ma is larger than intmax in magnitude.  ival = iunkno is returned as
!             an indication that ival could not be computed without integer overflow.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ma
      intent (inout) :: ival
      type(fm_settings) :: qx

      integer :: ndsave

      qx%ncall = qx%ncall + 1
      ndsave = qx%ndig
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMM2I'
          call imntr_inp1(ma, qx)
      endif

      call fmndig(int(ma%mp(2)), qx)
      if (qx%ndig < 3) qx%ndig = 3
      if (abs(ma%mp(2)) >= qx%mexpov) qx%ndig = 3
      qx%kflag = 0
      call fmm2i(ma, ival, qx)

      if (qx%kflag == -4 .and. ma%mp(2) /= qx%munkno) then
          qx%namest(qx%ncall) = 'IMM2I'
          call fmwarn(qx)
      endif
      if (abs(qx%ntrace) >= 1 .and. qx%ncall <= qx%lvltrc) then
          call imntr_outi(ival, qx)
      endif
      qx%ncall = qx%ncall - 1
      qx%ndig = ndsave

      return
      end subroutine imm2i

      subroutine imm2sp(ma, x, qx)

!  x = ma

!  Convert an im number to single precision.

!  if kflag = -4 is returned for a value of ma that is in the range of the machine's single
!  precision number system, change the definition of spmax in routine fmset to reflect the
!  current machine's range.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      real :: x
      intent (in) :: ma
      intent (inout) :: x
      type(fm_settings) :: qx

      double precision :: y
      integer :: nd2, ndsave

      qx%ncall = qx%ncall + 1
      qx%kflag = 0
      qx%namest(qx%ncall) = 'IMM2SP'
      if (qx%ntrace /= 0) call imntr_inp1(ma, qx)

      ndsave = qx%ndig
      call fmndig(max(3, int(ma%mp(2))), qx)
      nd2 = 2 - log(epsilon(1.0d0))/qx%dlogmb
      if (qx%ndig >= nd2) call fmndig(nd2, qx)
      if (qx%ndig < 3) qx%ndig = 3
      call fmm2dp2(ma, y, qx)
      if (abs(y) <= dble(huge(x))) then
          x = y
      else
          x = qx%runkno
          qx%kflag = -4
          if (ma%mp(2) /= qx%munkno) call fmwarn(qx)
      endif

      if (qx%ntrace /= 0) call imntr_outr(x, qx)
      qx%ndig = ndsave
      qx%ncall = qx%ncall - 1

      return
      end subroutine imm2sp

      subroutine immax(ma, mb, mc, qx)

!  mc = max(ma,mb)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: kwrnsv
      logical, external :: imcomp

      qx%kflag = 0
      qx%ncall = qx%ncall + 1
      call imi2m(0, mc, qx)
      mc%mp(5) = 0
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMMAX'
          call imntr_inp2(ma, mb, qx)
      endif

      kwrnsv = qx%kwarn
      qx%kwarn = 0
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) then
          call imunknown(mc, qx)
          qx%kflag = -4
      else if (imcomp(ma, '< ', mb, qx)) then
          call imeq(mb, mc, qx)
      else
          call imeq(ma, mc, qx)
      endif

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      qx%kwarn = kwrnsv
      if (qx%ntrace /= 0) call imntr_out1(mc, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine immax

      subroutine immin(ma, mb, mc, qx)

!  mc = min(ma,mb)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: kwrnsv
      logical, external :: imcomp

      qx%kflag = 0
      qx%ncall = qx%ncall + 1
      call imi2m(0, mc, qx)
      mc%mp(5) = 0
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMMIN'
          call imntr_inp2(ma, mb, qx)
      endif

      kwrnsv = qx%kwarn
      qx%kwarn = 0
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) then
          call imunknown(mc, qx)
          qx%kflag = -4
      else if (imcomp(ma, '> ', mb, qx)) then
          call imeq(mb, mc, qx)
      else
          call imeq(ma, mc, qx)
      endif

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      qx%kwarn = kwrnsv
      if (qx%ntrace /= 0) call imntr_out1(mc, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine immin

      subroutine immod(ma, mb, mc, qx)

!  mc = mod(ma,mb)

!  Use imdivr if both int(ma/mb) and mod(ma,mb) are needed.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: kl, ndsave, result_size
      type(multi) :: mxy(2)

      result_size = min(ma%mp(2), mb%mp(2)) + 3
      if (abs(result_size) >= qx%mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mc, result_size, qx)

      qx%ncall = qx%ncall + 1
      mc%mp(5) = 0
      qx%kflag = 0
      ndsave = qx%ndig
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMMOD'
          call imntr_inp2(ma, mb, qx)
      endif

      kl = 1
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) then
          call imunknown(mc, qx)
          qx%kflag = -4
          kl = 0
      endif

      if (kl == 1) then
          call imdivr(ma, mb, mxy(1), mxy(2), qx)
          call imeq(mxy(2), mc, qx)

          if (mc%mp(2) == qx%munkno) then
              qx%kflag = -4
              qx%namest(qx%ncall) = 'IMMOD'
              call fmwarn(qx)
          endif
      endif

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      if (qx%ntrace /= 0) call imntr_out1(mc, qx)
      qx%ncall = qx%ncall - 1
      qx%ndig = ndsave

      return
      end subroutine immod

      subroutine immodi(ma, imod, irem, qx)

!  Internal routine to return integer irem = mod( ma , imod ).
!  abs(imod) should be less than maxint/mbase for faster mod calculation.

!  ma is a multiple precision im integer.
!  imod and irem are one-word integers.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: imod, irem
      intent (in) :: ma, imod
      intent (inout) :: irem
      type(fm_settings) :: qx

      type(multi) :: t1, t2
      integer :: j, n
      real (kind(1.0d0)) :: mmod, mrem

      mmod = abs(imod)
      n = ma%mp(2)

!             If abs(imod) is more than than maxint/mbase, do it the hard way, since the
!             mbase*mrem in the fast method could be too big to represent exactly in d.p.

      if (mmod >= maxint/qx%mbase) then
          call imi2m(abs(imod), t1, qx)
          call immod(ma, t1, t2, qx)
          call imm2i(t2, irem, qx)
      else
          mrem = 0
          do j = 3, n+2
             mrem = mod( qx%mbase*mrem + ma%mp(j) , mmod )
          enddo
          irem = mrem
      endif

      if (ma%mp(1) < 0) irem = -irem

      end subroutine immodi

      subroutine immpy(ma, mb, mc, qx)

!  mc = ma * mb

!  This routine performs the trace printing.  immpy2 is used to do the arithmetic.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      qx%ncall = qx%ncall + 1
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMMPY'
          call imntr_inp2(ma, mb, qx)

          call immpy2(ma, mb, mc, qx)

          call imntr_out1(mc, qx)
      else
          call immpy2(ma, mb, mc, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine immpy

      subroutine immpy2(ma, mb, mc, qx)

!  mc = ma * mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mdab
      integer :: ndsave, result_size

      if (ma%mp(2) >= qx%mexpov .or. mb%mp(2) >= qx%mexpov) then
          result_size = 5
      else
          result_size = ma%mp(2) + mb%mp(2) + 4
      endif
      result_size = max(5, result_size)
      call fmalloc(mc, result_size, qx)

      mc%mp(5) = 0
      qx%kflag = 0
      ndsave = qx%ndig

      if (ma%mp(2) <= 1 .and. mb%mp(2) <= 1) then
          mdab = ma%mp(1) * ma%mp(3) * mb%mp(1) * mb%mp(3)
          if (abs(mdab) < qx%mbase) then
              mc%mp(2) = 1
              if (mdab == 0) mc%mp(2) = 0
              if (mdab >= 0) then
                  mc%mp(3) = mdab
                  mc%mp(1) = 1
              else
                  mc%mp(3) = -mdab
                  mc%mp(1) = -1
              endif
              mc%mp(4) = 0
              qx%ndig = ndsave
              return
          else if (abs(mdab) < qx%mbase*qx%mbase) then
              mc%mp(2) = 2
              if (mdab >= 0) then
                  mc%mp(3) = aint (mdab/qx%mbase)
                  mc%mp(4) = abs(mdab - qx%mbase*mc%mp(3))
                  mc%mp(1) = 1
              else
                  mc%mp(3) = aint (-mdab/qx%mbase)
                  mc%mp(4) = abs(-mdab - qx%mbase*mc%mp(3))
                  mc%mp(1) = -1
              endif
              qx%ndig = ndsave
              return
          endif
      endif

!             Check for special cases.

      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) then
          qx%kflag = -4
          call imi2m2(0, mc, qx)
          mc%mp(2) = qx%munkno
          mc%mp(3) = 1
          qx%ndig = ndsave
          return
      endif
      if (ma%mp(3) == 0 .or. mb%mp(3) == 0) then
          mc%mp(1) = 1
          mc%mp(2) = 0
          mc%mp(3) = 0
          mc%mp(4) = 0
          qx%ndig = ndsave
          return
      endif
      if (ma%mp(2) == qx%mexpov .or. mb%mp(2) == qx%mexpov) then
          qx%kflag = -5
          if (ma%mp(1)*mb%mp(1) < 0) then
              call imi2m2(-1, mc, qx)
              mc%mp(2) = qx%mexpov
              mc%mp(3) = 1
          else
              call imi2m2(1, mc, qx)
              mc%mp(2) = qx%mexpov
              mc%mp(3) = 1
          endif
          qx%ndig = ndsave
          return
      endif
      if (ma%mp(2) < 0 .or. mb%mp(2) < 0) then
          qx%kflag = -4
          qx%namest(qx%ncall) = 'IMMPY'
          call fmwarn(qx)
          call imi2m2(0, mc, qx)
          mc%mp(2) = qx%munkno
          mc%mp(3) = 1
          qx%ndig = ndsave
          return
      endif
      if (mb%mp(2) == 1 .and. mb%mp(3) == 1 .and. mb%mp(1) == 1) then
          call imeq(ma, mc, qx)
          if (mc%mp(2) <= 1) mc%mp(4) = 0
          qx%ndig = ndsave
          return
      else if (mb%mp(2) == 1 .and. mb%mp(3) == 1 .and. mb%mp(1) == -1) then
          call imeq(ma, mc, qx)
          call fmnegate(mc, qx)
          if (mc%mp(2) <= 1) mc%mp(4) = 0
          qx%ndig = ndsave
          return
      else if (ma%mp(2) == 1 .and. ma%mp(3) == 1 .and. ma%mp(1) == 1) then
          call imeq(mb, mc, qx)
          if (mc%mp(2) <= 1) mc%mp(4) = 0
          qx%ndig = ndsave
          return
      else if (ma%mp(2) == 1 .and. ma%mp(3) == 1 .and. ma%mp(1) == -1) then
          call imeq(mb, mc, qx)
          call fmnegate(mc, qx)
          if (mc%mp(2) <= 1) mc%mp(4) = 0
          qx%ndig = ndsave
          return
      endif
      call fmndig(int(ma%mp(2) + mb%mp(2)), qx)
      if (qx%ndig < 3) qx%ndig = 3
      call immpy3(ma, mb, qx)

!             Transfer to mc and fix the sign of the result.

      call fmndig(int(qx%mwa%mp(2)), qx)
      if (qx%ndig < 3) qx%ndig = 3
      if (ma%mp(1)*mb%mp(1) < 0) then
          call fmmove(qx%mwa, mc, qx)
          mc%mp(1) = -1
      else
          call fmmove(qx%mwa, mc, qx)
          mc%mp(1) = 1
      endif

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      qx%ndig = ndsave

      return
      end subroutine immpy2

      subroutine immpy3(ma, mb, qx)

!  Internal multiplication of ma*mb.  The result is returned in mwa.  Both ma and mb are positive.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma, mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: maxmwa, mbj, mbp1, mkt, mmax
      integer :: j, jm1, k, kb, kl, klma, klmb, n1, nd, nmethd, nzda, nzdb, result_size
      type(multi) :: mxy(2)

      result_size = 2*(ma%mp(2)+mb%mp(2)) + 30
      if (abs(result_size) >= qx%mexpov) result_size = 32
      result_size = max(32, result_size)
      call fmalloc(qx%mwa, result_size, qx)

      n1 = qx%ndig + 1
      qx%mwa%mp(2) = ma%mp(2) + mb%mp(2)
      qx%mwa%mp(n1+2) = 0

!             Check for using an fft-based method if precision is very high.

      nd = max(ma%mp(2), mb%mp(2))
      if (log(7.0d0*nd/3.0d0) < log(7.0d3/3.0d0)*min(ma%mp(2), mb%mp(2))/1.0d3) then
          nzda = int(ma%mp(2))
          nzdb = int(mb%mp(2))
          do j = 2, int(mb%mp(2))
             if (mb%mp(j+2) == 0) nzdb = nzdb - 1
          enddo
          if (real(nzda)*nzdb < 65.0*nd*log(real(nd))) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          nmethd = 1
      endif
      if (nmethd == 2) then
          nd = qx%ndig
          call fmndig(max(int(ma%mp(2)), int(mb%mp(2))), qx)
          call fmndig(max(3, qx%ndig), qx)
          call imi2fm(ma, mxy(1), qx)
          call imi2fm(mb, mxy(2), qx)
          call fmmpyfft(mxy(1), mxy(2), qx)
          call fmndig(nd, qx)
          return
      endif

!             The multiplication loop begins here.

!             maxmwa is an upper bound on the size of values in mwa divided by (mbase-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      mbp1 = qx%mbase + 1
      mmax = intmax - qx%mbase
      mmax = min((maxint/mbp1 - mbp1), mmax)
      mbj = mb%mp(3)
      qx%mwa%mp(3) = 0
      klma = int(ma%mp(2))
      do k = klma+3, n1
         qx%mwa%mp(k+1) = 0
      enddo

!             (Inner Loop)

      do k = 3, klma+2
         qx%mwa%mp(k+1) = ma%mp(k)*mbj
      enddo
      maxmwa = mbj
      kl = klma + 1
      if (maxmwa > mmax) then
          maxmwa = 0
          kl = klma + 1
          do kb = kl+1, 3, -1
             mkt = int (qx%mwa%mp(kb+1)/qx%mbase)
             qx%mwa%mp(kb) = qx%mwa%mp(kb) + mkt
             qx%mwa%mp(kb+1) = qx%mwa%mp(kb+1) - mkt*qx%mbase
          enddo
      endif
      jm1 = 2
      klmb = int(mb%mp(2))
      do j = 3, klmb+1
         mbj = mb%mp(j+1)
         if (mbj /= 0) then
             maxmwa = maxmwa + mbj
             jm1 = j - 1
             kl = klma + 1

!                       Major (Inner Loop)

             do k = j+2, j+klma+1
                qx%mwa%mp(k) = qx%mwa%mp(k) + ma%mp(k-jm1)*mbj
             enddo
         endif

         if (maxmwa > mmax) then
             maxmwa = 0

!                       Here normalization is only required for the range of digits currently
!                       changing in mwa.

             do kb = jm1+kl, jm1+2, -1
                mkt = int (qx%mwa%mp(kb+1)/qx%mbase)
                qx%mwa%mp(kb) = qx%mwa%mp(kb) + mkt
                qx%mwa%mp(kb+1) = qx%mwa%mp(kb+1) - mkt*qx%mbase
             enddo
         endif
      enddo

!             Perform the final normalization.  (Inner Loop)

      do kb = n1+1, 4, -1
         mkt = int (qx%mwa%mp(kb)/qx%mbase)
         qx%mwa%mp(kb-1) = qx%mwa%mp(kb-1) + mkt
         qx%mwa%mp(kb) = qx%mwa%mp(kb) - mkt*qx%mbase
      enddo

      return
      end subroutine immpy3

      subroutine immpy_mod(ma, mb, mc, md, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md
      type(fm_settings) :: qx

      call immpym(ma, mb, mc, md, qx)

      return
      end subroutine immpy_mod

      subroutine immpyi(ma, ival, mb, qx)

!  mb = ma * ival

!  This routine performs the trace printing.  immpyi2 is used to do the arithmetic.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      type(fm_settings) :: qx

      qx%ncall = qx%ncall + 1
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMMPYI'
          call imntr_inp1i(ma, ival, qx)

          call immpyi2(ma, ival, mb, qx)

          call imntr_out1(mb, qx)
      else
          call immpyi2(ma, ival, mb, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine immpyi

      subroutine immpyi2(ma, ival, mb, qx)

!  mb = ma * ival

!  Multiplication by a one word integer.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mcarry, mdab, mkt, mval
      double precision :: dt
      integer :: j, ka, kb, kc, kshift, n1, ndsave, nmval, nv2, result_size
      type(multi) :: mxy(1)

      dt = log(dble(abs(ival)+1))/qx%dlogmb + 1
      result_size = ma%mp(2) + dt + 4
      if (abs(result_size) >= qx%mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mb, result_size, qx)
      result_size = 2*result_size + 30
      if (abs(result_size) >= qx%mexpov) result_size = 32
      result_size = max(32, result_size)
      call fmalloc(qx%mwa, result_size, qx)
      mb%mp(5) = 0
      qx%kflag = 0
      ndsave = qx%ndig

!             Check for special cases.

      if (ma%mp(2) <= 1) then
          mdab = ma%mp(1) * ma%mp(3) * ival
          if (abs(mdab) < qx%mbase) then
              mb%mp(2) = 1
              if (mdab == 0) mb%mp(2) = 0
              mb%mp(1) = 1
              if (mdab < 0) mb%mp(1) = -1
              mb%mp(3) = abs(mdab)
              mb%mp(4) = 0
              qx%ndig = ndsave
              return
          else if (abs(mdab) < qx%mbase*qx%mbase) then
              mb%mp(2) = 2
              mb%mp(1) = 1
              if (mdab < 0) mb%mp(1) = -1
              mdab = abs(mdab)
              mb%mp(3) = aint (mdab/qx%mbase)
              mb%mp(4) = mdab - qx%mbase*mb%mp(3)
              qx%ndig = ndsave
              return
          endif
      endif

      if (ma%mp(2) < 0) then
          qx%kflag = -4
          qx%namest(qx%ncall) = 'IMMPYI'
          call fmwarn(qx)
          call imi2m2(0, mb, qx)
          mb%mp(2) = qx%munkno
          mb%mp(3) = 1
          qx%ndig = ndsave
          return
      endif
      if (ma%mp(2) == qx%munkno) then
          qx%kflag = -4
          call imi2m2(0, mb, qx)
          mb%mp(2) = qx%munkno
          mb%mp(3) = 1
          qx%ndig = ndsave
          return
      else if (ival == 0) then
          call imi2m2(0, mb, qx)
          mb%mp(4) = 0
          qx%ndig = ndsave
          return
      else if (ival == 1) then
          call imeq(ma, mb, qx)
          if (mb%mp(2) <= 1) mb%mp(4) = 0
          qx%ndig = ndsave
          return
      else if (ival == -1) then
          call imeq(ma, mb, qx)
          call fmnegate(mb, qx)
          if (mb%mp(2) <= 1) mb%mp(4) = 0
          qx%ndig = ndsave
          return
      else if (ma%mp(2) == 1 .and. ma%mp(3)*ma%mp(1) == 1) then
          call imi2m2(ival, mb, qx)
          if (mb%mp(2) <= 1) mb%mp(4) = 0
          qx%ndig = ndsave
          return
      else if (ma%mp(2) == 1 .and. ma%mp(3)*ma%mp(1) == -1) then
          call imi2m2(ival, mb, qx)
          call fmnegate(mb, qx)
          if (mb%mp(2) <= 1) mb%mp(4) = 0
          qx%ndig = ndsave
          return
      else if (ma%mp(2) == qx%mexpov) then
          qx%kflag = -5
          call imi2m2(1, mb, qx)
          mb%mp(2) = qx%mexpov
          mb%mp(3) = 1
          if ((ival > 0 .and. ma%mp(1) < 0) .or. (ival < 0 .and.ma%mp(1) > 0)) then
              mb%mp(1) = -1
          endif
          qx%ndig = ndsave
          return
      endif

!             Work with positive numbers.

      mval = abs(ival)
      nmval = int(mval)
      nv2 = nmval - 1
      call fmndig(int(ma%mp(2)), qx)
      if (qx%ndig < 3) qx%ndig = 3
      if (abs(ma%mp(2)) >= qx%mexpov) qx%ndig = 3
      n1 = qx%ndig + 1

!             To leave room for normalization, shift the product to the right kshift places in mwa.

      kshift = int((log(dble(ma%mp(3)+1)*dble(mval)))/qx%dlogmb)

!             If ival is too big, use immpy2.

      if (kshift > qx%ndig .or. mval > maxint/qx%mbase .or.  &
          nmval /= abs(ival) .or. nv2 /= abs(ival)-1) then
          call imi2m2(ival, mxy(1), qx)
          call immpy2(ma, mxy(1), mb, qx)
          if (mb%mp(2) <= 1) mb%mp(4) = 0
          qx%ndig = ndsave
          return
      endif

      qx%mwa%mp(2) = ma%mp(2) + kshift
      ka = 2 + kshift
      kb = n1 + kshift
      kc = qx%ndig + 5
      do j = kb, kc
         qx%mwa%mp(j+1) = 0
      enddo

      mcarry = 0

!             This is the main multiplication loop.

      do j = kb, ka, -1
         mkt = ma%mp(j-kshift+1)*mval + mcarry
         mcarry = int (mkt/qx%mbase)
         qx%mwa%mp(j+1) = mkt - mcarry*qx%mbase
      enddo

!             Resolve the final carry.

      do j = ka-1, 2, -1
         mkt = int (mcarry/qx%mbase)
         qx%mwa%mp(j+1) = mcarry - mkt*qx%mbase
         mcarry = mkt
      enddo

!             Now the first significant digit in the product is in
!             mwa%mp(3) or mwa%mp(4).

      if (qx%mwa%mp(3) == 0) then
          mb%mp(2) = qx%mwa%mp(2) - 1
          do j = 3, kb
             mb%mp(j) = qx%mwa%mp(j+1)
          enddo
      else
          mb%mp(2) = qx%mwa%mp(2)
          do j = 2, kb
             mb%mp(j+1) = qx%mwa%mp(j+1)
          enddo
      endif

!             Put the sign on the result.

      mb%mp(1) = 1
      if ((ival > 0 .and. ma%mp(1) < 0) .or. (ival < 0 .and.ma%mp(1) > 0)) mb%mp(1) = -1

      if (mb%mp(2) <= 1) mb%mp(4) = 0
      qx%ndig = ndsave

      return
      end subroutine immpyi2

      subroutine immpym(ma, mb, mc, md, qx)

!  md = ma * mb mod mc

!  This routine is slightly faster than calling immpy and immod separately.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: maxmwa, mbp1, mc1, mcarry, mdc, mdab, mkt, mlmax, mqd, mt1
      double precision :: xb, xbase, xbr, xmwa
      integer :: j, jb, jl, k, ka, kb, kl, kld, kltflg, kptmwa, n1, na1, nc1, ndsave,  &
                 nguard, nl, nmcwds, result_size
      type(multi) :: mxy(3)
      logical, external :: imcomp

      result_size = mc%mp(2) + 4
      if (abs(result_size) >= qx%mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(md, result_size, qx)
      result_size = 2*(ma%mp(2)+mb%mp(2)) + 30
      if (abs(result_size) >= qx%mexpov) result_size = 32
      result_size = max(32, result_size)
      call fmalloc(qx%mwa, result_size, qx)

      qx%ncall = qx%ncall + 1
      md%mp(5) = 0
      ndsave = qx%ndig
      qx%kflag = 0
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMMPYM'
          call imntr_inp3(ma, mb, mc, qx)
      endif

      if (ma%mp(2) <= 1) then
          kl = 1
          do while (kl == 1)
             kl = 0
             if (mb%mp(2) > 1) exit
             if (ma%mp(2) < 0 .or. mb%mp(2) < 0) exit
             mdab = ma%mp(1) * ma%mp(3) * mb%mp(1) * mb%mp(3)
             if (mc%mp(2) <= 2) then
                 if (mc%mp(3) == 0) exit
                 if (mc%mp(2) <= 1) then
                     mdc = mc%mp(1) * mc%mp(3)
                 else
                     mdc = mc%mp(1) * (mc%mp(3)*qx%mbase + mc%mp(4))
                 endif
                 mdab = mod(mdab, mdc)
             endif
             if (abs(mdab) < qx%mbase) then
                 md%mp(2) = 1
                 if (mdab == 0) md%mp(2) = 0
                 md%mp(1) = 1
                 if (mdab < 0) md%mp(1) = -1
                 md%mp(3) = abs(mdab)
                 md%mp(4) = 0
                 call immpym2(1, ndsave, md, qx)
                 return
             else if (abs(mdab) < qx%mbase*qx%mbase) then
                 md%mp(2) = 2
                 md%mp(1) = 1
                 if (mdab < 0) md%mp(1) = -1
                 mdab = abs(mdab)
                 md%mp(3) = aint (mdab/qx%mbase)
                 md%mp(4) = mdab - qx%mbase*md%mp(3)
                 call immpym2(1, ndsave, md, qx)
                 return
             endif
          enddo
      endif

!             Check for special cases.

      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno .or.  &
          mc%mp(2) == qx%munkno) then
          qx%kflag = -4
          call imunknown(md, qx)
          call immpym2(0, ndsave, md, qx)
          return
      else if (mc%mp(3) == 0 .or. ma%mp(2) < 0 .or. mb%mp(2) < 0 .or.  &
               mc%mp(2) < 0 .or. ma%mp(2) >= qx%mexpov .or.            &
               mb%mp(2) >= qx%mexpov .or. mc%mp(2) >= qx%mexpov) then
          qx%kflag = -4
          qx%namest(qx%ncall) = 'IMMPYM'
          call fmwarn(qx)
          call imunknown(md, qx)
          call immpym2(0, ndsave, md, qx)
          return
      else if (ma%mp(3) == 0 .or. mb%mp(3) == 0) then
          call imi2m(0, md, qx)
          call immpym2(0, ndsave, md, qx)
          return
      else if (mc%mp(2) == 1 .and. mc%mp(3) == 1) then
          call imi2m(0, md, qx)
          call immpym2(0, ndsave, md, qx)
          return
      else if (mb%mp(2) == 1 .and. mb%mp(3) == 1 .and. mb%mp(1) == 1) then
          call immod(ma, mc, md, qx)
          call immpym2(1, ndsave, md, qx)
          return
      else if (mb%mp(2) == 1 .and. mb%mp(3) == 1 .and. mb%mp(1) == -1) then
          call immod(ma, mc, md, qx)
          call fmnegate(md, qx)
          call immpym2(1, ndsave, md, qx)
          return
      else if (ma%mp(2) == 1 .and. ma%mp(3) == 1 .and. ma%mp(1) == 1) then
          call immod(mb, mc, md, qx)
          call immpym2(1, ndsave, md, qx)
          return
      else if (ma%mp(2) == 1 .and. ma%mp(3) == 1 .and. ma%mp(1) == -1) then
          call immod(mb, mc, md, qx)
          call fmnegate(md, qx)
          call immpym2(1, ndsave, md, qx)
          return
      endif

      call fmndig(int(ma%mp(2) + mb%mp(2)), qx)
      if (qx%ndig < 3) qx%ndig = 3

!             Check for using an fft-based method if precision is very high.

      if (qx%ndig >= 1000) then
          call immpy(ma, mb, mxy(1), qx)
          call immod(mxy(1), mc, mxy(2), qx)
          call imeq(mxy(2), md, qx)
          call immpym2(1, ndsave, md, qx)
          return
      endif

      n1 = qx%ndig + 1

!             It is faster if the second argument is the one with fewer digits.

      if (ma%mp(2) < mb%mp(2)) then
          call immpy3(mb, ma, qx)
      else
          call immpy3(ma, mb, qx)
      endif

!             Now do the division to find mwa mod mc.

      kltflg = 0
      if (qx%mwa%mp(3) == 0) then
          qx%mwa%mp(2) = qx%mwa%mp(2) - 1
      else
          do j = n1, 2, -1
             qx%mwa%mp(j+2) = qx%mwa%mp(j+1)
          enddo
          qx%mwa%mp(3) = 0
      endif
      kl = int(mc%mp(2))
      mt1 = max(ma%mp(2), mb%mp(2))
      result_size = max(mt1, mc%mp(2)) + 4
      if (abs(result_size) >= qx%mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mxy(1), result_size, qx)
      call fmalloc(mxy(2), result_size, qx)
      do j = 1, kl+2
         mxy(1)%mp(j) = mc%mp(j)
      enddo
      mxy(1)%mp(1) = 1
      if (qx%mwa%mp(2) == mxy(1)%mp(2) .and.  &
          abs(qx%mwa%mp(4)) <= mxy(1)%mp(3)) then
          do j = 4, n1+1
             mxy(2)%mp(j) = qx%mwa%mp(j+1)
          enddo
          mxy(2)%mp(3) = abs(qx%mwa%mp(4))
          mxy(2)%mp(2) = qx%mwa%mp(2)
          mxy(2)%mp(1) = 1
          if (imcomp(mxy(2), '==', mxy(1), qx)) then
              kltflg = 2
          else if (imcomp(mxy(2), '< ', mxy(1), qx)) then
              kltflg = 1
          endif
      endif
      if (qx%mwa%mp(2) < mc%mp(2) .or. kltflg >= 1) then
          if (kltflg /= 2) then
              do j = 3, n1+1
                 md%mp(j) = qx%mwa%mp(j+1)
              enddo
              md%mp(2) = qx%mwa%mp(2)
          else
              call imi2m(0, md, qx)
          endif
          md%mp(1) = 1
          if (ma%mp(1)*mb%mp(1) < 0) call fmnegate(md, qx)
          call immpym2(1, ndsave, md, qx)
          return
      endif

      call fmndig(int(qx%mwa%mp(2)), qx)
      if (qx%ndig < 3) qx%ndig = 3

!             nguard is the number of guard digits used.

      nguard = 1
      na1 = int(qx%mwa%mp(2)) + 1
      nc1 = int(mc%mp(2)) + 1
      qx%mwa%mp(2) = qx%mwa%mp(2) - mc%mp(2) + 1
      nl = na1 + nguard + 3
      do j = na1+2, nl
         qx%mwa%mp(j+1) = 0
      enddo

!             Work only with positive numbers.

      mc1 = mc%mp(2)

!             nmcwds is the number of words of mc used to compute the estimated quotient digit mqd.

      nmcwds = 4
      if (qx%mbase < 100) nmcwds = 7

!             xb is an approximation of mc used in estimating the quotient digits.

      xbase = dble(qx%mbase)
      xb = 0
      jl = nmcwds
      if (jl <= nc1) then
          do j = 2, jl
             xb = xb*xbase + dble(mc%mp(j+1))
          enddo
      else
          do j = 2, jl
             if (j <= nc1) then
                 xb = xb*xbase + dble(mc%mp(j+1))
             else
                 xb = xb*xbase
             endif
          enddo
      endif
      if (jl+1 <= nc1) then
          xb = xb + dble(mc%mp(jl+2))/xbase
      endif
      xbr = 1.0d0/xb

!             mlmax determines when to normalize all of mwa.

      mbp1 = qx%mbase + 1
      mlmax = maxint/mbp1
      mkt = intmax - qx%mbase
      mlmax = min(mlmax, mkt)

!             maxmwa is an upper bound on the size of values in mwa divided by mbase-1.
!             It is used to determine whether normalization can be postponed.

      maxmwa = 0

!             kptmwa points to the next digit in the quotient.

      kptmwa = 2

!             This is the start of the division loop.

!             xmwa is an approximation of the active part of mwa used in estimating quotient digits.

      ka = kptmwa + 1
      kb = ka + int(mc1) - 1
      jb = ka - 2
      kld = 1
      do while (kld == 1)
         kld = 0
         kl = kptmwa + nmcwds - 1
         if (kl <= nl) then
             xmwa = ((dble(qx%mwa%mp(kptmwa+1))*xbase + dble(qx%mwa%mp(kptmwa+2)))*xbase  &
                    + dble(qx%mwa%mp(kptmwa+3)))*xbase + dble(qx%mwa%mp(kptmwa+4))
             do j = kptmwa+4, kl
                xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
             enddo
         else
             xmwa = dble(qx%mwa%mp(kptmwa+1))
             do j = kptmwa+1, kl
                if (j <= nl) then
                    xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
                else
                    xmwa = xmwa*xbase
                endif
             enddo
         endif

!             mqd is the estimated quotient digit.

         mqd = aint(xmwa*xbr)
         if (mqd < 0) mqd = mqd - 1

         if (mqd > 0) then
             maxmwa = maxmwa + mqd
         else
             maxmwa = maxmwa - mqd
         endif

!             See if mwa must be normalized.

         ka = kptmwa + 1
         kb = ka + int(mc1) - 1
         if (maxmwa >= mlmax) then
             do j = kb, ka, -1
                if (qx%mwa%mp(j+1) < 0) then
                    mcarry = int((-qx%mwa%mp(j+1)-1)/qx%mbase) + 1
                    qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
                    qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
                else if (qx%mwa%mp(j+1) >= qx%mbase) then
                    mcarry = -int(qx%mwa%mp(j+1)/qx%mbase)
                    qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
                    qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
                endif
             enddo
             xmwa = 0
             if (kl <= nl) then
                 do j = kptmwa, kl
                    xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
                 enddo
             else
                 do j = kptmwa, kl
                    if (j <= nl) then
                        xmwa = xmwa*xbase + dble(qx%mwa%mp(j+1))
                    else
                        xmwa = xmwa*xbase
                    endif
                 enddo
             endif
             mqd = aint(xmwa*xbr)
             if (mqd < 0) mqd = mqd - 1
             if (mqd > 0) then
                 maxmwa = mqd
             else
                 maxmwa = -mqd
             endif
         endif

!             Subtract mqd*mc from mwa.

         jb = ka - 2
         if (mqd /= 0) then

!             Major (Inner Loop)

             do j = ka+1, kb+1
                qx%mwa%mp(j) = qx%mwa%mp(j) - mqd*mc%mp(j-jb)
             enddo
         endif

         qx%mwa%mp(ka+1) = qx%mwa%mp(ka+1) + qx%mwa%mp(ka)*qx%mbase
         qx%mwa%mp(kptmwa+1) = mqd

         kptmwa = kptmwa + 1
         if (kptmwa-2 < qx%mwa%mp(2)) kld = 1
      enddo

!             Final normalization.

      kptmwa = kptmwa - 1
      do j = kptmwa, 3, -1
         if (qx%mwa%mp(j+1) < 0) then
             mcarry = int((-qx%mwa%mp(j+1)-1)/qx%mbase) + 1
             qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
             qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
         else if (qx%mwa%mp(j+1) >= qx%mbase) then
             mcarry = -int(qx%mwa%mp(j+1)/qx%mbase)
             qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
             qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
         endif
      enddo

      kld = 1
      do while (kld == 1)
         kld = 0
         do j = kptmwa+int(mc1), kptmwa+2, -1
            if (qx%mwa%mp(j+1) < 0) then
                mcarry = int((-qx%mwa%mp(j+1)-1)/qx%mbase) + 1
                qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
                qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
            else if (qx%mwa%mp(j+1) >= qx%mbase) then
                mcarry = -int(qx%mwa%mp(j+1)/qx%mbase)
                qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mcarry*qx%mbase
                qx%mwa%mp(j) = qx%mwa%mp(j) - mcarry
            endif
         enddo

!             Due to rounding, the remainder may not be between 0 and abs(mc) here.
!             Correct if necessary.

         if (qx%mwa%mp(ka+1) < 0) then
             do j = ka, kb
                qx%mwa%mp(j+1) = qx%mwa%mp(j+1) + mc%mp(j-jb+1)
             enddo
             kld = 1
         else if (qx%mwa%mp(ka+1) >= qx%mbase) then
             do j = ka, kb
                qx%mwa%mp(j+1) = qx%mwa%mp(j+1) - mc%mp(j-jb+1)
             enddo
             kld = 1
         endif
      enddo

      if (qx%mwa%mp(kptmwa+2) /= 0) then
          do j = 1, int(mc1)
             md%mp(j+2) = qx%mwa%mp(j+kptmwa+1)
          enddo
          md%mp(2) = mc1
      else
          kld = 1
          do j = 1, int(mc1)
             if (qx%mwa%mp(j+kptmwa+1) /= 0) then
                 do k = j, int(mc1)
                    md%mp(k-j+3) = qx%mwa%mp(k+kptmwa+1)
                 enddo
                 md%mp(2) = mc1 + 1 - j
                 kld = 0
                 exit
             endif
          enddo
          if (kld == 1) then
              md%mp(2) = 0
              md%mp(3) = 0
          endif
      endif
      if (md%mp(2) <= 1) md%mp(4) = 0

      if (md%mp(2) > mxy(1)%mp(2) .or.    &
         (md%mp(2) == mxy(1)%mp(2) .and.  &
          abs(md%mp(3)) >= mxy(1)%mp(3))) then
          md%mp(1) = 1
          if (imcomp(md, '>=', mxy(1), qx)) then
              call imsub(md, mxy(1), mxy(3), qx)
              call imeq(mxy(3), md, qx)
          endif
      endif

      md%mp(1) = 1
      if (ma%mp(1)*mb%mp(1) < 0) then
          call fmnegate(md, qx)
      endif

      call immpym2(1, ndsave, md, qx)

      return
      end subroutine immpym

      subroutine immpym2(kf, ndsave, md, qx)

      use fmvals_parallel
      implicit none

      integer :: kf, ndsave
      type(multi) :: md
      intent (in) :: kf, ndsave
      intent (inout) :: md
      type(fm_settings) :: qx

      if (kf == 1) then
          if (md%mp(2) == qx%munkno) then
              qx%kflag = -4
              qx%namest(qx%ncall) = 'IMMPYM'
              call fmwarn(qx)
          endif
      endif

      if (md%mp(2) <= 1) md%mp(4) = 0
      if (qx%ntrace /= 0) call imntr_out1(md, qx)
      qx%ncall = qx%ncall - 1
      qx%ndig = ndsave

      return
      end subroutine immpym2

      subroutine imntr_inp1(ma, qx)

!  Print im numbers in base 10 format.  This is used for trace input from the im routines.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx

      integer :: ndsave
      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return
      if (abs(qx%ntrace) == 1) return

      name = qx%namest(qx%ncall)
      write (qx%kw, "(' Input to ', A)") trim(name)

      ndsave = qx%ndig
      if (qx%ntrace < 0) then
          call fmndig(max(3, int(ma%mp(2))), qx)
          if (abs(ma%mp(2)) >= qx%mexpov) qx%ndig = 3
          call imntrj(ma, qx%ndig, qx)
      endif

      if (qx%ntrace > 0) then
          call imprnt(ma, qx)
      endif

      qx%ndig = ndsave

      return
      end subroutine imntr_inp1

      subroutine imntr_inp1i(ma, n, qx)

!  Print im numbers in base 10 format.  This is used for trace input from the im routines.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: n
      intent (in) :: ma, n
      type(fm_settings) :: qx

      integer :: ndsave
      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return
      if (abs(qx%ntrace) == 1) return

      name = qx%namest(qx%ncall)
      write (qx%kw, "(' Input to ', A)") trim(name)

      ndsave = qx%ndig
      if (qx%ntrace < 0) then
          call fmndig(max(3, int(ma%mp(2))), qx)
          if (abs(ma%mp(2)) >= qx%mexpov) qx%ndig = 3
          call imntrj(ma, qx%ndig, qx)
      endif

      if (qx%ntrace > 0) then
          call imprnt(ma, qx)
      endif

      write (qx%kw, "(1X, I20)") n

      qx%ndig = ndsave

      return
      end subroutine imntr_inp1i

      subroutine imntr_inp2(ma, mb, qx)

!  Print im numbers in base 10 format.  This is used for trace input from the im routines.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma, mb
      type(fm_settings) :: qx

      integer :: ndsave
      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return
      if (abs(qx%ntrace) == 1) return

      name = qx%namest(qx%ncall)
      write (qx%kw, "(' Input to ', A)") trim(name)

      ndsave = qx%ndig
      if (qx%ntrace < 0) then
          call fmndig(max(3, int(ma%mp(2))), qx)
          if (abs(ma%mp(2)) >= qx%mexpov) qx%ndig = 3
          call imntrj(ma, qx%ndig, qx)
          call fmndig(max(3, int(mb%mp(2))), qx)
          if (abs(mb%mp(2)) >= qx%mexpov) qx%ndig = 3
          call imntrj(mb, qx%ndig, qx)
      else if (qx%ntrace > 0) then
          call imprnt(ma, qx)
          call imprnt(mb, qx)
      endif

      qx%ndig = ndsave

      return
      end subroutine imntr_inp2

      subroutine imntr_inp3(ma, mb, mc, qx)

!  Print im numbers in base 10 format.  This is used for trace input from the im routines.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb, mc
      type(fm_settings) :: qx

      integer :: ndsave
      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return
      if (abs(qx%ntrace) == 1) return

      name = qx%namest(qx%ncall)
      write (qx%kw, "(' Input to ', A)") trim(name)

      ndsave = qx%ndig
      if (qx%ntrace < 0) then
          call fmndig(max(3, int(ma%mp(2))), qx)
          if (abs(ma%mp(2)) >= qx%mexpov) qx%ndig = 3
          call imntrj(ma, qx%ndig, qx)
          call fmndig(max(3, int(mb%mp(2))), qx)
          if (abs(mb%mp(2)) >= qx%mexpov) qx%ndig = 3
          call imntrj(mb, qx%ndig, qx)
          call fmndig(max(3, int(mc%mp(2))), qx)
          if (abs(mc%mp(2)) >= qx%mexpov) qx%ndig = 3
          call imntrj(mc, qx%ndig, qx)
      else if (qx%ntrace > 0) then
          call imprnt(ma, qx)
          call imprnt(mb, qx)
          call imprnt(mc, qx)
      endif

      qx%ndig = ndsave

      return
      end subroutine imntr_inp3

      subroutine imntr_inpd(x, qx)

!  Internal routine for trace input of double precision variables.

      use fmvals_parallel
      implicit none

      double precision :: x
      intent (in) :: x
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return
      if (abs(qx%ntrace) == 1) return

      name = qx%namest(qx%ncall)
      write (qx%kw, "(' Input to ', A)") trim(name)

      write (qx%kw, "(1x, es30.20)") x

      return
      end subroutine imntr_inpd

      subroutine imntr_inpi(n, qx)

!  Internal routine for trace input of integer variables.

      use fmvals_parallel
      implicit none

      integer :: n
      intent (in) :: n
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return
      if (abs(qx%ntrace) == 1) return

      name = qx%namest(qx%ncall)
      write (qx%kw, "(' Input to ', A)") trim(name)

      write (qx%kw, "(1X, I20)") n

      return
      end subroutine imntr_inpi

      subroutine imntr_inpr(x, qx)

!  Internal routine for trace input of real variables.

      use fmvals_parallel
      implicit none

      real :: x
      intent (in) :: x
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return
      if (abs(qx%ntrace) == 1) return

      name = qx%namest(qx%ncall)
      write (qx%kw, "(' Input to ', A)") trim(name)

      write (qx%kw, "(1x, es20.10)") x

      return
      end subroutine imntr_inpr

      subroutine imntr_out1(ma, qx)

!  Print im numbers in base 10 format.  This is used for trace output from the im routines.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx

      integer :: ndsave
      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return
      name = qx%namest(qx%ncall)
      if (qx%kflag == 0) then
          write (qx%kw,                                                   &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10)"                                                   &
                ) name, qx%ncall, int(qx%mbase)
      else
          write (qx%kw,                                                  &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'KFLAG =', I3)"                               &
                ) name, qx%ncall, int(qx%mbase), qx%kflag
      endif

      ndsave = qx%ndig
      if (qx%ntrace < 0) then
          call fmndig(max(3, int(ma%mp(2))), qx)
          if (abs(ma%mp(2)) >= qx%mexpov) qx%ndig = 3
          call imntrj(ma, qx%ndig, qx)
      else if (qx%ntrace > 0) then
          call imprnt(ma, qx)
      endif

      qx%ndig = ndsave

      return
      end subroutine imntr_out1

      subroutine imntr_out1i(ma, n, qx)

!  Print im numbers in base 10 format.  This is used for trace output from the im routines.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: n
      intent (in) :: ma, n
      type(fm_settings) :: qx

      integer :: ndsave
      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return
      name = qx%namest(qx%ncall)
      if (qx%kflag == 0) then
          write (qx%kw,                                                   &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10)"                                                   &
                ) name, qx%ncall, int(qx%mbase)
      else
          write (qx%kw,                                                  &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'KFLAG =', I3)"                               &
                ) name, qx%ncall, int(qx%mbase), qx%kflag
      endif

      ndsave = qx%ndig
      if (qx%ntrace < 0) then
          call fmndig(max(3, int(ma%mp(2))), qx)
          if (abs(ma%mp(2)) >= qx%mexpov) qx%ndig = 3
          call imntrj(ma, qx%ndig, qx)
      else if (qx%ntrace > 0) then
          call imprnt(ma, qx)
      endif

      write (qx%kw, "(1X, I20)") n

      qx%ndig = ndsave

      return
      end subroutine imntr_out1i

      subroutine imntr_outd(x, qx)

!  Internal routine for trace output of double precision variables.

      use fmvals_parallel
      implicit none

      double precision :: x
      intent (in) :: x
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return

      name = qx%namest(qx%ncall)
      if (qx%kflag == 0) then
          write (qx%kw, "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', I10)")  &
                 name, qx%ncall, int(qx%mbase)
      else
          write (qx%kw,                                                  &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'KFLAG =', I3)"                               &
                ) name, qx%ncall, int(qx%mbase), qx%kflag
      endif

      write (qx%kw, "(1x, es30.20)") x

      return
      end subroutine imntr_outd

      subroutine imntr_outi(n, qx)

!  Internal routine for trace output of integer variables.

      use fmvals_parallel
      implicit none

      integer :: n
      type(fm_settings) :: qx

      character(9) :: name
      intent (in) :: n

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return

      name = qx%namest(qx%ncall)
      if (qx%kflag == 0) then
          write (qx%kw, "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', I10)")  &
                 name, qx%ncall, int(qx%mbase)
      else
          write (qx%kw,                                                  &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'KFLAG =', I3)"                               &
                ) name, qx%ncall, int(qx%mbase), qx%kflag
      endif

      write (qx%kw, "(1X, I20)") n

      return
      end subroutine imntr_outi

      subroutine imntr_outr(x, qx)

!  Internal routine for trace output of real variables.

      use fmvals_parallel
      implicit none

      real :: x
      intent (in) :: x
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return

      name = qx%namest(qx%ncall)
      if (qx%kflag == 0) then
          write (qx%kw, "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', I10)")  &
                 name, qx%ncall, int(qx%mbase)
      else
          write (qx%kw,                                                  &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'KFLAG =', I3)"                               &
                ) name, qx%ncall, int(qx%mbase), qx%kflag
      endif

      write (qx%kw, "(1x, es20.10)") x

      return
      end subroutine imntr_outr

      subroutine imntrj(ma, nd, qx)

!  Print trace output in internal base mbase format.  The number to be printed is in ma.

!  nd is the number of base mbase digits to be printed.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: nd
      intent (in) :: ma, nd
      type(fm_settings) :: qx

      character(99) :: form
      integer :: j, l, n

      l = int(log10(dble(qx%mbase-1))) + 2
      n = (qx%kswide-23)/l
      if (n > 10) n = 5*(n/5)
      if (nd <= n) then
          write (form, "(' (1X, I19, I', I2, ', ', I3, 'I', I2, ') ')") l+2, n-1, l
      else
          write (form,                                                                     &
                 "(' (1X, I19, I', I2, ', ', I3, 'I', I2, '/(22X, ', I3, 'I', I2, ')) ')"  &
                ) l+2, n-1, l, n, l
      endif
      if (int(ma%mp(2)) >= 2) then
          write (qx%kw, *) '            Sign = ', int(ma%mp(1)),  &
                       '  Exponent = ', int(ma%mp(2)), '  Digits:'
          write (form, *) '(13X, ', n, 'I', l, ')'
          write (qx%kw, form) (int(ma%mp(j)), j=3, nd+2)
      else
          write (qx%kw, *) '            Sign = ', int(ma%mp(1)),  &
                       '  Exponent = ', int(ma%mp(2)), '  Digits:'
          write (form, *) '(13X, ', n, 'I', l, ')'
          write (qx%kw, form) int(ma%mp(3)), (0, j=4, nd+2)
      endif

      return
      end subroutine imntrj

      subroutine imout(ma, line, lb, qx)

!  Convert an integer multiple precision number to a character array for output.

!  ma   is an im number to be converted to an a1 character array in base 10 format.
!  line is the character(1) array in which the result is returned.
!  lb   is the length of line.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      integer :: lb
      character :: line(lb)
      intent (in) :: ma, lb
      intent (inout) :: line
      type(fm_settings) :: qx

      integer :: jf1sav, jf2sav, ndsave

      qx%ncall = qx%ncall + 1
      qx%kflag = 0
      ndsave = qx%ndig
      qx%namest(qx%ncall) = 'IMOUT'

      ndsave = qx%ndig
      jf1sav = qx%jform1
      jf2sav = qx%jform2
      qx%jform1 = 2
      qx%jform2 = 0
      call fmndig(max(3, int(ma%mp(2))), qx)
      if (abs(ma%mp(2)) >= qx%mexpov) qx%ndig = 3
      call fmout(ma, line, lb, qx)

      qx%ndig = ndsave
      qx%jform1 = jf1sav
      qx%jform2 = jf2sav
      qx%ncall = qx%ncall - 1

      return
      end subroutine imout

      subroutine impmod(ma, mb, mc, md, qx)

!  md = mod(ma**mb,mc)

!  The binary multiplication method used requires an average of 1.5 * log2(mb) operations.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md
      type(fm_settings) :: qx

      integer :: irem, kl, kwrnsv, ndsave, result_size
      type(multi) :: mxy(6)

      result_size = mc%mp(2) + 3
      if (abs(result_size) >= qx%mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(md, result_size, qx)
      qx%kflag = 0
      qx%ncall = qx%ncall + 1
      md%mp(5) = 0
      ndsave = qx%ndig
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMPMOD'
          call imntr_inp3(ma, mb, mc, qx)
      endif

!             Check for special cases.

      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno .or.  &
          mc%mp(2) == qx%munkno .or. ma%mp(2) == qx%mexpov .or.  &
          mb%mp(2) == qx%mexpov .or. mc%mp(2) == qx%mexpov .or.  &
          ma%mp(2) < 0 .or. mb%mp(2) < 0 .or. mc%mp(2) < 0 .or.  &
          (mb%mp(1)*mb%mp(3) <= 0 .and. ma%mp(3) == 0) .or.      &
          mc%mp(3) == 0) then
          qx%kflag = -4
          if (ma%mp(2) /= qx%munkno .and. mb%mp(2) /= qx%munkno .and.  &
              mc%mp(2) /=qx%munkno) then
              qx%namest(qx%ncall) = 'IMPMOD'
              call fmwarn(qx)
          endif
          call imunknown(md, qx)
          if (qx%ntrace /= 0) call imntr_out1(md, qx)
          qx%ndig = ndsave
          qx%ncall = qx%ncall - 1
          return
      endif

      if (mb%mp(3) == 0) then
          call imi2m(1, md, qx)
          if (qx%ntrace /= 0) call imntr_out1(md, qx)
          qx%ndig = ndsave
          qx%ncall = qx%ncall - 1
          return
      endif

      if (mb%mp(2) == 1 .and. abs(mb%mp(3)) == 1) then
          kwrnsv = qx%kwarn
          qx%kwarn = 0
          if (mb%mp(1) == 1) then
              call immod(ma, mc, mxy(6), qx)
          else
              call imi2m(1, mxy(2), qx)
              call imdivr(mxy(2), ma, mxy(1), mxy(3), qx)
              call immod(mxy(1), mc, mxy(6), qx)
          endif
          call imeq(mxy(6), md, qx)
          if (qx%ntrace /= 0) call imntr_out1(md, qx)
          qx%ndig = ndsave
          qx%ncall = qx%ncall - 1
          qx%kwarn = kwrnsv
          return
      endif

      if (ma%mp(3) == 0) then
          call imi2m(0, md, qx)
          if (qx%ntrace /= 0) call imntr_out1(md, qx)
          qx%ndig = ndsave
          qx%ncall = qx%ncall - 1
          return
      endif

!             Initialize.

      kwrnsv = qx%kwarn
      qx%kwarn = 0
      call imabs(mb, mxy(3), qx)
      call imdivr(ma, mc, mxy(1), mxy(2), qx)
      call imeq(mc, mxy(1), qx)
      call imdvir(mxy(3), 2, mxy(6), irem, qx)
      if (irem == 0) then
          call imi2m(1, mxy(6), qx)
      else
          call imeq(mxy(2), mxy(6), qx)
      endif
      call imdvir(mxy(3), 2, mxy(4), irem, qx)
      call imeq(mxy(4), mxy(3), qx)

!             This is the multiplication loop.

      kl = 1
      do while (kl == 1)
         kl = 0
         call imdvir(mxy(3), 2, mxy(4), irem, qx)
         call imeq(mxy(4), mxy(3), qx)
         call immpym(mxy(2), mxy(2), mxy(1), mxy(5), qx)
         call imeq(mxy(5), mxy(2), qx)
         if (irem == 1) then
             call immpym(mxy(2), mxy(6), mxy(1), mxy(5), qx)
             call imeq(mxy(5), mxy(6), qx)
         endif
         if (mxy(3)%mp(3) > 0 .and. mxy(6)%mp(3) /= 0) kl = 1
      enddo

      if (mb%mp(1) < 0) then
          call imi2m(1, mxy(2), qx)
          qx%krem = 0
          call imdivr(mxy(2), mxy(6), mxy(4), mxy(3), qx)
          qx%krem = 1
          call imeq(mxy(4), mxy(6), qx)
      endif
      qx%kwarn = kwrnsv
      call imeq(mxy(6), md, qx)
      if (qx%kflag < 0) then
          qx%namest(qx%ncall) = 'IMPMOD'
          call fmwarn(qx)
      endif
      if (md%mp(2) <= 1) md%mp(4) = 0
      if (qx%ntrace /= 0) call imntr_out1(md, qx)
      qx%ndig = ndsave
      qx%ncall = qx%ncall - 1

      return
      end subroutine impmod

      subroutine impower(ma, mb, mc, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      call impwr(ma, mb, mc, qx)

      return
      end subroutine impower

      subroutine impower_mod(ma, mb, mc, md, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md
      type(fm_settings) :: qx

      call impmod(ma, mb, mc, md, qx)

      return
      end subroutine impower_mod

      subroutine imprint(ma, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx

      call imprnt(ma, qx)

      return
      end subroutine imprint

      subroutine imprnt(ma, qx)

!  Print ma in base 10 format.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx

      integer :: jf1sav, jf2sav, ndsave

      ndsave = qx%ndig
      jf1sav = qx%jform1
      jf2sav = qx%jform2
      qx%jform1 = 2
      qx%jform2 = 0
      call fmndig(max(3, int(ma%mp(2))), qx)
      if (abs(ma%mp(2)) >= qx%mexpov) qx%ndig = 3
      call fmprnt(ma, qx)
      qx%jform1 = jf1sav
      qx%jform2 = jf2sav
      qx%ndig = ndsave

      return
      end subroutine imprnt

      subroutine impwr(ma, mb, mc, qx)

!  mc = ma**mb

!  The binary multiplication method used requires an average of 1.5 * log2(mb) multiplications.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      double precision :: da, db
      integer :: irem, iremb, jsign, kl, kovfl, kwrnsv, result_size
      type(multi) :: mxy(5)

      kovfl = 0
      if ((ma%mp(2) == 1 .and. ma%mp(3) == 1) .or.  &
          ma%mp(3) == 0 .or. mb%mp(3) == 0) then
          result_size = 5
      else
          result_size = 5
          kovfl = 1
          kwrnsv = qx%kwarn
          qx%kwarn = 0
          call imm2dp(ma, da, qx)
          if (qx%kflag == 0) then
              call imm2dp(mb, db, qx)
              if (qx%kflag == 0) then
                  result_size = abs(db)*log(abs(da)+1)/qx%dlogmb + 5
                  kovfl = 0
                  if (abs(result_size) >= qx%mexpov) then
                      result_size = 5
                      kovfl = 1
                  endif
              endif
          else
              call imm2dp(mb, db, qx)
              if (qx%kflag == 0) then
                  result_size = min(huge(1)/10.0d0, abs(db)*(abs(ma%mp(2))+1) + 5)
                  kovfl = 0
                  if (abs(result_size) >= qx%mexpov .or. abs(ma%mp(2)) >= qx%mexpov) then
                      result_size = 5
                      kovfl = 1
                  endif
              endif
          endif
          qx%kwarn = kwrnsv
      endif
      if (mb%mp(1) < 0 .and. ma%mp(3) /= 0) then
          result_size = 5
      endif
      result_size = max(5, result_size)
      if (abs(result_size) >= qx%mexpov) result_size = 5
      call fmalloc(mc, result_size, qx)

      qx%kflag = 0
      qx%ncall = qx%ncall + 1
      mc%mp(5) = 0
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMPWR'
          call imntr_inp2(ma, mb, qx)
      endif
      kwrnsv = qx%kwarn

!             Check for special cases.

      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno .or.    &
          ma%mp(2) < 0 .or. mb%mp(2) < 0 .or. ((mb%mp(1) < 0 .or.  &
          mb%mp(3) == 0) .and. ma%mp(3) == 0)) then
          qx%kflag = -4
          if (ma%mp(2) /= qx%munkno .and. mb%mp(2) /= qx%munkno) then
              qx%kwarn = kwrnsv
              qx%namest(qx%ncall) = 'IMPWR'
              call fmwarn(qx)
          endif
          call imunknown(mc, qx)
          call impwr2(mc, kwrnsv, qx)
          return
      endif

      if (mb%mp(3) == 0) then
          call imi2m(1, mc, qx)
          call impwr2(mc, kwrnsv, qx)
          return
      endif

      if (ma%mp(2) == 1 .and. ma%mp(3) == 1) then
          qx%kwarn = 0
          if (ma%mp(1) == 1) then
              call imi2m(1, mc, qx)
          else
              call imi2m(2, mxy(1), qx)
              call imdivr(mb, mxy(1), mxy(4), mxy(2), qx)
              call imeq(mxy(4), mxy(1), qx)
              if (mxy(2)%mp(2) == qx%munkno) then
                  qx%kflag = -4
                  qx%kwarn = kwrnsv
                  qx%namest(qx%ncall) = 'IMPWR'
                  call fmwarn(qx)
                  call imunknown(mc, qx)
              else if (mxy(2)%mp(3) == 0) then
                  call imi2m(1, mc, qx)
              else
                  call imi2m(-1, mc, qx)
              endif
          endif
          call impwr2(mc, kwrnsv, qx)
          return
      endif

      if (mb%mp(2) == 1 .and. mb%mp(3) == 1) then
          qx%kwarn = 0
          if (mb%mp(1) == 1) then
              call imeq(ma, mc, qx)
          else
              call imi2m(1, mxy(1), qx)
              qx%krem = 0
              call imdivr(mxy(1), ma, mxy(3), mxy(2), qx)
              call imeq(mxy(3), mc, qx)
              qx%krem = 1
          endif
          call impwr2(mc, kwrnsv, qx)
          return
      endif

      if (ma%mp(3) == 0) then
          call imi2m(0, mc, qx)
          call impwr2(mc, kwrnsv, qx)
          return
      endif

      if (mb%mp(1) < 0) then
          call imi2m(0, mc, qx)
          call impwr2(mc, kwrnsv, qx)
          return
      endif

      if (mb%mp(2) == qx%mexpov) then
          if (mb%mp(1) < 0) then
              call imi2m(0, mc, qx)
          else if (ma%mp(1) > 0) then
              call imst2m('OVERFLOW', mc, qx)
              qx%kflag = -5
          else
              qx%kflag = -4
              qx%kwarn = kwrnsv
              qx%namest(qx%ncall) = 'IMPWR'
              call fmwarn(qx)
              call imunknown(mc, qx)
          endif
          call impwr2(mc, kwrnsv, qx)
          return
      endif

      if (ma%mp(2) == qx%mexpov) then
          jsign = 1
          if (ma%mp(1) < 0) jsign = -1
          if (mb%mp(1) > 0) then
              call imdvir(mb, 2, mxy(1), irem, qx)
              call imst2m('OVERFLOW', mc, qx)
              mc%mp(1) = jsign**irem
              qx%kflag = -5
          else
              call imi2m(0, mc, qx)
          endif
          call impwr2(mc, kwrnsv, qx)
          return
      endif

      if (kovfl == 1) then
          if (mb%mp(1) <= 0) then
              call imi2m(0, mc, qx)
          else if (ma%mp(1) >= 0) then
              call imst2m('OVERFLOW', mc, qx)
              qx%kflag = -5
              qx%kwarn = kwrnsv
              qx%namest(qx%ncall) = 'IMPWR'
              call fmwarn(qx)
          else
              call imdvir(mb, 2, mxy(1), irem, qx)
              call imst2m('OVERFLOW', mc, qx)
              mc%mp(1) = (-1)**irem
              qx%kflag = -5
              qx%kwarn = kwrnsv
              qx%namest(qx%ncall) = 'IMPWR'
              call fmwarn(qx)
          endif
          call impwr2(mc, kwrnsv, qx)
          return
      endif

!             Initialize.

      call fmalloc(mxy(1), result_size, qx)
      call fmalloc(mxy(3), result_size, qx)
      call fmalloc(mxy(5), result_size, qx)
      qx%kwarn = 0
      call imabs(mb, mxy(2), qx)

      call imeq(ma, mxy(1), qx)

      call imdvir(mb, 2, mxy(4), iremb, qx)
      call imeq(mxy(4), mc, qx)
      if (iremb == 0) then
          call imi2m(1, mc, qx)
      else
          call imeq(mxy(1), mc, qx)
      endif
      call imdvir(mxy(2), 2, mxy(4), irem, qx)
      call imeq(mxy(4), mxy(2), qx)

!             This is the multiplication loop.

      kl = 1
      do while (kl == 1)
         kl = 0
         call imdvir(mxy(2), 2, mxy(4), irem, qx)
         call imeq(mxy(4), mxy(2), qx)
         call imsqr(mxy(1), mxy(5), qx)
         call imeq(mxy(5), mxy(1), qx)
         if (irem == 1) then
             call immpy(mxy(1), mc, mxy(3), qx)
             call imeq(mxy(3), mc, qx)
         endif
         if (mxy(1)%mp(2) == qx%mexpov) then
             call imeq(mxy(1), mc, qx)
             if (ma%mp(1) < 0 .and. iremb == 1) mc%mp(1) = -1
             exit
         endif
         if (mxy(2)%mp(3) > 0) kl = 1
      enddo

      if (mb%mp(1) < 0) then
          call imi2m(1, mxy(1), qx)
          qx%krem = 0
          call imdivr(mxy(1), mc, mxy(4), mxy(2), qx)
          qx%krem = 1
          call imeq(mxy(4), mc, qx)
      endif

      if (mc%mp(2) >= qx%mexpov) then
          if (qx%ncall == 1 .or. mc%mp(2) >= qx%mexpov) then
              if (mc%mp(1) > 0) then
                  call imst2m('OVERFLOW', mc, qx)
              else
                  call imst2m('-OVERFLOW', mc, qx)
              endif
              qx%kflag = -5
              qx%kwarn = kwrnsv
              qx%namest(qx%ncall) = 'IMPWR'
              call fmwarn(qx)
          endif
      endif

      call impwr2(mc, kwrnsv, qx)

      return
      end subroutine impwr

      subroutine impwr2(mc, kwrnsv, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: mc
      integer :: kwrnsv
      intent (in) :: kwrnsv
      intent (inout) :: mc
      type(fm_settings) :: qx

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      qx%kwarn = kwrnsv
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMPWR'
          call imntr_out1(mc, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine impwr2

      subroutine imread(kread, ma, qx)

!  Read ma on unit kread.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  Only one number is allowed on the line(s).

      use fmvals_parallel
      implicit none

      character :: cmbuff(lmbuff)
      type(multi) :: ma
      integer :: kread
      intent (in) :: kread
      intent (inout) :: ma
      type(fm_settings) :: qx

      character :: line(132)
      integer :: j, jstat, kamper, lb

      qx%ncall = qx%ncall + 1
      call imi2m(0, ma, qx)
      ma%mp(5) = 0
      qx%namest(qx%ncall) = 'IMREAD'
      lb = 0
      kamper = 0

      do
         read (kread, "(132A1)", iostat=jstat) line
         if (jstat /= 0) then
             qx%kflag = -4
             call fmwarn(qx)
             call fmunknown(ma, qx)
             qx%ncall = qx%ncall - 1
             return
         endif

!             Scan the line and look for '&'

         do j = 1, 132
            if (line(j) == '&') then
                kamper = 1
                exit
            endif
            if (line(j) /= ' ') then
                lb = lb + 1
                if (lb > lmbuff) then
                    write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                                        " Raise its size (lmbuff) or change the format being used."
                    stop
                endif
                cmbuff(lb) = line(j)
            endif
         enddo
         if (kamper == 0) exit
         kamper = 0
      enddo

      call iminp(cmbuff, ma, 1, lb, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine imread

      subroutine imsign(ma, mb, mc, qx)

!  mc = sign(ma,mb)

!  mc is set to abs(ma) if mb is positive or zero, or -abs(ma) if mb is negative.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      type(fm_settings) :: qx

      integer :: kwrnsv, ndsave, result_size
      intent (in) :: ma, mb
      intent (inout) :: mc

      result_size = ma%mp(2) + 3
      if (abs(result_size) >= qx%mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mc, result_size, qx)

      qx%kflag = 0
      qx%ncall = qx%ncall + 1
      mc%mp(5) = 0
      ndsave = qx%ndig
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMSIGN'
          call imntr_inp2(ma, mb, qx)
      endif

      call fmndig(int(ma%mp(2)), qx)
      if (qx%ndig < 3) qx%ndig = 3
      if (abs(ma%mp(2)) >= qx%mexpov) qx%ndig = 3
      kwrnsv = qx%kwarn
      qx%kwarn = 0
      if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) then
          call imunknown(mc, qx)
          qx%kflag = -4
      else if (ma%mp(2) < 0 .or. mb%mp(2) < 0) then
          qx%kflag = -4
          qx%namest(qx%ncall) = 'IMSIGN'
          call fmwarn(qx)
          call imunknown(mc, qx)
      else if (mb%mp(1) >= 0) then
          call imeq(ma, mc, qx)
          mc%mp(1) = 1
      else
          call imeq(ma, mc, qx)
          if (mc%mp(2) /= qx%munkno .and. mc%mp(3) /= 0) mc%mp(1) = -1
      endif

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      qx%kwarn = kwrnsv
      if (qx%ntrace /= 0) call imntr_out1(mc, qx)
      qx%ncall = qx%ncall - 1
      qx%ndig = ndsave

      return
      end subroutine imsign

      subroutine imsp2m(x, ma, qx)

!  ma = x

!  Convert the integer part of a single precision to an im number.

      use fmvals_parallel
      implicit none

      real :: x
      type(multi) :: ma
      intent (in) :: x
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: ndsave
      type(multi) :: mxy

      qx%ncall = qx%ncall + 1
      qx%kflag = 0
      qx%namest(qx%ncall) = 'IMSP2M'
      if (qx%ntrace /= 0) call imntr_inpr(x, qx)

      ndsave = qx%ndig
      if (abs(x) < 1) then
          call imi2m(0, ma, qx)
      else
          call fmndig(max(3, int(log(abs(x))/log(dble(qx%mbase)))+2), qx)
          call fmsp2m(x, mxy, qx)
          call imfm2i(mxy, ma, qx)
      endif

      if (qx%ntrace /= 0) call imntr_out1(ma, qx)
      qx%ndig = ndsave
      qx%ncall = qx%ncall - 1

      return
      end subroutine imsp2m

      subroutine imsqr(ma, mb, qx)

!  mb = ma**2

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mdab
      integer :: ndsave, result_size

      result_size = 2*ma%mp(2) + 4
      if (abs(result_size) >= qx%mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mb, result_size, qx)

      qx%ncall = qx%ncall + 1
      mb%mp(5) = 0
      qx%kflag = 0
      ndsave = qx%ndig
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMSQR'
          call imntr_inp1(ma, qx)
      endif

      if (ma%mp(2) <= 1) then
          if (ma%mp(2) >= 0) then
              mdab = ma%mp(3) * ma%mp(3)
              if (abs(mdab) < qx%mbase) then
                  mb%mp(2) = 1
                  if (mdab == 0) mb%mp(2) = 0
                  mb%mp(3) = mdab
                  mb%mp(4) = 0
                  call imsqr3(mb, ndsave, qx)
                  return
              else if (abs(mdab) < qx%mbase*qx%mbase) then
                  mb%mp(2) = 2
                  mb%mp(3) = aint (mdab/qx%mbase)
                  mb%mp(4) = mdab - qx%mbase*mb%mp(3)
                  call imsqr3(mb, ndsave, qx)
                  return
              endif
          endif
      endif

      if (ma%mp(2) == qx%munkno) then
          qx%kflag = -4
          call imunknown(mb, qx)
          call imsqr3(mb, ndsave, qx)
          return
      endif
      if (ma%mp(3) == 0) then
          mb%mp(1) = 1
          mb%mp(2) = 0
          mb%mp(3) = 0
          mb%mp(4) = 0
          call imsqr3(mb, ndsave, qx)
          return
      endif
      if (ma%mp(2) == qx%mexpov) then
          qx%kflag = -5
          call imst2m('OVERFLOW', mb, qx)
          call imsqr3(mb, ndsave, qx)
          return
      endif
      if (ma%mp(2) == 1 .and. abs(ma%mp(3)) == 1) then
          call imi2m(1, mb, qx)
          call imsqr3(mb, ndsave, qx)
          return
      else if (ma%mp(2) < 0) then
          qx%kflag = -4
          qx%namest(qx%ncall) = 'IMSQR'
          call fmwarn(qx)
          call imunknown(mb, qx)
          call imsqr3(mb, ndsave, qx)
          return
      endif

      call fmndig(int(ma%mp(2) + ma%mp(2)), qx)
      if (qx%ndig < 3) qx%ndig = 3

      call imsqr2(ma, mb, qx)

      call imsqr3(mb, ndsave, qx)

      return
      end subroutine imsqr

      subroutine imsqr2(ma, mb, qx)

!  mb = ma**2

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: maxmax, maxmwa, mbj, mbkj, mbnorm, mbp1, mk, mka, mkt, mmax, mt
      integer :: j, jm1, k, kb, ki, kj, kl, knz, kovun, kwa, l, n1, nd, nmethd, nzda, result_size
      type(multi) :: mxy(2)

      result_size = 2*ma%mp(2) + 30
      if (abs(result_size) >= qx%mexpov) result_size = 32
      result_size = max(32, result_size)
      call fmalloc(qx%mwa, result_size, qx)

!             ksqr is used to tell fmmpyfft that only one input fft is needed.

      qx%ksqr = 1
      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      if (qx%mbase*qx%mbase <= mxbase/(4*qx%mbase)) then
          kovun = 0
          if (ma%mp(2) == qx%mexpov .or. ma%mp(2) == qx%mexpun) kovun = 1
          if (ma%mp(2) == qx%munkno) kovun = 2
          qx%ncall = qx%ncall + 1
          call immpy(ma, ma, mb, qx)
          qx%ncall = qx%ncall - 1
          if ((qx%kflag < 0 .and. kovun == 0) .or. (qx%kflag == -4 .and. kovun == 1)) then
              qx%namest(qx%ncall) = 'IMSQR'
              call fmwarn(qx)
          endif
          call imsqr4(mb, 0, qx)
          return
      else if (ma%mp(3) == 0) then
          call imeq(ma, mb, qx)
          call imsqr4(mb, 0, qx)
          return
      endif
      qx%kflag = 0
      maxmax = 0
      n1 = int(ma%mp(2)) + 1
      qx%mwa%mp(2) = ma%mp(2) + ma%mp(2)

!             Check for using an fft-based method if precision is very high.

      nd = 1000
      if (qx%ndig >= nd) then
          nzda = 0
          do j = 2, int(ma%mp(2))
             if (ma%mp(j+2) == 0) nzda = nzda + 1
          enddo
          if (ma%mp(2)-nzda < 50 .or. real(nzda)/ma%mp(2) > 0.8) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          nmethd = 1
      endif
      if (nmethd == 2) then
          nd = qx%ndig
          call fmndig(int(ma%mp(2)), qx)
          if (qx%ndig < 3) qx%ndig = 3
          if (abs(ma%mp(2)) >= qx%mexpov) qx%ndig = 3
          call imi2fm(ma, mxy(1), qx)
          call imi2fm(ma, mxy(2), qx)
          call fmmpyfft(mxy(1), mxy(2), qx)
          call fmndig(nd, qx)
          call imsqr4(mb, 1, qx)
          return
      endif

      l = n1 + int(ma%mp(2))
      qx%mwa%mp(l+2) = 0

!             The multiplication loop begins here.

!             mbnorm is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             maxmwa is an upper bound on the size of values in mwa divided by (mbase-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      mbp1 = qx%mbase + 1
      mbnorm = (maxint/(mbp1*mbp1))
      mmax = intmax - qx%mbase
      mmax = min((maxint/mbp1 - mbp1), mmax)
      knz = n1
      if (mbnorm >= 2) then
          mbj = ma%mp(3)

!             Count the trailing zeros in ma.

          if (ma%mp(n1+1) /= 0) then
              knz = n1
          else
              do j = int(ma%mp(2)), 2, -1
                 if (ma%mp(j+1) /= 0) then
                     knz = j
                     exit
                 endif
              enddo
          endif

          qx%mwa%mp(3) = 0
          qx%mwa%mp(4) = 0
          do k = n1+1, l
             qx%mwa%mp(k+1) = 0
          enddo

!             (Inner Loop)

          do k = 4, n1+1
             qx%mwa%mp(k+1) = ma%mp(k)*mbj
          enddo
          maxmwa = mbj
          do j = 3, n1
             mbj = ma%mp(j+1)
             if (mbj /= 0) then
                 maxmwa = maxmwa + mbj
                 jm1 = j - 1
                 kl = min(knz, l-jm1)

!                       Major (Inner Loop)

                 do k = 2*j+1, jm1+kl+1
                    qx%mwa%mp(k) = qx%mwa%mp(k) + ma%mp(k-jm1)*mbj
                 enddo
             endif

             if (maxmwa > mmax) then
                 maxmax = max(maxmax, maxmwa)
                 maxmwa = 0
                 jm1 = j - 1
                 kl = min(knz, l-jm1)

!                       Normalization is only required for the range of digits currently
!                       changing in mwa.

                 do kb = jm1+kl, 2*j, -1
                    mkt = int (qx%mwa%mp(kb+1)/qx%mbase)
                    qx%mwa%mp(kb) = qx%mwa%mp(kb) + mkt
                    qx%mwa%mp(kb+1) = qx%mwa%mp(kb+1) - mkt*qx%mbase
                 enddo
             endif
          enddo

!             Double mwa, add the square terms, and perform the final normalization.  (Inner Loop)

          if (2*max(maxmax, maxmwa)+qx%mbase > mmax) then
              do kb = l+1, 5, -1
                 mkt = int (qx%mwa%mp(kb)/qx%mbase)
                 qx%mwa%mp(kb-1) = qx%mwa%mp(kb-1) + mkt
                 qx%mwa%mp(kb) = qx%mwa%mp(kb) - mkt*qx%mbase
              enddo
          endif

          do j = 4, l, 2
             if (j/2 <= n1) then
                 mka = ma%mp(1+j/2)
                 qx%mwa%mp(j) = 2*qx%mwa%mp(j) + mka*mka
                 qx%mwa%mp(j+1) = 2*qx%mwa%mp(j+1)
             else
                 qx%mwa%mp(j) = 2*qx%mwa%mp(j)
                 qx%mwa%mp(j+1) = 2*qx%mwa%mp(j+1)
             endif
          enddo
          if (mod(l, 2) == 1) then
              if ((l+1)/2 <= n1) then
                  mka = ma%mp(1+(l+1)/2)
                  qx%mwa%mp(l+1) = 2*qx%mwa%mp(l+1) + mka*mka
              else
                  qx%mwa%mp(l+1) = 2*qx%mwa%mp(l+1)
              endif
          endif

          do kb = l+1, 4, -1
             mkt = int (qx%mwa%mp(kb)/qx%mbase)
             qx%mwa%mp(kb-1) = qx%mwa%mp(kb-1) + mkt
             qx%mwa%mp(kb) = qx%mwa%mp(kb) - mkt*qx%mbase
          enddo

      else

!             If normalization must be done for each digit, combine the two loops and normalize
!             as the digits are multiplied.

          do j = 2, l
             qx%mwa%mp(j+1) = 0
          enddo
          kj = ma%mp(2) + 2
          do j = 2, n1
             kj = kj - 1
             mbkj = ma%mp(kj+1)
             if (mbkj == 0) cycle
             kl = l - kj + 1
             if (kl > n1) kl = n1
             ki = kl + 2
             kwa = kl+ kj + 1
             mk = 0
             do k = 2, kl
                mt = ma%mp(ki-k+1)*mbkj + qx%mwa%mp(kwa-k+1) + mk
                mk = int (mt/qx%mbase)
                qx%mwa%mp(kwa-k+1) = mt - qx%mbase*mk
             enddo
             qx%mwa%mp(kwa-kl) = mk
          enddo

      endif

!             The multiplication is complete.

      call imsqr4(mb, 1, qx)

      return
      end subroutine imsqr2

      subroutine imsqr3(mb, ndsave, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: mb
      integer :: ndsave
      intent (in) :: ndsave
      intent (inout) :: mb
      type(fm_settings) :: qx

      if (mb%mp(2) <= 1) mb%mp(4) = 0
      mb%mp(1) = 1
      if (qx%ntrace /= 0) call imntr_out1(mb, qx)
      qx%ncall = qx%ncall - 1
      qx%ndig = ndsave

      return
      end subroutine imsqr3

      subroutine imsqr4(mb, kf, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: mb
      integer :: kf
      intent (in) :: kf
      intent (inout) :: mb
      type(fm_settings) :: qx

      if (kf == 1) then
          call fmndig(int(qx%mwa%mp(2)), qx)
          if (qx%ndig < 3) qx%ndig = 3
          call fmmove(qx%mwa, mb, qx)

          if (qx%kflag < 0) then
              qx%namest(qx%ncall) = 'IMSQR'
              call fmwarn(qx)
          endif
      endif

      mb%mp(1) = 1
      qx%ksqr = 0

      return
      end subroutine imsqr4

      subroutine imst2m(string, ma, qx)

!  ma = string

!  Convert a character string to im format.

      use fmvals_parallel
      implicit none

      character :: cmbuff(lmbuff)
      character(*) :: string
      type(multi) :: ma
      intent (in) :: string
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: j, lb, kfsave

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'IMST2M'
      lb = len(string)
      if (lb > lmbuff) then
          write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                              " Raise its size (lmbuff) or change the format being used."
          stop
      endif
      kfsave = qx%kflag

      do j = 1, lb
         cmbuff(j) = string(j:j)
      enddo

      call iminp(cmbuff, ma, 1, lb, qx)

      if (ma%mp(2) <= 1) ma%mp(4) = 0
      if (kfsave /= 0) qx%kflag = kfsave
      qx%ncall = qx%ncall - 1

      return
      end subroutine imst2m

      subroutine imsub(ma, mb, mc, qx)

!  mc = ma - mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mda, mdab, mdb
      integer :: ndsave, result_size

      result_size = max(ma%mp(2), mb%mp(2)) + 4
      if (abs(result_size) >= qx%mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mc, result_size, qx)

      qx%ncall = qx%ncall + 1
      mc%mp(5) = 0
      qx%kflag = 0
      ndsave = qx%ndig
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'IMSUB'
          call imntr_inp2(ma, mb, qx)
      endif

      if (ma%mp(2) <= 2) then
          if (.not. (mb%mp(2) > 2 .or. ma%mp(2) < 0 .or. mb%mp(2) < 0)) then
              if (ma%mp(2) <= 1) then
                  mda = ma%mp(1) * ma%mp(3)
              else
                  mda = ma%mp(1) * (ma%mp(3)*qx%mbase + ma%mp(4))
              endif
              if (mb%mp(2) <= 1) then
                  mdb = mb%mp(1) * mb%mp(3)
              else
                  mdb = mb%mp(1) * (mb%mp(3)*qx%mbase + mb%mp(4))
              endif
              mdab = mda - mdb
              if (abs(mdab) < qx%mbase) then
                  mc%mp(2) = 1
                  if (mdab == 0) mc%mp(2) = 0
                  mc%mp(1) = 1
                  if (mdab < 0) mc%mp(1) = -1
                  mc%mp(3) = abs(mdab)
                  mc%mp(4) = 0
                  if (mda == 0 .or. mdb == 0) qx%kflag = 1
                  call imsub2(mc, ndsave, qx)
                  return
              else if (abs(mdab) < qx%mbase*qx%mbase) then
                  mc%mp(2) = 2
                  mc%mp(1) = 1
                  if (mdab < 0) mc%mp(1) = -1
                  mdab = abs(mdab)
                  mc%mp(3) = aint (mdab/qx%mbase)
                  mc%mp(4) = mdab - qx%mbase*mc%mp(3)
                  if (mda == 0 .or. mdb == 0) qx%kflag = 1
                  call imsub2(mc, ndsave, qx)
                  return
              endif
          endif
      endif

      if (ma%mp(2) < 0 .or. mb%mp(2) < 0 .or.  &
          ma%mp(2) >= qx%mexpov .or. mb%mp(2) >= qx%mexpov) then
          if (ma%mp(2) == qx%munkno .or. mb%mp(2) == qx%munkno) then
              call imunknown(mc, qx)
              qx%kflag = -4
              call imsub2(mc, ndsave, qx)
              return
          endif
          if (ma%mp(2) == qx%mexpov) then
              if (ma%mp(1) == -mb%mp(1) .or. mb%mp(3) == 0) then
                  mc%mp(1) = ma%mp(1)
                  mc%mp(2) = ma%mp(2)
                  mc%mp(3) = ma%mp(3)
                  mc%mp(4) = ma%mp(4)
                  qx%kflag = -5
                  call imsub2(mc, ndsave, qx)
                  return
              else
                  qx%kflag = -4
                  qx%namest(qx%ncall) = 'IMSUB'
                  call fmwarn(qx)
                  call imunknown(mc, qx)
                  call imsub2(mc, ndsave, qx)
                  return
              endif
          endif
          if (mb%mp(2) == qx%mexpov) then
              if (-mb%mp(1) == ma%mp(1) .or. ma%mp(3) == 0) then
                  mc%mp(1) = -mb%mp(1)
                  mc%mp(2) = mb%mp(2)
                  mc%mp(3) = mb%mp(3)
                  mc%mp(4) = mb%mp(4)
                  qx%kflag = -5
                  call imsub2(mc, ndsave, qx)
                  return
              else
                  qx%kflag = -4
                  qx%namest(qx%ncall) = 'IMSUB'
                  call fmwarn(qx)
                  call imunknown(mc, qx)
                  call imsub2(mc, ndsave, qx)
                  return
              endif
          endif
          qx%kflag = -4
          qx%namest(qx%ncall) = 'IMSUB'
          call fmwarn(qx)
          call imunknown(mc, qx)
          call imsub2(mc, ndsave, qx)
          return
      endif

!             imadd3 will negate mb and add.

      qx%ksub = 1
      call imadd3(ma, mb, mc, qx)
      qx%ksub = 0

      call imsub2(mc, ndsave, qx)

      return
      end subroutine imsub

      subroutine imsub2(mc, ndsave, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: mc
      integer :: ndsave
      intent (in) :: ndsave
      intent (inout) :: mc
      type(fm_settings) :: qx

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      if (qx%ntrace /= 0) call imntr_out1(mc, qx)
      qx%ncall = qx%ncall - 1
      qx%ndig = ndsave

      return
      end subroutine imsub2

      subroutine imunknown(ma, qx)

!  Set ma to the im special value for unknown results.

      use fmvals_parallel
      implicit none

      type(multi) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: j

      call fmalloc(ma, 5, qx)
      do j = 4, 5
         ma%mp(j) = 0
      enddo
      ma%mp(1) = 1
      ma%mp(2) = qx%munkno
      ma%mp(3) = 1

      end subroutine imunknown

      subroutine imwrit(kwrite, ma, qx)

!  Write ma on unit kwrite.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  These numbers can then be read easily using imread.

      use fmvals_parallel
      implicit none

      character :: cmbuff(lmbuff)
      integer :: kwrite
      type(multi) :: ma
      intent (in) :: kwrite, ma
      type(fm_settings) :: qx

      integer :: j, k, ksave, l, last, lb, nd, ndsave, nexp

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'IMWRIT'
      ndsave = qx%ndig
      call fmndig(max(3, int(ma%mp(2))), qx)
      if (ma%mp(2) >= qx%mexpov) qx%ndig = 3

      ksave = qx%kflag
      nd = int(real(qx%ndig)*log10(real(qx%mbase))) + 1
      if (nd < 2) nd = 2
      nexp = int(2.0*log10(real(mxbase))) + 16
      lb = nd + nexp
      if (lb > lmbuff) then
          write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                              " Raise its size (lmbuff) or change the format being used."
          stop
      endif

      call imout(ma, cmbuff, lb, qx)

      qx%kflag = ksave
      qx%ndig = ndsave
      last = lb + 1
      do j = 1, lb
         if (cmbuff(last-j) /= ' ' .or. j == lb) then
             l = last - j
             if (mod(l, 73) /= 0) then
                 write (kwrite, "(4X, 73A1, ' &')") (cmbuff(k), k=1, l)
             else
                 if (l > 73) write (kwrite, "(4X, 73A1, ' &')") (cmbuff(k), k=1, l-73)
                 write (kwrite, "(4X, 73A1)") (cmbuff(k), k=l-72, l)
             endif
             qx%ncall = qx%ncall - 1
             return
         endif
      enddo
      qx%ncall = qx%ncall - 1

      return
      end subroutine imwrit

      subroutine imwrite(kwrite, ma, qx)

      use fmvals_parallel
      implicit none

      integer :: kwrite
      type(multi) :: ma
      intent (in) :: kwrite, ma
      type(fm_settings) :: qx

      call imwrit(kwrite, ma, qx)

      return
      end subroutine imwrite


!  The zm routines perform complex multiple-precision arithmetic.


      subroutine zmset(nprec, qx)

!  Set precision to at least nprec significant digits for using zm arithmetic.

      use fmvals_parallel
      implicit none

      integer :: nprec
      intent (in) :: nprec
      type(fm_settings) :: qx

!             Set jformz to ' 1.23 + 4.56 i ' format.

      qx%jformz = 1

!             Set jprntz to print real and imaginary parts on one line whenever possible.

      qx%jprntz = 1

!             Use fmset to initialize the other variables.

      call fmset(nprec, qx)

      return
      end subroutine zmset

      subroutine zm2i2m(integ1, integ2, ma, qx)

!  ma = integ1 + integ2 i

      use fmvals_parallel
      implicit none

      integer :: integ1, integ2
      type(multi) :: ma(2)
      intent (in) :: integ1, integ2
      intent (inout) :: ma
      type(fm_settings) :: qx

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'ZM2I2M'
      if (qx%ntrace /= 0) then
          call fmntr_inpii(integ1, integ2, qx)
      endif

      call fmi2m(integ1, ma(1), qx)
      call fmi2m(integ2, ma(2), qx)

      if (qx%ntrace /= 0) call zmntr_out1(ma, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine zm2i2m

      subroutine zmabs(ma, mbfm, qx)

!  mbfm = abs(ma)

!  Complex absolute value.  The result is a real fm number.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mbfm
      intent (in) :: ma
      intent (inout) :: mbfm
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(3), mresult

      call fmalloc(mbfm, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmabs_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mbfm, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmabs_m1(ma, mxy, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mbfm, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmabs

      subroutine zmabs_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing abs(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mxy(3), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      type(multi) :: mz01(2)

      call zmequ(ma, mz01, ndsave, qx%ndig, qx)

      call fmsqr(mz01(1), mxy(1), qx)
      call fmsqr(mz01(2), mxy(2), qx)
      call fmadd(mxy(1), mxy(2), mxy(3), qx)
      call fmsqrt(mxy(3), mresult, qx)

      return
      end subroutine zmabs_m1

      subroutine zmabs_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = abs(ma).

!  kresult = 1 is returned if a special case gives the value of abs(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMABS    '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (ma(1)%mp(3) == 0) then
          call fmabs(malocal(2), mresult, qx)
          kresult = 1
          return
      else if (ma(2)%mp(3) == 0) then
          call fmabs(malocal(1), mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmabs_sc

      subroutine zmacos(ma, mb, qx)

!  mb = acos(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(4), mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmacos_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmacos_m1(ma, mxy, mresult, ndsave, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmacos

      subroutine zmacos_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing acos(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mxy(4), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: j
      double precision :: xe, ye
      type(multi) :: mz01(2), mz02(2), mz03(2), mz04(2), mz05(2)

      call zmequ(ma, mz04, ndsave, qx%ndig, qx)

      call fmovun_xe(mz04(1), xe, qx)
      call fmovun_xe(mz04(2), ye, qx)
      if ((mz04(1)%mp(3) == 0 .or. xe*2 <= -qx%ndig) .and.  &
          (mz04(2)%mp(3) == 0 .or. ye*2 <= -qx%ndig)) then
          call fmpi(mz01(1), qx)
          qx%ndigpi = 0
          call fmdivi_r1(mz01(1), 2, qx)
          call fmi2m(0, mz01(2), qx)
          call zmsub(mz01, mz04, mresult, qx)
          return
      endif

      call zmi2m(0, mz01, qx)
      call zmi2m(1, mz03, qx)
      call zmsub(mz03, mz04, mz02, qx)
      call zmadd(mz03, mz04, mz05, qx)
      call zmmpy(mz02, mz05, mz03, qx)
      if ((mz03(1)%mp(2) == qx%munkno .and. mz03(1)%mp(5) >= 0) .or.  &
          (mz03(2)%mp(2) == qx%munkno .and. mz03(2)%mp(5) >= 0)) then
          call zmi2m(1, mz03, qx)
          call zmsqr(mz04, mz05, qx)
          call zmsub_r1(mz03, mz05, qx)
      endif
      call zmsqrt(mz03, mz02, qx)
      do j = 1, qx%ndig+2
         mz03(1)%mp(j) = mz02(2)%mp(j)
         mz03(2)%mp(j) = mz02(1)%mp(j)
      enddo
      call fmnegate(mz03(1), qx)

      if ((ma(1)%mp(3) /= 0 .and. mz03(1)%mp(2) == ma(1)%mp(2)     .and.  &
          mz03(1)%mp(1)*mz03(1)%mp(3) == ma(1)%mp(1)*ma(1)%mp(3)) .or.    &
          (ma(2)%mp(3) /= 0 .and. mz03(2)%mp(2) == ma(2)%mp(2)     .and.  &
          mz03(2)%mp(1)*mz03(2)%mp(3) == ma(2)%mp(1)*ma(2)%mp(3)) ) then
          call zmadd(mz04, mz03, mz05, qx)
          call fmsqr(mz05(1), mxy(2), qx)
          call fmsqr(mz05(2), mxy(3), qx)
          call fmadd(mxy(2), mxy(3), mxy(4), qx)
          call fmi2m(1, mxy(1), qx)
          call fmsub_r2(mxy(4), mxy(1), qx)
          if (mxy(1)%mp(2) < 0) then
              call fmndig(qx%ndig - int(mxy(1)%mp(2)), qx)
              if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
              call zmequ_r1(mz04, ndsave, qx%ndig, qx)
              call zmi2m(0, mz01, qx)
              call zmi2m(1, mz03, qx)
              call zmsub(mz03, mz04, mz02, qx)
              call zmadd(mz03, mz04, mz05, qx)
              call zmmpy(mz02, mz05, mz03, qx)
              if ((mz03(1)%mp(2) == qx%munkno .and. mz03(1)%mp(5) >= 0) .or.  &
                  (mz03(2)%mp(2) == qx%munkno .and. mz03(2)%mp(5) >= 0)) then
                  call zmi2m(1, mz03, qx)
                  call zmsqr(mz04, mz05, qx)
                  call zmsub_r1(mz03, mz05, qx)
              endif
              call zmsqrt(mz03, mz02, qx)
              do j = 1, qx%ndig+2
                 mz03(1)%mp(j) = mz02(2)%mp(j)
                 mz03(2)%mp(j) = mz02(1)%mp(j)
              enddo
              call fmnegate(mz03(1), qx)
              call zmadd(mz04, mz03, mz05, qx)
          endif

          call zmln(mz05, mz03, qx)
          do j = 1, qx%ndig+2
             mz01(1)%mp(j) = mz03(2)%mp(j)
             mz01(2)%mp(j) = mz03(1)%mp(j)
          enddo
          call fmnegate(mz01(2), qx)
      else
          call zmsub(mz04, mz03, mz05, qx)
          call fmsqr(mz05(1), mxy(2), qx)
          call fmsqr(mz05(2), mxy(3), qx)
          call fmadd(mxy(2), mxy(3), mxy(4), qx)
          call fmi2m(1, mxy(1), qx)
          call fmsub_r2(mxy(4), mxy(1), qx)
          if (mxy(1)%mp(2) < 0) then
              call fmndig(qx%ndig - int(mxy(1)%mp(2)), qx)
              if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
              call zmequ_r1(mz04, ndsave, qx%ndig, qx)
              call zmi2m(0, mz01, qx)
              call zmi2m(1, mz03, qx)
              call zmsub(mz03, mz04, mz02, qx)
              call zmadd(mz03, mz04, mz05, qx)
              call zmmpy(mz02, mz05, mz03, qx)
              if ((mz03(1)%mp(2) == qx%munkno .and. mz03(1)%mp(5) >= 0) .or.  &
                  (mz03(2)%mp(2) == qx%munkno .and. mz03(2)%mp(5) >= 0)) then
                  call zmi2m(1, mz03, qx)
                  call zmsqr(mz04, mz05, qx)
                  call zmsub_r1(mz03, mz05, qx)
              endif
              call zmsqrt(mz03, mz02, qx)
              do j = 1, qx%ndig+2
                 mz03(1)%mp(j) = mz02(2)%mp(j)
                 mz03(2)%mp(j) = mz02(1)%mp(j)
              enddo
              call fmnegate(mz03(1), qx)
              call zmsub(mz04, mz03, mz05, qx)
          endif

          call zmln(mz05, mz03, qx)
          do j = 1, qx%ndig+2
             mz01(1)%mp(j) = mz03(2)%mp(j)
             mz01(2)%mp(j) = mz03(1)%mp(j)
          enddo
          call fmnegate(mz01(1), qx)
      endif
      call zmeq(mz01, mresult, qx)

      return
      end subroutine zmacos_m1

      subroutine zmacos_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = acos(ma).

!  kresult = 1 is returned if a special case gives the value of acos(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j, krsave
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMACOS   '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call fmpi(mresult(1), qx)
          qx%ndigpi = 0
          call fmdivi_r1(mresult(1), 2, qx)
          call fmi2m(0, mresult(2), qx)
          kresult = 1
          return
      else if (malocal(2)%mp(3) == 0) then
          krsave = qx%krad
          qx%krad = 1
          call fmacos(malocal(1), mresult(1), qx)
          qx%krad = krsave
          if (qx%kflag == 0) then
              call fmi2m(0, mresult(2), qx)
              kresult = 1
              return
          endif
      endif

      return
      end subroutine zmacos_sc

      subroutine zmacosh(ma, mb, qx)

!  mb = acosh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmacosh_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmacosh_m1(ma, mresult, ndsave, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmacosh

      subroutine zmacosh_m1(ma, mresult, ndsave, qx)

!  Method 1 for computing acosh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult
      type(fm_settings) :: qx

      integer :: kl
      double precision :: xe, ye
      type(multi) :: mz01(2), mz02(2), mz03(2), mz04(2), mz05(2)

      call zmequ(ma, mz04, ndsave, qx%ndig, qx)

      kl = 1
      call fmovun_xe(mz04(1), xe, qx)
      call fmovun_xe(mz04(2), ye, qx)
      if ((mz04(1)%mp(3) == 0 .or. xe*4 <= -qx%ndig) .and.  &
          (mz04(2)%mp(3) == 0 .or. ye*4 <= -qx%ndig)) then
          call fmpi(mz02(1), qx)
          qx%ndigpi = 0
          call fmdivi_r1(mz02(1), 2, qx)
          call fmi2m(0, mz02(2), qx)
          call zmsub(mz02, mz04, mz03, qx)
          if (mz04(2)%mp(2) /= qx%mexpun) then
              call zmipwr(mz04, 3, mz02, qx)
              call zmdivi(mz02, 6, mz01, qx)
              call zmsub(mz03, mz01, mz02, qx)
              call fmeq(mz02(1), mz01(2), qx)
              call fmmpyi(mz02(2), -1, mz01(1), qx)
          else
              call fmipwr(mz04(1), 3, mz02(1), qx)
              call fmdivi(mz02(1), 6, mz01(1), qx)
              call fmsub(mz03(1), mz01(1), mz01(2), qx)
              call fmmpyi(mz03(2), -1, mz01(1), qx)
          endif
          if (mz04(2)%mp(1) < 0) then
              mz01(2)%mp(1) = -1
              call fmnegate(mz01(1), qx)
          endif
          kl = 0
      endif

      if (kl == 1) then
          call zmi2m(1, mz03, qx)
          call zmadd(mz04, mz03, mz05, qx)
          call zmsqrt(mz05, mz02, qx)
          call zmsub(mz04, mz03, mz05, qx)
          call zmsqrt(mz05, mz01, qx)
          call zmmpy(mz01, mz02, mz05, qx)
          call zmadd(mz04, mz05, mz02, qx)
          call zmln(mz02, mz01, qx)
      endif

      if (ma(2)%mp(3) == 0 .and. xe <= 0) then
          call fmi2m(0, mz01(1), qx)
      endif
      if ((mz01(1)%mp(2) == qx%munkno .and. mz01(1)%mp(5) >= 0) .or.  &
          (mz01(2)%mp(2) == qx%munkno .and. mz01(2)%mp(5) >= 0)) then
          call fmndig(qx%ndig + qx%ngrd22, qx)
          call zmequ(ma, mz01, ndsave, qx%ndig, qx)
          call zmacos(mz01, mz02, qx)
          call zm2i2m(0, 1, mz03, qx)
          mz03(2)%mp(1) = ma(2)%mp(1)
          call zmmpy(mz03, mz02, mz01, qx)
          call zmequ_r1(mz01, qx%ndig, qx%ndig-qx%ngrd22, qx)
      endif

      call zmeq(mz01, mresult, qx)

      return
      end subroutine zmacosh_m1

      subroutine zmacosh_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = acosh(ma).

!  kresult = 1 is returned if a special case gives the value of acosh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMACOSH  '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call fmpi(mresult(2), qx)
          qx%ndigpi = 0
          call fmdivi_r1(mresult(2), 2, qx)
          call fmi2m(0, mresult(1), qx)
          kresult = 1
          return
      else if (malocal(2)%mp(3) == 0) then
          call fmacosh(malocal(1), mresult(1), qx)
          if (qx%kflag == 0) then
              call fmi2m(0, mresult(2), qx)
              kresult = 1
              return
          endif
      endif

      return
      end subroutine zmacosh_sc

      subroutine zmadd(ma, mb, mc, qx)

!  mc = ma + mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: kf1, kfi, kfr, kovun, kwrnsv, ntrsav
      double precision :: xe, ye

      call zmalloc(mc, qx%ndig+2, qx)
      ntrsav = qx%ntrace
      qx%ncall = qx%ncall + 1
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'ZMADD'
          call zmntr_inp2(ma, mb, qx)
      endif
      qx%ntrace = 0
      kovun = 0
      if (ma(1)%mp(2) == qx%mexpov .or. ma(1)%mp(2) == qx%mexpun) kovun = 1
      if (ma(2)%mp(2) == qx%mexpov .or. ma(2)%mp(2) == qx%mexpun) kovun = 1
      if (mb(1)%mp(2) == qx%mexpov .or. mb(1)%mp(2) == qx%mexpun) kovun = 1
      if (mb(2)%mp(2) == qx%mexpov .or. mb(2)%mp(2) == qx%mexpun) kovun = 1
      if (ma(1)%mp(2) == qx%munkno .or. ma(2)%mp(2) == qx%munkno) kovun = 2
      if (mb(1)%mp(2) == qx%munkno .or. mb(2)%mp(2) == qx%munkno) kovun = 2

!             Force fmadd to use more guard digits for user calls.

      qx%ncall = qx%ncall - 1

      kwrnsv = qx%kwarn
      qx%kwarn = 0

      call fmadd(ma(1), mb(1), mc(1), qx)
      kf1 = qx%kflag
      call fmadd(ma(2), mb(2), mc(2), qx)

      qx%ncall = qx%ncall + 1
      if (ntrsav /= 0) then
          qx%ntrace = ntrsav
          qx%namest(qx%ncall) = 'ZMADD'
      endif
      qx%kwarn = kwrnsv
      if (qx%kflag == 1) qx%kflag = kf1
      if (qx%kflag == 1) then
          qx%kflag = 0
          if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
              qx%kflag = 1
          else if (mb(1)%mp(3) == 0 .and. mb(2)%mp(3) == 0) then
              qx%kflag = 1
          else if (ma(1)%mp(3) == 0 .and. mb(1)%mp(3) == 0) then
              qx%kflag = 1
          else if (ma(2)%mp(3) == 0 .and. mb(2)%mp(3) == 0) then
              qx%kflag = 1
          else
              if (ma(1)%mp(3) == 0) then
                  kfr = 1
              else if (mb(1)%mp(3) == 0) then
                  kfr = 2
              else
                  call fmovun_xe(ma(1), xe, qx)
                  call fmovun_xe(mb(1), ye, qx)
                  kfr = 2
                  if (xe < ye) kfr = 1
              endif
              if (ma(2)%mp(3) == 0) then
                  kfi = 1
              else if (mb(2)%mp(3) == 0) then
                  kfi = 2
              else
                  call fmovun_xe(ma(2), xe, qx)
                  call fmovun_xe(mb(2), ye, qx)
                  kfi = 2
                  if (xe < ye) kfi = 1
              endif
              if (kfr == kfi) qx%kflag = 1
          endif
      endif

      if (mc(1)%mp(2) == qx%munkno .or. mc(2)%mp(2) == qx%munkno) then
          if (qx%kflag /= 1) qx%kflag = -4
      else if (mc(1)%mp(2) == qx%mexpov .or. mc(2)%mp(2) == qx%mexpov) then
          if (qx%kflag /= 1) qx%kflag = -5
      else if (mc(1)%mp(2) == qx%mexpun .or. mc(2)%mp(2) == qx%mexpun) then
          if (qx%kflag /= 1) qx%kflag = -6
      endif
      if ((mc(1)%mp(2) == qx%munkno .and. kovun /= 2) .or.  &
          (mc(2)%mp(2) == qx%munkno .and. kovun /= 2) .or.  &
          (mc(1)%mp(2) == qx%mexpun .and. kovun == 0) .or.  &
          (mc(2)%mp(2) == qx%mexpun .and. kovun == 0) .or.  &
          (mc(1)%mp(2) == qx%mexpov .and. kovun == 0) .or.  &
          (mc(2)%mp(2) == qx%mexpov .and. kovun == 0)) then
          qx%namest(qx%ncall) = 'ZMADD'
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) then
          call zmntr_out1(mc, qx)
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine zmadd

      subroutine zmadd_r1(ma, mb, qx)

!  ma = ma + mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (inout) :: ma
      intent (in) :: mb
      type(fm_settings) :: qx

      integer :: k
      type(multi) :: mt(2)

      call zmadd(ma, mb, mt, qx)
      k = qx%kflag
      call zmeq(mt, ma, qx)
      qx%kflag = k

      end subroutine zmadd_r1

      subroutine zmadd_r2(ma, mb, qx)

!  mb = ma + mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      integer :: k
      type(multi) :: mt(2)

      call zmadd(ma, mb, mt, qx)
      k = qx%kflag
      call zmeq(mt, mb, qx)
      qx%kflag = k

      end subroutine zmadd_r2

      subroutine zmaddi(ma, integ, qx)

!  ma = ma + integ        Increment by one-word (real) integer.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2)
      integer :: integ
      intent (inout) :: ma
      intent (in) :: integ
      type(fm_settings) :: qx

      integer :: kovun, kwrnsv, ntrsav


      qx%ncall = qx%ncall + 1
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'ZMADDI'
          call zmntr_inp1i(ma, integ, qx)
      endif
      kovun = 0
      if (ma(1)%mp(2) == qx%mexpov .or. ma(1)%mp(2) == qx%mexpun) kovun = 1
      if (ma(2)%mp(2) == qx%mexpov .or. ma(2)%mp(2) == qx%mexpun) kovun = 1
      if (ma(1)%mp(2) == qx%munkno .or. ma(2)%mp(2) == qx%munkno) kovun = 2

!             Force fmaddi to use more guard digits for user calls.

      qx%ncall = qx%ncall - 1
      ntrsav = qx%ntrace
      qx%ntrace = 0
      kwrnsv = qx%kwarn
      qx%kwarn = 0

      call fmaddi(ma(1), integ, qx)

      qx%ntrace = ntrsav
      qx%kwarn = kwrnsv
      qx%ncall = qx%ncall + 1
      if (qx%ntrace /= 0) qx%namest(qx%ncall) = 'ZMADDI'
      if (ma(1)%mp(2) == qx%munkno .or. ma(2)%mp(2) == qx%munkno) then
          qx%kflag = -4
      else if (ma(1)%mp(2) == qx%mexpov .or. ma(2)%mp(2) == qx%mexpov) then
          if (qx%kflag /= 1) qx%kflag = -5
      else if (ma(1)%mp(2) == qx%mexpun .or. ma(2)%mp(2) == qx%mexpun) then
          if (qx%kflag /= 1) qx%kflag = -6
      endif
      if ((ma(1)%mp(2) == qx%munkno .and. kovun /= 2) .or.  &
          (ma(2)%mp(2) == qx%munkno .and. kovun /= 2) .or.  &
          (ma(1)%mp(2) == qx%mexpun .and. kovun == 0) .or.  &
          (ma(2)%mp(2) == qx%mexpun .and. kovun == 0) .or.  &
          (ma(1)%mp(2) == qx%mexpov .and. kovun == 0) .or.  &
          (ma(2)%mp(2) == qx%mexpov .and. kovun == 0)) then
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) call zmntr_out1(ma, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine zmaddi

      subroutine zmalloc(ma, n_size, qx)

!  Allocate zm number ma with size n_size.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2)
      integer :: n_size
      intent (in) :: n_size
      intent (inout) :: ma
      type(fm_settings) :: qx

      if (.not. allocated(ma(1)%mp)) then
          allocate(ma(1)%mp(max(n_size, 5)), stat=qx%k_stat)
          if (qx%k_stat /= 0) call fmdefine_error
      else if (size(ma(1)%mp) < max(n_size, 5)) then
          deallocate(ma(1)%mp)
          allocate(ma(1)%mp(max(n_size, 5)), stat=qx%k_stat)
          if (qx%k_stat /= 0) call fmdefine_error
      endif

      if (.not. allocated(ma(2)%mp)) then
          allocate(ma(2)%mp(max(n_size, 5)), stat=qx%k_stat)
          if (qx%k_stat /= 0) call fmdefine_error
      else if (size(ma(2)%mp) < max(n_size, 5)) then
          deallocate(ma(2)%mp)
          allocate(ma(2)%mp(max(n_size, 5)), stat=qx%k_stat)
          if (qx%k_stat /= 0) call fmdefine_error
      endif

      return
      end subroutine zmalloc

      subroutine zmarg(ma, mbfm, qx)

!  mbfm = arg(ma)

!  Complex argument.  The result is a real fm number.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mbfm
      intent (in) :: ma
      intent (inout) :: mbfm
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mresult

      call fmalloc(mbfm, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmarg_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call fmexit1(mresult, mbfm, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmarg_m1(ma, mresult, ndsave, qx)
         call fmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call fmexit1(mresult, mbfm, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmarg

      subroutine zmarg_m1(ma, mresult, ndsave, qx)

!  Method 1 for computing arg(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult
      type(fm_settings) :: qx

      type(multi) :: mz01(2)

      call zmequ(ma, mz01, ndsave, qx%ndig, qx)

      call fmatn2(mz01(2), mz01(1), mresult, qx)

      return
      end subroutine zmarg_m1

      subroutine zmarg_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = arg(ma).

!  kresult = 1 is returned if a special case gives the value of arg(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      double precision :: ar, b, x, xe, xf, y, ye, yf, ze, zf
      type(multi) :: malocal(2), mz01(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMARG    '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call fmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (malocal(2)%mp(3) == 0 .and. malocal(1)%mp(1) > 0) then
          call fmi2m(0, mresult, qx)
      else if (malocal(2)%mp(3) == 0 .and. malocal(1)%mp(1) < 0) then
          if (qx%krad == 1) then
              call fmpi(mresult, qx)
              qx%ndigpi = 0
          else
              call fmi2m(180, mresult, qx)
          endif
      else if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(1) > 0) then
          if (qx%krad == 1) then
              call fmpi(mresult, qx)
              qx%ndigpi = 0
              call fmdivi_r1(mresult, 2, qx)
          else
              call fmi2m(90, mresult, qx)
          endif
      else if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(1) < 0) then
          if (qx%krad == 1) then
              call fmpi(mresult, qx)
              qx%ndigpi = 0
              call fmdivi_r1(mresult, -2, qx)
          else
              call fmi2m(-90, mresult, qx)
          endif
      else if (abs(malocal(1)%mp(2)) >= qx%mexpov .or.  &
               abs(malocal(2)%mp(2)) >= qx%mexpov) then
          call fmunknown(mresult, qx)
          call fmovun_xexf(malocal(1), xe, xf, qx)
          call fmovun_xexf(malocal(2), ye, yf, qx)
          ze = min(xe, ye)
          zf = 1 - epsilon(1.0d0)
          xe = xe - ze
          ye = ye - ze
          call fmdp2m(huge(ze)/1.0d+10, mz01(1), qx)
          call fmovun_xe(mz01(1), ze, qx)
          if (xe > ze .and. malocal(1)%mp(1) > 0) then
              call fmdiv(malocal(2), malocal(1), mz01(2), qx)
              call fmovun_xexf(mz01(2), ze, zf, qx)
          else
              if (xe > ze) xe = ze
              if (ye > ze) ye = ze
              b = qx%mbase
              x = b**xe * xf * malocal(1)%mp(1)
              y = b**ye * yf * malocal(2)%mp(1)
              ar = atan2(y, x)
              if (ar < 0) mresult%mp(1) = -1
              ar = abs(ar)
              if (ar >= 1) then
                  ze = 0
                  do while (ar >= 1)
                     ze = ze + 1
                     ar = ar / b
                     zf = ar
                  enddo
              else
                  ze = 1
                  do while (ar < 1)
                     ze = ze - 1
                     zf = ar
                     ar = ar * b
                  enddo
              endif
          endif
          mresult%mp(4) = ze
          mresult%mp(5) = -zf*maxint
          if (malocal(2)%mp(1) < 0) mresult%mp(1) = -1
          qx%kflag = -4
          return
      endif

      return
      end subroutine zmarg_sc

      subroutine zmasin(ma, mb, qx)

!  mb = asin(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(4), mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmasin_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmasin_m1(ma, mxy, mresult, ndsave, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmasin

      subroutine zmasin_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing asin(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mxy(4), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: mz01(2), mz02(2), mz03(2), mz04(2), mz05(2)

      call zmequ(ma, mz04, ndsave, qx%ndig, qx)

      call zmi2m(0, mz01, qx)
      call zmi2m(1, mz03, qx)
      call zmsub(mz03, mz04, mz02, qx)
      call zmadd(mz03, mz04, mz05, qx)
      call zmmpy(mz02, mz05, mz03, qx)
      if ((mz03(1)%mp(2) == qx%munkno .and. mz03(1)%mp(5) >= 0) .or.  &
          (mz03(2)%mp(2) == qx%munkno .and. mz03(2)%mp(5) >= 0)) then
          call zmi2m(1, mz03, qx)
          call zmsqr(mz04, mz05, qx)
          call zmsub_r1(mz03, mz05, qx)
      endif
      call zmsqrt(mz03, mz02, qx)
      do j = 1, qx%ndig+2
         mz03(1)%mp(j) = mz04(2)%mp(j)
         mz03(2)%mp(j) = mz04(1)%mp(j)
      enddo
      call fmnegate(mz03(1), qx)

      if ((mz02(1)%mp(3) /= 0 .and.                                          &
           mz03(1)%mp(2) == mz02(1)%mp(2) .and.                              &
           mz03(1)%mp(1)*mz03(1)%mp(3) == mz02(1)%mp(1)*mz02(1)%mp(3)) .or.  &
          (mz02(2)%mp(3) /= 0 .and. mz03(2)%mp(2) == mz02(2)%mp(2) .and.     &
           mz03(2)%mp(1)*mz03(2)%mp(3) == mz02(2)%mp(1)*mz02(2)%mp(3)) ) then
          call zmadd(mz02, mz03, mz05, qx)
          call fmsqr(mz05(1), mxy(2), qx)
          call fmsqr(mz05(2), mxy(3), qx)
          call fmadd(mxy(2), mxy(3), mxy(4), qx)
          call fmi2m(1, mxy(1), qx)
          call fmsub_r2(mxy(4), mxy(1), qx)
          if (mxy(1)%mp(2) < 0) then
              call fmndig(qx%ndig - int(mxy(1)%mp(2)), qx)
              if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
              call zmequ_r1(mz04, ndsave, qx%ndig, qx)
              call zmi2m(0, mz01, qx)
              call zmi2m(1, mz03, qx)
              call zmsub(mz03, mz04, mz02, qx)
              call zmadd(mz03, mz04, mz05, qx)
              call zmmpy(mz02, mz05, mz03, qx)
              call zmsqrt(mz03, mz02, qx)
              do j = 1, qx%ndig+2
                 mz03(1)%mp(j) = mz04(2)%mp(j)
                 mz03(2)%mp(j) = mz04(1)%mp(j)
              enddo
              call fmnegate(mz03(1), qx)
              call zmadd(mz02, mz03, mz05, qx)
          endif

          call zmln(mz05, mz03, qx)
          do j = 1, qx%ndig+2
             mz01(1)%mp(j) = mz03(2)%mp(j)
             mz01(2)%mp(j) = mz03(1)%mp(j)
          enddo
          call fmnegate(mz01(2), qx)
      else
          call zmsub(mz02, mz03, mz05, qx)
          call fmsqr(mz05(1), mxy(2), qx)
          call fmsqr(mz05(2), mxy(3), qx)
          call fmadd(mxy(2), mxy(3), mxy(4), qx)
          call fmi2m(1, mxy(1), qx)
          call fmsub_r2(mxy(4), mxy(1), qx)
          if (mxy(1)%mp(2) < 0) then
              call fmndig(qx%ndig - int(mxy(1)%mp(2)), qx)
              if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
              call zmequ_r1(mz04, ndsave, qx%ndig, qx)
              call zmi2m(0, mz01, qx)
              call zmi2m(1, mz03, qx)
              call zmsub(mz03, mz04, mz02, qx)
              call zmadd(mz03, mz04, mz05, qx)
              call zmmpy(mz02, mz05, mz03, qx)
              if ((mz03(1)%mp(2) == qx%munkno .and. mz03(1)%mp(5) >= 0) .or.  &
                  (mz03(2)%mp(2) == qx%munkno .and. mz03(2)%mp(5) >= 0)) then
                  call zmi2m(1, mz03, qx)
                  call zmsqr(mz04, mz05, qx)
                  call zmsub_r1(mz03, mz05, qx)
              endif
              call zmsqrt(mz03, mz02, qx)
              do j = 1, qx%ndig+2
                 mz03(1)%mp(j) = mz04(2)%mp(j)
                 mz03(2)%mp(j) = mz04(1)%mp(j)
              enddo
              call fmnegate(mz03(1), qx)
              call zmsub(mz02, mz03, mz05, qx)
          endif
          call zmln(mz05, mz03, qx)
          do j = 1, qx%ndig+2
             mz01(1)%mp(j) = mz03(2)%mp(j)
             mz01(2)%mp(j) = mz03(1)%mp(j)
          enddo
          call fmnegate(mz01(1), qx)
      endif

      call zmeq(mz01, mresult, qx)

      return
      end subroutine zmasin_m1

      subroutine zmasin_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = asin(ma).

!  kresult = 1 is returned if a special case gives the value of asin(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      double precision :: xe, ye
      integer :: j, krsave
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMASIN   '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      call fmovun_xe(ma(1), xe, qx)
      call fmovun_xe(ma(2), ye, qx)
      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
          call zmi2m(0, mresult, qx)
          kresult = 1
          return
      else if ((ma(1)%mp(3) == 0 .or. xe*2 <= -ndsave) .and.  &
               (ma(2)%mp(3) == 0 .or. ye*2 <= -ndsave)) then
          call zmeq(malocal, mresult, qx)
          kresult = 1
          return
      else if (ma(2)%mp(3) == 0) then
          krsave = qx%krad
          qx%krad = 1
          call fmasin(malocal(1), mresult(1), qx)
          qx%krad = krsave
          if (qx%kflag == 0) then
              call fmi2m(0, mresult(2), qx)
              kresult = 1
              return
          endif
      endif

      return
      end subroutine zmasin_sc

      subroutine zmasinh(ma, mb, qx)

!  mb = asinh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmasinh_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmasinh_m1(ma, mresult, ndsave, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmasinh

      subroutine zmasinh_m1(ma, mresult, ndsave, qx)

!  Method 1 for computing asinh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult
      type(fm_settings) :: qx

      double precision :: b, xe, xf, ye, yf
      integer :: j, ndsav2
      type(multi) :: mz01(2), mz02(2), mz03(2), mz04(2), mz05(2)

      call zmequ(ma, mz04, ndsave, qx%ndig, qx)


      ndsav2 = qx%ndig
      do j = 1, 5
         call zmi2m(1, mz03, qx)
         call zmsqr(mz04, mz02, qx)
         call zmadd(mz03, mz02, mz05, qx)
         call zmsqrt(mz05, mz02, qx)
         call zmadd(mz02, mz04, mz05, qx)
         if (mz05(1)%mp(3) == 0 .and. mz05(1)%mp(5) >= 0 .and.  &
             mz05(2)%mp(3) == 0 .and. mz05(2)%mp(5) >= 0) then
             if (j < 5) then
                 call fmndig(2*qx%ndig, qx)
                 call zmequ_r1(mz04, qx%ndig/2, qx%ndig, qx)
                 cycle
             else
                 call fmndig(ndsav2, qx)
                 call zmunknown(mz01, qx)
                 exit
             endif
         endif
         if ((mz05(1)%mp(2) == qx%munkno .and. mz05(1)%mp(5) >= 0) .or.  &
             (mz05(2)%mp(2) == qx%munkno .and. mz05(2)%mp(5) >= 0)) then
             call fmndig(ndsav2, qx)
             call zmunknown(mz01, qx)
             exit
         endif
         call fmovun_xexf(mz02(1), xe, xf, qx)
         call fmovun_xexf(mz04(1), ye, yf, qx)
         if (xe < ye) then
             xe = ye
             xf = yf
         endif
         call fmovun_xexf(mz05(1), ye, yf, qx)
         b = qx%mbase
         if (log(xf) - (ye-xe+qx%ndig-ndsav2)*log(b) - log(yf) >= 5*log(10.0d0)) then
             if (mz05(1)%mp(5) < 0) then
                 call fmndig(ndsav2, qx)
                 call zmunknown(mz01, qx)
                 exit
             else
                 call fmndig(2*qx%ndig, qx)
                 call zmequ_r1(mz04, qx%ndig/2, qx%ndig, qx)
                 cycle
             endif
         endif
         call fmovun_xexf(mz02(2), xe, xf, qx)
         call fmovun_xexf(mz04(2), ye, yf, qx)
         if (xe < ye) then
             xe = ye
             xf = yf
         endif
         call fmovun_xexf(mz05(2), ye, yf, qx)
         if (log(xf) - (ye-xe+qx%ndig-ndsav2)*log(b) - log(yf) >= 5*log(10.0d0)) then
             if (mz05(1)%mp(5) < 0) then
                 call fmndig(ndsav2, qx)
                 call zmunknown(mz01, qx)
                 exit
             else
                 call fmndig(2*qx%ndig, qx)
                 call zmequ_r1(mz04, qx%ndig/2, qx%ndig, qx)
                 cycle
             endif
         endif
         call zmln(mz05, mz01, qx)
         call zmequ_r1(mz01, qx%ndig, ndsav2, qx)
         call fmndig(ndsav2, qx)
         if (j < 5) exit
      enddo

      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(2) <= 0) then
          call fmi2m(0, mz01(1), qx)
      endif

      call zmeq(mz01, mresult, qx)

      return
      end subroutine zmasinh_m1

      subroutine zmasinh_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = asinh(ma).

!  kresult = 1 is returned if a special case gives the value of asinh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      double precision :: xe, ye
      integer :: j
      type(multi) :: mz02(2), mz03(2), malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMASINH  '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      call fmovun_xe(malocal(1), xe, qx)
      call fmovun_xe(malocal(2), ye, qx)
      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
          call zmi2m(0, mresult, qx)
          kresult = 1
          return
      else if ((ma(1)%mp(3) == 0 .or. xe*2 <= -ndsave) .and.  &
               (ma(2)%mp(3) == 0 .or. ye*2 <= -ndsave)) then
          if (qx%kround == 1) then
              call zmeq(malocal, mresult, qx)
          else
              call zmipwr(malocal, 3, mz03, qx)
              call zmdivi(mz03, 6, mz02, qx)
              call zmsub(malocal, mz02, mresult, qx)
          endif
          kresult = 1
          return
      else if (ma(2)%mp(3) == 0) then
          call fmasinh(malocal(1), mresult(1), qx)
          if (qx%kflag == 0) then
              call fmi2m(0, mresult(2), qx)
              kresult = 1
              return
          endif
      endif

      return
      end subroutine zmasinh_sc

      subroutine zmatan(ma, mb, qx)

!  mb = atan(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(5), mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmatan_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmatan_m1(ma, mxy, mresult, ndsave, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmatan

      subroutine zmatan_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing atan(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mxy(5), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: j, jterm
      double precision :: x, xe, ye
      type(multi) :: mz01(2), mz02(2), mz03(2), mz04(2), mz05(2)
      logical, external :: fmcomp

      call zmequ(ma, mz04, ndsave, qx%ndig, qx)

      call fmovun_xe(mz04(1), xe, qx)
      call fmovun_xe(mz04(2), ye, qx)
      x = 1.0e+5
      call fmdpm(x, mxy(1), qx)
      call fmabs(mz04(1), mxy(2), qx)
      call fmabs(mz04(2), mxy(3), qx)
      call fmadd_r2(mxy(2), mxy(3), qx)

      if (fmcomp(mxy(3), '>=', mxy(1), qx)) then
          call zmi2m(0, mz03, qx)
          call fmpi(mz03(1), qx)
          qx%ndigpi = 0
          call fmdivi_r1(mz03(1), 2, qx)
          if (ma(1)%mp(1) < 0) call fmnegate(mz03(1), qx)
          call zmi2m(1, mz01, qx)
          call zmdiv(mz01, mz04, mz05, qx)
          call zmeq(mz05, mz02, qx)
          call zmsub(mz03, mz05, mz01, qx)
          call zmeq(mz01, mz03, qx)
          if (xe > qx%ndig .or. ye > qx%ndig) then
              call zmeq(mz03, mresult, qx)
              return
          endif
          call zmsqr(mz05, mz01, qx)
          jterm = 1
          do
             call zmmpy(mz02, mz01, mz05, qx)
             call zmeq(mz05, mz02, qx)
             jterm = jterm + 2
             call fmeq(mz02(1), mxy(4), qx)
             call fmeq(mz02(2), mxy(5), qx)
             call zmdivi(mz02, jterm, mz05, qx)
             call zmeq(mz05, mz02, qx)
             call zmadd(mz03, mz02, mz05, qx)
             call zmeq(mz05, mz03, qx)
             if (qx%kflag /= 0) then
                 call zmeq(mz03, mresult, qx)
                 return
             endif
             call fmeq(mxy(4), mz02(1), qx)
             call fmeq(mxy(5), mz02(2), qx)
             call zmmpy(mz02, mz01, mz05, qx)
             call zmeq(mz05, mz02, qx)
             jterm = jterm + 2
             call fmeq(mz02(1), mxy(4), qx)
             call fmeq(mz02(2), mxy(5), qx)
             call zmdivi(mz02, jterm, mz05, qx)
             call zmeq(mz05, mz02, qx)
             call zmsub(mz03, mz02, mz05, qx)
             call zmeq(mz05, mz03, qx)
             if (qx%kflag /= 0) then
                 call zmeq(mz03, mresult, qx)
                 return
             endif
             call fmeq(mxy(4), mz02(1), qx)
             call fmeq(mxy(5), mz02(2), qx)
          enddo
      else
          call zm2i2m(0, 1, mz01, qx)
          call zmsub(mz01, mz04, mz03, qx)
          call zmadd(mz01, mz04, mz05, qx)
          call zmdiv(mz05, mz03, mz02, qx)
          call fmsqr(mz02(1), mxy(3), qx)
          call fmsqr(mz02(2), mxy(4), qx)
          call fmadd(mxy(3), mxy(4), mxy(5), qx)
          call fmi2m(1, mxy(2), qx)
          call fmsub_r2(mxy(5), mxy(2), qx)
          call fmovun_xe(mxy(2), xe, qx)
          if (xe < 0) then
              call fmndig(qx%ndig - int(mxy(2)%mp(2)), qx)
              if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
              call zmequ_r1(mz04, ndsave, qx%ndig, qx)
              call zm2i2m(0, 1, mz01, qx)
              call zmsub(mz01, mz04, mz03, qx)
              call zmadd(mz01, mz04, mz05, qx)
              call zmdiv(mz05, mz03, mz02, qx)
          endif
          call zmln(mz02, mz05, qx)
          call zmdivi(mz05, 2, mz02, qx)
          do j = 1, qx%ndig+2
             mz03(1)%mp(j) = mz02(2)%mp(j)
             mz03(2)%mp(j) = mz02(1)%mp(j)
          enddo
          call fmnegate(mz03(1), qx)
      endif

      call zmeq(mz03, mresult, qx)

      return
      end subroutine zmatan_m1

      subroutine zmatan_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = atan(ma).

!  kresult = 1 is returned if a special case gives the value of atan(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      double precision :: xe, ye
      integer :: j, krsave
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMATAN   '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif
      call fmovun_xe(malocal(1), xe, qx)
      call fmovun_xe(malocal(2), ye, qx)
      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
          call zmi2m(0, mresult, qx)
          kresult = 1
          return
      else if ((ma(1)%mp(3) == 0 .or. xe*2 <= -ndsave) .and.  &
               (ma(2)%mp(3) == 0 .or. ye*2 <= -ndsave)) then
          call zmeq(malocal, mresult, qx)
          kresult = 1
          return
      else if (ma(2)%mp(3) == 0) then
          krsave = qx%krad
          qx%krad = 1
          call fmatan(malocal(1), mresult(1), qx)
          qx%krad = krsave
          if (qx%kflag == 0) then
              call fmi2m(0, mresult(2), qx)
              kresult = 1
              return
          endif
      endif

      return
      end subroutine zmatan_sc

      subroutine zmatanh(ma, mb, qx)

!  mb = atanh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(5), mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmatanh_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmatanh_m1(ma, mxy, mresult, ndsave, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmatanh

      subroutine zmatanh_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing atanh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mxy(5), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: jterm
      double precision :: xe, ye
      type(multi) :: mz01(2), mz02(2), mz03(2), mz04(2), mz05(2), mz06(2)
      logical, external :: fmcomp

      call zmequ(ma, mz04, ndsave, qx%ndig, qx)

      call fmdpm(1.0d+5, mxy(1), qx)
      call fmabs(mz04(1), mxy(2), qx)
      call fmabs(mz04(2), mxy(3), qx)
      call fmadd_r2(mxy(2), mxy(3), qx)

      if (fmcomp(mxy(3), '>=', mxy(1), qx)) then
          call zmi2m(0, mz03, qx)
          call fmpi(mz03(2), qx)
          qx%ndigpi = 0
          if (ma(2)%mp(1) > 0) then
              call fmdivi_r1(mz03(2), 2, qx)
          else
              call fmdivi_r1(mz03(2), -2, qx)
          endif
          if (ma(1)%mp(1) < 0) call fmnegate(mz03(1), qx)
          call zmi2m(1, mz01, qx)
          call zmdiv(mz01, mz04, mz05, qx)
          call zmeq(mz05, mz02, qx)
          call zmadd(mz03, mz05, mz01, qx)
          call zmeq(mz01, mz03, qx)
          call fmovun_xe(ma(1), xe, qx)
          call fmovun_xe(ma(2), ye, qx)
          if (xe > qx%ndig .or. ye > qx%ndig) then
              if (ma(2)%mp(3) == 0 .and. xe >= 1) mz03(2)%mp(1) = -ma(1)%mp(1)
              if (ma(1)%mp(3) == 0) call fmi2m(0, mz03(1), qx)
              call zmeq(mz03, mresult, qx)
              return
          endif
          call zmsqr(mz05, mz01, qx)
          jterm = 1
          do
             call zmmpy(mz02, mz01, mz05, qx)
             call zmeq(mz05, mz02, qx)
             jterm = jterm + 2
             call zmdivi(mz02, jterm, mz06, qx)
             call zmadd(mz03, mz06, mz05, qx)
             call zmeq(mz05, mz03, qx)
             if (qx%kflag /= 0) then
                 if (ma(2)%mp(3) == 0 .and. xe >= 1) mz03(2)%mp(1) = -ma(1)%mp(1)
                 if (ma(1)%mp(3) == 0) call fmi2m(0, mz03(1), qx)
                 call zmeq(mz03, mresult, qx)
                 return
             endif
          enddo
      else
          call zmi2m(0, mz03, qx)
          call zmi2m(1, mz01, qx)
          call zmsub(mz01, mz04, mz02, qx)
          call zmadd(mz01, mz04, mz05, qx)
          call zmdiv(mz05, mz02, mz03, qx)
          call fmsqr(mz03(1), mxy(3), qx)
          call fmsqr(mz03(2), mxy(4), qx)
          call fmadd(mxy(3), mxy(4), mxy(5), qx)
          call fmi2m(1, mxy(2), qx)
          call fmsub_r2(mxy(5), mxy(2), qx)
          call fmovun_xe(mxy(2), xe, qx)
          if (xe < 0) then
              call fmndig(qx%ndig - int(mxy(2)%mp(2)), qx)
              if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
              call zmequ_r1(mz04, ndsave, qx%ndig, qx)
              call zmi2m(1, mz01, qx)
              call zmsub(mz01, mz04, mz02, qx)
              call zmadd(mz01, mz04, mz05, qx)
              call zmdiv(mz05, mz02, mz03, qx)
          endif
          call zmln(mz03, mz05, qx)
          call zmdivi(mz05, 2, mz03, qx)
      endif

      call fmovun_xe(ma(1), xe, qx)
      if (ma(2)%mp(3) == 0 .and. xe >= 1) then
          mz03(2)%mp(1) = -ma(1)%mp(1)
      endif
      if (ma(1)%mp(3) == 0) then
          call fmi2m(0, mz03(1), qx)
      endif

      call zmeq(mz03, mresult, qx)

      return
      end subroutine zmatanh_m1

      subroutine zmatanh_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = atanh(ma).

!  kresult = 1 is returned if a special case gives the value of atanh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      double precision :: xe, ye
      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMATANH  '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      call fmovun_xe(malocal(1), xe, qx)
      call fmovun_xe(malocal(2), ye, qx)
      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
          call zmi2m(0, mresult, qx)
          kresult = 1
          return
      else if ((ma(1)%mp(3) == 0 .or. xe*2 <= -ndsave) .and.  &
               (ma(2)%mp(3) == 0 .or. ye*2 <= -ndsave)) then
          call zmeq(malocal, mresult, qx)
          kresult = 1
          return
      else if (ma(2)%mp(3) == 0 .and. ye <= 0) then
          call fmatanh(malocal(1), mresult(1), qx)
          if (qx%kflag == 0) then
              call fmi2m(0, mresult(2), qx)
              kresult = 1
              return
          endif
      endif

      return
      end subroutine zmatanh_sc

      subroutine zmcheck_accuracy(ma, ndsave, retry, qx)

!  Internal routine used by routines that need to check for rounding accuracy.

!  Return retry = .true. if we need to try again with more guard digits because the current
!  guard digits in ma are too close to 1/2 ulp.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2)
      integer :: ndsave
      logical :: retry
      intent (in) :: ma, ndsave
      intent (inout) :: retry
      type(fm_settings) :: qx

      integer :: j, kl
      double precision :: err

      if (abs(ma(1)%mp(2)) >= qx%mexpov .or. abs(ma(2)%mp(2)) >= qx%mexpov) return
      if (qx%ndig >= 2*ndsave+10) return

      if (qx%ncall >= 1) then
          kl = min(qx%ndig-ndsave, int(3*qx%dlogtn/qx%dlogmb + 2.5))
          err = 0
          do j = kl, 1, -1
             err = (err + ma(1)%mp(j+ndsave+2)) / qx%mbase
          enddo
          if ((qx%kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
              (qx%kround /= 1 .and. (err > 0.998 .or. err < 0.002))) then
              call fmndig(2*ndsave+10, qx)
              retry = .true.
              return
          endif
      endif

      if (qx%ncall >= 1) then
          kl = min(qx%ndig-ndsave, int(3*qx%dlogtn/qx%dlogmb + 2.5))
          err = 0
          do j = kl, 1, -1
             err = (err + ma(2)%mp(j+ndsave+2)) / qx%mbase
          enddo
          if ((qx%kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
              (qx%kround /= 1 .and. (err > 0.998 .or. err < 0.002))) then
              call fmndig(2*ndsave+10, qx)
              retry = .true.
          endif
      endif

      return
      end subroutine zmcheck_accuracy

      subroutine zmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)

!  Some routines monitor cancellation error to see if a retry is needed at higher precision.

      use fmvals_parallel
      implicit none

      type(multi) :: mresult(2), mretry(2)
      integer :: n_acc, ndsave, numtry
      logical :: retry
      intent (in) :: mresult, ndsave
      intent (inout) :: n_acc, numtry, mretry, retry
      type(fm_settings) :: qx

      integer :: iextra, j, kl, ndold, ngoal, ndgoal

      if (qx%ncall >= 1 .and. abs(mresult(1)%mp(2)) <= qx%mxexp .and.  &
          abs(mresult(2)%mp(2)) <= qx%mxexp) then
          ngoal = int(real(ndsave)*qx%alogm2) + 17
      else
          ngoal = int(-qx%mxexp2)
      endif

      if (n_acc <= ngoal) then
          if (numtry > 0) then
              ndgoal = int(real(ngoal)/qx%alogm2 + 1.0)
              kl = 0
              do j = 1, ndgoal+1
                 if (mretry(1)%mp(j+1) /= mresult(1)%mp(j+1) .or.  &
                     mretry(2)%mp(j+1) /= mresult(2)%mp(j+1)) then
                     kl = 1
                     exit
                 endif
              enddo
              if (kl == 0) then
                  return
              endif
          endif
          iextra = int(real(ngoal-n_acc)/qx%alogm2 + 23.03/qx%alogmb) + 1
          ndold = qx%ndig
          call fmndig(qx%ndig + iextra, qx)
          call zmequ(mresult, mretry, ndold, qx%ndig, qx)
          retry = .true.
      endif

      return
      end subroutine zmcheck_cancellation

      subroutine zmchsh(ma, mb, mc, qx)

!  mb = cosh(ma),    mc = sinh(ma).

!  If both the hyperbolic sine and cosine are needed, this routine is faster than calling both
!  zmcosh and zmsinh.

!  mb and mc must be distinct.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma
      intent (inout) :: mb, mc
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mresult1(2), mresult2(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmalloc(mc, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmchsh_sc(ma, ndsave, mresult1, mresult2, kresult, qx)
      if (kresult > 0) then
          call zmexit2(mresult1, mresult2, mb, mc, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmchsh_m1(ma, mresult1, mresult2, ndsave, qx)
         call zmcheck_accuracy(mresult1, ndsave, retry, qx)
         if (retry) cycle
         call zmcheck_accuracy(mresult2, ndsave, retry, qx)
      enddo

      call zmexit2(mresult1, mresult2, mb, mc, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmchsh

      subroutine zmchsh_m1(ma, mresult1, mresult2, ndsave, qx)

!  Method 1 for computing chsh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult1(2), mresult2(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult1, mresult2
      type(fm_settings) :: qx

      type(multi) :: mz01(2), mz02(2), mz03(2), mz04(2), mz05(2)

      call zmequ(ma, mz04, ndsave, qx%ndig, qx)

!             Find sinh(real(ma)) and cosh(real(ma)).

      call fmchsh(mz04(1), mz02(1), mz02(2), qx)

!             Find sin(imag(ma)) and cos(imag(ma)).

      call fmcssn(mz04(2), mz03(1), mz03(2), qx)

!             cosh(ma) =  cosh(real(ma))*cos(imag(ma)) + sinh(real(ma))*sin(imag(ma)) i

      call fmmpy(mz02(1), mz03(1), mz01(1), qx)
      call fmmpy(mz02(2), mz03(2), mz01(2), qx)

!             sinh(ma) =  sinh(real(ma))*cos(imag(ma)) + cosh(real(ma))*sin(imag(ma)) i

      call fmmpy(mz02(2), mz03(1), mz05(1), qx)
      call fmmpy(mz02(1), mz03(2), mz05(2), qx)

      call zmeq(mz01, mresult1, qx)
      call zmeq(mz05, mresult2, qx)

      return
      end subroutine zmchsh_m1

      subroutine zmchsh_sc(ma, ndsave, mresult1, mresult2, kresult, qx)

!  Check for special cases for {mresult1,mresult2} = chsh(ma).

!  kresult = 1 is returned if a special case gives the value of chsh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult1(2), mresult2(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult1, mresult2, kresult
      type(fm_settings) :: qx

      integer :: j, kl
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMCHSH   '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult1, qx)
          call zmunknown(mresult2, qx)
          kresult = 1
          return
      endif

      if (abs(ma(1)%mp(2)) >= qx%mexpov .or. abs(ma(2)%mp(2)) >= qx%mexpov) then
          call zmcosh(malocal, mresult1, qx)
          kl = qx%kflag
          call zmsinh(malocal, mresult2, qx)
          qx%kflag = max(qx%kflag, kl)
          kresult = 1
          return
      endif

      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
          call zmi2m(1, mresult1, qx)
          call zmi2m(0, mresult2, qx)
          kresult = 1
          return
      else if (ma(2)%mp(3) == 0) then
          call fmchsh(malocal(1), mresult1(1), mresult2(1), qx)
          call fmi2m(0, mresult1(2), qx)
          call fmi2m(0, mresult2(2), qx)
          kresult = 1
          return
      else if (ma(1)%mp(3) == 0) then
          call fmcssn(malocal(2), mresult1(1), mresult2(2), qx)
          call fmi2m(0, mresult1(2), qx)
          call fmi2m(0, mresult2(1), qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmchsh_sc

      subroutine zmcmpx(mafm, mbfm, mc, qx)

!  mc = complex( mafm , mbfm )

!  mafm and mbfm are real fm numbers, mc is a complex zm number.

      use fmvals_parallel
      implicit none

      type(multi) :: mafm, mbfm, mc(2)
      intent (in) :: mafm, mbfm
      intent (inout) :: mc
      type(fm_settings) :: qx

      call zmalloc(mc, qx%ndig+2, qx)

      qx%kflag = 0
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'ZMCMPX'
      if (qx%ntrace /= 0) call fmntr_inp2(mafm, mbfm, qx)

      call fmeq(mafm, mc(1), qx)
      call fmeq(mbfm, mc(2), qx)

      if (qx%ntrace /= 0) call zmntr_out1(mc, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine zmcmpx

      subroutine zmcomb(ma, mb, mc, qx)

!  mc = combination(ma,mb)   --   binomial coefficient

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(2, 8), mresult(2)

      call zmalloc(mc, qx%ndig+2, qx)
      call zmenter2(ma, mb, kovun, mxsave, ndsave, qx)
      call zmcomb_sc(ma, mb, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mc, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      retry = .true.
      do while (retry)
         retry = .false.
         call zmcomb_m1(ma, mb, mxy, mresult, ndsave, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mc, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmcomb

      subroutine zmcomb_m1(ma, mb, mxy, mresult, ndsave, qx)

!  Method 1 for computing comb(ma,mb).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2), mxy(2, 8), mresult(2)
      integer :: ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: k, kl, ntry, na, nd1
      logical, external :: fmcomp

!             comb(a,b) = a! / ( b! * (a-b)! )
!                       = gamma(a+1) / ( gamma(b+1) * gamma(a-b+1) )
!                       = exp( ln(gamma(a+1)) - ln(gamma(b+1)) - ln(gamma(a-b+1)) )


      nd1 = qx%ndig
      ntry = 0
      kl = 1
      do while (kl == 1)
         ntry = ntry + 1
         call zmequ(ma, mxy(1:2, 1), ndsave, qx%ndig, qx)
         call zmequ(mb, mxy(1:2, 2), ndsave, qx%ndig, qx)

         call zmi2m(1, mxy(1:2, 3), qx)

         call zmadd(mxy(1:2, 1), mxy(1:2, 3), mxy(1:2, 4), qx)
         call zmlngm(mxy(1:2, 4), mxy(1:2, 6), qx)

         call zmadd(mxy(1:2, 2), mxy(1:2, 3), mxy(1:2, 4), qx)
         call zmlngm(mxy(1:2, 4), mxy(1:2, 5), qx)
         call zmsub_r1(mxy(1:2, 6), mxy(1:2, 5), qx)

         call zmadd(mxy(1:2, 1), mxy(1:2, 3), mxy(1:2, 4), qx)
         call zmsub_r1(mxy(1:2, 4), mxy(1:2, 2), qx)
         call zmlngm(mxy(1:2, 4), mxy(1:2, 5), qx)
         call zmsub_r1(mxy(1:2, 6), mxy(1:2, 5), qx)

         if (mxy(2, 6)%mp(2) > nd1+qx%ngrd52) then
             call zmunknown(mresult, qx)
             return
         endif
         call zmexp(mxy(1:2, 6), mxy(1:2, 8), qx)

         if (ntry == 1) then
             call zmequ(mxy(1:2, 8), mxy(1:2, 7), qx%ndig, qx%ndig+qx%ngrd52, qx)
             call fmndig(qx%ndig + qx%ngrd52, qx)
             cycle
         else
             call zmequ(mxy(1:2, 7), mxy(1:2, 3), qx%ndig, ndsave, qx)
             call zmequ(mxy(1:2, 8), mxy(1:2, 4), qx%ndig, ndsave, qx)
             k = qx%ndig
             qx%ndig = ndsave
             na = 0
             if (fmcomp(mxy(1, 3), '==', mxy(1, 4), qx) .and.  &
                 fmcomp(mxy(2, 3), '==', mxy(2, 4), qx)) na = 1
             if (abs(mxy(1, 4)%mp(2)) >= qx%mexpov .and.  &
                 fmcomp(mxy(2, 3), '==', mxy(2, 4), qx)) na = 1
             if (abs(mxy(2, 4)%mp(2)) >= qx%mexpov .and.  &
                 fmcomp(mxy(1, 3), '==', mxy(1, 4), qx)) na = 1
             if (mxy(1, 4)%mp(2) == qx%mexpov .and.  &
                 mxy(2, 4)%mp(2) == qx%mexpov) na = 1
             if (mxy(1, 4)%mp(2) == qx%mexpov .and.  &
                 mxy(2, 4)%mp(3) == 0) then
                 if (mxy(2, 5)%mp(3) /= 0) na = 0
             endif
             if (mxy(2, 4)%mp(2) == qx%mexpov .and. mxy(1, 4)%mp(3) == 0) then
                 if (mxy(1, 5)%mp(3) /= 0) na = 0
             endif
             if (na == 0) then
                 if (ntry == 5) then
                     call zmunknown(mxy(1:2, 8), qx)
                     call fmndig(k, qx)
                     exit
                 else
                     call zmequ(mxy(1:2, 8), mxy(1:2, 7), k, 2*k, qx)
                     call fmndig(2*k, qx)
                     if (ma(1)%mp(2) == qx%munkno .or. ma(2)%mp(2) == qx%munkno .or.  &
                         mb(1)%mp(2) == qx%munkno .or. mb(2)%mp(2) == qx%munkno) then
                         call fmndig(k, qx)
                         exit
                     endif
                     cycle
                 endif
             else
                 call fmndig(k, qx)
                 exit
             endif
         endif
      enddo

      call zmeq(mxy(1:2, 8), mresult, qx)

      return
      end subroutine zmcomb_m1

      subroutine zmcomb_sc(ma, mb, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = comb(ma,mb).

!  kresult = 1 is returned if a special case gives the value of comb(ma,mb).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2), mblocal(2)
      logical, external :: fmcomp

      kresult = 0

      qx%namest(qx%ncall) = 'ZMCOMB   '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp2(ma, mb, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)
      call zmequ(mb, mblocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif
      if ((mblocal(1)%mp(2) == qx%munkno .and. mblocal(1)%mp(5) >= 0) .or.  &
          (mblocal(2)%mp(2) == qx%munkno .and. mblocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

!             If ma and mb are real, use fmcomb.

      if (malocal(2)%mp(3) == 0 .and. mblocal(2)%mp(3) == 0) then
          call fmcomb(malocal(1), mblocal(1), mresult(1), qx)
          call fmi2m(0, mresult(2), qx)
          kresult = 1
          return
      endif

!                   if ma = mb or mb = 0 return 1.

      if ( (fmcomp(malocal(1), "==", mblocal(1), qx) .and. fmcomp(malocal(2), "==", mblocal(2),qx)) .or.  &
           (mblocal(1)%mp(3) == 0 .and. mblocal(2)%mp(3) == 0) ) then
          call zmi2m(1, mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmcomb_sc

      subroutine zmcomplex(mafm, mbfm, mc, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: mafm, mbfm, mc(2)
      intent (in) ::  mafm, mbfm
      intent (inout) :: mc
      type(fm_settings) :: qx

      call zmcmpx(mafm, mbfm, mc, qx)

      return
      end subroutine zmcomplex

      subroutine zmconj(ma, mb, qx)

!  mb = conjg(ma)

!  Complex conjugate.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      qx%kflag = 0
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'ZMCONJ'
      if (qx%ntrace /= 0) call zmntr_inp1(ma, qx)

      call fmeq(ma(1), mb(1), qx)
      call fmeq(ma(2), mb(2), qx)
      call fmnegate(mb(2), qx)

      if (qx%ntrace /= 0) call zmntr_out1(mb, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine zmconj

      subroutine zmconjugate(ma, mb, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) ::  ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      call zmconj(ma, mb, qx)

      return
      end subroutine zmconjugate

      subroutine zmcos(ma, mb, qx)

!  mb = cos(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) ::  ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(5), mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmcos_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmcos_m1(ma, mxy, mresult, ndsave, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmcos

      subroutine zmcos_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing cos(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mxy(5), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      type(multi) :: mz01(2), mz02(2)

      call zmequ(ma, mz02, ndsave, qx%ndig, qx)

!             Find cos(real(ma)) and sin(real(ma)).

      call fmcssn(mz02(1), mz01(1), mz01(2), qx)

!             Find cosh(imag(ma)) and sinh(imag(ma)).

      call fmchsh(mz02(2), mxy(1), mxy(2), qx)

!             cos(ma) =  cos(real(ma))*cosh(imag(ma)) - sin(real(ma))*sinh(imag(ma)) i

      if (mxy(1)%mp(2) == qx%mexpov) then
          call fmabs(mz01(1), mxy(1), qx)
          call fmdivi_r1(mxy(1), 2, qx)
          call fmln(mxy(1), mxy(2), qx)
          qx%ndigli = 0
          call fmabs(mz02(2), mxy(3), qx)
          call fmadd(mxy(2), mxy(3), mxy(5), qx)
          call fmexp(mxy(5), mxy(4), qx)
          qx%ndige = 0
          if (mz01(1)%mp(1) < 0) call fmnegate(mxy(4), qx)

          call fmabs(mz01(2), mxy(1), qx)
          call fmdivi_r1(mxy(1), 2, qx)
          call fmln(mxy(1), mxy(2), qx)
          qx%ndigli = 0
          call fmadd(mxy(2), mxy(3), mxy(1), qx)
          call fmexp(mxy(1), mxy(5), qx)
          qx%ndige = 0
          if (mz02(2)%mp(1) > 0) call fmnegate(mxy(5), qx)
          if (mz01(2)%mp(1) < 0) call fmnegate(mxy(5), qx)

          call fmeq(mxy(4), mz01(1), qx)
          call fmeq(mxy(5), mz01(2), qx)
      else
          call fmmpy_r1(mz01(1), mxy(1), qx)
          call fmnegate(mxy(2), qx)
          call fmmpy_r1(mz01(2), mxy(2), qx)
      endif

      call zmeq(mz01, mresult, qx)

      return
      end subroutine zmcos_m1

      subroutine zmcos_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = cos(ma).

!  kresult = 1 is returned if a special case gives the value of cos(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMCOS    '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call zmi2m(1, mresult, qx)
          kresult = 1
          return
      else if (malocal(2)%mp(3) == 0) then
          call fmcos(malocal(1), mresult(1), qx)
          call fmi2m(0, mresult(2), qx)
          kresult = 1
          return
      else if (malocal(1)%mp(3) == 0) then
          call fmcosh(malocal(2), mresult(1), qx)
          call fmi2m(0, mresult(2), qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmcos_sc

      subroutine zmcos_sin(ma, mb, mc, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) ::  ma
      intent (inout) :: mb, mc
      type(fm_settings) :: qx

      call zmcssn(ma, mb, mc, qx)

      return
      end subroutine zmcos_sin

      subroutine zmcosh(ma, mb, qx)

!  mb = cosh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) ::  ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(5), mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmcosh_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmcosh_m1(ma, mxy, mresult, ndsave, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmcosh

      subroutine zmcosh_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing cosh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mxy(5), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      type(multi) :: mz01(2), mz02(2)

      call zmequ(ma, mz02, ndsave, qx%ndig, qx)

!             Find cos(imag(ma)) and sin(imag(ma)).

      call fmcssn(mz02(2), mz01(1), mz01(2), qx)

!             Find cosh(real(ma)) and sinh(real(ma)).

      call fmchsh(mz02(1), mxy(1), mxy(2), qx)

!             cosh(ma) =  cosh(real(ma))*cos(imag(ma)) + sinh(real(ma))*sin(imag(ma)) i

      if (mxy(1)%mp(2) == qx%mexpov) then
          call fmabs(mz01(1), mxy(1), qx)
          call fmdivi_r1(mxy(1), 2, qx)
          call fmln(mxy(1), mxy(2), qx)
          qx%ndigli = 0
          call fmabs(mz02(1), mxy(3), qx)
          call fmadd(mxy(2), mxy(3), mxy(5), qx)
          call fmexp(mxy(5), mxy(4), qx)
          qx%ndige = 0
          if (mz01(1)%mp(1) < 0) call fmnegate(mxy(4), qx)

          call fmabs(mz01(2), mxy(1), qx)
          call fmdivi_r1(mxy(1), 2, qx)
          call fmln(mxy(1), mxy(2), qx)
          qx%ndigli = 0
          call fmadd(mxy(2), mxy(3), mxy(1), qx)
          call fmexp(mxy(1), mxy(5), qx)
          qx%ndige = 0
          if (mz02(1)%mp(1) < 0) call fmnegate(mxy(5), qx)
          if (mz01(2)%mp(1) < 0) call fmnegate(mxy(5), qx)

          call fmeq(mxy(4), mz01(1), qx)
          call fmeq(mxy(5), mz01(2), qx)
      else
          call fmmpy_r1(mz01(1), mxy(1), qx)
          call fmmpy_r1(mz01(2), mxy(2), qx)
      endif

      call zmeq(mz01, mresult, qx)

      return
      end subroutine zmcosh_m1

      subroutine zmcosh_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = cosh(ma).

!  kresult = 1 is returned if a special case gives the value of cosh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMCOSH   '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call zmi2m(1, mresult, qx)
          kresult = 1
          return
      else if (malocal(1)%mp(3) == 0) then
          call fmcos(malocal(2), mresult(1), qx)
          call fmi2m(0, mresult(2), qx)
          kresult = 1
          return
      else if (malocal(2)%mp(3) == 0) then
          call fmcosh(malocal(1), mresult(1), qx)
          call fmi2m(0, mresult(2), qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmcosh_sc

      subroutine zmcosh_sinh(ma, mb, mc, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) ::  ma
      intent (inout) :: mb, mc
      type(fm_settings) :: qx

      call zmchsh(ma, mb, mc, qx)

      return
      end subroutine zmcosh_sinh

      subroutine zmcssn(ma, mb, mc, qx)

!  mb = cos(ma),    mc = sin(ma).

!  If both the sine and cosine are needed, this routine is faster than calling both zmcos and zmsin.

!  mb and mc must be distinct.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma
      intent (inout) :: mb, mc
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mresult1(2), mresult2(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmalloc(mc, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmcssn_sc(ma, ndsave, mresult1, mresult2, kresult, qx)
      if (kresult > 0) then
          call zmexit2(mresult1, mresult2, mb, mc, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmcssn_m1(ma, mresult1, mresult2, ndsave, qx)
         call zmcheck_accuracy(mresult1, ndsave, retry, qx)
         if (retry) cycle
         call zmcheck_accuracy(mresult2, ndsave, retry, qx)
      enddo

      call zmexit2(mresult1, mresult2, mb, mc, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmcssn

      subroutine zmcssn_m1(ma, mresult1, mresult2, ndsave, qx)

!  Method 1 for computing cssn(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult1(2), mresult2(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult1, mresult2
      type(fm_settings) :: qx

      integer :: krsave
      type(multi) :: mz01(2), mz02(2), mz03(2), mz04(2), mz05(2)

      krsave = qx%krad
      qx%krad = 1

      call zmequ(ma, mz04, ndsave, qx%ndig, qx)

!             Find sin(real(ma)) and cos(real(ma)).

      call fmcssn(mz04(1), mz02(1), mz02(2), qx)

!             Find sinh(imag(ma)) and cosh(imag(ma)).

      call fmchsh(mz04(2), mz03(1), mz03(2), qx)

!             cos(ma) =  cos(real(ma))*cosh(imag(ma)) - sin(real(ma))*sinh(imag(ma)) i

      call fmmpy(mz02(1), mz03(1), mz01(1), qx)
      call fmmpy(mz02(2), mz03(2), mz01(2), qx)
      call fmnegate(mz01(2), qx)

!             sin(ma) =  sin(real(ma))*cosh(imag(ma)) + cos(real(ma))*sinh(imag(ma)) i

      call fmmpy(mz02(2), mz03(1), mz05(1), qx)
      call fmmpy(mz02(1), mz03(2), mz05(2), qx)

      if (mz05(1)%mp(2) == qx%munkno .or. mz05(2)%mp(2) == qx%munkno) then
          call zmcos(mz04, mz01, qx)
          call zmsin(mz04, mz05, qx)
      endif

      call zmeq(mz01, mresult1, qx)
      call zmeq(mz05, mresult2, qx)
      qx%krad = krsave

      return
      end subroutine zmcssn_m1

      subroutine zmcssn_sc(ma, ndsave, mresult1, mresult2, kresult, qx)

!  Check for special cases for {mresult1,mresult2} = cssn(ma).

!  kresult = 1 is returned if a special case gives the value of cssn(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult1(2), mresult2(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult1, mresult2, kresult
      type(fm_settings) :: qx

      integer :: j, krsave
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMCSSN   '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      krsave = qx%krad
      qx%krad = 1

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult1, qx)
          call zmunknown(mresult2, qx)
          qx%krad = krsave
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call zmi2m(1, mresult1, qx)
          call zmi2m(0, mresult2, qx)
          qx%krad = krsave
          kresult = 1
          return
      else if (malocal(2)%mp(3) == 0) then
          call fmcssn(malocal(1), mresult1(1), mresult2(1), qx)
          call fmi2m(0, mresult1(2), qx)
          call fmi2m(0, mresult2(2), qx)
          qx%krad = krsave
          kresult = 1
          return
      else if (malocal(1)%mp(3) == 0) then
          call fmchsh(malocal(2), mresult1(1), mresult2(2), qx)
          call fmi2m(0, mresult1(2), qx)
          call fmi2m(0, mresult2(1), qx)
          qx%krad = krsave
          kresult = 1
          return
      endif
      qx%krad = krsave

      return
      end subroutine zmcssn_sc

      subroutine zmdiv(ma, mb, mc, qx)

!  mc = ma / mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(8), mresult(2)

      call zmalloc(mc, qx%ndig+2, qx)
      call zmenter2(ma, mb, kovun, mxsave, ndsave, qx)
      call zmdiv_sc(ma, mb, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mc, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmdiv_m1(ma, mb, mxy, mresult, ndsave, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mc, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmdiv

      subroutine zmdiv_m1(ma, mb, mxy, mresult, ndsave, qx)

!  Method 1 for computing  mc = ma / mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2), mxy(8), mresult(2)
      integer :: ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: j, kl
      real (kind(1.0d0)) :: maxexp
      type(multi) :: mz01(2), mz02(2)
      logical, external :: fmcomp

      call fmequ(ma(1), mxy(5), ndsave, qx%ndig, qx)
      call fmequ(ma(2), mxy(6), ndsave, qx%ndig, qx)
      call fmequ(mb(1), mxy(7), ndsave, qx%ndig, qx)
      call fmequ(mb(2), mxy(8), ndsave, qx%ndig, qx)

      if (mxy(5)%mp(3) == 0 .and. mxy(6)%mp(3) == 0) then
          call zmi2m(0, mresult, qx)
          return
      else if (mxy(8)%mp(3) == 0) then
          call fmdiv(mxy(5), mxy(7), mresult(1), qx)
          call fmdiv(mxy(6), mxy(7), mresult(2), qx)
          return
      else if (mxy(7)%mp(3) == 0) then
          call fmdiv(mxy(6), mxy(8), mresult(1), qx)
          call fmdiv(mxy(5), mxy(8), mresult(2), qx)
          call fmnegate(mresult(2), qx)
          return
      else if (mxy(6)%mp(3) == 0) then
          call fmsqr(mxy(7), mxy(3), qx)
          call fmsqr(mxy(8), mxy(4), qx)
          call fmadd_r2(mxy(3), mxy(4), qx)
          call fmdiv(mxy(7), mxy(4), mresult(1), qx)
          call fmmpy_r2(mxy(5), mresult(1), qx)
          call fmdiv(mxy(8), mxy(4), mresult(2), qx)
          call fmmpy_r2(mxy(5), mresult(2), qx)
          call fmnegate(mresult(2), qx)
          return
      else if (mxy(5)%mp(3) == 0) then
          call fmsqr(mxy(7), mxy(3), qx)
          call fmsqr(mxy(8), mxy(4), qx)
          call fmadd_r2(mxy(3), mxy(4), qx)
          call fmdiv(mxy(8), mxy(4), mresult(1), qx)
          call fmmpy_r2(mxy(6), mresult(1), qx)
          call fmdiv(mxy(7), mxy(4), mresult(2), qx)
          call fmmpy_r2(mxy(6), mresult(2), qx)
          return
      endif
      if (abs(mxy(5)%mp(2)) >= qx%mexpov .or. abs(mxy(6)%mp(2)) >= qx%mexpov .or.  &
          abs(mxy(7)%mp(2)) >= qx%mexpov .or. abs(mxy(8)%mp(2)) >= qx%mexpov ) then
          call zmi2m(0, mz01, qx)
          call zmdiv_unov(mxy(5), mxy(6), mxy(7), mxy(8), mresult, qx)
          return
      endif

!             Method for  ( a + b i ) / ( c + d i ):

!             if  abs(c) <= abs(d)  then

!                 p = c / d
!                 result = ( a*p + b )/( c*p + d ) + ( b*p - a )/( c*p + d ) i

!             else

!                 p = d / c
!                 result = ( b*p + a )/( d*p + c ) + ( b - a*p )/( d*p + c ) i


      if (mxy(7)%mp(3) == 0) then
          call fmi2m(0, mxy(4), qx)
          j = 1
      else if (mxy(8)%mp(3) == 0) then
          call fmi2m(0, mxy(4), qx)
          j = 2
      else if (mxy(7)%mp(2) < mxy(8)%mp(2)) then
          call fmdiv(mxy(7), mxy(8), mxy(4), qx)
          j = 1
      else if (mxy(8)%mp(2) < mxy(7)%mp(2)) then
          call fmdiv(mxy(8), mxy(7), mxy(4), qx)
          j = 2
      else if (mxy(7)%mp(3) < mxy(8)%mp(3)) then
          call fmdiv(mxy(7), mxy(8), mxy(4), qx)
          j = 1
      else if (mxy(8)%mp(3) < mxy(7)%mp(3)) then
          call fmdiv(mxy(8), mxy(7), mxy(4), qx)
          j = 2
      else if (mxy(7)%mp(4) < mxy(8)%mp(4)) then
          call fmdiv(mxy(7), mxy(8), mxy(4), qx)
          j = 1
      else if (mxy(8)%mp(4) < mxy(7)%mp(4)) then
          call fmdiv(mxy(8), mxy(7), mxy(4), qx)
          j = 2
      else if (fmcomp(mxy(7), '<=', mxy(8), qx)) then
          call fmdiv(mxy(7), mxy(8), mxy(4), qx)
          j = 1
      else
          call fmdiv(mxy(8), mxy(7), mxy(4), qx)
          j = 2
      endif

      kl = 1
      do while (kl == 1)
         kl = 0
         if (j == 1) then
             call fmdiv(mxy(7), mxy(8), mxy(4), qx)
             call fmmpye(mxy(4), mxy(5), mxy(6), mxy(7), mz01(1), mz01(2), mxy(3), qx)
             call fmadd_r1(mxy(3), mxy(8), qx)
             maxexp = max(mxy(6)%mp(2), mz01(1)%mp(2))
             call fmadd_r2(mxy(6), mz01(1), qx)
             if (mz01(1)%mp(2) < maxexp) exit
             maxexp = max(mz01(2)%mp(2), mxy(5)%mp(2))
             call fmsub_r1(mz01(2), mxy(5), qx)
             if (mz01(2)%mp(2) < maxexp) exit
             call fmdivd(mz01(1), mz01(2), mxy(3), mz02(1), mz02(2), qx)
             call zmeq(mz02, mresult, qx)
             return
         else
             call fmdiv(mxy(8), mxy(7), mxy(4), qx)
             call fmmpye(mxy(4), mxy(6), mxy(5), mxy(8), mz01(1), mz01(2), mxy(3), qx)
             call fmadd_r1(mxy(3), mxy(7), qx)
             maxexp = max(mxy(5)%mp(2), mz01(1)%mp(2))
             call fmadd_r2(mxy(5), mz01(1), qx)
             if (mz01(1)%mp(2) < maxexp) exit
             maxexp = max(mz01(2)%mp(2), mxy(6)%mp(2))
             call fmsub_r2(mxy(6), mz01(2), qx)
             if (mz01(2)%mp(2) < maxexp) exit
             call fmdivd(mz01(1), mz01(2), mxy(3), mz02(1), mz02(2), qx)
             call zmeq(mz02, mresult, qx)
             return
         endif
      enddo

!             When there was cancellation error above, raise precision and use
!             the more stable formula.
!             ( a*c + b*d ) / ( c*c + d*d ) + ( b*c - a*d ) / ( c*c + d*d ) i

      call fmequ_r1(mxy(5), qx%ndig, 2*qx%ndig, qx)
      call fmequ_r1(mxy(6), qx%ndig, 2*qx%ndig, qx)
      call fmequ_r1(mxy(7), qx%ndig, 2*qx%ndig, qx)
      call fmequ_r1(mxy(8), qx%ndig, 2*qx%ndig, qx)
      call fmndig(2*qx%ndig, qx)
      call fmmpye(mxy(7), mxy(5), mxy(6), mxy(7), mz01(1), mz01(2), mxy(3), qx)
      call fmmpye(mxy(8), mxy(6), mxy(5), mxy(8), mxy(1), mxy(2), mxy(4), qx)
      call fmadd_r2(mxy(3), mxy(4), qx)
      call fmadd_r1(mz01(1), mxy(1), qx)
      call fmsub_r1(mz01(2), mxy(2), qx)
      call fmdivd(mz01(1), mz01(2), mxy(4), mz02(1), mz02(2), qx)

      call zmeq(mz02, mresult, qx)

      return
      end subroutine zmdiv_m1

      subroutine zmdiv_r1(ma, mb, qx)

!  ma = ma / mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (inout) :: ma
      intent (in) :: mb
      type(fm_settings) :: qx

      type(multi) :: mt(2)

      call zmdiv(ma, mb, mt, qx)
      call zmeq(mt, ma, qx)

      end subroutine zmdiv_r1

      subroutine zmdiv_r2(ma, mb, qx)

!  mb = ma / mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      type(multi) :: mt(2)

      call zmdiv(ma, mb, mt, qx)
      call zmeq(mt, mb, qx)

      end subroutine zmdiv_r2

      subroutine zmdiv_sc(ma, mb, ndsave, mresult, kresult, qx)

!  Check for special cases for  mc = ma / mb

!  kresult = 1 is returned if a special case gives the value of the result.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2), mblocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMDIV    '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp2(ma, mb, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)
      call zmequ(mb, mblocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0) .or.  &
          (mblocal(1)%mp(2) == qx%munkno .and. mblocal(1)%mp(5) >= 0) .or.  &
          (mblocal(2)%mp(2) == qx%munkno .and. mblocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (mblocal(1)%mp(3) == 0 .and. mblocal(2)%mp(3) == 0) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif
      if (malocal(1)%mp(2) == mblocal(1)%mp(2) .and.  &
          malocal(1)%mp(3) == mblocal(1)%mp(3) .and.  &
          malocal(1)%mp(1) == mblocal(1)%mp(1)) then
          if (malocal(2)%mp(2) == mblocal(2)%mp(2) .and.  &
              malocal(2)%mp(3) == mblocal(2)%mp(3) .and.  &
              malocal(2)%mp(1) == mblocal(2)%mp(1)) then
              do j = 3, ndsave+1
                 if (malocal(1)%mp(j+1) /= mblocal(1)%mp(j+1)) return
                 if (malocal(2)%mp(j+1) /= mblocal(2)%mp(j+1)) return
              enddo
              if (abs(malocal(1)%mp(2)) < qx%mexpov .and.  &
                  abs(malocal(2)%mp(2)) < qx%mexpov .and.  &
                  abs(mblocal(1)%mp(2)) < qx%mexpov .and.  &
                  abs(mblocal(2)%mp(2)) < qx%mexpov) then
                  call zmi2m(1, mresult, qx)
                  kresult = 1
                  return
              endif
          endif
      endif
      if (malocal(1)%mp(2) == mblocal(1)%mp(2) .and.  &
          malocal(1)%mp(3) == mblocal(1)%mp(3) .and.  &
          (-malocal(1)%mp(1)) == mblocal(1)%mp(1)) then
          if (malocal(2)%mp(2) == mblocal(2)%mp(2) .and.  &
              malocal(2)%mp(3) == mblocal(2)%mp(3) .and.  &
              (-malocal(2)%mp(1)) == mblocal(2)%mp(1)) then
              do j = 3, ndsave+1
                 if (malocal(1)%mp(j+1) /= mblocal(1)%mp(j+1)) return
                 if (malocal(2)%mp(j+1) /= mblocal(2)%mp(j+1)) return
              enddo
              if (abs(malocal(1)%mp(2)) < qx%mexpov .and.  &
                  abs(malocal(2)%mp(2)) < qx%mexpov .and.  &
                  abs(mblocal(1)%mp(2)) < qx%mexpov .and.  &
                  abs(mblocal(2)%mp(2)) < qx%mexpov) then
                  call zmi2m(-1, mresult, qx)
                  kresult = 1
                  return
              endif
          endif
      endif

      return
      end subroutine zmdiv_sc

      subroutine zmdiv_unov(ma, mb, mc, md, mz, qx)

!  Check special cases where at least one of ma, mb, mc, md is underflow or overflow.

!  Return mz as the result.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md, mz(2)
      intent (inout) :: mz
      intent (in) :: ma, mb, mc, md
      type(fm_settings) :: qx

      type(multi) :: mxy(7)
      double precision :: a_xe, a_xf, b_xe, b_xf, c_xe, c_xf, d, d_xe, d_xf, t1, t2, t3, t4

      call fmsqr(mc, mxy(4), qx)
      call fmsqr(md, mxy(5), qx)
      call fmadd(mxy(4), mxy(5), mxy(3), qx)
      call fmmpy(ma, mc, mxy(4), qx)
      call fmmpy(mb, md, mxy(5), qx)
      call fmadd(mxy(4), mxy(5), mxy(6), qx)
      call fmdiv(mxy(6), mxy(3), mz(1), qx)
      call fmmpy(mb, mc, mxy(4), qx)
      call fmmpy(ma, md, mxy(5), qx)
      call fmsub(mxy(4), mxy(5), mxy(6), qx)
      call fmdiv(mxy(6), mxy(3), mz(2), qx)
      if (mz(1)%mp(2) /= qx%munkno .and. mz(2)%mp(2) /= qx%munkno) return
      if (.not. ( (mz(1)%mp(2) == qx%munkno .and. mz(1)%mp(5) >= 0) .or.  &
                  (mz(2)%mp(2) == qx%munkno .and. mz(2)%mp(5) >= 0) )) return

      call fmsqr(ma, mxy(4), qx)
      call fmsqr(mb, mxy(5), qx)
      call fmadd(mxy(4), mxy(5), mxy(2), qx)
      call fmsqr(mc, mxy(4), qx)
      call fmsqr(md, mxy(5), qx)
      call fmadd(mxy(4), mxy(5), mxy(3), qx)
      call fmdiv(mxy(2), mxy(3), mxy(5), qx)
      call fmovun_xexf(ma, a_xe, a_xf, qx)
      call fmovun_xexf(mb, b_xe, b_xf, qx)
      call fmovun_xexf(mc, c_xe, c_xf, qx)
      call fmovun_xexf(md, d_xe, d_xf, qx)
      if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
          d = 1.0d+10
      else
          d = 4
      endif
      t1 = max(a_xe, b_xe) - max(c_xe, d_xe)
      if (t1 >= (huge(qx%mbase)/d)/2 .or. t1 <= -(huge(qx%mbase)/d)/2) then
          mxy(5)%mp(4) = t1
          call fmeq(mxy(5), mxy(4), qx)
      else
          call fmsqrt(mxy(5), mxy(4), qx)
      endif
      if (mxy(4)%mp(2) /= qx%munkno .and. abs(mxy(4)%mp(2)) == qx%mexpov) then
          t3 = qx%dlogmb*(a_xe - b_xe)/2 + log(a_xf)
          t4 = qx%dlogmb*(b_xe - a_xe)/2 + log(b_xf)
          if (log(tiny(t3)) <= t3 .and. t3 <= log(huge(t3))) then
              t3 = ma%mp(1) * dble(qx%mbase)**( (a_xe - b_xe)/2 ) * a_xf
              t4 = mb%mp(1) * dble(qx%mbase)**( (b_xe - a_xe)/2 ) * b_xf
              t1 = atan2(t4, t3)
          else
              if (ma%mp(1) > 0 .and. a_xe > b_xe) then
                  t1 = 0
              else if (mb%mp(1) > 0 .and. b_xe > a_xe) then
                  t1 = asin(1.0d0)
              else if (mb%mp(1) < 0 .and. b_xe > a_xe) then
                  t1 = asin(-1.0d0)
              else if (ma%mp(1) < 0 .and. mb%mp(1) > 0 .and. a_xe > b_xe) then
                  t1 = acos(-1.0d0)
              else
                  t1 = -acos(-1.0)
              endif
          endif

          t3 = qx%dlogmb*(c_xe - d_xe)/2 + log(c_xf)
          t4 = qx%dlogmb*(d_xe - c_xe)/2 + log(d_xf)
          if (log(tiny(t3)) <= t3 .and. t3 <= log(huge(t3))) then
              t3 = mc%mp(1) * dble(qx%mbase)**( (c_xe - d_xe)/2 ) * c_xf
              t4 = md%mp(1) * dble(qx%mbase)**( (d_xe - c_xe)/2 ) * d_xf
              t2 = atan2(t4, t3)
          else
              if (mc%mp(1) > 0 .and. c_xe > d_xe) then
                  t2 = 0
              else if (md%mp(1) > 0 .and. d_xe > c_xe) then
                  t2 = asin(1.0d0)
              else if (md%mp(1) < 0 .and. d_xe > c_xe) then
                  t2 = asin(-1.0d0)
              else if (mc%mp(1) < 0 .and. md%mp(1) > 0 .and. c_xe > d_xe) then
                  t2 = acos(-1.0d0)
              else
                  t2 = -acos(-1.0)
              endif
          endif

          call fmdp2m(cos(t1-t2), mxy(3), qx)
          call fmmpy(mxy(3), mxy(4), mz(1), qx)
          call fmdp2m(sin(t1-t2), mxy(3), qx)
          call fmmpy(mxy(3), mxy(4), mz(2), qx)
          if (mz(1)%mp(2) /= qx%munkno .and. mz(2)%mp(2) /= qx%munkno) return
      else if (abs(mxy(4)%mp(2)) < qx%mexpov) then
          call fmovun_xexf(ma, a_xe, a_xf, qx)
          call fmovun_xexf(mb, b_xe, b_xf, qx)
          call fmovun_xexf(mc, c_xe, c_xf, qx)
          call fmovun_xexf(md, d_xe, d_xf, qx)
          call fmmpy(ma, mc, mxy(1), qx)
          call fmmpy(mb, md, mxy(2), qx)
          call fmmpy(ma, md, mxy(3), qx)
          call fmmpy(mb, mc, mxy(4), qx)
          call fmadd(mxy(1), mxy(2), mz(1), qx)
          call fmsub(mxy(4), mxy(3), mz(2), qx)
          if (a_xe+c_xe > b_xe+d_xe + qx%ndig) call fmeq(mxy(1), mz(1), qx)
          if (b_xe+d_xe > a_xe+c_xe + qx%ndig) call fmeq(mxy(2), mz(1), qx)
          if (a_xe+d_xe > b_xe+c_xe + qx%ndig) call fmmpyi(mxy(3), -1, mz(2), qx)
          if (b_xe+c_xe > a_xe+d_xe + qx%ndig) call fmeq(mxy(4), mz(2), qx)
          call fmsqr(mc, mxy(5), qx)
          call fmsqr(md, mxy(6), qx)
          call fmadd(mxy(5), mxy(6), mxy(7), qx)
          call fmdiv_r1(mz(1), mxy(7), qx)
          call fmdiv_r1(mz(2), mxy(7), qx)
          if (mz(1)%mp(2) /= qx%munkno .and. mz(2)%mp(2) /= qx%munkno) return
      endif

      call zmunknown(mz, qx)

      return
      end subroutine zmdiv_unov

      subroutine zmdivi(ma, integ, mb, qx)

!  mb = ma / integ        Divide by one-word (real) integer.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      integer :: integ
      intent (in) :: ma, integ
      intent (inout) :: mb
      type(fm_settings) :: qx

      integer :: kovun, kwrnsv, ntrsav

      call zmalloc(mb, qx%ndig+2, qx)

      if ((ma(1)%mp(2) == qx%munkno .and. ma(1)%mp(5) >= 0) .or.  &
          (ma(2)%mp(2) == qx%munkno .and. ma(2)%mp(5) >= 0)) then
          qx%ncall = qx%ncall + 1
          qx%namest(qx%ncall) = 'ZMDIVI   '
          call zmntr_inp1i(ma, integ, qx)
          call zmunknown(mb, qx)
          qx%kflag = -4
          call zmntr_out1(mb, qx)
          qx%ncall = qx%ncall - 1
          return
      endif

      qx%ncall = qx%ncall + 1
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'ZMDIVI'
          call zmntr_inp1i(ma, integ, qx)
      endif
      kovun = 0
      if (ma(1)%mp(2) == qx%mexpov .or. ma(1)%mp(2) == qx%mexpun) kovun = 1
      if (ma(2)%mp(2) == qx%mexpov .or. ma(2)%mp(2) == qx%mexpun) kovun = 1
      if (ma(1)%mp(2) == qx%munkno .or. ma(2)%mp(2) == qx%munkno) kovun = 2

!             Force fmdivi to use more guard digits for user calls.

      qx%ncall = qx%ncall - 1
      ntrsav = qx%ntrace
      qx%ntrace = 0
      kwrnsv = qx%kwarn
      qx%kwarn = 0

      call fmdivi(ma(1), integ, mb(1), qx)
      call fmdivi(ma(2), integ, mb(2), qx)

      qx%ntrace = ntrsav
      qx%kwarn = kwrnsv
      qx%ncall = qx%ncall + 1
      if (qx%ntrace /= 0) qx%namest(qx%ncall) = 'ZMDIVI'
      if (mb(1)%mp(2) == qx%munkno .or. mb(2)%mp(2) == qx%munkno) then
          qx%kflag = -4
      else if (mb(1)%mp(2) == qx%mexpov .or. mb(2)%mp(2) == qx%mexpov) then
          qx%kflag = -5
      else if (mb(1)%mp(2) == qx%mexpun .or. mb(2)%mp(2) == qx%mexpun) then
          qx%kflag = -6
      endif
      if ((mb(1)%mp(2) == qx%munkno .and. kovun /= 2) .or.  &
          (mb(2)%mp(2) == qx%munkno .and. kovun /= 2) .or.  &
          (mb(1)%mp(2) == qx%mexpun .and. kovun == 0) .or.  &
          (mb(2)%mp(2) == qx%mexpun .and. kovun == 0) .or.  &
          (mb(1)%mp(2) == qx%mexpov .and. kovun == 0) .or.  &
          (mb(2)%mp(2) == qx%mexpov .and. kovun == 0)) then
          qx%namest(qx%ncall) = 'ZMDIVI'
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) call zmntr_out1(mb, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine zmdivi

      subroutine zmdivi_r1(ma, ival, qx)

!  ma = ma / ival

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2)
      integer :: ival
      intent (inout) :: ma
      intent (in) :: ival
      type(fm_settings) :: qx

      type(multi) :: mt(2)

      call zmdivi(ma, ival, mt, qx)
      call zmeq(mt, ma, qx)

      return
      end subroutine zmdivi_r1

      subroutine zmenter1(ma, kovun, mxsave, ndsave, qx)

!  At the start of a function this routine raises precision, and extends the
!  overflow/underflow threshold.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2)
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (in) :: ma
      intent (inout) :: kovun, mxsave, ndsave
      type(fm_settings) :: qx

      integer :: k

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      kovun = 0
      if (ma(1)%mp(2) == qx%mexpov .or. ma(1)%mp(2) == qx%mexpun) kovun = 1
      if (ma(2)%mp(2) == qx%mexpov .or. ma(2)%mp(2) == qx%mexpun) kovun = 1
      if (ma(1)%mp(2) == qx%munkno .or. ma(2)%mp(2) == qx%munkno) kovun = 2

!             Increase the working precision.

      qx%ncall = qx%ncall + 1
      ndsave = qx%ndig
      if (qx%ncall == 1) then
          k = max(qx%ngrd52, 2)
          call fmndig(max(qx%ndig+k, 3), qx)
          if (qx%mbase >= 100*abs(ma(1)%mp(3)) .or.  &
              qx%mbase >= 100*abs(ma(2)%mp(3))) then
              call fmndig(qx%ndig + 1, qx)
          endif
          qx%kround1 = qx%kround
      else if (qx%kround1 /= 1) then
          call fmndig(qx%ndig + qx%ngrd22, qx)
      endif

!             Extend the overflow/underflow threshold.

      mxsave = qx%mxexp
      qx%mxexp = qx%mxexp2

      return
      end subroutine zmenter1

      subroutine zmenter2(ma, mb, kovun, mxsave, ndsave, qx)

!  At the start of a function this routine raises precision, and extends the
!  overflow/underflow threshold.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (in) :: ma, mb
      intent (inout) :: kovun, mxsave, ndsave
      type(fm_settings) :: qx

      integer :: k

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      kovun = 0
      if (ma(1)%mp(2) == qx%mexpov .or. ma(1)%mp(2) == qx%mexpun) kovun = 1
      if (ma(2)%mp(2) == qx%mexpov .or. ma(2)%mp(2) == qx%mexpun) kovun = 1
      if (mb(1)%mp(2) == qx%mexpov .or. mb(1)%mp(2) == qx%mexpun) kovun = 1
      if (mb(2)%mp(2) == qx%mexpov .or. mb(2)%mp(2) == qx%mexpun) kovun = 1
      if (ma(1)%mp(2) == qx%munkno .or. ma(2)%mp(2) == qx%munkno) kovun = 2
      if (mb(1)%mp(2) == qx%munkno .or. mb(2)%mp(2) == qx%munkno) kovun = 2

!             Increase the working precision.

      qx%ncall = qx%ncall + 1
      ndsave = qx%ndig
      if (qx%ncall == 1) then
          k = max(qx%ngrd52, 2)
          call fmndig(max(qx%ndig+k, 3), qx)
          if (qx%mbase >= 100*abs(ma(1)%mp(3)) .or.  &
              qx%mbase >= 100*abs(ma(2)%mp(3))) then
              call fmndig(qx%ndig + 1, qx)
          endif
          qx%kround1 = qx%kround
      else if (qx%kround1 /= 1) then
          call fmndig(qx%ndig + qx%ngrd22, qx)
      endif

!             Extend the overflow/underflow threshold.

      mxsave = qx%mxexp
      qx%mxexp = qx%mxexp2

      return
      end subroutine zmenter2

      subroutine zmeq(ma, mb, qx)

!  mb = ma

!  This is the standard form of equality, where ma and mb both have precision ndig.
!  use zmequ for assignments that also change precision.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      call fmeq(ma(1), mb(1), qx)
      call fmeq(ma(2), mb(2), qx)

      return
      end subroutine zmeq

      subroutine zmequ(ma, mb, nda, ndb, qx)

!  Set mb (having ndb digits) equal to ma (having nda digits).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      integer :: nda, ndb
      intent (in) :: nda, ndb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      call fmequ(ma(1), mb(1), nda, ndb, qx)
      call fmequ(ma(2), mb(2), nda, ndb, qx)

      return
      end subroutine zmequ

      subroutine zmequ_r1(ma, nda, ndb, qx)

!  Change precision of ma from nda digits on input to ndb digits on output.

!  If ndb is less than nda the result is rounded to ndb digits.

!  If ndb is greater than nda the result has zero digits padded on the right.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2)
      integer :: nda, ndb
      intent (in) :: nda, ndb
      intent (inout) :: ma
      type(fm_settings) :: qx

      call fmequ_r1(ma(1), nda, ndb, qx)
      call fmequ_r1(ma(2), nda, ndb, qx)

      return
      end subroutine zmequ_r1

      subroutine zmerf(ma, mb, qx)

!  mb = erf(ma)    Error function.

!  2/sqrt(pi) * integral from 0 to ma of e**(-t**2) dt.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(2, 15), mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmerf_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call zmerf_m(ma, mxy, mresult, ndsave, numtry, retry, qx)
         if (retry) then
             retry = .false.
             call zmcheck_accuracy(mresult, ndsave, retry, qx)
         endif
         numtry = numtry + 1
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmerf

      subroutine zmerf_m(ma, mxy, mresult, ndsave, numtry, retry, qx)

!  Method selection for computing erf(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mxy(2, 15), mresult(2)
      integer :: ndsave, numtry
      logical :: retry
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, numtry, retry
      type(fm_settings) :: qx

      double precision :: c1, c2, c4, x, xe, xk
      integer :: kflagx, nmethd
      logical, external :: fmcomp

      retry = .true.

      call zmequ(ma, mxy(1:2, 1), ndsave, qx%ndig, qx)

!             Check for special cases.

      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
          call zmeq(mxy(1:2, 1), mresult, qx)
          retry = .false.
          return
      endif
      call zmabs(mxy(1:2, 1), mxy(1, 2), qx)
      call fmovun_xe(mxy(1, 2), xe, qx)
      if (xe <= -qx%ndig/2) then
          call fmpi(mxy(1, 3), qx)
          qx%ndigpi = 0
          call fmsqrt(mxy(1, 3), mxy(1, 4), qx)
          call fmi2m(2, mxy(1, 5), qx)
          call fmdiv(mxy(1, 5), mxy(1, 4), mxy(1, 6), qx)
          call fmmpy(mxy(1, 1), mxy(1, 6), mxy(1, 3), qx)
          call fmmpy(mxy(2, 1), mxy(1, 6), mxy(2, 3), qx)
          call zmeq(mxy(1:2, 3), mresult, qx)
          return
      endif

!             x is a double precision approximation to the size of input argument to this function.

      call zmabs(mxy(1:2, 1), mxy(1, 4), qx)
      call fmm2dp(mxy(1, 4), x, qx)
      kflagx = qx%kflag
      call fmovun_xe(mxy(1, 4), xe, qx)
      if (qx%kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax**0.33d0
          kflagx = 0
      else if (qx%kflag == 0 .and. x < 1.0d0/dpmax**0.33d0) then
          x = 1.0d0/dpmax**0.33d0
      endif
      if (qx%kflag /= 0 .and. xe > 0) then
          x = dpmax**0.33d0
          kflagx = 0
      else if (qx%kflag == 0 .and. x > dpmax**0.33d0) then
          x = dpmax**0.33d0
      endif

!             Determine which method to use.

!             nmethd = 1 use the convergent series,
!                    = 2 use a 2nd convergent series,
!                    = 3 use a continued fraction expansion,
!                    = 4 use an asymptotic series.

      xk = max(3.0d0, (2*x**2 + 1)/2)
      xk = -xk + log(2*xk-1)*(2*xk-0.5d0) + log(xk-1)*(-xk+0.5d0) - log(2.0d0)*(2*xk-1) -  &
           log(x)*(2*xk+1)
      if (-xk/qx%dlogmb > qx%ndig+(3+qx%ndig/20)*qx%ngrd52) then
          nmethd = 4
      else
          c4 = 5.0
          xk = 0.0
          do while (-xk/qx%dlogmb <= qx%ndig+(3+qx%ndig/20)*qx%ngrd52)
             c4 = 2 * c4
             xk = max(3.0d0, (2*c4**2 + 1)/2)
             xk = -xk + log(2*xk-1)*(2*xk-0.5d0) + log(xk-1)*(-xk+0.5d0) - log(2.0d0)*(2*xk-1) -  &
                  log(c4)*(2*xk+1)
          enddo
          c1 = c4/2
          do while (c4-c1 > 0.1)
             c2 = (c1 + c4) / 2
             xk = max(3.0d0, (2*c2**2 + 1)/2)
             xk = -xk + log(2*xk-1)*(2*xk-0.5d0) + log(xk-1)*(-xk+0.5d0) - log(2.0d0)*(2*xk-1) -  &
                  log(c2)*(2*xk+1)
             if (-xk/qx%dlogmb > qx%ndig+(3+qx%ndig/20)*qx%ngrd52) then
                 c4 = c2
             else
                 c1 = c2
             endif
          enddo
          if (x > 0.75*c4 .and. x > c4 - 5) then
              nmethd = 3
          else
              call fmdiv(mxy(2, 1), mxy(1, 1), mxy(1, 15), qx)
              call fmabs(mxy(1, 15), mxy(2, 15), qx)
              call fmdp2m(1.5d0, mxy(1, 15), qx)
              if (fmcomp(mxy(2, 15), '>', mxy(1, 15), qx)) then
                  if (x > 0.70*c4) then
                      nmethd = 2
                  else
                      nmethd = 1
                  endif
              else
                  if (x > 6.0) then
                      nmethd = 2
                  else
                      nmethd = 1
                  endif
              endif
          endif
      endif

      if (nmethd == 1) then
          call zmerf_m1(mxy, mresult, ndsave, numtry, kflagx, x, qx)
      else if (nmethd == 2) then
          call zmerf_m2(mxy, mresult, ndsave, numtry, kflagx, x, qx)
      else if (nmethd == 3) then
          call zmerf_m3(mxy, mresult, ndsave, numtry, kflagx, x, qx)
      else if (nmethd == 4) then
          call zmerf_m4(mxy, mresult, ndsave, numtry, kflagx, x, qx)
      endif

      return
      end subroutine zmerf_m

      subroutine zmerf_m1(mxy, mresult, ndsave, numtry, kflagx, x, qx)

!  Method 1 for computing erf(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: xe
      integer :: iextra, j, j2, kl, nd, nd1, ndsav1, nterm
      type(multi) :: mjsums(2, ljsums)
      double precision, external :: fmnterms

!             Method 1.  Use the (-1)**n x**(2n+1) / n! / (2n+1) series.

!                        = ( 2 / sqrt(pi) ) * ( x - x**3/1! + x**5/2! - x**7/3! + ... )

      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig+qx%ngrd52), qx)
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, qx%ndig, qx)

!             If ma is large in magnitude or close to the real line, use more guard digits.

      call fmsqr(mxy(1, 1), mxy(1, 15), qx)
      call fmsqr(mxy(2, 1), mxy(2, 15), qx)
      call fmmpy(mxy(1, 1), mxy(2, 1), mxy(1, 14), qx)
      call fmst2m('-4.409869', mxy(1, 13), qx)

      call fmst2m(' 0.000918', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(1, 1), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m(' 0.002513', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(2, 1), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m(' 0.124040', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(1, 15), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m('-0.000288', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(1, 14), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m(' 0.001638', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(2, 15), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmm2i(mxy(1, 13), iextra, qx)
      iextra = max(0, nint((iextra+3) * 16.11809565d0 / qx%dlogmb)+1)
      if (iextra > 0) then
          call zmequ_r1(mxy(1:2, 1), qx%ndig, qx%ndig+iextra, qx)
      endif
      call fmndig(qx%ndig + iextra, qx)
      if (kflagx == 0) then
          j2 = int(0.66*sqrt(fmnterms(x**2, 1, 0, 0, 1, qx)) - 0.8)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call zmi2m(1, mxy(1:2, 6), qx)
      call zmi2m(1, mjsums(1:2, 1), qx)

      do j = 2, j2
         if (nterm > 1) then
             call zmdivi_r1(mxy(1:2, 6), nterm, qx)
         endif
         call zmdivi(mxy(1:2, 6), 2*nterm+1, mjsums(1:2, j), qx)
         nterm = nterm + 1
      enddo
      call zmabs(mxy(1:2, 1), mxy(1, 15), qx)
      call fmovun_xe(mxy(1, 15), xe, qx)
      if (xe < -qx%ndig) then
          kl = 0
      else
          kl = 1
          call zmipwr(mxy(1:2, 1), 2*j2, mxy(1:2, 5), qx)
      endif

      do while (kl == 1)
         call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 5), qx)
         do j = 1, j2
            call zmdivi_r1(mxy(1:2, 6), nterm, qx)
            call zmdivi(mxy(1:2, 6), 2*nterm+1, mxy(1:2, 4), qx)
            call fmndig(ndsav1, qx)
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 4), qx)
            if (qx%kflag == 1 .or.                                                    &
                (mjsums(1, j)%mp(2) == qx%munkno .and. mjsums(1, j)%mp(5) >= 0) .or.  &
                (mjsums(2, j)%mp(2) == qx%munkno .and. mjsums(2, j)%mp(5) >= 0)) then
                kl = 0
                exit
            endif
            nd = mjsums(1, j)%mp(2)-mxy(1, 4)%mp(2)
            nd1 = mjsums(2, j)%mp(2)-mxy(2, 4)%mp(2)
            nd = ndsav1 - int(min(nd, nd1))
            call fmndig(min(ndsav1, nd), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
            nterm = nterm + 1
         enddo
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call zmsqr(mxy(1:2, 1), mxy(1:2, 4), qx)
      call zmnegate(mxy(1:2, 4), qx)
      call zmeq(mjsums(1:2, j2), mxy(1:2, 5), qx)

      do j = 2, j2
         call zmmpy(mxy(1:2, 5), mxy(1:2, 4), mxy(1:2, 15), qx)
         call zmadd(mxy(1:2, 15), mjsums(1:2, j2-j+1), mxy(1:2, 5), qx)
      enddo

      call zmmpy_r1(mxy(1:2, 5), mxy(1:2, 1), qx)

      call fmpi(mxy(1, 4), qx)
      qx%ndigpi = 0
      call fmi2m(0, mxy(2, 4), qx)
      call zmsqrt(mxy(1:2, 4), mxy(1:2, 3), qx)
      call zmmpyi(mxy(1:2, 5), 2, mxy(1:2, 4), qx)
      call zmdiv_r2(mxy(1:2, 4), mxy(1:2, 3), qx)

      call zmeq(mxy(1:2, 3), mresult, qx)

      return
      end subroutine zmerf_m1

      subroutine zmerf_m2(mxy, mresult, ndsave, numtry, kflagx, x, qx)

!  Method 2 for computing erf(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: xe
      integer :: iextra, j, j2, kl, nd, nd1, ndsav1, nterm
      type(multi) :: mjsums(2, ljsums)
      double precision, external :: fmnterms

!             Method 2.  Use the x**(2n+1) * 2**(n+1) / (1*3*5*...*(2n+1)) series.

      iextra = 0
      call fmsqr(mxy(1, 1), mxy(1, 15), qx)
      call fmsqr(mxy(2, 1), mxy(2, 15), qx)
      call fmmpy(mxy(1, 1), mxy(2, 1), mxy(1, 14), qx)
      call fmst2m('-2.156685', mxy(1, 13), qx)

      call fmst2m('-0.000490', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(1, 1), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m('-0.000013', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(2, 1), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m(' 0.062094', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(1, 15), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m(' 0.000027', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(1, 14), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m(' 0.062030', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(2, 15), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmm2i(mxy(1, 13), iextra, qx)
      iextra = max(0, nint((iextra+3) * 16.11809565d0 / qx%dlogmb)+1)
      call fmndig(qx%ndig + iextra, qx)
      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig) + 1, qx)
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, qx%ndig, qx)
      if (kflagx == 0) then
          j2 = int(0.51*sqrt(fmnterms(2*x, 2, -1, 0, 1, qx)))
      else
          j2 = 1
      endif
      j2 = max(1, min(ljsums, j2))
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call zmmpyi(mxy(1:2, 1), 2, mxy(1:2, 6), qx)
      call zmeq(mxy(1:2, 6), mjsums(1:2, 1), qx)
      do j = 2, j2
         call zmmpyi_r1(mxy(1:2, 6), 2, qx)
         call zmdivi_r1(mxy(1:2, 6), 2*nterm+1, qx)
         call zmeq(mxy(1:2, 6), mjsums(1:2, j), qx)
         nterm = nterm + 1
      enddo
      call zmabs(mxy(1:2, 1), mxy(1, 15), qx)
      call fmovun_xe(mxy(1, 15), xe, qx)
      if (xe < -qx%ndig) then
          kl = 0
      else
          kl = 1
          call zmipwr(mxy(1:2, 1), 2*j2, mxy(1:2, 5), qx)
      endif

      do while (kl == 1)
         call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 5), qx)
         do j = 1, j2
            call zmmpyi(mxy(1:2, 6), 2, mxy(1:2, 15), qx)
            call zmdivi(mxy(1:2, 15), 2*nterm+1, mxy(1:2, 6), qx)
            call fmndig(ndsav1, qx)
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 6), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            nd = mjsums(1, j)%mp(2)-mxy(1, 6)%mp(2)
            nd1 = mjsums(2, j)%mp(2)-mxy(2, 6)%mp(2)
            nd = ndsav1 - int(min(nd, nd1))
            call fmndig(min(ndsav1, nd), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
            nterm = nterm + 1
         enddo
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call zmsqr(mxy(1:2, 1), mxy(1:2, 6), qx)
      call zmeq(mjsums(1:2, j2), mxy(1:2, 5), qx)
      do j = 2, j2
         call zmmpy(mxy(1:2, 5), mxy(1:2, 6), mxy(1:2, 15), qx)
         call zmadd(mxy(1:2, 15), mjsums(1:2, j2-j+1), mxy(1:2, 5), qx)
      enddo

      call fmpi(mxy(1, 4), qx)
      qx%ndigpi = 0
      call fmi2m(0, mxy(2, 4), qx)
      call zmsqrt(mxy(1:2, 4), mxy(1:2, 3), qx)
      call zmdiv_r2(mxy(1:2, 5), mxy(1:2, 3), qx)
      call zmexp(mxy(1:2, 6), mxy(1:2, 4), qx)
      call zmdiv_r1(mxy(1:2, 3), mxy(1:2, 4), qx)

      call zmeq(mxy(1:2, 3), mresult, qx)

      return
      end subroutine zmerf_m2

      subroutine zmerf_m3(mxy, mresult, ndsave, numtry, kflagx, x, qx)

!  Method 3 for computing erf(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: k, ksma, kt, nd, nd1, ndsav1, ndsav2, nterms
      logical, external :: fmcomp

!             Method 3.  Continued fraction expansion (asymptotic).
!                        Used for Re(x) > 0, erf(x) = -erf(-x) otherwise.

!                                  erf(x) = 1 + (-exp(-x**2)/sqrt(pi)) /
!                                                                   x + 1 /
!                                                                     2*x + 2 /
!                                                                           x + 3 /
!                                                                             2*x + 4 /
!                                                                                   x + 5 ...

      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig) + 1, qx)
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, qx%ndig, qx)
      ndsav1 = qx%ndig
      ksma = mxy(1, 1)%mp(1)
      if (ksma < 0) then
          call zmnegate(mxy(1:2, 1), qx)
      endif

      call zmeq(mxy(1:2, 1), mxy(1:2, 2), qx)

      call zmsqr(mxy(1:2, 2), mxy(1:2, 4), qx)
      call zmmpyi(mxy(1:2, 4), -1, mxy(1:2, 15), qx)
      call zmexp(mxy(1:2, 15), mxy(1:2, 10), qx)
      call zmmpyi(mxy(1:2, 10), -1, mxy(1:2, 15), qx)
      call fmpi(mxy(1, 10), qx)
      qx%ndigpi = 0
      call fmsqrt_r1(mxy(1, 10), qx)
      call fmi2m(0, mxy(2, 10), qx)
      call zmdiv_r2(mxy(1:2, 15), mxy(1:2, 10), qx)
      call zmdiv_r1(mxy(1:2, 10), mxy(1:2, 2), qx)
      call zmi2m(-31, mxy(1:2, 13), qx)

      call fmi2m(1, mxy(1, 15), qx)
      call fmulp(mxy(1, 15), mxy(2, 15), qx)
      call fmdiv(mxy(1, 1), mxy(2, 1), mxy(1, 15), qx)
      call fmsqr_r1(mxy(1, 15), qx)
      if (fmcomp(mxy(1, 15), '<', mxy(2, 15), qx)) then
          call zmi2m(0, mxy(1:2, 15), qx)
      else
          call zmi2m(1, mxy(1:2, 15), qx)
      endif
      call zmadd(mxy(1:2, 15), mxy(1:2, 10), mxy(1:2, 14), qx)
      call zmi2m(1, mxy(1:2, 8), qx)
      call zmeq(mxy(1:2, 2), mxy(1:2, 9), qx)
      nterms = int(intmax/10)

!             Continued fraction loop.

      ndsav2 = qx%ndig
      do k = 3, nterms
         call zmmpyi(mxy(1:2, 2), 1+mod(k, 2), mxy(1:2, 11), qx)
         call zmmpy_r1(mxy(1:2, 11), mxy(1:2, 9), qx)
         call zmmpyi(mxy(1:2, 8), k-2, mxy(1:2, 12), qx)
         call zmadd(mxy(1:2, 11), mxy(1:2, 12), mxy(1:2, 7), qx)
         call zmmpy_r1(mxy(1:2, 10), mxy(1:2, 12), qx)
         call zmdiv_r1(mxy(1:2, 10), mxy(1:2, 7), qx)
         call zmnegate(mxy(1:2, 10), qx)
         call zmeq(mxy(1:2, 9), mxy(1:2, 8), qx)
         call zmeq(mxy(1:2, 7), mxy(1:2, 9), qx)
         call fmndig(ndsav2, qx)
         call zmadd_r1(mxy(1:2, 14), mxy(1:2, 10), qx)

!             Check for convergence.

         if (qx%kflag == 1 .and. k > 2) then
             exit
         endif
         kt = max(1000, int(2*qx%alogmt*ndsave))
         if (k > kt) then
             if (ksma < 0) then
                 call zmnegate(mxy(1:2, 1), qx)
             endif
             call zmerf_m2(mxy, mresult, ndsave, numtry, kflagx, x, qx)
             return
         endif
         call zmeq(mxy(1:2, 10), mxy(1:2, 13), qx)
         nd = mxy(1, 14)%mp(2)-mxy(1, 10)%mp(2)
         nd1 = mxy(2, 14)%mp(2)-mxy(2, 10)%mp(2)
         nd = min(ndsav2, max(qx%ngrd22, ndsav2-int(min(nd, nd1))))
         call fmndig(nd, qx)
         if (k == nterms) then
             call zmunknown(mresult, qx)
             qx%kflag = -4
             return
         endif
      enddo

      call zmeq(mxy(1:2, 14), mxy(1:2, 3), qx)
      if (ksma < 0) then
          call zmnegate(mxy(1:2, 3), qx)
      endif
      call fmndig(ndsav1, qx)

      call zmeq(mxy(1:2, 3), mresult, qx)

      return
      end subroutine zmerf_m3

      subroutine zmerf_m4(mxy, mresult, ndsave, numtry, kflagx, x, qx)

!  Method 4 for computing erf(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: xe
      integer :: j, j2, kl, ksma, kt, nd, nd1, ndsav1, nterm
      type(multi) :: mjsums(2, ljsums)
      double precision, external :: fmnterms
      logical, external :: fmcomp

!             Method 4.  Asymptotic series
!                        1 - ( Exp(-x**2) / Sqrt(Pi) ) *
!                            Sum_{k=0}**Infinity (  (-1)**k * poch(1/2,k) / x**(2*k+1) )

!             The series is  1/x - (1/2) / x**3  +  ( 1*3 )/(2**2) / x**5 - ( 1*3*5 )/(2**3) / x**7
!                            + ...

      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig-1), qx)
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, qx%ndig, qx)
      ksma = mxy(1, 1)%mp(1)
      if (ksma < 0) then
          call zmnegate(mxy(1:2, 1), qx)
      endif
      if (kflagx == 0) then
          j2 = int(0.66*sqrt(fmnterms(x**2, 1, 0, 0, 0, qx)) - 0.8)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call zmsqr(mxy(1:2, 1), mxy(1:2, 15), qx)
      call zmmpyi(mxy(1:2, 15), 2, mxy(1:2, 7), qx)
      call zmi2m(1, mxy(1:2, 8), qx)
      call zmdiv(mxy(1:2, 8), mxy(1:2, 7), mxy(1:2, 6), qx)
      call zmi2m(1, mjsums(1:2, 1), qx)
      do j = 2, j2
         nterm = nterm + 1
         call zmmpyi_r1(mxy(1:2, 8), 2*nterm-3, qx)
         call zmeq(mxy(1:2, 8), mjsums(1:2, j), qx)
      enddo
      call zmabs(mxy(1:2, 1), mxy(1, 15), qx)
      call fmovun_xe(mxy(1, 15), xe, qx)
      if (xe < -qx%ndig) then
          kl = 0
      else
          kl = 1
          call zmipwr(mxy(1:2, 6), j2, mxy(1:2, 7), qx)
          call zmi2m(-31, mxy(1:2, 13), qx)
      endif

      do while (kl == 1)
         call zmmpy_r2(mxy(1:2, 7), mxy(1:2, 8), qx)
         do j = 1, j2
            nterm = nterm + 1
            call zmmpyi_r1(mxy(1:2, 8), 2*nterm-3, qx)
            call fmndig(ndsav1, qx)
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 8), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            kt = max(19000, int(6*qx%alogmt*ndsave))
            if (nterm > kt) then
                call zmabs(mxy(1:2, 8), mxy(1, 15), qx)
                call zmabs(mxy(1:2, 13), mxy(2, 15), qx)
                if (fmcomp(mxy(1, 15), '>', mxy(2, 15), qx)) then
                    if (ksma < 0) then
                        call zmnegate(mxy(1:2, 1), qx)
                    endif
                    call zmerf_m2(mxy, mresult, ndsave, numtry, kflagx, x, qx)
                    return
                endif
            endif
            call zmeq(mxy(1:2, 8), mxy(1:2, 13), qx)
            nd = mjsums(1, j)%mp(2)-mxy(1, 8)%mp(2)
            nd1 = mjsums(2, j)%mp(2)-mxy(2, 8)%mp(2)
            nd = ndsav1 - int(min(nd, nd1))
            call fmndig(min(ndsav1, nd), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         enddo
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call zmmpyi(mxy(1:2, 6), -1, mxy(1:2, 4), qx)
      call zmi2m(1, mxy(1:2, 5), qx)
      do j = 2, j2
         call zmmpy_r1(mxy(1:2, 5), mxy(1:2, 4), qx)
         call zmmpy(mxy(1:2, 5), mjsums(1:2, j), mxy(1:2, 15), qx)
         call zmadd(mxy(1:2, 15), mjsums(1:2, 1), mxy(1:2, 8), qx)
         call zmeq(mxy(1:2, 8), mjsums(1:2, 1), qx)
      enddo
      call fmmpy(mxy(1, 1), mxy(2, 1), mxy(2, 15), qx)
      call fmmpyi_r1(mxy(2, 15), -2, qx)
      call fmi2m(0, mxy(1, 15), qx)
      call zmexp(mxy(1:2, 15), mxy(1:2, 14), qx)
      call zmmpy(mjsums(1:2, 1), mxy(1:2, 14), mxy(1:2, 15), qx)
      call fmpi(mxy(1, 4), qx)
      qx%ndigpi = 0
      call fmsqrt(mxy(1, 4), mxy(1, 8), qx)
      call fmi2m(0, mxy(2, 8), qx)
      call zmmpy(mxy(1:2, 8), mxy(1:2, 1), mxy(1:2, 14), qx)
      call zmdiv(mxy(1:2, 15), mxy(1:2, 14), mxy(1:2, 13), qx)
      call fmadd(mxy(2, 1), mxy(1, 1), mxy(1, 12), qx)
      call fmsub(mxy(2, 1), mxy(1, 1), mxy(1, 11), qx)
      call fmmpy(mxy(1, 12), mxy(1, 11), mxy(1, 10), qx)
      call fmexp(mxy(1, 10), mxy(1, 12), qx)
      qx%ndige = 0
      call fmmpy(mxy(1, 13), mxy(1, 12), mxy(1, 4), qx)
      call fmmpy(mxy(2, 13), mxy(1, 12), mxy(2, 4), qx)

      if (mxy(1, 4)%mp(2) == qx%munkno .and. mxy(1, 4)%mp(5) >= 0) then
          call fmabs(mxy(1, 13), mxy(1, 14), qx)
          call fmln(mxy(1, 14), mxy(1, 15), qx)
          qx%ndigli = 0
          call fmadd(mxy(1, 10), mxy(1, 15), mxy(1, 14), qx)
          call fmexp(mxy(1, 14), mxy(1, 4), qx)
          qx%ndige = 0
          mxy(1, 4)%mp(1) = mxy(1, 13)%mp(1)
      endif
      if (mxy(2, 4)%mp(2) == qx%munkno .and. mxy(2, 4)%mp(5) >= 0) then
          call fmabs(mxy(2, 13), mxy(1, 14), qx)
          call fmln(mxy(1, 14), mxy(1, 15), qx)
          qx%ndigli = 0
          call fmadd(mxy(1, 10), mxy(1, 15), mxy(1, 14), qx)
          call fmexp(mxy(1, 14), mxy(2, 4), qx)
          qx%ndige = 0
          mxy(2, 4)%mp(1) = mxy(2, 13)%mp(1)
      endif
      call fmi2m(1, mxy(1, 15), qx)
      call fmulp(mxy(1, 15), mxy(2, 15), qx)
      call fmdiv(mxy(1, 1), mxy(2, 1), mxy(1, 15), qx)
      call fmsqr_r1(mxy(1, 15), qx)
      if (fmcomp(mxy(1, 15), '<', mxy(2, 15), qx)) then
          call zmi2m(0, mxy(1:2, 15), qx)
          call zmsub(mxy(1:2, 15), mxy(1:2, 4), mxy(1:2, 3), qx)
      else
          call zmi2m(1, mxy(1:2, 15), qx)
          call zmsub(mxy(1:2, 15), mxy(1:2, 4), mxy(1:2, 3), qx)
      endif

      if (ksma < 0) then
          call zmnegate(mxy(1:2, 3), qx)
      endif

      call zmeq(mxy(1:2, 3), mresult, qx)

      return
      end subroutine zmerf_m4

      subroutine zmerf_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = erf(ma).

!  kresult = 1 is returned if a special case gives the value of erf(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMERF    '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

!             If ma is real, use fmerf.

      if (malocal(2)%mp(3) == 0) then
          call fmerf(malocal(1), mresult(1), qx)
          call fmi2m(0, mresult(2), qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmerf_sc

      subroutine zmerfc(ma, mb, qx)

!  mb = erfc(ma)    Complimentary error function.

!  1 - 2/sqrt(pi) * integral from 0 to ma of e**(-t**2) dt.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(2, 15), mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmerfc_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call zmerfc_m(ma, mxy, mresult, ndsave, numtry, retry, qx)
         if (retry) then
             retry = .false.
             call zmcheck_accuracy(mresult, ndsave, retry, qx)
         endif
         numtry = numtry + 1
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmerfc

      subroutine zmerfc_m(ma, mxy, mresult, ndsave, numtry, retry, qx)

!  Method selection for computing erfc(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mxy(2, 15), mresult(2)
      integer :: ndsave, numtry
      logical :: retry
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, numtry, retry
      type(fm_settings) :: qx

      double precision :: c1, c2, c4, x, xe, xk
      integer :: kflagx, nmethd
      logical, external :: fmcomp

      retry = .true.

      call zmequ(ma, mxy(1:2, 1), ndsave, qx%ndig, qx)

!             Check for special cases.

      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
          call zmeq(mxy(1:2, 1), mresult, qx)
          retry = .false.
          return
      endif
      call zmabs(mxy(1:2, 1), mxy(1, 2), qx)
      call fmovun_xe(mxy(1, 2), xe, qx)
      if (xe <= -qx%ndig/2) then
          call fmpi(mxy(1, 3), qx)
          qx%ndigpi = 0
          call fmsqrt(mxy(1, 3), mxy(1, 4), qx)
          call fmi2m(2, mxy(1, 5), qx)
          call fmdiv(mxy(1, 5), mxy(1, 4), mxy(1, 6), qx)
          call fmmpy(mxy(1, 1), mxy(1, 6), mxy(1, 5), qx)
          call fmmpy(mxy(2, 1), mxy(1, 6), mxy(2, 5), qx)
          call zmi2m(1, mxy(1:2, 4), qx)
          call zmsub(mxy(1:2, 4), mxy(1:2, 5), mresult, qx)
          return
      endif

!             x is a double precision approximation to the size of input argument to this function.

      call zmabs(mxy(1:2, 1), mxy(1, 4), qx)
      call fmm2dp(mxy(1, 4), x, qx)
      kflagx = qx%kflag
      call fmovun_xe(mxy(1, 4), xe, qx)
      if (qx%kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax**0.33d0
          kflagx = 0
      else if (qx%kflag == 0 .and. x < 1.0d0/dpmax**0.33d0) then
          x = 1.0d0/dpmax**0.33d0
      endif
      if (qx%kflag /= 0 .and. xe > 0) then
          x = dpmax**0.33d0
          kflagx = 0
      else if (qx%kflag == 0 .and. x > dpmax**0.33d0) then
          x = dpmax**0.33d0
      endif

!             Determine which method to use.

!             nmethd = 1 use the convergent series,
!                    = 2 use a 2nd convergent series,
!                    = 3 use a continued fraction expansion,
!                    = 4 use an asymptotic series.

      xk = max(3.0d0, (2*x**2 + 1)/2)
      xk = -xk + log(2*xk-1)*(2*xk-0.5d0) + log(xk-1)*(-xk+0.5d0) - log(2.0d0)*(2*xk-1) -  &
           log(x)*(2*xk+1)
      if (-xk/qx%dlogmb > qx%ndig+(3+qx%ndig/20)*qx%ngrd52) then
          nmethd = 4
      else
          c4 = 5.0
          xk = 0.0
          do while (-xk/qx%dlogmb <= qx%ndig+(3+qx%ndig/20)*qx%ngrd52)
             c4 = 2 * c4
             xk = max(3.0d0, (2*c4**2 + 1)/2)
             xk = -xk + log(2*xk-1)*(2*xk-0.5d0) + log(xk-1)*(-xk+0.5d0) - log(2.0d0)*(2*xk-1) -  &
                  log(c4)*(2*xk+1)
          enddo
          c1 = c4/2
          do while (c4-c1 > 0.1)
             c2 = (c1 + c4) / 2
             xk = max(3.0d0, (2*c2**2 + 1)/2)
             xk = -xk + log(2*xk-1)*(2*xk-0.5d0) + log(xk-1)*(-xk+0.5d0) - log(2.0d0)*(2*xk-1) -  &
                  log(c2)*(2*xk+1)
             if (-xk/qx%dlogmb > qx%ndig+(3+qx%ndig/20)*qx%ngrd52) then
                 c4 = c2
             else
                 c1 = c2
             endif
          enddo
          call fmdiv(mxy(2, 1), mxy(1, 1), mxy(1, 15), qx)
          call fmabs(mxy(1, 15), mxy(2, 15), qx)
          call fmdp2m(1.5d0, mxy(1, 15), qx)
          if (fmcomp(mxy(2, 15), '>', mxy(1, 15), qx) .or. mxy(1, 1)%mp(3) == 0) then
              if (x > 0.8*c4) then
                  nmethd = 3
              else
                  nmethd = 1
              endif
          else
              if (x > 0.6*c4) then
                  nmethd = 3
              else if (x > 6.0) then
                  nmethd = 2
              else
                  nmethd = 1
              endif
          endif
      endif

      if (nmethd == 1) then
          call zmerfc_m1(mxy, mresult, ndsave, numtry, kflagx, x, qx)
      else if (nmethd == 2) then
          call zmerfc_m2(mxy, mresult, ndsave, numtry, kflagx, x, qx)
      else if (nmethd == 3) then
          call zmerfc_m3(mxy, mresult, ndsave, numtry, kflagx, x, qx)
      else if (nmethd == 4) then
          call zmerfc_m4(mxy, mresult, ndsave, numtry, kflagx, x, qx)
      endif

      if (ma(1)%mp(3) == 0) then
          if (mresult(2)%mp(2) /= qx%munkno) then
              call fmi2m(1, mresult(1), qx)
          endif
      endif

      return
      end subroutine zmerfc_m

      subroutine zmerfc_m1(mxy, mresult, ndsave, numtry, kflagx, x, qx)

!  Method 1 for computing erfc(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: xe
      integer :: iextra, j, j2, kl, nd, nd1, ndsav1, nterm
      type(multi) :: mjsums(2, ljsums)
      double precision, external :: fmnterms

!             Method 1.  Use the 1 - (-1)**n x**(2n+1) / n! / (2n+1) series.

!                        = 1 - ( 2 / sqrt(pi) ) * ( x - x**3/1! + x**5/2! - x**7/3! + ... )

      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig+qx%ngrd52), qx)
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, qx%ndig, qx)

!             If ma is large in magnitude or close to the real line, use more guard digits.

      call fmsqr(mxy(1, 1), mxy(1, 15), qx)
      call fmsqr(mxy(2, 1), mxy(2, 15), qx)
      call fmmpy(mxy(1, 1), mxy(2, 1), mxy(1, 14), qx)
      call fmst2m('-4.408443', mxy(1, 13), qx)

      call fmst2m(' 0.000832', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(1, 1), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m(' 0.002632', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(2, 1), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m(' 0.124034', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(1, 15), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m('-0.000291', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(1, 14), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m(' 0.001637', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(2, 15), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmm2i(mxy(1, 13), iextra, qx)
      iextra = max(0, nint((iextra+3) * 16.11809565d0 / qx%dlogmb)+1)
      if (iextra > 0) then
          call zmequ_r1(mxy(1:2, 1), qx%ndig, qx%ndig+iextra, qx)
      endif
      call fmndig(qx%ndig + iextra, qx)
      if (kflagx == 0) then
          j2 = int(0.66*sqrt(fmnterms(x**2, 1, 0, 0, 1, qx)) - 0.8)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call zmi2m(1, mxy(1:2, 6), qx)
      call zmi2m(1, mjsums(1:2, 1), qx)

      do j = 2, j2
         if (nterm > 1) then
             call zmdivi_r1(mxy(1:2, 6), nterm, qx)
         endif
         call zmdivi(mxy(1:2, 6), 2*nterm+1, mjsums(1:2, j), qx)
         nterm = nterm + 1
      enddo
      call zmabs(mxy(1:2, 1), mxy(1, 15), qx)
      call fmovun_xe(mxy(1, 15), xe, qx)
      if (xe < -qx%ndig) then
          kl = 0
      else
          kl = 1
          call zmipwr(mxy(1:2, 1), 2*j2, mxy(1:2, 5), qx)
      endif

      do while (kl == 1)
         call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 5), qx)
         do j = 1, j2
            call zmdivi_r1(mxy(1:2, 6), nterm, qx)
            call zmdivi(mxy(1:2, 6), 2*nterm+1, mxy(1:2, 4), qx)
            call fmndig(ndsav1, qx)
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 4), qx)
            if (qx%kflag == 1 .or. qx%kflag == -4) then
                kl = 0
                exit
            endif
            nd = mjsums(1, j)%mp(2)-mxy(1, 4)%mp(2)
            nd1 = mjsums(2, j)%mp(2)-mxy(2, 4)%mp(2)
            nd = ndsav1 - int(min(nd, nd1))
            call fmndig(min(ndsav1, nd), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
            nterm = nterm + 1
         enddo
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call zmsqr(mxy(1:2, 1), mxy(1:2, 4), qx)
      call zmnegate(mxy(1:2, 4), qx)
      call zmeq(mjsums(1:2, j2), mxy(1:2, 5), qx)

      do j = 2, j2
         call zmmpy(mxy(1:2, 5), mxy(1:2, 4), mxy(1:2, 15), qx)
         call zmadd(mxy(1:2, 15), mjsums(1:2, j2-j+1), mxy(1:2, 5), qx)
      enddo

      call zmmpy_r1(mxy(1:2, 5), mxy(1:2, 1), qx)

      call fmpi(mxy(1, 4), qx)
      qx%ndigpi = 0
      call fmi2m(0, mxy(2, 4), qx)
      call zmsqrt(mxy(1:2, 4), mxy(1:2, 3), qx)
      call zmmpyi(mxy(1:2, 5), 2, mxy(1:2, 4), qx)
      call zmdiv_r2(mxy(1:2, 4), mxy(1:2, 3), qx)

      call zmi2m(1, mxy(1:2, 15), qx)
      call zmsub_r2(mxy(1:2, 15), mxy(1:2, 3), qx)

      call zmeq(mxy(1:2, 3), mresult, qx)

      return
      end subroutine zmerfc_m1

      subroutine zmerfc_m2(mxy, mresult, ndsave, numtry, kflagx, x, qx)

!  Method 2 for computing erfc(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: xe
      integer :: iextra, j, j2, kl, nd, nd1, ndsav1, nterm
      type(multi) :: mjsums(2, ljsums)
      double precision, external :: fmnterms

!             Method 2.  Use the 1 - x**(2n+1) * 2**(n+1) / (1*3*5*...*(2n+1)) series.

      call fmsqr(mxy(1, 1), mxy(1, 15), qx)
      call fmsqr(mxy(2, 1), mxy(2, 15), qx)
      call fmmpy(mxy(1, 1), mxy(2, 1), mxy(1, 14), qx)
      call fmst2m('-1.966130', mxy(1, 13), qx)

      call fmst2m(' 0.002853', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(1, 1), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m('-0.001447', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(2, 1), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m(' 0.062040', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(1, 15), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m('-0.000063', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(1, 14), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m(' 0.061968', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(2, 15), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmm2i(mxy(1, 13), iextra, qx)
      iextra = max(0, nint((iextra+3) * 16.11809565d0 / qx%dlogmb)+1)
      call fmndig(qx%ndig + iextra, qx)
      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig) + 1, qx)
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, qx%ndig, qx)
      if (kflagx == 0) then
          j2 = int(0.51*sqrt(fmnterms(2*x, 2, -1, 0, 1, qx)))
      else
          j2 = 1
      endif
      j2 = max(1, min(ljsums, j2))
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call zmmpyi(mxy(1:2, 1), 2, mxy(1:2, 6), qx)
      call zmeq(mxy(1:2, 6), mjsums(1:2, 1), qx)
      do j = 2, j2
         call zmmpyi_r1(mxy(1:2, 6), 2, qx)
         call zmdivi_r1(mxy(1:2, 6), 2*nterm+1, qx)
         call zmeq(mxy(1:2, 6), mjsums(1:2, j), qx)
         nterm = nterm + 1
      enddo
      call zmabs(mxy(1:2, 1), mxy(1, 15), qx)
      call fmovun_xe(mxy(1, 15), xe, qx)
      if (xe < -qx%ndig) then
          kl = 0
      else
          kl = 1
          call zmipwr(mxy(1:2, 1), 2*j2, mxy(1:2, 5), qx)
      endif

      do while (kl == 1)
         call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 5), qx)
         do j = 1, j2
            call zmmpyi(mxy(1:2, 6), 2, mxy(1:2, 15), qx)
            call zmdivi(mxy(1:2, 15), 2*nterm+1, mxy(1:2, 6), qx)
            call fmndig(ndsav1, qx)
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 6), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            nd = mjsums(1, j)%mp(2)-mxy(1, 6)%mp(2)
            nd1 = mjsums(2, j)%mp(2)-mxy(2, 6)%mp(2)
            nd = ndsav1 - int(min(nd, nd1))
            call fmndig(min(ndsav1, nd), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
            nterm = nterm + 1
         enddo
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call zmsqr(mxy(1:2, 1), mxy(1:2, 6), qx)
      call zmeq(mjsums(1:2, j2), mxy(1:2, 5), qx)
      do j = 2, j2
         call zmmpy(mxy(1:2, 5), mxy(1:2, 6), mxy(1:2, 15), qx)
         call zmadd(mxy(1:2, 15), mjsums(1:2, j2-j+1), mxy(1:2, 5), qx)
      enddo

      call fmpi(mxy(1, 4), qx)
      qx%ndigpi = 0
      call fmi2m(0, mxy(2, 4), qx)
      call zmsqrt(mxy(1:2, 4), mxy(1:2, 3), qx)
      call zmdiv_r2(mxy(1:2, 5), mxy(1:2, 3), qx)
      call zmexp(mxy(1:2, 6), mxy(1:2, 4), qx)
      call zmdiv_r1(mxy(1:2, 3), mxy(1:2, 4), qx)

      call zmi2m(1, mxy(1:2, 15), qx)
      call zmsub_r2(mxy(1:2, 15), mxy(1:2, 3), qx)

      call zmeq(mxy(1:2, 3), mresult, qx)

      return
      end subroutine zmerfc_m2

      subroutine zmerfc_m3(mxy, mresult, ndsave, numtry, kflagx, x, qx)

!  Method 3 for computing erfc(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: k, ksma, kt, nd, nd1, ndsav1, ndsav2, nterms
      logical, external :: fmcomp

!             Method 3.  Continued fraction expansion (asymptotic).
!                        Used for Re(x) > 0.
!                        For Re(x) < 0, use   erfc(x) = 1 - erf(x) = 1 + erf(-x) = 2 - erfc(-x).

!                                  erfc(x) = 0 + exp(-x**2)/sqrt(pi) /
!                                                                 x + 1 /
!                                                                   2*x + 2 /
!                                                                         x + 3 /
!                                                                           2*x + 4 /
!                                                                                 x + 5 ...

      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig) + 1, qx)
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, qx%ndig, qx)
      ndsav1 = qx%ndig
      ksma = mxy(1, 1)%mp(1)
      if (ksma < 0) then
          call zmnegate(mxy(1:2, 1), qx)
      endif

      call zmeq(mxy(1:2, 1), mxy(1:2, 2), qx)

      call zmsqr(mxy(1:2, 2), mxy(1:2, 4), qx)
      call zmmpyi(mxy(1:2, 4), -1, mxy(1:2, 15), qx)
      call zmexp(mxy(1:2, 15), mxy(1:2, 10), qx)
      call zmeq(mxy(1:2, 10), mxy(1:2, 15), qx)
      call fmpi(mxy(1, 10), qx)
      qx%ndigpi = 0
      call fmsqrt_r1(mxy(1, 10), qx)
      call fmi2m(0, mxy(2, 10), qx)
      call zmdiv_r2(mxy(1:2, 15), mxy(1:2, 10), qx)
      call zmdiv_r1(mxy(1:2, 10), mxy(1:2, 2), qx)
      call zmi2m(-31, mxy(1:2, 13), qx)

      call zmeq(mxy(1:2, 10), mxy(1:2, 14), qx)
      call zmi2m(1, mxy(1:2, 8), qx)
      call zmeq(mxy(1:2, 2), mxy(1:2, 9), qx)
      nterms = int(intmax/10)

!             Continued fraction loop.

      ndsav2 = qx%ndig
      do k = 3, nterms
         call zmmpyi(mxy(1:2, 2), 1+mod(k, 2), mxy(1:2, 11), qx)
         call zmmpy_r1(mxy(1:2, 11), mxy(1:2, 9), qx)
         call zmmpyi(mxy(1:2, 8), k-2, mxy(1:2, 12), qx)
         call zmadd(mxy(1:2, 11), mxy(1:2, 12), mxy(1:2, 7), qx)
         call zmmpy_r1(mxy(1:2, 10), mxy(1:2, 12), qx)
         call zmdiv_r1(mxy(1:2, 10), mxy(1:2, 7), qx)
         call zmnegate(mxy(1:2, 10), qx)
         call zmeq(mxy(1:2, 9), mxy(1:2, 8), qx)
         call zmeq(mxy(1:2, 7), mxy(1:2, 9), qx)
         call fmndig(ndsav2, qx)
         call zmadd_r1(mxy(1:2, 14), mxy(1:2, 10), qx)

!             Check for convergence.

         if (qx%kflag == 1 .and. k > 2) then
             exit
         endif
         kt = max(1000, int(5*qx%alogmt*ndsave))
         if (k > kt) then
             call zmerfc_m2(mxy, mresult, ndsave, numtry, kflagx, x, qx)
             return
         endif
         call zmeq(mxy(1:2, 10), mxy(1:2, 13), qx)
         nd = mxy(1, 14)%mp(2)-mxy(1, 10)%mp(2)
         nd1 = mxy(2, 14)%mp(2)-mxy(2, 10)%mp(2)
         nd = min(ndsav2, max(qx%ngrd22, ndsav2-int(min(nd, nd1))))
         call fmndig(nd, qx)
         if (k == nterms) then
             call zmunknown(mresult, qx)
             qx%kflag = -4
             return
         endif
      enddo

      call fmi2m(1, mxy(1, 15), qx)
      call fmulp(mxy(1, 15), mxy(2, 15), qx)
      call fmdiv(mxy(1, 1), mxy(2, 1), mxy(1, 15), qx)
      call fmsqr_r1(mxy(1, 15), qx)
      if (fmcomp(mxy(1, 15), '<', mxy(2, 15), qx)) then
          call fmi2m(1, mxy(1, 15), qx)
          call fmadd_r2(mxy(1, 15), mxy(1, 14), qx)
      endif
      call zmeq(mxy(1:2, 14), mxy(1:2, 3), qx)
      if (ksma < 0) then
          call zmi2m(2, mxy(1:2, 15), qx)
          call zmsub_r2(mxy(1:2, 15), mxy(1:2, 3), qx)
      endif
      call fmndig(ndsav1, qx)

      call zmeq(mxy(1:2, 3), mresult, qx)

      return
      end subroutine zmerfc_m3

      subroutine zmerfc_m4(mxy, mresult, ndsave, numtry, kflagx, x, qx)

!  Method 4 for computing erfc(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: xe
      integer :: j, j2, kl, ksma, kt, nd, nd1, ndsav1, nterm
      type(multi) :: mjsums(2, ljsums)
      double precision, external :: fmnterms
      logical, external :: fmcomp

!             Method 4.  Asymptotic series
!
!                        For Re(x) >= 0,
!                        erfc(x) = ( Exp(-x**2) / Sqrt(Pi) ) *
!                                  Sum_{k=0}**Infinity (  (-1)**k * poch(1/2,k) / x**(2*k+1) )

!                        For Re(x) < 0, use   erfc(x) = 1 - erf(x) = 1 + erf(-x) = 2 - erfc(-x).

!             The series is  1/x - (1/2) / x**3  +  ( 1*3 )/(2**2) / x**5 - ( 1*3*5 )/(2**3) / x**7
!                            + ...

      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig-1), qx)
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, qx%ndig, qx)
      ksma = mxy(1, 1)%mp(1)
      if (ksma < 0) then
          call zmnegate(mxy(1:2, 1), qx)
      endif
      if (kflagx == 0) then
          j2 = int(0.66*sqrt(fmnterms(x**2, 1, 0, 0, 0, qx)) - 0.8)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call zmsqr(mxy(1:2, 1), mxy(1:2, 15), qx)
      call zmmpyi(mxy(1:2, 15), 2, mxy(1:2, 7), qx)
      call zmi2m(1, mxy(1:2, 8), qx)
      call zmdiv(mxy(1:2, 8), mxy(1:2, 7), mxy(1:2, 6), qx)
      call zmi2m(1, mjsums(1:2, 1), qx)
      do j = 2, j2
         nterm = nterm + 1
         call zmmpyi_r1(mxy(1:2, 8), 2*nterm-3, qx)
         call zmeq(mxy(1:2, 8), mjsums(1:2, j), qx)
      enddo
      call zmabs(mxy(1:2, 1), mxy(1, 15), qx)
      call fmovun_xe(mxy(1, 15), xe, qx)
      if (xe < -qx%ndig) then
          kl = 0
      else
          kl = 1
          call zmipwr(mxy(1:2, 6), j2, mxy(1:2, 7), qx)
          call zmi2m(-31, mxy(1:2, 13), qx)
      endif

      do while (kl == 1)
         call zmmpy_r2(mxy(1:2, 7), mxy(1:2, 8), qx)
         do j = 1, j2
            nterm = nterm + 1
            call zmmpyi_r1(mxy(1:2, 8), 2*nterm-3, qx)
            call fmndig(ndsav1, qx)
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 8), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            kt = max(19000, int(6*qx%alogmt*ndsave))
            if (nterm > kt) then
                call zmabs(mxy(1:2, 8), mxy(1, 15), qx)
                call zmabs(mxy(1:2, 13), mxy(2, 15), qx)
                if (fmcomp(mxy(1, 15), '>', mxy(2, 15), qx)) then
                    call zmerfc_m2(mxy, mresult, ndsave, numtry, kflagx, x, qx)
                    return
                endif
            endif
            call zmeq(mxy(1:2, 8), mxy(1:2, 13), qx)
            nd = mjsums(1, j)%mp(2)-mxy(1, 8)%mp(2)
            nd1 = mjsums(2, j)%mp(2)-mxy(2, 8)%mp(2)
            nd = ndsav1 - int(min(nd, nd1))
            call fmndig(min(ndsav1, nd), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         enddo
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call zmmpyi(mxy(1:2, 6), -1, mxy(1:2, 4), qx)
      call zmi2m(1, mxy(1:2, 5), qx)
      do j = 2, j2
         call zmmpy_r1(mxy(1:2, 5), mxy(1:2, 4), qx)
         call zmmpy(mxy(1:2, 5), mjsums(1:2, j), mxy(1:2, 15), qx)
         call zmadd(mxy(1:2, 15), mjsums(1:2, 1), mxy(1:2, 8), qx)
         call zmeq(mxy(1:2, 8), mjsums(1:2, 1), qx)
      enddo
      call fmmpy(mxy(1, 1), mxy(2, 1), mxy(2, 15), qx)
      call fmmpyi_r1(mxy(2, 15), -2, qx)
      call fmi2m(0, mxy(1, 15), qx)
      call zmexp(mxy(1:2, 15), mxy(1:2, 14), qx)
      call zmmpy(mjsums(1:2, 1), mxy(1:2, 14), mxy(1:2, 15), qx)
      call fmpi(mxy(1, 4), qx)
      qx%ndigpi = 0
      call fmsqrt(mxy(1, 4), mxy(1, 8), qx)
      call fmi2m(0, mxy(2, 8), qx)
      call zmmpy(mxy(1:2, 8), mxy(1:2, 1), mxy(1:2, 14), qx)
      call zmdiv(mxy(1:2, 15), mxy(1:2, 14), mxy(1:2, 13), qx)
      call fmadd(mxy(2, 1), mxy(1, 1), mxy(1, 12), qx)
      call fmsub(mxy(2, 1), mxy(1, 1), mxy(1, 11), qx)
      call fmmpy(mxy(1, 12), mxy(1, 11), mxy(1, 10), qx)
      call fmexp(mxy(1, 10), mxy(1, 12), qx)
      qx%ndige = 0
      call fmmpy(mxy(1, 13), mxy(1, 12), mxy(1, 4), qx)
      call fmmpy(mxy(2, 13), mxy(1, 12), mxy(2, 4), qx)
      if (mxy(1, 4)%mp(2) == qx%munkno .and. mxy(1, 4)%mp(5) >= 0) then
          call fmabs(mxy(1, 13), mxy(1, 14), qx)
          call fmln(mxy(1, 14), mxy(1, 15), qx)
          qx%ndigli = 0
          call fmadd(mxy(1, 10), mxy(1, 15), mxy(1, 14), qx)
          call fmexp(mxy(1, 14), mxy(1, 4), qx)
          qx%ndige = 0
          mxy(1, 4)%mp(1) = mxy(1, 13)%mp(1)
      endif
      if (mxy(2, 4)%mp(2) == qx%munkno .and. mxy(2, 4)%mp(5) >= 0) then
          call fmabs(mxy(2, 13), mxy(1, 14), qx)
          call fmln(mxy(1, 14), mxy(1, 15), qx)
          qx%ndigli = 0
          call fmadd(mxy(1, 10), mxy(1, 15), mxy(1, 14), qx)
          call fmexp(mxy(1, 14), mxy(2, 4), qx)
          qx%ndige = 0
          mxy(2, 4)%mp(1) = mxy(2, 13)%mp(1)
      endif

      call fmi2m(1, mxy(1, 15), qx)
      call fmulp(mxy(1, 15), mxy(2, 15), qx)
      call fmdiv(mxy(1, 1), mxy(2, 1), mxy(1, 15), qx)
      call fmsqr_r1(mxy(1, 15), qx)
      if (fmcomp(mxy(1, 15), '<', mxy(2, 15), qx)) then
          call fmi2m(1, mxy(1, 15), qx)
          call fmadd_r2(mxy(1, 15), mxy(1, 4), qx)
      endif

      if (ksma < 0) then
          call zmi2m(2, mxy(1:2, 15), qx)
          call zmsub(mxy(1:2, 15), mxy(1:2, 4), mxy(1:2, 3), qx)
      else
          call zmeq(mxy(1:2, 4), mxy(1:2, 3), qx)
      endif

      call zmeq(mxy(1:2, 3), mresult, qx)

      return
      end subroutine zmerfc_m4

      subroutine zmerfc_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = erfc(ma).

!  kresult = 1 is returned if a special case gives the value of erfc(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMERFC   '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

!             If ma is real, use fmerfc.

      if (malocal(2)%mp(3) == 0) then
          call fmerfc(malocal(1), mresult(1), qx)
          call fmi2m(0, mresult(2), qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmerfc_sc

      subroutine zmerfcs(ma, mb, qx)

!  mb = exp(ma**2) * erfc(ma)    Scaled complimentary error function.

!  erfc(z) underflows for relatively small magnitude |z| in the right half-plane (re(z) >= 0).
!  Multiplying by exp(z**2) allows the scaled complimentary error function to be computed even
!  when |z| is large and re(z) >= 0.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(2, 15), mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmerfcs_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call zmerfcs_m(ma, mxy, mresult, ndsave, numtry, retry, qx)
         if (ma(1)%mp(3) == 0) then
             if (mresult(2)%mp(2) /= qx%munkno) then
                 call fmsqr(mxy(2, 1), mxy(1, 4), qx)
                 call fmnegate(mxy(1, 4), qx)
                 call fmexp(mxy(1, 4), mresult(1), qx)
                 qx%ndige = 0
             endif
         endif
         if (retry) then
             retry = .false.
             call zmcheck_accuracy(mresult, ndsave, retry, qx)
         endif
         numtry = numtry + 1
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmerfcs

      subroutine zmerfcs_m(ma, mxy, mresult, ndsave, numtry, retry, qx)

!  Method selection for computing erfcs(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mxy(2, 15), mresult(2)
      integer :: ndsave, numtry
      logical :: retry
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, numtry, retry
      type(fm_settings) :: qx

      double precision :: c1, c2, c4, x, xe, xk
      integer :: kflagx, nmethd
      logical, external :: fmcomp

      retry = .true.

      call zmequ(ma, mxy(1:2, 1), ndsave, qx%ndig, qx)

!             Check for special cases.

      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
          call zmi2m(1, mresult, qx)
          retry = .false.
          return
      endif
      call zmabs(mxy(1:2, 1), mxy(1, 2), qx)
      call fmovun_xe(mxy(1, 2), xe, qx)
      if (xe <= -qx%ndig/2) then
          call fmpi(mxy(1, 3), qx)
          qx%ndigpi = 0
          call fmsqrt(mxy(1, 3), mxy(1, 4), qx)
          call fmi2m(2, mxy(1, 5), qx)
          call fmdiv(mxy(1, 5), mxy(1, 4), mxy(1, 6), qx)
          call fmmpy(mxy(1, 1), mxy(1, 6), mxy(1, 5), qx)
          call fmmpy(mxy(2, 1), mxy(1, 6), mxy(2, 5), qx)
          call zmi2m(1, mxy(1:2, 4), qx)
          call zmsub(mxy(1:2, 4), mxy(1:2, 5), mresult, qx)
          return
      else if (xe >= qx%ndig/2) then
          if (mxy(1, 1)%mp(1) > 0) then
              call zmeq(mxy(1:2, 1), mxy(1:2, 6), qx)
          else
              call zmmpyi(mxy(1:2, 1), -1, mxy(1:2, 6), qx)
          endif
          call fmpi(mxy(1, 3), qx)
          qx%ndigpi = 0
          call fmsqrt(mxy(1, 3), mxy(1, 4), qx)
          call fmmpy(mxy(1, 6), mxy(1, 4), mxy(1, 5), qx)
          call fmmpy(mxy(2, 6), mxy(1, 4), mxy(2, 5), qx)
          call zmi2m(1, mxy(1:2, 4), qx)
          call zmdiv(mxy(1:2, 4), mxy(1:2, 5), mxy(1:2, 3), qx)
          if (mxy(1, 1)%mp(1) < 0) then
              call zmsqr(mxy(1:2, 1), mxy(1:2, 5), qx)
              call zmexp(mxy(1:2, 5), mxy(1:2, 4), qx)
              call zmmpyi(mxy(1:2, 4), 2, mxy(1:2, 5), qx)
              call zmsub(mxy(1:2, 5), mxy(1:2, 3), mxy(1:2, 4), qx)
              call zmeq(mxy(1:2, 4), mxy(1:2, 3), qx)
          endif
          call zmeq(mxy(1:2, 3), mresult, qx)
          return
      endif

!             x is a double precision approximation to the size of input argument to this function.

      call zmabs(mxy(1:2, 1), mxy(1, 4), qx)
      call fmm2dp(mxy(1, 4), x, qx)
      kflagx = qx%kflag
      call fmovun_xe(mxy(1, 4), xe, qx)
      if (qx%kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax**0.33d0
          kflagx = 0
      else if (qx%kflag == 0 .and. x < 1.0d0/dpmax**0.33d0) then
          x = 1.0d0/dpmax**0.33d0
      endif
      if (qx%kflag /= 0 .and. xe > 0) then
          x = dpmax**0.33d0
          kflagx = 0
      else if (qx%kflag == 0 .and. x > dpmax**0.33d0) then
          x = dpmax**0.33d0
      endif

!             Determine which method to use.

!             nmethd = 1 use the convergent series,
!                    = 2 use a 2nd convergent series,
!                    = 3 use a continued fraction expansion,
!                    = 4 use an asymptotic series.

      xk = max(3.0d0, (2*x**2 + 1)/2)
      xk = -xk + log(2*xk-1)*(2*xk-0.5d0) + log(xk-1)*(-xk+0.5d0) - log(2.0d0)*(2*xk-1) -  &
           log(x)*(2*xk+1)
      if (-xk/qx%dlogmb > qx%ndig+(3+qx%ndig/20)*qx%ngrd52) then
          nmethd = 4
      else
          c4 = 5.0
          xk = 0.0
          do while (-xk/qx%dlogmb <= qx%ndig+(3+qx%ndig/20)*qx%ngrd52)
             c4 = 2 * c4
             xk = max(3.0d0, (2*c4**2 + 1)/2)
             xk = -xk + log(2*xk-1)*(2*xk-0.5d0) + log(xk-1)*(-xk+0.5d0) - log(2.0d0)*(2*xk-1) -  &
                  log(c4)*(2*xk+1)
          enddo
          c1 = c4/2
          do while (c4-c1 > 0.1)
             c2 = (c1 + c4) / 2
             xk = max(3.0d0, (2*c2**2 + 1)/2)
             xk = -xk + log(2*xk-1)*(2*xk-0.5d0) + log(xk-1)*(-xk+0.5d0) - log(2.0d0)*(2*xk-1) -  &
                  log(c2)*(2*xk+1)
             if (-xk/qx%dlogmb > qx%ndig+(3+qx%ndig/20)*qx%ngrd52) then
                 c4 = c2
             else
                 c1 = c2
             endif
          enddo
          call fmdiv(mxy(2, 1), mxy(1, 1), mxy(1, 15), qx)
          call fmabs(mxy(1, 15), mxy(2, 15), qx)
          call fmdp2m(1.5d0, mxy(1, 15), qx)
          if (fmcomp(mxy(2, 15), '>', mxy(1, 15), qx) .or. mxy(1, 1)%mp(3) == 0) then
              if (x > 0.8*c4) then
                  nmethd = 3
              else
                  nmethd = 1
              endif
          else
              if (x > 0.6*c4) then
                  nmethd = 3
              else if (x > 6.0) then
                  nmethd = 2
              else
                  nmethd = 1
              endif
          endif
      endif

      if (nmethd == 1) then
          call zmerfcs_m1(mxy, mresult, ndsave, numtry, kflagx, x, qx)
      else if (nmethd == 2) then
          call zmerfcs_m2(mxy, mresult, ndsave, numtry, kflagx, x, qx)
      else if (nmethd == 3) then
          call zmerfcs_m3(mxy, mresult, ndsave, numtry, kflagx, x, qx)
      else if (nmethd == 4) then
          call zmerfcs_m4(mxy, mresult, ndsave, numtry, kflagx, x, qx)
      endif

      return
      end subroutine zmerfcs_m

      subroutine zmerfcs_m1(mxy, mresult, ndsave, numtry, kflagx, x, qx)

!  Method 1 for computing erfcs(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: xe
      integer :: iextra, j, j2, kl, nd, nd1, ndsav1, nterm
      type(multi) :: mjsums(2, ljsums)
      double precision, external :: fmnterms


!             Method 1.  Use the 1 - (-1)**n x**(2n+1) / n! / (2n+1) series.

!                        exp(x**2) * ( 1 - (2/sqrt(pi))*( x - x**3/1! + x**5/2! - x**7/3! + ... ) )

      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig+qx%ngrd52), qx)
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, qx%ndig, qx)

!             If ma is large in magnitude or close to the real line, use more guard digits.

      call fmsqr(mxy(1, 1), mxy(1, 15), qx)
      call fmsqr(mxy(2, 1), mxy(2, 15), qx)
      call fmmpy(mxy(1, 1), mxy(2, 1), mxy(1, 14), qx)
      call fmst2m('-4.408443', mxy(1, 13), qx)

      call fmst2m(' 0.000832', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(1, 1), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m(' 0.002632', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(2, 1), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m(' 0.124034', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(1, 15), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m('-0.000291', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(1, 14), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m(' 0.001637', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(2, 15), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmm2i(mxy(1, 13), iextra, qx)
      iextra = max(0, nint((iextra+3) * 16.11809565d0 / qx%dlogmb)+1)
      if (iextra > 0) then
          call zmequ_r1(mxy(1:2, 1), qx%ndig, qx%ndig+iextra, qx)
      endif
      call fmndig(qx%ndig + iextra, qx)
      if (kflagx == 0) then
          j2 = int(0.66*sqrt(fmnterms(x**2, 1, 0, 0, 1, qx)) - 0.8)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call zmi2m(1, mxy(1:2, 6), qx)
      call zmi2m(1, mjsums(1:2, 1), qx)

      do j = 2, j2
         if (nterm > 1) then
             call zmdivi_r1(mxy(1:2, 6), nterm, qx)
         endif
         call zmdivi(mxy(1:2, 6), 2*nterm+1, mjsums(1:2, j), qx)
         nterm = nterm + 1
      enddo
      call zmabs(mxy(1:2, 1), mxy(1, 15), qx)
      call fmovun_xe(mxy(1, 15), xe, qx)
      if (xe < -qx%ndig) then
          kl = 0
      else
          kl = 1
          call zmipwr(mxy(1:2, 1), 2*j2, mxy(1:2, 5), qx)
      endif

      do while (kl == 1)
         call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 5), qx)
         do j = 1, j2
            call zmdivi_r1(mxy(1:2, 6), nterm, qx)
            call zmdivi(mxy(1:2, 6), 2*nterm+1, mxy(1:2, 4), qx)
            call fmndig(ndsav1, qx)
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 4), qx)
            if (qx%kflag == 1 .or. qx%kflag == -4) then
                kl = 0
                exit
            endif
            nd = mjsums(1, j)%mp(2)-mxy(1, 4)%mp(2)
            nd1 = mjsums(2, j)%mp(2)-mxy(2, 4)%mp(2)
            nd = ndsav1 - int(min(nd, nd1))
            call fmndig(min(ndsav1, nd), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
            nterm = nterm + 1
         enddo
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call zmsqr(mxy(1:2, 1), mxy(1:2, 4), qx)
      call zmnegate(mxy(1:2, 4), qx)
      call zmeq(mjsums(1:2, j2), mxy(1:2, 5), qx)

      do j = 2, j2
         call zmmpy(mxy(1:2, 5), mxy(1:2, 4), mxy(1:2, 15), qx)
         call zmadd(mxy(1:2, 15), mjsums(1:2, j2-j+1), mxy(1:2, 5), qx)
      enddo

      call zmmpy_r1(mxy(1:2, 5), mxy(1:2, 1), qx)

      call fmpi(mxy(1, 4), qx)
      qx%ndigpi = 0
      call fmi2m(0, mxy(2, 4), qx)
      call zmsqrt(mxy(1:2, 4), mxy(1:2, 3), qx)
      call zmmpyi(mxy(1:2, 5), 2, mxy(1:2, 4), qx)
      call zmdiv_r2(mxy(1:2, 4), mxy(1:2, 3), qx)

      call zmi2m(1, mxy(1:2, 15), qx)
      call zmsub_r2(mxy(1:2, 15), mxy(1:2, 3), qx)
      call zmsqr(mxy(1:2, 1), mxy(1:2, 15), qx)
      call zmexp(mxy(1:2, 15), mxy(1:2, 14), qx)
      call zmmpy_r1(mxy(1:2, 3), mxy(1:2, 14), qx)

      call zmeq(mxy(1:2, 3), mresult, qx)

      return
      end subroutine zmerfcs_m1

      subroutine zmerfcs_m2(mxy, mresult, ndsave, numtry, kflagx, x, qx)

!  Method 2 for computing erfcs(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: xe
      integer :: iextra, j, j2, kl, nd, nd1, ndsav1, nterm
      type(multi) :: mjsums(2, ljsums)
      double precision, external :: fmnterms


!             Method 2.  Use the 1 - x**(2n+1) * 2**(n+1) / (1*3*5*...*(2n+1)) series.

!                        exp(x**2) * ( 1 - x**(2n+1) * 2**(n+1) / (1*3*5*...*(2n+1)) )

      call fmsqr(mxy(1, 1), mxy(1, 15), qx)
      call fmsqr(mxy(2, 1), mxy(2, 15), qx)
      call fmmpy(mxy(1, 1), mxy(2, 1), mxy(1, 14), qx)
      call fmst2m('-1.966130', mxy(1, 13), qx)

      call fmst2m(' 0.002853', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(1, 1), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m('-0.001447', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(2, 1), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m(' 0.062040', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(1, 15), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m('-0.000063', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(1, 14), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmst2m(' 0.061968', mxy(2, 13), qx)
      call fmmpy_r1(mxy(2, 13), mxy(2, 15), qx)
      call fmadd_r1(mxy(1, 13), mxy(2, 13), qx)

      call fmm2i(mxy(1, 13), iextra, qx)
      iextra = max(0, nint((iextra+3) * 16.11809565d0 / qx%dlogmb)+1)
      call fmndig(qx%ndig + iextra, qx)
      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig) + 1, qx)
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, qx%ndig, qx)
      if (kflagx == 0) then
          j2 = int(0.51*sqrt(fmnterms(2*x, 2, -1, 0, 1, qx)))
      else
          j2 = 1
      endif
      j2 = max(1, min(ljsums, j2))
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call zmmpyi(mxy(1:2, 1), 2, mxy(1:2, 6), qx)
      call zmeq(mxy(1:2, 6), mjsums(1:2, 1), qx)
      do j = 2, j2
         call zmmpyi_r1(mxy(1:2, 6), 2, qx)
         call zmdivi_r1(mxy(1:2, 6), 2*nterm+1, qx)
         call zmeq(mxy(1:2, 6), mjsums(1:2, j), qx)
         nterm = nterm + 1
      enddo
      call zmabs(mxy(1:2, 1), mxy(1, 15), qx)
      call fmovun_xe(mxy(1, 15), xe, qx)
      if (xe < -qx%ndig) then
          kl = 0
      else
          kl = 1
          call zmipwr(mxy(1:2, 1), 2*j2, mxy(1:2, 5), qx)
      endif

      do while (kl == 1)
         call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 5), qx)
         do j = 1, j2
            call zmmpyi(mxy(1:2, 6), 2, mxy(1:2, 15), qx)
            call zmdivi(mxy(1:2, 15), 2*nterm+1, mxy(1:2, 6), qx)
            call fmndig(ndsav1, qx)
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 6), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            nd = mjsums(1, j)%mp(2)-mxy(1, 6)%mp(2)
            nd1 = mjsums(2, j)%mp(2)-mxy(2, 6)%mp(2)
            nd = ndsav1 - int(min(nd, nd1))
            call fmndig(min(ndsav1, nd), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
            nterm = nterm + 1
         enddo
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call zmsqr(mxy(1:2, 1), mxy(1:2, 6), qx)
      call zmeq(mjsums(1:2, j2), mxy(1:2, 5), qx)
      do j = 2, j2
         call zmmpy(mxy(1:2, 5), mxy(1:2, 6), mxy(1:2, 15), qx)
         call zmadd(mxy(1:2, 15), mjsums(1:2, j2-j+1), mxy(1:2, 5), qx)
      enddo

      call fmpi(mxy(1, 4), qx)
      qx%ndigpi = 0
      call fmi2m(0, mxy(2, 4), qx)
      call zmsqrt(mxy(1:2, 4), mxy(1:2, 3), qx)
      call zmdiv_r2(mxy(1:2, 5), mxy(1:2, 3), qx)
      call zmexp(mxy(1:2, 6), mxy(1:2, 4), qx)
      call zmdiv_r1(mxy(1:2, 3), mxy(1:2, 4), qx)

      call zmi2m(1, mxy(1:2, 15), qx)
      call zmsub_r2(mxy(1:2, 15), mxy(1:2, 3), qx)

      call zmsqr(mxy(1:2, 1), mxy(1:2, 15), qx)
      call zmexp(mxy(1:2, 15), mxy(1:2, 14), qx)
      call zmmpy_r1(mxy(1:2, 3), mxy(1:2, 14), qx)

      call zmeq(mxy(1:2, 3), mresult, qx)

      return
      end subroutine zmerfcs_m2

      subroutine zmerfcs_m3(mxy, mresult, ndsave, numtry, kflagx, x, qx)

!  Method 3 for computing erfcs(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: k, ksma, kt, nd, nd1, ndsav1, ndsav2, nterms
      logical, external :: fmcomp

!             Method 3.  Continued fraction expansion (asymptotic).
!                        Used for Re(x) > 0.

!                               erfc_sc(x) = 0 + 1/sqrt(pi) /
!                                                         x + 1 /
!                                                           2*x + 2 /
!                                                                 x + 3 /
!                                                                   2*x + 4 /
!                                                                         x + 5 ...
!
!                        For Re(x) < 0, use   erfc_sc(x) = exp(x**2) * (1 - erf(x))
!                                                        = exp(x**2) * (1 + erf(-x))
!                                                        = exp(x**2) * (2 - erfc(-x))
!                                                        = 2*exp(x**2) - erfc_sc(-x)

      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig) + 1, qx)
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, qx%ndig, qx)
      ndsav1 = qx%ndig
      ksma = mxy(1, 1)%mp(1)
      if (ksma < 0) then
          call zmnegate(mxy(1:2, 1), qx)
      endif

      call zmeq(mxy(1:2, 1), mxy(1:2, 2), qx)

      call zmi2m(1, mxy(1:2, 15), qx)
      call fmpi(mxy(1, 10), qx)
      qx%ndigpi = 0
      call fmsqrt_r1(mxy(1, 10), qx)
      call fmi2m(0, mxy(2, 10), qx)
      call zmdiv_r2(mxy(1:2, 15), mxy(1:2, 10), qx)
      call zmdiv_r1(mxy(1:2, 10), mxy(1:2, 2), qx)
      call zmi2m(-31, mxy(1:2, 13), qx)

      call zmeq(mxy(1:2, 10), mxy(1:2, 14), qx)
      call zmi2m(1, mxy(1:2, 8), qx)
      call zmeq(mxy(1:2, 2), mxy(1:2, 9), qx)
      nterms = int(intmax/10)

!             Continued fraction loop.

      ndsav2 = qx%ndig
      do k = 3, nterms
         call zmmpyi(mxy(1:2, 2), 1+mod(k, 2), mxy(1:2, 11), qx)
         call zmmpy_r1(mxy(1:2, 11), mxy(1:2, 9), qx)
         call zmmpyi(mxy(1:2, 8), k-2, mxy(1:2, 12), qx)
         call zmadd(mxy(1:2, 11), mxy(1:2, 12), mxy(1:2, 7), qx)
         call zmmpy_r1(mxy(1:2, 10), mxy(1:2, 12), qx)
         call zmdiv_r1(mxy(1:2, 10), mxy(1:2, 7), qx)
         call zmnegate(mxy(1:2, 10), qx)
         call zmeq(mxy(1:2, 9), mxy(1:2, 8), qx)
         call zmeq(mxy(1:2, 7), mxy(1:2, 9), qx)
         call fmndig(ndsav2, qx)
         call zmadd_r1(mxy(1:2, 14), mxy(1:2, 10), qx)

!             Check for convergence.

         if (qx%kflag == 1 .and. k > 2) then
             exit
         endif
         kt = max(1000, int(5*qx%alogmt*ndsave))
         if (k > kt) then
             call zmerfcs_m2(mxy, mresult, ndsave, numtry, kflagx, x, qx)
         endif
         call zmeq(mxy(1:2, 10), mxy(1:2, 13), qx)
         nd = mxy(1, 14)%mp(2)-mxy(1, 10)%mp(2)
         nd1 = mxy(2, 14)%mp(2)-mxy(2, 10)%mp(2)
         nd = min(ndsav2, max(qx%ngrd22, ndsav2-int(min(nd, nd1))))
         call fmndig(nd, qx)
         if (k == nterms) then
             call zmunknown(mresult, qx)
             qx%kflag = -4
             return
         endif
      enddo

      call fmi2m(1, mxy(1, 15), qx)
      call fmulp(mxy(1, 15), mxy(2, 15), qx)
      call fmdiv(mxy(1, 1), mxy(2, 1), mxy(1, 15), qx)
      call fmsqr_r1(mxy(1, 15), qx)
      if (fmcomp(mxy(1, 15), '<', mxy(2, 15), qx)) then
          call zmsqr(mxy(1:2, 1), mxy(1:2, 13), qx)
          call zmexp(mxy(1:2, 13), mxy(1:2, 15), qx)
          call zmadd_r2(mxy(1:2, 15), mxy(1, 14), qx)
      endif
      call zmeq(mxy(1:2, 14), mxy(1:2, 3), qx)
      if (ksma < 0) then
          call zmsqr(mxy(1:2, 1), mxy(1:2, 15), qx)
          call zmexp(mxy(1:2, 15), mxy(1:2, 14), qx)
          call zmmpyi(mxy(1:2, 14), 2, mxy(1:2, 15), qx)
          call zmsub_r2(mxy(1:2, 15), mxy(1:2, 3), qx)
      endif
      call fmndig(ndsav1, qx)

      call zmeq(mxy(1:2, 3), mresult, qx)

      return
      end subroutine zmerfcs_m3

      subroutine zmerfcs_m4(mxy, mresult, ndsave, numtry, kflagx, x, qx)

!  Method 4 for computing erfcs(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: xe
      integer :: j, j2, kl, ksma, kt, nd, nd1, ndsav1, nterm
      type(multi) :: mjsums(2, ljsums)
      double precision, external :: fmnterms
      logical, external :: fmcomp

!             Method 4.  Asymptotic series
!
!                        For Re(x) >= 0,
!                        erfc_sc(x) = ( 1 / Sqrt(Pi) ) *
!                                  Sum_{k=0}^Infinity (  (-1)**k * poch(1/2,k) / x**(2*k+1) )

!                        The series is  1/x - (1/2) / x**3  +  ( 1*3 )/(2**2) / x**5 -
!                                       ( 1*3*5 )/(2**3) / x**7 + ...

!                        For Re(x) < 0, use   erfc(x) = 1 - erf(x) = 1 + erf(-x) = 2 - erfc(-x).
!                                       erfc_sc(x) = Exp(x**2) * (2 - erfc(-x))
!                                                  = 2*Exp(x**2) - erfc_sc(-x)

      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig-1), qx)
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, qx%ndig, qx)
      ksma = mxy(1, 1)%mp(1)
      if (ksma < 0) then
          call zmnegate(mxy(1:2, 1), qx)
      endif
      if (kflagx == 0) then
          j2 = int(0.66*sqrt(fmnterms(x**2, 1, 0, 0, 0, qx)) - 0.8)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = qx%ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call zmsqr(mxy(1:2, 1), mxy(1:2, 15), qx)
      call zmmpyi(mxy(1:2, 15), 2, mxy(1:2, 7), qx)
      call zmi2m(1, mxy(1:2, 8), qx)
      call zmdiv(mxy(1:2, 8), mxy(1:2, 7), mxy(1:2, 6), qx)
      call zmi2m(1, mjsums(1:2, 1), qx)
      do j = 2, j2
         nterm = nterm + 1
         call zmmpyi_r1(mxy(1:2, 8), 2*nterm-3, qx)
         call zmeq(mxy(1:2, 8), mjsums(1:2, j), qx)
      enddo
      call zmabs(mxy(1:2, 1), mxy(1, 15), qx)
      call fmovun_xe(mxy(1, 15), xe, qx)
      if (xe < -qx%ndig) then
          kl = 0
      else
          kl = 1
          call zmipwr(mxy(1:2, 6), j2, mxy(1:2, 7), qx)
          call zmi2m(-31, mxy(1:2, 13), qx)
      endif

      do while (kl == 1)
         call zmmpy_r2(mxy(1:2, 7), mxy(1:2, 8), qx)
         do j = 1, j2
            nterm = nterm + 1
            call zmmpyi_r1(mxy(1:2, 8), 2*nterm-3, qx)
            call fmndig(ndsav1, qx)
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 8), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            kt = max(19000, int(6*qx%alogmt*ndsave))
            if (nterm > kt) then
                call zmabs(mxy(1:2, 8), mxy(1, 15), qx)
                call zmabs(mxy(1:2, 13), mxy(2, 15), qx)
                if (fmcomp(mxy(1, 15), '>', mxy(2, 15), qx)) then
                    call zmerfcs_m2(mxy, mresult, ndsave, numtry, kflagx, x, qx)
                endif
            endif
            call zmeq(mxy(1:2, 8), mxy(1:2, 13), qx)
            nd = mjsums(1, j)%mp(2)-mxy(1, 8)%mp(2)
            nd1 = mjsums(2, j)%mp(2)-mxy(2, 8)%mp(2)
            nd = ndsav1 - int(min(nd, nd1))
            call fmndig(min(ndsav1, nd), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         enddo
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call zmmpyi(mxy(1:2, 6), -1, mxy(1:2, 4), qx)
      call zmi2m(1, mxy(1:2, 5), qx)
      do j = 2, j2
         call zmmpy_r1(mxy(1:2, 5), mxy(1:2, 4), qx)
         call zmmpy(mxy(1:2, 5), mjsums(1:2, j), mxy(1:2, 15), qx)
         call zmadd(mxy(1:2, 15), mjsums(1:2, 1), mxy(1:2, 8), qx)
         call zmeq(mxy(1:2, 8), mjsums(1:2, 1), qx)
      enddo

      call fmpi(mxy(1, 4), qx)
      qx%ndigpi = 0
      call fmsqrt(mxy(1, 4), mxy(1, 8), qx)
      call fmi2m(0, mxy(2, 8), qx)
      call zmdiv(mjsums(1:2, 1), mxy(1:2, 8), mxy(1:2, 4), qx)
      call zmdiv_r1(mxy(1:2, 4), mxy(1:2, 1), qx)

      call fmi2m(1, mxy(1, 15), qx)
      call fmulp(mxy(1, 15), mxy(2, 15), qx)
      call fmdiv(mxy(1, 1), mxy(2, 1), mxy(1, 15), qx)
      call fmsqr_r1(mxy(1, 15), qx)
      if (fmcomp(mxy(1, 15), '<', mxy(2, 15), qx)) then
          call zmsqr(mxy(1:2, 1), mxy(1:2, 13), qx)
          call zmexp(mxy(1:2, 13), mxy(1:2, 15), qx)
          call zmadd_r2(mxy(1:2, 15), mxy(1:2, 4), qx)
      endif
      if (ksma < 0) then
          call zmsqr(mxy(1:2, 1), mxy(1:2, 15), qx)
          call fmi2m(2, mxy(1, 14), qx)
          call fmln(mxy(1, 14), mxy(1, 13), qx)
          qx%ndigli = 0
          call fmadd_r1(mxy(1, 15), mxy(1, 13), qx)
          call zmexp(mxy(1:2, 15), mxy(1:2, 14), qx)
          call zmsub(mxy(1:2, 14), mxy(1:2, 4), mxy(1:2, 3), qx)
      else
          call zmeq(mxy(1:2, 4), mxy(1:2, 3), qx)
      endif

      call zmeq(mxy(1:2, 3), mresult, qx)

      return
      end subroutine zmerfcs_m4

      subroutine zmerfcs_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = erfcs(ma).

!  kresult = 1 is returned if a special case gives the value of erfcs(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMERFCS  '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmerfcs_sc

      subroutine zmexit1(ma, mb, kovun, mxsave, ndsave, qx)

!  At the end of a function this routine checks for tracing the output argument,
!  rounds ma from precision ndig to precision ndsave as the returned function value mb,
!  and resets precision, and the overflow/underflow threshold to the values from the
!  start of that function.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (in) :: ma
      intent (inout) :: mb, kovun, mxsave, ndsave
      type(fm_settings) :: qx

      integer :: kfsave, kwrnsv

      kwrnsv = qx%kwarn
      qx%kwarn = 0
      qx%mxexp = mxsave
      kfsave = qx%kflag
      call zmequ(ma, mb, qx%ndig, ndsave, qx)
      if (qx%kflag /= -5 .and. qx%kflag /= -6) qx%kflag = kfsave
      qx%ndig = ndsave
      qx%kwarn = kwrnsv
      if (qx%kflag == 1) qx%kflag = 0
      if (mb(1)%mp(2) == qx%mexpun .or. mb(2)%mp(2) == qx%mexpun) qx%kflag = -6
      if (mb(1)%mp(2) == qx%mexpov .or. mb(2)%mp(2) == qx%mexpov) qx%kflag = -5
      if (mb(1)%mp(2) == qx%munkno .or. mb(2)%mp(2) == qx%munkno) then
          if (qx%kflag /= -9) qx%kflag = -4
      endif
      if ((mb(1)%mp(2) == qx%munkno .and. qx%kflag /= -9 .and. kovun /= 2) .or.  &
          (mb(2)%mp(2) == qx%munkno .and. qx%kflag /= -9 .and. kovun /= 2) .or.  &
          (mb(1)%mp(2) == qx%mexpun .and. kovun == 0)  .or.                      &
          (mb(2)%mp(2) == qx%mexpun .and. kovun == 0)  .or.                      &
          (mb(1)%mp(2) == qx%mexpov .and. kovun == 0)  .or.                      &
          (mb(2)%mp(2) == qx%mexpov .and. kovun == 0)) then
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) call zmntr_out1(mb, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine zmexit1

      subroutine zmexit2(ma, mb, mc, md, kovun, mxsave, ndsave, qx)

!  At the end of a function this routine checks for tracing the output argument,
!  rounds ma,mb from precision ndig to precision ndsave as the returned function value mc,md,
!  and resets precision, and the overflow/underflow threshold to the values from the
!  start of that function.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2), mc(2), md(2)
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (in) :: ma, mb
      intent (inout) :: mc, md, kovun, mxsave, ndsave
      type(fm_settings) :: qx

      integer :: kfsave, kwrnsv

      kwrnsv = qx%kwarn
      qx%kwarn = 0
      qx%mxexp = mxsave
      kfsave = qx%kflag
      call zmequ(ma, mc, qx%ndig, ndsave, qx)
      call zmequ(mb, md, qx%ndig, ndsave, qx)
      if (qx%kflag /= -5 .and. qx%kflag /= -6) qx%kflag = kfsave
      qx%ndig = ndsave
      qx%kwarn = kwrnsv
      if (qx%kflag == 1) qx%kflag = 0
      if (mc(1)%mp(2) == qx%mexpun .or. mc(2)%mp(2) == qx%mexpun) qx%kflag = -6
      if (md(1)%mp(2) == qx%mexpun .or. md(2)%mp(2) == qx%mexpun) qx%kflag = -6
      if (mc(1)%mp(2) == qx%mexpov .or. mc(2)%mp(2) == qx%mexpov) qx%kflag = -5
      if (md(1)%mp(2) == qx%mexpov .or. md(2)%mp(2) == qx%mexpov) qx%kflag = -5
      if (mc(1)%mp(2) == qx%munkno .or. mc(2)%mp(2) == qx%munkno .or.  &
          md(1)%mp(2) == qx%munkno .or. md(2)%mp(2) == qx%munkno) then
          if (qx%kflag /= -9) qx%kflag = -4
      endif
      if ((mc(1)%mp(2) == qx%munkno .and. qx%kflag /= -9 .and. kovun /= 2) .or.  &
          (mc(2)%mp(2) == qx%munkno .and. qx%kflag /= -9 .and. kovun /= 2) .or.  &
          (md(1)%mp(2) == qx%munkno .and. qx%kflag /= -9 .and. kovun /= 2) .or.  &
          (md(2)%mp(2) == qx%munkno .and. qx%kflag /= -9 .and. kovun /= 2) .or.  &
          (mc(1)%mp(2) == qx%mexpun .and. kovun == 0)  .or.                      &
          (mc(2)%mp(2) == qx%mexpun .and. kovun == 0)  .or.                      &
          (md(1)%mp(2) == qx%mexpun .and. kovun == 0)  .or.                      &
          (md(2)%mp(2) == qx%mexpun .and. kovun == 0)  .or.                      &
          (mc(1)%mp(2) == qx%mexpov .and. kovun == 0)  .or.                      &
          (mc(2)%mp(2) == qx%mexpov .and. kovun == 0)  .or.                      &
          (md(1)%mp(2) == qx%mexpov .and. kovun == 0)  .or.                      &
          (md(2)%mp(2) == qx%mexpov .and. kovun == 0)) then
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) call zmntr_out2(mc, md, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine zmexit2

      subroutine zmexp(ma, mb, qx)

!  mb = exp(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy, mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmexp_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmexp_m1(ma, mxy, mresult, ndsave, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmexp

      subroutine zmexp_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing exp(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mxy, mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: kwrnsv
      type(multi) :: mz01(2), mz02(2)

      call zmequ(ma, mz02, ndsave, qx%ndig, qx)

      if (ma(1)%mp(3) == 0) then
          call fmi2m(1, mxy, qx)
      else
          call fmexp(mz02(1), mxy, qx)
          qx%ndige = 0
          if (ma(2)%mp(3) == 0) then
              call fmeq(mxy, mresult(1), qx)
              call fmi2m(0, mresult(2), qx)
              return
          endif
      endif

      call fmcssn(mz02(2), mz01(1), mz01(2), qx)

      kwrnsv = qx%kwarn
      qx%kwarn = 0
      call fmmpyd(mxy, mz01(1), mz01(2), mz02(1), mz02(2), qx)
      qx%kwarn = kwrnsv

      call zmeq(mz02, mresult, qx)

      return
      end subroutine zmexp_m1

      subroutine zmexp_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = exp(ma).

!  kresult = 1 is returned if a special case gives the value of exp(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMEXP    '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call zmi2m(1, mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmexp_sc

      subroutine zmfact(ma, mb, qx)

!  mb = ma!     Factorial for complex input.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(2, 3), mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmfact_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmfact_m1(ma, mxy, mresult, ndsave, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmfact

      subroutine zmfact_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing ma!.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mxy(2, 3), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      logical, external :: fmcomp

      call zmequ(ma, mxy(1:2, 1), ndsave, qx%ndig, qx)

!             Check for special cases.

      if (ma(2)%mp(3) == 0) then
          call fmint(mxy(1, 1), mxy(1, 3), qx)
          if (fmcomp(mxy(1, 1), '==', mxy(1, 3), qx)) then
              call zmunknown(mresult, qx)
              qx%kflag = -4
              return
          endif
      endif

!             Use  x! = gamma(x+1).

      call zmi2m(1, mxy(1:2, 2), qx)
      call zmadd_r2(mxy(1:2, 1), mxy(1:2, 2), qx)
      call zmgam(mxy(1:2, 2), mresult, qx)

      return
      end subroutine zmfact_m1

      subroutine zmfact_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = ma!.

!  kresult = 1 is returned if a special case gives the value of ma!.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMFACT   '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

!             If ma is real, use fmfact.

      if (ma(2)%mp(3) == 0) then
          call fmfact(malocal(1), mresult(1), qx)
          call fmi2m(0, mresult(2), qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmfact_sc

      subroutine zmform(form1, form2, ma, string, qx)

!  Convert ma to string using form1 format for the real part and form2 format for the
!  imaginary part.

      use fmvals_parallel
      implicit none

      character :: cmbuff(lmbuff)
      character :: cmbufz(lmbufz)
      character(*) :: form1, form2, string
      type(multi) :: ma(2)
      intent (in) :: ma, form1, form2
      intent (inout) :: string
      type(fm_settings) :: qx

      integer :: j, kwidim, kwidre, last, lsign
      type(multi) :: mxy(1)

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'ZMFORM'
      string = ' '
      call zmfpcz(form1, ma(1), kwidre, cmbufz, qx)
      call fmeq(ma(2), mxy(1), qx)
      if (mxy(1)%mp(1) > 0) then
          lsign = 1
      else
          lsign = -1
          call fmnegate(mxy(1), qx)
      endif
      call zmfpcm(form2, mxy(1), kwidim, cmbuff, qx)

      if (kwidre+kwidim+50 > lmbufz) then
          write (*,"(//a//)") " Output buffer cmbufz is not big enough." //  &
                              " Raise its size (lmbufz) or change the format being used."
          stop
      endif

      cmbufz(kwidre+1) = ' '
      if (lsign == 1) then
          cmbufz(kwidre+2) = '+'
      else
          cmbufz(kwidre+2) = '-'
      endif
      cmbufz(kwidre+3) = ' '
      do j = 1, kwidim
         cmbufz(kwidre+3+j) = cmbuff(j)
      enddo
      cmbufz(kwidre+4+kwidim) = ' '
      cmbufz(kwidre+5+kwidim) = 'i'
      if (qx%jformz == 2) cmbufz(kwidre+5+kwidim) = 'I'
      last = kwidre + kwidim + 5

      if (mxy(1)%mp(2) == qx%mexpov .or. mxy(1)%mp(2) == qx%mexpun) then
          do j = kwidre+3, last
             if (cmbufz(j) == 'O' .or. cmbufz(j) == 'U') then
                 cmbufz(j-2) = ' '
                 exit
             endif
          enddo
      endif

      if (last <= len(string)) then
          do j = 1, last
             string(j:j) = cmbufz(j)
          enddo
      else
          do j = 1, last
             string(j:j) = '*'
          enddo
      endif
      qx%ncall = qx%ncall - 1

      return
      end subroutine zmform

      subroutine zmfpcm(form, ma, kwi, cmbuff, qx)

!  Internal routine to convert ma to base 10 using form format.
!  The result is returned in cmbuff and the field width is kwi.

      use fmvals_parallel
      implicit none

      character :: cmbuff(lmbuff)
      character(*) :: form
      type(fm_settings) :: qx
      type(multi) :: ma
      integer :: kwi
      intent (in) :: ma, form
      intent (inout) :: kwi
      double precision :: val
      integer :: j, jf1sav, jf2sav, jpt, k1, k2, k3, kd, kwd, ksave, last, lb, lengfm,  &
                 lfirst, nd, nexp
      type(multi) :: mxy(1)


      ksave = qx%kflag
      jf1sav = qx%jform1
      jf2sav = qx%jform2
      lengfm = len(form)
      kwi = 75
      kwd = 40
      if (index(form, 'I') > 0 .or. index(form, 'i') > 0) then
          k1 = max(index(form, 'I'), index(form, 'i')) + 1
          k2 = lengfm
          if (k2 >= k1) then
              call fmst2d(form(k1:k2), val, qx)
              kwi = nint(val)
          else
              kwi = 50
          endif
          kwi = max(1, kwi)
          qx%jform1 = 2
          qx%jform2 = 0
          kwd = kwi + 11
          if (kwd+50 > lmbuff) then
              write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                                  " Raise its size (lmbuff) or change the format being used."
              stop
          endif
          call fmnint(ma, mxy(1), qx)
          if (mxy(1)%mp(3) /= 0) then
              call fmout(mxy(1), cmbuff, kwd, qx)
          else
              do j = 1, kwd
                 cmbuff(j) = ' '
              enddo
              cmbuff(2) = '0'
          endif
          lfirst = 1
          last = 1
          do j = 1, kwd
             if (cmbuff(kwd+1-j) /= ' ') lfirst = kwd+1-j
             if (cmbuff(j) /= ' ') last = j
          enddo
          jpt = 1
          if (last-lfirst+1 > kwi) then
              call zmfpcm2(kwi, jf1sav, jf2sav, cmbuff, qx)
              return
          endif
          if (last <= kwi) then
              do j = last, lfirst, -1
                 jpt = kwi - last + j
                 cmbuff(jpt) = cmbuff(j)
              enddo
              do j = 1, jpt-1
                 cmbuff(j) = ' '
              enddo
          else
              do j = lfirst, last
                 jpt = kwi - last + j
                 cmbuff(jpt) = cmbuff(j)
              enddo
          endif
      else if (index(form, 'F') > 0 .or. index(form, 'f') > 0) then
          k1 = max(index(form, 'F'), index(form, 'f')) + 1
          k2 = index(form(1:lengfm), '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val, qx)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val, qx)
              kd = nint(val)
          else
              kd = 0
          endif
          kwi = max(1, kwi)
          kd = max(0, min(kd, kwi-2))
          qx%jform1 = 2
          qx%jform2 = kd
          nd = int(real(qx%ndig)*log10(real(qx%mbase))) + 1
          if (nd < 2) nd = 2
          nexp = int(2.0*log10(real(mxbase))) + 16
          lb = max(qx%jform2+nexp, nd+nexp)
          kwd = lb
          if (kwd+50 > lmbuff) then
              write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                                  " Raise its size (lmbuff) or change the format being used."
              stop
          endif
          call fmout(ma, cmbuff, kwd, qx)
          lfirst = 1
          last = 1
          do j = 1, kwd
             if (cmbuff(kwd+1-j) /= ' ') lfirst = kwd+1-j
             if (cmbuff(j) /= ' ') last = j
          enddo
          if (last-lfirst+1 > kwi) then

!             Not enough room for this f format, or fmout converted it to e format to avoid
!             showing no significant digits.  See if a shortened form will fit in e format.

              nexp = int(log10((abs(ma%mp(2))+1)*log10(dble(qx%mbase))+1)+1)
              nd = kwi - nexp - 5
              if (nd < 1) then
                  call zmfpcm2(kwi, jf1sav, jf2sav, cmbuff, qx)
                  return
              else
                  qx%jform1 = 0
                  qx%jform2 = nd
                  if (kwi+50 > lmbuff) then
                      write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                                          " Raise its size (lmbuff) or change the format being used."
                      stop
                  endif
                  call fmout(ma, cmbuff, kwi, qx)
                  lfirst = 1
                  last = 1
                  do j = 1, kwi
                     if (cmbuff(kwi+1-j) /= ' ') lfirst = kwi+1-j
                     if (cmbuff(j) /= ' ') last = j
                  enddo
              endif
          endif
          jpt = 1
          if (last <= kwi) then
              do j = last, lfirst, -1
                 jpt = kwi - last + j
                 cmbuff(jpt) = cmbuff(j)
              enddo
              do j = 1, jpt-1
                 cmbuff(j) = ' '
              enddo
          else
              do j = lfirst, last
                 jpt = kwi - last + j
                 cmbuff(jpt) = cmbuff(j)
              enddo
          endif
      else if (index(form, '1PE') > 0 .or. index(form, '1pe') > 0 .or. index(form, 'ES') > 0 .or.  &
               index(form, 'es') > 0) then
          if (index(form, '1PE') > 0 .or. index(form, '1pe') > 0) then
              k1 = max(index(form, 'E'), index(form, 'e')) + 1
          else
              k1 = max(index(form, 'S'), index(form, 's')) + 1
          endif
          k2 = index(form(1:lengfm), '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val, qx)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val, qx)
              kd = nint(val)
          else
              kd = 0
          endif
          kwi = max(1, kwi)
          kd = max(0, min(kd, kwi-2))
          qx%jform1 = 1
          qx%jform2 = kd + 1
          if (kwi+50 > lmbuff) then
              write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                                  " Raise its size (lmbuff) or change the format being used."
              stop
          endif
          call fmout(ma, cmbuff, kwi, qx)
      else if (index(form, 'E') > 0 .or. index(form, 'e') > 0) then
          k1 = max(index(form, 'E'), index(form, 'e')) + 1
          k2 = index(form(1:lengfm), '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val, qx)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val, qx)
              kd = nint(val)
          else
              kd = 0
          endif
          kwi = max(1, kwi)
          kd = max(0, min(kd, kwi-2))
          qx%jform1 = 0
          qx%jform2 = kd
          if (kwi+50 > lmbuff) then
              write (*,"(//a//)") " Output buffer cmbuff is not big enough." //  &
                                  " Raise its size (lmbuff) or change the format being used."
              stop
          endif
          call fmout(ma, cmbuff, kwi, qx)
      else
          call zmfpcm2(kwi, jf1sav, jf2sav, cmbuff, qx)
          return
      endif

      qx%jform1 = jf1sav
      qx%jform2 = jf2sav
      qx%kflag = ksave

      return
      end subroutine zmfpcm

      subroutine zmfpcm2(kwi, jf1sav, jf2sav, cmbuff, qx)

!  Handle error conditions for zmfpcm.

      use fmvals_parallel
      implicit none

      character :: cmbuff(lmbuff)
      integer :: kwi, jf1sav, jf2sav
      intent (in) :: kwi, jf1sav, jf2sav
      type(fm_settings) :: qx

      integer :: j

      qx%kflag = -8
      do j = 1, kwi
         cmbuff(j) = '*'
      enddo
      qx%jform1 = jf1sav
      qx%jform2 = jf2sav

      return
      end subroutine zmfpcm2

      subroutine zmfpcz(form, ma, kwi, cmbufz, qx)

!  Internal routine to convert ma to base 10 using form format.
!  The result is returned in cmbufz and the field width is kwi.

      use fmvals_parallel
      implicit none

      character :: cmbufz(lmbufz)
      character(*) :: form
      type(fm_settings) :: qx
      type(multi) :: ma
      integer :: kwi
      intent (in) :: ma, form
      intent (inout) :: kwi
      double precision :: val
      integer :: j, jf1sav, jf2sav, jpt, k1, k2, k3, kd, kwd, ksave, last, lb,  &
                 lengfm, lfirst, nd, nexp
      type(multi) :: mxy(1)


      ksave = qx%kflag
      jf1sav = qx%jform1
      jf2sav = qx%jform2
      lengfm = len(form)
      kwi = 75
      kwd = 40
      if (index(form, 'I') > 0 .or. index(form, 'i') > 0) then
          k1 = max(index(form, 'I'), index(form, 'i')) + 1
          k2 = lengfm
          if (k2 >= k1) then
              call fmst2d(form(k1:k2), val, qx)
              kwi = nint(val)
          else
              kwi = 50
          endif
          kwi = max(1, kwi)
          qx%jform1 = 2
          qx%jform2 = 0
          kwd = kwi + 11
          if (kwd+50 > lmbufz) then
              write (*,"(//a//)") " Output buffer cmbufz is not big enough." //  &
                                  " Raise its size (lmbufz) or change the format being used."
              stop
          endif
          call fmnint(ma, mxy(1), qx)
          if (mxy(1)%mp(3) /= 0) then
              call fmout(mxy(1), cmbufz, kwd, qx)
          else
              do j = 1, kwd
                 cmbufz(j) = ' '
              enddo
              cmbufz(2) = '0'
          endif
          lfirst = 1
          last = 1
          do j = 1, kwd
             if (cmbufz(kwd+1-j) /= ' ') lfirst = kwd+1-j
             if (cmbufz(j) /= ' ') last = j
          enddo
          jpt = 1
          if (last-lfirst+1 > kwi) then
              call zmfpcz2(kwi, jf1sav, jf2sav, cmbufz, qx)
              return
          endif
          if (last <= kwi) then
              do j = last, lfirst, -1
                 jpt = kwi - last + j
                 cmbufz(jpt) = cmbufz(j)
              enddo
              do j = 1, jpt-1
                 cmbufz(j) = ' '
              enddo
          else
              do j = lfirst, last
                 jpt = kwi - last + j
                 cmbufz(jpt) = cmbufz(j)
              enddo
          endif
      else if (index(form, 'F') > 0 .or. index(form, 'f') > 0) then
          k1 = max(index(form, 'F'), index(form, 'f')) + 1
          k2 = index(form(1:lengfm), '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val, qx)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val, qx)
              kd = nint(val)
          else
              kd = 0
          endif
          kwi = max(1, kwi)
          kd = max(0, min(kd, kwi-2))
          qx%jform1 = 2
          qx%jform2 = kd
          nd = int(real(qx%ndig)*log10(real(qx%mbase))) + 1
          if (nd < 2) nd = 2
          nexp = int(2.0*log10(real(mxbase))) + 16
          lb = max(qx%jform2+nexp, nd+nexp)
          kwd = lb
          if (kwd+50 > lmbufz) then
              write (*,"(//a//)") " Output buffer cmbufz is not big enough." //  &
                                  " Raise its size (lmbufz) or change the format being used."
              stop
          endif
          call fmout(ma, cmbufz, kwd, qx)
          lfirst = 1
          last = 1
          do j = 1, kwd
             if (cmbufz(kwd+1-j) /= ' ') lfirst = kwd+1-j
             if (cmbufz(j) /= ' ') last = j
          enddo
          if (last-lfirst+1 > kwi) then

!             Not enough room for this f format, or fmout converted it to e format to avoid
!             showing no significant digits.  See if a shortened form will fit in e format.

              nexp = int(log10((abs(ma%mp(2))+1)*log10(dble(qx%mbase))+1)+1)
              nd = kwi - nexp - 5
              if (nd < 1) then
                  call zmfpcz2(kwi, jf1sav, jf2sav, cmbufz, qx)
                  return
              else
                  qx%jform1 = 0
                  qx%jform2 = nd
                  if (kwi+50 > lmbufz) then
                      write (*,"(//a//)") " Output buffer cmbufz is not big enough." //  &
                                          " Raise its size (lmbufz) or change the format being used."
                      stop
                  endif
                  call fmout(ma, cmbufz, kwi, qx)
                  lfirst = 1
                  last = 1
                  do j = 1, kwi
                     if (cmbufz(kwi+1-j) /= ' ') lfirst = kwi+1-j
                     if (cmbufz(j) /= ' ') last = j
                  enddo
              endif
          endif
          jpt = 1
          if (last <= kwi) then
              do j = last, lfirst, -1
                 jpt = kwi - last + j
                 cmbufz(jpt) = cmbufz(j)
              enddo
              do j = 1, jpt-1
                 cmbufz(j) = ' '
              enddo
          else
              do j = lfirst, last
                 jpt = kwi - last + j
                 cmbufz(jpt) = cmbufz(j)
              enddo
          endif
      else if (index(form, '1PE') > 0 .or. index(form, '1pe') > 0 .or. index(form, 'ES') > 0 .or.  &
               index(form, 'es') > 0) then
          if (index(form, '1PE') > 0 .or. index(form, '1pe') > 0) then
              k1 = max(index(form, 'E'), index(form, 'e')) + 1
          else
              k1 = max(index(form, 'S'), index(form, 's')) + 1
          endif
          k2 = index(form(1:lengfm), '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val, qx)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val, qx)
              kd = nint(val)
          else
              kd = 0
          endif
          kwi = max(1, kwi)
          kd = max(0, min(kd, kwi-2))
          qx%jform1 = 1
          qx%jform2 = kd + 1
          if (kwi+50 > lmbufz) then
              write (*,"(//a//)") " Output buffer cmbufz is not big enough." //  &
                                  " Raise its size (lmbufz) or change the format being used."
              stop
          endif
          call fmout(ma, cmbufz, kwi, qx)
      else if (index(form, 'E') > 0 .or. index(form, 'e') > 0) then
          k1 = max(index(form, 'E'), index(form, 'e')) + 1
          k2 = index(form(1:lengfm), '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val, qx)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val, qx)
              kd = nint(val)
          else
              kd = 0
          endif
          kwi = max(1, kwi)
          kd = max(0, min(kd, kwi-2))
          qx%jform1 = 0
          qx%jform2 = kd
          if (kwi+50 > lmbufz) then
              write (*,"(//a//)") " Output buffer cmbufz is not big enough." //  &
                                  " Raise its size (lmbufz) or change the format being used."
              stop
          endif
          call fmout(ma, cmbufz, kwi, qx)
      else
          call zmfpcz2(kwi, jf1sav, jf2sav, cmbufz, qx)
          return
      endif

      qx%jform1 = jf1sav
      qx%jform2 = jf2sav
      qx%kflag = ksave

      return
      end subroutine zmfpcz

      subroutine zmfpcz2(kwi, jf1sav, jf2sav, cmbufz, qx)

!  Handle error conditions for zmfpcz.

      use fmvals_parallel
      implicit none

      character :: cmbufz(lmbufz)
      integer :: kwi, jf1sav, jf2sav
      intent (in) :: kwi, jf1sav, jf2sav
      type(fm_settings) :: qx

      integer :: j

      qx%kflag = -8
      do j = 1, kwi
         cmbufz(j) = '*'
      enddo
      qx%jform1 = jf1sav
      qx%jform2 = jf2sav

      return
      end subroutine zmfpcz2

      subroutine zmfprint(form1, form2, ma, qx)

      use fmvals_parallel
      implicit none

      character(*) :: form1, form2
      type(multi) :: ma(2)
      intent (in) :: ma, form1, form2
      type(fm_settings) :: qx

      call zmfprt(form1, form2, ma, qx)

      return
      end subroutine zmfprint

      subroutine zmfprt(form1, form2, ma, qx)

!  Print ma in base 10 using form1 format for the real part and form2 format for the imaginary part.

      use fmvals_parallel
      implicit none

      character :: cmbuff(lmbuff)
      character :: cmbufz(lmbufz)
      character(*) :: form1, form2
      type(multi) :: ma(2)
      intent (in) :: ma, form1, form2
      type(fm_settings) :: qx

      character(20) :: form
      integer :: j, k, kwidim, kwidre, last, lsign
      type(multi) :: mxy(1)


      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'ZMFPRT'

      call zmfpcz(form1, ma(1), kwidre, cmbufz, qx)
      call fmeq(ma(2), mxy(1), qx)
      if (mxy(1)%mp(1) >= 0) then
          lsign = 1
      else
          lsign = -1
          call fmnegate(mxy(1), qx)
      endif
      call zmfpcm(form2, mxy(1), kwidim, cmbuff, qx)

      if (kwidre+kwidim+50 > lmbufz) then
          write (*,"(//a//)") " Output buffer cmbufz is not big enough." //  &
                              " Raise its size (lmbufz) or change the format being used."
          stop
      endif

      cmbufz(kwidre+1) = ' '
      if (lsign == 1) then
          cmbufz(kwidre+2) = '+'
      else
          cmbufz(kwidre+2) = '-'
      endif
      cmbufz(kwidre+3) = ' '
      do j = 1, kwidim
         cmbufz(kwidre+3+j) = cmbuff(j)
      enddo
      cmbufz(kwidre+4+kwidim) = ' '
      cmbufz(kwidre+5+kwidim) = 'i'
      if (qx%jformz == 2) cmbufz(kwidre+5+kwidim) = 'I'
      last = kwidre + kwidim + 5

      if (mxy(1)%mp(2) == qx%mexpov .or. mxy(1)%mp(2) == qx%mexpun) then
          do j = kwidre+3, last
             if (cmbufz(j) == 'O' .or. cmbufz(j) == 'U') then
                 cmbufz(j-2) = ' '
                 exit
             endif
          enddo
      endif

      write (form, "(' (6X, ', I3, 'A1) ')") qx%kswide-7
      write (qx%kw, form) (cmbufz(k), k=1, last)
      qx%ncall = qx%ncall - 1

      return
      end subroutine zmfprt

      subroutine zmgam(ma, mb, qx)

!  mb = gamma(ma)

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(2, 15), mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmgam_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmgam_m1(ma, mxy, mresult, ndsave, qx)
         qx%numbrn = 0
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmgam

      subroutine zmgam_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing gam(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mbern(lmbern)
      integer :: ndbern(lmbern)
      type(multi) :: ma(2), mxy(2, 15), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: xe
      integer :: j, km, krnd, n
      logical, external :: fmcomp

      call zmequ(ma, mxy(1:2, 1), ndsave, qx%ndig, qx)

!             Check for special cases.

      if (ma(2)%mp(3) == 0) then
          call fmint(mxy(1, 1), mxy(1, 15), qx)
          if (fmcomp(mxy(1, 1), '==', mxy(1, 15), qx)) then
              call zmunknown(mresult, qx)
              qx%kflag = -4
              return
          endif
      endif
      km = 0
      call fmi2m(1, mxy(1, 7), qx)
      call fmovun_xe(mxy(2, 1), xe, qx)
      if (xe <= -qx%ndig/2) then
          krnd = qx%kround
          qx%kround = 1
          call fmpsi(mxy(1, 1), mxy(1, 8), qx)
          if (mxy(1, 8)%mp(2) == qx%munkno .and. mxy(1, 8)%mp(5) >= 0 .and.  &
              mxy(1, 1)%mp(2) /= qx%mexpov) then
              km = 2
          else
              call fmpgam(1, mxy(1, 1), mxy(1, 9), qx)
              call fmsqr(mxy(2, 1), mxy(1, 11), qx)
              call fmsqr(mxy(1, 8), mxy(1, 12), qx)
              call fmadd(mxy(1, 12), mxy(1, 9), mxy(1, 13), qx)
              call fmmpy_r1(mxy(1, 13), mxy(1, 11), qx)
              call fmdivi_r1(mxy(1, 13), 2, qx)
              call fmsub(mxy(1, 7), mxy(1, 13), mxy(1, 14), qx)
              if (fmcomp(mxy(1, 7), '==', mxy(1, 14), qx)) then
                  call fmpgam(2, mxy(1, 1), mxy(1, 10), qx)
                  call fmipwr(mxy(1, 8), 3, mxy(1, 12), qx)
                  call fmmpy(mxy(1, 8), mxy(1, 9), mxy(1, 13), qx)
                  call fmmpyi_r1(mxy(1, 13), 3, qx)
                  call fmadd_r1(mxy(1, 12), mxy(1, 13), qx)
                  call fmadd(mxy(1, 12), mxy(1, 10), mxy(1, 13), qx)
                  call fmmpy_r1(mxy(1, 13), mxy(1, 11), qx)
                  call fmdivi_r1(mxy(1, 13), 6, qx)
                  call fmsub(mxy(1, 8), mxy(1, 13), mxy(1, 14), qx)
                  if (fmcomp(mxy(1, 8), '==', mxy(1, 14), qx)) km = 1
              endif
              qx%kround = krnd
          endif
      endif
      call zmabs(mxy(1:2, 1), mxy(1, 2), qx)
      call fmipwr(mxy(1, 2), 3, mxy(1, 3), qx)
      call fmi2m(1, mxy(1, 4), qx)
      call fmulp(mxy(1, 4), mxy(1, 5), qx)
      if (fmcomp(mxy(1, 3), '<=', mxy(1, 5), qx)) then
          call fmi2m(0, mxy(2, 4), qx)
          call zmdiv(mxy(1:2, 4), mxy(1:2, 1), mxy(1:2, 5), qx)
          call fmeuler(mxy(1, 4), qx)
          call fmsub_r1(mxy(1, 5), mxy(1, 4), qx)
          call fmsqr_r1(mxy(1, 4), qx)
          call fmmpyi_r1(mxy(1, 4), 6, qx)
          call fmpi(mxy(1, 3), qx)
          qx%ndigpi = 0
          call fmsqr_r1(mxy(1, 3), qx)
          call fmadd_r1(mxy(1, 4), mxy(1, 3), qx)
          call fmdivi_r1(mxy(1, 4), 12, qx)
          call zmmpy(mxy(1:2, 1), mxy(1:2, 4), mxy(1:2, 3), qx)
          call zmadd_r2(mxy(1:2, 5), mxy(1:2, 3), qx)
      else if (km == 1) then
          call fmgam(mxy(1, 1), mxy(1, 3), qx)
          call fmmpy(mxy(1, 3), mxy(1, 8), mxy(1, 5), qx)
          call fmmpy(mxy(1, 5), mxy(2, 1), mxy(2, 3), qx)
      else if (km == 2) then
          call fmm2i(mxy(1, 1), n, qx)
          if (qx%kflag == 0) then
              n = -n
          else
              n = -99
          endif
          if (n > 0 .and. n <= max(100, 10*qx%ndig)) then
              call fmi2m(1, mxy(1, 4), qx)
              call fmi2m(1, mxy(1, 5), qx)
              do j = 2, n
                 call fmmpyi(mxy(1, 4), j, mxy(1, 6), qx)
                 call fmmpyi_r1(mxy(1, 5), j-1, qx)
                 call fmadd(mxy(1, 5), mxy(1, 6), mxy(1, 4), qx)
              enddo
              call fmmpyi_r1(mxy(1, 5), n, qx)
              call fmdiv(mxy(1, 4), mxy(1, 5), mxy(1, 6), qx)
          else
              call fmi2m(1, mxy(1, 8), qx)
              call fmmpyi(mxy(1, 1), -1, mxy(1, 4), qx)
              call fmi2m(1, mxy(1, 7), qx)
              call fmsqr(mxy(1, 4), mxy(1, 9), qx)
              call fmln(mxy(1, 4), mxy(1, 6), qx)
              qx%ndigli = 0
              call fmeulr(mxy(1, 2), qx)
              qx%ndgeul = 0
              call fmadd_r1(mxy(1, 6), mxy(1, 2), qx)
              call fmmpyi(mxy(1, 4), 2, mxy(1, 2), qx)
              call fmdiv_r2(mxy(1, 8), mxy(1, 2), qx)
              call fmadd_r1(mxy(1, 6), mxy(1, 2), qx)
              do j = 2, 10**9, 2
                 call fmmpy_r1(mxy(1, 7), mxy(1, 9), qx)
                 call fmmpyi(mxy(1, 7), j, mxy(1, 2), qx)
                 call fmdiv_r2(mxy(1, 8), mxy(1, 2), qx)
                 call fmbern(j, mxy(1, 2), mxy(1, 10), mbern, ndbern, qx)
                 call fmsub_r1(mxy(1, 6), mxy(1, 10), qx)
                 if (qx%kflag == 1) exit
              enddo
          endif
          call fmeulr(mxy(1, 2), qx)
          qx%ndgeul = 0
          call fmsub(mxy(1, 6), mxy(1, 2), mxy(1, 3), qx)
          call fmmpyi(mxy(1, 1), -1, mxy(1, 4), qx)
          call fmfact(mxy(1, 4), mxy(1, 5), qx)
          call fmdiv_r1(mxy(1, 3), mxy(1, 5), qx)
          call fmmpyi(mxy(1, 1), -1, mxy(1, 4), qx)
          call fmfact(mxy(1, 4), mxy(1, 2), qx)
          call fmmpy_r1(mxy(1, 2), mxy(2, 1), qx)
          call fmi2m(-1, mxy(1, 8), qx)
          call fmdiv(mxy(1, 8), mxy(1, 2), mxy(2, 3), qx)
          call fmi2m(2, mxy(1, 5), qx)
          call fmmod(mxy(1, 4), mxy(1, 5), mxy(1, 7), qx)
          if (mxy(1, 7)%mp(3) /= 0) then
              call zmmpyi(mxy(1:2, 3), -1, mxy(1:2, 4), qx)
              call zmeq(mxy(1:2, 4), mxy(1:2, 3), qx)
          endif
      else if (mxy(1, 1)%mp(2) == qx%mexpun) then
          call zmeq(mxy(1:2, 1), mxy(1:2, 2), qx)
          call fmi2m(0, mxy(1, 2), qx)
          call zmlngm(mxy(1:2, 2), mxy(1:2, 4), qx)
          call zmexp(mxy(1:2, 4), mxy(1:2, 3), qx)
      else
          call zmlngm(mxy(1:2, 1), mxy(1:2, 2), qx)
          call zmexp(mxy(1:2, 2), mxy(1:2, 3), qx)
      endif

      call zmeq(mxy(1:2, 3), mresult, qx)

      return
      end subroutine zmgam_m1

      subroutine zmgam_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = gam(ma).

!  kresult = 1 is returned if a special case gives the value of gam(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMGAM    '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

!             If ma is real and positive, use fmgam.

      if (malocal(2)%mp(3) == 0) then
          if (malocal(1)%mp(1) > 0 .and. malocal(1)%mp(3) > 0) then
              call fmgam(malocal(1), mresult(1), qx)
              call fmi2m(0, mresult(2), qx)
              kresult = 1
              return
          endif
      endif

      return
      end subroutine zmgam_sc

      subroutine zmi2m(integ, ma, qx)

!  ma = integ

!  The real part of ma is set to the one word integer value integ.
!  The imaginary part is set to zero.

      use fmvals_parallel
      implicit none

      integer :: integ
      type(multi) :: ma(2)
      intent (in) :: integ
      intent (inout) :: ma
      type(fm_settings) :: qx

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'ZMI2M'
      if (qx%ntrace /= 0) call fmntr_inpi(integ, qx)

      call fmi2m(integ, ma(1), qx)
      call fmi2m(0, ma(2), qx)

      if (qx%ntrace /= 0) call zmntr_out1(ma, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine zmi2m

      subroutine zmimag(ma, mbfm, qx)

!  mbfm = imag(ma)        imaginary part of ma

!  ma is a complex zm number, mbfm is a real fm number.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mbfm
      intent (in) :: ma
      intent (inout) :: mbfm
      type(fm_settings) :: qx

      qx%kflag = 0
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'ZMIMAG'
      if (qx%ntrace /= 0) call zmntr_inp1(ma, qx)

      call fmeq(ma(2), mbfm, qx)

      if (qx%ntrace /= 0) call fmntr_out1(mbfm, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine zmimag

      subroutine zminp(line, ma, la, lb, qx)

!  Convert an a1 character string to floating point multiple precision complex format.

!  line is an a1 character array of length lb to be converted to zm format and returned in ma.
!  Convert the section line(la:lb).

!  The input numbers may be in integer or any real format.
!  In exponential format the 'e' may also be 'd', 'q', or 'm'.

!  The following are all valid input strings:

!  1.23 + 4.56 i
!  1.23 + 4.56*i
!  2 + i
!  -i
!  1.23
!  4.56i
!  ( 1.23 , 4.56 )

!  So that zminp will convert any output from zmout, line is tested to see if the input contains any
!  of the special symbols +overflow, -overflow, +underflow, -underflow, or unknown.
!  For user input the abbreviations ovfl, unfl, unkn may be used.

      use fmvals_parallel
      implicit none

      integer :: la, lb
      character :: line(lb)
      type(multi) :: ma(2)
      intent (in) :: line, la, lb
      intent (inout) :: ma
      type(fm_settings) :: qx
      integer :: j, jstate, k, kdigfl, kflag1, kiflag, kpt, krsave, ksign, kstart, kstop,  &
                 kstopi, kstopr, kstrti, kstrtr, ktype, kval, ndsave, ntrsav

!  Simulate a finite-state automaton to scan the input line and build the number.
!  States 2-8 refer to the real part, states 10-16 refer to the imaginary part.
!  States of the machine:

!   1.  Initial entry to the subroutine
!   2.  Sign of the number
!   3.  Scanning digits before a decimal point
!   4.  Decimal point
!   5.  Scanning digits after a decimal point
!   6.  e, d, q, or m - precision indicator before the exponent
!   7.  Sign of the exponent
!   8.  Scanning exponent
!   9.  Comma between the real and imaginary part
!  10.  Sign of the number
!  11.  Scanning digits before a decimal point
!  12.  Decimal point
!  13.  Scanning digits after a decimal point
!  14.  e, d, q, or m - precision indicator before the exponent
!  15.  Sign of the exponent
!  16.  Scanning exponent
!  17.  Syntax error

!  Character types recognized by the machine:

!  1.  Sign (+,-)
!  2.  Numeral (0,1,...,9)
!  3.  Decimal point (.)
!  4.  Precision indicator (e,d,q,m)
!  5.  Illegal character for number
!  6.  Comma (,)
!  7.  Character to be ignored   ' '    '('    ')'    '*'

!  All blanks are ignored.  The analysis of the number proceeds as follows:  If the simulated
!  machine is in state jstate and a character of type jtype is encountered the new state of the
!  machine is given by jtrans_zm(jstate,jtype).

!  State  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16

      integer :: jtrans_zm(16, 4) = reshape(  (/                              &
          2, 17, 10, 10, 10,  7, 17, 10, 10, 17, 17, 17, 17, 15, 17, 17,      &
          3,  3,  3,  5,  5,  8,  8,  8, 11, 11, 11, 13, 13, 16, 16, 16,      &
          4,  4,  4, 17, 17, 17, 17, 17, 12, 12, 12, 17, 17, 17, 17, 17,      &
          6,  6,  6,  6,  6,  8, 17, 17, 14, 14, 14, 14, 14, 16, 17, 17   /)  &
        , (/ 16, 4 /) )
      type(multi) :: mxy(2)

      call zmalloc(ma, qx%ndig+2, qx)

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'ZMINP'
      ndsave = qx%ndig
      krsave = qx%kround
      qx%kround = 1
      qx%kflag = 0

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      if (qx%lhash == 0) call fmhtbl(qx)

!             Since arithmetic tracing is not usually desired during i/o conversion, disable
!             tracing during this routine.

      ntrsav = qx%ntrace
      qx%ntrace = 0

!             Increase the working precision.

      if (qx%ncall <= 2) then
          k = qx%ngrd52
          call fmndig(max(qx%ndig+k, 3), qx)
      endif
      kstart = la
      kstop = lb
      jstate = 1
      kstrtr = 0
      kstopr = 0
      kstrti = 0
      kstopi = 0
      kdigfl = 0
      kiflag = 0
      ksign = 1

!             Scan the number.

      do j = kstart, kstop
         if (line(j) == ' ' .or. line(j) == '(' .or. line(j) == ')' .or. line(j) == '*') cycle
         if (line(j) == 'I' .or. line(j) == 'i') then
             kiflag = 1
             if (kstrti == 0) then
                 kstrti = kstrtr
                 kstopi = kstopr
                 kstrtr = 0
                 kstopr = 0
             endif
             cycle
         endif

         kpt = ichar(line(j))
         if (kpt < lhash1 .or. kpt > lhash2) then
             write (qx%kw,                                                      &
                "(/' Error in input conversion.'/"                          //  &
                "' ICHAR function was out of range for the current', "      //  &
                "' dimensions.'/' ICHAR(''', A, ''') gave the value ', "    //  &
                "I12, ', which is outside the currently'/' dimensioned', "  //  &
                "' bounds of (', I5, ':', I5, ') for variables KHASHT ', "  //  &
                "'and KHASHV.'/' Re-define the two parameters ', "          //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain', "   //  &
                "' all possible output values from ICHAR.'//)"                  &
                   ) line(j), kpt, lhash1, lhash2
             ktype = 5
             kval  = 0
         else
             ktype = qx%khasht(kpt)
             kval  = qx%khashv(kpt)
         endif
         if (ktype == 2 .or. ktype == 5) kdigfl = 1
         if (line(j) == ',') then
             if (jstate < 9) then
                 jstate = 9
             else
                 call zminp2(ma, ndsave, ntrsav, krsave, qx)
                 return
             endif
         else
             if (ktype >= 5) ktype = 2
             if (jstate < 17) jstate = jtrans_zm(jstate, ktype)
         endif
         if (jstate == 9 .or. jstate == 10) kdigfl = 0
         if (jstate == 2 .or. jstate == 10) ksign = kval

         if (jstate >= 2 .and. jstate <= 8) then
             if (kstrtr == 0) kstrtr = j
             kstopr = j
         endif
         if (jstate >= 10 .and. jstate <= 16) then
             if (kstrti == 0) kstrti = j
             kstopi = j
         endif

      enddo

!             Form the number and return.

      if (kstrtr > 0) then
          qx%ncall = qx%ncall - 1
          call fminp(line, mxy(1), kstrtr, kstopr, qx)
          qx%ncall = qx%ncall + 1
      else
          call fmi2m2(0, mxy(1), qx)
      endif
      kflag1 = qx%kflag

      if (kstrti > 0) then
          if (kiflag == 1 .and. kdigfl == 0) then
              call fmi2m2(ksign, mxy(2), qx)
          else
              qx%ncall = qx%ncall - 1
              call fminp(line, mxy(2), kstrti, kstopi, qx)
              qx%ncall = qx%ncall + 1
          endif
      else if (kiflag == 1) then
          call fmi2m2(1, mxy(2), qx)
      else
          call fmi2m2(0, mxy(2), qx)
      endif

      if (kflag1 /= 0 .or. qx%kflag /= 0 .or. jstate == 17) then
          call zminp2(ma, ndsave, ntrsav, krsave, qx)
          return
      endif
      call fmequ(mxy(1), ma(1), qx%ndig, ndsave, qx)
      call fmequ(mxy(2), ma(2), qx%ndig, ndsave, qx)

      qx%ndig = ndsave
      qx%ntrace = ntrsav
      qx%kround = krsave
      qx%kflag = 0
      qx%ncall = qx%ncall - 1

      return
      end subroutine zminp

      subroutine zminp2(ma, ndsave, ntrsav, krsave, qx)

!  Handle error conditions for zminp.

      use fmvals_parallel
      implicit none

      integer :: ndsave, ntrsav, krsave
      type(multi) :: ma(2)
      intent (in) :: ndsave, ntrsav, krsave
      intent (inout) :: ma
      type(fm_settings) :: qx

      qx%kflag = -7
      call fmwarn(qx)
      call zmunknown(ma, qx)

      qx%ndig = ndsave
      qx%ntrace = ntrsav
      qx%kround = krsave
      qx%ncall = qx%ncall - 1

      return
      end subroutine zminp2

      subroutine zmint(ma, mb, qx)

!  mb = int(ma)

!  The integer parts of both real and imaginary values are returned.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'ZMINT'
      if (qx%ntrace /= 0) call zmntr_inp1(ma, qx)

      call fmint(ma(1), mb(1), qx)
      call fmint(ma(2), mb(2), qx)

      if (qx%ntrace /= 0) call zmntr_out1(mb, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine zmint

      subroutine zmipower(ma, ival, mb, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      type(fm_settings) :: qx

      call zmipwr(ma, ival, mb, qx)

      return
      end subroutine zmipower

      subroutine zmipwr(ma, ival, mb, qx)

!  mb = ma**ival

!  Raise a zm number to an integer power.
!  The binary multiplication method used requires an average of 1.5 * log2(ival) multiplications.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmipwr_sc(ma, ival, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmipwr_m1(ma, ival, mresult, ndsave, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmipwr

      subroutine zmipwr_m1(ma, ival, mresult, ndsave, qx)

!  Method 1 for computing ma**ival.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: ival, ndsave
      intent (in) :: ma, ival, ndsave
      intent (inout) :: mresult
      type(fm_settings) :: qx

      integer :: i2n, k, kwrnsv
      real :: xval
      type(multi) :: mz01(2), mz02(2), mz03(2), mz04(2), mz05(2)

      call zmequ(ma, mz01, ndsave, qx%ndig, qx)

      if (mz01(2)%mp(3) == 0) then
          call fmipwr(mz01(1), ival, mresult(1), qx)
          call fmi2m2(0, mresult(2), qx)
          return
      endif

      if (mz01(1)%mp(3) == 0) then
          if (ival >= 0) then
              i2n = mod(ival, 4)
          else
              i2n = mod(4 - mod(abs(ival), 4), 4)
          endif
          if (i2n == 0) then
              call fmipwr(mz01(2), ival, mresult(1), qx)
              call fmi2m2(0, mresult(2), qx)
          else if (i2n == 1) then
              call fmipwr(mz01(2), ival, mresult(2), qx)
              call fmi2m2(0, mresult(1), qx)
          else if (i2n == 2) then
              call fmipwr(mz01(2), ival, mresult(1), qx)
              call fmi2m2(0, mresult(2), qx)
              call fmnegate(mresult(1), qx)
          else if (i2n == 3) then
              call fmipwr(mz01(2), ival, mresult(2), qx)
              call fmi2m2(0, mresult(1), qx)
              call fmnegate(mresult(2), qx)
          endif
          return
      endif

      if (ival == -1) then
          kwrnsv = qx%kwarn
          qx%kwarn = 0
          k = int((5.0d0*qx%dlogtn)/qx%dlogmb + 2.0d0)
          call fmndig(max(qx%ndig+k, 3), qx)
          call zmi2m(1, mz02, qx)
          call zmequ(ma, mz03, ndsave, qx%ndig, qx)
          call zmdiv(mz02, mz03, mresult, qx)
          qx%kwarn = kwrnsv
          return
      endif

!             Increase the working precision.

      if (qx%ncall == 1) then
          xval = abs(ival) + 1
          k = int((5.0*real(qx%dlogtn) + 2.5*log(xval))/qx%alogmb + 3.0)
          if (qx%mbase <= 1000) k = 2*k
          call fmndig(max(qx%ndig+k, 3), qx)
      else
          xval = abs(ival) + 1
          k = int(log(xval)/qx%alogmb + 1.0)
          call fmndig(qx%ndig + k, qx)
      endif
      call zmequ(ma, mz02, ndsave, qx%ndig, qx)

!             Initialize.

      kwrnsv = qx%kwarn
      qx%kwarn = 0
      k = abs(ival)
      if (mod(k, 2) == 0) then
          call zmi2m(1, mz05, qx)
      else
          call zmeq(mz02, mz05, qx)
      endif

!             This is the multiplication loop.

      do while (k > 1)
         k = k/2
         call zmsqr(mz02, mz04, qx)
         call zmeq(mz04, mz02, qx)
         if (mod(k, 2) == 1) then
             call zmmpy_r2(mz02, mz05, qx)
         endif
      enddo

!             Invert if the exponent is negative.

      if (ival < 0) then
          call zmi2m(1, mz02, qx)
          call zmdiv_r2(mz02, mz05, qx)
      endif
      qx%kwarn = kwrnsv

      call zmeq(mz05, mresult, qx)

      return
      end subroutine zmipwr_m1

      subroutine zmipwr_sc(ma, ival, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = ma**ival.

!  kresult = 1 is returned if a special case gives the value of ma**ival.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: ival, kresult, ndsave
      intent (in) :: ma, ival, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMIPWR   '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1i(ma, ival, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
          if (ival == 0) then
              call zmunknown(mresult, qx)
          else
              call zmi2m(0, mresult, qx)
          endif
          kresult = 1
          return
      endif

      if (ival == 1) then
          call zmeq(malocal, mresult, qx)
          kresult = 1
          return
      else if (ival == 2) then
          call zmsqr(malocal, mresult, qx)
          kresult = 1
          return
      else if (ival == 0) then
          call zmi2m(1, mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmipwr_sc

      subroutine zmlg10(ma, mb, qx)

!  mb = log10(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy, mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmlg10_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmlg10_m1(ma, mxy, mresult, ndsave, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmlg10

      subroutine zmlg10_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing log10(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mxy, mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      type(multi) :: mz01(2), mz02(2)

      call zmequ(ma, mz01, ndsave, qx%ndig, qx)
      call zmln(mz01, mz02, qx)
      call fmlni(10, mxy, qx)
      qx%ndigli = 0
      call fmdivd(mz02(1), mz02(2), mxy, mresult(1), mresult(2), qx)

      return
      end subroutine zmlg10_m1

      subroutine zmlg10_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = log10(ma).

!  kresult = 1 is returned if a special case gives the value of log10(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMLG10   '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmlg10_sc

      subroutine zmln(ma, mb, qx)

!  mb = ln(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(4), mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmln_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmln_m1(ma, mxy, mresult, ndsave, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmln

      subroutine zmln_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing ln(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mxy(4), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: kf1, krsave
      type(multi) :: mz01(2), mz02(2)
      logical, external :: fmcomp

      call zmequ(ma, mz02, ndsave, qx%ndig, qx)

      krsave = qx%krad
      qx%krad = 1
      if (ma(2)%mp(3) == 0) then
          if (ma(1)%mp(1) < 0) then
              call fmeq(mz02(1), mz01(1), qx)
              call fmnegate(mz01(1), qx)
              call fmln(mz01(1), mxy(4), qx)
              qx%ndigli = 0
              call fmeq(mxy(4), mz01(1), qx)
              call fmpi(mz01(2), qx)
              qx%ndigpi = 0
          else
              call fmln(mz02(1), mz01(1), qx)
              qx%ndigli = 0
              call fmi2m(0, mz01(2), qx)
          endif
          qx%krad = krsave
          call zmeq(mz01, mresult, qx)
          return
      else if (ma(1)%mp(3) == 0) then
          if (ma(2)%mp(1) < 0) then
              call fmeq(mz02(2), mz01(1), qx)
              call fmnegate(mz01(1), qx)
              call fmln(mz01(1), mxy(4), qx)
              qx%ndigli = 0
              call fmeq(mxy(4), mz01(1), qx)
              call fmpi(mz01(2), qx)
              qx%ndigpi = 0
              call fmdivi_r1(mz01(2), -2, qx)
          else
              call fmln(mz02(2), mz01(1), qx)
              qx%ndigli = 0
              call fmpi(mz01(2), qx)
              qx%ndigpi = 0
              call fmdivi_r1(mz01(2), 2, qx)
          endif
          qx%krad = krsave
          call zmeq(mz01, mresult, qx)
          return
      endif

!             ln(a + b i) = ln(abs(a + b i)) + arg(a + b i) i.

      call fmabs(mz02(1), mxy(1), qx)
      call fmabs(mz02(2), mxy(2), qx)

!             Check for cancellation in ln(x).

      call fmi2m(1, mxy(3), qx)
      kf1 = 0
      if (fmcomp(mxy(1), '==', mxy(3), qx) .and. mxy(2)%mp(2) <= -ndsave) kf1 = 1
      if (fmcomp(mxy(2), '==', mxy(3), qx) .and. mxy(1)%mp(2) <= -ndsave) kf1 = 1

      if (fmcomp(mxy(1), '>=', mxy(2), qx)) then
          call fmsub(mz02(1), mxy(3), mxy(1), qx)
          call fmadd(mz02(1), mxy(3), mxy(2), qx)
          call fmmpy_r1(mxy(1), mxy(2), qx)
          call fmsqr(mz02(2), mxy(2), qx)
          call fmadd_r2(mxy(1), mxy(2), qx)
      else
          call fmsub(mz02(2), mxy(3), mxy(1), qx)
          call fmadd(mz02(2), mxy(3), mxy(2), qx)
          call fmmpy_r1(mxy(1), mxy(2), qx)
          call fmsqr(mz02(1), mxy(2), qx)
          call fmadd_r2(mxy(1), mxy(2), qx)
      endif
      call zmabs(mz02, mz01(1), qx)
      call fmadd(mz01(1), mxy(3), mxy(1), qx)
      call fmdiv_r2(mxy(2), mxy(1), qx)
      if (kf1 == 1) then
          call fmeq(mxy(1), mz01(1), qx)
          call fmatn2(mz02(2), mz02(1), mz01(2), qx)
          qx%krad = krsave
          call zmeq(mz01, mresult, qx)
          return
      else if (mxy(1)%mp(2) < 0) then
          call fmndig(qx%ndig - int(mxy(1)%mp(2)), qx)
          if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
          call zmequ_r1(mz02, ndsave, qx%ndig, qx)
          call zmabs(mz02, mz01(1), qx)
      endif

      call fmln(mz01(1), mxy(4), qx)
      qx%ndigli = 0
      call fmeq(mxy(4), mz01(1), qx)
      call fmatn2(mz02(2), mz02(1), mz01(2), qx)
      qx%krad = krsave

      call zmeq(mz01, mresult, qx)

      return
      end subroutine zmln_m1

      subroutine zmln_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = ln(ma).

!  kresult = 1 is returned if a special case gives the value of ln(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMLN     '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          qx%kflag = -4
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmln_sc

      subroutine zmlngm(ma, mb, qx)

!  mb = LogGamma(ma)

!  In the complex plane this Log Gamma function is not identical to ln(gamma(ma)), because of
!  branch points in the complex log function.

!  This function returns the function value of the principal branch of the log gamma function.
!  It is the same as ln(gamma(ma)) when ma is a positive real number, but it can differ from
!  ln(gamma(ma)) by an integer multiple of 2*pi*i elsewhere.  Note that we still have
!  gamma(z) = exp(loggamma(z)) = exp(ln(gamma(z))) even when they differ.

!     Ref:  d.e.g. Hare, "Computing the Principal Branch of log-Gamma"
!           Journal of Algorithms, Volume 25, Issue 2, November 1997, Pages 221-236

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(2, 15), mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmlngm_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call zmlngm_m1(ma, mxy, mresult, ndsave, numtry, qx)
         qx%numbrn = 0
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
         numtry = numtry + 1
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmlngm

      subroutine zmlngm_m1(ma, mxy, mresult, ndsave, numtry, qx)

!  Method 1 for computing lngm(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mbern(lmbern)
      integer :: ndbern(lmbern)
      type(multi) :: ma(2), mxy(2, 15), mresult(2)
      integer :: ndsave, numtry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: x, xe, xk, xs
      integer :: j, j1, j2, jc, js, kl, ks, kt, kz, large, nd, nd1, ndsav1, nterm
      type(multi) :: mjsums(2, ljsums)
      logical, external :: fmcomp

      call zmequ(ma, mxy(1:2, 1), ndsave, qx%ndig, qx)

!             Check for special cases.

      if (ma(2)%mp(3) == 0) then
          call fmint(mxy(1, 1), mxy(1, 15), qx)
          if (fmcomp(mxy(1, 1), '==', mxy(1, 15), qx)) then
              call zmunknown(mresult, qx)
              qx%kflag = -4
              return
          endif
      endif
      call zmabs(mxy(1:2, 1), mxy(1, 2), qx)
      call fmi2m(1, mxy(1, 4), qx)
      if (fmcomp(mxy(1, 2), '<', mxy(1, 4), qx)) then
          call zmln(mxy(1:2, 1), mxy(1:2, 4), qx)
          call zmnegate(mxy(1:2, 4), qx)
          call fmeuler(mxy(1, 5), qx)
          call fmi2m(0, mxy(2, 5), qx)
          call zmmpy_r1(mxy(1:2, 5), mxy(1:2, 1), qx)
          call zmsub_r1(mxy(1:2, 4), mxy(1:2, 5), qx)
          call fmpi(mxy(1, 3), qx)
          qx%ndigpi = 0
          call fmsqr_r1(mxy(1, 3), qx)
          call fmdivi_r1(mxy(1, 3), 12, qx)
          call fmi2m(0, mxy(2, 3), qx)
          call zmsqr(mxy(1:2, 1), mxy(1:2, 5), qx)
          call zmmpy(mxy(1:2, 3), mxy(1:2, 5), mxy(1:2, 6), qx)
          call zmadd_r1(mxy(1:2, 4), mxy(1:2, 6), qx)
          call zmmpy_r1(mxy(1:2, 5), mxy(1:2, 1), qx)
          call zmmpyi(mxy(1:2, 5), 4, mxy(1:2, 6), qx)
          call zmdivi_r1(mxy(1:2, 6), 10, qx)
          call zmsub(mxy(1:2, 4), mxy(1:2, 6), mresult, qx)
          if (qx%kflag == 1) then
              return
          endif
      endif
      if (mxy(2, 1)%mp(2) == qx%mexpun) then
          call fmlngm(mxy(1, 1), mxy(1, 3), qx)
          call fmpsi(mxy(1, 1), mxy(1, 4), qx)
          call fmmpy(mxy(2, 1), mxy(1, 4), mxy(2, 3), qx)
          call zmeq(mxy(1:2, 3), mresult, qx)
          return
      endif

!             x is a double precision approximation to the size of input argument to this function.

      call zmabs(mxy(1:2, 1), mxy(1, 4), qx)
      call fmm2dp(mxy(1, 4), x, qx)
      call fmovun_xe(mxy(1, 4), xe, qx)
      if (qx%kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax**0.33d0
      else if (qx%kflag == 0 .and. x < 1.0d0/dpmax**0.33d0) then
          x = 1.0d0/dpmax**0.33d0
      endif
      if (qx%kflag /= 0 .and. xe > 0) then
          x = dpmax**0.33d0
      else if (qx%kflag == 0 .and. x > dpmax**0.33d0) then
          x = dpmax**0.33d0
      endif

!             Determine the smallest shift js for which the asymptotic series for ln(gamma(x+js))
!             converges for the current precison.

      call zmeq(mxy(1:2, 1), mxy(1:2, 2), qx)
      mxy(1, 2)%mp(1) = 1
      xk = 1.5d0*log(abs(x)) - 2*3.14159*abs(x)
      if (abs(x) < 2) xk = 0
      if (-xk/qx%dlogmb > qx%ndig+(3+qx%ndig/20)*qx%ngrd52) then
          js = 0
      else
          j1 = 1
          j2 = j1
          do while (-xk/qx%dlogmb <= qx%ndig+(3+qx%ndig/20)*qx%ngrd52)
             j2 = 2*j2
             call zmi2m(j2, mxy(1:2, 5), qx)
             call zmadd(mxy(1:2, 2), mxy(1:2, 5), mxy(1:2, 6), qx)
             call zmabs(mxy(1:2, 6), mxy(1, 4), qx)
             call fmm2dp(mxy(1, 4), xs, qx)
             xk = 1.5d0*log(xs) - 2*3.14159*xs
          enddo
          js = j2
          do while (abs(j2-j1) > 1)
             js = (j1 + j2) / 2
             call zmi2m(js, mxy(1:2, 5), qx)
             call zmadd(mxy(1:2, 2), mxy(1:2, 5), mxy(1:2, 6), qx)
             call zmabs(mxy(1:2, 6), mxy(1, 4), qx)
             call fmm2dp(mxy(1, 4), xs, qx)
             xk = 1.5d0*log(xs) - 2*3.14159*xs
             if (-xk/qx%dlogmb > qx%ndig+(3+qx%ndig/20)*qx%ngrd52) then
                 j2 = js
             else
                 j1 = js
             endif
          enddo
      endif

!             Use the asymptotic series after replacing input z by 1-z via the reflection formula
!             if re(z) < 0, by conjugate(z) if im(z) < 0, and by z+js if needed for enough accuracy.

      call zmeq(mxy(1:2, 1), mxy(1:2, 2), qx)
      if (ma(1)%mp(1) < 0) then
          call zmi2m(1, mxy(1:2, 15), qx)
          call zmsub_r2(mxy(1:2, 15), mxy(1:2, 2), qx)
      endif
      jc = 0
      if (mxy(2, 2)%mp(1) < 0) then
          jc = 1
          call fmnegate(mxy(2, 2), qx)
      endif
      call zmi2m(js, mxy(1:2, 5), qx)
      call zmadd_r1(mxy(1:2, 2), mxy(1:2, 5), qx)
      if (numtry <= 0 .and. qx%ncall <= 1) then
          call fmndig(max(ndsave+qx%ngrd52, qx%ndig-1), qx)
      endif
      j2 = int(0.3*qx%alogmb + 0.2*sqrt(real(qx%ndig)))
      j2 = max(1, min(ljsums, j2))

      ndsav1 = qx%ndig

!             Split into j2 concurrent sums.

      call zmsqr(mxy(1:2, 2), mxy(1:2, 6), qx)
      call zmi2m(1, mxy(1:2, 15), qx)
      call zmdiv_r2(mxy(1:2, 15), mxy(1:2, 6), qx)
      call zmipwr(mxy(1:2, 6), j2, mxy(1:2, 7), qx)
      call zmeq(mxy(1:2, 2), mxy(1:2, 8), qx)

      nterm = 0
      call zmln(mxy(1:2, 2), mxy(1:2, 10), qx)
      call zmi2m(1, mxy(1:2, 11), qx)
      call zmdivi_r1(mxy(1:2, 11), 2, qx)
      call zmsub(mxy(1:2, 2), mxy(1:2, 11), mxy(1:2, 12), qx)
      call zmmpy(mxy(1:2, 10), mxy(1:2, 12), mxy(1:2, 11), qx)
      call zmsub(mxy(1:2, 11), mxy(1:2, 2), mxy(1:2, 10), qx)
      call fmpi(mxy(1, 11), qx)
      qx%ndigpi = 0
      call fmmpyi_r1(mxy(1, 11), 2, qx)
      call fmln(mxy(1, 11), mxy(1, 12), qx)
      qx%ndigli = 0
      call fmdivi_r1(mxy(1, 12), 2, qx)
      call fmi2m(0, mxy(2, 12), qx)
      call zmadd(mxy(1:2, 10), mxy(1:2, 12), mjsums(1:2, 1), qx)
      do j = 2, j2
         nterm = nterm + 1
         call fmbern(2*nterm, mxy(1, 8), mxy(1, 15), mbern, ndbern, qx)
         call fmbern(2*nterm, mxy(2, 8), mxy(2, 15), mbern, ndbern, qx)
         call zmdivi(mxy(1:2, 15), (2*nterm-1)*2*nterm, mjsums(1:2, j), qx)
      enddo

      call zmi2m(0, mxy(1:2, 9), qx)
      call zmi2m(0, mxy(1:2, 13), qx)
      call zmeq(mjsums(1:2, j2), mxy(1:2, 13), qx)

      kl = 1
      do while (kl == 1)
         call zmmpy_r2(mxy(1:2, 7), mxy(1:2, 8), qx)
         do j = 1, j2
            nterm = nterm + 1
            large = int(intmax/(2*nterm))/(2*nterm)
            call fmbern(2*nterm, mxy(1, 8), mxy(1, 15), mbern, ndbern, qx)
            call fmbern(2*nterm, mxy(2, 8), mxy(2, 15), mbern, ndbern, qx)
            if (nterm < large) then
                call zmdivi_r1(mxy(1:2, 15), (2*nterm-1)*2*nterm, qx)
            else
                call zmdivi_r1(mxy(1:2, 15), 2*nterm-1, qx)
                call zmdivi_r1(mxy(1:2, 15), 2*nterm, qx)
            endif
            call fmndig(ndsav1, qx)
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 15), qx)
            if (qx%kflag /= 0) then
                kl = 0
                exit
            endif
            if (j == j2) then
                call zmeq(mxy(1:2, 9), mxy(1:2, 13), qx)
                call zmeq(mxy(1:2, 15), mxy(1:2, 9), qx)
            endif
            kt = max(19000, int(6*qx%alogmt*ndsave))
            if (nterm > kt) then
                call zmabs(mxy(1:2, 9), mxy(1, 15), qx)
                call zmabs(mxy(1:2, 13), mxy(2, 15), qx)
                if (fmcomp(mxy(1, 15), '>', mxy(2, 15), qx)) then
                    call zmunknown(mresult, qx)
                    return
                endif
            endif
            nd = mjsums(1, j)%mp(2)-mxy(1, 15)%mp(2)
            nd1 = mjsums(2, j)%mp(2)-mxy(2, 15)%mp(2)
            nd = ndsav1 - int(min(nd, nd1))
            call fmndig(min(ndsav1, nd), qx)
            if (qx%ndig < max(3, qx%ngrd22)) qx%ndig = max(3, qx%ngrd22)
         enddo
      enddo

!             Put the j2 separate sums back together.

      qx%kflag = 0
      call zmi2m(1, mxy(1:2, 5), qx)
      do j = 2, j2
         call zmmpy_r1(mxy(1:2, 5), mxy(1:2, 6), qx)
         call zmmpy(mxy(1:2, 5), mjsums(1:2, j), mxy(1:2, 15), qx)
         call zmadd_r2(mxy(1:2, 15), mjsums(1:2, 1), qx)
      enddo
      call zmeq(mjsums(1:2, 1), mxy(1:2, 3), qx)

!             Reverse the effects of modifying the original argument.

!             Reverse any shifting.

      kz = 0
      ks = 1
      if (js /= 0) then
          call zmeq(mxy(1:2, 1), mxy(1:2, 14), qx)
          if (ma(1)%mp(1) < 0) then
              call zmi2m(1, mxy(1:2, 15), qx)
              call zmsub_r2(mxy(1:2, 15), mxy(1:2, 14), qx)
          endif
          if (mxy(2, 14)%mp(1) < 0) then
              call fmnegate(mxy(2, 14), qx)
          endif
          call zmi2m(1, mxy(1:2, 15), qx)
          do j = 1, js
             call zmmpy_r1(mxy(1:2, 15), mxy(1:2, 14), qx)
             if (mxy(2, 15)%mp(1) < 0 .and. ks == 1) kz = kz + 1
             ks = mxy(2, 15)%mp(1)
             call fmaddi(mxy(1, 14), 1, qx)
          enddo
          call zmln(mxy(1:2, 15), mxy(1:2, 14), qx)
          call zmsub_r1(mxy(1:2, 3), mxy(1:2, 14), qx)
          call fmpi(mxy(2, 14), qx)
          qx%ndigpi = 0
          call fmmpyi_r1(mxy(2, 14), 2*kz, qx)
          call fmsub_r1(mxy(2, 3), mxy(2, 14), qx)
      endif

!             Reverse any conjugate.

      if (jc == 1) then
          call fmnegate(mxy(2, 3), qx)
      endif

!             Reverse any reflection.

      if (ma(1)%mp(1) < 0) then
          call fmpi(mxy(1, 14), qx)
          qx%ndigpi = 0
          call fmi2m(0, mxy(2, 14), qx)
          call zmmpy(mxy(1:2, 14), mxy(1:2, 1), mxy(1:2, 15), qx)
          call zmsin(mxy(1:2, 15), mxy(1:2, 13), qx)
          if (abs(mxy(1, 13)%mp(2)) >= qx%mexpov .or.  &
              abs(mxy(2, 13)%mp(2)) >= qx%mexpov) then
              call fmcos_sin(mxy(1, 15), mxy(2, 10), mxy(1, 10), qx)
              if (mxy(2, 15)%mp(1) < 0) call fmnegate(mxy(2, 10), qx)
              call zmarg(mxy(1:2, 10), mxy(2, 13), qx)
              call fmnegate(mxy(2, 13), qx)
              call fmmpyi(mxy(1, 14), 2, mxy(1, 12), qx)
              call fmln(mxy(1, 12), mxy(1, 13), qx)
              qx%ndigli = 0
              call fmabs(mxy(2, 15), mxy(1, 12), qx)
              call fmsub_r1(mxy(1, 13), mxy(1, 12), qx)
          else
              call zmdiv(mxy(1:2, 14), mxy(1:2, 13), mxy(1:2, 15), qx)
              call zmln(mxy(1:2, 15), mxy(1:2, 13), qx)
          endif
          call zmsub_r2(mxy(1:2, 13), mxy(1:2, 3), qx)
          call fmdivi(mxy(1, 1), 2, mxy(1, 15), qx)
          if (ma(2)%mp(3) == 0) then
              call fmi2m(4, mxy(1, 13), qx)
          else
              call fmi2m(3, mxy(1, 13), qx)
          endif
          call fmdivi_r1(mxy(1, 13), 4, qx)
          call fmsub_r1(mxy(1, 15), mxy(1, 13), qx)
          call fmint(mxy(1, 15), mxy(1, 11), qx)
          call fmsub(mxy(1, 15), mxy(1, 11), mxy(1, 12), qx)
          if (mxy(1, 12)%mp(3) == 0) then
              call fmeq(mxy(1, 15), mxy(1, 13), qx)
          else if (mxy(1, 15)%mp(1) > 0) then
              call fmaddi(mxy(1, 11), 1, qx)
              call fmeq(mxy(1, 11), mxy(1, 13), qx)
          else
              call fmeq(mxy(1, 11), mxy(1, 13), qx)
          endif
          call fmmpy(mxy(1, 13), mxy(1, 14), mxy(1, 11), qx)
          if (ma(2)%mp(1) < 0) then
              call fmmpyi_r1(mxy(1, 11), -2, qx)
          else
              call fmmpyi_r1(mxy(1, 11), 2, qx)
          endif
          call fmadd_r1(mxy(2, 3), mxy(1, 11), qx)
      endif

      call zmeq(mxy(1:2, 3), mresult, qx)

      return
      end subroutine zmlngm_m1

      subroutine zmlngm_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = lngm(ma).

!  kresult = 1 is returned if a special case gives the value of lngm(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMLNGM   '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

!             If ma is real and positive, use fmlngm.

      if (malocal(2)%mp(3) == 0) then
          if (malocal(1)%mp(1) > 0 .and. malocal(1)%mp(3) > 0) then
              call fmlngm(malocal(1), mresult(1), qx)
              call fmi2m(0, mresult(2), qx)
              kresult = 1
              return
          endif
      endif

      return
      end subroutine zmlngm_sc

      subroutine zmlog10(ma, mb, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      call zmlg10(ma, mb, qx)

      return
      end subroutine zmlog10

      subroutine zmm2i(ma, integ, qx)

!  integ = ma

!  integ is set to the integer value of the real part of ma

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2)
      integer :: integ
      intent (in) :: ma
      intent (inout) :: integ
      type(fm_settings) :: qx

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'ZMM2I'
      if (qx%ntrace /= 0) call zmntr_inp1(ma, qx)

      call fmm2i(ma(1), integ, qx)

      if (qx%ntrace /= 0) call fmntr_outi(integ, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine zmm2i

      subroutine zmm2z(ma, zval, qx)

!  zval = ma

!  Complex variable zval is set to ma.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2)
      complex :: zval
      intent (in) :: ma
      intent (inout) :: zval
      type(fm_settings) :: qx

      real :: di, dr

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'ZMM2Z'
      if (qx%ntrace /= 0) call zmntr_inp1(ma, qx)

      call fmm2sp(ma(1), dr, qx)
      call fmm2sp(ma(2), di, qx)
      zval = cmplx(dr, di)

      if (qx%ntrace /= 0) call fmntr_outz(zval, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine zmm2z

      subroutine zmmpy(ma, mb, mc, qx)

!  mc = ma * mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kr_retry, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(7), mresult(2)

      call zmalloc(mc, qx%ndig+2, qx)
      call zmenter2(ma, mb, kovun, mxsave, ndsave, qx)
      call zmmpy_sc(ma, mb, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mc, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      kr_retry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call zmmpy_m1(ma, mb, mxy, mresult, ndsave, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
         kr_retry = kr_retry + 1
         if (kr_retry > 1) exit
      enddo

      call zmexit1(mresult, mc, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmmpy

      subroutine zmmpy_m1(ma, mb, mxy, mresult, ndsave, qx)

!  Method 1 for computing  mc = ma / mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2), mxy(7), mresult(2)
      integer :: ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: kl, nds, nmethd, ntrsav
      real (kind(1.0d0)) :: maxexp
      type(multi) :: mz01(2)

      call fmequ(ma(1), mxy(4), ndsave, qx%ndig, qx)
      call fmequ(ma(2), mxy(5), ndsave, qx%ndig, qx)
      call fmequ(mb(1), mxy(6), ndsave, qx%ndig, qx)
      call fmequ(mb(2), mxy(7), ndsave, qx%ndig, qx)
      ntrsav = qx%ntrace
      qx%ntrace = 0

!             Check for special cases.

      nmethd = 1

!             If precision is low, use a slower but more stable form of the multiplication formula.

      if (qx%ndig >= 35) nmethd = 2

      kl = 1
      do while (kl == 1)
         kl = 0
         if (abs(mxy(4)%mp(2)) >= qx%mexpov .or. abs(mxy(5)%mp(2)) >= qx%mexpov .or.  &
             abs(mxy(6)%mp(2)) >= qx%mexpov .or. abs(mxy(7)%mp(2)) >= qx%mexpov ) then
             call zmi2m(0, mz01, qx)
             call zmmpy_unov(mxy(4), mxy(5), mxy(6), mxy(7), mresult, qx)
             qx%ntrace = ntrsav
             return
         else if (nmethd == 1) then

!             Method 1 for  ( a + b i ) * ( c + d i )

!             result = a*c - b*d + ( a*d + b*c ) i

             call fmmpyd(mxy(4), mxy(6), mxy(7), mz01(1), mz01(2), qx)
             call fmmpyd(mxy(5), mxy(7), mxy(6), mxy(1), mxy(2), qx)
             maxexp = max(mz01(1)%mp(2), mxy(1)%mp(2))
             call fmsub_r1(mz01(1), mxy(1), qx)
             if (mz01(1)%mp(2) < maxexp) exit
             maxexp = max(mz01(2)%mp(2), mxy(2)%mp(2))
             call fmadd_r1(mz01(2), mxy(2), qx)
             if (mz01(2)%mp(2) < maxexp) exit
             kl = 2
             exit
         else

!             Method 2 for  ( a + b i ) * ( c + d i )

!             p = ( a + b )*( c + d )
!             result = a*c - b*d + ( p - a*c - b*d ) i

             call fmadd(mxy(4), mxy(5), mxy(1), qx)
             call fmadd(mxy(6), mxy(7), mxy(2), qx)
             call fmmpy_r1(mxy(1), mxy(2), qx)

             call fmmpy(mxy(4), mxy(6), mxy(2), qx)
             call fmmpy(mxy(5), mxy(7), mxy(3), qx)

             maxexp = max(mxy(2)%mp(2), mxy(3)%mp(2))
             call fmsub(mxy(2), mxy(3), mz01(1), qx)
             if (mz01(1)%mp(2) < maxexp) exit
             maxexp = max(mxy(1)%mp(2), mxy(2)%mp(2))
             maxexp = max(maxexp, mxy(3)%mp(2))
             call fmsub(mxy(1), mxy(2), mz01(2), qx)
             call fmsub_r1(mz01(2), mxy(3), qx)
             if (mz01(2)%mp(2) < maxexp) exit
             kl = 2
             exit
         endif
      enddo

      if (kl == 0) then
          nds = qx%ndig
          call fmndig(2*qx%ndig, qx)
          call fmequ(ma(1), mxy(4), ndsave, qx%ndig, qx)
          call fmequ(ma(2), mxy(5), ndsave, qx%ndig, qx)
          call fmequ(mb(1), mxy(6), ndsave, qx%ndig, qx)
          call fmequ(mb(2), mxy(7), ndsave, qx%ndig, qx)
          call fmmpyd(mxy(4), mxy(6), mxy(7), mz01(1), mz01(2), qx)
          call fmmpyd(mxy(5), mxy(7), mxy(6), mxy(1), mxy(2), qx)
          call fmsub_r1(mz01(1), mxy(1), qx)
          call fmadd_r1(mz01(2), mxy(2), qx)
          call fmndig(nds, qx)
      endif

      call zmeq(mz01, mresult, qx)
      qx%ntrace = ntrsav

      return
      end subroutine zmmpy_m1

      subroutine zmmpy_r1(ma, mb, qx)

!  ma = ma * mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (inout) :: ma
      intent (in) :: mb
      type(fm_settings) :: qx

      type(multi) :: mxy(2)

      call zmmpy(ma, mb, mxy, qx)
      call zmeq(mxy, ma, qx)

      end subroutine zmmpy_r1

      subroutine zmmpy_r2(ma, mb, qx)

!  mb = ma * mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      type(multi) :: mxy(2)

      call zmmpy(ma, mb, mxy, qx)
      call zmeq(mxy, mb, qx)

      end subroutine zmmpy_r2

      subroutine zmmpy_sc(ma, mb, ndsave, mresult, kresult, qx)

!  Check for special cases for  mc = ma * mb

!  kresult = 1 is returned if a special case gives the value of the result.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2), mblocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMMPY    '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp2(ma, mb, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)
      call zmequ(mb, mblocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0) .or.  &
          (mblocal(1)%mp(2) == qx%munkno .and. mblocal(1)%mp(5) >= 0) .or.  &
          (mblocal(2)%mp(2) == qx%munkno .and. mblocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if ((malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) .or.  &
          (mblocal(1)%mp(3) == 0 .and. mblocal(2)%mp(3) == 0)) then
          call zmi2m(0, mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmmpy_sc

      subroutine zmmpy_unov(ma, mb, mc, md, mz, qx)

!  Check special cases where at least one of ma, mb, mc, md is underflow or overflow.

!  Return mz as the result.

      use fmvals_parallel
      implicit none

      type(multi) :: ma, mb, mc, md, mz(2)
      intent (inout) :: mz
      intent (in) :: ma, mb, mc, md
      type(fm_settings) :: qx

      type(multi) :: mxy(8)
      double precision :: a_xe, a_xf, b_xe, b_xf, c_xe, c_xf, d, d_xe, d_xf, t1, t2, t3, t4


      call fmmpy(ma, mc, mxy(1), qx)
      call fmmpy(mb, md, mxy(2), qx)
      call fmmpy(ma, md, mxy(3), qx)
      call fmmpy(mb, mc, mxy(4), qx)
      call fmsub(mxy(1), mxy(2), mz(1), qx)
      call fmadd(mxy(3), mxy(4), mz(2), qx)
      if (mz(1)%mp(2) /= qx%munkno .and. mz(2)%mp(2) /= qx%munkno) return
      if (.not. ( (mz(1)%mp(2) == qx%munkno .and. mz(1)%mp(5) >= 0) .or.  &
                  (mz(2)%mp(2) == qx%munkno .and. mz(2)%mp(5) >= 0) )) return

      call fmsqr(ma, mxy(8), qx)
      call fmsqr(mb, mxy(5), qx)
      call fmadd(mxy(8), mxy(5), mxy(7), qx)
      call fmsqr(mc, mxy(8), qx)
      call fmsqr(md, mxy(5), qx)
      call fmadd(mxy(8), mxy(5), mxy(6), qx)
      call fmmpy(mxy(7), mxy(6), mxy(5), qx)
      call fmovun_xexf(ma, a_xe, a_xf, qx)
      call fmovun_xexf(mb, b_xe, b_xf, qx)
      call fmovun_xexf(mc, c_xe, c_xf, qx)
      call fmovun_xexf(md, d_xe, d_xf, qx)
      if (huge(qx%mbase)/qx%mexpov > 1.0d+20) then
          d = 1.0d+10
      else
          d = 4
      endif
      t1 = max(a_xe, b_xe) + max(c_xe, d_xe)
      if (t1 >= (huge(qx%mbase)/d)/2 .or. t1 <= -(huge(qx%mbase)/d)/2) then
          mxy(5)%mp(4) = t1
          call fmeq(mxy(5), mxy(8), qx)
      else
          call fmsqrt(mxy(5), mxy(8), qx)
      endif
      if (mxy(8)%mp(2) /= qx%munkno .and. abs(mxy(8)%mp(2)) == qx%mexpov) then
          call fmovun_xexf(ma, a_xe, a_xf, qx)
          call fmovun_xexf(mb, b_xe, b_xf, qx)
          call fmovun_xexf(mc, c_xe, c_xf, qx)
          call fmovun_xexf(md, d_xe, d_xf, qx)
          t3 = qx%dlogmb*(a_xe - b_xe)/2 + log(a_xf)
          t4 = qx%dlogmb*(b_xe - a_xe)/2 + log(b_xf)
          if (log(tiny(t3)) <= t3 .and. t3 <= log(huge(t3))) then
              t3 = ma%mp(1) * dble(qx%mbase)**( (a_xe - b_xe)/2 ) * a_xf
              t4 = mb%mp(1) * dble(qx%mbase)**( (b_xe - a_xe)/2 ) * b_xf
              t1 = atan2(t4, t3)
          else
              if (ma%mp(1) > 0 .and. a_xe > b_xe) then
                  t1 = 0
              else if (mb%mp(1) > 0 .and. b_xe > a_xe) then
                  t1 = asin(1.0d0)
              else if (mb%mp(1) < 0 .and. b_xe > a_xe) then
                  t1 = asin(-1.0d0)
              else if (ma%mp(1) < 0 .and. mb%mp(1) > 0 .and. a_xe > b_xe) then
                  t1 = acos(-1.0d0)
              else
                  t1 = -acos(-1.0)
              endif
          endif

          t3 = qx%dlogmb*(c_xe - d_xe)/2 + log(c_xf)
          t4 = qx%dlogmb*(d_xe - c_xe)/2 + log(d_xf)
          if (log(tiny(t3)) <= t3 .and. t3 <= log(huge(t3))) then
              t3 = mc%mp(1) * dble(qx%mbase)**( (c_xe - d_xe)/2 ) * c_xf
              t4 = md%mp(1) * dble(qx%mbase)**( (d_xe - c_xe)/2 ) * d_xf
              t2 = atan2(t4, t3)
          else
              if (mc%mp(1) > 0 .and. c_xe > d_xe) then
                  t2 = 0
              else if (md%mp(1) > 0 .and. d_xe > c_xe) then
                  t2 = asin(1.0d0)
              else if (md%mp(1) < 0 .and. d_xe > c_xe) then
                  t2 = asin(-1.0d0)
              else if (mc%mp(1) < 0 .and. md%mp(1) > 0 .and. c_xe > d_xe) then
                  t2 = acos(-1.0d0)
              else
                  t2 = -acos(-1.0)
              endif
          endif

          call fmdp2m(cos(t1+t2), mxy(6), qx)
          call fmmpy(mxy(6), mxy(8), mz(1), qx)
          call fmdp2m(sin(t1+t2), mxy(6), qx)
          call fmmpy(mxy(6), mxy(8), mz(2), qx)
          if (mz(1)%mp(2) /= qx%munkno .and. mz(2)%mp(2) /= qx%munkno) return
      else if (abs(mxy(8)%mp(2)) < qx%mexpov) then
          call fmovun_xexf(ma, a_xe, a_xf, qx)
          call fmovun_xexf(mb, b_xe, b_xf, qx)
          call fmovun_xexf(mc, c_xe, c_xf, qx)
          call fmovun_xexf(md, d_xe, d_xf, qx)
          call fmsub(mxy(1), mxy(2), mz(1), qx)
          call fmadd(mxy(3), mxy(4), mz(2), qx)
          if (a_xe+c_xe > b_xe+d_xe + qx%ndig) call fmeq(mxy(1), mz(1), qx)
          if (b_xe+d_xe > a_xe+c_xe + qx%ndig) call fmmpyi(mxy(2), -1, mz(1), qx)
          if (a_xe+d_xe > b_xe+c_xe + qx%ndig) call fmeq(mxy(3), mz(2), qx)
          if (b_xe+c_xe > a_xe+d_xe + qx%ndig) call fmeq(mxy(4), mz(2), qx)
          if (mz(1)%mp(2) /= qx%munkno .and. mz(2)%mp(2) /= qx%munkno) return
      endif
      call zmunknown(mz, qx)

      return
      end subroutine zmmpy_unov

      subroutine zmmpyi(ma, integ, mb, qx)

!  mb = ma * integ        Multiply by one-word (real) integer.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      integer :: integ
      intent (in) :: ma, integ
      intent (inout) :: mb
      type(fm_settings) :: qx

      integer :: kovun, kwrnsv, ntrsav

      qx%ncall = qx%ncall + 1
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'ZMMPYI'
          call zmntr_inp1i(ma, integ, qx)
      endif
      kovun = 0
      if (ma(1)%mp(2) == qx%mexpov .or. ma(1)%mp(2) == qx%mexpun) kovun = 1
      if (ma(2)%mp(2) == qx%mexpov .or. ma(2)%mp(2) == qx%mexpun) kovun = 1
      if (ma(1)%mp(2) == qx%munkno .or. ma(2)%mp(2) == qx%munkno) kovun = 2

!             Force fmmpyi to use more guard digits for user calls.

      qx%ncall = qx%ncall - 1
      ntrsav = qx%ntrace
      qx%ntrace = 0
      kwrnsv = qx%kwarn
      qx%kwarn = 0

      call fmmpyi(ma(1), integ, mb(1), qx)
      call fmmpyi(ma(2), integ, mb(2), qx)

      qx%ntrace = ntrsav
      qx%kwarn = kwrnsv
      qx%ncall = qx%ncall + 1
      if (qx%ntrace /= 0) qx%namest(qx%ncall) = 'ZMMPYI'
      if (mb(1)%mp(2) == qx%munkno .or. mb(2)%mp(2) == qx%munkno) then
          qx%kflag = -4
      else if (mb(1)%mp(2) == qx%mexpov .or. mb(2)%mp(2) == qx%mexpov) then
          qx%kflag = -5
      else if (mb(1)%mp(2) == qx%mexpun .or. mb(2)%mp(2) == qx%mexpun) then
          qx%kflag = -6
      endif
      if ((mb(1)%mp(2) == qx%munkno .and. kovun /= 2) .or.  &
          (mb(2)%mp(2) == qx%munkno .and. kovun /= 2) .or.  &
          (mb(1)%mp(2) == qx%mexpun .and. kovun == 0) .or.  &
          (mb(2)%mp(2) == qx%mexpun .and. kovun == 0) .or.  &
          (mb(1)%mp(2) == qx%mexpov .and. kovun == 0) .or.  &
          (mb(2)%mp(2) == qx%mexpov .and. kovun == 0)) then
          qx%namest(qx%ncall) = 'ZMMPYI'
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) call zmntr_out1(mb, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine zmmpyi

      subroutine zmmpyi_r1(ma, ival, qx)

!  ma = ma / ival

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2)
      integer :: ival
      intent (inout) :: ma
      intent (in) :: ival
      type(fm_settings) :: qx

      type(multi) :: mt(2)


      call zmmpyi(ma, ival, mt, qx)
      call zmeq(mt, ma, qx)


      end subroutine zmmpyi_r1

      subroutine zmnegate(ma, qx)

!  Change the sign of ma.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2)
      intent (inout) :: ma
      type(fm_settings) :: qx

      ma(1)%mp(1) = -ma(1)%mp(1)
      if (ma(1)%mp(3) == 0) ma(1)%mp(1) = 1
      if (ma(1)%mp(2) == qx%munkno .and. ma(1)%mp(5) >= 0) ma(1)%mp(1) = 1
      ma(2)%mp(1) = -ma(2)%mp(1)
      if (ma(2)%mp(3) == 0) ma(2)%mp(1) = 1
      if (ma(2)%mp(2) == qx%munkno .and. ma(2)%mp(5) >= 0) ma(2)%mp(1) = 1

      end subroutine zmnegate

      subroutine zmnint(ma, mb, qx)

!  mb = nint(ma)

!  The nearest integers to both real and imaginary parts are returned.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'ZMNINT'
      if (qx%ntrace /= 0) call zmntr_inp1(ma, qx)

      call fmnint(ma(1), mb(1), qx)
      call fmnint(ma(2), mb(2), qx)

      if (qx%ntrace /= 0) call zmntr_out1(mb, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine zmnint

      subroutine zmntr_inp1(ma, qx)

!  Print ZM numbers in base 10 format using zmout for conversion.
!  This is used for trace output from the ZM routines.

!  ma  -  the ZM number to be printed.

!  ntrace and lvltrc (in module fmvals) control trace printout.

!  ntrace = 0        No printout except warnings and errors.

!  ntrace = 1        The result of each call to one of the routines
!                    is printed in base 10, using zmout.

!  ntrace = -1       The result of each call to one of the routines
!                    is printed in internal base mbase format.

!  ntrace = 2        The input arguments and result of each call to one
!                    of the routines is printed in base 10, using zmout.

!  ntrace = -2       The input arguments and result of each call to one
!                    of the routines is printed in base mbase format.

!  lvltrc defines the call level to which the trace is done.  lvltrc = 1 means only FM routines
!         called directly by the user are traced, lvltrc = k prints traces for ZM or FM routines
!         with call levels up to and including level k.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2)
      intent (in) :: ma
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return
      if (abs(qx%ntrace) == 1) return

      name = qx%namest(qx%ncall)
      if (qx%kround == 1) then
          write (qx%kw, "(' Input to ', A)") trim(name)
      else if (qx%kround == 2) then
          write (qx%kw, "(' Input to ', A, A)") name, '      (round toward +infinity)'
      else if (qx%kround == 0) then
          write (qx%kw, "(' Input to ', A, A)") name, '      (round toward zero)'
      else if (qx%kround == -1) then
          write (qx%kw, "(' Input to ', A, A)") name, '      (round toward -infinity)'
      else
          write (qx%kw, "(' Input to ', A)") trim(name)
      endif

!             Check for base mbase internal format trace.

      if (qx%ntrace < 0) then
          call zmntrj(ma, qx%ndig, qx)
      else
          call zmprnt(ma, qx)
      endif

      return
      end subroutine zmntr_inp1

      subroutine zmntr_inp1i(ma, ival, qx)

!  This is used for trace output from the ZM routines.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2)
      integer :: ival
      intent (in) :: ma, ival
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return
      if (abs(qx%ntrace) == 1) return

      name = qx%namest(qx%ncall)
      if (qx%kround == 1) then
          write (qx%kw, "(' Input to ', A)") trim(name)
      else if (qx%kround == 2) then
          write (qx%kw, "(' Input to ', A, A)") name, '      (round toward +infinity)'
      else if (qx%kround == 0) then
          write (qx%kw, "(' Input to ', A, A)") name, '      (round toward zero)'
      else if (qx%kround == -1) then
          write (qx%kw, "(' Input to ', A, A)") name, '      (round toward -infinity)'
      else
          write (qx%kw, "(' Input to ', A)") trim(name)
      endif

!             Check for base mbase internal format trace.

      if (qx%ntrace < 0) then
          call zmntrj(ma, qx%ndig, qx)
      else
          call zmprnt(ma, qx)
      endif
      write (qx%kw, "(1x, i20)") ival

      return
      end subroutine zmntr_inp1i

      subroutine zmntr_inp1ii(ma, ival, jval, qx)

!  This is used for trace output from the ZM routines.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2)
      integer :: ival, jval
      intent (in) :: ma, ival, jval
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return
      if (abs(qx%ntrace) == 1) return

      name = qx%namest(qx%ncall)
      if (qx%kround == 1) then
          write (qx%kw, "(' Input to ', A)") trim(name)
      else if (qx%kround == 2) then
          write (qx%kw, "(' Input to ', A, A)") name, '      (round toward +infinity)'
      else if (qx%kround == 0) then
          write (qx%kw, "(' Input to ', A, A)") name, '      (round toward zero)'
      else if (qx%kround == -1) then
          write (qx%kw, "(' Input to ', A, A)") name, '      (round toward -infinity)'
      else
          write (qx%kw, "(' Input to ', A)") trim(name)
      endif

!             Check for base mbase internal format trace.

      if (qx%ntrace < 0) then
          call zmntrj(ma, qx%ndig, qx)
      else
          call zmprnt(ma, qx)
      endif
      write (qx%kw, "(1x, i20)") ival
      write (qx%kw, "(1x, i20)") jval

      return
      end subroutine zmntr_inp1ii

      subroutine zmntr_inp2(ma, mb, qx)

!  Print ZM numbers in base 10 format using zmout for conversion.
!  This is used for trace output from the ZM routines.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma, mb
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return
      if (abs(qx%ntrace) == 1) return

      name = qx%namest(qx%ncall)
      if (qx%kround == 1) then
          write (qx%kw, "(' Input to ', A)") trim(name)
      else if (qx%kround == 2) then
          write (qx%kw, "(' Input to ', A, A)") name, '      (round toward +infinity)'
      else if (qx%kround == 0) then
          write (qx%kw, "(' Input to ', A, A)") name, '      (round toward zero)'
      else if (qx%kround == -1) then
          write (qx%kw, "(' Input to ', A, A)") name, '      (round toward -infinity)'
      else
          write (qx%kw, "(' Input to ', A)") trim(name)
      endif

!             Check for base mbase internal format trace.

      if (qx%ntrace < 0) then
          call zmntrj(ma, qx%ndig, qx)
          call zmntrj(mb, qx%ndig, qx)
      else
          call zmprnt(ma, qx)
          call zmprnt(mb, qx)
      endif

      return
      end subroutine zmntr_inp2

      subroutine zmntr_inpi1(ival, ma, qx)

!  This is used for trace output from the ZM routines.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2)
      integer :: ival
      intent (in) :: ma, ival
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return
      if (abs(qx%ntrace) == 1) return

      name = qx%namest(qx%ncall)
      if (qx%kround == 1) then
          write (qx%kw, "(' Input to ', A)") trim(name)
      else if (qx%kround == 2) then
          write (qx%kw, "(' Input to ', A, A)") name, '      (round toward +infinity)'
      else if (qx%kround == 0) then
          write (qx%kw, "(' Input to ', A, A)") name, '      (round toward zero)'
      else if (qx%kround == -1) then
          write (qx%kw, "(' Input to ', A, A)") name, '      (round toward -infinity)'
      else
          write (qx%kw, "(' Input to ', A)") trim(name)
      endif

!             Check for base mbase internal format trace.

      write (qx%kw, "(1x, i20)") ival
      if (qx%ntrace < 0) then
          call zmntrj(ma, qx%ndig, qx)
      else
          call zmprnt(ma, qx)
      endif

      return
      end subroutine zmntr_inpi1

      subroutine zmntr_out1(ma, qx)

!  Print ZM numbers in base 10 format using zmout for conversion.
!  This is used for trace output from the ZM routines.

!  ma  -  the ZM number to be printed.

!  ntrace and lvltrc (in module fmvals) control trace printout.

!  ntrace = 0        No printout except warnings and errors.

!  ntrace = 1        The result of each call to one of the routines
!                    is printed in base 10, using zmout.

!  ntrace = -1       The result of each call to one of the routines
!                    is printed in internal base mbase format.

!  ntrace = 2        The input arguments and result of each call to one
!                    of the routines is printed in base 10, using zmout.

!  ntrace = -2       The input arguments and result of each call to one
!                    of the routines is printed in base mbase format.

!  lvltrc defines the call level to which the trace is done.  lvltrc = 1 means only FM routines
!         called directly by the user are traced, lvltrc = k prints traces for ZM or FM routines
!         with call levels up to and including level k.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2)
      intent (in) :: ma
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return

      name = qx%namest(qx%ncall)
      if (qx%kflag == 0) then
          write (qx%kw,                                                   &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10, 5X, 'NDIG =', I10)"                                &
                ) name, qx%ncall, int(qx%mbase), qx%ndig
      else
          write (qx%kw,                                                  &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"            &
                ) name, qx%ncall, int(qx%mbase), qx%ndig, qx%kflag
      endif

!             Check for base mbase internal format trace.

      if (qx%ntrace < 0) then
          call zmntrj(ma, qx%ndig, qx)
      else
          call zmprnt(ma, qx)
      endif

      return
      end subroutine zmntr_out1

      subroutine zmntr_out2(ma, mb, qx)

!  Print ZM numbers in base 10 format using zmout for conversion.
!  This is used for trace output from the ZM routines.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma, mb
      type(fm_settings) :: qx

      character(9) :: name

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return

      name = qx%namest(qx%ncall)
      if (qx%kflag == 0) then
          write (qx%kw,                                                   &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10, 5X, 'NDIG =', I10)"                                &
                ) name, qx%ncall, int(qx%mbase), qx%ndig
      else
          write (qx%kw,                                                  &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"            &
                ) name, qx%ncall, int(qx%mbase), qx%ndig, qx%kflag
      endif

!             Check for base mbase internal format trace.

      if (qx%ntrace < 0) then
          call zmntrj(ma, qx%ndig, qx)
          call zmntrj(mb, qx%ndig, qx)
      else
          call zmprnt(ma, qx)
          call zmprnt(mb, qx)
      endif

      return
      end subroutine zmntr_out2

      subroutine zmntr_outz(z, qx)

!  Internal routine for trace output of complex variables.

      use fmvals_parallel
      implicit none

      complex :: z
      intent (in) :: z
      type(fm_settings) :: qx

      character(9) :: name
      double precision :: xreal, ximag

      if (qx%ntrace == 0) return
      if (qx%ncall > qx%lvltrc) return

      name = qx%namest(qx%ncall)
      if (qx%kflag == 0) then
          write (qx%kw,                                                   &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10, 5X, 'NDIG =', I10)"                                &
                ) name, qx%ncall, int(qx%mbase), qx%ndig
      else
          write (qx%kw,                                                  &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"            &
                ) name, qx%ncall, int(qx%mbase), qx%ndig, qx%kflag
      endif

      xreal = dble(z)
      ximag = dble(aimag(z))
      if (ximag >= 0.0d0) then
          write (qx%kw, "(1x, es20.10, ' +', es20.10, ' i')") xreal, ximag
      else
          write (qx%kw, "(1x, es20.10, ' -', es20.10, ' i')") xreal, abs(ximag)
      endif

      return
      end subroutine zmntr_outz

      subroutine zmntrj(ma, nd, qx)

!  Print trace output in internal base mbase format.  The number to be printed is in ma.

!  nd is the number of base mbase digits to be printed.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2)
      integer :: nd
      intent (in) :: ma, nd
      type(fm_settings) :: qx

      character(99) :: form
      character(40) :: st1, st2
      integer :: j, l, n
      character(40), external :: fmfi

      l = int(log10(dble(qx%mbase-1))) + 2
      n = (qx%kswide-23)/l
      if (n > 10) n = 5*(n/5)
      if (nd <= n) then
          write (form, "(' (1X, I19, I', I2, ', ', I3, 'I', I2, ') ')") l+2, n-1, l
      else
          write (form,                                           &
                 "(' (1X, I19, I', I2, ', ', I3, 'I', I2, "  //  &
                 "'/(22X, ', I3, 'I', I2, ')) ')"                &
                ) l+2, n-1, l, n, l
      endif
      st1 = fmfi(int(ma(1)%mp(1)))
      st2 = fmfi(int(ma(1)%mp(2)))
      write (qx%kw, "(A, A, A, A, A)") '            Sign = ', trim(st1),  &
                                   '   Exponent = ', trim(st2), '   Digits of real part:'
      write (form,*) '(13X, ', n, 'I', l, ')'
      if (ma(1)%mp(5) < 0) then
          if (nd+2 >= 6) then
              write (qx%kw, form) int(ma(1)%mp(3)), 0, 0,(int(ma(1)%mp(j)), j=6, nd+2)
          else if (nd+2 == 5) then
              write (qx%kw, form) int(ma(1)%mp(3)), 0, 0
          else
              write (qx%kw, form) int(ma(1)%mp(3)), 0
          endif
      else
          write (qx%kw, form) (int(ma(1)%mp(j)), j=3, nd+2)
      endif

      st1 = fmfi(int(ma(2)%mp(1)))
      st2 = fmfi(int(ma(2)%mp(2)))
      write (qx%kw, "(A, A, A, A, A, A, A)") '            Sign = ', trim(st1),  &
                                   '   Exponent = ', trim(st2), '   Digits of imaginary part:'
      if (ma(2)%mp(5) < 0) then
          if (nd+2 >= 6) then
              write (qx%kw, form) int(ma(2)%mp(3)), 0, 0,(int(ma(2)%mp(j)), j=6, nd+2)
          else if (nd+2 == 5) then
              write (qx%kw, form) int(ma(2)%mp(3)), 0, 0
          else
              write (qx%kw, form) int(ma(2)%mp(3)), 0
          endif
      else
          write (qx%kw, form) (int(ma(2)%mp(j)), j=3, nd+2)
      endif

      return
      end subroutine zmntrj

      subroutine zmout(ma, line, lb, last1, last2, qx)

!  Convert a floating multiple precision number to a character array for output.

!  ma    is an zm number to be converted to an a1 character array in base 10 format
!  line  is the character(1) array in which the result is returned.
!  lb    is the length of line.
!  last1 is returned as the position of the last nonblank character of the real part of the
!        number in line.
!  last2 is returned as the position of the last nonblank character of the imaginary part of
!        the number in line.

!  jform1 and jform2 determine the format of the two fm numbers making up the complex value ma.
!  See fmout for details.

!  jformz determines the format of the real and imaginary parts.

!  jformz = 1  normal setting :       1.23 - 4.56 i
!         = 2  use capital I  :       1.23 - 4.56 I
!         = 3  parenthesis format   ( 1.23 , -4.56 )

!  line should be dimensioned at least 4*(log10(mbase)*ndig + 15) on a 32-bit machine to allow
!  for up to 10 digit exponents.  Replace 15 by 20 if 48-bit integers are used, 25 for 64-bit
!  integers, etc.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2)
      integer :: lb, last1, last2
      character :: line(lb)
      intent (in) :: ma, lb
      intent (inout) :: line, last1, last2
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: maims
      integer :: j, kpt, lb2, nd, nexp
      type(multi) :: mxy(1)


      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'ZMOUT'
      do j = 1, lb
         line(j) = ' '
      enddo
      nd = int(real(qx%ndig)*log10(real(qx%mbase))) + 1
      if (nd < 2) nd = 2
      nexp = int(2.0*log10(real(mxbase))) + 16
      kpt = 1
      if (qx%jformz == 3) kpt = 3
      lb2 = max(qx%jform2+nexp, nd+nexp)
      lb2 = min(lb+1-kpt, lb2)
      call fmout(ma(1), line(kpt), lb2, qx)

      if (qx%jformz == 3) line(1) = '('
      last1 = 1
      do j = lb2, 1, -1
         if (line(j) /= ' ') then
             last1 = j
             exit
         endif
      enddo

      maims = ma(2)%mp(1)
      if (ma(2)%mp(2) == qx%munkno) maims = 1
      call fmi2m2(0, mxy(1), qx)
      do j = 1, qx%ndig+2
         mxy(1)%mp(j) = ma(2)%mp(j)
      enddo
      line(last1+1) = ' '
      if (qx%jformz == 3) then
          line(last1+2) = ','
      else
          if (maims < 0) then
              mxy(1)%mp(1) = 1
              line(last1+2) = '-'
          else
              line(last1+2) = '+'
          endif
      endif

      kpt = last1 + 3
      lb2 = max(qx%jform2+nexp, nd+nexp)
      lb2 = min(lb+1-kpt, lb2+2)
      call fmout(mxy(1), line(kpt), lb2, qx)
      last1 = kpt
      do j = lb2+kpt-1, kpt, -1
         if (line(j) /= ' ') then
             last2 = j
             exit
         endif
      enddo

      last2 = last2 + 2
      line(last2) = 'i'
      if (qx%jformz == 2) line(last2) = 'I'
      if (qx%jformz == 3) line(last2) = ')'

      if (line(kpt) == ' ' .and. line(kpt+1) == '+') then
          do j = kpt+2, last2
             line(j-2) = line(j)
          enddo
          line(last2-1) = ' '
          line(last2) = ' '
          last2 = last2 - 2
      endif

      qx%ncall = qx%ncall - 1

      return
      end subroutine zmout

      subroutine zmpgam(n, ma, mb, qx)

!  mb = polygamma(n,ma)      (nth derivative of psi)

      use fmvals_parallel
      implicit none

      integer :: n
      type(multi) :: ma(2), mb(2)
      intent (in) :: n, ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, numtry, n_acc
      logical :: retry
      type(multi) :: mxy(2, 13), mresult(2), mretry(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmpgam_sc(n, ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      numtry = 0
      n_acc = nint(qx%ndig*qx%alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call zmpgam_m1(n, ma, mxy, mresult, ndsave, retry, numtry, n_acc, qx)
         qx%numbrn = 0
         if (retry) then
             retry = .false.
             call zmcheck_accuracy(mresult, ndsave, retry, qx)
             if (.not. retry) then
                 call zmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)
             endif
         endif
         numtry = numtry + 1
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmpgam

      subroutine zmpgam_m1(n, ma, mxy, mresult, ndsave, retry, numtry, n_acc, qx)

!  Method 1 for computing polygamma(n,ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mbern(lmbern)
      integer :: ndbern(lmbern)
      type(multi) :: ma(2), mxy(2, 13), mresult(2)
      integer :: n, ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: n, ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc
      type(fm_settings) :: qx

      double precision :: xe
      integer :: iextra, inta, j, j2, jn, jnc, jstart, k, k1, k2, kl,       &
                 krflct, krsave, kwrnsv, lshift, n1, nbot, nc, nd1, ndig2,  &
                 ndsav1, ndsv2, nmxdif, nterm, ntop

!             Set the coefficients used in computing various derivatives of cot(pi*x)
!             for the reflection formula.

      integer :: kgcd(14) = (/ 1, 2, 2, 8, 8, 16, 16, 128, 128, 256, 256, 1024, 1024, 2048 /)
      integer :: kcoeff(56) = (/                                                            &
                           1,        1,                     3, 1,               3, 2,       &
                          15,  15,   2,                    45,  60, 17,                     &
                         315, 525, 231, 17,               315, 630, 378, 62,                &
                        2835,      6615,      5040,      1320,       62,                    &
                       14175,     37800,     34965,     12720,     1382,                    &
                      155925,    467775,    509355,    238425,    42306,     1382,          &
                      467775,   1559250,   1954260,   1121670,   280731,    21844,          &
                     6081075,  22297275,  31621590,  21531510,  7012005,   907725,  21844,  &
                    42567525, 170270100, 269594325, 212612400, 85630545, 15839460, 929569 /)
      type(multi) :: mjsums(2, ljsums)
      logical, external :: fmcomp

      retry = .true.

      if (numtry >= 1) then
          if (qx%ncall == 1) call fmndig(max(qx%ndig, 2*ndsave+10), qx)
      endif
      call fmndig(qx%ndig + n/4, qx)
      n_acc = nint(qx%ndig*qx%alogm2)
      call zmequ(ma, mxy(1:2, 1), ndsave, qx%ndig, qx)
      lshift = 0
      call zmeq(mxy(1:2, 1), mxy(1:2, 13), qx)

!             Check for special cases.

      if (n == 0) then
          call zmpsi(mxy(1:2, 1), mresult, qx)
          return
      endif

!             Near zero polygamma(n,x) =
!                       for odd n:       n!/x**(n+1) + c(n)*pi**(n+1) + polygamma(n+1,1.0)*x + ...
!                       for even n:     -n!/x**(n+1) + polygamma(n,1.0) + c(n+1)*pi**(n+2)*x + ...

!                       c(n) = abs(Bernoulli(n+1)) * 4**((n-1)/2) / ((n+1)/2)

      call zmabs(mxy(1:2, 1), mxy(1, 2), qx)
      call fmovun_xe(mxy(1, 2), xe, qx)
      if (xe < (-qx%ndig-1)) then
          call fmfcti(n, mxy(1, 12), qx)
          call fmi2m(0, mxy(2, 12), qx)
          call zmipwr(mxy(1:2, 13), n+1, mxy(1:2, 11), qx)
          call zmdiv(mxy(1:2, 12), mxy(1:2, 11), mxy(1:2, 10), qx)
          if (mod(n, 2) == 1) then
              call fmpi(mxy(1, 2), qx)
              qx%ndigpi = 0
              call fmipwr(mxy(1, 2), n+1, mxy(1, 3), qx)

              call fmbernoulli(n+1, mxy(2, 4), mbern, ndbern, qx)
              call fmabs(mxy(2, 4), mxy(1, 4), qx)
              call fmi2m(4, mxy(1, 5), qx)
              call fmipwr(mxy(1, 5), (n-1)/2, mxy(1, 6), qx)
              call fmmpy(mxy(1, 4), mxy(1, 6), mxy(1, 5), qx)
              call fmdivi(mxy(1, 5), (n+1)/2, mxy(1, 6), qx)
              call fmmpy(mxy(1, 6), mxy(1, 3), mxy(1, 9), qx)
              call fmadd_r1(mxy(1, 10), mxy(1, 9), qx)

              call fmi2m(1, mxy(1, 3), qx)
              call fmpgam(n+1, mxy(1, 3), mxy(1, 4), qx)
              call fmi2m(0, mxy(2, 4), qx)
              call zmmpy(mxy(1:2, 4), mxy(1:2, 13), mxy(1:2, 9), qx)
              call zmadd_r1(mxy(1:2, 10), mxy(1:2, 9), qx)
          else
              call fmi2m(1, mxy(1, 3), qx)
              call fmpgam(n, mxy(1, 3), mxy(1, 9), qx)
              call fmadd_r1(mxy(1, 10), mxy(1, 9), qx)

              call fmpi(mxy(1, 2), qx)
              qx%ndigpi = 0
              call fmipwr(mxy(1, 2), n+2, mxy(1, 3), qx)

              call fmbernoulli(n+2, mxy(2, 4), mbern, ndbern, qx)
              call fmabs(mxy(2, 4), mxy(1, 4), qx)
              call fmi2m(4, mxy(1, 5), qx)
              call fmipwr(mxy(1, 5), n/2, mxy(1, 6), qx)
              call fmmpy(mxy(1, 4), mxy(1, 6), mxy(1, 5), qx)
              call fmdivi(mxy(1, 5), (n+2)/2, mxy(1, 6), qx)
              call fmmpy(mxy(1, 6), mxy(1, 3), mxy(1, 9), qx)
              call fmi2m(0, mxy(2, 9), qx)
              call zmmpy_r1(mxy(1:2, 9), mxy(1:2, 13), qx)
              call zmadd_r1(mxy(1:2, 10), mxy(1:2, 9), qx)
          endif
          call zmeq(mxy(1:2, 10), mresult, qx)
          return
      endif

      krflct = 0
      call fmdp2m(-0.5d0, mxy(1, 5), qx)
      if (fmcomp(mxy(1, 13), '<=', mxy(1, 5), qx)) then
          krflct = 1
          call zmi2m(1, mxy(1:2, 4), qx)
          call zmsub_r2(mxy(1:2, 4), mxy(1:2, 13), qx)
      endif

!             For large abs(ma), polygamma(n,x) = (-1)**(n-1)*( (n-1)!/x**n + n!/(2*x**(n+1)) + ...)

      call zmabs(mxy(1:2, 13), mxy(1, 2), qx)
      call fmovun_xe(mxy(1, 2), xe, qx)
      if (xe > qx%ndig+3) then
          call zmipwr(mxy(1:2, 13), -n, mxy(1:2, 2), qx)
          call fmfcti(n-1, mxy(1, 9), qx)
          call fmi2m(0, mxy(2, 9), qx)
          call zmmpy(mxy(1:2, 2), mxy(1:2, 9), mxy(1:2, 3), qx)
          call zmdiv_r1(mxy(1:2, 2), mxy(1:2, 13), qx)
          call zmmpyi_r1(mxy(1:2, 9), n, qx)
          call zmmpy(mxy(1:2, 2), mxy(1:2, 9), mxy(1:2, 10), qx)
          call zmdivi_r1(mxy(1:2, 10), 2, qx)
          call zmadd_r1(mxy(1:2, 10), mxy(1:2, 3), qx)

          if (mod(n-1, 2) == 1) then
              call zmnegate(mxy(1:2, 10), qx)
          endif
          if (qx%kround /= 1) then
              call zmmpyi(mxy(1:2, 10), n, mxy(1:2, 4), qx)
              call zmdivi_r1(mxy(1:2, 4), 2, qx)
              call zmdiv_r1(mxy(1:2, 4), mxy(1:2, 13), qx)
              call zmadd_r1(mxy(1:2, 10), mxy(1:2, 4), qx)
          endif
      else

!             To speed the asymptotic series calculation, increase the argument by lshift.

          iextra = 0
          kwrnsv = qx%kwarn
          qx%kwarn = 0
          call fmm2i(mxy(1, 13), inta, qx)
          qx%kwarn = kwrnsv

          if (qx%kflag == -4) then
              lshift = 0
          else
              lshift = max(0, int(real(qx%ndig)*qx%alogmb/4.46-real(inta)))
              lshift = lshift + (7*n)/20
          endif
          if (lshift > 0) lshift = 4*(lshift/4 + 1)

          if (lshift /= 0) then
              call zmi2m(lshift, mxy(1:2, 4), qx)
              call zmadd(mxy(1:2, 13), mxy(1:2, 4), mxy(1:2, 12), qx)
          else
              call zmeq(mxy(1:2, 13), mxy(1:2, 12), qx)
          endif

!             Sum the asymptotic series.

          j2 = int(0.3*qx%alogmb + 0.2*sqrt(real(qx%ndig)))
          j2 = max(1, min(ljsums, j2))

!             mxy(13) is z
!             mxy(12) is z + lshift
!             mxy(9) is x**j2 = (1/(z+lshift)**2)**j2
!             mxy(10) is the current power of x times the quotient of factorials in each term
!             mxy(11) is the current term in the sum
!             mxy(8) is (n+1)!
!             mjsums holds the partial sums

          ndsav1 = qx%ndig
          call fmfcti(n+1, mxy(1, 8), qx)
          call fmi2m(0, mxy(2, 8), qx)
          call zmdivi(mxy(1:2, 8), 2, mxy(1:2, 10), qx)
          j = -2*j2
          call zmipwr(mxy(1:2, 12), j, mxy(1:2, 9), qx)
          call zmabs(mxy(1:2, 9), mxy(1, 2), qx)
          if (abs(mxy(1, 2)%mp(2)) >= qx%mexpab) then
              j2 = 1
              call zmipwr(mxy(1:2, 12), -2, mxy(1:2, 9), qx)
          endif
          nterm = 2
          do j = 1, j2
             nterm = 2*j
             call fmbern(nterm, mxy(1, 10), mjsums(1, j), mbern, ndbern, qx)
             call fmbern(nterm, mxy(2, 10), mjsums(2, j), mbern, ndbern, qx)
             if (qx%kflag == -11) then
                 call zmunknown(mresult, qx)
                 qx%kflag = -4
                 retry = .false.
                 return
             endif
             ntop = (n+nterm)*(n+nterm+1)
             call zmmpyi_r1(mxy(1:2, 10), ntop, qx)
             nbot = (nterm+1)*(nterm+2)
             call zmdivi_r1(mxy(1:2, 10), nbot, qx)
          enddo

          ndig2 = qx%ndig
          kl = 1
          do while (kl == 1)
             call zmmpy_r1(mxy(1:2, 10), mxy(1:2, 9), qx)
             nmxdif = min(ndsav1, qx%ngrd22)
             do j = 1, j2
                nterm = nterm + 2
                call fmbern(nterm, mxy(1, 10), mxy(1, 11), mbern, ndbern, qx)
                call fmbern(nterm, mxy(2, 10), mxy(2, 11), mbern, ndbern, qx)
                if (qx%kflag == -11) then
                    call zmunknown(mresult, qx)
                    qx%kflag = -4
                    retry = .false.
                    return
                endif
                call fmndig(ndsav1, qx)
                call zmadd_r1(mjsums(1:2, j), mxy(1:2, 11), qx)
                if (qx%kflag /= 0) then
                    kl = 0
                    exit
                else
                    call zmabs(mjsums(1:2, j), mxy(1, 2), qx)
                    call zmabs(mxy(1:2, 11), mxy(2, 2), qx)
                    nmxdif = max(nmxdif, ndsav1-int(mxy(1, 2)%mp(2)-mxy(2, 2)%mp(2)))
                    call fmndig(ndig2, qx)
                    if (n+nterm > intmax/(n+nterm+1) .or. n+nterm > mxbase/(n+nterm+1)) then
                        call zmmpyi_r1(mxy(1:2, 10), n+nterm, qx)
                        call zmmpyi_r1(mxy(1:2, 10), n+nterm+1, qx)
                        call zmdivi_r1(mxy(1:2, 10), nterm+1, qx)
                        call zmdivi_r1(mxy(1:2, 10), nterm+2, qx)
                    else
                        ntop = (n+nterm)*(n+nterm+1)
                        call zmmpyi_r1(mxy(1:2, 10), ntop, qx)
                        nbot = (nterm+1)*(nterm+2)
                        call zmdivi_r1(mxy(1:2, 10), nbot, qx)
                    endif
                endif
             enddo
             ndig2 = nmxdif
             call fmndig(ndig2, qx)
          enddo

!             Put the j2 concurrent sums back together.

          call fmndig(ndsav1, qx)
          if (j2 > 1) then
              call zmi2m(1, mxy(1:2, 9), qx)
              call zmsqr(mxy(1:2, 12), mxy(1:2, 11), qx)
              call zmdiv_r2(mxy(1:2, 9), mxy(1:2, 11), qx)
              call zmeq(mjsums(1:2, j2), mxy(1:2, 9), qx)
              do j = j2-1, 1, -1
                 call zmmpy_r1(mxy(1:2, 9), mxy(1:2, 11), qx)
                 call zmadd_r1(mxy(1:2, 9), mjsums(1:2, j), qx)
              enddo
              call zmeq(mxy(1:2, 9), mjsums(1:2, 1), qx)
          endif
          call zmipwr(mxy(1:2, 12), n+2, mxy(1:2, 6), qx)
          call zmdiv_r1(mjsums(1:2, 1), mxy(1:2, 6), qx)

!             Add the initial terms to the asymptotic series.

          call zmdivi(mxy(1:2, 8), n+1, mxy(1:2, 9), qx)
          call zmdivi(mxy(1:2, 9), n, mxy(1:2, 8), qx)
          call zmmpyi(mxy(1:2, 12), 2, mxy(1:2, 7), qx)
          call zmi2m(n, mxy(1:2, 10), qx)
          call zmadd(mxy(1:2, 7), mxy(1:2, 10), mxy(1:2, 3), qx)
          call fmcancel(mxy(1, 7), mxy(1, 10), mxy(1, 3), k1, qx)
          call fmcancel(mxy(2, 7), mxy(2, 10), mxy(2, 3), k2, qx)
          n_acc = n_acc - max(k1, k2)
          call zmeq(mxy(1:2, 3), mxy(1:2, 7), qx)
          call zmmpy_r1(mxy(1:2, 7), mxy(1:2, 8), qx)
          call zmmpyi_r1(mxy(1:2, 6), 2, qx)
          call zmdiv_r1(mxy(1:2, 6), mxy(1:2, 12), qx)
          call zmdiv(mxy(1:2, 7), mxy(1:2, 6), mxy(1:2, 10), qx)
          call zmadd(mjsums(1:2, 1), mxy(1:2, 10), mxy(1:2, 3), qx)
          call fmcancel(mjsums(1, 1), mxy(1, 10), mxy(1, 3), k1, qx)
          call fmcancel(mjsums(2, 1), mxy(2, 10), mxy(2, 3), k2, qx)
          n_acc = n_acc - max(k1, k2)
          call zmeq(mxy(1:2, 3), mxy(1:2, 10), qx)
          if (mod(n-1, 2) == 1) then
              call zmnegate(mxy(1:2, 10), qx)
          endif

!             Now pgam of the shifted argument has been computed.  Reverse the shifting.
!             The sum 1/(ma)**(n+1) + ... + 1/(ma+lshift-1)**(n+1) is computed.

!             mxy(13) is z
!             mxy(9) is n!
!             mxy(10) is the sum of the asymptotic series
!             mxy(11) is the sum 1/(ma)**(n+1) + ... + 1/(ma+lshift-1)**(n+1)
      endif

      if (lshift > 0) then

          call zmi2m(1, mxy(1:2, 6), qx)
          call zmeq(mxy(1:2, 13), mxy(1:2, 7), qx)
          n1 = -(n + 1)
          call zmipwr(mxy(1:2, 7), n1, mxy(1:2, 11), qx)
          do k = 1, lshift-1
             call zmadd_r1(mxy(1:2, 7), mxy(1:2, 6), qx)
             call zmipwr(mxy(1:2, 7), n1, mxy(1:2, 12), qx)
             call zmadd_r1(mxy(1:2, 11), mxy(1:2, 12), qx)
          enddo
          call zmmpy_r2(mxy(1:2, 9), mxy(1:2, 11), qx)
          if (mod(n+1, 2) == 1) then
              call zmnegate(mxy(1:2, 11), qx)
          endif
          call zmadd(mxy(1:2, 10), mxy(1:2, 11), mxy(1:2, 3), qx)
          call fmcancel(mxy(1, 10), mxy(1, 11), mxy(1, 3), k1, qx)
          call fmcancel(mxy(2, 10), mxy(2, 11), mxy(2, 3), k2, qx)
          n_acc = n_acc - max(k1, k2)
          call zmeq(mxy(1:2, 3), mxy(1:2, 10), qx)
      endif

!             Use the reflection formula if Real(ma) was less than -1/2.

      if (krflct == 1) then

!             mxy(11) is cot(Pi*z)
!             mxy(9) is mxy(11)**2

!             Reduce the argument before multiplying by Pi.

          call fmnint(mxy(1, 13), mxy(1, 5), qx)
          call fmsub(mxy(1, 13), mxy(1, 5), mxy(1, 9), qx)
          call fmeq(mxy(2, 13), mxy(2, 9), qx)
          if (mxy(1, 9)%mp(3) /= 0) then
              call fmcancel(mxy(1, 13), mxy(1, 5), mxy(1, 9), k1, qx)
              n_acc = n_acc - k1
          endif
          ndsv2 = qx%ndig

          kl = 1
          do while (kl == 1)
             kl = 0
             call fmpi(mxy(1, 11), qx)
             qx%ndigpi = 0
             call fmi2m(0, mxy(2, 11), qx)
             call zmmpy_r1(mxy(1:2, 11), mxy(1:2, 9), qx)
             krsave = qx%krad
             qx%krad = 1
             call zmtan(mxy(1:2, 11), mxy(1:2, 2), qx)
             call zmeq(mxy(1:2, 2), mxy(1:2, 11), qx)
             qx%krad = krsave

             call zmabs(mxy(1:2, 11), mxy(1, 5), qx)
             call fmovun_xe(mxy(1, 5), xe, qx)
             if ((xe < 0 .or. xe > 1) .and. ndsv2 == qx%ndig) then
                 nd1 = max(-mxy(1, 5)%mp(2), mxy(1, 5)%mp(2))
                 iextra = int(min(2*qx%ndig, nd1))
                 if (abs(mxy(1, 5)%mp(2)) >= qx%mexpov) iextra = 0
                 if (iextra > 0) then
                     call zmequ_r1(mxy(1:2, 9), qx%ndig, qx%ndig+iextra, qx)
                 endif
                 call fmndig(qx%ndig + iextra, qx)
                 if (iextra > 0) then
                     kl = 1
                 endif
             endif
          enddo

          call fmndig(ndsv2, qx)
          call zmi2m(1, mxy(1:2, 5), qx)
          call zmdiv_r2(mxy(1:2, 5), mxy(1:2, 11), qx)
          call zmsqr(mxy(1:2, 11), mxy(1:2, 9), qx)
          nc = (n+1)/2

!             For n up to 14, use the stored coefficients to compute the Nth derivative
!             of Cot(Pi*z).  For larger n, the coefficients are generated from a recurrence
!             relation and stored as FM numbers.

          if (n <= 14) then
              jstart = (n*n + 4 - mod(n, 2))/4
              if (n <= 2) then
                  call zmi2m(1, mxy(1:2, 6), qx)
              else
                  call zmmpyi(mxy(1:2, 9), kcoeff(jstart), mxy(1:2, 6), qx)
              endif
              do j = 2, nc
                 call zmi2m(kcoeff(jstart+j-1), mxy(1:2, 7), qx)
                 call zmadd_r1(mxy(1:2, 6), mxy(1:2, 7), qx)
                 if (j < nc) call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 9), qx)
              enddo
              if (mod(n, 2) == 0) call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 11), qx)
              if (n > 1) call zmmpyi_r1(mxy(1:2, 6), kgcd(n), qx)
          else
              if (nc > ljsums) then
                  qx%kflag = -12
                  write (qx%kw,                                                        &
                         "(' For ZMPGAM(', I5, ',*) with NDIG =', I5, ', ', I7, "  //  &
                         "' words are needed'/' in array MJSUMS.', "               //  &
                         "'  The current dimension of MJSUMS IS', I7/)"                &
                        ) n, qx%ndig, nc*(qx%ndig+3), ljsums
                  call zmunknown(mresult, qx)
                  return
              endif

              do j = 1, 7
                 call zmi2m(kcoeff(j+49), mjsums(1:2, j), qx)
                 call zmmpyi_r1(mjsums(1:2, j), kgcd(14), qx)
              enddo
              do jn = 15, n
                 jnc = (jn+1)/2
                 do k = jnc, 2, -1
                    if (k == jnc .and. mod(jn, 2) == 1) then
                        call zmeq(mjsums(1:2, k-1), mjsums(1:2, k), qx)
                    else
                        call zmadd_r2(mjsums(1:2, k-1), mjsums(1:2, k), qx)
                        call zmmpyi_r1(mjsums(1:2, k), jn-2*(k-1), qx)
                    endif
                 enddo
                 call zmmpyi_r1(mjsums(1:2, 1), jn, qx)
              enddo

!             mjsums now has the coefficients needed for the polynomial in Cot**2 that defines
!             the Nth derivative of Cot.

              call zmeq(mjsums(1:2, 1), mxy(1:2, 6), qx)
              do j = 2, nc
                 call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 9), qx)
                 call zmadd_r1(mxy(1:2, 6), mjsums(1:2, j), qx)
              enddo
              if (mod(n, 2) == 0) call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 11), qx)
          endif

!             To complete the calculation of the Nth derivative of Cot, multiply the polynomial
!             in Cot**2 by Csc**2.

          call zmadd(mxy(1:2, 9), mxy(1:2, 5), mxy(1:2, 7), qx)
          call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 7), qx)

          call fmpi(mxy(2, 7), qx)
          qx%ndigpi = 0
          call fmipwr(mxy(2, 7), n+1, mxy(1, 7), qx)
          call fmi2m(0, mxy(2, 7), qx)
          call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 7), qx)
          if (mod(n, 2) == 1) then
              call zmnegate(mxy(1:2, 10), qx)
          endif
          call zmadd(mxy(1:2, 10), mxy(1:2, 6), mxy(1:2, 3), qx)
          call fmcancel(mxy(1, 10), mxy(1, 6), mxy(1, 3), k1, qx)
          call fmcancel(mxy(2, 10), mxy(2, 6), mxy(2, 3), k2, qx)
          n_acc = n_acc - max(k1, k2)
          call zmeq(mxy(1:2, 3), mxy(1:2, 10), qx)
      endif

      call zmeq(mxy(1:2, 10), mresult, qx)

      return
      end subroutine zmpgam_m1

      subroutine zmpgam_sc(n, ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = polygamma(n,ma).

!  kresult = 1 is returned if a special case gives the value of polygamma(n,ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: n, kresult, ndsave
      intent (in) :: n, ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMPGAM   '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inpi1(n, ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

!             If ma is real, use fmpgam.

      if (ma(2)%mp(3) == 0) then
          call fmpgam(n, malocal(1), mresult(1), qx)
          call fmi2m(0, mresult(2), qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmpgam_sc

      subroutine zmpower(ma, mb, mc, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      call zmpwr(ma, mb, mc, qx)

      return
      end subroutine zmpower

      subroutine zmprint(ma, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2)
      intent (in) :: ma
      type(fm_settings) :: qx

      call zmprnt(ma, qx)

      return
      end subroutine zmprint

      subroutine zmprnt(ma, qx)

!  Print ma in base 10 format.

!  zmprnt can be called directly by the user for easy output in m format.
!  ma is converted using zmout and printed.

      use fmvals_parallel
      implicit none

      character :: cmbufz(lmbufz)
      type(multi) :: ma(2)
      intent (in) :: ma
      type(fm_settings) :: qx

      character(20) :: form
      integer :: k, ksave, last1, last2, lb, lbz, nd, nexp

      ksave = qx%kflag
      nd = int(real(qx%ndig)*log10(real(qx%mbase))) + 1
      if (nd < 2) nd = 2
      nexp = int(2.0*log10(real(mxbase))) + 16
      lb = max(qx%jform2+nexp, nd+nexp)

      if (qx%jprntz == 1) then
          lbz = 2*lb + 7
          if (lbz > lmbufz) then
              write (*,"(//a//)") " Output buffer cmbufz is not big enough." //  &
                                  " Raise its size (lmbufz) or change the format being used."
              stop
          endif
          call zmout(ma, cmbufz, lbz, last1, last2, qx)
          write (form, "(' (6X, ', I3, 'A1) ')") qx%kswide-7
          write (qx%kw, form) (cmbufz(k), k=1, last2)
      else
          call fmprnt(ma(1), qx)
          call fmprnt(ma(2), qx)
      endif
      qx%kflag = ksave

      return
      end subroutine zmprnt

      subroutine zmpsi(ma, mb, qx)

!  mb = psi(ma)      (derivative of ln(gamma(ma))

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, n_acc, numtry
      logical :: retry
      type(multi) :: mxy(2, 12), mresult(2), mretry(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmpsi_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)
      numtry = 0
      n_acc = nint(qx%ndig*qx%alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call zmpsi_m1(ma, mxy, mresult, ndsave, retry, numtry, n_acc, qx)
         qx%numbrn = 0
         if (retry) then
             retry = .false.
             call zmcheck_accuracy(mresult, ndsave, retry, qx)
             if (.not. retry) then
                 call zmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)
             endif
         endif
         numtry = numtry + 1
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmpsi

      subroutine zmpsi_m1(ma, mxy, mresult, ndsave, retry, numtry, n_acc, qx)

!  Method 1 for computing psi(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: mbern(lmbern)
      integer :: ndbern(lmbern)
      type(multi) :: ma(2), mxy(2, 12), mresult(2)
      integer :: ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc
      type(fm_settings) :: qx

      double precision :: xe
      integer :: inta, j, j2, k, k0, k0b, k1, k1b, k2, kl, krflct, krsave, kwrnsv,  &
                 lshift, nd1, ndenom, ndig2, ndsav1, nmxdif, nterm
      type(multi) :: mjsums(2, ljsums)
      logical, external :: fmcomp
      retry = .true.
      if (numtry >= 1) then
          if (qx%ncall == 1) call fmndig(max(qx%ndig, 2*ndsave+10), qx)
      endif
      n_acc = nint(qx%ndig*qx%alogm2)
      call zmequ(ma, mxy(1:2, 1), ndsave, qx%ndig, qx)
      call zmeq(mxy(1:2, 1), mxy(1:2, 11), qx)

!             Near zero Psi(x) is about -1/x - EulerGamma.

      call zmabs(mxy(1:2, 1), mxy(1, 2), qx)
      call fmovun_xe(mxy(1, 2), xe, qx)
      if (xe < (-qx%ndig-1)) then
          call zmi2m(-1, mxy(1:2, 3), qx)
          call zmdiv(mxy(1:2, 3), mxy(1:2, 11), mxy(1:2, 8), qx)
          call fmeuler(mxy(1, 3), qx)
          call fmsub_r1(mxy(1, 8), mxy(1, 3), qx)
          call zmeq(mxy(1:2, 8), mresult, qx)
          return
      endif

      if (ma(1)%mp(2) == qx%mexpun) then
          call fmi2m(0, mxy(1, 11), qx)
      endif

      krflct = 0
      call fmdpm(dble(-0.5), mxy(1, 4), qx)
      if (fmcomp(mxy(1, 1), '<=', mxy(1, 4), qx)) then
          krflct = 1
          call zmi2m(1, mxy(1:2, 3), qx)
          call zmsub_r2(mxy(1:2, 3), mxy(1:2, 11), qx)
      endif

!             Use the b(2n)/(2n*x**(2n) asymptotic series.
!             To speed the asymptotic series calculation,
!             increase the argument by lshift.

      n_acc = nint(qx%ndig*qx%alogm2)
      kwrnsv = qx%kwarn
      qx%kwarn = 0
      call fmm2i(mxy(1, 11), inta, qx)
      qx%kwarn = kwrnsv

      if (qx%kflag == -4) then
          lshift = 0
      else
          lshift = max(0, int(real(qx%ndig)*qx%alogmb/4.46-real(inta)))
      endif
      if (lshift > 0) lshift = 4*(lshift/4 + 1)

      if (lshift /= 0) then
          call zmi2m(lshift, mxy(1:2, 3), qx)
          call zmadd(mxy(1:2, 11), mxy(1:2, 3), mxy(1:2, 10), qx)
      else
          call zmeq(mxy(1:2, 11), mxy(1:2, 10), qx)
      endif

!             Sum the asymptotic series.

      j2 = int(0.3*qx%alogmb + 0.2*sqrt(real(qx%ndig)))
      j2 = max(1, min(ljsums, j2))

!             mxy(1:2,11) is z
!             mxy(1:2,10) is z + lshift
!             mxy(1:2, 7) is x**j2 = (1/(z+lshift)**2)**j2
!             mxy(1:2, 8) is the current power of x
!             mxy(1:2, 9) is the current term in the sum
!             mjsums is the partial sum

      ndsav1 = qx%ndig
      call zmi2m(1, mxy(1:2, 8), qx)
      j = -2*j2
      call zmipwr(mxy(1:2, 10), j, mxy(1:2, 7), qx)
      call zmabs(mxy(1:2, 7), mxy(1, 12), qx)
      if (abs(mxy(1, 12)%mp(2)) >= qx%mexpab) then
          j2 = 1
          call zmipwr(mxy(1:2, 10), -2, mxy(1:2, 7), qx)
      endif
      nterm = 2
      do j = 1, j2
         nterm = 2*j
         call fmbern(nterm, mxy(1, 8), mxy(1, 9), mbern, ndbern, qx)
         call fmbern(nterm, mxy(2, 8), mxy(2, 9), mbern, ndbern, qx)
         if (qx%kflag == -11) then
             call zmunknown(mresult, qx)
             qx%kflag = -4
             retry = .false.
             return
         endif
         ndenom = nterm
         call zmdivi(mxy(1:2, 9), ndenom, mjsums(1:2, j), qx)
      enddo

      ndig2 = qx%ndig
      kl = 1
      do while (kl == 1)
         call zmmpy_r1(mxy(1:2, 8), mxy(1:2, 7), qx)
         nmxdif = min(ndsav1, qx%ngrd22)
         do j = 1, j2
            nterm = nterm + 2
            call fmbern(nterm, mxy(1, 8), mxy(1, 9), mbern, ndbern, qx)
            call fmbern(nterm, mxy(2, 8), mxy(2, 9), mbern, ndbern, qx)
            if (qx%kflag == -11) then
                call zmunknown(mresult, qx)
                qx%kflag = -4
                retry = .false.
                return
            endif
            ndenom = nterm
            call zmdivi_r1(mxy(1:2, 9), ndenom, qx)
            call fmndig(ndsav1, qx)
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 9), qx)
            nd1 = mjsums(1, j)%mp(2) - mxy(1, 9)%mp(2)
            nmxdif = max(nmxdif, ndsav1-nd1)
            nd1 = mjsums(2, j)%mp(2) - mxy(2, 9)%mp(2)
            nmxdif = max(nmxdif, ndsav1-nd1)
            call fmndig(ndig2, qx)
            if (qx%kflag /= 0 .and. qx%kflag /= -6) then
                kl = 0
                exit
            endif
         enddo
         ndig2 = nmxdif
         call fmndig(ndig2, qx)
      enddo

!             Put the j2 concurrent sums back together.

      call fmndig(ndsav1, qx)
      call zmi2m(1, mxy(1:2, 7), qx)
      call zmsqr(mxy(1:2, 10), mxy(1:2, 9), qx)
      call zmdiv_r2(mxy(1:2, 7), mxy(1:2, 9), qx)
      if (j2 > 1) then
          call zmeq(mjsums(1:2, j2), mxy(1:2, 7), qx)
          do j = j2-1, 1, -1
             call zmmpy_r1(mxy(1:2, 7), mxy(1:2, 9), qx)
             call zmadd_r1(mxy(1:2, 7), mjsums(1:2, j), qx)
          enddo
          call zmeq(mxy(1:2, 7), mjsums(1:2, 1), qx)
      endif

!             Add the log term to the asymptotic series.

      call zmmpy(mjsums(1:2, 1), mxy(1:2, 9), mxy(1:2, 8), qx)
      call zmln(mxy(1:2, 10), mxy(1:2, 9), qx)
      call zmi2m(1, mxy(1:2, 4), qx)
      call zmdiv(mxy(1:2, 4), mxy(1:2, 10), mxy(1:2, 5), qx)
      call zmdivi_r1(mxy(1:2, 5), 2, qx)
      call zmsub(mxy(1:2, 9), mxy(1:2, 5), mxy(1:2, 3), qx)
      call fmcancel(mxy(1, 9), mxy(1, 5), mxy(1, 3), k1, qx)
      call fmcancel(mxy(2, 9), mxy(2, 5), mxy(2, 3), k2, qx)
      n_acc = n_acc - max(k1, k2)
      call zmeq(mxy(1:2, 3), mxy(1:2, 5), qx)
      call zmsub(mxy(1:2, 5), mxy(1:2, 8), mxy(1:2, 3), qx)
      call fmcancel(mxy(1, 5), mxy(1, 8), mxy(1, 3), k1, qx)
      call fmcancel(mxy(2, 5), mxy(2, 8), mxy(2, 3), k2, qx)
      n_acc = n_acc - max(k1, k2)
      call zmeq(mxy(1:2, 3), mxy(1:2, 8), qx)

!             Now Psi of the shifted argument has been computed.  Reverse the shifting.
!             The sum 1/(ma) + ... + 1/(ma+lshift-1) is computed.

      if (lshift > 0) then
          call zmsqr(mxy(1:2, 11), mxy(1:2, 4), qx)
          call zmmpy(mxy(1:2, 11), mxy(1:2, 4), mxy(1:2, 5), qx)
          call zmsqr(mxy(1:2, 4), mxy(1:2, 6), qx)
          call zmmpyi(mxy(1:2, 5), 6, mxy(1:2, 10), qx)
          call zmadd_r1(mxy(1:2, 6), mxy(1:2, 10), qx)
          call zmmpyi(mxy(1:2, 4), 11, mxy(1:2, 10), qx)
          call zmadd_r1(mxy(1:2, 6), mxy(1:2, 10), qx)
          call zmmpyi(mxy(1:2, 11), 6, mxy(1:2, 10), qx)
          call zmadd(mxy(1:2, 6), mxy(1:2, 10), mxy(1:2, 7), qx)
          call zmmpyi(mxy(1:2, 5), 4, mxy(1:2, 6), qx)
          call zmmpyi(mxy(1:2, 4), 18, mxy(1:2, 10), qx)
          call zmadd_r1(mxy(1:2, 6), mxy(1:2, 10), qx)
          call zmmpyi(mxy(1:2, 11), 22, mxy(1:2, 10), qx)
          call zmadd_r1(mxy(1:2, 6), mxy(1:2, 10), qx)
          call zmi2m(6, mxy(1:2, 10), qx)
          call zmadd_r1(mxy(1:2, 6), mxy(1:2, 10), qx)
          call zmdiv(mxy(1:2, 6), mxy(1:2, 7), mxy(1:2, 9), qx)
          call zmmpyi_r1(mxy(1:2, 5), 16, qx)
          do k = 4, lshift-4, 4
             call zmadd_r1(mxy(1:2, 7), mxy(1:2, 5), qx)

             call zmmpyi(mxy(1:2, 4), 48, mxy(1:2, 10), qx)
             call zmadd_r1(mxy(1:2, 6), mxy(1:2, 10), qx)

             k2 = 8*(6*k - 3)
             call zmmpyi(mxy(1:2, 4), k2, mxy(1:2, 10), qx)
             call zmadd_r1(mxy(1:2, 7), mxy(1:2, 10), qx)

             k1 = 16*(6*k - 3)
             call zmmpyi(mxy(1:2, 11), k1, mxy(1:2, 10), qx)
             call zmadd_r1(mxy(1:2, 6), mxy(1:2, 10), qx)

             if (k <= sqrt(real(intmax)/49.0)) then
                 k1 = 8*(6*k*k - 6*k + 7)
                 call zmmpyi(mxy(1:2, 11), k1, mxy(1:2, 10), qx)
                 call zmadd_r1(mxy(1:2, 7), mxy(1:2, 10), qx)

                 call zmi2m(k1, mxy(1:2, 10), qx)
                 call zmadd_r1(mxy(1:2, 6), mxy(1:2, 10), qx)
             else
                 k1 = 48*k
                 call zmmpyi(mxy(1:2, 11), k1, mxy(1:2, 10), qx)
                 call zmmpyi_r1(mxy(1:2, 10), k, qx)
                 call zmadd_r1(mxy(1:2, 7), mxy(1:2, 10), qx)
                 k1b = 8*(-6*k + 7)
                 call zmmpyi(mxy(1:2, 11), k1b, mxy(1:2, 10), qx)
                 call zmadd_r1(mxy(1:2, 7), mxy(1:2, 10), qx)

                 call zmi2m(k1, mxy(1:2, 10), qx)
                 call zmmpyi_r1(mxy(1:2, 10), k, qx)
                 call zmadd_r1(mxy(1:2, 6), mxy(1:2, 10), qx)
                 call zmi2m(k1b, mxy(1:2, 10), qx)
                 call zmadd_r1(mxy(1:2, 6), mxy(1:2, 10), qx)
             endif
             if (k <= (real(intmax)/17.0)**0.3333) then
                 k0 = 8*(2*k - 1)*(k*k - k + 3)
                 call zmi2m(k0, mxy(1:2, 10), qx)
                 call zmadd_r1(mxy(1:2, 7), mxy(1:2, 10), qx)
             else if (k <= sqrt(real(intmax)*0.9)) then
                 k0 = 8*(2*k - 1)
                 call zmi2m(k0, mxy(1:2, 10), qx)
                 k0b = k*k - k + 3
                 call zmmpyi_r1(mxy(1:2, 10), k0b, qx)
                 call zmadd_r1(mxy(1:2, 7), mxy(1:2, 10), qx)
             else
                 k0 = 8*(2*k - 1)
                 call zmi2m(k0, mxy(1:2, 10), qx)
                 call zmmpyi_r1(mxy(1:2, 10), k, qx)
                 call zmmpyi_r1(mxy(1:2, 10), k, qx)
                 call zmadd_r1(mxy(1:2, 7), mxy(1:2, 10), qx)
                 k0b = -k + 3
                 call zmi2m(k0, mxy(1:2, 10), qx)
                 call zmmpyi_r1(mxy(1:2, 10), k0b, qx)
                 call zmadd_r1(mxy(1:2, 7), mxy(1:2, 10), qx)
             endif
             call zmdiv(mxy(1:2, 6), mxy(1:2, 7), mxy(1:2, 10), qx)
             call zmadd_r1(mxy(1:2, 9), mxy(1:2, 10), qx)
          enddo
          call zmsub(mxy(1:2, 8), mxy(1:2, 9), mxy(1:2, 3), qx)
          call fmcancel(mxy(1, 8), mxy(1, 9), mxy(1, 3), k1, qx)
          call fmcancel(mxy(2, 8), mxy(2, 9), mxy(2, 3), k2, qx)
          n_acc = n_acc - max(k1, k2)
          call zmeq(mxy(1:2, 3), mxy(1:2, 8), qx)
      endif

!             Use the reflection formula if Real(ma) was less than -1/2.

      if (krflct == 1) then

!             Reduce the argument before multiplying by Pi.

          call fmnint(mxy(1, 11), mxy(1, 4), qx)
          call fmsub(mxy(1, 11), mxy(1, 4), mxy(1, 7), qx)
          call fmeq(mxy(2, 11), mxy(2, 7), qx)
          call fmcancel(mxy(1, 11), mxy(1, 4), mxy(1, 7), k1, qx)
          n_acc = n_acc - k1
          call fmpi(mxy(1, 9), qx)
          qx%ndigpi = 0
          call fmi2m(0, mxy(2, 9), qx)
          call zmmpy_r1(mxy(1:2, 9), mxy(1:2, 7), qx)
          krsave = qx%krad
          qx%krad = 1
          call zmtan(mxy(1:2, 9), mxy(1:2, 2), qx)
          qx%krad = krsave
          call fmpi(mxy(1, 9), qx)
          qx%ndigpi = 0
          call fmi2m(0, mxy(2, 9), qx)
          call zmdiv_r2(mxy(1:2, 9), mxy(1:2, 2), qx)
          call zmadd(mxy(1:2, 8), mxy(1:2, 2), mxy(1:2, 3), qx)
          call fmcancel(mxy(1, 8), mxy(1, 2), mxy(1, 3), k1, qx)
          call fmcancel(mxy(2, 8), mxy(2, 2), mxy(2, 3), k2, qx)
          n_acc = n_acc - max(k1, k2)
          call zmeq(mxy(1:2, 3), mxy(1:2, 8), qx)
      endif

      call zmeq(mxy(1:2, 8), mresult, qx)

      return
      end subroutine zmpsi_m1

      subroutine zmpsi_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = psi(ma).

!  kresult = 1 is returned if a special case gives the value of psi(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMPSI    '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

!             If ma is real, use fmpsi.

      if (ma(2)%mp(3) == 0) then
          call fmpsi(malocal(1), mresult(1), qx)
          call fmi2m(0, mresult(2), qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmpsi_sc

      subroutine zmpwr(ma, mb, mc, qx)

!  mc = ma**mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, no_retry
      logical :: retry
      type(multi) :: mxy(5), mresult(2)

      call zmalloc(mc, qx%ndig+2, qx)
      call zmenter2(ma, mb, kovun, mxsave, ndsave, qx)
      call zmpwr_sc(ma, mb, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mc, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         no_retry = 0
         call zmpwr_m1(ma, mb, mxy, mresult, ndsave, no_retry, qx)
         if (no_retry == 0) call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mc, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmpwr

      subroutine zmpwr_m1(ma, mb, mxy, mresult, ndsave, no_retry, qx)

!  Method 1 for computing  mc = ma**mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2), mxy(5), mresult(2)
      integer :: ndsave, no_retry
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult, no_retry
      type(fm_settings) :: qx

      integer :: iextra, intmb, j, jsin, jcos, jswap, k, kradsv, kwrnsv
      real :: xval
      real (kind(1.0d0)) :: mtemp
      double precision :: xe
      type(multi) :: mz01(2), mz02(2), mz03(2), mz04(2), mz05(2), mz06(2)
      logical, external :: fmcomp

      k = max(mb(1)%mp(2), mb(2)%mp(2))
      if (k < 25000) then
          call fmndig(qx%ndig + max(k, 0) + 1, qx)
      else
          call fmndig(qx%ndig + 1, qx)
      endif

      call zmequ(ma, mz04, ndsave, qx%ndig, qx)
      call zmequ(mb, mz05, ndsave, qx%ndig, qx)

!             Check for special cases.

      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
          if (mb(1)%mp(1) > 0 .and. mb(2)%mp(3) == 0) then
              call zmi2m(0, mresult, qx)
              no_retry = 1
              return
          else
              qx%kflag = -4
              call zmunknown(mresult, qx)
              no_retry = 1
              return
          endif
      endif
      if (ma(2)%mp(3) == 0 .and. mb(2)%mp(3) == 0) then
          call fmpwr(mz04(1), mz05(1), mz02(1), qx)
          call fmi2m(0, mz02(2), qx)
          call zmeq(mz02, mresult, qx)
          return
      else if (mb(2)%mp(3) == 0) then
          kwrnsv = qx%kwarn
          qx%kwarn = 0
          call fmm2i2(mz05(1), intmb, qx)
          qx%kwarn = kwrnsv
          if (qx%kflag == 0) then
              if (qx%ncall == 1) then
                  xval = abs(intmb) + 1
                  k = int((1.5*log(xval))/qx%alogmb + 2.0)
                  call fmndig(max(qx%ndig+k, 3), qx)
                  if (qx%mbase >= 100*abs(ma(1)%mp(3)) .or.  &
                      qx%mbase >= 100*abs(ma(2)%mp(3))) then
                      call fmndig(qx%ndig + 1, qx)
                  endif
              endif
              call zmequ_r1(mz04, ndsave, qx%ndig, qx)
              call zmipwr(mz04, intmb, mz03, qx)
              call zmeq(mz03, mresult, qx)
              return
          endif
      endif

!             Check for cases where abs(ma) is very close to 1, and avoid cancellation.

      call fmabs(mz04(1), mxy(1), qx)
      call fmabs(mz04(2), mxy(2), qx)
      call fmi2m(1, mxy(3), qx)
      call fmovun_xe(mxy(2), xe, qx)
      if (fmcomp(mxy(1), '==', mxy(3), qx) .and. (xe <= -qx%ndig .or. mxy(2)%mp(3) == 0)) then
          if (ma(1)%mp(1) > 0) then

!                 (1+c)**b = 1 + b*c + ...

              call zmi2m(1, mz02, qx)
              call zmsub(mz04, mz02, mz06, qx)
              call zmmpy(mz05, mz06, mz02, qx)
              call fmadd_r1(mz02(1), mxy(3), qx)
          else

!                 (-1+c)**b = (-1)**b * (1 - b*c + ... )

              call zmi2m(-1, mz02, qx)
              call zmsub(mz04, mz02, mz01, qx)
              call zmmpy(mz05, mz01, mz06, qx)
              call zmmpyi(mz06, -1, mz02, qx)
              call fmadd_r1(mz02(1), mxy(3), qx)
              kradsv = qx%krad
              qx%krad = 0
              if (ma(2)%mp(1) >= 0) then
                  call fmmpyi(mz05(1), 180, mxy(4), qx)
              else
                  call fmmpyi(mz05(1), -180, mxy(4), qx)
              endif
              call fmcssn(mxy(4), mz03(1), mz03(2), qx)
              qx%krad = kradsv
              call fmpi(mxy(3), qx)
              qx%ndigpi = 0
              call fmmpy_r1(mxy(3), mz05(2), qx)
              if (ma(2)%mp(1) >= 0) call fmnegate(mxy(3), qx)
              call fmexp(mxy(3), mxy(5), qx)
              qx%ndige = 0
              call fmeq(mxy(5), mxy(3), qx)
              call fmmpyd(mxy(3), mz03(1), mz03(2), mz06(1), mz06(2), qx)
              call zmmpy(mz02, mz06, mz01, qx)
              call zmeq(mz01, mz02, qx)
          endif
          call zmeq(mz02, mresult, qx)
          return
      endif
      call fmovun_xe(mxy(1), xe, qx)
      if (fmcomp(mxy(2), '==', mxy(3), qx) .and. (xe <= -qx%ndig .or. mxy(1)%mp(3) == 0)) then
          if (ma(2)%mp(1) > 0) then

!                 (i+c)**b = i**b * (1 - b*c*i - ... )

              call zm2i2m(0, 1, mz02, qx)
              call zmsub(mz04, mz02, mz06, qx)
              call zmmpy(mz05, mz06, mz02, qx)
              do j = 1, qx%ndig+2
                 mtemp = mz02(1)%mp(j)
                 mz02(1)%mp(j) = mz02(2)%mp(j)
                 mz02(2)%mp(j) = mtemp
              enddo
              call fmnegate(mz02(2), qx)
              call fmadd_r1(mz02(1), mxy(3), qx)
              kradsv = qx%krad
              qx%krad = 0
              call fmmpyi(mz05(1), 90, mxy(4), qx)
              call fmcssn(mxy(4), mz03(1), mz03(2), qx)
              qx%krad = kradsv
              call fmpi(mxy(3), qx)
              qx%ndigpi = 0
              call fmmpy_r1(mxy(3), mz05(2), qx)
              call fmdivi_r1(mxy(3), -2, qx)
              call fmexp(mxy(3), mxy(5), qx)
              qx%ndige = 0
              call fmeq(mxy(5), mxy(3), qx)
              call fmmpyd(mxy(3), mz03(1), mz03(2), mz06(1), mz06(2), qx)
              call zmmpy(mz02, mz06, mz01, qx)
              call zmeq(mz01, mz02, qx)
          else

!                 (-i+c)**b = (-i)**b * (1 + b*c*i - ... )

              call zm2i2m(0, -1, mz02, qx)
              call zmsub(mz04, mz02, mz06, qx)
              call zmmpy(mz05, mz06, mz02, qx)
              do j = 1, qx%ndig+2
                 mtemp = mz02(1)%mp(j)
                 mz02(1)%mp(j) = mz02(2)%mp(j)
                 mz02(2)%mp(j) = mtemp
              enddo
              call fmnegate(mz02(1), qx)
              call fmadd_r1(mz02(1), mxy(3), qx)
              kradsv = qx%krad
              qx%krad = 0
              call fmmpyi(mz05(1), -90, mxy(4), qx)
              call fmcssn(mxy(4), mz03(1), mz03(2), qx)
              qx%krad = kradsv
              call fmpi(mxy(3), qx)
              qx%ndigpi = 0
              call fmmpy_r1(mxy(3), mz05(2), qx)
              call fmdivi_r1(mxy(3), 2, qx)
              call fmexp(mxy(3), mxy(5), qx)
              qx%ndige = 0
              call fmeq(mxy(5), mxy(3), qx)
              call fmmpyd(mxy(3), mz03(1), mz03(2), mz06(1), mz06(2), qx)
              call zmmpy(mz02, mz06, mz01, qx)
              call zmeq(mz01, mz02, qx)
          endif
          call zmeq(mz02, mresult, qx)
          return
      endif

      call zmln(mz04, mz06, qx)
      call zmmpy(mz05, mz06, mz02, qx)
      call fmeq(mz02(2), mz01(1), qx)
      call fmovun_xe(mz01(1), xe, qx)
      if (xe > 25000) then
          qx%kflag = -4
          call zmunknown(mresult, qx)
          no_retry = 1
          return
      endif
      kwrnsv = qx%kwarn
      qx%kwarn = 0
      call fmrdc(mz01(1), jsin, jcos, jswap, qx)
      qx%kwarn = kwrnsv
      iextra = int(mz02(2)%mp(2) - mz01(1)%mp(2))
      if (abs(mz02(2)%mp(2)) >= qx%mexpov .or. abs(mz01(1)%mp(2)) >= qx%mexpov) iextra = 0
      if (qx%ndig >= ndsave+qx%ngrd52+max(0, iextra)) iextra = 0
      if (iextra > 1) then
          call fmndig(qx%ndig + iextra, qx)
          call zmequ_r1(mz04, ndsave, qx%ndig, qx)
          call zmequ_r1(mz05, ndsave, qx%ndig, qx)
          call zmln(mz04, mz06, qx)
          call zmmpy(mz05, mz06, mz02, qx)
      endif

      call zmexp(mz02, mz04, qx)
      call zmeq(mz04, mz02, qx)


      call zmeq(mz02, mresult, qx)

      return
      end subroutine zmpwr_m1

      subroutine zmpwr_sc(ma, mb, ndsave, mresult, kresult, qx)

!  Check for special cases for  mc = ma**mb

!  kresult = 1 is returned if a special case gives the value of the result.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2), mblocal(2), mz01(2), mz02(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMPWR    '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp2(ma, mb, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)
      call zmequ(mb, mblocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0) .or.  &
          (mblocal(1)%mp(2) == qx%munkno .and. mblocal(1)%mp(5) >= 0) .or.  &
          (mblocal(2)%mp(2) == qx%munkno .and. mblocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (abs(malocal(1)%mp(2)) >= qx%mexpov .or. abs(malocal(2)%mp(2)) >= qx%mexpov .or.  &
          abs(mblocal(1)%mp(2)) >= qx%mexpov .or. abs(mblocal(2)%mp(2)) >= qx%mexpov ) then
          call zmequ(malocal, mz01, ndsave, qx%ndig, qx)
          call zmequ(mblocal, mz02, ndsave, qx%ndig, qx)
          call zmpwr_unov(mz01, mz02, mresult, qx)
          if (abs(mresult(1)%mp(2)) >= qx%mexpov .or.  &
              abs(mresult(2)%mp(2)) >= qx%mexpov) then
              kresult = 1
              return
          endif
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          if (mblocal(1)%mp(1) > 0 .and. mblocal(2)%mp(3) == 0) then
              call zmi2m(0, mresult, qx)
              kresult = 1
              return
          else
              qx%kflag = -4
              call zmunknown(mresult, qx)
              kresult = 1
              return
          endif
      endif

      return
      end subroutine zmpwr_sc

      subroutine zmpwr_unov(ma, mb, mz, qx)

!  Check special cases where at least one part of ma, mb is underflow or overflow.

!  Return mz as the result.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2), mz(2)
      intent (inout) :: mz
      intent (in) :: ma, mb
      type(fm_settings) :: qx

      type(multi) :: mxy(3), mz01(2), mz02(2)
      real (kind(1.0d0)) :: ms
      double precision :: xe, xf, t1

      call zmabs(ma, mxy(1), qx)
      if (abs(mxy(1)%mp(2)) == qx%mexpov) then
          call fmovun_xexf(mxy(1), xe, xf, qx)
          t1 = xe * log(dble(qx%mbase)) + log(xf)
          call fmdp2m(t1, mxy(2), qx)
      else
          call fmln(mxy(1), mxy(2), qx)
          qx%ndigli = 0
      endif
      call zmarg(ma, mxy(3), qx)
      call fmeq(mxy(2), mz01(1), qx)
      call fmeq(mxy(3), mz01(2), qx)
      call zmmpy(mb, mz01, mz02, qx)
      call zmexp(mz02, mz, qx)
      ms = mz(1)%mp(1)
      call fmovun_xexf(mz(1), xe, xf, qx)
      if (xe > qx%mxexp0+1) then
          call fmoverflow(1, mz(1), qx)
          qx%kflag = -5
      else if (xe < -qx%mxexp0) then
          call fmunderflow(1, mz(1), qx)
          qx%kflag = -6
      else
          call fmunknown(mz(1), qx)
          qx%kflag = -4
      endif
      mz(1)%mp(1) = ms
      mz(1)%mp(4) = xe
      mz(1)%mp(5) = -xf*maxint

      ms = mz(2)%mp(1)
      call fmovun_xexf(mz(2), xe, xf, qx)
      if (xe > qx%mxexp0+1) then
          call fmoverflow(1, mz(2), qx)
          qx%kflag = -5
      else if (xe < -qx%mxexp0) then
          call fmunderflow(1, mz(2), qx)
          qx%kflag = -6
      else
          call fmunknown(mz(2), qx)
          qx%kflag = -4
      endif
      mz(2)%mp(1) = ms
      mz(2)%mp(4) = xe
      mz(2)%mp(5) = -xf*maxint

      return
      end subroutine zmpwr_unov

      subroutine zmrational_power(ma, ival, jval, mb, qx)

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      integer :: ival, jval
      intent (in) :: ma, ival, jval
      intent (inout) :: mb
      type(fm_settings) :: qx

      call zmrpwr(ma, ival, jval, mb, qx)

      return
      end subroutine zmrational_power

      subroutine zmread(kread, ma, qx)

!  Read ma on unit kread.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  Only one number is allowed on the line(s).

      use fmvals_parallel
      implicit none

      character :: cmbufz(lmbufz)
      integer :: kread
      type(multi) :: ma(2)
      intent (in) :: kread
      intent (inout) :: ma
      type(fm_settings) :: qx

      character :: line(80)
      integer :: j, jstat, kamper, lb

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'ZMREAD'
      lb = 0

      do
         read (kread, "(132A1)", iostat=jstat) line
         if (jstat /= 0) then
             qx%kflag = -4
             call fmwarn(qx)
             call zmunknown(ma, qx)
             qx%ncall = qx%ncall - 1
             return
         endif

!             Scan the line and look for '&'

         kamper = 0
         do j = 1, 80
            if (line(j) == '&') then
                kamper = 1
                exit
            endif
            if (line(j) /= ' ') then
                lb = lb + 1
                if (lb > lmbufz) then
                    write (*,"(//a//)") " Output buffer cmbufz is not big enough." //  &
                                        " Raise its size (lmbufz) or change the format being used."
                    stop
                endif
                cmbufz(lb) = line(j)
             endif
         enddo
         if (kamper == 0) exit
         kamper = 0
      enddo

      qx%ncall = qx%ncall - 1
      call zminp(cmbufz, ma, 1, lb, qx)

      return
      end subroutine zmread

      subroutine zmreal(ma, mbfm, qx)

!  mbfm = real(ma)

!  ma is a complex zm number, mbfm is a real fm number.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mbfm
      intent (in) :: ma
      intent (inout) :: mbfm
      type(fm_settings) :: qx

      qx%kflag = 0
      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'ZMREAL'
      if (qx%ntrace /= 0) call zmntr_inp1(ma, qx)

      call fmeq(ma(1), mbfm, qx)

      if (qx%ntrace /= 0) call fmntr_out1(mbfm, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine zmreal

      subroutine zmrpwr(ma, ival, jval, mb, qx)

!  mb = ma**(ival/jval)

!  Raise a zm number to a rational power.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      integer :: ival, jval
      intent (in) :: ma, ival, jval
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy, mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmrpwr_sc(ma, ival, jval, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmrpwr_m1(ma, ival, jval, mxy, mresult, ndsave, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmrpwr

      subroutine zmrpwr_m1(ma, ival, jval, mxy, mresult, ndsave, qx)

!  Method 1 for computing ma**(ival/jval).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mxy, mresult(2)
      integer :: ival, jval, ndsave
      intent (in) :: ma, ival, jval, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      integer :: ijsign, invert, ival2, j, jval2, k, kst, l, lval
      real :: xval
      real (kind(1.0d0)) :: mr1
      double precision :: ar, br, f, theta, x
      integer :: nstack(49)
      type(multi) :: mz01(2), mz02(2), mz03(2), mz04(2)

      call zmequ(ma, mz02, ndsave, qx%ndig, qx)

      if (abs(mz02(1)%mp(2)) >= qx%mexpov .or. abs(mz02(2)%mp(2)) >= qx%mexpov) then
          call zmi2m(ival, mz01, qx)
          call zmi2m(jval, mz03, qx)
          call zmdiv_r1(mz01, mz03, qx)
          call zmpwr(mz02, mz01, mresult, qx)
          return
      endif

      qx%kflag = 0
      ijsign = 1
      ival2 = abs(ival)
      jval2 = abs(jval)
      if (ival > 0 .and. jval < 0) ijsign = -1
      if (ival < 0 .and. jval > 0) ijsign = -1
      if (ival2 > 0 .and. jval2 > 0) call fmgcdi(ival2, jval2)

!             Increase the working precision.

      if (qx%ncall == 1) then
          xval = max(abs(ival), abs(jval)) + 1
          k = int((5.0*real(qx%dlogtn) + log(xval))/qx%alogmb + 2.0)
          call fmndig(max(qx%ndig+k, 3), qx)
      else
          xval = max(abs(ival), abs(jval)) + 1
          k = int(log(xval)/qx%alogmb + 1.0)
          call fmndig(qx%ndig + k, qx)
      endif
      if (qx%mbase >= 100*abs(mz02(1)%mp(3)) .or.  &
          qx%mbase >= 100*abs(mz02(2)%mp(3))) then
          call fmndig(qx%ndig + 1, qx)
      endif

      call zmequ(ma, mz02, ndsave, qx%ndig, qx)
      if (ival2 == 1 .and. jval2 == 2) then
          call zmsqrt(mz02, mz04, qx)
          if (ijsign < 0) then
              call zmi2m(1, mz01, qx)
              call zmdiv(mz01, mz04, mz02, qx)
              call zmeq(mz02, mz04, qx)
          endif
          call zmeq(mz04, mresult, qx)
          return
      endif

!             Generate the first approximation to ma**(1/jval2).

      call zmi2m(0, mz04, qx)
      call fmdig(nstack, kst, qx)
      call fmndig(nstack(1), qx)
      call fmsqr(mz02(1), mz01(1), qx)
      call fmsqr(mz02(2), mxy, qx)
      call fmadd_r1(mz01(1), mxy, qx)
      call fmsqrt_r1(mz01(1), qx)
      if (mz01(1)%mp(2) >= qx%mexpov) then
          call zmunknown(mresult, qx)
          return
      endif

!             Invert ma if abs(ma) >= 1 and ival or jval is large.

      invert = 0
      if (ival > 5 .or. jval > 5) then
          if (mz01(1)%mp(2) > 0 .and. (mz02(2)%mp(3) /= 0 .or.  &
              mz02(1)%mp(1) > 0)) then
              invert = 1
              call fmndig(nstack(kst), qx)
              call zmi2m(1, mz04, qx)
              call zmdiv(mz04, mz02, mz03, qx)
              call zmeq(mz03, mz02, qx)
              call fmndig(nstack(1), qx)
              call fmdiv_r2(mz04(1), mz01(1), qx)
          endif
      endif

      call fmdiv(mz02(1), mz01(1), mxy, qx)
      if (mxy%mp(2) == qx%munkno) then
          call zmunknown(mresult, qx)
          return
      endif
      call fmm2dp(mxy, ar, qx)
      call fmdiv(mz02(2), mz01(1), mxy, qx)
      if (mxy%mp(2) == qx%munkno) then
          call zmunknown(mresult, qx)
          return
      endif
      call fmm2dp(mxy, br, qx)
      mr1 = mz01(1)%mp(2)
      mz01(1)%mp(2) = 0
      call fmm2dp(mz01(1), x, qx)
      l = int(mr1/jval2)
      f = mr1/dble(jval2) - l
      x = x**(1.0d0/jval2) * dble(qx%mbase)**f
      call fmdpm(x, mxy, qx)
      mxy%mp(2) = mxy%mp(2) + l

      theta = atan2(br, ar)
      x = cos(theta/jval2)
      call fmdpm(x, mz04(1), qx)
      x = sin(theta/jval2)
      call fmdpm(x, mz04(2), qx)
      call fmmpy_r2(mxy, mz04(1), qx)
      call fmmpy_r2(mxy, mz04(2), qx)

!             Newton iteration.

      do j = 1, kst
         call fmndig(nstack(j), qx)
         if (j < kst) call fmndig(qx%ndig + 1, qx)
         lval = jval2 - 1
         call zmipwr(mz04, lval, mz01, qx)
         call zmdiv(mz02, mz01, mz03, qx)
         call zmmpyi(mz04, lval, mz01, qx)
         call zmadd(mz01, mz03, mz04, qx)
         call zmdivi(mz04, jval2, mz03, qx)
         call zmeq(mz03, mz04, qx)
      enddo

      call zmipwr(mz03, ijsign*ival2, mz04, qx)
      if (invert == 1) then
          call zmi2m(1, mz01, qx)
          call zmdiv(mz01, mz04, mz03, qx)
          call zmeq(mz03, mz04, qx)
      endif

      call zmeq(mz04, mresult, qx)

      return
      end subroutine zmrpwr_m1

      subroutine zmrpwr_sc(ma, ival, jval, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = ma**(ival/jval)

!  kresult = 1 is returned if a special case gives the value of ma**(ival/jval).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: ival, jval, kresult, ndsave
      intent (in) :: ma, ival, jval, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMRPWR   '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1ii(ma, ival, jval, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0) .or.  &
          jval == 0) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          if ((ival > 0 .and. jval > 0) .or. (ival < 0 .and. jval < 0)) then
              call zmi2m(1, mresult, qx)
          else
              call zmunknown(mresult, qx)
          endif
          kresult = 1
          return
      endif

      if (ival == 0) then
          call zmi2m(1, mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmrpwr_sc

      subroutine zmsin(ma, mb, qx)

!  mb = sin(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(5), mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmsin_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmsin_m1(ma, mxy, mresult, ndsave, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmsin

      subroutine zmsin_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing sin(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mxy(5), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: xe, ye
      type(multi) :: mz01(2), mz02(2)

      call zmequ(ma, mz02, ndsave, qx%ndig, qx)

      call fmovun_xe(ma(1), xe, qx)
      call fmovun_xe(ma(2), ye, qx)
      if (xe < -qx%ndig .and. ye < -qx%ndig) then
          call zmeq(mz02, mresult, qx)
          return
      else if (ma(2)%mp(3) == 0) then
          call fmsin(mz02(1), mresult(1), qx)
          call fmi2m(0, mresult(2), qx)
          return
      else if (ma(1)%mp(3) == 0) then
          call fmsinh(mz02(2), mresult(2), qx)
          call fmi2m(0, mresult(1), qx)
          return
      endif

!             Find cos(real(ma)) and sin(real(ma)).

      call fmcssn(mz02(1), mz01(2), mz01(1), qx)

!             find cosh(imag(ma)) and sinh(imag(ma)).

      call fmchsh(mz02(2), mxy(1), mxy(2), qx)

!             sin(ma) =  sin(real(ma))*cosh(imag(ma)) + cos(real(ma))*sinh(imag(ma)) i

      if (mxy(1)%mp(2) == qx%mexpov) then
          call fmabs(mz01(1), mxy(1), qx)
          call fmdivi_r1(mxy(1), 2, qx)
          call fmln(mxy(1), mxy(2), qx)
          qx%ndigli = 0
          call fmabs(mz02(2), mxy(3), qx)
          call fmadd(mxy(2), mxy(3), mxy(5), qx)
          call fmexp(mxy(5), mxy(4), qx)
          qx%ndige = 0
          if (mz01(1)%mp(1) < 0) call fmnegate(mxy(4), qx)

          call fmabs(mz01(2), mxy(1), qx)
          call fmdivi_r1(mxy(1), 2, qx)
          call fmln(mxy(1), mxy(2), qx)
          qx%ndigli = 0
          call fmadd(mxy(2), mxy(3), mxy(1), qx)
          call fmexp(mxy(1), mxy(5), qx)
          qx%ndige = 0
          if (mz02(2)%mp(1) < 0) call fmnegate(mxy(5), qx)
          if (mz01(2)%mp(1) < 0) call fmnegate(mxy(5), qx)

          call fmeq(mxy(4), mz01(1), qx)
          call fmeq(mxy(5), mz01(2), qx)
      else
          call fmmpy_r1(mz01(1), mxy(1), qx)
          call fmmpy_r1(mz01(2), mxy(2), qx)
      endif

      call zmeq(mz01, mresult, qx)

      return
      end subroutine zmsin_m1

      subroutine zmsin_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = sin(ma).

!  kresult = 1 is returned if a special case gives the value of sin(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMSIN    '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call zmi2m(0, mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmsin_sc

      subroutine zmsinh(ma, mb, qx)

!  mb = sinh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(5), mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmsinh_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmsinh_m1(ma, mxy, mresult, ndsave, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmsinh

      subroutine zmsinh_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing sinh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mxy(5), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      double precision :: xe, ye
      type(multi) :: mz01(2), mz02(2)

      call zmequ(ma, mz02, ndsave, qx%ndig, qx)

      call fmovun_xe(ma(1), xe, qx)
      call fmovun_xe(ma(2), ye, qx)
      if (xe < -qx%ndig .and. ye < -qx%ndig) then
          call zmeq(mz02, mresult, qx)
          return
      else if (ma(1)%mp(3) == 0) then
          call fmsin(mz02(2), mresult(2), qx)
          call fmi2m(0, mresult(1), qx)
          return
      else if (ma(2)%mp(3) == 0) then
          call fmsinh(mz02(1), mresult(1), qx)
          call fmi2m(0, mresult(2), qx)
          return
      endif

!             Find sin(imag(ma)) and cos(imag(ma)).

      call fmcssn(mz02(2), mz01(1), mz01(2), qx)

!             Find sinh(real(ma)) and cosh(real(ma)).

      call fmchsh(mz02(1), mxy(1), mxy(2), qx)

!             sinh(ma) =  sinh(real(ma))*cos(imag(ma)) + cosh(real(ma))*sin(imag(ma)) i

      if (mxy(1)%mp(2) == qx%mexpov) then
          call fmabs(mz01(1), mxy(1), qx)
          call fmdivi_r1(mxy(1), 2, qx)
          call fmln(mxy(1), mxy(2), qx)
          qx%ndigli = 0
          call fmabs(mz02(1), mxy(3), qx)
          call fmadd(mxy(2), mxy(3), mxy(5), qx)
          call fmexp(mxy(5), mxy(4), qx)
          qx%ndige = 0
          if (mz01(1)%mp(1) < 0) call fmnegate(mxy(4), qx)
          if (mz02(1)%mp(1) < 0) call fmnegate(mxy(4), qx)

          call fmabs(mz01(2), mxy(1), qx)
          call fmdivi_r1(mxy(1), 2, qx)
          call fmln(mxy(1), mxy(2), qx)
          qx%ndigli = 0
          call fmadd(mxy(2), mxy(3), mxy(1), qx)
          call fmexp(mxy(1), mxy(5), qx)
          qx%ndige = 0
          if (mz01(2)%mp(1) < 0) call fmnegate(mxy(5), qx)

          call fmeq(mxy(4), mz01(1), qx)
          call fmeq(mxy(5), mz01(2), qx)
      else
          call fmmpy_r1(mz01(1), mxy(2), qx)
          call fmmpy_r1(mz01(2), mxy(1), qx)
      endif

      call zmeq(mz01, mresult, qx)

      return
      end subroutine zmsinh_m1

      subroutine zmsinh_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = sinh(ma).

!  kresult = 1 is returned if a special case gives the value of sinh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMSINH   '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call zmi2m(0, mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmsinh_sc

      subroutine zmsqr(ma, mb, qx)

!  mb = ma*ma.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(2), mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmsqr_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmsqr_m1(ma, mxy, mresult, ndsave, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmsqr

      subroutine zmsqr_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing ma*ma.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mxy(2), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      type(multi) :: mz01(2), mz02(2)

      call zmequ(ma, mz02, ndsave, qx%ndig, qx)

      call fmadd(mz02(1), mz02(2), mxy(1), qx)
      call fmsub(mz02(1), mz02(2), mxy(2), qx)
      call fmmpy(mxy(1), mxy(2), mz01(1), qx)
      call fmmpy(mz02(1), mz02(2), mxy(2), qx)
      call fmadd(mxy(2), mxy(2), mz01(2), qx)

      call zmeq(mz01, mresult, qx)

      return
      end subroutine zmsqr_m1

      subroutine zmsqr_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = ma*ma.

!  kresult = 1 is returned if a special case gives the value of ma*ma.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMSQR    '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (malocal(2)%mp(3) == 0) then
          call fmsqr(malocal(1), mresult(1), qx)
          call fmi2m(0, mresult(2), qx)
          kresult = 1
      else if (malocal(1)%mp(3) == 0) then
          call fmsqr(malocal(2), mresult(1), qx)
          call fmnegate(mresult(1), qx)
          call fmi2m(0, mresult(2), qx)
          kresult = 1
      endif

      return
      end subroutine zmsqr_sc

      subroutine zmsqrt(ma, mb, qx)

!  mb = sqrt(ma).  Principal Square Root.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi) :: mxy(3), mresult(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmsqrt_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      retry = .true.
      do while (retry)
         retry = .false.
         call zmsqrt_m1(ma, mxy, mresult, ndsave, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmsqrt

      subroutine zmsqrt_m1(ma, mxy, mresult, ndsave, qx)

!  Method 1 for computing sqrt(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mxy(3), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult
      type(fm_settings) :: qx

      type(multi) :: mz01(2), mz02(2)

      call zmequ(ma, mz02, ndsave, qx%ndig, qx)

      if (ma(1)%mp(3) == 0) then
          call fmabs(mz02(2), mxy(1), qx)
          call fmdivi(mxy(1), 2, mxy(3), qx)
          call fmsqrt_r1(mxy(3), qx)
      else if (ma(2)%mp(3) == 0) then
          call fmabs(mz02(1), mxy(3), qx)
          call fmsqrt_r1(mxy(3), qx)
      else if (ma(2)%mp(2) == qx%mexpun) then
          call fmsqr(mz02(1), mxy(1), qx)
          call fmsqr(mz02(2), mxy(2), qx)
          call fmadd(mxy(1), mxy(2), mxy(3), qx)
          call fmsqrt_r1(mxy(3), qx)
          if (mxy(3)%mp(2) == qx%munkno) then
              call fmabs(mz02(1), mxy(1), qx)
              call fmabs(mz02(2), mxy(2), qx)
              call fmmax(mxy(1), mxy(2), mz01(1), qx)
              call fmmin(mxy(1), mxy(2), mz01(2), qx)
              call fmdiv(mz01(2), mz01(1), mxy(3), qx)
              call fmi2m(1, mxy(1), qx)
              call fmadd(mxy(1), mxy(3), mxy(2), qx)
              call fmsqrt_r1(mxy(2), qx)
              call fmmpy(mz01(1), mxy(2), mxy(3), qx)
          endif
          call fmabs(mz02(1), mxy(2), qx)
          call fmadd_r2(mxy(2), mxy(3), qx)
          call fmdivi_r1(mxy(3), 2, qx)
          call fmsqrt_r1(mxy(3), qx)
      else
          call fmsqr(mz02(1), mxy(1), qx)
          call fmsqr(mz02(2), mxy(2), qx)
          call fmadd(mxy(1), mxy(2), mxy(3), qx)
          call fmsqrt_r1(mxy(3), qx)
          if (mxy(3)%mp(2) == qx%munkno) then
              call fmabs(mz02(1), mxy(1), qx)
              call fmabs(mz02(2), mxy(2), qx)
              call fmmax(mxy(1), mxy(2), mz01(1), qx)
              call fmmin(mxy(1), mxy(2), mz01(2), qx)
              call fmdiv(mz01(2), mz01(1), mxy(3), qx)
              call fmi2m(1, mxy(1), qx)
              call fmadd(mxy(1), mxy(3), mxy(2), qx)
              call fmsqrt_r1(mxy(2), qx)
              call fmmpy(mz01(1), mxy(2), mxy(3), qx)
          endif
          call fmabs(mz02(1), mxy(2), qx)
          call fmadd_r2(mxy(2), mxy(3), qx)
          call fmdivi_r1(mxy(3), 2, qx)
          call fmsqrt_r1(mxy(3), qx)
      endif

      call fmadd(mxy(3), mxy(3), mxy(2), qx)
      if (ma(1)%mp(1) >= 0) then
          call fmdiv(mz02(2), mxy(2), mz01(2), qx)
          call fmeq(mxy(3), mz01(1), qx)
      else
          if (ma(2)%mp(1) >= 0) then
              call fmdiv(mz02(2), mxy(2), mz01(1), qx)
              call fmeq(mxy(3), mz01(2), qx)
          else
              call fmdiv(mz02(2), mxy(2), mz01(1), qx)
              call fmeq(mxy(3), mz01(2), qx)
              call fmnegate(mz01(1), qx)
              call fmnegate(mz01(2), qx)
          endif
      endif

      call zmeq(mz01, mresult, qx)

      return
      end subroutine zmsqrt_m1

      subroutine zmsqrt_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = sqrt(ma).

!  kresult = 1 is returned if a special case gives the value of sqrt(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMSQRT   '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call zmi2m(0, mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmsqrt_sc

      subroutine zmst2m(string, ma, qx)

!  ma = string

!  Convert a character string to fm format.
!  This is often more convenient than using zminp, which converts an array of character(1) values.

      use fmvals_parallel
      implicit none

      character :: cmbufz(lmbufz)
      character(*) :: string
      type(multi) :: ma(2)
      intent (in) :: string
      intent (inout) :: ma
      type(fm_settings) :: qx

      integer :: j, lb, kfsave

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'ZMST2M'
      lb = len(string)
      kfsave = qx%kflag

      if (lb > lmbufz) then
          write (*,"(//a//)") " Output buffer cmbufz is not big enough." //  &
                              " Raise its size (lmbufz) or change the format being used."
          stop
      endif
      do j = 1, lb
         cmbufz(j) = string(j:j)
      enddo

      qx%ncall = qx%ncall - 1
      call zminp(cmbufz, ma, 1, lb, qx)

      if (kfsave /= 0) qx%kflag = kfsave

      return
      end subroutine zmst2m

      subroutine zmsub(ma, mb, mc, qx)

!  mc = ma - mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx

      integer :: kovun
      double precision :: xe1, xe2, xe3, xe4
      type(multi) :: mxy(2)

      qx%ncall = qx%ncall + 1
      if (qx%ntrace /= 0) then
          qx%namest(qx%ncall) = 'ZMSUB'
          call zmntr_inp2(ma, mb, qx)
      endif
      kovun = 0
      if (ma(1)%mp(2) == qx%mexpov .or. ma(1)%mp(2) == qx%mexpun) kovun = 1
      if (ma(2)%mp(2) == qx%mexpov .or. ma(2)%mp(2) == qx%mexpun) kovun = 1
      if (mb(1)%mp(2) == qx%mexpov .or. mb(1)%mp(2) == qx%mexpun) kovun = 1
      if (mb(2)%mp(2) == qx%mexpov .or. mb(2)%mp(2) == qx%mexpun) kovun = 1
      if (ma(1)%mp(2) == qx%munkno .or. ma(2)%mp(2) == qx%munkno) kovun = 2
      if (mb(1)%mp(2) == qx%munkno .or. mb(2)%mp(2) == qx%munkno) kovun = 2

      call zmeq(mb, mxy, qx)
      call fmnegate(mxy(1), qx)
      call fmnegate(mxy(2), qx)
      call zmadd(ma, mxy, mc, qx)
      if (qx%kflag == 1) then
          call fmovun_xe(ma(1), xe1, qx)
          call fmovun_xe(ma(2), xe2, qx)
          call fmovun_xe(mb(1), xe3, qx)
          call fmovun_xe(mb(2), xe4, qx)
          if (max(xe1, xe2) <= max(xe3, xe4)) qx%kflag = 0
      endif
      if (mc(1)%mp(2) == qx%munkno .or. mc(2)%mp(2) == qx%munkno) then
          if (qx%kflag /= 1) qx%kflag = -4
      else if (mc(1)%mp(2) == qx%mexpov .or. mc(2)%mp(2) == qx%mexpov) then
          if (qx%kflag /= 1) qx%kflag = -5
      else if (mc(1)%mp(2) == qx%mexpun .or. mc(2)%mp(2) == qx%mexpun) then
          if (qx%kflag /= 1) qx%kflag = -6
      endif
      if ((mc(1)%mp(2) == qx%munkno .and. kovun /= 2) .or.  &
          (mc(2)%mp(2) == qx%munkno .and. kovun /= 2) .or.  &
          (mc(1)%mp(2) == qx%mexpun .and. kovun == 0) .or.  &
          (mc(2)%mp(2) == qx%mexpun .and. kovun == 0) .or.  &
          (mc(1)%mp(2) == qx%mexpov .and. kovun == 0) .or.  &
          (mc(2)%mp(2) == qx%mexpov .and. kovun == 0)) then
          qx%namest(qx%ncall) = 'ZMSUB'
          call fmwarn(qx)
      endif
      if (qx%ntrace /= 0) call zmntr_out1(mc, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine zmsub

      subroutine zmsub_r1(ma, mb, qx)

!  ma = ma - mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (inout) :: ma
      intent (in) :: mb
      type(fm_settings) :: qx

      integer :: k
      type(multi) :: mxy(2)

      call zmsub(ma, mb, mxy, qx)
      k = qx%kflag
      call zmeq(mxy, ma, qx)
      qx%kflag = k

      end subroutine zmsub_r1

      subroutine zmsub_r2(ma, mb, qx)

!  mb = ma - mb

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      integer :: k
      type(multi) :: mxy(2)

      call zmsub(ma, mb, mxy, qx)
      k = qx%kflag
      call zmeq(mxy, mb, qx)
      qx%kflag = k

      end subroutine zmsub_r2

      subroutine zmtan(ma, mb, qx)

!  mb = tan(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(3), mresult(2), mretry(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmtan_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      n_acc = nint(qx%ndig*qx%alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call zmtan_m1(ma, mxy, mresult, ndsave, n_acc, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
         if (.not. retry) then
             call zmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)
         endif
         numtry = numtry + 1
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmtan

      subroutine zmtan_m1(ma, mxy, mresult, ndsave, n_acc, qx)

!  Method 1 for computing tan(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mxy(3), mresult(2)
      integer :: ndsave, n_acc
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      integer :: k, krsave
      double precision :: xe, ye
      type(multi) :: mz01(2), mz02(2), mz03(2)

      call fmndig(qx%ndig + qx%ngrd21, qx)
      call zmequ(ma, mz02, ndsave, qx%ndig, qx)
      n_acc = nint(qx%ndig*qx%alogm2)
      krsave = qx%krad
      qx%krad = 1

      call fmovun_xe(ma(1), xe, qx)
      call fmovun_xe(ma(2), ye, qx)
      if (xe < -qx%ndig .and. ye < -qx%ndig) then
          call zmeq(mz02, mresult, qx)
          qx%krad = krsave
          return
      else if (ma(2)%mp(3) == 0) then
          call fmtan(mz02(1), mresult(1), qx)
          call fmi2m(0, mresult(2), qx)
          qx%krad = krsave
          return
      else if (ma(1)%mp(3) == 0) then
          call fmtanh(mz02(2), mresult(2), qx)
          call fmi2m(0, mresult(1), qx)
          qx%krad = krsave
          return
      endif

!             Find sin(2*real(ma)) and cos(2*real(ma)).

      call fmadd(mz02(1), mz02(1), mz01(1), qx)
      call fmcssn(mz01(1), mz01(2), mxy(2), qx)
      call fmeq(mxy(2), mz01(1), qx)

!             Find sinh(2*imag(ma)) and cosh(2*imag(ma)).

      call fmadd(mz02(2), mz02(2), mxy(2), qx)
      call fmchsh(mxy(2), mxy(1), mxy(3), qx)
      call fmeq(mxy(3), mxy(2), qx)
      if (mz01(1)%mp(2) == qx%munkno .and. mz01(1)%mp(5) >= 0) then
          if (qx%kround == 1) then
              call fmovun_xe(mxy(1), xe, qx)
              if (xe >= qx%ndig) then
                  call fmi2m(0, mz01(2), qx)
                  call fmi2m(1, mxy(1), qx)
                  call fmi2m(1, mxy(2), qx)
                  mxy(2)%mp(1) = ma(2)%mp(1)
              endif
          endif
      endif

!             tan(ma) =  sin(2*real(ma))  / (cos(2*real(ma))+cosh(2*imag(ma)) +
!                        sinh(2*imag(ma)) / (cos(2*real(ma))+cosh(2*imag(ma)) i

      call fmadd(mz01(2), mxy(1), mxy(3), qx)
      call fmcancel(mz01(2), mxy(1), mxy(3), k, qx)
      n_acc = n_acc - k
      call fmeq(mxy(3), mxy(1), qx)
      if (mxy(1)%mp(2) == qx%mexpov) then
          call fmdiv_r1(mz01(1), mxy(1), qx)
          call fmi2m2(1, mz01(2), qx)
          if (mxy(2)%mp(1) < 0) call fmnegate(mz01(2), qx)
      else
          call fmdivd(mz01(1), mxy(2), mxy(1), mz03(1), mz03(2), qx)
          call zmeq(mz03, mz01, qx)
      endif

      call zmeq(mz01, mresult, qx)
      qx%krad = krsave

      return
      end subroutine zmtan_m1

      subroutine zmtan_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = tan(ma).

!  kresult = 1 is returned if a special case gives the value of tan(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMTAN    '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call zmi2m(0, mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmtan_sc

      subroutine zmtanh(ma, mb, qx)

!  mb = tanh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi) :: mxy(3), mresult(2), mretry(2)

      call zmalloc(mb, qx%ndig+2, qx)
      call zmenter1(ma, kovun, mxsave, ndsave, qx)
      call zmtanh_sc(ma, ndsave, mresult, kresult, qx)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)
          return
      endif

      if (qx%mblogs /= qx%mbase) call fmcons(qx)

      numtry = 0
      n_acc = nint(qx%ndig*qx%alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call zmtanh_m1(ma, mxy, mresult, ndsave, n_acc, qx)
         call zmcheck_accuracy(mresult, ndsave, retry, qx)
         if (.not. retry) then
             call zmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry, qx)
         endif
         numtry = numtry + 1
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave, qx)

      return
      end subroutine zmtanh

      subroutine zmtanh_m1(ma, mxy, mresult, ndsave, n_acc, qx)

!  Method 1 for computing tanh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mxy(3), mresult(2)
      integer :: ndsave, n_acc
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, n_acc
      type(fm_settings) :: qx

      integer :: k, krsave
      double precision :: xe, ye
      type(multi) :: mz01(2), mz02(2), mz03(2)

      call zmequ(ma, mz02, ndsave, qx%ndig, qx)
      n_acc = nint(qx%ndig*qx%alogm2)
      krsave = qx%krad
      qx%krad = 1

      call fmovun_xe(mz02(1), xe, qx)
      call fmovun_xe(mz02(2), ye, qx)
      if (xe < -qx%ndig .and. ye < -qx%ndig) then
          call zmeq(mz02, mresult, qx)
          qx%krad = krsave
          return
      else if (ma(1)%mp(3) == 0) then
          call fmtan(mz02(2), mresult(2), qx)
          call fmi2m(0, mresult(1), qx)
          qx%krad = krsave
          return
      else if (ma(2)%mp(3) == 0) then
          call fmtanh(mz02(1), mresult(1), qx)
          call fmi2m(0, mresult(2), qx)
          qx%krad = krsave
          return
      endif

!             Find sin(2*imag(ma)) and cos(2*imag(ma)).

      call fmadd(mz02(2), mz02(2), mz01(1), qx)
      call fmcssn(mz01(1), mz01(2), mxy(2), qx)
      call fmeq(mxy(2), mz01(1), qx)

!             Find sinh(2*real(ma)) and cosh(2*real(ma)).

      call fmadd(mz02(1), mz02(1), mxy(2), qx)
      call fmchsh(mxy(2), mxy(1), mxy(3), qx)
      call fmeq(mxy(3), mxy(2), qx)
      if (mz01(1)%mp(2) == qx%munkno .and. mz01(1)%mp(5) >= 0) then
          if (qx%kround == 1) then
              call fmovun_xe(mxy(1), xe, qx)
              if (xe >= qx%ndig) then
                  call fmi2m(0, mz01(2), qx)
                  call fmi2m(1, mxy(1), qx)
                  call fmi2m(1, mxy(2), qx)
                  mxy(2)%mp(1) = ma(1)%mp(1)
              endif
          endif
      endif

!             tanh(ma) =  sinh(2*real(ma)) / (cos(2*imag(ma))+cosh(2*real(ma)) +
!                         sin(2*imag(ma))  / (cos(2*imag(ma))+cosh(2*real(ma)) i

      call fmadd(mz01(2), mxy(1), mxy(3), qx)
      call fmcancel(mz01(2), mxy(1), mxy(3), k, qx)
      n_acc = n_acc - k
      call fmeq(mxy(3), mxy(1), qx)
      if (mxy(1)%mp(2) == qx%mexpov) then
          call fmdiv(mz01(1), mxy(1), mz01(2), qx)
          call fmi2m2(1, mz01(1), qx)
          if (mxy(2)%mp(1) < 0) mz01(1)%mp(1) = -1
      else
          call fmdivd(mz01(1), mxy(2), mxy(1), mz03(2), mz03(1), qx)
          call zmeq(mz03, mz01, qx)
      endif

      call zmeq(mz01, mresult, qx)
      qx%krad = krsave

      return
      end subroutine zmtanh_m1

      subroutine zmtanh_sc(ma, ndsave, mresult, kresult, qx)

!  Check for special cases for mresult = tanh(ma).

!  kresult = 1 is returned if a special case gives the value of tanh(ma).

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult
      type(fm_settings) :: qx

      integer :: j
      type(multi) :: malocal(2)

      kresult = 0

      qx%namest(qx%ncall) = 'ZMTANH   '
      j = qx%ndig
      qx%ndig = ndsave
      call zmntr_inp1(ma, qx)
      call fmndig(j, qx)

      call zmequ(ma, malocal, ndsave, qx%ndig, qx)

      if ((malocal(1)%mp(2) == qx%munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == qx%munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult, qx)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call zmi2m(0, mresult, qx)
          kresult = 1
          return
      endif

      return
      end subroutine zmtanh_sc

      subroutine zmunknown(ma, qx)

!  Set ma to fm's special value for unknown complex results.

      use fmvals_parallel
      implicit none

      type(multi) :: ma(2)
      intent (inout) :: ma
      type(fm_settings) :: qx

      call fmunknown(ma(1), qx)
      call fmunknown(ma(2), qx)

      return
      end subroutine zmunknown

      subroutine zmwrit(kwrite, ma, qx)

!  Write ma on unit kwrite under the current format.  Multi-line numbers will have '&' as the last
!  nonblank character on all but the last line of the real part and the imaginary part.
!  These numbers can then be read easily using zmread.

      use fmvals_parallel
      implicit none

      character :: cmbufz(lmbufz)
      integer :: kwrite
      type(multi) :: ma(2)
      intent (in) :: ma, kwrite
      type(fm_settings) :: qx

      integer :: j, k, ksave, l, last, last1, last2, lb, nd, nexp

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'ZMWRIT'
      ksave = qx%kflag
      nd = int(real(qx%ndig)*log10(real(qx%mbase))) + 1
      if (nd < 2) nd = 2
      nexp = int(2.0*log10(real(mxbase))) + 16
      lb = 2*max(qx%jform2+nexp, nd+nexp) + 3
      if (lb > lmbufz) then
          write (*,"(//a//)") " Output buffer cmbufz is not big enough." //  &
                              " Raise its size (lmbufz) or change the format being used."
          stop
      endif
      call zmout(ma, cmbufz, lb, last1, last2, qx)
      qx%kflag = ksave
      last = last2 + 1
      do j = 1, last2
         if (cmbufz(last-j) /= ' ' .or. j == last2) then
             l = last - j
             if (mod(l, 73) /= 0) then
                 write (kwrite, "(4X, 73A1, ' &')") (cmbufz(k), k=1, l)
             else
                 write (kwrite, "(4X, 73A1, ' &')") (cmbufz(k), k=1, l-73)
                 write (kwrite, "(4X, 73A1)") (cmbufz(k), k=l-72, l)
             endif
             qx%ncall = qx%ncall - 1
             return
         endif
      enddo
      qx%ncall = qx%ncall - 1

      return
      end subroutine zmwrit

      subroutine zmwrite(kwrite, ma, qx)

      use fmvals_parallel
      implicit none

      integer :: kwrite
      type(multi) :: ma(2)
      intent (in) :: kwrite, ma
      type(fm_settings) :: qx

      call zmwrit(kwrite, ma, qx)

      return
      end subroutine zmwrite

      subroutine zmz2m(zval, ma, qx)

!  ma = zval

!  zval is complex and is converted to zm form.

      use fmvals_parallel
      implicit none

      complex :: zval
      type(multi) :: ma(2)
      intent (in) :: zval
      intent (inout) :: ma
      type(fm_settings) :: qx

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'ZMZ2M'
      if (qx%ntrace /= 0) call fmntr_inpz(zval, qx)

      call fmsp2m(real(zval), ma(1), qx)
      call fmsp2m(aimag(zval), ma(2), qx)

      if (qx%ntrace /= 0) call zmntr_out1(ma, qx)
      qx%ncall = qx%ncall - 1

      return
      end subroutine zmz2m

 module fmzm_1_parallel
      use fmvals_parallel


!  FMZM 1.4                        David M. Smith

!  This module extends the definition of the basic Fortran arithmetic and function operations so
!  they also apply to multiple precision numbers, using version 1.4 of FM.
!  There are three multiple precision data types:
!     FM  (multiple precision real)
!     IM  (multiple precision integer)
!     ZM  (multiple precision complex)

!  For some examples and general advice about using these multiple-precision data types, see the
!  program SampleFM.f95.

!  Most of the functions defined in this module are multiple precision versions of standard Fortran
!  functions.  In addition, there are functions for direct conversion, formatting, and some
!  mathematical special functions.

!  to_fm is a function for converting other types of numbers to type FM.  Note that to_fm(3.12)
!  converts the real constant to FM, but it is accurate only to single precision, since the number
!  3.12 cannot be represented exactly in binary and has already been rounded to single precision.
!  Similarly, to_fm(3.12d0) agrees with 3.12 to double precision accuracy, and to_fm('3.12') or
!  to_fm(312)/to_fm(100) agrees to full FM accuracy.

!  to_im converts to type IM, and to_zm converts to type ZM.

!  Functions are also supplied for converting the three multiple precision types to the other
!  numeric data types:
!     to_int   converts to machine precision integer
!     to_sp    converts to single precision
!     to_dp    converts to double precision
!     to_spz   converts to single precision complex
!     to_dpz   converts to double precision complex

!  WARNING:   When multiple precision type declarations are inserted in an existing program, take
!             care in converting functions like dble(x), where x has been declared as a multiple
!             precision type.  If x was single precision in the original program, then replacing
!             the dble(x) by to_dp(x) in the new version could lose accuracy. For this reason, the
!             Fortran type-conversion functions defined in this module assume that results should
!             be multiple precision whenever inputs are.  Examples:
!             dble(to_fm('1.23e+123456'))         is type FM
!             real(to_fm('1.23e+123456'))         is type FM
!             real(to_zm('3.12+4.56i'))           is type FM   = to_fm('3.12')
!             int(to_fm('1.23'))                  is type IM   = to_im(1)
!             int(to_im('1e+23'))                 is type IM
!             cmplx(to_fm('1.23'),to_fm('4.56'))  is type ZM

!  is_overflow, is_underflow, and is_unknown are logical functions for checking whether a multiple
!  precision number is in one of the exception categories.  Testing to see if a type FM number is
!  in the +overflow category by directly using an if can be tricky.  When mafm is +overflow, the
!  statement
!             if (mafm == to_fm(' +overflow ')) then
!  will return false, since the comparison routine cannot be sure that two different overflowed
!  results would have been equal if the overflow threshold had been higher.  Instead, use
!             if (is_overflow(mafm)) then
!  which will be true if mafm is + or - overflow.

!  Programs using this module may sometimes need to call fm, im, or zm routines directly.  This
!  is normally the case when routines are needed that are not Fortran intrinsics, such as the
!  formatting subroutine fm_form.  In a program using this module, suppose mafm has been declared
!  with type (fm) :: mafm.  To convert the number to a character string with f65.60 format, use
!     call fm_form('f65.60',mafm,st1)

!  WARNING:   To be safe, all multiple precision variables in a user's program should be declared
!             as type (fm), (im), or (zm), and any direct calls to subroutines should be the kind
!             with the underscore.  To compute pi, use
!                 call fm_pi(pi)
!             Calling the low-level routine in fm.f95 ( call fmpi(pi%mfm) ) is not recommended.

!  In subroutine or function subprograms all multiple precision variables that are local to that
!  routine should be declared with the save attribute.  It is not an error to omit save, but if
!  the compiler creates new copies of the variables for each call to the routine, then the program
!  could leak memory.

!  Type (fm), (im), or (zm) variables cannot have their multiple precision values initialized in
!  the declaration statement, as can ordinary variables.  If the original program had
!      double precision :: x = 2.3d0
!  then the corresponding FM version would have
!      type (fm) :: x
!      ... (other declarations) ...
!      x = to_fm( '2.3' )
!
!  An attempt to use a multiple precision variable that has not been defined will be detected by
!  the routines in this module and an error message printed.
!
!  For each of the operations =,  == ,  /= ,  < ,  <= ,  > ,  >= , +, -, *, /, and **, the interface
!  module defines all mixed mode variations involving one of the three multiple precision derived
!  types and another argument having one of the types: { integer, real, double, complex, complex
!  double, fm, im, zm }.  So mixed mode expressions such as
!        mafm = 12
!        mafm = mafm + 1
!        if (abs(mafm) > 1.0d-23) then
!  are handled correctly.

!  Not all the named functions are defined for all three multiple precision derived types, so the
!  list below shows which can be used.  The labels "real", "integer", and "complex" refer to types
!  fm, im, and zm respectively, "string" means the function accepts character strings (e.g.,
!  to_fm('3.45')), and "other" means the function can accept any of the machine precision data
!  types integer, real, double, complex, or complex double.  For functions that accept two or more
!  arguments, like atan2 or max, all the arguments must be of the same type.

!  Note that to_zm also has a 2-argument form:  to_zm(2,3) for getting 2 + 3*i.
!  cmplx can be used for that, as in cmplx( to_fm(2) , to_fm(3) ), but the 2-argument form is
!  more concise.  The 2-argument form is available for machine precision integer, single and
!  double precision real pairs.  For others, such as x and y being type(fm), just use cmplx(x,y).

!  Fortran's 2-argument version of atan(x,y) is also provided.  It is the same as the older atan2.
!  Functions in this list that are not provided by standard Fortran, such as special functions,
!  have more information about their arguments farther down.


!  AVAILABLE FUNCTIONS:

!     =
!     +
!     -
!     *
!     /
!     **
!     ==
!     /=
!     <
!     <=
!     >
!     >=
!     abs                  real    integer    complex
!     acos                 real               complex
!     acosh                real               complex
!     aimag                                   complex
!     aint                 real               complex
!     anint                real               complex
!     arg                                     complex
!     asin                 real               complex
!     asinh                real               complex
!     atan                 real               complex
!     atan2                real
!     atanh                real               complex
!     bernoulli            real
!     bessel_j             real
!     bessel_y             real
!     beta                 real
!     binomial             real    integer    complex
!     btest                        integer
!     ceiling              real    integer    complex
!     cmplx                real    integer
!     conjg                                   complex
!     cos                  real               complex
!     cosh                 real               complex
!     cos_integral         real
!     cosh_integral        real
!     dble                 real    integer    complex
!     digits               real    integer    complex
!     dim                  real    integer
!     dint                 real               complex
!     epsilon              real
!     erf                  real               complex
!     erfc                 real               complex
!     erfc_scaled          real               complex
!     exp                  real               complex
!     exponent             real
!     exp_integral_ei      real
!     exp_integral_en      real
!     factorial            real    integer    complex
!     floor                real    integer    complex
!     fraction             real               complex
!     fresnel_c            real
!     fresnel_s            real
!     gamma                real               complex
!     gcd                          integer
!     huge                 real    integer    complex
!     hypot                real
!     incomplete_beta      real
!     incomplete_gamma1    real
!     incomplete_gamma2    real
!     int                  real    integer    complex
!     log                  real               complex
!     log10                real               complex
!     log_erfc             real
!     log_gamma            real               complex
!     log_integral         real
!     max                  real    integer
!     maxexponent          real
!     min                  real    integer
!     minexponent          real
!     mod                  real    integer
!     modulo               real    integer
!     multiply_mod                 integer
!     nearest              real
!     nint                 real    integer    complex
!     norm2                real
!     pochhammer           real
!     polygamma            real               complex
!     power_mod                    integer
!     precision            real               complex
!     psi                  real               complex
!     radix                real    integer    complex
!     range                real    integer    complex
!     real                 real    integer    complex
!     rrspacing            real
!     scale                real               complex
!     setexponent          real
!     sign                 real    integer
!     sin                  real               complex
!     sinh                 real               complex
!     sin_integral         real
!     sinh_integral        real
!     spacing              real
!     sqrt                 real               complex
!     tan                  real               complex
!     tanh                 real               complex
!     tiny                 real    integer    complex
!     to_fm                real    integer    complex    string    other
!     to_im                real    integer    complex    string    other
!     to_zm                real    integer    complex    string    other
!     to_int               real    integer    complex
!     to_sp                real    integer    complex
!     to_dp                real    integer    complex
!     to_spz               real    integer    complex
!     to_dpz               real    integer    complex
!     is_overflow          real    integer    complex
!     is_underflow         real    integer    complex
!     is_unknown           real    integer    complex


!  SUBROUTINES THAT DO NOT CORRESPOND TO ANY FUNCTION ABOVE:

!  1. Type (fm).  ma, mb, mc refer to type (fm) numbers.

!     fm_cosh_sinh(ma,mb,mc)     mb = cosh(ma),  mc = sinh(ma)
!                                Faster than making two separate calls.

!     fm_cos_sin(ma,mb,mc)       mb = cos(ma),  mc = sin(ma)
!                                Faster than making two separate calls.

!     fm_euler(ma)               ma = Euler's constant ( 0.5772156649... )

!     fm_flag(k)                 k = kflag  get the value of the FM condition flag -- stored in
!                                           the internal FM variable kflag in module fmvals.

!     fm_form(form,ma,string)    ma is converted to a character string using format form and
!                                   returned in string.  form can represent i, f, e, or es formats.
!                                   Example:
!                                   call fmform('f60.40',ma,string)

!     fm_fprint(form,ma)         Print ma on unit kw using form format.

!     fm_pi(ma)                  ma = pi

!     fm_print(ma)               Print ma on unit kw using current format.

!     fm_random_number(x)        x is returned as a double precision random number, uniformly
!                                distributed on the open interval (0,1).  It is a high-quality,
!                                long-period generator based on 49-digit prime numbers.
!                                Note that x is double precision, unlike the similar Fortran
!                                intrinsic random number routine, which can return a single
!                                or double precision result.
!                                A default initial seed is used if fm_random_number is called
!                                without calling fm_random_seed_put first.

!     fm_random_seed_get(seed)   returns the seven integers seed(1) through seed(7) as the current
!                                seed for the fm_random_number generator.

!     fm_random_seed_put(seed)   initializes the fm_random_number generator using the seven integers
!                                seed(1) through seed(7). These get and put functions are slower
!                                than fm_random_number, so fm_random_number should be called many
!                                times between fm_random_seed_put calls.  Also, some generators that
!                                used a 9-digit modulus have failed randomness tests when used with
!                                only a few numbers being generated between calls to re-start with
!                                a new seed.

!     fm_random_seed_size(size)  returns integer size as the size of the seed array used by the
!                                fm_random_number generator.  Currently, size = 7.

!     fm_rational_power(ma,k,j,mb)
!                                mb = ma**(k/j)  Rational power.
!                                Faster than mb = ma**(to_fm(k)/j) for functions like the cube root.

!     fm_read(kread,ma)          ma is returned after reading one (possibly multi-line) FM number
!                                   on unit kread.  This routine reads numbers written by fm_write.

!     fm_set(nprec)              Set the internal FM variables so that the precision is at least
!                                nprec base 10 digits plus three base 10 guard digits.

!     fm_setvar(string)          Define a new value for one of the internal FM variables in module
!                                fmvals that controls one of the FM options.  string has the form
!                                      variable = value.
!                                Example:  To change the screen width for FM output:
!                                      call fm_setvar(' kswide = 120 ')
!                                The variables that can be changed and the options they control are
!                                listed in sections 2 through 6 of the comments at the top of the
!                                fm.f95 file.  Only one variable can be set per call.  The variable
!                                name in string must have no embedded blanks.  The value part of
!                                string can be in any numerical format, except in the case of
!                                variable cmchar, which is character type.  To set cmchar to 'e',
!                                don't use any quotes in string:
!                                      call fm_setvar(' cmchar = e ')

!     fm_ulp(ma,mb)              mb = One Unit in the Last Place of ma.  For positive ma this is the
!                                     same as the Fortran function spacing, but mb < 0 if ma < 0.
!                                     Examples:  If mbase = 10 and ndig = 30, then ulp(1.0) =
!                                                1.0e-29,  ulp(-4.5e+67) = -1.0e+38.
!

!     fm_vars                    Write the current values of the internal FM variables on unit kw.

!     fm_write(kwrite,ma)        Write ma on unit kwrite.
!                                Multi-line numbers will have '&' as the last nonblank character
!                                on all but the last line.  These numbers can then be read easily
!                                using fm_read.


!  2. Type (im).    ma, mb, mc refer to type (im) numbers.

!     im_divr(ma,mb,mc,md)       mc = int(ma/mb),   md = ma mod mb
!                                     When both the quotient and remainder are needed, this routine
!                                     is twice as fast as doing mc = ma/mb and md = mod(ma,mb)
!                                     separately.

!     im_dvir(ma,ival,mb,irem)   mb = int(ma/ival),   irem = ma mod ival
!                                ival and irem are one word integers.  Faster than doing separately.

!     im_form(form,ma,string)    ma is converted to a character string using format form and
!                                   returned in string.  form can represent i, f, e, or es formats.
!                                   Example: call imform('i70',ma,string)

!     im_fprint(form,ma)         Print ma on unit kw using form format.

!     im_print(ma)               Print ma on unit kw.

!     im_read(kread,ma)          ma is returned after reading one (possibly multi-line) IM number
!                                   on unit kread.  This routine reads numbers written by im_write.

!     im_write(kwrite,ma)        Write ma on unit kwrite.  Multi-line numbers will have '&' as the
!                                last nonblank character on all but the last line.
!                                These numbers can then be read easily using im_read.


!  3. Type (zm).    ma, mb, mc refer to type (zm) numbers.  mbfm is type (fm).

!     zm_arg(ma,mbfm)            mbfm = complex argument of ma.  mbfm is the (real) angle in the
!                                       interval ( -pi , pi ] from the positive real axis to the
!                                       point (x,y) when ma = x + y*i.

!     zm_cosh_sinh(ma,mb,mc)     mb = cosh(ma),  mc = sinh(ma).
!                                     Faster than 2 calls.

!     zm_cos_sin(ma,mb,mc)       mb = cos(ma),  mc = sin(ma).
!                                     Faster than 2 calls.

!     zm_form(form1,form2,ma,string)
!                                string = ma
!                                ma is converted to a character string using format form1 for the
!                                real part and form2 for the imaginary part.  The result is returned
!                                in string.  form1 and form2 can represent i, f, e, or es formats.
!                                Example:
!                                      call zmform('f20.10', 'f15.10',ma,string)

!     zm_fprint(form1,form2,ma)  Print ma on unit kw using formats form1 and form2.

!     zm_print(ma)               Print ma on unit kw using current format.

!     zm_read(kread,ma)          ma is returned after reading one (possibly multi-line) ZM number
!                                   on unit kread.  This routine reads numbers written by zmwrite.

!     zm_rational_power(ma,ival,jval,mb)
!                                mb = ma ** (ival/jval)
!                                Faster than mb = ma**(to_fm(k)/j) for functions like the cube root.

!     zm_write(kwrite,ma)        Write ma on unit kwrite.  Multi-line numbers are formatted for
!                                automatic reading with zmread.


!  Some other functions are defined that do not correspond to machine precision intrinsic
!  functions. These include formatting functions, integer modular functions and gcd, and some
!  mathematical special functions.
!  n, k below are machine precision integers, j1, j2, j3 are type (im), fmt, fmtr, fmti are
!  character strings, a, b, x are type (fm), and z is type (zm).
!  The three formatting functions return a character string containing the formatted number, the
!  three type (im) functions return a type (im) result, and the 12 special functions return
!  type (fm) results.

!  Formatting functions:

!     fm_format(fmt,a)        Put a into fmt (real) format
!     im_format(fmt,j1)       Put j1 into fmt (integer) format
!     zm_format(fmtr,fmti,z)  Put z into (complex) format, fmtr for the real
!                             part and fmti for the imaginary part

!     Examples:
!        st = fm_format('f65.60',a)
!        write (*,*) ' a = ',trim(st)
!        st = fm_format('e75.60',b)
!        write (*,*) ' b = ',st(1:75)
!        st = im_format('i50',j1)
!        write (*,*) ' j1 = ',st(1:50)
!        st = zm_format('f35.30', 'f30.25',z)
!        write (*,*) ' z = ',st(1:70)

!     These functions are used for one-line output.  The returned character strings are of
!     length 200.

!     For higher precision numbers, the output can be broken onto multiple lines automatically by
!     calling subroutines fm_print, im_print, zm_print, or the line breaks can be done by hand after
!     calling one of the subroutines fm_form, im_form, zm_form.

!     For zm_format the length of the output is 5 more than the sum of the two field widths.

!  Integer functions:

!     binomial(n,k)           Binomial coefficient n choose k.  Returns the exact result as a
!                                  type IM value.
!     binomial(j1,j2)         Binomial coefficient j1 choose j2.  Like factorial below, the result
!                                  might be too large unless min(j2,j1-j2) is fairly small,
!     factorial(n)            n!   Returns the exact result as a type IM value.
!     factorial(j1)           j1!  Note that the factorial function grows so rapidly that if type IM
!                                  variable j1 is larger than the largest machine precision integer,
!                                  then j1! has over 10 billion digits and the calculation would
!                                  likely fail due to memory or time constraints.  This version is
!                                  provided for convenience, and will return unknown if j1 cannot
!                                  be represented as a machine precision integer.
!     gcd(j1,j2)              Greatest Common Divisor of j1 and j2.
!     multiply_mod(j1,j2,j3)  j1 * j2 mod j3
!     power_mod(j1,j2,j3)     j1 ** j2 mod j3

!  Special functions:

!     bernoulli(n)            Nth Bernoulli number
!     bessel_j(n,x)           Bessel function of the first kind J_n(x)
!     bessel_j0(x)            Fortran-08 name for j_0(x)
!     bessel_j1(x)            Fortran-08 name for j_1(x)
!     bessel_jn(n,x)          Fortran-08 name for J_n(x)
!     bessel_jn(n1,n2,x)      Returns array (/ J_n1(x) , ... , J_n2(x) /)
!     bessel_y(n,x)           Bessel function of the second kind Y_n(x)
!     bessel_y0(x)            Fortran-08 name for y_0(x)
!     bessel_y1(x)            Fortran-08 name for y_1(x)
!     bessel_yn(n,x)          Fortran-08 name for Y_n(x)
!     bessel_yn(n1,n2,x)      Returns array (/ Y_n1(x) , ... , Y_n2(x) /)
!     beta(a,b)               Integral (0 to 1)  t**(a-1) * (1-t)**(b-1)  dt
!     binomial(a,b)           Binomial Coefficient  a! / ( b! (a-b)! )
!     cos_integral(x)         Cosine Integral Ci(x)
!     cosh_integral(x)        Hyperbolic Cosine Integral Chi(x)
!     erf(x)                  Error function Erf(x)
!     erfc(x)                 Complimentary error function Erfc(x)
!     erfc_scaled(x)          Exp(x^2) * Erfc(x)
!     exp_integral_ei(x)      Exponential Integral Ei(x)
!     exp_integral_en(n,x)    Exponential Integral E_n(x)
!     factorial(x)            x!   = Gamma(x+1)
!     fresnel_c(x)            Fresnel Cosine Integral c(x)
!     fresnel_s(x)            Fresnel Sine Integral s(x)
!     gamma(x)                Integral (0 to infinity)  t**(x-1) * exp(-t)  dt
!     incomplete_beta(x,a,b)  Integral (0 to x)  t**(a-1) * (1-t)**(b-1)  dt
!     incomplete_gamma1(a,x)  Integral (0 to x)  t**(a-1) * exp(-t)  dt
!     incomplete_gamma2(a,x)  Integral (x to infinity)  t**(a-1) * exp(-t)  dt
!     log_erfc(x)             Ln( Erfc(x) )
!     log_gamma(x)            Analytic continuation of real Ln( Gamma(x) ).  May differ from complex
!                             Ln( Gamma(x) ) by an integer multiple of 2*pi*i.
!     log_integral(x)         Logarithmic Integral Li(x)
!     pochhammer(x,n)         x*(x+1)*(x+2)*...*(x+n-1)
!     polygamma(n,x)          Nth derivative of Psi(x)
!     psi(x)                  Derivative of Ln(Gamma(x))
!     sin_integral(x)         Sine Integral Si(x)
!     sinh_integral(x)        Hyperbolic Sine Integral Shi(x)


!  Array operations:

!  Arithmetic operations and functions on arrays of dimension (rank) one or two are supported for
!  each of the three multiple-precision types.  Binary operations (+-*/) require both arguments to
!  have the same rank and shape.

!     Examples:
!        type (fm), save, dimension(10)  :: a, b
!        type (fm), save, dimension(3,3) :: c
!        type (im), save, dimension(10)  :: j, k
!        type (im), save, dimension(3,3) :: l
!        ...
!        a = 0                           ! Set the whole array to zero
!        j = j * k                       ! Set j(i) = j(i) * k(i) for i = 1, ..., 10
!        b = a - k                       ! Mixed-mode operations are ok
!        c = 7.3d0 * c - ( c + 2*l )/3

!     Array functions:

!        dot_product(x,y)     Dot product of rank 1 vectors of the same type.
!                             Note that when x and y are complex, the result is not just the sum
!                             of the products of the corresponding array elements, as it is for
!                             types FM and IM.  For ZM the formula is the sum of
!                             conjg(x(j)) * y(j).
!        is_overflow(x)       Returns true if any element is + or - overflow.
!        is_underflow(x)      Returns true if any element is + or - underflow.
!        is_unknown(x)        Returns true if any element is unknown.
!        matmul(x,y)          Matrix multiplication of arrays of the same type
!                             Cases for valid argument shapes:
!                             (1)  (n,m) * (m,k) --> (n,k)
!                             (2)    (m) * (m,k) --> (k)
!                             (3)  (n,m) * (m)   --> (n)
!        maxloc(x)            Location of the maximum value in the array
!        maxval(x)            Maximum value in the array
!        minloc(x)            Location of the minimum value in the array
!        minval(x)            Minimum value in the array
!        product(x)           Product of all values in the array
!        sum(x)               Sum of all values in the array
!        transpose(x)         Matrix transposition.  If x is a rank 2 array with shape (n,m), then
!                             y = transpose(x) has shape (m,n) with y(i,j) = x(j,i).
!        to_fm(x)             Rank 1 or 2 arrays are converted to similar type (fm) arrays.
!        to_im(x)             Rank 1 or 2 arrays are converted to similar type (im) arrays.
!        to_zm(x)             Rank 1 or 2 arrays are converted to similar type (zm) arrays.
!        to_int(x)            Rank 1 or 2 arrays are converted to similar integer arrays.
!        to_sp(x)             Rank 1 or 2 arrays are converted to similar single precision arrays.
!        to_dp(x)             Rank 1 or 2 arrays are converted to similar double precision arrays.
!        to_spz(x)            Rank 1 or 2 arrays are converted to similar single complex arrays.
!        to_dpz(x)            Rank 1 or 2 arrays are converted to similar double complex arrays.

!     The arithmetic array functions dot_product, matmul, product, and sum work like the other
!     functions in the FM package in that they raise precision and compute the sums and/or products
!     at the higher precision, then round the final result back to the user's precision to provide
!     a more accurate result.

!     Fortran's optional [,mask] argument for these functions is not provided.

!     Many of the 1-argument functions can be used with array arguments, with the result being an
!     array of the same size and shape where the function has been applied to each element.

!     Examples:
!        type (fm), save, dimension(10) :: a, b, c
!        ...
!        a = abs(b)                ! Set a(i) = abs(b(i)) for i = 1, ..., 10
!        c = sqrt(a+4+b*b)         ! Set c(i) = sqrt(a(i)+4+b(i)*b(i)) for i = 1, ..., 10

!     Functions that can have array arguments.  As above, "real", "integer", and "complex" refer
!     to types FM, IM, and ZM respectively.

!     abs              real    integer    complex
!     acos             real               complex
!     acosh            real               complex
!     aimag                               complex
!     aint             real               complex
!     anint            real               complex
!     arg                                 complex
!     asin             real               complex
!     asinh            real               complex
!     atan             real               complex
!     atanh            real               complex
!     ceiling          real    integer    complex
!     conjg                               complex
!     cos              real               complex
!     cosh             real               complex
!     exp              real               complex
!     floor            real    integer    complex
!     fraction         real               complex
!     int              real    integer    complex
!     log              real               complex
!     log10            real               complex
!     nint             real    integer    complex
!     sin              real               complex
!     sinh             real               complex
!     sqrt             real               complex
!     tan              real               complex
!     tanh             real               complex
!     cos_integral     real
!     cosh_integral    real
!     erf              real               complex
!     erfc             real               complex
!     erfc_scaled      real               complex
!     exp_integral_ei  real
!     factorial        real    integer    complex    machine-precision integer
!     fresnel_c        real
!     fresnel_s        real
!     gamma            real               complex
!     log_erfc         real
!     log_gamma        real               complex
!     log_integral     real
!     psi              real               complex
!     sin_integral     real
!     sinh_integral    real


   interface to_fm
      module procedure fm_i
      module procedure fm_r
      module procedure fm_d
      module procedure fm_z
      module procedure fm_zd
      module procedure fm_fm
      module procedure fm_im
      module procedure fm_zm
      module procedure fm_st
      module procedure fm_i1
      module procedure fm_r1
      module procedure fm_d1
      module procedure fm_z1
      module procedure fm_zd1
      module procedure fm_fm1
      module procedure fm_im1
      module procedure fm_zm1
      module procedure fm_st1
      module procedure fm_i2
      module procedure fm_r2
      module procedure fm_d2
      module procedure fm_z2
      module procedure fm_zd2
      module procedure fm_fm2
      module procedure fm_im2
      module procedure fm_zm2
      module procedure fm_st2
   end interface

   interface to_im
      module procedure im_i
      module procedure im_r
      module procedure im_d
      module procedure im_z
      module procedure im_c
      module procedure im_fm
      module procedure im_im
      module procedure im_zm
      module procedure im_st
      module procedure im_i1
      module procedure im_r1
      module procedure im_d1
      module procedure im_z1
      module procedure im_c1
      module procedure im_fm1
      module procedure im_im1
      module procedure im_zm1
      module procedure im_st1
      module procedure im_i2
      module procedure im_r2
      module procedure im_d2
      module procedure im_z2
      module procedure im_c2
      module procedure im_fm2
      module procedure im_im2
      module procedure im_zm2
      module procedure im_st2
   end interface

   interface to_zm
      module procedure zm_i
      module procedure zm2_i
      module procedure zm_r
      module procedure zm2_r
      module procedure zm_d
      module procedure zm2_d
      module procedure zm_z
      module procedure zm_c
      module procedure zm_fm
      module procedure zm_im
      module procedure zm_zm
      module procedure zm_st
      module procedure zm_i1
      module procedure zm_r1
      module procedure zm_d1
      module procedure zm_z1
      module procedure zm_c1
      module procedure zm_fm1
      module procedure zm_im1
      module procedure zm_zm1
      module procedure zm_st1
      module procedure zm_i2
      module procedure zm_r2
      module procedure zm_d2
      module procedure zm_z2
      module procedure zm_c2
      module procedure zm_fm2
      module procedure zm_im2
      module procedure zm_zm2
      module procedure zm_st2
   end interface

   interface to_int
      module procedure fm_2int
      module procedure im_2int
      module procedure zm_2int
      module procedure fm_2int1
      module procedure im_2int1
      module procedure zm_2int1
      module procedure fm_2int2
      module procedure im_2int2
      module procedure zm_2int2
   end interface

   interface to_sp
      module procedure fm_2sp
      module procedure im_2sp
      module procedure zm_2sp
      module procedure fm_2sp1
      module procedure im_2sp1
      module procedure zm_2sp1
      module procedure fm_2sp2
      module procedure im_2sp2
      module procedure zm_2sp2
   end interface

   interface to_dp
      module procedure fm_2dp
      module procedure im_2dp
      module procedure zm_2dp
      module procedure fm_2dp1
      module procedure im_2dp1
      module procedure zm_2dp1
      module procedure fm_2dp2
      module procedure im_2dp2
      module procedure zm_2dp2
   end interface

   interface to_spz
      module procedure fm_2spz
      module procedure im_2spz
      module procedure zm_2spz
      module procedure fm_2spz1
      module procedure im_2spz1
      module procedure zm_2spz1
      module procedure fm_2spz2
      module procedure im_2spz2
      module procedure zm_2spz2
   end interface

   interface to_dpz
      module procedure fm_2dpz
      module procedure im_2dpz
      module procedure zm_2dpz
      module procedure fm_2dpz1
      module procedure im_2dpz1
      module procedure zm_2dpz1
      module procedure fm_2dpz2
      module procedure im_2dpz2
      module procedure zm_2dpz2
   end interface

   interface is_overflow
      module procedure fm_is_overflow
      module procedure im_is_overflow
      module procedure zm_is_overflow
      module procedure fm_is_overflow1
      module procedure im_is_overflow1
      module procedure zm_is_overflow1
      module procedure fm_is_overflow2
      module procedure im_is_overflow2
      module procedure zm_is_overflow2
   end interface

   interface is_underflow
      module procedure fm_is_underflow
      module procedure im_is_underflow
      module procedure zm_is_underflow
      module procedure fm_is_underflow1
      module procedure im_is_underflow1
      module procedure zm_is_underflow1
      module procedure fm_is_underflow2
      module procedure im_is_underflow2
      module procedure zm_is_underflow2
   end interface

   interface is_unknown
      module procedure fm_is_unknown
      module procedure im_is_unknown
      module procedure zm_is_unknown
      module procedure fm_is_unknown1
      module procedure im_is_unknown1
      module procedure zm_is_unknown1
      module procedure fm_is_unknown2
      module procedure im_is_unknown2
      module procedure zm_is_unknown2
   end interface

   interface fm_undef_inp
      module procedure fm_undef_inp_fm0
      module procedure fm_undef_inp_im0
      module procedure fm_undef_inp_zm0
      module procedure fm_undef_inp_fm1
      module procedure fm_undef_inp_im1
      module procedure fm_undef_inp_zm1
      module procedure fm_undef_inp_fm2
      module procedure fm_undef_inp_im2
      module procedure fm_undef_inp_zm2
   end interface

!  The next function is no longer needed in version 1.4.
!  Dummy versions of the individual procedures are included for compatibility with version 1.3.

   interface fm_deallocate
      module procedure fm_deallocate_fm1
      module procedure fm_deallocate_im1
      module procedure fm_deallocate_zm1
      module procedure fm_deallocate_fm2
      module procedure fm_deallocate_im2
      module procedure fm_deallocate_zm2
   end interface


 contains

!                                                               to_fm

   function fm_i(ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      integer :: ival
      intent (in) :: ival
      type(fm_settings) :: qx
      call fmi2m(ival, return_value%mfm, qx)
   end function fm_i

   function fm_r(r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      real :: r
      intent (in) :: r
      type(fm_settings) :: qx
      call fmsp2m(r, return_value%mfm, qx)
   end function fm_r

   function fm_d(d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      double precision :: d
      intent (in) :: d
      type(fm_settings) :: qx
      call fmdp2m(d, return_value%mfm, qx)
   end function fm_d

   function fm_z(z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      complex :: z
      intent (in) :: z
      type(fm_settings) :: qx
      call fmsp2m(real(z), return_value%mfm, qx)
   end function fm_z

   function fm_zd(c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: c
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), return_value%mfm, qx)
   end function fm_zd

   function fm_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value, ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmeq(ma%mfm, return_value%mfm, qx)
   end function fm_fm

   function fm_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call imi2fm(ma%mim, return_value%mfm, qx)
   end function fm_im

   function fm_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (zm) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmreal(ma%mzm, return_value%mfm, qx)
   end function fm_zm

   function fm_st(st)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      character(*) :: st
      intent (in) :: st
      type(fm_settings) :: qx
      call fmst2m(st, return_value%mfm, qx)
   end function fm_st

   function fm_i1(ival)     result (return_value)
      use fmvals_parallel
      implicit none
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ival
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), return_value(j)%mfm, qx)
      enddo
   end function fm_i1

   function fm_r1(r)     result (return_value)
      use fmvals_parallel
      implicit none
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: r
      type(fm_settings) :: qx
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), return_value(j)%mfm, qx)
      enddo
   end function fm_r1

   function fm_d1(d)     result (return_value)
      use fmvals_parallel
      implicit none
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: d
      type(fm_settings) :: qx
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), return_value(j)%mfm, qx)
      enddo
   end function fm_d1

   function fm_z1(z)     result (return_value)
      use fmvals_parallel
      implicit none
      complex, dimension(:) :: z
      type (fm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: z
      type(fm_settings) :: qx
      n = size(z)
      do j = 1, n
         call fmsp2m(real(z(j)), return_value(j)%mfm, qx)
      enddo
   end function fm_z1

   function fm_zd1(c)     result (return_value)
      use fmvals_parallel
      implicit none
      complex (kind(0.0d0)), dimension(:) :: c
      type (fm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: c
      type(fm_settings) :: qx
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), return_value(j)%mfm, qx)
      enddo
   end function fm_zd1

   function fm_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmeq(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fm_fm1

   function fm_im1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, return_value(j)%mfm, qx)
      enddo
   end function fm_im1

   function fm_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmreal(ma(j)%mzm, return_value(j)%mfm, qx)
      enddo
   end function fm_zm1

   function fm_st1(st)     result (return_value)
      use fmvals_parallel
      implicit none
      character(*), dimension(:) :: st
      type (fm), dimension(size(st)) :: return_value
      integer :: j, n
      intent (in) :: st
      type(fm_settings) :: qx
      n = size(st)
      do j = 1, n
         call fmst2m(st(j), return_value(j)%mfm, qx)
      enddo
   end function fm_st1

   function fm_i2(ival)     result (return_value)
      use fmvals_parallel
      implicit none
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ival
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call fmi2m(ival(j, k), return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fm_i2

   function fm_r2(r)     result (return_value)
      use fmvals_parallel
      implicit none
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: r
      type(fm_settings) :: qx
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fm_r2

   function fm_d2(d)     result (return_value)
      use fmvals_parallel
      implicit none
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: d
      type(fm_settings) :: qx
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fm_d2

   function fm_z2(z)     result (return_value)
      use fmvals_parallel
      implicit none
      complex, dimension(:,:) :: z
      type (fm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: z
      type(fm_settings) :: qx
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call fmsp2m(real(z(j, k)), return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fm_z2

   function fm_zd2(c)     result (return_value)
      use fmvals_parallel
      implicit none
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (fm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: c
      type(fm_settings) :: qx
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fm_zd2

   function fm_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fm_fm2

   function fm_im2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fm_im2

   function fm_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmreal(ma(j, k)%mzm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fm_zm2

   function fm_st2(st)     result (return_value)
      use fmvals_parallel
      implicit none
      character(*), dimension(:,:) :: st
      type (fm), dimension(size(st, dim=1), size(st, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: st
      type(fm_settings) :: qx
      do j = 1, size(st, dim=1)
         do k = 1, size(st, dim=2)
            call fmst2m(st(j, k), return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fm_st2

!                                                               to_im

   function im_i(ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: return_value
      integer :: ival
      intent (in) :: ival
      type(fm_settings) :: qx
      call imi2m(ival, return_value%mim, qx)
   end function im_i

   function im_r(r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: return_value
      real :: r
      character(25) :: st
      integer :: ival
      intent (in) :: r
      type(fm_settings) :: qx
      if (abs(r) < huge(1)) then
          ival = int(r)
          call imi2m(ival, return_value%mim, qx)
      else
          write (st, '(E25.16)') r
          call imst2m(st, return_value%mim, qx)
      endif
   end function im_r

   function im_d(d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: return_value
      double precision :: d
      character(25) :: st
      integer :: ival
      intent (in) :: d
      type(fm_settings) :: qx
      if (abs(d) < huge(1)) then
          ival = int(d)
          call imi2m(ival, return_value%mim, qx)
      else
          write (st, '(E25.16)') d
          call imst2m(st, return_value%mim, qx)
      endif
   end function im_d

   function im_z(z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: return_value
      complex :: z
      real :: r
      character(25) :: st
      integer :: ival
      intent (in) :: z
      type(fm_settings) :: qx
      r = real(z)
      if (abs(r) < huge(1)) then
          ival = int(r)
          call imi2m(ival, return_value%mim, qx)
      else
          write (st, '(E25.16)') r
          call imst2m(st, return_value%mim, qx)
      endif
   end function im_z

   function im_c(c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: return_value
      complex (kind(0.0d0)) :: c
      double precision :: d
      character(25) :: st
      integer :: ival
      intent (in) :: c
      type(fm_settings) :: qx
      d = real(c, kind(0.0d0))
      if (abs(d) < huge(1)) then
          ival = int(d)
          call imi2m(ival, return_value%mim, qx)
      else
          write (st, '(E25.16)') d
          call imst2m(st, return_value%mim, qx)
      endif
   end function im_c

   function im_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: return_value
      type (fm) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call imfm2i(ma%mfm, return_value%mim, qx)
   end function im_fm

   function im_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: return_value, ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call imeq(ma%mim, return_value%mim, qx)
   end function im_im

   function im_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: return_value
      type (zm) :: ma
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call zmreal(ma%mzm, mtlvfm, qx)
      call imfm2i(mtlvfm, return_value%mim, qx)
   end function im_zm

   function im_st(st)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: return_value
      character(*) :: st
      intent (in) :: st
      type(fm_settings) :: qx
      call imst2m(st, return_value%mim, qx)
   end function im_st

   function im_i1(ival)     result (return_value)
      use fmvals_parallel
      implicit none
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ival
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), return_value(j)%mim, qx)
      enddo
   end function im_i1

   function im_r1(r)     result (return_value)
      use fmvals_parallel
      implicit none
      real, dimension(:) :: r
      type (im), dimension(size(r)) :: return_value
      character(25) :: st
      integer :: ival, j, n
      intent (in) :: r
      type(fm_settings) :: qx
      n = size(r)
      do j = 1, n
         if (abs(r(j)) < huge(1)) then
             ival = int(r(j))
             call imi2m(ival, return_value(j)%mim, qx)
         else
             write (st, '(E25.16)') r(j)
             call imst2m(st, return_value(j)%mim, qx)
         endif
      enddo
   end function im_r1

   function im_d1(d)     result (return_value)
      use fmvals_parallel
      implicit none
      double precision, dimension(:) :: d
      type (im), dimension(size(d)) :: return_value
      character(25) :: st
      integer :: ival, j, n
      intent (in) :: d
      type(fm_settings) :: qx
      n = size(d)
      do j = 1, n
         if (abs(d(j)) < huge(1)) then
             ival = int(d(j))
             call imi2m(ival, return_value(j)%mim, qx)
         else
             write (st, '(E25.16)') d(j)
             call imst2m(st, return_value(j)%mim, qx)
         endif
      enddo
   end function im_d1

   function im_z1(z)     result (return_value)
      use fmvals_parallel
      implicit none
      complex, dimension(:) :: z
      type (im), dimension(size(z)) :: return_value
      real :: r
      character(25) :: st
      integer :: ival, j, n
      intent (in) :: z
      type(fm_settings) :: qx
      n = size(z)
      do j = 1, n
         r = real(z(j))
         if (abs(r) < huge(1)) then
             ival = int(r)
             call imi2m(ival, return_value(j)%mim, qx)
         else
             write (st, '(E25.16)') r
             call imst2m(st, return_value(j)%mim, qx)
         endif
      enddo
   end function im_z1

   function im_c1(c)     result (return_value)
      use fmvals_parallel
      implicit none
      complex (kind(0.0d0)), dimension(:) :: c
      type (im), dimension(size(c)) :: return_value
      double precision :: d
      character(25) :: st
      integer :: ival, j, n
      intent (in) :: c
      type(fm_settings) :: qx
      n = size(c)
      do j = 1, n
         d = real(c(j), kind(0.0d0))
         if (abs(d) < huge(1)) then
             ival = int(d)
             call imi2m(ival, return_value(j)%mim, qx)
         else
             write (st, '(E25.16)') d
             call imst2m(st, return_value(j)%mim, qx)
         endif
      enddo
   end function im_c1

   function im_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call imfm2i(ma(j)%mfm, return_value(j)%mim, qx)
      enddo
   end function im_fm1

   function im_im1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call imeq(ma(j)%mim, return_value(j)%mim, qx)
      enddo
   end function im_im1

   function im_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmreal(ma(j)%mzm, mtlvfm, qx)
         call imfm2i(mtlvfm, return_value(j)%mim, qx)
      enddo
   end function im_zm1

   function im_st1(st)     result (return_value)
      use fmvals_parallel
      implicit none
      character(*), dimension(:) :: st
      type (im), dimension(size(st)) :: return_value
      integer :: j, n
      intent (in) :: st
      type(fm_settings) :: qx
      n = size(st)
      do j = 1, n
         call imst2m(st(j), return_value(j)%mim, qx)
      enddo
   end function im_st1

   function im_i2(ival)     result (return_value)
      use fmvals_parallel
      implicit none
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ival
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call imi2m(ival(j, k), return_value(j, k)%mim, qx)
         enddo
      enddo
   end function im_i2

   function im_r2(r)     result (return_value)
      use fmvals_parallel
      implicit none
      real, dimension(:,:) :: r
      type (im), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      character(25) :: st
      integer :: ival, j, k
      intent (in) :: r
      type(fm_settings) :: qx
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            if (abs(r(j, k)) < huge(1)) then
                ival = int(r(j, k))
                call imi2m(ival, return_value(j, k)%mim, qx)
            else
                write (st, '(E25.16)') r(j, k)
                call imst2m(st, return_value(j, k)%mim, qx)
            endif
         enddo
      enddo
   end function im_r2

   function im_d2(d)     result (return_value)
      use fmvals_parallel
      implicit none
      double precision, dimension(:,:) :: d
      type (im), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      character(25) :: st
      integer :: ival, j, k
      intent (in) :: d
      type(fm_settings) :: qx
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            if (abs(d(j, k)) < huge(1)) then
                ival = int(d(j, k))
                call imi2m(ival, return_value(j, k)%mim, qx)
            else
                write (st, '(E25.16)') d(j, k)
                call imst2m(st, return_value(j, k)%mim, qx)
            endif
         enddo
      enddo
   end function im_d2

   function im_z2(z)     result (return_value)
      use fmvals_parallel
      implicit none
      complex, dimension(:,:) :: z
      type (im), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      real :: r
      character(25) :: st
      integer :: ival, j, k
      intent (in) :: z
      type(fm_settings) :: qx
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            r = real(z(j, k))
            if (abs(r) < huge(1)) then
                ival = int(r)
                call imi2m(ival, return_value(j, k)%mim, qx)
            else
                write (st, '(E25.16)') r
                call imst2m(st, return_value(j, k)%mim, qx)
            endif
         enddo
      enddo
   end function im_z2

   function im_c2(c)     result (return_value)
      use fmvals_parallel
      implicit none
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (im), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      double precision :: d
      character(25) :: st
      integer :: ival, j, k
      intent (in) :: c
      type(fm_settings) :: qx
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            d = real(c(j, k), kind(0.0d0))
            if (abs(d) < huge(1)) then
                ival = int(d)
                call imi2m(ival, return_value(j, k)%mim, qx)
            else
                write (st, '(E25.16)') d
                call imst2m(st, return_value(j, k)%mim, qx)
            endif
         enddo
      enddo
   end function im_c2

   function im_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imfm2i(ma(j, k)%mfm, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function im_fm2

   function im_im2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(ma(j, k)%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function im_im2

   function im_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmreal(ma(j, k)%mzm, mtlvfm, qx)
            call imfm2i(mtlvfm, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function im_zm2

   function im_st2(st)     result (return_value)
      use fmvals_parallel
      implicit none
      character(*), dimension(:,:) :: st
      type (im), dimension(size(st, dim=1), size(st, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: st
      type(fm_settings) :: qx
      do j = 1, size(st, dim=1)
         do k = 1, size(st, dim=2)
            call imst2m(st(j, k), return_value(j, k)%mim, qx)
         enddo
      enddo
   end function im_st2

!                                                               to_zm

   function zm_i(ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      integer :: ival
      intent (in) :: ival
      type(fm_settings) :: qx
      call zmi2m(ival, return_value%mzm, qx)
   end function zm_i

   function zm2_i(i1, i2)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      integer :: i1, i2
      intent (in) :: i1, i2
      type(fm_settings) :: qx
      call zm2i2m(i1, i2, return_value%mzm, qx)
   end function zm2_i

   function zm_r(r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      real :: r
      intent (in) :: r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, return_value%mzm, qx)
   end function zm_r

   function zm2_r(r1, r2)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      real :: r1, r2
      intent (in) :: r1, r2
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmsp2m(r1, mtlvfm, qx)
      call fmsp2m(r2, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, return_value%mzm, qx)
   end function zm2_r

   function zm_d(d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      double precision :: d
      intent (in) :: d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, return_value%mzm, qx)
   end function zm_d

   function zm2_d(d1, d2)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      double precision :: d1, d2
      intent (in) :: d1, d2
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(d1, mtlvfm, qx)
      call fmdp2m(d2, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, return_value%mzm, qx)
   end function zm2_d

   function zm_z(z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      complex :: z
      intent (in) :: z
      type(fm_settings) :: qx
      call zmz2m(z, return_value%mzm, qx)
   end function zm_z

   function zm_c(c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: c
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, return_value%mzm, qx)
   end function zm_c

   function zm_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      intent (in) :: ma
      type(multi) :: mulvfm
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(ma%mfm, mulvfm, return_value%mzm, qx)
   end function zm_fm

   function zm_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      intent (in) :: ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, return_value%mzm, qx)
   end function zm_im

   function zm_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value, ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmeq(ma%mzm, return_value%mzm, qx)
   end function zm_zm

   function zm_st(st)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      character(*) :: st
      intent (in) :: st
      type(fm_settings) :: qx
      call zmst2m(st, return_value%mzm, qx)
   end function zm_st

   function zm_i1(ival)     result (return_value)
      use fmvals_parallel
      implicit none
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ival
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call zmi2m(ival(j), return_value(j)%mzm, qx)
      enddo
   end function zm_i1

   function zm_r1(r)     result (return_value)
      use fmvals_parallel
      implicit none
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      n = size(r)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, return_value(j)%mzm, qx)
      enddo
   end function zm_r1

   function zm_d1(d)     result (return_value)
      use fmvals_parallel
      implicit none
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      n = size(d)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, return_value(j)%mzm, qx)
      enddo
   end function zm_d1

   function zm_z1(z)     result (return_value)
      use fmvals_parallel
      implicit none
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: z
      type(fm_settings) :: qx
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), return_value(j)%mzm, qx)
      enddo
   end function zm_z1

   function zm_c1(c)     result (return_value)
      use fmvals_parallel
      implicit none
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: c
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, return_value(j)%mzm, qx)
      enddo
   end function zm_c1

   function zm_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(multi) :: mulvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, return_value(j)%mzm, qx)
      enddo
   end function zm_fm1

   function zm_im1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, return_value(j)%mzm, qx)
      enddo
   end function zm_im1

   function zm_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmeq(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function zm_zm1

   function zm_st1(st)     result (return_value)
      use fmvals_parallel
      implicit none
      character(*), dimension(:) :: st
      type (zm), dimension(size(st)) :: return_value
      integer :: j, n
      intent (in) :: st
      type(fm_settings) :: qx
      n = size(st)
      do j = 1, n
         call zmst2m(st(j), return_value(j)%mzm, qx)
      enddo
   end function zm_st1

   function zm_i2(ival)     result (return_value)
      use fmvals_parallel
      implicit none
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ival
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call zmi2m(ival(j, k), return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function zm_i2

   function zm_r2(r)     result (return_value)
      use fmvals_parallel
      implicit none
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function zm_r2

   function zm_d2(d)     result (return_value)
      use fmvals_parallel
      implicit none
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function zm_d2

   function zm_z2(z)     result (return_value)
      use fmvals_parallel
      implicit none
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: z
      type(fm_settings) :: qx
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function zm_z2

   function zm_c2(c)     result (return_value)
      use fmvals_parallel
      implicit none
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: c
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function zm_c2

   function zm_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(multi) :: mulvfm
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function zm_fm2

   function zm_im2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function zm_im2

   function zm_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function zm_zm2

   function zm_st2(st)     result (return_value)
      use fmvals_parallel
      implicit none
      character(*), dimension(:,:) :: st
      type (zm), dimension(size(st, dim=1), size(st, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: st
      type(fm_settings) :: qx
      do j = 1, size(st, dim=1)
         do k = 1, size(st, dim=2)
            call zmst2m(st(j, k), return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function zm_st2

!                                                              to_int

   function fm_2int(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmm2i(ma%mfm, return_value, qx)
   end function fm_2int

   function im_2int(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call imm2i(ma%mim, return_value, qx)
   end function im_2int

   function zm_2int(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmm2i(ma%mzm, return_value, qx)
   end function zm_2int

   function fm_2int1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      integer, dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmm2i(ma(j)%mfm, return_value(j), qx)
      enddo
   end function fm_2int1

   function im_2int1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      integer, dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call imm2i(ma(j)%mim, return_value(j), qx)
      enddo
   end function im_2int1

   function zm_2int1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      integer, dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmm2i(ma(j)%mzm(1), return_value(j), qx)
      enddo
   end function zm_2int1

   function fm_2int2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      integer, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2i(ma(j, k)%mfm, return_value(j, k), qx)
         enddo
      enddo
   end function fm_2int2

   function im_2int2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      integer, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imm2i(ma(j, k)%mim, return_value(j, k), qx)
         enddo
      enddo
   end function im_2int2

   function zm_2int2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      integer, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2i(ma(j, k)%mzm(1), return_value(j, k), qx)
         enddo
      enddo
   end function zm_2int2

!                                                               to_sp

   function fm_2sp(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      real :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmm2sp(ma%mfm, return_value, qx)
   end function fm_2sp

   function im_2sp(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      real :: return_value
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmm2sp(mtlvfm, return_value, qx)
   end function im_2sp

   function zm_2sp(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      real :: return_value
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call zmreal(ma%mzm, mtlvfm, qx)
      call fmm2sp(mtlvfm, return_value, qx)
   end function zm_2sp

   function fm_2sp1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      real, dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmm2sp(ma(j)%mfm, return_value(j), qx)
      enddo
   end function fm_2sp1

   function im_2sp1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      real, dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call imm2sp(ma(j)%mim, return_value(j), qx)
      enddo
   end function im_2sp1

   function zm_2sp1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      real, dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmm2sp(ma(j)%mzm(1), return_value(j), qx)
      enddo
   end function zm_2sp1

   function fm_2sp2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      real, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2sp(ma(j, k)%mfm, return_value(j, k), qx)
         enddo
      enddo
   end function fm_2sp2

   function im_2sp2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      real, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imm2sp(ma(j, k)%mim, return_value(j, k), qx)
         enddo
      enddo
   end function im_2sp2

   function zm_2sp2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      real, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2sp(ma(j, k)%mzm(1), return_value(j, k), qx)
         enddo
      enddo
   end function zm_2sp2

!                                                               to_dp

   function fm_2dp(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      double precision :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmm2dp(ma%mfm, return_value, qx)
   end function fm_2dp

   function im_2dp(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      double precision :: return_value
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmm2dp(mtlvfm, return_value, qx)
   end function im_2dp

   function zm_2dp(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      double precision :: return_value
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call zmreal(ma%mzm, mtlvfm, qx)
      call fmm2dp(mtlvfm, return_value, qx)
   end function zm_2dp

   function fm_2dp1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      double precision, dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmm2dp(ma(j)%mfm, return_value(j), qx)
      enddo
   end function fm_2dp1

   function im_2dp1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      double precision, dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call imm2dp(ma(j)%mim, return_value(j), qx)
      enddo
   end function im_2dp1

   function zm_2dp1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      double precision, dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmm2dp(ma(j)%mzm(1), return_value(j), qx)
      enddo
   end function zm_2dp1

   function fm_2dp2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      double precision, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2dp(ma(j, k)%mfm, return_value(j, k), qx)
         enddo
      enddo
   end function fm_2dp2

   function im_2dp2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      double precision, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imm2dp(ma(j, k)%mim, return_value(j, k), qx)
         enddo
      enddo
   end function im_2dp2

   function zm_2dp2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      double precision, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2dp(ma(j, k)%mzm(1), return_value(j, k), qx)
         enddo
      enddo
   end function zm_2dp2

!                                                              to_spz

   function fm_2spz(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex :: return_value
      real :: r
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmm2sp(ma%mfm, r, qx)
      return_value = cmplx( r , 0.0 )
   end function fm_2spz

   function im_2spz(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex :: return_value
      real :: r
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmm2sp(mtlvfm, r, qx)
      return_value = cmplx( r , 0.0 )
   end function im_2spz

   function zm_2spz(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmm2z(ma%mzm, return_value, qx)
   end function zm_2spz

   function fm_2spz1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      complex, dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmm2sp(ma(j)%mfm, r, qx)
         return_value(j) = cmplx( r , 0.0 )
      enddo
   end function fm_2spz1

   function im_2spz1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      complex, dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call fmm2sp(mtlvfm, r, qx)
         return_value(j) = cmplx( r , 0.0 )
      enddo
   end function im_2spz1

   function zm_2spz1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      complex, dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmm2z(ma(j)%mzm, return_value(j), qx)
      enddo
   end function zm_2spz1

   function fm_2spz2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      complex, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2sp(ma(j, k)%mfm, r, qx)
            return_value(j, k) = cmplx( r , 0.0 )
         enddo
      enddo
   end function fm_2spz2

   function im_2spz2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      complex, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call fmm2sp(mtlvfm, r, qx)
            return_value(j, k) = cmplx( r , 0.0 )
         enddo
      enddo
   end function im_2spz2

   function zm_2spz2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      complex, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmm2z(ma(j, k)%mzm, return_value(j, k), qx)
         enddo
      enddo
   end function zm_2spz2

!                                                              to_dpz

   function fm_2dpz(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)) :: return_value
      double precision :: d
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmm2dp(ma%mfm, d, qx)
      return_value = cmplx( d , 0.0d0 , kind(0.0d0) )
   end function fm_2dpz

   function im_2dpz(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)) :: return_value
      double precision :: d
      intent (in) :: ma
      type(fm_settings) :: qx
      call imm2dp(ma%mim, d, qx)
      return_value = cmplx( d , 0.0d0 , kind(0.0d0) )
   end function im_2dpz

   function zm_2dpz(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)) :: return_value
      double precision :: d1, d2
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call zmreal(ma%mzm, mtlvfm, qx)
      call fmm2dp(mtlvfm, d1, qx)
      call zmimag(ma%mzm, mtlvfm, qx)
      call fmm2dp(mtlvfm, d2, qx)
      return_value = cmplx( d1 , d2 , kind(0.0d0) )
   end function zm_2dpz

   function fm_2dpz1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmm2dp(ma(j)%mfm, d, qx)
         return_value(j) = cmplx( d , 0.0d0 , kind(0.0d0) )
      enddo
   end function fm_2dpz1

   function im_2dpz1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call fmm2dp(mtlvfm, d, qx)
         return_value(j) = cmplx( d , 0.0d0 , kind(0.0d0) )
      enddo
   end function im_2dpz1

   function zm_2dpz1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d1, d2
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmreal(ma(j)%mzm, mtlvfm, qx)
         call fmm2dp(mtlvfm, d1, qx)
         call zmimag(ma(j)%mzm, mtlvfm, qx)
         call fmm2dp(mtlvfm, d2, qx)
         return_value(j) = cmplx( d1 , d2 , kind(0.0d0) )
      enddo
   end function zm_2dpz1

   function fm_2dpz2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2dp(ma(j, k)%mfm, d, qx)
            return_value(j, k) = cmplx( d , 0.0d0 , kind(0.0d0) )
         enddo
      enddo
   end function fm_2dpz2

   function im_2dpz2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call fmm2dp(mtlvfm, d, qx)
            return_value(j, k) = cmplx( d , 0.0d0 , kind(0.0d0) )
         enddo
      enddo
   end function im_2dpz2

   function zm_2dpz2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d1, d2
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmreal(ma(j, k)%mzm, mtlvfm, qx)
            call fmm2dp(mtlvfm, d1, qx)
            call zmimag(ma(j, k)%mzm, mtlvfm, qx)
            call fmm2dp(mtlvfm, d2, qx)
            return_value(j, k) = cmplx( d1 , d2 , kind(0.0d0) )
         enddo
      enddo
   end function zm_2dpz2

   subroutine fm_eq(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmeq(ma%mfm, mb%mfm, qx)
   end subroutine fm_eq

   subroutine im_eq(ma, mb)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call imeq(ma%mim, mb%mim, qx)
   end subroutine im_eq

   subroutine zm_eq(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmeq(ma%mzm, mb%mzm, qx)
   end subroutine zm_eq

!                                                         is_overflow

   function fm_is_overflow(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      logical :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = .false.
      if (ma%mfm%mp(2) == qx%mexpov) return_value = .true.
   end function fm_is_overflow

   function im_is_overflow(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      logical :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = .false.
      if (ma%mim%mp(2) == qx%mexpov) return_value = .true.
   end function im_is_overflow

   function zm_is_overflow(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      logical :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = .false.
      if (ma%mzm(1)%mp(2) == qx%mexpov) return_value = .true.
      if (ma%mzm(2)%mp(2) == qx%mexpov) return_value = .true.
   end function zm_is_overflow

   function fm_is_overflow1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      logical :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      return_value = .false.
      do j = 1, n
         if (ma(j)%mfm%mp(2) == qx%mexpov) return_value = .true.
      enddo
   end function fm_is_overflow1

   function im_is_overflow1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      logical :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      return_value = .false.
      do j = 1, n
         if (ma(j)%mim%mp(2) == qx%mexpov) return_value = .true.
      enddo
   end function im_is_overflow1

   function zm_is_overflow1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      logical :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      return_value = .false.
      do j = 1, n
         if (ma(j)%mzm(1)%mp(2) == qx%mexpov) return_value = .true.
         if (ma(j)%mzm(2)%mp(2) == qx%mexpov) return_value = .true.
      enddo
   end function zm_is_overflow1

   function fm_is_overflow2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      logical :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = .false.
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (ma(j, k)%mfm%mp(2) == qx%mexpov) return_value = .true.
         enddo
      enddo
   end function fm_is_overflow2

   function im_is_overflow2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      logical :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = .false.
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (ma(j, k)%mim%mp(2) == qx%mexpov) return_value = .true.
         enddo
      enddo
   end function im_is_overflow2

   function zm_is_overflow2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      logical :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = .false.
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (ma(j, k)%mzm(1)%mp(2) == qx%mexpov) return_value = .true.
            if (ma(j, k)%mzm(2)%mp(2) == qx%mexpov) return_value = .true.
         enddo
      enddo
   end function zm_is_overflow2

!                                                        is_underflow

   function fm_is_underflow(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      logical :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = .false.
      if (ma%mfm%mp(2) == qx%mexpun) return_value = .true.
   end function fm_is_underflow

!  The integer versions are included for completeness, but type (im) numbers can't underflow.

   function im_is_underflow(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      logical :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = .false.
      if (ma%mim%mp(2) == qx%mexpun) return_value = .true.
   end function im_is_underflow

   function zm_is_underflow(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      logical :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = .false.
      if (ma%mzm(1)%mp(2) == qx%mexpun) return_value = .true.
      if (ma%mzm(2)%mp(2) == qx%mexpun) return_value = .true.
   end function zm_is_underflow

   function fm_is_underflow1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      logical :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      return_value = .false.
      do j = 1, n
         if (ma(j)%mfm%mp(2) == qx%mexpun) return_value = .true.
      enddo
   end function fm_is_underflow1

   function im_is_underflow1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      logical :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      return_value = .false.
      do j = 1, n
         if (ma(j)%mim%mp(2) == qx%mexpun) return_value = .true.
      enddo
   end function im_is_underflow1

   function zm_is_underflow1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      logical :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      return_value = .false.
      do j = 1, n
         if (ma(j)%mzm(1)%mp(2) == qx%mexpun) return_value = .true.
         if (ma(j)%mzm(2)%mp(2) == qx%mexpun) return_value = .true.
      enddo
   end function zm_is_underflow1

   function fm_is_underflow2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      logical :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = .false.
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (ma(j, k)%mfm%mp(2) == qx%mexpun) return_value = .true.
         enddo
      enddo
   end function fm_is_underflow2

   function im_is_underflow2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      logical :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = .false.
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (ma(j, k)%mim%mp(2) == qx%mexpun) return_value = .true.
         enddo
      enddo
   end function im_is_underflow2

   function zm_is_underflow2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      logical :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = .false.
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (ma(j, k)%mzm(1)%mp(2) == qx%mexpun) return_value = .true.
            if (ma(j, k)%mzm(2)%mp(2) == qx%mexpun) return_value = .true.
         enddo
      enddo
   end function zm_is_underflow2

!                                                          is_unknown

   function fm_is_unknown(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      logical :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = .false.
      if (ma%mfm%mp(2) == qx%munkno) return_value = .true.
   end function fm_is_unknown

   function im_is_unknown(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      logical :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = .false.
      if (ma%mim%mp(2) == qx%munkno) return_value = .true.
   end function im_is_unknown

   function zm_is_unknown(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      logical :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = .false.
      if (ma%mzm(1)%mp(2) == qx%munkno) return_value = .true.
      if (ma%mzm(2)%mp(2) == qx%munkno) return_value = .true.
   end function zm_is_unknown

   function fm_is_unknown1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      logical :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      return_value = .false.
      do j = 1, n
         if (ma(j)%mfm%mp(2) == qx%munkno) return_value = .true.
      enddo
   end function fm_is_unknown1

   function im_is_unknown1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      logical :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      return_value = .false.
      do j = 1, n
         if (ma(j)%mim%mp(2) == qx%munkno) return_value = .true.
      enddo
   end function im_is_unknown1

   function zm_is_unknown1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      logical :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      return_value = .false.
      do j = 1, n
         if (ma(j)%mzm(1)%mp(2) == qx%munkno) return_value = .true.
         if (ma(j)%mzm(2)%mp(2) == qx%munkno) return_value = .true.
      enddo
   end function zm_is_unknown1

   function fm_is_unknown2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      logical :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = .false.
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (ma(j, k)%mfm%mp(2) == qx%munkno) return_value = .true.
         enddo
      enddo
   end function fm_is_unknown2

   function im_is_unknown2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      logical :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = .false.
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (ma(j, k)%mim%mp(2) == qx%munkno) return_value = .true.
         enddo
      enddo
   end function im_is_unknown2

   function zm_is_unknown2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      logical :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = .false.
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (ma(j, k)%mzm(1)%mp(2) == qx%munkno) return_value = .true.
            if (ma(j, k)%mzm(2)%mp(2) == qx%munkno) return_value = .true.
         enddo
      enddo
   end function zm_is_unknown2

   subroutine fm_undef_inp_fm0(ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      if (.not. allocated(ma%mfm%mp)) call fm_input_error(qx)
   end subroutine fm_undef_inp_fm0

   subroutine fm_undef_inp_im0(ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      if (.not. allocated(ma%mim%mp)) call fm_input_error(qx)
   end subroutine fm_undef_inp_im0

   subroutine fm_undef_inp_zm0(ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      if (.not. allocated(ma%mzm(1)%mp)) call fm_input_error(qx)
      if (.not. allocated(ma%mzm(2)%mp)) call fm_input_error(qx)
   end subroutine fm_undef_inp_zm0

   subroutine fm_undef_inp_fm1(ma)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      integer :: j
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma)
         if (.not. allocated(ma(j)%mfm%mp)) call fm_input_error1(j, qx)
      enddo
   end subroutine fm_undef_inp_fm1

   subroutine fm_undef_inp_im1(ma)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      integer :: j
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma)
         if (.not. allocated(ma(j)%mim%mp)) call fm_input_error1(j, qx)
      enddo
   end subroutine fm_undef_inp_im1

   subroutine fm_undef_inp_zm1(ma)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      integer :: j
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma)
         if (.not. allocated(ma(j)%mzm(1)%mp)) call fm_input_error1(j, qx)
         if (.not. allocated(ma(j)%mzm(2)%mp)) call fm_input_error1(j, qx)
      enddo
   end subroutine fm_undef_inp_zm1

   subroutine fm_undef_inp_fm2(ma)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (.not. allocated(ma(j, k)%mfm%mp)) call fm_input_error2(j, k, qx)
         enddo
      enddo
   end subroutine fm_undef_inp_fm2

   subroutine fm_undef_inp_im2(ma)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (.not. allocated(ma(j, k)%mim%mp)) call fm_input_error2(j, k, qx)
         enddo
      enddo
   end subroutine fm_undef_inp_im2

   subroutine fm_undef_inp_zm2(ma)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (.not. allocated(ma(j, k)%mzm(1)%mp)) call fm_input_error2(j, k, qx)
            if (.not. allocated(ma(j, k)%mzm(2)%mp)) call fm_input_error2(j, k, qx)
         enddo
      enddo
   end subroutine fm_undef_inp_zm2

   subroutine fm_deallocate_fm1(ma)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx
      if (size(ma) < 0 .and. qx%ndig < 0) write (*,*) ' Invalid NDIG = ', qx%ndig
   end subroutine fm_deallocate_fm1

   subroutine fm_deallocate_im1(ma)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx
      if (size(ma) < 0 .and. qx%ndig < 0) write (*,*) ' Invalid NDIG = ', qx%ndig
   end subroutine fm_deallocate_im1

   subroutine fm_deallocate_zm1(ma)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx
      if (size(ma) < 0 .and. qx%ndig < 0) write (*,*) ' Invalid NDIG = ', qx%ndig
   end subroutine fm_deallocate_zm1

   subroutine fm_deallocate_fm2(ma)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx
      if (size(ma) < 0 .and. qx%ndig < 0) write (*,*) ' Invalid NDIG = ', qx%ndig
   end subroutine fm_deallocate_fm2

   subroutine fm_deallocate_im2(ma)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx
      if (size(ma) < 0 .and. qx%ndig < 0) write (*,*) ' Invalid NDIG = ', qx%ndig
   end subroutine fm_deallocate_im2

   subroutine fm_deallocate_zm2(ma)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx
      if (size(ma) < 0 .and. qx%ndig < 0) write (*,*) ' Invalid NDIG = ', qx%ndig
   end subroutine fm_deallocate_zm2

   subroutine fm_input_error(qx)
      use fmvals_parallel
      implicit none
      integer :: err(2) = (/ 22, 23 /)
      type(fm_settings) :: qx
      write (*,*) ' '
      write (*,*) ' '
      write (*,*) ' ***  Error in a program using the FM package  ***'
      write (*,*) ' '
      write (*,*) ' A multiple precision number is undefined in an expression or as an input'
      write (*,*) ' argument to a subprogram.'
      write (*,*) ' '
      write (*,*) ' The most common causes of this error are:'
      write (*,*) "     1. A multiple-precision variable (type(fm), (im), (zm), etc.) appears in an"
      write (*,*) "        expression in the user's program before it has been given a value."
      write (*,*) "     2. The user's program raises precision (ndig) and later tries to use a"
      write (*,*) "        variable previously defined at a lower precision."
      write (*,*) "        Call fm_equ or fm_equ_r1 to increase the size of type(fm) variables"
      write (*,*) "        after increasing precision, zm_equ for type(zm) variables, etc."
      write (*,*) ' '
      write (*,*) ' To help isolate the code that caused this error, this error message is followed'
      write (*,*) ' by an illegal out-of-range array reference.  Some compilers have an option for'
      write (*,*) ' checking array bounds and will give a traceback with the line number in the'
      write (*,*) ' calling program where the error originated.'
      write (*,*) ' '
      write (*,*) ' The program has been stopped.'
      write (*,*) ' '
      if (err(-qx%ndig) > 22) write (*,*) ' Negative array subscript.'
      stop
   end subroutine fm_input_error

   subroutine fm_input_error1(j, qx)
      use fmvals_parallel
      implicit none
      integer :: j
      integer :: err(2) = (/ 22, 23 /)
      intent (in) :: j
      type(fm_settings) :: qx
      write (*,*) ' '
      write (*,*) ' '
      write (*,*) ' ***  Error in a program using the FM package  ***'
      write (*,*) ' '
      write (*,*) ' Element (', j, ') of a multiple precision one-dimensional array'
      write (*,*) ' is undefined in an expression.'
      write (*,*) ' '
      write (*,*) ' Note that if an array section is being used, like A(6:10), then if A(7) is'
      write (*,*) ' undefined it will be listed as element (2) here.'
      write (*,*) ' '
      write (*,*) ' The most common causes of this error are:'
      write (*,*) "     1. A multiple-precision variable (type(fm), (im), (zm), etc.) appears in an"
      write (*,*) "        expression in the user's program before it has been given a value."
      write (*,*) "     2. The user's program raises precision (ndig) and later tries to use a"
      write (*,*) "        variable previously defined at a lower precision."
      write (*,*) "        Call fm_equ or fm_equ_r1 to increase the size of type(fm) variables"
      write (*,*) "        after increasing precision, zm_equ for type(zm) variables, etc."
      write (*,*) ' '
      write (*,*) ' To help isolate the code that caused this error, this error message is followed'
      write (*,*) ' by an illegal out-of-range array reference.  Some compilers have an option for'
      write (*,*) ' checking array bounds and will give a traceback with the line number in the'
      write (*,*) ' calling program where the error originated.'
      write (*,*) ' '
      write (*,*) ' The program has been stopped.'
      write (*,*) ' '
      if (err(-qx%ndig) > 22) write (*,*) ' Negative array subscript.'
      stop
   end subroutine fm_input_error1

   subroutine fm_input_error2(j, k, qx)
      use fmvals_parallel
      implicit none
      integer :: j, k
      integer :: err(2) = (/ 22, 23 /)
      intent (in) :: j, k
      type(fm_settings) :: qx
      write (*,*) ' '
      write (*,*) ' '
      write (*,*) ' ***  Error in a program using the FM package  ***'
      write (*,*) ' '
      write (*,*) ' Element (', j, ', ', k, ') of a multiple precision two-dimensional array'
      write (*,*) ' is undefined in an expression.'
      write (*,*) ' '
      write (*,*) ' Note that if an array section is being used, like A(6:10), then if A(7) is'
      write (*,*) ' undefined it will be listed as element (2) here.'
      write (*,*) ' '
      write (*,*) ' The most common causes of this error are:'
      write (*,*) "     1. A multiple-precision variable (type(fm), (im), (zm), etc.) appears in an"
      write (*,*) "        expression in the user's program before it has been given a value."
      write (*,*) "     2. The user's program raises precision (ndig) and later tries to use a"
      write (*,*) "        variable previously defined at a lower precision."
      write (*,*) "        Call fm_equ or fm_equ_r1 to increase the size of type(fm) variables"
      write (*,*) "        after increasing precision, zm_equ for type(zm) variables, etc."
      write (*,*) ' '
      write (*,*) ' To help isolate the code that caused this error, this error message is followed'
      write (*,*) ' by an illegal out-of-range array reference.  Some compilers have an option for'
      write (*,*) ' checking array bounds and will give a traceback with the line number in the'
      write (*,*) ' calling program where the error originated.'
      write (*,*) ' '
      write (*,*) ' The program has been stopped.'
      write (*,*) ' '
      if (err(-qx%ndig) > 22) write (*,*) ' Negative array subscript.'
      stop
   end subroutine fm_input_error2

 end module fmzm_1_parallel

 module fmzm_2_parallel
    use fmzm_1_parallel

!   These abbreviations are used for operations on the various data types.

!   i    Integer
!   r    Real
!   d    Double Precision
!   z    Complex
!   c    Complex Double Precision
!   fm   Multiple precision real
!   im   Multiple precision integer
!   zm   Multiple precision complex

!   For example, the "=" procedure fmeq_fmd is for statements like x = a, where x is type FM
!   and a is type Double Precision.

!   Digits refer to the number of dimensions (rank) for an array.
!   fmeq_fm1r handles statements like a = 1.0, where a is a 1-dimensional array of type FM and the
!   right side (1.0) is real.  Like the ordinary Fortran array syntax, this sets all the elements
!   of array a to 1.0.

    interface assignment (=)
       module procedure fmeq_ifm
       module procedure fmeq_iim
       module procedure fmeq_izm
       module procedure fmeq_rfm
       module procedure fmeq_rim
       module procedure fmeq_rzm
       module procedure fmeq_dfm
       module procedure fmeq_dim
       module procedure fmeq_dzm
       module procedure fmeq_zfm
       module procedure fmeq_zim
       module procedure fmeq_zzm
       module procedure fmeq_cfm
       module procedure fmeq_cim
       module procedure fmeq_czm
       module procedure fmeq_fmi
       module procedure fmeq_fmr
       module procedure fmeq_fmd
       module procedure fmeq_fmz
       module procedure fmeq_fmc
       module procedure fmeq_fmfm
       module procedure fmeq_fmim
       module procedure fmeq_fmzm
       module procedure fmeq_imi
       module procedure fmeq_imr
       module procedure fmeq_imd
       module procedure fmeq_imz
       module procedure fmeq_imc
       module procedure fmeq_imfm
       module procedure fmeq_imim
       module procedure fmeq_imzm
       module procedure fmeq_zmi
       module procedure fmeq_zmr
       module procedure fmeq_zmd
       module procedure fmeq_zmz
       module procedure fmeq_zmc
       module procedure fmeq_zmfm
       module procedure fmeq_zmim
       module procedure fmeq_zmzm
       module procedure fmeq_fm1i
       module procedure fmeq_fm1r
       module procedure fmeq_fm1d
       module procedure fmeq_fm1z
       module procedure fmeq_fm1c
       module procedure fmeq_i1fm
       module procedure fmeq_r1fm
       module procedure fmeq_d1fm
       module procedure fmeq_z1fm
       module procedure fmeq_c1fm
       module procedure fmeq_fm1fm
       module procedure fmeq_fm1im
       module procedure fmeq_fm1zm
       module procedure fmeq_im1fm
       module procedure fmeq_zm1fm
       module procedure fmeq_fm1i1
       module procedure fmeq_fm1r1
       module procedure fmeq_fm1d1
       module procedure fmeq_fm1z1
       module procedure fmeq_fm1c1
       module procedure fmeq_i1fm1
       module procedure fmeq_r1fm1
       module procedure fmeq_d1fm1
       module procedure fmeq_z1fm1
       module procedure fmeq_c1fm1
       module procedure fmeq_fm1fm1
       module procedure fmeq_fm1im1
       module procedure fmeq_fm1zm1
       module procedure fmeq_im1fm1
       module procedure fmeq_zm1fm1
       module procedure fmeq_im1i
       module procedure fmeq_im1r
       module procedure fmeq_im1d
       module procedure fmeq_im1z
       module procedure fmeq_im1c
       module procedure fmeq_i1im
       module procedure fmeq_r1im
       module procedure fmeq_d1im
       module procedure fmeq_z1im
       module procedure fmeq_c1im
       module procedure fmeq_im1im
       module procedure fmeq_im1zm
       module procedure fmeq_zm1im
       module procedure fmeq_im1i1
       module procedure fmeq_im1r1
       module procedure fmeq_im1d1
       module procedure fmeq_im1z1
       module procedure fmeq_im1c1
       module procedure fmeq_i1im1
       module procedure fmeq_r1im1
       module procedure fmeq_d1im1
       module procedure fmeq_z1im1
       module procedure fmeq_c1im1
       module procedure fmeq_im1im1
       module procedure fmeq_im1zm1
       module procedure fmeq_zm1im1
       module procedure fmeq_zm1i
       module procedure fmeq_zm1r
       module procedure fmeq_zm1d
       module procedure fmeq_zm1z
       module procedure fmeq_zm1c
       module procedure fmeq_i1zm
       module procedure fmeq_r1zm
       module procedure fmeq_d1zm
       module procedure fmeq_z1zm
       module procedure fmeq_c1zm
       module procedure fmeq_zm1zm
       module procedure fmeq_zm1i1
       module procedure fmeq_zm1r1
       module procedure fmeq_zm1d1
       module procedure fmeq_zm1z1
       module procedure fmeq_zm1c1
       module procedure fmeq_i1zm1
       module procedure fmeq_r1zm1
       module procedure fmeq_d1zm1
       module procedure fmeq_z1zm1
       module procedure fmeq_c1zm1
       module procedure fmeq_zm1zm1
       module procedure fmeq_fm2i
       module procedure fmeq_fm2r
       module procedure fmeq_fm2d
       module procedure fmeq_fm2z
       module procedure fmeq_fm2c
       module procedure fmeq_i2fm
       module procedure fmeq_r2fm
       module procedure fmeq_d2fm
       module procedure fmeq_z2fm
       module procedure fmeq_c2fm
       module procedure fmeq_fm2fm
       module procedure fmeq_fm2im
       module procedure fmeq_fm2zm
       module procedure fmeq_im2fm
       module procedure fmeq_zm2fm
       module procedure fmeq_fm2i2
       module procedure fmeq_fm2r2
       module procedure fmeq_fm2d2
       module procedure fmeq_fm2z2
       module procedure fmeq_fm2c2
       module procedure fmeq_i2fm2
       module procedure fmeq_r2fm2
       module procedure fmeq_d2fm2
       module procedure fmeq_z2fm2
       module procedure fmeq_c2fm2
       module procedure fmeq_fm2fm2
       module procedure fmeq_fm2im2
       module procedure fmeq_fm2zm2
       module procedure fmeq_im2fm2
       module procedure fmeq_zm2fm2
       module procedure fmeq_im2i
       module procedure fmeq_im2r
       module procedure fmeq_im2d
       module procedure fmeq_im2z
       module procedure fmeq_im2c
       module procedure fmeq_i2im
       module procedure fmeq_r2im
       module procedure fmeq_d2im
       module procedure fmeq_z2im
       module procedure fmeq_c2im
       module procedure fmeq_im2im
       module procedure fmeq_im2zm
       module procedure fmeq_zm2im
       module procedure fmeq_im2i2
       module procedure fmeq_im2r2
       module procedure fmeq_im2d2
       module procedure fmeq_im2z2
       module procedure fmeq_im2c2
       module procedure fmeq_i2im2
       module procedure fmeq_r2im2
       module procedure fmeq_d2im2
       module procedure fmeq_z2im2
       module procedure fmeq_c2im2
       module procedure fmeq_im2im2
       module procedure fmeq_im2zm2
       module procedure fmeq_zm2im2
       module procedure fmeq_zm2i
       module procedure fmeq_zm2r
       module procedure fmeq_zm2d
       module procedure fmeq_zm2z
       module procedure fmeq_zm2c
       module procedure fmeq_i2zm
       module procedure fmeq_r2zm
       module procedure fmeq_d2zm
       module procedure fmeq_z2zm
       module procedure fmeq_c2zm
       module procedure fmeq_zm2zm
       module procedure fmeq_zm2i2
       module procedure fmeq_zm2r2
       module procedure fmeq_zm2d2
       module procedure fmeq_zm2z2
       module procedure fmeq_zm2c2
       module procedure fmeq_i2zm2
       module procedure fmeq_r2zm2
       module procedure fmeq_d2zm2
       module procedure fmeq_z2zm2
       module procedure fmeq_c2zm2
       module procedure fmeq_zm2zm2
    end interface

    interface operator (==)
       module procedure fmleq_ifm
       module procedure fmleq_iim
       module procedure fmleq_izm
       module procedure fmleq_rfm
       module procedure fmleq_rim
       module procedure fmleq_rzm
       module procedure fmleq_dfm
       module procedure fmleq_dim
       module procedure fmleq_dzm
       module procedure fmleq_zfm
       module procedure fmleq_zim
       module procedure fmleq_zzm
       module procedure fmleq_cfm
       module procedure fmleq_cim
       module procedure fmleq_czm
       module procedure fmleq_fmi
       module procedure fmleq_fmr
       module procedure fmleq_fmd
       module procedure fmleq_fmz
       module procedure fmleq_fmc
       module procedure fmleq_fmfm
       module procedure fmleq_fmim
       module procedure fmleq_fmzm
       module procedure fmleq_imi
       module procedure fmleq_imr
       module procedure fmleq_imd
       module procedure fmleq_imz
       module procedure fmleq_imc
       module procedure fmleq_imfm
       module procedure fmleq_imim
       module procedure fmleq_imzm
       module procedure fmleq_zmi
       module procedure fmleq_zmr
       module procedure fmleq_zmd
       module procedure fmleq_zmz
       module procedure fmleq_zmc
       module procedure fmleq_zmfm
       module procedure fmleq_zmim
       module procedure fmleq_zmzm
    end interface

 contains


!                                                                   =

   subroutine fmeq_ifm(ival, ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer :: ival
      intent (inout) :: ival
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmm2i(ma%mfm, ival, qx)
   end subroutine fmeq_ifm

   subroutine fmeq_iim(ival, ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer :: ival
      intent (inout) :: ival
      intent (in) :: ma
      type(fm_settings) :: qx
      call imm2i(ma%mim, ival, qx)
   end subroutine fmeq_iim

   subroutine fmeq_izm(ival, ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer :: ival
      intent (inout) :: ival
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmm2i(ma%mzm, ival, qx)
   end subroutine fmeq_izm

   subroutine fmeq_rfm(r, ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      real :: r
      intent (inout) :: r
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmm2sp(ma%mfm, r, qx)
   end subroutine fmeq_rfm

   subroutine fmeq_rim(r, ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      real :: r
      intent (inout) :: r
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmm2sp(mtlvfm, r, qx)
   end subroutine fmeq_rim

   subroutine fmeq_rzm(r, ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      real :: r
      intent (inout) :: r
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call zmreal(ma%mzm, mtlvfm, qx)
      call fmm2sp(mtlvfm, r, qx)
   end subroutine fmeq_rzm

   subroutine fmeq_dfm(d, ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      double precision :: d
      intent (inout) :: d
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmm2dp(ma%mfm, d, qx)
   end subroutine fmeq_dfm

   subroutine fmeq_dim(d, ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      double precision :: d
      intent (inout) :: d
      intent (in) :: ma
      type(fm_settings) :: qx
      call imm2dp(ma%mim, d, qx)
   end subroutine fmeq_dim

   subroutine fmeq_dzm(d, ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      double precision :: d
      intent (inout) :: d
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call zmreal(ma%mzm, mtlvfm, qx)
      call fmm2dp(mtlvfm, d, qx)
   end subroutine fmeq_dzm

   subroutine fmeq_zfm(z, ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex :: z
      real :: r
      intent (inout) :: z
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmm2sp(ma%mfm, r, qx)
      z = cmplx( r , 0.0 )
   end subroutine fmeq_zfm

   subroutine fmeq_zim(z, ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex :: z
      double precision :: d
      intent (inout) :: z
      intent (in) :: ma
      type(fm_settings) :: qx
      call imm2dp(ma%mim, d, qx)
      z = cmplx( real(d) , 0.0 )
   end subroutine fmeq_zim

   subroutine fmeq_zzm(z, ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex :: z
      intent (inout) :: z
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmm2z(ma%mzm, z, qx)
   end subroutine fmeq_zzm

   subroutine fmeq_cfm(c, ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      double precision :: d
      intent (inout) :: c
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmm2dp(ma%mfm, d, qx)
      c = cmplx( d , 0.0d0 , kind(0.0d0) )
   end subroutine fmeq_cfm

   subroutine fmeq_cim(c, ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      double precision :: d
      intent (inout) :: c
      intent (in) :: ma
      type(fm_settings) :: qx
      call imm2dp(ma%mim, d, qx)
      c = cmplx( d , 0.0d0 , kind(0.0d0) )
   end subroutine fmeq_cim

   subroutine fmeq_czm(c, ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)) :: c
      double precision :: d1, d2
      intent (inout) :: c
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call zmreal(ma%mzm, mtlvfm, qx)
      call fmm2dp(mtlvfm, d1, qx)
      call zmimag(ma%mzm, mtlvfm, qx)
      call fmm2dp(mtlvfm, d2, qx)
      c = cmplx( d1 , d2 , kind(0.0d0) )
   end subroutine fmeq_czm

   subroutine fmeq_fmi(ma, ival)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer :: ival
      intent (inout) :: ma
      intent (in) :: ival
      type(fm_settings) :: qx
      call fmi2m(ival, ma%mfm, qx)
   end subroutine fmeq_fmi

   subroutine fmeq_fmr(ma, r)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      real :: r
      intent (inout) :: ma
      intent (in) :: r
      type(fm_settings) :: qx
      call fmsp2m(r, ma%mfm, qx)
   end subroutine fmeq_fmr

   subroutine fmeq_fmd(ma, d)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      double precision :: d
      intent (inout) :: ma
      intent (in) :: d
      type(fm_settings) :: qx
      call fmdp2m(d, ma%mfm, qx)
   end subroutine fmeq_fmd

   subroutine fmeq_fmz(ma, z)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex :: z
      real :: r
      intent (inout) :: ma
      intent (in) :: z
      type(fm_settings) :: qx
      r = real(z)
      call fmsp2m(r, ma%mfm, qx)
   end subroutine fmeq_fmz

   subroutine fmeq_fmc(ma, c)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      double precision :: d
      intent (inout) :: ma
      intent (in) :: c
      type(fm_settings) :: qx
      d = real(c, kind(0.0d0))
      call fmdp2m(d, ma%mfm, qx)
   end subroutine fmeq_fmc

   subroutine fmeq_fmfm(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb
      type(fm_settings) :: qx
      call fmeq(mb%mfm, ma%mfm, qx)
   end subroutine fmeq_fmfm

   subroutine fmeq_fmim(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (im) :: mb
      intent (inout) :: ma
      intent (in) :: mb
      type(fm_settings) :: qx
      call imi2fm(mb%mim, ma%mfm, qx)
   end subroutine fmeq_fmim

   subroutine fmeq_fmzm(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (zm) :: mb
      intent (inout) :: ma
      intent (in) :: mb
      type(fm_settings) :: qx
      call zmreal(mb%mzm, ma%mfm, qx)
   end subroutine fmeq_fmzm

   subroutine fmeq_imi(ma, ival)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer :: ival
      intent (inout) :: ma
      intent (in) :: ival
      type(fm_settings) :: qx
      call imi2m(ival, ma%mim, qx)
   end subroutine fmeq_imi

   subroutine fmeq_imr(ma, r)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer :: ival
      real :: r
      character(25) :: st
      intent (inout) :: ma
      intent (in) :: r
      type(fm_settings) :: qx
      if (abs(r) < huge(1)) then
          ival = int(r)
          call imi2m(ival, ma%mim, qx)
      else
          write (st, '(E25.16)') r
          call imst2m(st, ma%mim, qx)
      endif
   end subroutine fmeq_imr

   subroutine fmeq_imd(ma, d)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer :: ival
      double precision :: d
      character(25) :: st
      intent (inout) :: ma
      intent (in) :: d
      type(fm_settings) :: qx
      if (abs(d) < huge(1)) then
          ival = int(d)
          call imi2m(ival, ma%mim, qx)
      else
          write (st, '(E25.16)') d
          call imst2m(st, ma%mim, qx)
      endif
   end subroutine fmeq_imd

   subroutine fmeq_imz(ma, z)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex :: z
      real :: r
      character(25) :: st
      integer :: ival
      intent (inout) :: ma
      intent (in) :: z
      type(fm_settings) :: qx
      r = real(z)
      if (abs(r) < huge(1)) then
          ival = int(r)
          call imi2m(ival, ma%mim, qx)
      else
          write (st, '(E25.16)') r
          call imst2m(st, ma%mim, qx)
      endif
   end subroutine fmeq_imz

   subroutine fmeq_imc(ma, c)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      double precision :: d
      character(25) :: st
      integer :: ival
      intent (inout) :: ma
      intent (in) :: c
      type(fm_settings) :: qx
      d = real(c, kind(0.0d0))
      if (abs(d) < huge(1)) then
          ival = int(d)
          call imi2m(ival, ma%mim, qx)
      else
          write (st, '(E25.16)') d
          call imst2m(st, ma%mim, qx)
      endif
   end subroutine fmeq_imc

   subroutine fmeq_imfm(ma, mb)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (fm) :: mb
      intent (inout) :: ma
      intent (in) :: mb
      type(fm_settings) :: qx
      call imfm2i(mb%mfm, ma%mim, qx)
   end subroutine fmeq_imfm

   subroutine fmeq_imim(ma, mb)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb
      type(fm_settings) :: qx
      call imeq(mb%mim, ma%mim, qx)
   end subroutine fmeq_imim

   subroutine fmeq_imzm(ma, mb)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (zm) :: mb
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call zmreal(mb%mzm, mtlvfm, qx)
      call imfm2i(mtlvfm, ma%mim, qx)
   end subroutine fmeq_imzm

   subroutine fmeq_zmi(ma, ival)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer :: ival
      intent (inout) :: ma
      intent (in) :: ival
      type(fm_settings) :: qx
      call zmi2m(ival, ma%mzm, qx)
   end subroutine fmeq_zmi

   subroutine fmeq_zmr(ma, r)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      real :: r
      complex :: z
      intent (inout) :: ma
      intent (in) :: r
      type(fm_settings) :: qx
      z = cmplx(r, 0.0)
      call zmz2m(z, ma%mzm, qx)
   end subroutine fmeq_zmr

   subroutine fmeq_zmd(ma, d)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      double precision :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmdp2m(0.0d0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, ma%mzm, qx)
   end subroutine fmeq_zmd

   subroutine fmeq_zmz(ma, z)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex :: z
      intent (inout) :: ma
      intent (in) :: z
      type(fm_settings) :: qx
      call zmz2m(z, ma%mzm, qx)
   end subroutine fmeq_zmz

   subroutine fmeq_zmc(ma, c)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)) :: c
      double precision :: d
      intent (inout) :: ma
      intent (in) :: c
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      d = real(c, kind(0.0d0))
      call fmdp2m(d, mtlvfm, qx)
      d = aimag(c)
      call fmdp2m(d, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, ma%mzm, qx)
   end subroutine fmeq_zmc

   subroutine fmeq_zmfm(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: mb
      type (zm) :: ma
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmeq(mb%mfm, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, ma%mzm, qx)
   end subroutine fmeq_zmfm

   subroutine fmeq_zmim(ma, mb)
      use fmvals_parallel
      implicit none
      type (im) :: mb
      type (zm) :: ma
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call imi2fm(mb%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, ma%mzm, qx)
   end subroutine fmeq_zmim

   subroutine fmeq_zmzm(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmeq(mb%mzm, mtlvzm, qx)
      call zmeq(mtlvzm, ma%mzm, qx)
   end subroutine fmeq_zmzm

!             Array equal assignments for FM.

!             (1) rank 1  =  rank 0

   subroutine fmeq_fm1i(ma, ival)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      integer :: ival, j, n
      intent (inout) :: ma
      intent (in) :: ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(ival, mtlvfm, qx)
      do j = 1, n
         call fmeq(mtlvfm, ma(j)%mfm, qx)
      enddo
   end subroutine fmeq_fm1i

   subroutine fmeq_fm1r(ma, r)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      integer :: j, n
      real :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, n
         call fmeq(mtlvfm, ma(j)%mfm, qx)
      enddo
   end subroutine fmeq_fm1r

   subroutine fmeq_fm1d(ma, d)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      integer :: j, n
      double precision :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, n
         call fmeq(mtlvfm, ma(j)%mfm, qx)
      enddo
   end subroutine fmeq_fm1d

   subroutine fmeq_fm1z(ma, z)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      integer :: j, n
      complex :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(real(z), mtlvfm, qx)
      do j = 1, n
         call fmeq(mtlvfm, ma(j)%mfm, qx)
      enddo
   end subroutine fmeq_fm1z

   subroutine fmeq_fm1c(ma, c)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (inout) :: ma
      intent (in) :: c
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      do j = 1, n
         call fmeq(mtlvfm, ma(j)%mfm, qx)
      enddo
   end subroutine fmeq_fm1c

   subroutine fmeq_i1fm(ival, ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer, dimension(:) :: ival
      integer :: j, k, n
      intent (inout) :: ival
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ival)
      call fmm2i(ma%mfm, k, qx)
      do j = 1, n
         ival(j) = k
      enddo
   end subroutine fmeq_i1fm

   subroutine fmeq_r1fm(r, ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      real, dimension(:) :: r
      real :: r2
      integer :: j, n
      intent (inout) :: r
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(r)
      call fmm2sp(ma%mfm, r2, qx)
      do j = 1, n
         r(j) = r2
      enddo
   end subroutine fmeq_r1fm

   subroutine fmeq_d1fm(d, ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      double precision, dimension(:) :: d
      double precision :: d2
      integer :: j, n
      intent (inout) :: d
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(d)
      call fmm2dp(ma%mfm, d2, qx)
      do j = 1, n
         d(j) = d2
      enddo
   end subroutine fmeq_d1fm

   subroutine fmeq_z1fm(z, ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex, dimension(:) :: z
      real :: r2
      integer :: j, n
      intent (inout) :: z
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(z)
      call fmm2sp(ma%mfm, r2, qx)
      do j = 1, n
         z(j) = r2
      enddo
   end subroutine fmeq_z1fm

   subroutine fmeq_c1fm(c, ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      double precision :: d2
      integer :: j, n
      intent (inout) :: c
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(c)
      call fmm2dp(ma%mfm, d2, qx)
      do j = 1, n
         c(j) = d2
      enddo
   end subroutine fmeq_c1fm

   subroutine fmeq_fm1fm(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmeq(mb%mfm, mtlvfm, qx)
      do j = 1, n
         call fmeq(mtlvfm, ma(j)%mfm, qx)
      enddo
   end subroutine fmeq_fm1fm

   subroutine fmeq_fm1im(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (im) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call imi2fm(mb%mim, mtlvfm, qx)
      do j = 1, n
         call fmeq(mtlvfm, ma(j)%mfm, qx)
      enddo
   end subroutine fmeq_fm1im

   subroutine fmeq_fm1zm(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call zmreal(mb%mzm, mtlvfm, qx)
      do j = 1, n
         call fmeq(mtlvfm, ma(j)%mfm, qx)
      enddo
   end subroutine fmeq_fm1zm

   subroutine fmeq_im1fm(ma, mb)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      n = size(ma)
      call imfm2i(mb%mfm, mtlvim, qx)
      do j = 1, n
         call imeq(mtlvim, ma(j)%mim, qx)
      enddo
   end subroutine fmeq_im1fm

   subroutine fmeq_zm1fm(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (fm) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm, qx)
      do j = 1, n
         call zmeq(mtlvzm, ma(j)%mzm, qx)
      enddo
   end subroutine fmeq_zm1fm

!             (2) rank 1  =  rank 1

   subroutine fmeq_fm1i1(ma, ival)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      integer, dimension(:) :: ival
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          call fmunknown(mtlvfm, qx)
          do j = 1, size(ma)
             call fmeq(mtlvfm, ma(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmi2m(ival(j), ma(j)%mfm, qx)
      enddo
   end subroutine fmeq_fm1i1

   subroutine fmeq_fm1r1(ma, r)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      integer :: j, n
      real, dimension(:) :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          call fmunknown(mtlvfm, qx)
          do j = 1, size(ma)
             call fmeq(mtlvfm, ma(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(r(j), ma(j)%mfm, qx)
      enddo
   end subroutine fmeq_fm1r1

   subroutine fmeq_fm1d1(ma, d)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      integer :: j, n
      double precision, dimension(:) :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          call fmunknown(mtlvfm, qx)
          do j = 1, size(ma)
             call fmeq(mtlvfm, ma(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(d(j), ma(j)%mfm, qx)
      enddo
   end subroutine fmeq_fm1d1

   subroutine fmeq_fm1z1(ma, z)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      integer :: j, n
      complex, dimension(:) :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          call fmunknown(mtlvfm, qx)
          do j = 1, size(ma)
             call fmeq(mtlvfm, ma(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(real(z(j)), ma(j)%mfm, qx)
      enddo
   end subroutine fmeq_fm1z1

   subroutine fmeq_fm1c1(ma, c)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (inout) :: ma
      intent (in) :: c
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          call fmunknown(mtlvfm, qx)
          do j = 1, size(ma)
             call fmeq(mtlvfm, ma(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), ma(j)%mfm, qx)
      enddo
   end subroutine fmeq_fm1c1

   subroutine fmeq_i1fm1(ival, ma)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      integer, dimension(:) :: ival
      integer :: j, n
      intent (inout) :: ival
      intent (in) :: ma
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ival)
             ival(j) = qx%iunkno
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call fmm2i(ma(j)%mfm, ival(j), qx)
      enddo
   end subroutine fmeq_i1fm1

   subroutine fmeq_r1fm1(r, ma)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      real, dimension(:) :: r
      integer :: j, n
      intent (inout) :: r
      intent (in) :: ma
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(r)
             r(j) = qx%runkno
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call fmm2sp(ma(j)%mfm, r(j), qx)
      enddo
   end subroutine fmeq_r1fm1

   subroutine fmeq_d1fm1(d, ma)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      double precision, dimension(:) :: d
      integer :: j, n
      intent (inout) :: d
      intent (in) :: ma
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(d)
             d(j) = qx%runkno
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call fmm2dp(ma(j)%mfm, d(j), qx)
      enddo
   end subroutine fmeq_d1fm1

   subroutine fmeq_z1fm1(z, ma)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      complex, dimension(:) :: z
      real :: r
      integer :: j, n
      intent (inout) :: z
      intent (in) :: ma
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(z)
             z(j) = cmplx(qx%runkno, qx%runkno)
          enddo
          return
      endif
      n = size(z)
      do j = 1, n
         call fmm2sp(ma(j)%mfm, r, qx)
         z(j) = cmplx(r, 0.0)
      enddo
   end subroutine fmeq_z1fm1

   subroutine fmeq_c1fm1(c, ma)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      real (kind(0.0d0)) :: d
      integer :: j, n
      intent (inout) :: c
      intent (in) :: ma
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(c)
             d = qx%runkno
             c(j) = cmplx(d, d , kind(0.0d0))
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call fmm2dp(ma(j)%mfm, d, qx)
         c(j) = cmplx(d, 0.0d0 , kind(0.0d0))
      enddo
   end subroutine fmeq_c1fm1

   subroutine fmeq_fm1fm1(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (fm), allocatable, dimension(:) :: temp
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          call fmunknown(mtlvfm, qx)
          do j = 1, size(ma)
             call fmeq(mtlvfm, ma(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)

!             To avoid problems when lhs and rhs are overlapping parts of the same array, move mb
!             to a temporary array before re-defining any of ma.

      allocate(temp(n))
      do j = 1, n
         call fmeq(mb(j)%mfm, temp(j)%mfm, qx)
      enddo
      do j = 1, n
         call fmeq(temp(j)%mfm, ma(j)%mfm, qx)
      enddo
      deallocate(temp)
   end subroutine fmeq_fm1fm1

   subroutine fmeq_fm1im1(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (im), dimension(:) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          call fmunknown(mtlvfm, qx)
          do j = 1, size(ma)
             call fmeq(mtlvfm, ma(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2fm(mb(j)%mim, ma(j)%mfm, qx)
      enddo
   end subroutine fmeq_fm1im1

   subroutine fmeq_fm1zm1(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          call fmunknown(mtlvfm, qx)
          do j = 1, size(ma)
             call fmeq(mtlvfm, ma(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmreal(mb(j)%mzm, ma(j)%mfm, qx)
      enddo
   end subroutine fmeq_fm1zm1

   subroutine fmeq_im1fm1(ma, mb)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          call imunknown(mtlvim, qx)
          do j = 1, size(ma)
             call imeq(mtlvim, ma(j)%mim, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imfm2i(mb(j)%mfm, ma(j)%mim, qx)
      enddo
   end subroutine fmeq_im1fm1

   subroutine fmeq_zm1fm1(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          call zmunknown(mtlvzm, qx)
          do j = 1, size(ma)
             call zmeq(mtlvzm, ma(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call zmcmpx(mb(j)%mfm, mtlvfm, ma(j)%mzm, qx)
      enddo
   end subroutine fmeq_zm1fm1

!             (3) rank 2  =  rank 0

   subroutine fmeq_fm2i(ma, ival)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      integer :: ival, j, k
      intent (inout) :: ma
      intent (in) :: ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(mtlvfm, ma(j, k)%mfm, qx)
         enddo
      enddo
   end subroutine fmeq_fm2i

   subroutine fmeq_fm2r(ma, r)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      integer :: j, k
      real :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(mtlvfm, ma(j, k)%mfm, qx)
         enddo
      enddo
   end subroutine fmeq_fm2r

   subroutine fmeq_fm2d(ma, d)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      integer :: j, k
      double precision :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(mtlvfm, ma(j, k)%mfm, qx)
         enddo
      enddo
   end subroutine fmeq_fm2d

   subroutine fmeq_fm2z(ma, z)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      integer :: j, k
      complex :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(real(z), mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(mtlvfm, ma(j, k)%mfm, qx)
         enddo
      enddo
   end subroutine fmeq_fm2z

   subroutine fmeq_fm2c(ma, c)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (inout) :: ma
      intent (in) :: c
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(mtlvfm, ma(j, k)%mfm, qx)
         enddo
      enddo
   end subroutine fmeq_fm2c

   subroutine fmeq_i2fm(ival, ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer, dimension(:,:) :: ival
      integer :: j, k, l
      intent (inout) :: ival
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmm2i(ma%mfm, l, qx)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            ival(j, k) = l
         enddo
      enddo
   end subroutine fmeq_i2fm

   subroutine fmeq_r2fm(r, ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      real, dimension(:,:) :: r
      real :: r2
      integer :: j, k
      intent (inout) :: r
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmm2sp(ma%mfm, r2, qx)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            r(j, k) = r2
         enddo
      enddo
   end subroutine fmeq_r2fm

   subroutine fmeq_d2fm(d, ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      double precision, dimension(:,:) :: d
      double precision :: d2
      integer :: j, k
      intent (inout) :: d
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmm2dp(ma%mfm, d2, qx)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            d(j, k) = d2
         enddo
      enddo
   end subroutine fmeq_d2fm

   subroutine fmeq_z2fm(z, ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex, dimension(:,:) :: z
      real :: r2
      integer :: j, k
      intent (inout) :: z
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmm2sp(ma%mfm, r2, qx)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            z(j, k) = r2
         enddo
      enddo
   end subroutine fmeq_z2fm

   subroutine fmeq_c2fm(c, ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      double precision :: d2
      integer :: j, k
      intent (inout) :: c
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmm2dp(ma%mfm, d2, qx)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            c(j, k) = d2
         enddo
      enddo
   end subroutine fmeq_c2fm

   subroutine fmeq_fm2fm(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmeq(mb%mfm, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(mtlvfm, ma(j, k)%mfm, qx)
         enddo
      enddo
   end subroutine fmeq_fm2fm

   subroutine fmeq_fm2im(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(mb%mim, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(mtlvfm, ma(j, k)%mfm, qx)
         enddo
      enddo
   end subroutine fmeq_fm2im

   subroutine fmeq_fm2zm(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call zmreal(mb%mzm, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(mtlvfm, ma(j, k)%mfm, qx)
         enddo
      enddo
   end subroutine fmeq_fm2zm

   subroutine fmeq_im2fm(ma, mb)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imfm2i(mb%mfm, mtlvim, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(mtlvim, ma(j, k)%mim, qx)
         enddo
      enddo
   end subroutine fmeq_im2fm

   subroutine fmeq_zm2fm(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(mtlvzm, ma(j, k)%mzm, qx)
         enddo
      enddo
   end subroutine fmeq_zm2fm

!             (4) rank 2  =  rank 2

   subroutine fmeq_fm2i2(ma, ival)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          call fmunknown(mtlvfm, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmeq(mtlvfm, ma(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), ma(j, k)%mfm, qx)
         enddo
      enddo
   end subroutine fmeq_fm2i2

   subroutine fmeq_fm2r2(ma, r)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      integer :: j, k
      real, dimension(:,:) :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          call fmunknown(mtlvfm, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmeq(mtlvfm, ma(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), ma(j, k)%mfm, qx)
         enddo
      enddo
   end subroutine fmeq_fm2r2

   subroutine fmeq_fm2d2(ma, d)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          call fmunknown(mtlvfm, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmeq(mtlvfm, ma(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), ma(j, k)%mfm, qx)
         enddo
      enddo
   end subroutine fmeq_fm2d2

   subroutine fmeq_fm2z2(ma, z)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          call fmunknown(mtlvfm, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmeq(mtlvfm, ma(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(real(z(j, k)), ma(j, k)%mfm, qx)
         enddo
      enddo
   end subroutine fmeq_fm2z2

   subroutine fmeq_fm2c2(ma, c)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (inout) :: ma
      intent (in) :: c
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          call fmunknown(mtlvfm, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmeq(mtlvfm, ma(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), ma(j, k)%mfm, qx)
         enddo
      enddo
   end subroutine fmeq_fm2c2

   subroutine fmeq_i2fm2(ival, ma)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (inout) :: ival
      intent (in) :: ma
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ival, dim=1)
             do k = 1, size(ival, dim=2)
                ival(j, k) = qx%iunkno
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2i(ma(j, k)%mfm, ival(j, k), qx)
         enddo
      enddo
   end subroutine fmeq_i2fm2

   subroutine fmeq_r2fm2(r, ma)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      integer :: j, k
      intent (inout) :: r
      intent (in) :: ma
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(r, dim=1)
             do k = 1, size(r, dim=2)
                r(j, k) = qx%runkno
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2sp(ma(j, k)%mfm, r(j, k), qx)
         enddo
      enddo
   end subroutine fmeq_r2fm2

   subroutine fmeq_d2fm2(d, ma)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      integer :: j, k
      intent (inout) :: d
      intent (in) :: ma
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(d, dim=1)
             do k = 1, size(d, dim=2)
                d(j, k) = qx%runkno
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2dp(ma(j, k)%mfm, d(j, k), qx)
         enddo
      enddo
   end subroutine fmeq_d2fm2

   subroutine fmeq_z2fm2(z, ma)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      real :: r
      integer :: j, k
      intent (inout) :: z
      intent (in) :: ma
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(z, dim=1)
             do k = 1, size(z, dim=2)
                z(j, k) = cmplx(qx%runkno, qx%runkno)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2sp(ma(j, k)%mfm, r, qx)
            z(j, k) = cmplx(r, 0.0)
         enddo
      enddo
   end subroutine fmeq_z2fm2

   subroutine fmeq_c2fm2(c, ma)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      real (kind(0.0d0)) :: d
      integer :: j, k
      intent (inout) :: c
      intent (in) :: ma
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(c, dim=1)
             do k = 1, size(c, dim=2)
                d = qx%runkno
                c(j, k) = cmplx(d, d , kind(0.0d0))
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2dp(ma(j, k)%mfm, d, qx)
            c(j, k) = cmplx(d, 0.0d0 , kind(0.0d0))
         enddo
      enddo
   end subroutine fmeq_c2fm2

   subroutine fmeq_fm2fm2(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), allocatable, dimension(:,:) :: temp
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          call fmunknown(mtlvfm, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmeq(mtlvfm, ma(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif

!             To avoid problems when lhs and rhs are overlapping parts of the same array, move mb
!             to a temporary array before re-defining any of ma.

      allocate(temp(size(ma, dim=1), size(ma, dim=2)))
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(mb(j, k)%mfm, temp(j, k)%mfm, qx)
         enddo
      enddo
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(temp(j, k)%mfm, ma(j, k)%mfm, qx)
         enddo
      enddo
      deallocate(temp)
   end subroutine fmeq_fm2fm2

   subroutine fmeq_fm2im2(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          call fmunknown(mtlvfm, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmeq(mtlvfm, ma(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(mb(j, k)%mim, ma(j, k)%mfm, qx)
         enddo
      enddo
   end subroutine fmeq_fm2im2

   subroutine fmeq_fm2zm2(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          call fmunknown(mtlvfm, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmeq(mtlvfm, ma(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmreal(mb(j, k)%mzm, ma(j, k)%mfm, qx)
         enddo
      enddo
   end subroutine fmeq_fm2zm2

   subroutine fmeq_im2fm2(ma, mb)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          call imunknown(mtlvim, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imeq(mtlvim, ma(j, k)%mim, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imfm2i(mb(j, k)%mfm, ma(j, k)%mim, qx)
         enddo
      enddo
   end subroutine fmeq_im2fm2

   subroutine fmeq_zm2fm2(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          call zmunknown(mtlvzm, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmeq(mtlvzm, ma(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(mb(j, k)%mfm, mtlvfm, ma(j, k)%mzm, qx)
         enddo
      enddo
   end subroutine fmeq_zm2fm2

!             Array equal assignments for IM.

!             (1) rank 1  =  rank 0

   subroutine fmeq_im1i(ma, ival)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      integer :: ival, j, n
      intent (inout) :: ma
      intent (in) :: ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      n = size(ma)
      call imi2m(ival, mtlvim, qx)
      do j = 1, n
         call imeq(mtlvim, ma(j)%mim, qx)
      enddo
   end subroutine fmeq_im1i

   subroutine fmeq_im1r(ma, r)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      integer :: j, n
      real :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi) :: mtlvfm, mtlvim
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      call imfm2i(mtlvfm, mtlvim, qx)
      do j = 1, n
         call imeq(mtlvim, ma(j)%mim, qx)
      enddo
   end subroutine fmeq_im1r

   subroutine fmeq_im1d(ma, d)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      integer :: j, n
      double precision :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi) :: mtlvfm, mtlvim
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      call imfm2i(mtlvfm, mtlvim, qx)
      do j = 1, n
         call imeq(mtlvim, ma(j)%mim, qx)
      enddo
   end subroutine fmeq_im1d

   subroutine fmeq_im1z(ma, z)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      integer :: j, n
      complex :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi) :: mtlvfm, mtlvim
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(real(z), mtlvfm, qx)
      call imfm2i(mtlvfm, mtlvim, qx)
      do j = 1, n
         call imeq(mtlvim, ma(j)%mim, qx)
      enddo
   end subroutine fmeq_im1z

   subroutine fmeq_im1c(ma, c)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (inout) :: ma
      intent (in) :: c
      type(multi) :: mtlvfm, mtlvim
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call imfm2i(mtlvfm, mtlvim, qx)
      do j = 1, n
         call imeq(mtlvim, ma(j)%mim, qx)
      enddo
   end subroutine fmeq_im1c

   subroutine fmeq_i1im(ival, ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer, dimension(:) :: ival
      integer :: j, k, n
      intent (inout) :: ival
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ival)
      call imm2i(ma%mim, k, qx)
      do j = 1, n
         ival(j) = k
      enddo
   end subroutine fmeq_i1im

   subroutine fmeq_r1im(r, ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      real, dimension(:) :: r
      real :: r2
      integer :: j, n
      intent (inout) :: r
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(r)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmm2sp(mtlvfm, r2, qx)
      do j = 1, n
         r(j) = r2
      enddo
   end subroutine fmeq_r1im

   subroutine fmeq_d1im(d, ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      double precision, dimension(:) :: d
      double precision :: d2
      integer :: j, n
      intent (inout) :: d
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(d)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmm2dp(mtlvfm, d2, qx)
      do j = 1, n
         d(j) = d2
      enddo
   end subroutine fmeq_d1im

   subroutine fmeq_z1im(z, ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex, dimension(:) :: z
      real :: r2
      integer :: j, n
      intent (inout) :: z
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(z)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmm2sp(mtlvfm, r2, qx)
      do j = 1, n
         z(j) = r2
      enddo
   end subroutine fmeq_z1im

   subroutine fmeq_c1im(c, ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      double precision :: d2
      integer :: j, n
      intent (inout) :: c
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(c)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmm2dp(mtlvfm, d2, qx)
      do j = 1, n
         c(j) = d2
      enddo
   end subroutine fmeq_c1im

   subroutine fmeq_im1im(ma, mb)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      n = size(ma)
      call imeq(mb%mim, mtlvim, qx)
      do j = 1, n
         call imeq(mtlvim, ma(j)%mim, qx)
      enddo
   end subroutine fmeq_im1im

   subroutine fmeq_im1zm(ma, mb)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm, mtlvim
      type(fm_settings) :: qx
      n = size(ma)
      call zmreal(mb%mzm, mtlvfm, qx)
      call imfm2i(mtlvfm, mtlvim, qx)
      do j = 1, n
         call imeq(mtlvim, ma(j)%mim, qx)
      enddo
   end subroutine fmeq_im1zm

   subroutine fmeq_zm1im(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (im) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call imi2fm(mb%mim, mulvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mulvfm, mtlvfm, mtlvzm, qx)
      do j = 1, n
         call zmeq(mtlvzm, ma(j)%mzm, qx)
      enddo
   end subroutine fmeq_zm1im

!             (2) rank 1  =  rank 1

   subroutine fmeq_im1i1(ma, ival)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      integer, dimension(:) :: ival
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          call imunknown(mtlvim, qx)
          do j = 1, size(ma)
             call imeq(mtlvim, ma(j)%mim, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2m(ival(j), ma(j)%mim, qx)
      enddo
   end subroutine fmeq_im1i1

   subroutine fmeq_im1r1(ma, r)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      integer :: j, n
      real, dimension(:) :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi) :: mtlvfm, mtlvim
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          call imunknown(mtlvim, qx)
          do j = 1, size(ma)
             call imeq(mtlvim, ma(j)%mim, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call imfm2i(mtlvfm, ma(j)%mim, qx)
      enddo
   end subroutine fmeq_im1r1

   subroutine fmeq_im1d1(ma, d)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      integer :: j, n
      double precision, dimension(:) :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi) :: mtlvfm, mtlvim
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          call imunknown(mtlvim, qx)
          do j = 1, size(ma)
             call imeq(mtlvim, ma(j)%mim, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call imfm2i(mtlvfm, ma(j)%mim, qx)
      enddo
   end subroutine fmeq_im1d1

   subroutine fmeq_im1z1(ma, z)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      integer :: j, n
      complex, dimension(:) :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi) :: mtlvfm, mtlvim
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          call imunknown(mtlvim, qx)
          do j = 1, size(ma)
             call imeq(mtlvim, ma(j)%mim, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(real(z(j)), mtlvfm, qx)
         call imfm2i(mtlvfm, ma(j)%mim, qx)
      enddo
   end subroutine fmeq_im1z1

   subroutine fmeq_im1c1(ma, c)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (inout) :: ma
      intent (in) :: c
      type(multi) :: mtlvfm, mtlvim
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          call imunknown(mtlvim, qx)
          do j = 1, size(ma)
             call imeq(mtlvim, ma(j)%mim, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call imfm2i(mtlvfm, ma(j)%mim, qx)
      enddo
   end subroutine fmeq_im1c1

   subroutine fmeq_i1im1(ival, ma)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      integer, dimension(:) :: ival
      integer :: j, n
      intent (inout) :: ival
      intent (in) :: ma
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             ival(j) = qx%iunkno
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call imm2i(ma(j)%mim, ival(j), qx)
      enddo
   end subroutine fmeq_i1im1

   subroutine fmeq_r1im1(r, ma)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      real, dimension(:) :: r
      integer :: j, n
      intent (inout) :: r
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             r(j) = qx%runkno
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call fmm2sp(mtlvfm, r(j), qx)
      enddo
   end subroutine fmeq_r1im1

   subroutine fmeq_d1im1(d, ma)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      double precision, dimension(:) :: d
      integer :: j, n
      intent (inout) :: d
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             d(j) = qx%runkno
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call fmm2dp(mtlvfm, d(j), qx)
      enddo
   end subroutine fmeq_d1im1

   subroutine fmeq_z1im1(z, ma)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      complex, dimension(:) :: z
      real :: r
      integer :: j, n
      intent (inout) :: z
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             z(j) = cmplx(qx%runkno, qx%runkno)
          enddo
          return
      endif
      n = size(z)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call fmm2sp(mtlvfm, r, qx)
         z(j) = cmplx(r, 0.0)
      enddo
   end subroutine fmeq_z1im1

   subroutine fmeq_c1im1(c, ma)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      real (kind(0.0d0)) :: d
      integer :: j, n
      intent (inout) :: c
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             d = qx%runkno
             c(j) = cmplx(d, d , kind(0.0d0))
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call fmm2dp(mtlvfm, d, qx)
         c(j) = cmplx(d, 0.0d0 , kind(0.0d0))
      enddo
   end subroutine fmeq_c1im1

   subroutine fmeq_im1im1(ma, mb)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (im), allocatable, dimension(:) :: temp
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          call imunknown(mtlvim, qx)
          do j = 1, size(ma)
             call imeq(mtlvim, ma(j)%mim, qx)
          enddo
          return
      endif
      n = size(ma)

!             To avoid problems when lhs and rhs are overlapping parts of the same array, move mb
!             to a temporary array before re-defining any of ma.

      allocate(temp(n))
      do j = 1, n
         call imeq(mb(j)%mim, temp(j)%mim, qx)
      enddo
      do j = 1, n
         call imeq(temp(j)%mim, ma(j)%mim, qx)
      enddo
      deallocate(temp)
   end subroutine fmeq_im1im1

   subroutine fmeq_im1zm1(ma, mb)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm, mtlvim
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          call imunknown(mtlvim, qx)
          do j = 1, size(ma)
             call imeq(mtlvim, ma(j)%mim, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmreal(mb(j)%mzm, mtlvfm, qx)
         call imfm2i(mtlvfm, ma(j)%mim, qx)
      enddo
   end subroutine fmeq_im1zm1

   subroutine fmeq_zm1im1(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (im), dimension(:) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          call zmunknown(mtlvzm, qx)
          do j = 1, size(ma)
             call zmeq(mtlvzm, ma(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call imi2fm(mb(j)%mim, mulvfm, qx)
         call zmcmpx(mulvfm, mtlvfm, ma(j)%mzm, qx)
      enddo
   end subroutine fmeq_zm1im1

!             (3) rank 2  =  rank 0

   subroutine fmeq_im2i(ma, ival)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      integer :: ival, j, k
      intent (inout) :: ma
      intent (in) :: ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(mtlvim, ma(j, k)%mim, qx)
         enddo
      enddo
   end subroutine fmeq_im2i

   subroutine fmeq_im2r(ma, r)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      integer :: j, k
      real :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi) :: mtlvfm, mtlvim
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call imfm2i(mtlvfm, mtlvim, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(mtlvim, ma(j, k)%mim, qx)
         enddo
      enddo
   end subroutine fmeq_im2r

   subroutine fmeq_im2d(ma, d)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      integer :: j, k
      double precision :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi) :: mtlvfm, mtlvim
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call imfm2i(mtlvfm, mtlvim, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(mtlvim, ma(j, k)%mim, qx)
         enddo
      enddo
   end subroutine fmeq_im2d

   subroutine fmeq_im2z(ma, z)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      integer :: j, k
      complex :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi) :: mtlvfm, mtlvim
      type(fm_settings) :: qx
      call fmsp2m(real(z), mtlvfm, qx)
      call imfm2i(mtlvfm, mtlvim, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(mtlvim, ma(j, k)%mim, qx)
         enddo
      enddo
   end subroutine fmeq_im2z

   subroutine fmeq_im2c(ma, c)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (inout) :: ma
      intent (in) :: c
      type(multi) :: mtlvfm, mtlvim
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call imfm2i(mtlvfm, mtlvim, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(mtlvim, ma(j, k)%mim, qx)
         enddo
      enddo
   end subroutine fmeq_im2c

   subroutine fmeq_i2im(ival, ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer, dimension(:,:) :: ival
      integer :: j, k, l
      intent (inout) :: ival
      intent (in) :: ma
      type(fm_settings) :: qx
      call imm2i(ma%mim, l, qx)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            ival(j, k) = l
         enddo
      enddo
   end subroutine fmeq_i2im

   subroutine fmeq_r2im(r, ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      real, dimension(:,:) :: r
      real :: r2
      integer :: j, k
      intent (inout) :: r
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmm2sp(mtlvfm, r2, qx)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            r(j, k) = r2
         enddo
      enddo
   end subroutine fmeq_r2im

   subroutine fmeq_d2im(d, ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      double precision, dimension(:,:) :: d
      double precision :: d2
      integer :: j, k
      intent (inout) :: d
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmm2dp(mtlvfm, d2, qx)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            d(j, k) = d2
         enddo
      enddo
   end subroutine fmeq_d2im

   subroutine fmeq_z2im(z, ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex, dimension(:,:) :: z
      real :: r2
      integer :: j, k
      intent (inout) :: z
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmm2sp(mtlvfm, r2, qx)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            z(j, k) = r2
         enddo
      enddo
   end subroutine fmeq_z2im

   subroutine fmeq_c2im(c, ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      double precision :: d2
      integer :: j, k
      intent (inout) :: c
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmm2dp(mtlvfm, d2, qx)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            c(j, k) = d2
         enddo
      enddo
   end subroutine fmeq_c2im

   subroutine fmeq_im2im(ma, mb)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imeq(mb%mim, mtlvim, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(mtlvim, ma(j, k)%mim, qx)
         enddo
      enddo
   end subroutine fmeq_im2im

   subroutine fmeq_im2zm(ma, mb)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm, mtlvim
      type(fm_settings) :: qx
      call zmreal(mb%mzm, mtlvfm, qx)
      call imfm2i(mtlvfm, mtlvim, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(mtlvim, ma(j, k)%mim, qx)
         enddo
      enddo
   end subroutine fmeq_im2zm

   subroutine fmeq_zm2im(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call imi2fm(mb%mim, mulvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mulvfm, mtlvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(mtlvzm, ma(j, k)%mzm, qx)
         enddo
      enddo
   end subroutine fmeq_zm2im

!             (4) rank 2  =  rank 2

   subroutine fmeq_im2i2(ma, ival)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          call imunknown(mtlvim, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imeq(mtlvim, ma(j, k)%mim, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2m(ival(j, k), ma(j, k)%mim, qx)
         enddo
      enddo
   end subroutine fmeq_im2i2

   subroutine fmeq_im2r2(ma, r)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      integer :: j, k
      real, dimension(:,:) :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi) :: mtlvfm, mtlvim
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          call imunknown(mtlvim, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imeq(mtlvim, ma(j, k)%mim, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call imfm2i(mtlvfm, ma(j, k)%mim, qx)
         enddo
      enddo
   end subroutine fmeq_im2r2

   subroutine fmeq_im2d2(ma, d)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi) :: mtlvfm, mtlvim
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          call imunknown(mtlvim, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imeq(mtlvim, ma(j, k)%mim, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call imfm2i(mtlvfm, ma(j, k)%mim, qx)
         enddo
      enddo
   end subroutine fmeq_im2d2

   subroutine fmeq_im2z2(ma, z)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi) :: mtlvfm, mtlvim
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          call imunknown(mtlvim, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imeq(mtlvim, ma(j, k)%mim, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(real(z(j, k)), mtlvfm, qx)
            call imfm2i(mtlvfm, ma(j, k)%mim, qx)
         enddo
      enddo
   end subroutine fmeq_im2z2

   subroutine fmeq_im2c2(ma, c)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (inout) :: ma
      intent (in) :: c
      type(multi) :: mtlvfm, mtlvim
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          call imunknown(mtlvim, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imeq(mtlvim, ma(j, k)%mim, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call imfm2i(mtlvfm, ma(j, k)%mim, qx)
         enddo
      enddo
   end subroutine fmeq_im2c2

   subroutine fmeq_i2im2(ival, ma)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (inout) :: ival
      intent (in) :: ma
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                ival(j, k) = qx%iunkno
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imm2i(ma(j, k)%mim, ival(j, k), qx)
         enddo
      enddo
   end subroutine fmeq_i2im2

   subroutine fmeq_r2im2(r, ma)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      integer :: j, k
      intent (inout) :: r
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                r(j, k) = qx%runkno
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call fmm2sp(mtlvfm, r(j, k), qx)
         enddo
      enddo
   end subroutine fmeq_r2im2

   subroutine fmeq_d2im2(d, ma)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      integer :: j, k
      intent (inout) :: d
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                d(j, k) = qx%runkno
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call fmm2dp(mtlvfm, d(j, k), qx)
         enddo
      enddo
   end subroutine fmeq_d2im2

   subroutine fmeq_z2im2(z, ma)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      real :: r
      integer :: j, k
      intent (inout) :: z
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                z(j, k) = cmplx(qx%runkno, qx%runkno)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call fmm2sp(mtlvfm, r, qx)
            z(j, k) = cmplx(r, 0.0)
         enddo
      enddo
   end subroutine fmeq_z2im2

   subroutine fmeq_c2im2(c, ma)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      real (kind(0.0d0)) :: d
      integer :: j, k
      intent (inout) :: c
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                d = qx%runkno
                c(j, k) = cmplx(d, d , kind(0.0d0))
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call fmm2dp(mtlvfm, d, qx)
            c(j, k) = cmplx(d, 0.0d0 , kind(0.0d0))
         enddo
      enddo
   end subroutine fmeq_c2im2

   subroutine fmeq_im2im2(ma, mb)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (im), allocatable, dimension(:,:) :: temp
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          call imunknown(mtlvim, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imeq(mtlvim, ma(j, k)%mim, qx)
             enddo
          enddo
          return
      endif

!             To avoid problems when lhs and rhs are overlapping parts of the same array, move mb
!             to a temporary array before re-defining any of ma.

      allocate(temp(size(ma, dim=1), size(ma, dim=2)))
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(mb(j, k)%mim, temp(j, k)%mim, qx)
         enddo
      enddo
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(temp(j, k)%mim, ma(j, k)%mim, qx)
         enddo
      enddo
      deallocate(temp)
   end subroutine fmeq_im2im2

   subroutine fmeq_im2zm2(ma, mb)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm, mtlvim
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          call imunknown(mtlvim, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imeq(mtlvim, ma(j, k)%mim, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmreal(mb(j, k)%mzm, mtlvfm, qx)
            call imfm2i(mtlvfm, ma(j, k)%mim, qx)
         enddo
      enddo
   end subroutine fmeq_im2zm2

   subroutine fmeq_zm2im2(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          call zmunknown(mtlvzm, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmeq(mtlvzm, ma(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(mb(j, k)%mim, mulvfm, qx)
            call zmcmpx(mulvfm, mtlvfm, ma(j, k)%mzm, qx)
         enddo
      enddo
   end subroutine fmeq_zm2im2

!             Array equal assignments for ZM.

!             (1) rank 1  =  rank 0

   subroutine fmeq_zm1i(ma, ival)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      integer :: ival, j, n
      intent (inout) :: ma
      intent (in) :: ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmi2m(ival, mtlvzm, qx)
      do j = 1, n
         call zmeq(mtlvzm, ma(j)%mzm, qx)
      enddo
   end subroutine fmeq_zm1i

   subroutine fmeq_zm1r(ma, r)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      integer :: j, n
      real :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmeq(mtlvzm, ma(j)%mzm, qx)
      enddo
   end subroutine fmeq_zm1r

   subroutine fmeq_zm1d(ma, d)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      integer :: j, n
      double precision :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmeq(mtlvzm, ma(j)%mzm, qx)
      enddo
   end subroutine fmeq_zm1d

   subroutine fmeq_zm1z(ma, z)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      integer :: j, n
      complex :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      do j = 1, n
         call zmeq(mtlvzm, ma(j)%mzm, qx)
      enddo
   end subroutine fmeq_zm1z

   subroutine fmeq_zm1c(ma, c)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      integer :: j, n
      complex (kind(0.0d0)) :: c
      double precision :: d
      intent (inout) :: ma
      intent (in) :: c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      d = aimag(c)
      call fmdp2m(d, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmeq(mtlvzm, ma(j)%mzm, qx)
      enddo
   end subroutine fmeq_zm1c

   subroutine fmeq_i1zm(ival, ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer, dimension(:) :: ival
      integer :: j, k, n
      intent (inout) :: ival
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ival)
      call zmm2i(ma%mzm, k, qx)
      do j = 1, n
         ival(j) = k
      enddo
   end subroutine fmeq_i1zm

   subroutine fmeq_r1zm(r, ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      real, dimension(:) :: r
      real :: r2
      integer :: j, n
      intent (inout) :: r
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(r)
      call zmreal(ma%mzm, mtlvfm, qx)
      call fmm2sp(mtlvfm, r2, qx)
      do j = 1, n
         r(j) = r2
      enddo
   end subroutine fmeq_r1zm

   subroutine fmeq_d1zm(d, ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      double precision, dimension(:) :: d
      double precision :: d2
      integer :: j, n
      intent (inout) :: d
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(d)
      call zmreal(ma%mzm, mtlvfm, qx)
      call fmm2dp(mtlvfm, d2, qx)
      do j = 1, n
         d(j) = d2
      enddo
   end subroutine fmeq_d1zm

   subroutine fmeq_z1zm(z, ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex, dimension(:) :: z
      complex :: z2
      integer :: j, n
      intent (inout) :: z
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(z)
      call zmm2z(ma%mzm, z2, qx)
      do j = 1, n
         z(j) = z2
      enddo
   end subroutine fmeq_z1zm

   subroutine fmeq_c1zm(c, ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      double precision :: d2, d3
      integer :: j, n
      intent (inout) :: c
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(c)
      call zmreal(ma%mzm, mtlvfm, qx)
      call fmm2dp(mtlvfm, d2, qx)
      call zmimag(ma%mzm, mtlvfm, qx)
      call fmm2dp(mtlvfm, d3, qx)
      do j = 1, n
         c(j) = cmplx(d2, d3, kind(0.0d0))
      enddo
   end subroutine fmeq_c1zm

   subroutine fmeq_zm1zm(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmeq(mb%mzm, mtlvzm, qx)
      do j = 1, n
         call zmeq(mtlvzm, ma(j)%mzm, qx)
      enddo
   end subroutine fmeq_zm1zm

!             (2) rank 1  =  rank 1

   subroutine fmeq_zm1i1(ma, ival)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      integer, dimension(:) :: ival
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          call zmunknown(mtlvzm, qx)
          do j = 1, size(ma)
             call zmeq(mtlvzm, ma(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmi2m(ival(j), ma(j)%mzm, qx)
      enddo
   end subroutine fmeq_zm1i1

   subroutine fmeq_zm1r1(ma, r)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      integer :: j, n
      real, dimension(:) :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          call zmunknown(mtlvzm, qx)
          do j = 1, size(ma)
             call zmeq(mtlvzm, ma(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, ma(j)%mzm, qx)
      enddo
   end subroutine fmeq_zm1r1

   subroutine fmeq_zm1d1(ma, d)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      integer :: j, n
      double precision, dimension(:) :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          call zmunknown(mtlvzm, qx)
          do j = 1, size(ma)
             call zmeq(mtlvzm, ma(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, ma(j)%mzm, qx)
      enddo
   end subroutine fmeq_zm1d1

   subroutine fmeq_zm1z1(ma, z)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      integer :: j, n
      complex, dimension(:) :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          call zmunknown(mtlvzm, qx)
          do j = 1, size(ma)
             call zmeq(mtlvzm, ma(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmz2m(z(j), ma(j)%mzm, qx)
      enddo
   end subroutine fmeq_zm1z1

   subroutine fmeq_zm1c1(ma, c)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      double precision :: d
      intent (inout) :: ma
      intent (in) :: c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          call zmunknown(mtlvzm, qx)
          do j = 1, size(ma)
             call zmeq(mtlvzm, ma(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         d = aimag(c(j))
         call fmdp2m(d, mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, ma(j)%mzm, qx)
      enddo
   end subroutine fmeq_zm1c1

   subroutine fmeq_i1zm1(ival, ma)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      integer, dimension(:) :: ival
      integer :: j, n
      intent (inout) :: ival
      intent (in) :: ma
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             ival(j) = qx%iunkno
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call zmm2i(ma(j)%mzm, ival(j), qx)
      enddo
   end subroutine fmeq_i1zm1

   subroutine fmeq_r1zm1(r, ma)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      real, dimension(:) :: r
      integer :: j, n
      intent (inout) :: r
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             r(j) = qx%runkno
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call zmreal(ma(j)%mzm, mtlvfm, qx)
         call fmm2sp(mtlvfm, r(j), qx)
      enddo
   end subroutine fmeq_r1zm1

   subroutine fmeq_d1zm1(d, ma)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      double precision, dimension(:) :: d
      integer :: j, n
      intent (inout) :: d
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             d(j) = qx%runkno
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call zmreal(ma(j)%mzm, mtlvfm, qx)
         call fmm2dp(mtlvfm, d(j), qx)
      enddo
   end subroutine fmeq_d1zm1

   subroutine fmeq_z1zm1(z, ma)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      complex, dimension(:) :: z
      integer :: j, n
      intent (inout) :: z
      intent (in) :: ma
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             z(j) = cmplx(qx%runkno, qx%runkno)
          enddo
          return
      endif
      n = size(z)
      do j = 1, n
         call zmm2z(ma(j)%mzm, z(j), qx)
      enddo
   end subroutine fmeq_z1zm1

   subroutine fmeq_c1zm1(c, ma)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      real (kind(0.0d0)) :: d, d1, d2
      integer :: j, n
      intent (inout) :: c
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             d = qx%runkno
             c(j) = cmplx(d, d , kind(0.0d0))
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call zmreal(ma(j)%mzm, mtlvfm, qx)
         call fmm2dp(mtlvfm, d1, qx)
         call zmimag(ma(j)%mzm, mtlvfm, qx)
         call fmm2dp(mtlvfm, d2, qx)
         c(j) = cmplx(d1, d2 , kind(0.0d0))
      enddo
   end subroutine fmeq_c1zm1

   subroutine fmeq_zm1zm1(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), allocatable, dimension(:) :: temp
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          call zmunknown(mtlvzm, qx)
          do j = 1, size(ma)
             call zmeq(mtlvzm, ma(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)

!             To avoid problems when lhs and rhs are overlapping parts of the same array, move mb
!             to a temporary array before re-defining any of ma.

      allocate(temp(n))
      do j = 1, n
         call zmeq(mb(j)%mzm, temp(j)%mzm, qx)
      enddo
      do j = 1, n
         call zmeq(temp(j)%mzm, ma(j)%mzm, qx)
      enddo
      deallocate(temp)
   end subroutine fmeq_zm1zm1

!             (3) rank 2  =  rank 0

   subroutine fmeq_zm2i(ma, ival)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      integer :: ival, j, k
      intent (inout) :: ma
      intent (in) :: ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmi2m(ival, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(mtlvzm, ma(j, k)%mzm, qx)
         enddo
      enddo
   end subroutine fmeq_zm2i

   subroutine fmeq_zm2r(ma, r)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      integer :: j, k
      real :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(mtlvzm, ma(j, k)%mzm, qx)
         enddo
      enddo
   end subroutine fmeq_zm2r

   subroutine fmeq_zm2d(ma, d)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      integer :: j, k
      double precision :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(mtlvzm, ma(j, k)%mzm, qx)
         enddo
      enddo
   end subroutine fmeq_zm2d

   subroutine fmeq_zm2z(ma, z)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      integer :: j, k
      complex :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(mtlvzm, ma(j, k)%mzm, qx)
         enddo
      enddo
   end subroutine fmeq_zm2z

   subroutine fmeq_zm2c(ma, c)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      integer :: j, k
      complex (kind(0.0d0)) :: c
      double precision :: d
      intent (inout) :: ma
      intent (in) :: c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      d = aimag(c)
      call fmdp2m(d, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(mtlvzm, ma(j, k)%mzm, qx)
         enddo
      enddo
   end subroutine fmeq_zm2c

   subroutine fmeq_i2zm(ival, ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer, dimension(:,:) :: ival
      integer :: j, k, l
      intent (inout) :: ival
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmm2i(ma%mzm, l, qx)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            ival(j, k) = l
         enddo
      enddo
   end subroutine fmeq_i2zm

   subroutine fmeq_r2zm(r, ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      real, dimension(:,:) :: r
      real :: r2
      integer :: j, k
      intent (inout) :: r
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call zmreal(ma%mzm, mtlvfm, qx)
      call fmm2sp(mtlvfm, r2, qx)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            r(j, k) = r2
         enddo
      enddo
   end subroutine fmeq_r2zm

   subroutine fmeq_d2zm(d, ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      double precision, dimension(:,:) :: d
      double precision :: d2
      integer :: j, k
      intent (inout) :: d
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call zmreal(ma%mzm, mtlvfm, qx)
      call fmm2dp(mtlvfm, d2, qx)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            d(j, k) = d2
         enddo
      enddo
   end subroutine fmeq_d2zm

   subroutine fmeq_z2zm(z, ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex, dimension(:,:) :: z
      complex :: z2
      integer :: j, k
      intent (inout) :: z
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmm2z(ma%mzm, z2, qx)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            z(j, k) = z2
         enddo
      enddo
   end subroutine fmeq_z2zm

   subroutine fmeq_c2zm(c, ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      double precision :: d2, d3
      integer :: j, k
      intent (inout) :: c
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call zmreal(ma%mzm, mtlvfm, qx)
      call fmm2dp(mtlvfm, d2, qx)
      call zmimag(ma%mzm, mtlvfm, qx)
      call fmm2dp(mtlvfm, d3, qx)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            c(j, k) = cmplx(d2, d3, kind(0.0d0))
         enddo
      enddo
   end subroutine fmeq_c2zm

   subroutine fmeq_zm2zm(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmeq(mb%mzm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(mtlvzm, ma(j, k)%mzm, qx)
         enddo
      enddo
   end subroutine fmeq_zm2zm

!             (4) rank 2  =  rank 2

   subroutine fmeq_zm2i2(ma, ival)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          call zmunknown(mtlvzm, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmeq(mtlvzm, ma(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmi2m(ival(j, k), ma(j, k)%mzm, qx)
         enddo
      enddo
   end subroutine fmeq_zm2i2

   subroutine fmeq_zm2r2(ma, r)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      integer :: j, k
      real, dimension(:,:) :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          call zmunknown(mtlvzm, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmeq(mtlvzm, ma(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, ma(j, k)%mzm, qx)
         enddo
      enddo
   end subroutine fmeq_zm2r2

   subroutine fmeq_zm2d2(ma, d)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          call zmunknown(mtlvzm, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmeq(mtlvzm, ma(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, ma(j, k)%mzm, qx)
         enddo
      enddo
   end subroutine fmeq_zm2d2

   subroutine fmeq_zm2z2(ma, z)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          call zmunknown(mtlvzm, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmeq(mtlvzm, ma(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), ma(j, k)%mzm, qx)
         enddo
      enddo
   end subroutine fmeq_zm2z2

   subroutine fmeq_zm2c2(ma, c)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      double precision :: d
      intent (inout) :: ma
      intent (in) :: c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          call zmunknown(mtlvzm, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmeq(mtlvzm, ma(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            d = aimag(c(j, k))
            call fmdp2m(d, mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, ma(j, k)%mzm, qx)
         enddo
      enddo
   end subroutine fmeq_zm2c2

   subroutine fmeq_i2zm2(ival, ma)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (inout) :: ival
      intent (in) :: ma
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                ival(j, k) = qx%iunkno
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmm2i(ma(j, k)%mzm, ival(j, k), qx)
         enddo
      enddo
   end subroutine fmeq_i2zm2

   subroutine fmeq_r2zm2(r, ma)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      integer :: j, k
      intent (inout) :: r
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                r(j, k) = qx%runkno
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmreal(ma(j, k)%mzm, mtlvfm, qx)
            call fmm2sp(mtlvfm, r(j, k), qx)
         enddo
      enddo
   end subroutine fmeq_r2zm2

   subroutine fmeq_d2zm2(d, ma)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      integer :: j, k
      intent (inout) :: d
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                d(j, k) = qx%runkno
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmreal(ma(j, k)%mzm, mtlvfm, qx)
            call fmm2dp(mtlvfm, d(j, k), qx)
         enddo
      enddo
   end subroutine fmeq_d2zm2

   subroutine fmeq_z2zm2(z, ma)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      integer :: j, k
      intent (inout) :: z
      intent (in) :: ma
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                z(j, k) = cmplx(qx%runkno, qx%runkno)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmm2z(ma(j, k)%mzm, z(j, k), qx)
         enddo
      enddo
   end subroutine fmeq_z2zm2

   subroutine fmeq_c2zm2(c, ma)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      real (kind(0.0d0)) :: d, d1, d2
      integer :: j, k
      intent (inout) :: c
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                d = qx%runkno
                c(j, k) = cmplx(d, d , kind(0.0d0))
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmreal(ma(j, k)%mzm, mtlvfm, qx)
            call fmm2dp(mtlvfm, d1, qx)
            call zmimag(ma(j, k)%mzm, mtlvfm, qx)
            call fmm2dp(mtlvfm, d2, qx)
            c(j, k) = cmplx(d1, d2 , kind(0.0d0))
         enddo
      enddo
   end subroutine fmeq_c2zm2

   subroutine fmeq_zm2zm2(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), allocatable, dimension(:,:) :: temp
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          call zmunknown(mtlvzm, qx)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmeq(mtlvzm, ma(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif

!             To avoid problems when lhs and rhs are overlapping parts of the same array, move mb
!             to a temporary array before re-defining any of ma.

      allocate(temp(size(ma, dim=1), size(ma, dim=2)))
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(mb(j, k)%mzm, temp(j, k)%mzm, qx)
         enddo
      enddo
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(temp(j, k)%mzm, ma(j, k)%mzm, qx)
         enddo
      enddo
      deallocate(temp)
   end subroutine fmeq_zm2zm2

!                                                                  ==

   function fmleq_ifm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'EQ', ma%mfm, qx)
   end function fmleq_ifm

   function fmleq_iim(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      return_value = imcomp(mtlvim, 'EQ', ma%mim, qx)
   end function fmleq_iim

   function fmleq_izm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      call zmreal(ma%mzm, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmimag(ma%mzm, mulvfm, qx)
      l2 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      return_value = l1.and.l2
   end function fmleq_izm

   function fmleq_rfm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'EQ', ma%mfm, qx)
   end function fmleq_rfm

   function fmleq_rim(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      qx%ndig = ndsave
   end function fmleq_rim

   function fmleq_rzm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call zmreal(ma%mzm, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmimag(ma%mzm, mulvfm, qx)
      l2 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      return_value = l1.and.l2
   end function fmleq_rzm

   function fmleq_dfm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'EQ', ma%mfm, qx)
   end function fmleq_dfm

   function fmleq_dim(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: d, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      qx%ndig = ndsave
   end function fmleq_dim

   function fmleq_dzm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call zmreal(ma%mzm, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmimag(ma%mzm, mulvfm, qx)
      l2 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      return_value = l1.and.l2
   end function fmleq_dzm

   function fmleq_zfm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(real(z), mtlvfm, qx)
      l1 = fmcomp(mtlvfm, 'EQ', ma%mfm, qx)
      l2 = .true.
      if (aimag(z) /= 0.0) l2 = .false.
      return_value = l1.and.l2
   end function fmleq_zfm

   function fmleq_zim(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (im) :: ma
      complex :: z
      integer :: ka, ndsave
      intent (in) :: z, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmsp2m(real(z), mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      qx%ndig = ndsave
      l2 = .true.
      if (aimag(z) /= 0.0) l2 = .false.
      return_value = l1.and.l2
   end function fmleq_zim

   function fmleq_zzm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call zmreal(mtlvzm, mtlvfm, qx)
      call zmreal(ma%mzm, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      call zmimag(mtlvzm, mtlvfm, qx)
      call zmimag(ma%mzm, mulvfm, qx)
      l2 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      return_value = l1.and.l2
   end function fmleq_zzm

   function fmleq_cfm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      l1 = fmcomp(mtlvfm, 'EQ', ma%mfm, qx)
      l2 = .true.
      if (aimag(c) /= 0.0) l2 = .false.
      return_value = l1.and.l2
   end function fmleq_cfm

   function fmleq_cim(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      integer :: ka, ndsave
      intent (in) :: c, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      qx%ndig = ndsave
      l2 = .true.
      if (aimag(c) /= 0.0) l2 = .false.
      return_value = l1.and.l2
   end function fmleq_cim

   function fmleq_czm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call zmreal(ma%mzm, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      call fmdp2m(aimag(c), mtlvfm, qx)
      call zmimag(ma%mzm, mulvfm, qx)
      l2 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      return_value = l1.and.l2
   end function fmleq_czm

   function fmleq_fmi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'EQ', mtlvfm, qx)
   end function fmleq_fmi

   function fmleq_fmr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'EQ', mtlvfm, qx)
   end function fmleq_fmr

   function fmleq_fmd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'EQ', mtlvfm, qx)
   end function fmleq_fmd

   function fmleq_fmz(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(real(z), mtlvfm, qx)
      l1 = fmcomp(ma%mfm, 'EQ', mtlvfm, qx)
      l2 = .true.
      if (aimag(z) /= 0.0) l2 = .false.
      return_value = l1.and.l2
   end function fmleq_fmz

   function fmleq_fmc(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      l1 = fmcomp(ma%mfm, 'EQ', mtlvfm, qx)
      l2 = .true.
      if (aimag(c) /= 0.0) l2 = .false.
      return_value = l1.and.l2
   end function fmleq_fmc

   function fmleq_fmfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma, mb
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      return_value = fmcomp(ma%mfm, 'EQ', mb%mfm, qx)
   end function fmleq_fmfm

   function fmleq_fmim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      type (im) :: mb
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmint(ma%mfm, mtlvfm, qx)
      if (fmcomp(ma%mfm, 'EQ', mtlvfm, qx)) then
          call imi2fm(mb%mim, mtlvfm, qx)
          return_value = fmcomp(ma%mfm, 'EQ', mtlvfm, qx)
      else
          return_value = .false.
      endif
   end function fmleq_fmim

   function fmleq_fmzm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: ma
      type (zm) :: mb
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call zmreal(mb%mzm, mtlvfm, qx)
      l1 = fmcomp(ma%mfm, 'EQ', mtlvfm, qx)
      l2 = .true.
      if (mb%mzm(2)%mp(3) /= 0) l2 = .false.
      return_value = l1.and.l2
   end function fmleq_fmzm

   function fmleq_imi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      return_value = imcomp(ma%mim, 'EQ', mtlvim, qx)
   end function fmleq_imi

   function fmleq_imr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mulvfm, 'EQ', mtlvfm, qx)
      qx%ndig = ndsave
   end function fmleq_imr

   function fmleq_imd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mulvfm, 'EQ', mtlvfm, qx)
      qx%ndig = ndsave
   end function fmleq_imd

   function fmleq_imz(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (im) :: ma
      complex :: z
      integer :: ka, ndsave
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmsp2m(real(z), mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      l1 = fmcomp(mulvfm, 'EQ', mtlvfm, qx)
      qx%ndig = ndsave
      l2 = .true.
      if (aimag(z) /= 0.0) l2 = .false.
      return_value = l1.and.l2
   end function fmleq_imz

   function fmleq_imc(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      integer :: ka, ndsave
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      l1 = fmcomp(mulvfm, 'EQ', mtlvfm, qx)
      qx%ndig = ndsave
      l2 = .true.
      if (aimag(c) /= 0.0) l2 = .false.
      return_value = l1.and.l2
   end function fmleq_imc

   function fmleq_imfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      type (fm) :: mb
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmint(mb%mfm, mtlvfm, qx)
      if (fmcomp(mb%mfm, 'EQ', mtlvfm, qx)) then
          call imi2fm(ma%mim, mtlvfm, qx)
          return_value = fmcomp(mb%mfm, 'EQ', mtlvfm, qx)
      else
          return_value = .false.
      endif
   end function fmleq_imfm

   function fmleq_imim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma, mb
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      return_value = imcomp(ma%mim, 'EQ', mb%mim, qx)
   end function fmleq_imim

   function fmleq_imzm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      type (zm) :: mb
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call zmreal(mb%mzm, mtlvfm, qx)
      call fmint(mtlvfm, mulvfm, qx)
      if (fmcomp(mulvfm, 'EQ', mtlvfm, qx).and.mb%mzm(2)%mp(3) == 0) then
          call imi2fm(ma%mim, mulvfm, qx)
          return_value = fmcomp(mulvfm, 'EQ', mtlvfm, qx)
      else
          return_value = .false.
      endif
   end function fmleq_imzm

   function fmleq_zmi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (zm) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call zmreal(ma%mzm, mtlvfm, qx)
      call fmint(mtlvfm, mulvfm, qx)
      if (fmcomp(mulvfm, 'EQ', mtlvfm, qx).and.ma%mzm(2)%mp(3) == 0) then
          call fmi2m(ival, mulvfm, qx)
          return_value = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      else
          return_value = .false.
      endif
   end function fmleq_zmi

   function fmleq_zmr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call zmreal(ma%mzm, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmimag(ma%mzm, mulvfm, qx)
      l2 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      return_value = l1.and.l2
   end function fmleq_zmr

   function fmleq_zmd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call zmreal(ma%mzm, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmimag(ma%mzm, mulvfm, qx)
      l2 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      return_value = l1.and.l2
   end function fmleq_zmd

   function fmleq_zmz(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call zmreal(mtlvzm, mtlvfm, qx)
      call zmreal(ma%mzm, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      call zmimag(mtlvzm, mtlvfm, qx)
      call zmimag(ma%mzm, mulvfm, qx)
      l2 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      return_value = l1.and.l2
   end function fmleq_zmz

   function fmleq_zmc(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call zmreal(ma%mzm, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      call fmdp2m(aimag(c), mtlvfm, qx)
      call zmimag(ma%mzm, mulvfm, qx)
      l2 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      return_value = l1.and.l2
   end function fmleq_zmc

   function fmleq_zmfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: mb
      type (zm) :: ma
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call zmreal(ma%mzm, mtlvfm, qx)
      l1 = fmcomp(mb%mfm, 'EQ', mtlvfm, qx)
      l2 = .true.
      if (ma%mzm(2)%mp(3) /= 0) l2 = .false.
      return_value = l1.and.l2
   end function fmleq_zmfm

   function fmleq_zmim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: mb
      type (zm) :: ma
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call zmreal(ma%mzm, mtlvfm, qx)
      call fmint(mtlvfm, mulvfm, qx)
      if (fmcomp(mulvfm, 'EQ', mtlvfm, qx).and.ma%mzm(2)%mp(3) == 0) then
          call imi2fm(mb%mim, mulvfm, qx)
          return_value = fmcomp(mulvfm, 'EQ', mtlvfm, qx)
      else
          return_value = .false.
      endif
   end function fmleq_zmim

   function fmleq_zmzm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma, mb
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call zmreal(ma%mzm, mtlvfm, qx)
      call zmreal(mb%mzm, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      call zmimag(ma%mzm, mtlvfm, qx)
      call zmimag(mb%mzm, mulvfm, qx)
      l2 = fmcomp(mtlvfm, 'EQ', mulvfm, qx)
      return_value = l1.and.l2
   end function fmleq_zmzm

 end module fmzm_2_parallel

 module fmzm_3_parallel
    use fmzm_1_parallel

    interface operator (/=)
       module procedure fmlne_ifm
       module procedure fmlne_iim
       module procedure fmlne_izm
       module procedure fmlne_rfm
       module procedure fmlne_rim
       module procedure fmlne_rzm
       module procedure fmlne_dfm
       module procedure fmlne_dim
       module procedure fmlne_dzm
       module procedure fmlne_zfm
       module procedure fmlne_zim
       module procedure fmlne_zzm
       module procedure fmlne_cfm
       module procedure fmlne_cim
       module procedure fmlne_czm
       module procedure fmlne_fmi
       module procedure fmlne_fmr
       module procedure fmlne_fmd
       module procedure fmlne_fmz
       module procedure fmlne_fmc
       module procedure fmlne_fmfm
       module procedure fmlne_fmim
       module procedure fmlne_fmzm
       module procedure fmlne_imi
       module procedure fmlne_imr
       module procedure fmlne_imd
       module procedure fmlne_imz
       module procedure fmlne_imc
       module procedure fmlne_imfm
       module procedure fmlne_imim
       module procedure fmlne_imzm
       module procedure fmlne_zmi
       module procedure fmlne_zmr
       module procedure fmlne_zmd
       module procedure fmlne_zmz
       module procedure fmlne_zmc
       module procedure fmlne_zmfm
       module procedure fmlne_zmim
       module procedure fmlne_zmzm
    end interface

    interface operator (>)
       module procedure fmlgt_ifm
       module procedure fmlgt_iim
       module procedure fmlgt_rfm
       module procedure fmlgt_rim
       module procedure fmlgt_dfm
       module procedure fmlgt_dim
       module procedure fmlgt_fmi
       module procedure fmlgt_fmr
       module procedure fmlgt_fmd
       module procedure fmlgt_fmfm
       module procedure fmlgt_fmim
       module procedure fmlgt_imi
       module procedure fmlgt_imr
       module procedure fmlgt_imd
       module procedure fmlgt_imfm
       module procedure fmlgt_imim
    end interface

    interface operator (>=)
       module procedure fmlge_ifm
       module procedure fmlge_iim
       module procedure fmlge_rfm
       module procedure fmlge_rim
       module procedure fmlge_dfm
       module procedure fmlge_dim
       module procedure fmlge_fmi
       module procedure fmlge_fmr
       module procedure fmlge_fmd
       module procedure fmlge_fmfm
       module procedure fmlge_fmim
       module procedure fmlge_imi
       module procedure fmlge_imr
       module procedure fmlge_imd
       module procedure fmlge_imfm
       module procedure fmlge_imim
    end interface

    interface operator (<)
       module procedure fmllt_ifm
       module procedure fmllt_iim
       module procedure fmllt_rfm
       module procedure fmllt_rim
       module procedure fmllt_dfm
       module procedure fmllt_dim
       module procedure fmllt_fmi
       module procedure fmllt_fmr
       module procedure fmllt_fmd
       module procedure fmllt_fmfm
       module procedure fmllt_fmim
       module procedure fmllt_imi
       module procedure fmllt_imr
       module procedure fmllt_imd
       module procedure fmllt_imfm
       module procedure fmllt_imim
    end interface

    interface operator (<=)
       module procedure fmlle_ifm
       module procedure fmlle_iim
       module procedure fmlle_rfm
       module procedure fmlle_rim
       module procedure fmlle_dfm
       module procedure fmlle_dim
       module procedure fmlle_fmi
       module procedure fmlle_fmr
       module procedure fmlle_fmd
       module procedure fmlle_fmfm
       module procedure fmlle_fmim
       module procedure fmlle_imi
       module procedure fmlle_imr
       module procedure fmlle_imd
       module procedure fmlle_imfm
       module procedure fmlle_imim
    end interface

 contains

!                                                                  /=

   function fmlne_ifm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'NE', ma%mfm, qx)
   end function fmlne_ifm

   function fmlne_iim(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      return_value = imcomp(mtlvim, 'NE', ma%mim, qx)
   end function fmlne_iim

   function fmlne_izm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      call zmreal(ma%mzm, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmimag(ma%mzm, mulvfm, qx)
      l2 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      return_value = l1.or.l2
   end function fmlne_izm

   function fmlne_rfm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'NE', ma%mfm, qx)
   end function fmlne_rfm

   function fmlne_rim(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      real :: r
      integer :: ka, ndsave
      intent (in) :: r, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      qx%ndig = ndsave
   end function fmlne_rim

   function fmlne_rzm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call zmreal(ma%mzm, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmimag(ma%mzm, mulvfm, qx)
      l2 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      return_value = l1.or.l2
   end function fmlne_rzm

   function fmlne_dfm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'NE', ma%mfm, qx)
   end function fmlne_dfm

   function fmlne_dim(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: d, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      qx%ndig = ndsave
   end function fmlne_dim

   function fmlne_dzm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call zmreal(ma%mzm, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmimag(ma%mzm, mulvfm, qx)
      l2 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      return_value = l1.or.l2
   end function fmlne_dzm

   function fmlne_zfm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(real(z), mtlvfm, qx)
      l1 = fmcomp(mtlvfm, 'NE', ma%mfm, qx)
      l2 = .false.
      if (aimag(z) /= 0.0) l2 = .true.
      return_value = l1.or.l2
   end function fmlne_zfm

   function fmlne_zim(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      complex :: z
      intent (in) :: z, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmsp2m(real(z), mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      qx%ndig = ndsave
      l2 = .false.
      if (aimag(z) /= 0.0) l2 = .true.
      return_value = l1.or.l2
   end function fmlne_zim

   function fmlne_zzm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call zmreal(mtlvzm, mtlvfm, qx)
      call zmreal(ma%mzm, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      call zmimag(mtlvzm, mtlvfm, qx)
      call zmimag(ma%mzm, mulvfm, qx)
      l2 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      return_value = l1.or.l2
   end function fmlne_zzm

   function fmlne_cfm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      l1 = fmcomp(mtlvfm, 'NE', ma%mfm, qx)
      l2 = .false.
      if (aimag(c) /= 0.0) l2 = .true.
      return_value = l1.or.l2
   end function fmlne_cfm

   function fmlne_cim(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      integer :: ka, ndsave
      intent (in) :: c, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      qx%ndig = ndsave
      l2 = .false.
      if (aimag(c) /= 0.0) l2 = .true.
      return_value = l1.or.l2
   end function fmlne_cim

   function fmlne_czm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call zmreal(ma%mzm, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      call fmdp2m(aimag(c), mtlvfm, qx)
      call zmimag(ma%mzm, mulvfm, qx)
      l2 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      return_value = l1.or.l2
   end function fmlne_czm

   function fmlne_fmi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'NE', mtlvfm, qx)
   end function fmlne_fmi

   function fmlne_fmr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'NE', mtlvfm, qx)
   end function fmlne_fmr

   function fmlne_fmd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'NE', mtlvfm, qx)
   end function fmlne_fmd

   function fmlne_fmz(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(real(z), mtlvfm, qx)
      l1 = fmcomp(ma%mfm, 'NE', mtlvfm, qx)
      l2 = .false.
      if (aimag(z) /= 0.0) l2 = .true.
      return_value = l1.or.l2
   end function fmlne_fmz

   function fmlne_fmc(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      l1 = fmcomp(ma%mfm, 'NE', mtlvfm, qx)
      l2 = .false.
      if (aimag(c) /= 0.0) l2 = .true.
      return_value = l1.or.l2
   end function fmlne_fmc

   function fmlne_fmfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma, mb
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      return_value = fmcomp(ma%mfm, 'NE', mb%mfm, qx)
   end function fmlne_fmfm

   function fmlne_fmim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      type (im) :: mb
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmint(ma%mfm, mtlvfm, qx)
      if (fmcomp(ma%mfm, 'EQ', mtlvfm, qx)) then
          call imi2fm(mb%mim, mtlvfm, qx)
          return_value = fmcomp(ma%mfm, 'NE', mtlvfm, qx)
      else
          return_value = .true.
      endif
   end function fmlne_fmim

   function fmlne_fmzm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: ma
      type (zm) :: mb
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call zmreal(mb%mzm, mtlvfm, qx)
      l1 = fmcomp(ma%mfm, 'NE', mtlvfm, qx)
      l2 = .false.
      if (mb%mzm(2)%mp(3) /= 0) l2 = .true.
      return_value = l1.or.l2
   end function fmlne_fmzm

   function fmlne_imi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      return_value = imcomp(ma%mim, 'NE', mtlvim, qx)
   end function fmlne_imi

   function fmlne_imr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mulvfm, 'NE', mtlvfm, qx)
      qx%ndig = ndsave
   end function fmlne_imr

   function fmlne_imd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mulvfm, 'NE', mtlvfm, qx)
      qx%ndig = ndsave
   end function fmlne_imd

   function fmlne_imz(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmsp2m(real(z), mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      l1 = fmcomp(mulvfm, 'NE', mtlvfm, qx)
      qx%ndig = ndsave
      l2 = .false.
      if (aimag(z) /= 0.0) l2 = .true.
      return_value = l1.or.l2
   end function fmlne_imz

   function fmlne_imc(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      integer :: ka, ndsave
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      l1 = fmcomp(mulvfm, 'NE', mtlvfm, qx)
      qx%ndig = ndsave
      l2 = .false.
      if (aimag(c) /= 0.0) l2 = .true.
      return_value = l1.or.l2
   end function fmlne_imc

   function fmlne_imfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      type (fm) :: mb
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmint(mb%mfm, mtlvfm, qx)
      if (fmcomp(mb%mfm, 'EQ', mtlvfm, qx)) then
          call imi2fm(ma%mim, mtlvfm, qx)
          return_value = fmcomp(mb%mfm, 'NE', mtlvfm, qx)
      else
          return_value = .true.
      endif
   end function fmlne_imfm

   function fmlne_imim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma, mb
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      return_value = imcomp(ma%mim, 'NE', mb%mim, qx)
   end function fmlne_imim

   function fmlne_imzm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      type (zm) :: mb
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call zmreal(mb%mzm, mtlvfm, qx)
      call fmint(mtlvfm, mulvfm, qx)
      if (fmcomp(mulvfm, 'EQ', mtlvfm, qx).and.mb%mzm(2)%mp(3) == 0) then
          call imi2fm(ma%mim, mulvfm, qx)
          return_value = fmcomp(mulvfm, 'NE', mtlvfm, qx)
      else
          return_value = .true.
      endif
   end function fmlne_imzm

   function fmlne_zmi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (zm) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call zmreal(ma%mzm, mtlvfm, qx)
      call fmint(mtlvfm, mulvfm, qx)
      if (fmcomp(mulvfm, 'EQ', mtlvfm, qx).and.ma%mzm(2)%mp(3) == 0) then
          call fmi2m(ival, mulvfm, qx)
          return_value = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      else
          return_value = .true.
      endif
   end function fmlne_zmi

   function fmlne_zmr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call zmreal(ma%mzm, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmimag(ma%mzm, mulvfm, qx)
      l2 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      return_value = l1.or.l2
   end function fmlne_zmr

   function fmlne_zmd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call zmreal(ma%mzm, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmimag(ma%mzm, mulvfm, qx)
      l2 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      return_value = l1.or.l2
   end function fmlne_zmd

   function fmlne_zmz(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call zmreal(mtlvzm, mtlvfm, qx)
      call zmreal(ma%mzm, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      call zmimag(mtlvzm, mtlvfm, qx)
      call zmimag(ma%mzm, mulvfm, qx)
      l2 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      return_value = l1.or.l2
   end function fmlne_zmz

   function fmlne_zmc(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call zmreal(ma%mzm, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      call fmdp2m(aimag(c), mtlvfm, qx)
      call zmimag(ma%mzm, mulvfm, qx)
      l2 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      return_value = l1.or.l2
   end function fmlne_zmc

   function fmlne_zmfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: mb
      type (zm) :: ma
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call zmreal(ma%mzm, mtlvfm, qx)
      l1 = fmcomp(mb%mfm, 'NE', mtlvfm, qx)
      l2 = .false.
      if (ma%mzm(2)%mp(3) /= 0) l2 = .true.
      return_value = l1.or.l2
   end function fmlne_zmfm

   function fmlne_zmim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: mb
      type (zm) :: ma
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call zmreal(ma%mzm, mtlvfm, qx)
      call fmint(mtlvfm, mulvfm, qx)
      if (fmcomp(mulvfm, 'EQ', mtlvfm, qx).and.ma%mzm(2)%mp(3) == 0) then
          call imi2fm(mb%mim, mulvfm, qx)
          return_value = fmcomp(mulvfm, 'NE', mtlvfm, qx)
      else
          return_value = .true.
      endif
   end function fmlne_zmim

   function fmlne_zmzm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma, mb
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call zmreal(ma%mzm, mtlvfm, qx)
      call zmreal(mb%mzm, mulvfm, qx)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      call zmimag(ma%mzm, mtlvfm, qx)
      call zmimag(mb%mzm, mulvfm, qx)
      l2 = fmcomp(mtlvfm, 'NE', mulvfm, qx)
      return_value = l1.or.l2
   end function fmlne_zmzm

!                                                                   >

   function fmlgt_ifm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'GT', ma%mfm, qx)
   end function fmlgt_ifm

   function fmlgt_iim(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      return_value = imcomp(mtlvim, 'GT', ma%mim, qx)
   end function fmlgt_iim

   function fmlgt_rfm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'GT', ma%mfm, qx)
   end function fmlgt_rfm

   function fmlgt_rim(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mtlvfm, 'GT', mulvfm, qx)
      qx%ndig = ndsave
   end function fmlgt_rim

   function fmlgt_dfm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'GT', ma%mfm, qx)
   end function fmlgt_dfm

   function fmlgt_dim(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: d, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mtlvfm, 'GT', mulvfm, qx)
      qx%ndig = ndsave
   end function fmlgt_dim

   function fmlgt_fmi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'GT', mtlvfm, qx)
   end function fmlgt_fmi

   function fmlgt_fmr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'GT', mtlvfm, qx)
   end function fmlgt_fmr

   function fmlgt_fmd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'GT', mtlvfm, qx)
   end function fmlgt_fmd

   function fmlgt_fmfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma, mb
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      return_value = fmcomp(ma%mfm, 'GT', mb%mfm, qx)
   end function fmlgt_fmfm

   function fmlgt_fmim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      type (im) :: mb
      integer :: ka, ndsave
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = mb%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call imi2fm(mb%mim, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'GT', mtlvfm, qx)
      qx%ndig = ndsave
   end function fmlgt_fmim

   function fmlgt_imi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      return_value = imcomp(ma%mim, 'GT', mtlvim, qx)
   end function fmlgt_imi

   function fmlgt_imr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mulvfm, 'GT', mtlvfm, qx)
      qx%ndig = ndsave
   end function fmlgt_imr

   function fmlgt_imd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mulvfm, 'GT', mtlvfm, qx)
      qx%ndig = ndsave
   end function fmlgt_imd

   function fmlgt_imfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      type (fm) :: mb
      integer :: ka, ndsave
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'GT', mb%mfm, qx)
      qx%ndig = ndsave
   end function fmlgt_imfm

   function fmlgt_imim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma, mb
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      return_value = imcomp(ma%mim, 'GT', mb%mim, qx)
   end function fmlgt_imim

!                                                                  >=

   function fmlge_ifm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'GE', ma%mfm, qx)
   end function fmlge_ifm

   function fmlge_iim(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      return_value = imcomp(mtlvim, 'GE', ma%mim, qx)
   end function fmlge_iim

   function fmlge_rfm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'GE', ma%mfm, qx)
   end function fmlge_rfm

   function fmlge_rim(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mtlvfm, 'GE', mulvfm, qx)
      qx%ndig = ndsave
   end function fmlge_rim

   function fmlge_dfm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'GE', ma%mfm, qx)
   end function fmlge_dfm

   function fmlge_dim(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: d, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mtlvfm, 'GE', mulvfm, qx)
      qx%ndig = ndsave
   end function fmlge_dim

   function fmlge_fmi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'GE', mtlvfm, qx)
   end function fmlge_fmi

   function fmlge_fmr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'GE', mtlvfm, qx)
   end function fmlge_fmr

   function fmlge_fmd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'GE', mtlvfm, qx)
   end function fmlge_fmd

   function fmlge_fmfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma, mb
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      return_value = fmcomp(ma%mfm, 'GE', mb%mfm, qx)
   end function fmlge_fmfm

   function fmlge_fmim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      type (im) :: mb
      integer :: ka, ndsave
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = mb%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call imi2fm(mb%mim, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'GE', mtlvfm, qx)
      qx%ndig = ndsave
   end function fmlge_fmim

   function fmlge_imi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      return_value = imcomp(ma%mim, 'GE', mtlvim, qx)
   end function fmlge_imi

   function fmlge_imr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mulvfm, 'GE', mtlvfm, qx)
      qx%ndig = ndsave
   end function fmlge_imr

   function fmlge_imd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mulvfm, 'GE', mtlvfm, qx)
      qx%ndig = ndsave
   end function fmlge_imd

   function fmlge_imfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      type (fm) :: mb
      integer :: ka, ndsave
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'GE', mb%mfm, qx)
      qx%ndig = ndsave
   end function fmlge_imfm

   function fmlge_imim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma, mb
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      return_value = imcomp(ma%mim, 'GE', mb%mim, qx)
   end function fmlge_imim

!                                                                   <

   function fmllt_ifm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'LT', ma%mfm, qx)
   end function fmllt_ifm

   function fmllt_iim(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      return_value = imcomp(mtlvim, 'LT', ma%mim, qx)
   end function fmllt_iim

   function fmllt_rfm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'LT', ma%mfm, qx)
   end function fmllt_rfm

   function fmllt_rim(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mtlvfm, 'LT', mulvfm, qx)
      qx%ndig = ndsave
   end function fmllt_rim

   function fmllt_dfm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'LT', ma%mfm, qx)
   end function fmllt_dfm

   function fmllt_dim(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: d, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mtlvfm, 'LT', mulvfm, qx)
      qx%ndig = ndsave
   end function fmllt_dim

   function fmllt_fmi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'LT', mtlvfm, qx)
   end function fmllt_fmi

   function fmllt_fmr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'LT', mtlvfm, qx)
   end function fmllt_fmr

   function fmllt_fmd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'LT', mtlvfm, qx)
   end function fmllt_fmd

   function fmllt_fmfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma, mb
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      return_value = fmcomp(ma%mfm, 'LT', mb%mfm, qx)
   end function fmllt_fmfm

   function fmllt_fmim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      type (im) :: mb
      integer :: ka, ndsave
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = mb%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call imi2fm(mb%mim, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'LT', mtlvfm, qx)
      qx%ndig = ndsave
   end function fmllt_fmim

   function fmllt_imi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      return_value = imcomp(ma%mim, 'LT', mtlvim, qx)
   end function fmllt_imi

   function fmllt_imr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mulvfm, 'LT', mtlvfm, qx)
      qx%ndig = ndsave
   end function fmllt_imr

   function fmllt_imd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mulvfm, 'LT', mtlvfm, qx)
      qx%ndig = ndsave
   end function fmllt_imd

   function fmllt_imfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      type (fm) :: mb
      integer :: ka, ndsave
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'LT', mb%mfm, qx)
      qx%ndig = ndsave
   end function fmllt_imfm

   function fmllt_imim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma, mb
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      return_value = imcomp(ma%mim, 'LT', mb%mim, qx)
   end function fmllt_imim

!                                                                  <=

   function fmlle_ifm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'LE', ma%mfm, qx)
   end function fmlle_ifm

   function fmlle_iim(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      return_value = imcomp(mtlvim, 'LE', ma%mim, qx)
   end function fmlle_iim

   function fmlle_rfm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'LE', ma%mfm, qx)
   end function fmlle_rfm

   function fmlle_rim(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mtlvfm, 'LE', mulvfm, qx)
      qx%ndig = ndsave
   end function fmlle_rim

   function fmlle_dfm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'LE', ma%mfm, qx)
   end function fmlle_dfm

   function fmlle_dim(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: d, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mtlvfm, 'LE', mulvfm, qx)
      qx%ndig = ndsave
   end function fmlle_dim

   function fmlle_fmi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'LE', mtlvfm, qx)
   end function fmlle_fmi

   function fmlle_fmr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'LE', mtlvfm, qx)
   end function fmlle_fmr

   function fmlle_fmd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'LE', mtlvfm, qx)
   end function fmlle_fmd

   function fmlle_fmfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma, mb
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      return_value = fmcomp(ma%mfm, 'LE', mb%mfm, qx)
   end function fmlle_fmfm

   function fmlle_fmim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      type (im) :: mb
      integer :: ka, ndsave
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = mb%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call imi2fm(mb%mim, mtlvfm, qx)
      return_value = fmcomp(ma%mfm, 'LE', mtlvfm, qx)
      qx%ndig = ndsave
   end function fmlle_fmim

   function fmlle_imi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      return_value = imcomp(ma%mim, 'LE', mtlvim, qx)
   end function fmlle_imi

   function fmlle_imr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mulvfm, 'LE', mtlvfm, qx)
      qx%ndig = ndsave
   end function fmlle_imr

   function fmlle_imd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      return_value = fmcomp(mulvfm, 'LE', mtlvfm, qx)
      qx%ndig = ndsave
   end function fmlle_imd

   function fmlle_imfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      type (fm) :: mb
      integer :: ka, ndsave
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      ka = ma%mim%mp(2)
      call fmndig(max(ka+qx%ngrd52, qx%ndig), qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      return_value = fmcomp(mtlvfm, 'LE', mb%mfm, qx)
      qx%ndig = ndsave
   end function fmlle_imfm

   function fmlle_imim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma, mb
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      return_value = imcomp(ma%mim, 'LE', mb%mim, qx)
   end function fmlle_imim

 end module fmzm_3_parallel

 module fmzm_4_parallel
    use fmzm_1_parallel

    interface operator (+)
       module procedure fmadd_ifm
       module procedure fmadd_iim
       module procedure fmadd_izm
       module procedure fmadd_rfm
       module procedure fmadd_rim
       module procedure fmadd_rzm
       module procedure fmadd_dfm
       module procedure fmadd_dim
       module procedure fmadd_dzm
       module procedure fmadd_zfm
       module procedure fmadd_zim
       module procedure fmadd_zzm
       module procedure fmadd_cfm
       module procedure fmadd_cim
       module procedure fmadd_czm
       module procedure fmadd_fmi
       module procedure fmadd_fmr
       module procedure fmadd_fmd
       module procedure fmadd_fmz
       module procedure fmadd_fmc
       module procedure fmadd_fmfm
       module procedure fmadd_fmim
       module procedure fmadd_fmzm
       module procedure fmadd_imi
       module procedure fmadd_imr
       module procedure fmadd_imd
       module procedure fmadd_imz
       module procedure fmadd_imc
       module procedure fmadd_imfm
       module procedure fmadd_imim
       module procedure fmadd_imzm
       module procedure fmadd_zmi
       module procedure fmadd_zmr
       module procedure fmadd_zmd
       module procedure fmadd_zmz
       module procedure fmadd_zmc
       module procedure fmadd_zmfm
       module procedure fmadd_zmim
       module procedure fmadd_zmzm
       module procedure fmadd_fm
       module procedure fmadd_im
       module procedure fmadd_zm
       module procedure fmadd_ifm1
       module procedure fmadd_rfm1
       module procedure fmadd_dfm1
       module procedure fmadd_zfm1
       module procedure fmadd_cfm1
       module procedure fmadd_fmi1
       module procedure fmadd_fmr1
       module procedure fmadd_fmd1
       module procedure fmadd_fmz1
       module procedure fmadd_fmc1
       module procedure fmadd_fmfm1
       module procedure fmadd_imfm1
       module procedure fmadd_zmfm1
       module procedure fmadd_fmim1
       module procedure fmadd_fmzm1
       module procedure fmadd_fm1i
       module procedure fmadd_fm1r
       module procedure fmadd_fm1d
       module procedure fmadd_fm1z
       module procedure fmadd_fm1c
       module procedure fmadd_i1fm
       module procedure fmadd_r1fm
       module procedure fmadd_d1fm
       module procedure fmadd_z1fm
       module procedure fmadd_c1fm
       module procedure fmadd_fm1fm
       module procedure fmadd_fm1im
       module procedure fmadd_fm1zm
       module procedure fmadd_im1fm
       module procedure fmadd_zm1fm
       module procedure fmadd_i1fm1
       module procedure fmadd_r1fm1
       module procedure fmadd_d1fm1
       module procedure fmadd_z1fm1
       module procedure fmadd_c1fm1
       module procedure fmadd_fm1i1
       module procedure fmadd_fm1r1
       module procedure fmadd_fm1d1
       module procedure fmadd_fm1z1
       module procedure fmadd_fm1c1
       module procedure fmadd_fm1fm1
       module procedure fmadd_im1fm1
       module procedure fmadd_zm1fm1
       module procedure fmadd_fm1im1
       module procedure fmadd_fm1zm1
       module procedure fmadd_iim1
       module procedure fmadd_rim1
       module procedure fmadd_dim1
       module procedure fmadd_zim1
       module procedure fmadd_cim1
       module procedure fmadd_imi1
       module procedure fmadd_imr1
       module procedure fmadd_imd1
       module procedure fmadd_imz1
       module procedure fmadd_imc1
       module procedure fmadd_imim1
       module procedure fmadd_zmim1
       module procedure fmadd_imzm1
       module procedure fmadd_im1i
       module procedure fmadd_im1r
       module procedure fmadd_im1d
       module procedure fmadd_im1z
       module procedure fmadd_im1c
       module procedure fmadd_i1im
       module procedure fmadd_r1im
       module procedure fmadd_d1im
       module procedure fmadd_z1im
       module procedure fmadd_c1im
       module procedure fmadd_im1im
       module procedure fmadd_im1zm
       module procedure fmadd_zm1im
       module procedure fmadd_i1im1
       module procedure fmadd_r1im1
       module procedure fmadd_d1im1
       module procedure fmadd_z1im1
       module procedure fmadd_c1im1
       module procedure fmadd_im1i1
       module procedure fmadd_im1r1
       module procedure fmadd_im1d1
       module procedure fmadd_im1z1
       module procedure fmadd_im1c1
       module procedure fmadd_im1im1
       module procedure fmadd_zm1im1
       module procedure fmadd_im1zm1
       module procedure fmadd_izm1
       module procedure fmadd_rzm1
       module procedure fmadd_dzm1
       module procedure fmadd_zzm1
       module procedure fmadd_czm1
       module procedure fmadd_zmi1
       module procedure fmadd_zmr1
       module procedure fmadd_zmd1
       module procedure fmadd_zmz1
       module procedure fmadd_zmc1
       module procedure fmadd_zmzm1
       module procedure fmadd_zm1i
       module procedure fmadd_zm1r
       module procedure fmadd_zm1d
       module procedure fmadd_zm1z
       module procedure fmadd_zm1c
       module procedure fmadd_i1zm
       module procedure fmadd_r1zm
       module procedure fmadd_d1zm
       module procedure fmadd_z1zm
       module procedure fmadd_c1zm
       module procedure fmadd_zm1zm
       module procedure fmadd_i1zm1
       module procedure fmadd_r1zm1
       module procedure fmadd_d1zm1
       module procedure fmadd_z1zm1
       module procedure fmadd_c1zm1
       module procedure fmadd_zm1i1
       module procedure fmadd_zm1r1
       module procedure fmadd_zm1d1
       module procedure fmadd_zm1z1
       module procedure fmadd_zm1c1
       module procedure fmadd_zm1zm1
       module procedure fmadd_ifm2
       module procedure fmadd_rfm2
       module procedure fmadd_dfm2
       module procedure fmadd_zfm2
       module procedure fmadd_cfm2
       module procedure fmadd_fmi2
       module procedure fmadd_fmr2
       module procedure fmadd_fmd2
       module procedure fmadd_fmz2
       module procedure fmadd_fmc2
       module procedure fmadd_fmfm2
       module procedure fmadd_imfm2
       module procedure fmadd_zmfm2
       module procedure fmadd_fmim2
       module procedure fmadd_fmzm2
       module procedure fmadd_fm2i
       module procedure fmadd_fm2r
       module procedure fmadd_fm2d
       module procedure fmadd_fm2z
       module procedure fmadd_fm2c
       module procedure fmadd_i2fm
       module procedure fmadd_r2fm
       module procedure fmadd_d2fm
       module procedure fmadd_z2fm
       module procedure fmadd_c2fm
       module procedure fmadd_fm2fm
       module procedure fmadd_fm2im
       module procedure fmadd_fm2zm
       module procedure fmadd_im2fm
       module procedure fmadd_zm2fm
       module procedure fmadd_i2fm2
       module procedure fmadd_r2fm2
       module procedure fmadd_d2fm2
       module procedure fmadd_z2fm2
       module procedure fmadd_c2fm2
       module procedure fmadd_fm2i2
       module procedure fmadd_fm2r2
       module procedure fmadd_fm2d2
       module procedure fmadd_fm2z2
       module procedure fmadd_fm2c2
       module procedure fmadd_fm2fm2
       module procedure fmadd_im2fm2
       module procedure fmadd_zm2fm2
       module procedure fmadd_fm2im2
       module procedure fmadd_fm2zm2
       module procedure fmadd_iim2
       module procedure fmadd_rim2
       module procedure fmadd_dim2
       module procedure fmadd_zim2
       module procedure fmadd_cim2
       module procedure fmadd_imi2
       module procedure fmadd_imr2
       module procedure fmadd_imd2
       module procedure fmadd_imz2
       module procedure fmadd_imc2
       module procedure fmadd_imim2
       module procedure fmadd_zmim2
       module procedure fmadd_imzm2
       module procedure fmadd_im2i
       module procedure fmadd_im2r
       module procedure fmadd_im2d
       module procedure fmadd_im2z
       module procedure fmadd_im2c
       module procedure fmadd_i2im
       module procedure fmadd_r2im
       module procedure fmadd_d2im
       module procedure fmadd_z2im
       module procedure fmadd_c2im
       module procedure fmadd_im2im
       module procedure fmadd_im2zm
       module procedure fmadd_zm2im
       module procedure fmadd_i2im2
       module procedure fmadd_r2im2
       module procedure fmadd_d2im2
       module procedure fmadd_z2im2
       module procedure fmadd_c2im2
       module procedure fmadd_im2i2
       module procedure fmadd_im2r2
       module procedure fmadd_im2d2
       module procedure fmadd_im2z2
       module procedure fmadd_im2c2
       module procedure fmadd_im2im2
       module procedure fmadd_zm2im2
       module procedure fmadd_im2zm2
       module procedure fmadd_izm2
       module procedure fmadd_rzm2
       module procedure fmadd_dzm2
       module procedure fmadd_zzm2
       module procedure fmadd_czm2
       module procedure fmadd_zmi2
       module procedure fmadd_zmr2
       module procedure fmadd_zmd2
       module procedure fmadd_zmz2
       module procedure fmadd_zmc2
       module procedure fmadd_zmzm2
       module procedure fmadd_zm2i
       module procedure fmadd_zm2r
       module procedure fmadd_zm2d
       module procedure fmadd_zm2z
       module procedure fmadd_zm2c
       module procedure fmadd_i2zm
       module procedure fmadd_r2zm
       module procedure fmadd_d2zm
       module procedure fmadd_z2zm
       module procedure fmadd_c2zm
       module procedure fmadd_zm2zm
       module procedure fmadd_i2zm2
       module procedure fmadd_r2zm2
       module procedure fmadd_d2zm2
       module procedure fmadd_z2zm2
       module procedure fmadd_c2zm2
       module procedure fmadd_zm2i2
       module procedure fmadd_zm2r2
       module procedure fmadd_zm2d2
       module procedure fmadd_zm2z2
       module procedure fmadd_zm2c2
       module procedure fmadd_zm2zm2
       module procedure fmadd_fm1
       module procedure fmadd_im1
       module procedure fmadd_zm1
       module procedure fmadd_fm2
       module procedure fmadd_im2
       module procedure fmadd_zm2
    end interface

 contains

!                                                                   +

   function fmadd_ifm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      call fmadd(mtlvfm, ma%mfm, return_value%mfm, qx)
   end function fmadd_ifm

   function fmadd_iim(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      call imadd(mtlvim, ma%mim, return_value%mim, qx)
   end function fmadd_iim

   function fmadd_izm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmadd(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmadd_izm

   function fmadd_rfm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmadd(mtlvfm, ma%mfm, return_value%mfm, qx)
   end function fmadd_rfm

   function fmadd_rim(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      call fmadd(mtlvfm, mulvfm, return_value%mfm, qx)
   end function fmadd_rim

   function fmadd_rzm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmadd(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmadd_rzm

   function fmadd_dfm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmadd(mtlvfm, ma%mfm, return_value%mfm, qx)
   end function fmadd_dfm

   function fmadd_dim(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      call fmadd(mtlvfm, mulvfm, return_value%mfm, qx)
   end function fmadd_dim

   function fmadd_dzm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmadd(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmadd_dzm

   function fmadd_zfm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
      call zmadd(mtlvzm, mulvzm, return_value%mzm, qx)
   end function fmadd_zfm

   function fmadd_zim(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmadd(mtlvzm, mulvzm, return_value%mzm, qx)
   end function fmadd_zim

   function fmadd_zzm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      complex :: z
      intent (in) :: z, ma
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call zmadd(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmadd_zzm

   function fmadd_cfm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
      call zmadd(mtlvzm, mulvzm, return_value%mzm, qx)
   end function fmadd_cfm

   function fmadd_cim(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmadd(mtlvzm, mulvzm, return_value%mzm, qx)
   end function fmadd_cim

   function fmadd_czm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmadd(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmadd_czm

   function fmadd_fmi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      call fmadd(ma%mfm, mtlvfm, return_value%mfm, qx)
   end function fmadd_fmi

   function fmadd_fmr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmadd(ma%mfm, mtlvfm, return_value%mfm, qx)
   end function fmadd_fmr

   function fmadd_fmd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmadd(ma%mfm, mtlvfm, return_value%mfm, qx)
   end function fmadd_fmd

   function fmadd_fmz(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
      call zmadd(mulvzm, mtlvzm, return_value%mzm, qx)
   end function fmadd_fmz

   function fmadd_fmc(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
      call zmadd(mulvzm, mtlvzm, return_value%mzm, qx)
   end function fmadd_fmc

   function fmadd_fmfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call fmadd(ma%mfm, mb%mfm, return_value%mfm, qx)
   end function fmadd_fmfm

   function fmadd_fmim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      type (im) :: mb
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(mb%mim, mtlvfm, qx)
      call fmadd(ma%mfm, mtlvfm, return_value%mfm, qx)
   end function fmadd_fmim

   function fmadd_fmzm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (zm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm, qx)
      call zmadd(mtlvzm, mb%mzm, return_value%mzm, qx)
   end function fmadd_fmzm

   function fmadd_imi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      call imadd(ma%mim, mtlvim, return_value%mim, qx)
   end function fmadd_imi

   function fmadd_imr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      call fmadd(mulvfm, mtlvfm, return_value%mfm, qx)
   end function fmadd_imr

   function fmadd_imd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      call fmadd(mulvfm, mtlvfm, return_value%mfm, qx)
   end function fmadd_imd

   function fmadd_imz(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmadd(mulvzm, mtlvzm, return_value%mzm, qx)
   end function fmadd_imz

   function fmadd_imc(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmadd(mulvzm, mtlvzm, return_value%mzm, qx)
   end function fmadd_imc

   function fmadd_imfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (fm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmadd(mtlvfm, mb%mfm, return_value%mfm, qx)
   end function fmadd_imfm

   function fmadd_imim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call imadd(ma%mim, mb%mim, return_value%mim, qx)
   end function fmadd_imim

   function fmadd_imzm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (zm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mulvfm, mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmadd(mulvzm, mb%mzm, return_value%mzm, qx)
   end function fmadd_imzm

   function fmadd_zmi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmadd(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmadd_zmi

   function fmadd_zmr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmadd(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmadd_zmr

   function fmadd_zmd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmadd(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmadd_zmd

   function fmadd_zmz(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call zmadd(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmadd_zmz

   function fmadd_zmc(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmadd(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmadd_zmc

   function fmadd_zmfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: mb
      type (zm) :: ma, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm, qx)
      call zmadd(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmadd_zmfm

   function fmadd_zmim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: mb
      type (zm) :: ma, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mulvfm, mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(mb%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmadd(ma%mzm, mulvzm, return_value%mzm, qx)
   end function fmadd_zmim

   function fmadd_zmzm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call zmadd(ma%mzm, mb%mzm, return_value%mzm, qx)
   end function fmadd_zmzm

   function fmadd_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmeq(ma%mfm, return_value%mfm, qx)
   end function fmadd_fm

   function fmadd_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call imeq(ma%mim, return_value%mim, qx)
   end function fmadd_im

   function fmadd_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmeq(ma%mzm, return_value%mzm, qx)
   end function fmadd_zm

!             Array addition operations for FM.

!             (1) rank 0  +  rank 1

   function fmadd_ifm1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(ival, mtlvfm, qx)
      do j = 1, n
         call fmadd(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_ifm1

   function fmadd_rfm1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, n
         call fmadd(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_rfm1

   function fmadd_dfm1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, n
         call fmadd(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_dfm1

   function fmadd_zfm1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zfm1

   function fmadd_cfm1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_cfm1

   function fmadd_fmi1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm, qx)
         call fmadd(ma%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_fmi1

   function fmadd_fmr1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmadd(ma%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_fmr1

   function fmadd_fmd1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmadd(ma%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_fmd1

   function fmadd_fmz1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_fmz1

   function fmadd_fmc1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_fmc1

   function fmadd_fmfm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(mb)
      do j = 1, n
         call fmadd(ma%mfm, mb(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_fmfm1

   function fmadd_imfm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(mb)
      call imi2fm(ma%mim, mtlvfm, qx)
      do j = 1, n
         call fmadd(mtlvfm, mb(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_imfm1

   function fmadd_zmfm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (fm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(mb)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n	
         call zmcmpx(mb(j)%mfm, mtlvfm, mtlvzm, qx)
         call zmadd(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zmfm1

   function fmadd_fmim1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (im), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(mb)
      do j = 1, n
         call imi2fm(mb(j)%mim, mtlvfm, qx)
         call fmadd(ma%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_fmim1

   function fmadd_fmzm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(mb)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm, qx)
      do j = 1, n
         call zmadd(mtlvzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_fmzm1

!             (2) rank 1  +  rank 0

   function fmadd_fm1i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(ival, mtlvfm, qx)
      do j = 1, n
         call fmadd(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_fm1i

   function fmadd_fm1r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, n
         call fmadd(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_fm1r

   function fmadd_fm1d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, n
         call fmadd(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_fm1d

   function fmadd_fm1z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_fm1z

   function fmadd_fm1c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_fm1c

   function fmadd_i1fm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm, qx)
         call fmadd(mtlvfm, ma%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_i1fm

   function fmadd_r1fm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmadd(mtlvfm, ma%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_r1fm

   function fmadd_d1fm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmadd(mtlvfm, ma%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_d1fm

   function fmadd_z1fm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_z1fm

   function fmadd_c1fm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_c1fm

   function fmadd_fm1fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmadd(ma(j)%mfm, mb%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_fm1fm

   function fmadd_fm1im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (im) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call imi2fm(mb%mim, mtlvfm, qx)
      do j = 1, n
         call fmadd(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_fm1im

   function fmadd_fm1zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mtlvfm, mtlvzm, qx)
         call zmadd(mtlvzm, mb%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_fm1zm

   function fmadd_im1fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call fmadd(mtlvfm, mb%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_im1fm

   function fmadd_zm1fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (fm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm, qx)
      do j = 1, n
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zm1fm

!             (3) rank 1  +  rank 1

   function fmadd_fm1i1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm, qx)
         call fmadd(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_fm1i1

   function fmadd_fm1r1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmadd(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_fm1r1

   function fmadd_fm1d1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmadd(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_fm1d1

   function fmadd_fm1z1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_fm1z1

   function fmadd_fm1c1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_fm1c1

   function fmadd_i1fm1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm, qx)
         call fmadd(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_i1fm1

   function fmadd_r1fm1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmadd(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_r1fm1

   function fmadd_d1fm1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmadd(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_d1fm1

   function fmadd_z1fm1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(z)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_z1fm1

   function fmadd_c1fm1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_c1fm1

   function fmadd_fm1fm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmadd(ma(j)%mfm, mb(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_fm1fm1

   function fmadd_fm1im1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2fm(mb(j)%mim, mtlvfm, qx)
         call fmadd(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_fm1im1

   function fmadd_fm1zm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mtlvfm, mtlvzm, qx)
         call zmadd(mtlvzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_fm1zm1

   function fmadd_im1fm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call fmadd(mtlvfm, mb(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_im1fm1

   function fmadd_zm1fm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call zmcmpx(mb(j)%mfm, mtlvfm, mtlvzm, qx)
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zm1fm1

!             (4) rank 0  +  rank 2

   function fmadd_ifm2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmadd(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_ifm2

   function fmadd_rfm2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmadd(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_rfm2

   function fmadd_dfm2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmadd(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_dfm2

   function fmadd_zfm2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zfm2

   function fmadd_cfm2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_cfm2

   function fmadd_fmi2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call fmi2m(ival(j, k), mtlvfm, qx)
            call fmadd(ma%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_fmi2

   function fmadd_fmr2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmadd(ma%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_fmr2

   function fmadd_fmd2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmadd(ma%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_fmd2

   function fmadd_fmz2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_fmz2

   function fmadd_fmc2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_fmc2

   function fmadd_fmfm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call fmadd(ma%mfm, mb(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_fmfm2

   function fmadd_imfm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call fmadd(mtlvfm, mb(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_imfm2

   function fmadd_zmfm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (fm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmcmpx(mb(j, k)%mfm, mtlvfm, mtlvzm, qx)
            call zmadd(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zmfm2

   function fmadd_fmim2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (im), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imi2fm(mb(j, k)%mim, mtlvfm, qx)
            call fmadd(ma%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_fmim2

   function fmadd_fmzm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm, qx)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmadd(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_fmzm2

!             (5) rank 2  +  rank 0

   function fmadd_fm2i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmadd(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_fm2i

   function fmadd_fm2r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmadd(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_fm2r

   function fmadd_fm2d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmadd(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_fm2d

   function fmadd_fm2z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_fm2z

   function fmadd_fm2c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_fm2c

   function fmadd_i2fm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call fmi2m(ival(j, k), mtlvfm, qx)
            call fmadd(mtlvfm, ma%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_i2fm

   function fmadd_r2fm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmadd(mtlvfm, ma%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_r2fm

   function fmadd_d2fm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmadd(mtlvfm, ma%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_d2fm

   function fmadd_z2fm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_z2fm

   function fmadd_c2fm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_c2fm

   function fmadd_fm2fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmadd(ma(j, k)%mfm, mb%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_fm2fm

   function fmadd_fm2im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(mb%mim, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmadd(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_fm2im

   function fmadd_fm2zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mtlvfm, mtlvzm, qx)
            call zmadd(mtlvzm, mb%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_fm2zm

   function fmadd_im2fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call fmadd(mtlvfm, mb%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_im2fm

   function fmadd_zm2fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zm2fm

!             (6) rank 2  +  rank 2

   function fmadd_fm2i2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm, qx)
            call fmadd(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_fm2i2

   function fmadd_fm2r2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmadd(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_fm2r2

   function fmadd_fm2d2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmadd(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_fm2d2

   function fmadd_fm2z2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_fm2z2

   function fmadd_fm2c2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_fm2c2

   function fmadd_i2fm2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm, qx)
            call fmadd(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_i2fm2

   function fmadd_r2fm2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmadd(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_r2fm2

   function fmadd_d2fm2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmadd(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_d2fm2

   function fmadd_z2fm2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_z2fm2

   function fmadd_c2fm2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_c2fm2

   function fmadd_fm2fm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmadd(ma(j, k)%mfm, mb(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_fm2fm2

   function fmadd_fm2im2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(mb(j, k)%mim, mtlvfm, qx)
            call fmadd(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_fm2im2

   function fmadd_fm2zm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mtlvfm, mtlvzm, qx)
            call zmadd(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_fm2zm2

   function fmadd_im2fm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call fmadd(mtlvfm, mb(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_im2fm2

   function fmadd_zm2fm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(mb(j, k)%mfm, mtlvfm, mtlvzm, qx)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zm2fm2

!             Array addition operations for IM.

!             (1) rank 0  +  rank 1

   function fmadd_iim1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      n = size(ma)
      call imi2m(ival, mtlvim, qx)
      do j = 1, n
         call imadd(mtlvim, ma(j)%mim, return_value(j)%mim, qx)
      enddo
   end function fmadd_iim1

   function fmadd_rim1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mulvfm, qx)
         call fmadd(mtlvfm, mulvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_rim1

   function fmadd_dim1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mulvfm, qx)
         call fmadd(mtlvfm, mulvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_dim1

   function fmadd_zim1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zim1

   function fmadd_cim1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_cim1

   function fmadd_imi1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim, qx)
         call imadd(ma%mim, mtlvim, return_value(j)%mim, qx)
      enddo
   end function fmadd_imi1

   function fmadd_imr1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      n = size(r)
      call imi2fm(ma%mim, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmadd(mulvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_imr1

   function fmadd_imd1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      n = size(d)
      call imi2fm(ma%mim, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmadd(mulvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_imd1

   function fmadd_imz1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_imz1

   function fmadd_imc1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_imc1

   function fmadd_imim1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (im), dimension(:) :: mb
      type (im), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(mb)
      do j = 1, n
         call imadd(ma%mim, mb(j)%mim, return_value(j)%mim, qx)
      enddo
   end function fmadd_imim1

   function fmadd_zmim1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (im), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mvlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(mb)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call imi2fm(mb(j)%mim, mvlvfm, qx)
         call zmcmpx(mvlvfm, mtlvfm, mtlvzm, qx)
         call zmadd(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zmim1

   function fmadd_imzm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mvlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(mb)
      call imi2fm(ma%mim, mvlvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mvlvfm, mtlvfm, mtlvzm, qx)
      do j = 1, n
         call zmadd(mtlvzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_imzm1

!             (2) rank 1  +  rank 0

   function fmadd_im1i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      n = size(ma)
      call imi2m(ival, mtlvim, qx)
      do j = 1, n
         call imadd(ma(j)%mim, mtlvim, return_value(j)%mim, qx)
      enddo
   end function fmadd_im1i

   function fmadd_im1r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm, qx)
         call fmadd(mvlvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_im1r

   function fmadd_im1d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm, qx)
         call fmadd(mvlvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_im1d

   function fmadd_im1z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm, qx)
         call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_im1z

   function fmadd_im1c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm, qx)
         call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_im1c

   function fmadd_i1im(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim, qx)
         call imadd(mtlvim, ma%mim, return_value(j)%mim, qx)
      enddo
   end function fmadd_i1im

   function fmadd_r1im(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      n = size(r)
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmadd(mtlvfm, mvlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_r1im

   function fmadd_d1im(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      n = size(d)
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmadd(mtlvfm, mvlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_d1im

   function fmadd_z1im(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      call imi2fm(ma%mim, mvlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_z1im

   function fmadd_c1im(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      call imi2fm(ma%mim, m1lvfm, qx)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_c1im

   function fmadd_im1im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im) :: mb
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call imadd(ma(j)%mim, mb%mim, return_value(j)%mim, qx)
      enddo
   end function fmadd_im1im

   function fmadd_im1zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
         call zmadd(m1lvzm, mb%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_im1zm

   function fmadd_zm1im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (im) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call imi2fm(mb%mim, m1lvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
      do j = 1, n
         call zmadd(ma(j)%mzm, m1lvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zm1im

!             (3) rank 1  +  rank 1

   function fmadd_im1i1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2m(ival(j), mtlvim, qx)
         call imadd(ma(j)%mim, mtlvim, return_value(j)%mim, qx)
      enddo
   end function fmadd_im1i1

   function fmadd_im1r1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmadd(m1lvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_im1r1

   function fmadd_im1d1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmadd(m1lvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_im1d1

   function fmadd_im1z1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_im1z1

   function fmadd_im1c1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_im1c1

   function fmadd_i1im1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim, qx)
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim, qx)
         call imadd(mtlvim, ma(j)%mim, return_value(j)%mim, qx)
      enddo
   end function fmadd_i1im1

   function fmadd_r1im1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmsp2m(r(j), mtlvfm, qx)
         call fmadd(mtlvfm, m1lvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_r1im1

   function fmadd_d1im1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmdp2m(d(j), mtlvfm, qx)
         call fmadd(mtlvfm, m1lvfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_d1im1

   function fmadd_z1im1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(z)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_z1im1

   function fmadd_c1im1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_c1im1

   function fmadd_im1im1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imadd(ma(j)%mim, mb(j)%mim, return_value(j)%mim, qx)
      enddo
   end function fmadd_im1im1

   function fmadd_im1zm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
         call zmadd(m1lvzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_im1zm1

   function fmadd_zm1im1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call imi2fm(mb(j)%mim, m1lvfm, qx)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
         call zmadd(ma(j)%mzm, m1lvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zm1im1

!             (4) rank 0  +  rank 2

   function fmadd_iim2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imadd(mtlvim, ma(j, k)%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmadd_iim2

   function fmadd_rim2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mulvfm, qx)
            call fmadd(mtlvfm, mulvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_rim2

   function fmadd_dim2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mulvfm, qx)
            call fmadd(mtlvfm, mulvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_dim2

   function fmadd_zim2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zim2

   function fmadd_cim2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_cim2

   function fmadd_imi2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call imi2m(ival(j, k), mtlvim, qx)
            call imadd(ma%mim, mtlvim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmadd_imi2

   function fmadd_imr2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mulvfm, qx)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmadd(mulvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_imr2

   function fmadd_imd2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mulvfm, qx)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmadd(mulvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_imd2

   function fmadd_imz2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_imz2

   function fmadd_imc2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_imc2

   function fmadd_imim2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (im), dimension(:,:) :: mb
      type (im), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imadd(ma%mim, mb(j, k)%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmadd_imim2

   function fmadd_zmim2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (im), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mvlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imi2fm(mb(j, k)%mim, mvlvfm, qx)
            call zmcmpx(mvlvfm, mtlvfm, mtlvzm, qx)
            call zmadd(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zmim2

   function fmadd_imzm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mvlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mvlvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mvlvfm, mtlvfm, mtlvzm, qx)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmadd(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_imzm2

!             (5) rank 2  +  rank 0

   function fmadd_im2i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imadd(ma(j, k)%mim, mtlvim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmadd_im2i

   function fmadd_im2r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm, qx)
            call fmadd(mvlvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_im2r

   function fmadd_im2d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm, qx)
            call fmadd(mvlvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_im2d

   function fmadd_im2z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm, qx)
            call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_im2z

   function fmadd_im2c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm, qx)
            call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_im2c

   function fmadd_i2im(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call imi2m(ival(j, k), mtlvim, qx)
            call imadd(mtlvim, ma%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmadd_i2im

   function fmadd_r2im(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmadd(mtlvfm, mvlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_r2im

   function fmadd_d2im(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmadd(mtlvfm, mvlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_d2im

   function fmadd_z2im(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mvlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_z2im

   function fmadd_c2im(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, m1lvfm, qx)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_c2im

   function fmadd_im2im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im) :: mb
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imadd(ma(j, k)%mim, mb%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmadd_im2im

   function fmadd_im2zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
            call zmadd(m1lvzm, mb%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_im2zm

   function fmadd_zm2im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      call imi2fm(mb%mim, m1lvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(ma(j, k)%mzm, m1lvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zm2im

!             (6) rank 2  +  rank 2

   function fmadd_im2i2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2m(ival(j, k), mtlvim, qx)
            call imadd(ma(j, k)%mim, mtlvim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmadd_im2i2

   function fmadd_im2r2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmadd(m1lvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_im2r2

   function fmadd_im2d2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmadd(m1lvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_im2d2

   function fmadd_im2z2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_im2z2

   function fmadd_im2c2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_im2c2

   function fmadd_i2im2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2m(ival(j, k), mtlvim, qx)
            call imadd(mtlvim, ma(j, k)%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmadd_i2im2

   function fmadd_r2im2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmadd(mtlvfm, m1lvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_r2im2

   function fmadd_d2im2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmadd(mtlvfm, m1lvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_d2im2

   function fmadd_z2im2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_z2im2

   function fmadd_c2im2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_c2im2

   function fmadd_im2im2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imadd(ma(j, k)%mim, mb(j, k)%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmadd_im2im2

   function fmadd_im2zm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
            call zmadd(m1lvzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_im2zm2

   function fmadd_zm2im2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(mb(j, k)%mim, m1lvfm, qx)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
            call zmadd(ma(j, k)%mzm, m1lvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zm2im2

!             Array addition operations for ZM.

!             (1) rank 0  +  rank 1

   function fmadd_izm1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmi2m(ival, mtlvzm, qx)
      do j = 1, n
         call zmadd(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_izm1

   function fmadd_rzm1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmadd(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_rzm1

   function fmadd_dzm1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmadd(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_dzm1

   function fmadd_zzm1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      do j = 1, n
         call zmadd(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zzm1

   function fmadd_czm1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmadd(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_czm1

   function fmadd_zmi1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm, qx)
         call zmadd(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zmi1

   function fmadd_zmr1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(r)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmadd(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zmr1

   function fmadd_zmd1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(d)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmadd(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zmd1

   function fmadd_zmz1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmadd(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zmz1

   function fmadd_zmc1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmadd(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zmc1

   function fmadd_zmzm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(mb)
      do j = 1, n
         call zmadd(ma%mzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zmzm1

!             (2) rank 1  +  rank 0

   function fmadd_zm1i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(ival, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zm1i

   function fmadd_zm1r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zm1r

   function fmadd_zm1d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zm1d

   function fmadd_zm1z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      do j = 1, n
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zm1z

   function fmadd_zm1c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zm1c

   function fmadd_i1zm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm, qx)
         call zmadd(mtlvzm, ma%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_i1zm

   function fmadd_r1zm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(r)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmadd(mtlvzm, ma%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_r1zm

   function fmadd_d1zm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(d)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmadd(mtlvzm, ma%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_d1zm

   function fmadd_z1zm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmadd(mtlvzm, ma%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_z1zm

   function fmadd_c1zm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmadd(mtlvzm, ma%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_c1zm

   function fmadd_zm1zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmadd(ma(j)%mzm, mb%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zm1zm

!             (3) rank 1  +  rank 1

   function fmadd_zm1i1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm, qx)
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zm1i1

   function fmadd_zm1r1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zm1r1

   function fmadd_zm1d1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zm1d1

   function fmadd_zm1z1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zm1z1

   function fmadd_zm1c1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zm1c1

   function fmadd_i1zm1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ival)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmadd(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_i1zm1

   function fmadd_r1zm1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(r)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmadd(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_r1zm1

   function fmadd_d1zm1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(d)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmadd(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_d1zm1

   function fmadd_z1zm1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmadd(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_z1zm1

   function fmadd_c1zm1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmadd(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_c1zm1

   function fmadd_zm1zm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmadd(ma(j)%mzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zm1zm1

!             (4) rank 0  +  rank 2

   function fmadd_izm2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmi2m(ival, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_izm2

   function fmadd_rzm2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_rzm2

   function fmadd_dzm2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_dzm2

   function fmadd_zzm2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zzm2

   function fmadd_czm2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_czm2

   function fmadd_zmi2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call zmi2m(ival(j, k), mtlvzm, qx)
            call zmadd(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zmi2

   function fmadd_zmr2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmadd(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zmr2

   function fmadd_zmd2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmadd(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zmd2

   function fmadd_zmz2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmadd(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zmz2

   function fmadd_zmc2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmadd(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zmc2

   function fmadd_zmzm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmadd(ma%mzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zmzm2

!             (5) rank 2  +  rank 0

   function fmadd_zm2i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zm2i

   function fmadd_zm2r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zm2r

   function fmadd_zm2d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zm2d

   function fmadd_zm2z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zm2z

   function fmadd_zm2c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zm2c

   function fmadd_i2zm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call zmi2m(ival(j, k), mtlvzm, qx)
            call zmadd(mtlvzm, ma%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_i2zm

   function fmadd_r2zm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmadd(mtlvzm, ma%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_r2zm

   function fmadd_d2zm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmadd(mtlvzm, ma%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_d2zm

   function fmadd_z2zm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmadd(mtlvzm, ma%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_z2zm

   function fmadd_c2zm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmadd(mtlvzm, ma%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_c2zm

   function fmadd_zm2zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(ma(j, k)%mzm, mb%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zm2zm

!             (6) rank 2  +  rank 2

   function fmadd_zm2i2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmi2m(ival(j, k), mtlvzm, qx)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zm2i2

   function fmadd_zm2r2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zm2r2

   function fmadd_zm2d2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zm2d2

   function fmadd_zm2z2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zm2z2

   function fmadd_zm2c2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zm2c2

   function fmadd_i2zm2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmadd(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_i2zm2

   function fmadd_r2zm2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmadd(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_r2zm2

   function fmadd_d2zm2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmadd(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_d2zm2

   function fmadd_z2zm2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmadd(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_z2zm2

   function fmadd_c2zm2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmadd(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_c2zm2

   function fmadd_zm2zm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(ma(j, k)%mzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zm2zm2

   function fmadd_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmeq(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmadd_fm1

   function fmadd_im1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call imeq(ma(j)%mim, return_value(j)%mim, qx)
      enddo
   end function fmadd_im1

   function fmadd_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmeq(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmadd_zm1

   function fmadd_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmadd_fm2

   function fmadd_im2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(ma(j, k)%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmadd_im2

   function fmadd_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmadd_zm2

 end module fmzm_4_parallel

 module fmzm_5_parallel
    use fmzm_1_parallel

    interface operator (-)
       module procedure fmsub_ifm
       module procedure fmsub_iim
       module procedure fmsub_izm
       module procedure fmsub_rfm
       module procedure fmsub_rim
       module procedure fmsub_rzm
       module procedure fmsub_dfm
       module procedure fmsub_dim
       module procedure fmsub_dzm
       module procedure fmsub_zfm
       module procedure fmsub_zim
       module procedure fmsub_zzm
       module procedure fmsub_cfm
       module procedure fmsub_cim
       module procedure fmsub_czm
       module procedure fmsub_fmi
       module procedure fmsub_fmr
       module procedure fmsub_fmd
       module procedure fmsub_fmz
       module procedure fmsub_fmc
       module procedure fmsub_fmfm
       module procedure fmsub_fmim
       module procedure fmsub_fmzm
       module procedure fmsub_imi
       module procedure fmsub_imr
       module procedure fmsub_imd
       module procedure fmsub_imz
       module procedure fmsub_imc
       module procedure fmsub_imfm
       module procedure fmsub_imim
       module procedure fmsub_imzm
       module procedure fmsub_zmi
       module procedure fmsub_zmr
       module procedure fmsub_zmd
       module procedure fmsub_zmz
       module procedure fmsub_zmc
       module procedure fmsub_zmfm
       module procedure fmsub_zmim
       module procedure fmsub_zmzm
       module procedure fmsub_fm
       module procedure fmsub_im
       module procedure fmsub_zm
       module procedure fmsub_ifm1
       module procedure fmsub_rfm1
       module procedure fmsub_dfm1
       module procedure fmsub_zfm1
       module procedure fmsub_cfm1
       module procedure fmsub_fmi1
       module procedure fmsub_fmr1
       module procedure fmsub_fmd1
       module procedure fmsub_fmz1
       module procedure fmsub_fmc1
       module procedure fmsub_fmfm1
       module procedure fmsub_imfm1
       module procedure fmsub_zmfm1
       module procedure fmsub_fmim1
       module procedure fmsub_fmzm1
       module procedure fmsub_fm1i
       module procedure fmsub_fm1r
       module procedure fmsub_fm1d
       module procedure fmsub_fm1z
       module procedure fmsub_fm1c
       module procedure fmsub_i1fm
       module procedure fmsub_r1fm
       module procedure fmsub_d1fm
       module procedure fmsub_z1fm
       module procedure fmsub_c1fm
       module procedure fmsub_fm1fm
       module procedure fmsub_fm1im
       module procedure fmsub_fm1zm
       module procedure fmsub_im1fm
       module procedure fmsub_zm1fm
       module procedure fmsub_i1fm1
       module procedure fmsub_r1fm1
       module procedure fmsub_d1fm1
       module procedure fmsub_z1fm1
       module procedure fmsub_c1fm1
       module procedure fmsub_fm1i1
       module procedure fmsub_fm1r1
       module procedure fmsub_fm1d1
       module procedure fmsub_fm1z1
       module procedure fmsub_fm1c1
       module procedure fmsub_fm1fm1
       module procedure fmsub_im1fm1
       module procedure fmsub_zm1fm1
       module procedure fmsub_fm1im1
       module procedure fmsub_fm1zm1
       module procedure fmsub_iim1
       module procedure fmsub_rim1
       module procedure fmsub_dim1
       module procedure fmsub_zim1
       module procedure fmsub_cim1
       module procedure fmsub_imi1
       module procedure fmsub_imr1
       module procedure fmsub_imd1
       module procedure fmsub_imz1
       module procedure fmsub_imc1
       module procedure fmsub_imim1
       module procedure fmsub_zmim1
       module procedure fmsub_imzm1
       module procedure fmsub_im1i
       module procedure fmsub_im1r
       module procedure fmsub_im1d
       module procedure fmsub_im1z
       module procedure fmsub_im1c
       module procedure fmsub_i1im
       module procedure fmsub_r1im
       module procedure fmsub_d1im
       module procedure fmsub_z1im
       module procedure fmsub_c1im
       module procedure fmsub_im1im
       module procedure fmsub_im1zm
       module procedure fmsub_zm1im
       module procedure fmsub_i1im1
       module procedure fmsub_r1im1
       module procedure fmsub_d1im1
       module procedure fmsub_z1im1
       module procedure fmsub_c1im1
       module procedure fmsub_im1i1
       module procedure fmsub_im1r1
       module procedure fmsub_im1d1
       module procedure fmsub_im1z1
       module procedure fmsub_im1c1
       module procedure fmsub_im1im1
       module procedure fmsub_zm1im1
       module procedure fmsub_im1zm1
       module procedure fmsub_izm1
       module procedure fmsub_rzm1
       module procedure fmsub_dzm1
       module procedure fmsub_zzm1
       module procedure fmsub_czm1
       module procedure fmsub_zmi1
       module procedure fmsub_zmr1
       module procedure fmsub_zmd1
       module procedure fmsub_zmz1
       module procedure fmsub_zmc1
       module procedure fmsub_zmzm1
       module procedure fmsub_zm1i
       module procedure fmsub_zm1r
       module procedure fmsub_zm1d
       module procedure fmsub_zm1z
       module procedure fmsub_zm1c
       module procedure fmsub_i1zm
       module procedure fmsub_r1zm
       module procedure fmsub_d1zm
       module procedure fmsub_z1zm
       module procedure fmsub_c1zm
       module procedure fmsub_zm1zm
       module procedure fmsub_i1zm1
       module procedure fmsub_r1zm1
       module procedure fmsub_d1zm1
       module procedure fmsub_z1zm1
       module procedure fmsub_c1zm1
       module procedure fmsub_zm1i1
       module procedure fmsub_zm1r1
       module procedure fmsub_zm1d1
       module procedure fmsub_zm1z1
       module procedure fmsub_zm1c1
       module procedure fmsub_zm1zm1
       module procedure fmsub_ifm2
       module procedure fmsub_rfm2
       module procedure fmsub_dfm2
       module procedure fmsub_zfm2
       module procedure fmsub_cfm2
       module procedure fmsub_fmi2
       module procedure fmsub_fmr2
       module procedure fmsub_fmd2
       module procedure fmsub_fmz2
       module procedure fmsub_fmc2
       module procedure fmsub_fmfm2
       module procedure fmsub_imfm2
       module procedure fmsub_zmfm2
       module procedure fmsub_fmim2
       module procedure fmsub_fmzm2
       module procedure fmsub_fm2i
       module procedure fmsub_fm2r
       module procedure fmsub_fm2d
       module procedure fmsub_fm2z
       module procedure fmsub_fm2c
       module procedure fmsub_i2fm
       module procedure fmsub_r2fm
       module procedure fmsub_d2fm
       module procedure fmsub_z2fm
       module procedure fmsub_c2fm
       module procedure fmsub_fm2fm
       module procedure fmsub_fm2im
       module procedure fmsub_fm2zm
       module procedure fmsub_im2fm
       module procedure fmsub_zm2fm
       module procedure fmsub_i2fm2
       module procedure fmsub_r2fm2
       module procedure fmsub_d2fm2
       module procedure fmsub_z2fm2
       module procedure fmsub_c2fm2
       module procedure fmsub_fm2i2
       module procedure fmsub_fm2r2
       module procedure fmsub_fm2d2
       module procedure fmsub_fm2z2
       module procedure fmsub_fm2c2
       module procedure fmsub_fm2fm2
       module procedure fmsub_im2fm2
       module procedure fmsub_zm2fm2
       module procedure fmsub_fm2im2
       module procedure fmsub_fm2zm2
       module procedure fmsub_iim2
       module procedure fmsub_rim2
       module procedure fmsub_dim2
       module procedure fmsub_zim2
       module procedure fmsub_cim2
       module procedure fmsub_imi2
       module procedure fmsub_imr2
       module procedure fmsub_imd2
       module procedure fmsub_imz2
       module procedure fmsub_imc2
       module procedure fmsub_imim2
       module procedure fmsub_zmim2
       module procedure fmsub_imzm2
       module procedure fmsub_im2i
       module procedure fmsub_im2r
       module procedure fmsub_im2d
       module procedure fmsub_im2z
       module procedure fmsub_im2c
       module procedure fmsub_i2im
       module procedure fmsub_r2im
       module procedure fmsub_d2im
       module procedure fmsub_z2im
       module procedure fmsub_c2im
       module procedure fmsub_im2im
       module procedure fmsub_im2zm
       module procedure fmsub_zm2im
       module procedure fmsub_i2im2
       module procedure fmsub_r2im2
       module procedure fmsub_d2im2
       module procedure fmsub_z2im2
       module procedure fmsub_c2im2
       module procedure fmsub_im2i2
       module procedure fmsub_im2r2
       module procedure fmsub_im2d2
       module procedure fmsub_im2z2
       module procedure fmsub_im2c2
       module procedure fmsub_im2im2
       module procedure fmsub_zm2im2
       module procedure fmsub_im2zm2
       module procedure fmsub_izm2
       module procedure fmsub_rzm2
       module procedure fmsub_dzm2
       module procedure fmsub_zzm2
       module procedure fmsub_czm2
       module procedure fmsub_zmi2
       module procedure fmsub_zmr2
       module procedure fmsub_zmd2
       module procedure fmsub_zmz2
       module procedure fmsub_zmc2
       module procedure fmsub_zmzm2
       module procedure fmsub_zm2i
       module procedure fmsub_zm2r
       module procedure fmsub_zm2d
       module procedure fmsub_zm2z
       module procedure fmsub_zm2c
       module procedure fmsub_i2zm
       module procedure fmsub_r2zm
       module procedure fmsub_d2zm
       module procedure fmsub_z2zm
       module procedure fmsub_c2zm
       module procedure fmsub_zm2zm
       module procedure fmsub_i2zm2
       module procedure fmsub_r2zm2
       module procedure fmsub_d2zm2
       module procedure fmsub_z2zm2
       module procedure fmsub_c2zm2
       module procedure fmsub_zm2i2
       module procedure fmsub_zm2r2
       module procedure fmsub_zm2d2
       module procedure fmsub_zm2z2
       module procedure fmsub_zm2c2
       module procedure fmsub_zm2zm2
       module procedure fmsub_fm1
       module procedure fmsub_im1
       module procedure fmsub_zm1
       module procedure fmsub_fm2
       module procedure fmsub_im2
       module procedure fmsub_zm2
    end interface

 contains

!                                                                   -

   function fmsub_ifm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      call fmsub(mtlvfm, ma%mfm, return_value%mfm, qx)
   end function fmsub_ifm

   function fmsub_iim(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      call imsub(mtlvim, ma%mim, return_value%mim, qx)
   end function fmsub_iim

   function fmsub_izm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmsub(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmsub_izm

   function fmsub_rfm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmsub(mtlvfm, ma%mfm, return_value%mfm, qx)
   end function fmsub_rfm

   function fmsub_rim(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      call fmsub(mtlvfm, mulvfm, return_value%mfm, qx)
   end function fmsub_rim

   function fmsub_rzm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmsub(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmsub_rzm

   function fmsub_dfm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmsub(mtlvfm, ma%mfm, return_value%mfm, qx)
   end function fmsub_dfm

   function fmsub_dim(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      call fmsub(mtlvfm, mulvfm, return_value%mfm, qx)
   end function fmsub_dim

   function fmsub_dzm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmsub(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmsub_dzm

   function fmsub_zfm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
      call zmsub(mtlvzm, mulvzm, return_value%mzm, qx)
   end function fmsub_zfm

   function fmsub_zim(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmsub(mtlvzm, mulvzm, return_value%mzm, qx)
   end function fmsub_zim

   function fmsub_zzm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      complex :: z
      intent (in) :: z, ma
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call zmsub(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmsub_zzm

   function fmsub_cfm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
      call zmsub(mtlvzm, mulvzm, return_value%mzm, qx)
   end function fmsub_cfm

   function fmsub_cim(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmsub(mtlvzm, mulvzm, return_value%mzm, qx)
   end function fmsub_cim

   function fmsub_czm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmsub(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmsub_czm

   function fmsub_fmi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      call fmsub(ma%mfm, mtlvfm, return_value%mfm, qx)
   end function fmsub_fmi

   function fmsub_fmr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmsub(ma%mfm, mtlvfm, return_value%mfm, qx)
   end function fmsub_fmr

   function fmsub_fmd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmsub(ma%mfm, mtlvfm, return_value%mfm, qx)
   end function fmsub_fmd

   function fmsub_fmz(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
      call zmsub(mulvzm, mtlvzm, return_value%mzm, qx)
   end function fmsub_fmz

   function fmsub_fmc(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
      call zmsub(mulvzm, mtlvzm, return_value%mzm, qx)
   end function fmsub_fmc

   function fmsub_fmfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call fmsub(ma%mfm, mb%mfm, return_value%mfm, qx)
   end function fmsub_fmfm

   function fmsub_fmim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      type (im) :: mb
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(mb%mim, mtlvfm, qx)
      call fmsub(ma%mfm, mtlvfm, return_value%mfm, qx)
   end function fmsub_fmim

   function fmsub_fmzm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (zm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm, qx)
      call zmsub(mtlvzm, mb%mzm, return_value%mzm, qx)
   end function fmsub_fmzm

   function fmsub_imi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      call imsub(ma%mim, mtlvim, return_value%mim, qx)
   end function fmsub_imi

   function fmsub_imr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      call fmsub(mulvfm, mtlvfm, return_value%mfm, qx)
   end function fmsub_imr

   function fmsub_imd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      call fmsub(mulvfm, mtlvfm, return_value%mfm, qx)
   end function fmsub_imd

   function fmsub_imz(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmsub(mulvzm, mtlvzm, return_value%mzm, qx)
   end function fmsub_imz

   function fmsub_imc(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmsub(mulvzm, mtlvzm, return_value%mzm, qx)
   end function fmsub_imc

   function fmsub_imfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (fm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmsub(mtlvfm, mb%mfm, return_value%mfm, qx)
   end function fmsub_imfm

   function fmsub_imim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call imsub(ma%mim, mb%mim, return_value%mim, qx)
   end function fmsub_imim

   function fmsub_imzm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (zm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mulvfm, mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmsub(mulvzm, mb%mzm, return_value%mzm, qx)
   end function fmsub_imzm

   function fmsub_zmi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmsub(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmsub_zmi

   function fmsub_zmr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmsub(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmsub_zmr

   function fmsub_zmd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmsub(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmsub_zmd

   function fmsub_zmz(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call zmsub(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmsub_zmz

   function fmsub_zmc(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmsub(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmsub_zmc

   function fmsub_zmfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: mb
      type (zm) :: ma, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm, qx)
      call zmsub(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmsub_zmfm

   function fmsub_zmim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: mb
      type (zm) :: ma, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mulvfm, mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(mb%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmsub(ma%mzm, mulvzm, return_value%mzm, qx)
   end function fmsub_zmim

   function fmsub_zmzm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call zmsub(ma%mzm, mb%mzm, return_value%mzm, qx)
   end function fmsub_zmzm

   function fmsub_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmeq(ma%mfm, mtlvfm, qx)
      call fmnegate(mtlvfm, qx)
      call fmeq(mtlvfm, return_value%mfm, qx)
   end function fmsub_fm

   function fmsub_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, return_value
      intent (in) :: ma
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imeq(ma%mim, mtlvim, qx)
      call fmnegate(mtlvim, qx)
      call imeq(mtlvim, return_value%mim, qx)
   end function fmsub_im

   function fmsub_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmeq(ma%mzm, mtlvzm, qx)
      call fmnegate(mtlvzm(1), qx)
      call fmnegate(mtlvzm(2), qx)
      call zmeq(mtlvzm, return_value%mzm, qx)
   end function fmsub_zm

!             Array subtraction operations for FM.

!             (1) rank 0  -  rank 1

   function fmsub_ifm1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(ival, mtlvfm, qx)
      do j = 1, n
         call fmsub(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_ifm1

   function fmsub_rfm1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, n
         call fmsub(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_rfm1

   function fmsub_dfm1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, n
         call fmsub(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_dfm1

   function fmsub_zfm1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zfm1

   function fmsub_cfm1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_cfm1

   function fmsub_fmi1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm, qx)
         call fmsub(ma%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_fmi1

   function fmsub_fmr1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmsub(ma%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_fmr1

   function fmsub_fmd1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmsub(ma%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_fmd1

   function fmsub_fmz1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_fmz1

   function fmsub_fmc1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_fmc1

   function fmsub_fmfm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(mb)
      do j = 1, n
         call fmsub(ma%mfm, mb(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_fmfm1

   function fmsub_imfm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(mb)
      call imi2fm(ma%mim, mtlvfm, qx)
      do j = 1, n
         call fmsub(mtlvfm, mb(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_imfm1

   function fmsub_zmfm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (fm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(mb)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n	
         call zmcmpx(mb(j)%mfm, mtlvfm, mtlvzm, qx)
         call zmsub(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zmfm1

   function fmsub_fmim1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (im), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(mb)
      do j = 1, n
         call imi2fm(mb(j)%mim, mtlvfm, qx)
         call fmsub(ma%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_fmim1

   function fmsub_fmzm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(mb)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm, qx)
      do j = 1, n
         call zmsub(mtlvzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_fmzm1

!             (2) rank 1  -  rank 0

   function fmsub_fm1i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(ival, mtlvfm, qx)
      do j = 1, n
         call fmsub(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_fm1i

   function fmsub_fm1r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, n
         call fmsub(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_fm1r

   function fmsub_fm1d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, n
         call fmsub(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_fm1d

   function fmsub_fm1z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_fm1z

   function fmsub_fm1c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_fm1c

   function fmsub_i1fm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm, qx)
         call fmsub(mtlvfm, ma%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_i1fm

   function fmsub_r1fm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmsub(mtlvfm, ma%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_r1fm

   function fmsub_d1fm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmsub(mtlvfm, ma%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_d1fm

   function fmsub_z1fm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_z1fm

   function fmsub_c1fm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_c1fm

   function fmsub_fm1fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmsub(ma(j)%mfm, mb%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_fm1fm

   function fmsub_fm1im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (im) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call imi2fm(mb%mim, mtlvfm, qx)
      do j = 1, n
         call fmsub(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_fm1im

   function fmsub_fm1zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mtlvfm, mtlvzm, qx)
         call zmsub(mtlvzm, mb%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_fm1zm

   function fmsub_im1fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call fmsub(mtlvfm, mb%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_im1fm

   function fmsub_zm1fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (fm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm, qx)
      do j = 1, n
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zm1fm

!             (3) rank 1  -  rank 1

   function fmsub_fm1i1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm, qx)
         call fmsub(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_fm1i1

   function fmsub_fm1r1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmsub(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_fm1r1

   function fmsub_fm1d1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmsub(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_fm1d1

   function fmsub_fm1z1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_fm1z1

   function fmsub_fm1c1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_fm1c1

   function fmsub_i1fm1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm, qx)
         call fmsub(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_i1fm1

   function fmsub_r1fm1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmsub(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_r1fm1

   function fmsub_d1fm1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmsub(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_d1fm1

   function fmsub_z1fm1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(z)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_z1fm1

   function fmsub_c1fm1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_c1fm1

   function fmsub_fm1fm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsub(ma(j)%mfm, mb(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_fm1fm1

   function fmsub_fm1im1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2fm(mb(j)%mim, mtlvfm, qx)
         call fmsub(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_fm1im1

   function fmsub_fm1zm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mtlvfm, mtlvzm, qx)
         call zmsub(mtlvzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_fm1zm1

   function fmsub_im1fm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call fmsub(mtlvfm, mb(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_im1fm1

   function fmsub_zm1fm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call zmcmpx(mb(j)%mfm, mtlvfm, mtlvzm, qx)
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zm1fm1

!             (4) rank 0  -  rank 2

   function fmsub_ifm2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsub(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_ifm2

   function fmsub_rfm2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsub(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_rfm2

   function fmsub_dfm2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsub(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_dfm2

   function fmsub_zfm2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zfm2

   function fmsub_cfm2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_cfm2

   function fmsub_fmi2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call fmi2m(ival(j, k), mtlvfm, qx)
            call fmsub(ma%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_fmi2

   function fmsub_fmr2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmsub(ma%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_fmr2

   function fmsub_fmd2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmsub(ma%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_fmd2

   function fmsub_fmz2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_fmz2

   function fmsub_fmc2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_fmc2

   function fmsub_fmfm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call fmsub(ma%mfm, mb(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_fmfm2

   function fmsub_imfm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call fmsub(mtlvfm, mb(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_imfm2

   function fmsub_zmfm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (fm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmcmpx(mb(j, k)%mfm, mtlvfm, mtlvzm, qx)
            call zmsub(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zmfm2

   function fmsub_fmim2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (im), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imi2fm(mb(j, k)%mim, mtlvfm, qx)
            call fmsub(ma%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_fmim2

   function fmsub_fmzm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm, qx)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmsub(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_fmzm2

!             (5) rank 2  -  rank 0

   function fmsub_fm2i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsub(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_fm2i

   function fmsub_fm2r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsub(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_fm2r

   function fmsub_fm2d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsub(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_fm2d

   function fmsub_fm2z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_fm2z

   function fmsub_fm2c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_fm2c

   function fmsub_i2fm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call fmi2m(ival(j, k), mtlvfm, qx)
            call fmsub(mtlvfm, ma%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_i2fm

   function fmsub_r2fm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmsub(mtlvfm, ma%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_r2fm

   function fmsub_d2fm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmsub(mtlvfm, ma%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_d2fm

   function fmsub_z2fm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_z2fm

   function fmsub_c2fm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_c2fm

   function fmsub_fm2fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsub(ma(j, k)%mfm, mb%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_fm2fm

   function fmsub_fm2im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(mb%mim, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsub(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_fm2im

   function fmsub_fm2zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mtlvfm, mtlvzm, qx)
            call zmsub(mtlvzm, mb%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_fm2zm

   function fmsub_im2fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call fmsub(mtlvfm, mb%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_im2fm

   function fmsub_zm2fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zm2fm

!             (6) rank 2  -  rank 2

   function fmsub_fm2i2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm, qx)
            call fmsub(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_fm2i2

   function fmsub_fm2r2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmsub(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_fm2r2

   function fmsub_fm2d2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmsub(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_fm2d2

   function fmsub_fm2z2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_fm2z2

   function fmsub_fm2c2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_fm2c2

   function fmsub_i2fm2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm, qx)
            call fmsub(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_i2fm2

   function fmsub_r2fm2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmsub(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_r2fm2

   function fmsub_d2fm2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmsub(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_d2fm2

   function fmsub_z2fm2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_z2fm2

   function fmsub_c2fm2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_c2fm2

   function fmsub_fm2fm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsub(ma(j, k)%mfm, mb(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_fm2fm2

   function fmsub_fm2im2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(mb(j, k)%mim, mtlvfm, qx)
            call fmsub(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_fm2im2

   function fmsub_fm2zm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mtlvfm, mtlvzm, qx)
            call zmsub(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_fm2zm2

   function fmsub_im2fm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call fmsub(mtlvfm, mb(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_im2fm2

   function fmsub_zm2fm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(mb(j, k)%mfm, mtlvfm, mtlvzm, qx)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zm2fm2

!             Array subtraction operations for IM.

!             (1) rank 0  -  rank 1

   function fmsub_iim1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      n = size(ma)
      call imi2m(ival, mtlvim, qx)
      do j = 1, n
         call imsub(mtlvim, ma(j)%mim, return_value(j)%mim, qx)
      enddo
   end function fmsub_iim1

   function fmsub_rim1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mulvfm, qx)
         call fmsub(mtlvfm, mulvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_rim1

   function fmsub_dim1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mulvfm, qx)
         call fmsub(mtlvfm, mulvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_dim1

   function fmsub_zim1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zim1

   function fmsub_cim1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_cim1

   function fmsub_imi1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim, qx)
         call imsub(ma%mim, mtlvim, return_value(j)%mim, qx)
      enddo
   end function fmsub_imi1

   function fmsub_imr1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      n = size(r)
      call imi2fm(ma%mim, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmsub(mulvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_imr1

   function fmsub_imd1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      n = size(d)
      call imi2fm(ma%mim, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmsub(mulvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_imd1

   function fmsub_imz1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_imz1

   function fmsub_imc1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_imc1

   function fmsub_imim1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (im), dimension(:) :: mb
      type (im), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(mb)
      do j = 1, n
         call imsub(ma%mim, mb(j)%mim, return_value(j)%mim, qx)
      enddo
   end function fmsub_imim1

   function fmsub_zmim1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (im), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mvlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(mb)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call imi2fm(mb(j)%mim, mvlvfm, qx)
         call zmcmpx(mvlvfm, mtlvfm, mtlvzm, qx)
         call zmsub(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zmim1

   function fmsub_imzm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mvlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(mb)
      call imi2fm(ma%mim, mvlvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mvlvfm, mtlvfm, mtlvzm, qx)
      do j = 1, n
         call zmsub(mtlvzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_imzm1

!             (2) rank 1  -  rank 0

   function fmsub_im1i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      n = size(ma)
      call imi2m(ival, mtlvim, qx)
      do j = 1, n
         call imsub(ma(j)%mim, mtlvim, return_value(j)%mim, qx)
      enddo
   end function fmsub_im1i

   function fmsub_im1r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm, qx)
         call fmsub(mvlvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_im1r

   function fmsub_im1d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm, qx)
         call fmsub(mvlvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_im1d

   function fmsub_im1z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm, qx)
         call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_im1z

   function fmsub_im1c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm, qx)
         call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_im1c

   function fmsub_i1im(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim, qx)
         call imsub(mtlvim, ma%mim, return_value(j)%mim, qx)
      enddo
   end function fmsub_i1im

   function fmsub_r1im(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      n = size(r)
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmsub(mtlvfm, mvlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_r1im

   function fmsub_d1im(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      n = size(d)
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmsub(mtlvfm, mvlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_d1im

   function fmsub_z1im(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      call imi2fm(ma%mim, mvlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_z1im

   function fmsub_c1im(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      call imi2fm(ma%mim, m1lvfm, qx)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_c1im

   function fmsub_im1im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im) :: mb
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call imsub(ma(j)%mim, mb%mim, return_value(j)%mim, qx)
      enddo
   end function fmsub_im1im

   function fmsub_im1zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
         call zmsub(m1lvzm, mb%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_im1zm

   function fmsub_zm1im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (im) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call imi2fm(mb%mim, m1lvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
      do j = 1, n
         call zmsub(ma(j)%mzm, m1lvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zm1im

!             (3) rank 1  -  rank 1

   function fmsub_im1i1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2m(ival(j), mtlvim, qx)
         call imsub(ma(j)%mim, mtlvim, return_value(j)%mim, qx)
      enddo
   end function fmsub_im1i1

   function fmsub_im1r1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmsub(m1lvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_im1r1

   function fmsub_im1d1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmsub(m1lvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_im1d1

   function fmsub_im1z1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_im1z1

   function fmsub_im1c1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_im1c1

   function fmsub_i1im1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim, qx)
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim, qx)
         call imsub(mtlvim, ma(j)%mim, return_value(j)%mim, qx)
      enddo
   end function fmsub_i1im1

   function fmsub_r1im1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmsp2m(r(j), mtlvfm, qx)
         call fmsub(mtlvfm, m1lvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_r1im1

   function fmsub_d1im1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmdp2m(d(j), mtlvfm, qx)
         call fmsub(mtlvfm, m1lvfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_d1im1

   function fmsub_z1im1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(z)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_z1im1

   function fmsub_c1im1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_c1im1

   function fmsub_im1im1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imsub(ma(j)%mim, mb(j)%mim, return_value(j)%mim, qx)
      enddo
   end function fmsub_im1im1

   function fmsub_im1zm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
         call zmsub(m1lvzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_im1zm1

   function fmsub_zm1im1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call imi2fm(mb(j)%mim, m1lvfm, qx)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
         call zmsub(ma(j)%mzm, m1lvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zm1im1

!             (4) rank 0  -  rank 2

   function fmsub_iim2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imsub(mtlvim, ma(j, k)%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmsub_iim2

   function fmsub_rim2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mulvfm, qx)
            call fmsub(mtlvfm, mulvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_rim2

   function fmsub_dim2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mulvfm, qx)
            call fmsub(mtlvfm, mulvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_dim2

   function fmsub_zim2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zim2

   function fmsub_cim2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_cim2

   function fmsub_imi2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call imi2m(ival(j, k), mtlvim, qx)
            call imsub(ma%mim, mtlvim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmsub_imi2

   function fmsub_imr2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mulvfm, qx)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmsub(mulvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_imr2

   function fmsub_imd2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mulvfm, qx)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmsub(mulvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_imd2

   function fmsub_imz2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_imz2

   function fmsub_imc2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_imc2

   function fmsub_imim2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (im), dimension(:,:) :: mb
      type (im), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imsub(ma%mim, mb(j, k)%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmsub_imim2

   function fmsub_zmim2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (im), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mvlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imi2fm(mb(j, k)%mim, mvlvfm, qx)
            call zmcmpx(mvlvfm, mtlvfm, mtlvzm, qx)
            call zmsub(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zmim2

   function fmsub_imzm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mvlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mvlvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mvlvfm, mtlvfm, mtlvzm, qx)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmsub(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_imzm2

!             (5) rank 2  -  rank 0

   function fmsub_im2i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imsub(ma(j, k)%mim, mtlvim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmsub_im2i

   function fmsub_im2r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm, qx)
            call fmsub(mvlvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_im2r

   function fmsub_im2d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm, qx)
            call fmsub(mvlvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_im2d

   function fmsub_im2z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm, qx)
            call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_im2z

   function fmsub_im2c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm, qx)
            call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_im2c

   function fmsub_i2im(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call imi2m(ival(j, k), mtlvim, qx)
            call imsub(mtlvim, ma%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmsub_i2im

   function fmsub_r2im(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmsub(mtlvfm, mvlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_r2im

   function fmsub_d2im(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmsub(mtlvfm, mvlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_d2im

   function fmsub_z2im(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mvlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_z2im

   function fmsub_c2im(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, m1lvfm, qx)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_c2im

   function fmsub_im2im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im) :: mb
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imsub(ma(j, k)%mim, mb%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmsub_im2im

   function fmsub_im2zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
            call zmsub(m1lvzm, mb%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_im2zm

   function fmsub_zm2im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      call imi2fm(mb%mim, m1lvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(ma(j, k)%mzm, m1lvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zm2im

!             (6) rank 2  -  rank 2

   function fmsub_im2i2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2m(ival(j, k), mtlvim, qx)
            call imsub(ma(j, k)%mim, mtlvim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmsub_im2i2

   function fmsub_im2r2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmsub(m1lvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_im2r2

   function fmsub_im2d2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmsub(m1lvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_im2d2

   function fmsub_im2z2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_im2z2

   function fmsub_im2c2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_im2c2

   function fmsub_i2im2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2m(ival(j, k), mtlvim, qx)
            call imsub(mtlvim, ma(j, k)%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmsub_i2im2

   function fmsub_r2im2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmsub(mtlvfm, m1lvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_r2im2

   function fmsub_d2im2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmsub(mtlvfm, m1lvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_d2im2

   function fmsub_z2im2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_z2im2

   function fmsub_c2im2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_c2im2

   function fmsub_im2im2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imsub(ma(j, k)%mim, mb(j, k)%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmsub_im2im2

   function fmsub_im2zm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
            call zmsub(m1lvzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_im2zm2

   function fmsub_zm2im2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(mb(j, k)%mim, m1lvfm, qx)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
            call zmsub(ma(j, k)%mzm, m1lvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zm2im2

!             Array subtraction operations for ZM.

!             (1) rank 0  -  rank 1

   function fmsub_izm1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmi2m(ival, mtlvzm, qx)
      do j = 1, n
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_izm1

   function fmsub_rzm1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_rzm1

   function fmsub_dzm1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_dzm1

   function fmsub_zzm1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      do j = 1, n
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zzm1

   function fmsub_czm1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_czm1

   function fmsub_zmi1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm, qx)
         call zmsub(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zmi1

   function fmsub_zmr1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(r)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmsub(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zmr1

   function fmsub_zmd1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(d)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmsub(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zmd1

   function fmsub_zmz1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmsub(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zmz1

   function fmsub_zmc1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmsub(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zmc1

   function fmsub_zmzm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(mb)
      do j = 1, n
         call zmsub(ma%mzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zmzm1

!             (2) rank 1  -  rank 0

   function fmsub_zm1i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(ival, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zm1i

   function fmsub_zm1r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zm1r

   function fmsub_zm1d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zm1d

   function fmsub_zm1z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      do j = 1, n
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zm1z

   function fmsub_zm1c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zm1c

   function fmsub_i1zm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm, qx)
         call zmsub(mtlvzm, ma%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_i1zm

   function fmsub_r1zm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(r)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmsub(mtlvzm, ma%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_r1zm

   function fmsub_d1zm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(d)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmsub(mtlvzm, ma%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_d1zm

   function fmsub_z1zm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmsub(mtlvzm, ma%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_z1zm

   function fmsub_c1zm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmsub(mtlvzm, ma%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_c1zm

   function fmsub_zm1zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmsub(ma(j)%mzm, mb%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zm1zm

!             (3) rank 1  -  rank 1

   function fmsub_zm1i1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm, qx)
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zm1i1

   function fmsub_zm1r1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zm1r1

   function fmsub_zm1d1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zm1d1

   function fmsub_zm1z1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zm1z1

   function fmsub_zm1c1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zm1c1

   function fmsub_i1zm1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ival)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_i1zm1

   function fmsub_r1zm1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(r)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_r1zm1

   function fmsub_d1zm1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(d)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_d1zm1

   function fmsub_z1zm1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_z1zm1

   function fmsub_c1zm1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_c1zm1

   function fmsub_zm1zm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmsub(ma(j)%mzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zm1zm1

!             (4) rank 0  -  rank 2

   function fmsub_izm2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmi2m(ival, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_izm2

   function fmsub_rzm2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_rzm2

   function fmsub_dzm2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_dzm2

   function fmsub_zzm2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zzm2

   function fmsub_czm2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_czm2

   function fmsub_zmi2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call zmi2m(ival(j, k), mtlvzm, qx)
            call zmsub(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zmi2

   function fmsub_zmr2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmsub(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zmr2

   function fmsub_zmd2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmsub(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zmd2

   function fmsub_zmz2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmsub(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zmz2

   function fmsub_zmc2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmsub(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zmc2

   function fmsub_zmzm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmsub(ma%mzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zmzm2

!             (5) rank 2  -  rank 0

   function fmsub_zm2i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zm2i

   function fmsub_zm2r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zm2r

   function fmsub_zm2d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zm2d

   function fmsub_zm2z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zm2z

   function fmsub_zm2c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zm2c

   function fmsub_i2zm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call zmi2m(ival(j, k), mtlvzm, qx)
            call zmsub(mtlvzm, ma%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_i2zm

   function fmsub_r2zm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmsub(mtlvzm, ma%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_r2zm

   function fmsub_d2zm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmsub(mtlvzm, ma%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_d2zm

   function fmsub_z2zm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmsub(mtlvzm, ma%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_z2zm

   function fmsub_c2zm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmsub(mtlvzm, ma%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_c2zm

   function fmsub_zm2zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(ma(j, k)%mzm, mb%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zm2zm

!             (6) rank 2  -  rank 2

   function fmsub_zm2i2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmi2m(ival(j, k), mtlvzm, qx)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zm2i2

   function fmsub_zm2r2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zm2r2

   function fmsub_zm2d2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zm2d2

   function fmsub_zm2z2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zm2z2

   function fmsub_zm2c2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zm2c2

   function fmsub_i2zm2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_i2zm2

   function fmsub_r2zm2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_r2zm2

   function fmsub_d2zm2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_d2zm2

   function fmsub_z2zm2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_z2zm2

   function fmsub_c2zm2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_c2zm2

   function fmsub_zm2zm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(ma(j, k)%mzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zm2zm2

   function fmsub_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call fmsub(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmsub_fm1

   function fmsub_im1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      n = size(ma)
      call imi2m(0, mtlvim, qx)
      do j = 1, n
         call imsub(mtlvim, ma(j)%mim, return_value(j)%mim, qx)
      enddo
   end function fmsub_im1

   function fmsub_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmi2m(0, mtlvzm, qx)
      do j = 1, n
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsub_zm1

   function fmsub_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsub(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsub_fm2

   function fmsub_im2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(0, mtlvim, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imsub(mtlvim, ma(j, k)%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmsub_im2

   function fmsub_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmi2m(0, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsub_zm2

 end module fmzm_5_parallel

 module fmzm_6_parallel
    use fmzm_1_parallel

    interface operator (*)
       module procedure fmmpy_ifm
       module procedure fmmpy_iim
       module procedure fmmpy_izm
       module procedure fmmpy_rfm
       module procedure fmmpy_rim
       module procedure fmmpy_rzm
       module procedure fmmpy_dfm
       module procedure fmmpy_dim
       module procedure fmmpy_dzm
       module procedure fmmpy_zfm
       module procedure fmmpy_zim
       module procedure fmmpy_zzm
       module procedure fmmpy_cfm
       module procedure fmmpy_cim
       module procedure fmmpy_czm
       module procedure fmmpy_fmi
       module procedure fmmpy_fmr
       module procedure fmmpy_fmd
       module procedure fmmpy_fmz
       module procedure fmmpy_fmc
       module procedure fmmpy_fmfm
       module procedure fmmpy_fmim
       module procedure fmmpy_fmzm
       module procedure fmmpy_imi
       module procedure fmmpy_imr
       module procedure fmmpy_imd
       module procedure fmmpy_imz
       module procedure fmmpy_imc
       module procedure fmmpy_imfm
       module procedure fmmpy_imim
       module procedure fmmpy_imzm
       module procedure fmmpy_zmi
       module procedure fmmpy_zmr
       module procedure fmmpy_zmd
       module procedure fmmpy_zmz
       module procedure fmmpy_zmc
       module procedure fmmpy_zmfm
       module procedure fmmpy_zmim
       module procedure fmmpy_zmzm
       module procedure fmmpy_ifm1
       module procedure fmmpy_rfm1
       module procedure fmmpy_dfm1
       module procedure fmmpy_zfm1
       module procedure fmmpy_cfm1
       module procedure fmmpy_fmi1
       module procedure fmmpy_fmr1
       module procedure fmmpy_fmd1
       module procedure fmmpy_fmz1
       module procedure fmmpy_fmc1
       module procedure fmmpy_fmfm1
       module procedure fmmpy_imfm1
       module procedure fmmpy_zmfm1
       module procedure fmmpy_fmim1
       module procedure fmmpy_fmzm1
       module procedure fmmpy_fm1i
       module procedure fmmpy_fm1r
       module procedure fmmpy_fm1d
       module procedure fmmpy_fm1z
       module procedure fmmpy_fm1c
       module procedure fmmpy_i1fm
       module procedure fmmpy_r1fm
       module procedure fmmpy_d1fm
       module procedure fmmpy_z1fm
       module procedure fmmpy_c1fm
       module procedure fmmpy_fm1fm
       module procedure fmmpy_fm1im
       module procedure fmmpy_fm1zm
       module procedure fmmpy_im1fm
       module procedure fmmpy_zm1fm
       module procedure fmmpy_i1fm1
       module procedure fmmpy_r1fm1
       module procedure fmmpy_d1fm1
       module procedure fmmpy_z1fm1
       module procedure fmmpy_c1fm1
       module procedure fmmpy_fm1i1
       module procedure fmmpy_fm1r1
       module procedure fmmpy_fm1d1
       module procedure fmmpy_fm1z1
       module procedure fmmpy_fm1c1
       module procedure fmmpy_fm1fm1
       module procedure fmmpy_im1fm1
       module procedure fmmpy_zm1fm1
       module procedure fmmpy_fm1im1
       module procedure fmmpy_fm1zm1
       module procedure fmmpy_iim1
       module procedure fmmpy_rim1
       module procedure fmmpy_dim1
       module procedure fmmpy_zim1
       module procedure fmmpy_cim1
       module procedure fmmpy_imi1
       module procedure fmmpy_imr1
       module procedure fmmpy_imd1
       module procedure fmmpy_imz1
       module procedure fmmpy_imc1
       module procedure fmmpy_imim1
       module procedure fmmpy_zmim1
       module procedure fmmpy_imzm1
       module procedure fmmpy_im1i
       module procedure fmmpy_im1r
       module procedure fmmpy_im1d
       module procedure fmmpy_im1z
       module procedure fmmpy_im1c
       module procedure fmmpy_i1im
       module procedure fmmpy_r1im
       module procedure fmmpy_d1im
       module procedure fmmpy_z1im
       module procedure fmmpy_c1im
       module procedure fmmpy_im1im
       module procedure fmmpy_im1zm
       module procedure fmmpy_zm1im
       module procedure fmmpy_i1im1
       module procedure fmmpy_r1im1
       module procedure fmmpy_d1im1
       module procedure fmmpy_z1im1
       module procedure fmmpy_c1im1
       module procedure fmmpy_im1i1
       module procedure fmmpy_im1r1
       module procedure fmmpy_im1d1
       module procedure fmmpy_im1z1
       module procedure fmmpy_im1c1
       module procedure fmmpy_im1im1
       module procedure fmmpy_zm1im1
       module procedure fmmpy_im1zm1
       module procedure fmmpy_izm1
       module procedure fmmpy_rzm1
       module procedure fmmpy_dzm1
       module procedure fmmpy_zzm1
       module procedure fmmpy_czm1
       module procedure fmmpy_zmi1
       module procedure fmmpy_zmr1
       module procedure fmmpy_zmd1
       module procedure fmmpy_zmz1
       module procedure fmmpy_zmc1
       module procedure fmmpy_zmzm1
       module procedure fmmpy_zm1i
       module procedure fmmpy_zm1r
       module procedure fmmpy_zm1d
       module procedure fmmpy_zm1z
       module procedure fmmpy_zm1c
       module procedure fmmpy_i1zm
       module procedure fmmpy_r1zm
       module procedure fmmpy_d1zm
       module procedure fmmpy_z1zm
       module procedure fmmpy_c1zm
       module procedure fmmpy_zm1zm
       module procedure fmmpy_i1zm1
       module procedure fmmpy_r1zm1
       module procedure fmmpy_d1zm1
       module procedure fmmpy_z1zm1
       module procedure fmmpy_c1zm1
       module procedure fmmpy_zm1i1
       module procedure fmmpy_zm1r1
       module procedure fmmpy_zm1d1
       module procedure fmmpy_zm1z1
       module procedure fmmpy_zm1c1
       module procedure fmmpy_zm1zm1
       module procedure fmmpy_ifm2
       module procedure fmmpy_rfm2
       module procedure fmmpy_dfm2
       module procedure fmmpy_zfm2
       module procedure fmmpy_cfm2
       module procedure fmmpy_fmi2
       module procedure fmmpy_fmr2
       module procedure fmmpy_fmd2
       module procedure fmmpy_fmz2
       module procedure fmmpy_fmc2
       module procedure fmmpy_fmfm2
       module procedure fmmpy_imfm2
       module procedure fmmpy_zmfm2
       module procedure fmmpy_fmim2
       module procedure fmmpy_fmzm2
       module procedure fmmpy_fm2i
       module procedure fmmpy_fm2r
       module procedure fmmpy_fm2d
       module procedure fmmpy_fm2z
       module procedure fmmpy_fm2c
       module procedure fmmpy_i2fm
       module procedure fmmpy_r2fm
       module procedure fmmpy_d2fm
       module procedure fmmpy_z2fm
       module procedure fmmpy_c2fm
       module procedure fmmpy_fm2fm
       module procedure fmmpy_fm2im
       module procedure fmmpy_fm2zm
       module procedure fmmpy_im2fm
       module procedure fmmpy_zm2fm
       module procedure fmmpy_i2fm2
       module procedure fmmpy_r2fm2
       module procedure fmmpy_d2fm2
       module procedure fmmpy_z2fm2
       module procedure fmmpy_c2fm2
       module procedure fmmpy_fm2i2
       module procedure fmmpy_fm2r2
       module procedure fmmpy_fm2d2
       module procedure fmmpy_fm2z2
       module procedure fmmpy_fm2c2
       module procedure fmmpy_fm2fm2
       module procedure fmmpy_im2fm2
       module procedure fmmpy_zm2fm2
       module procedure fmmpy_fm2im2
       module procedure fmmpy_fm2zm2
       module procedure fmmpy_iim2
       module procedure fmmpy_rim2
       module procedure fmmpy_dim2
       module procedure fmmpy_zim2
       module procedure fmmpy_cim2
       module procedure fmmpy_imi2
       module procedure fmmpy_imr2
       module procedure fmmpy_imd2
       module procedure fmmpy_imz2
       module procedure fmmpy_imc2
       module procedure fmmpy_imim2
       module procedure fmmpy_zmim2
       module procedure fmmpy_imzm2
       module procedure fmmpy_im2i
       module procedure fmmpy_im2r
       module procedure fmmpy_im2d
       module procedure fmmpy_im2z
       module procedure fmmpy_im2c
       module procedure fmmpy_i2im
       module procedure fmmpy_r2im
       module procedure fmmpy_d2im
       module procedure fmmpy_z2im
       module procedure fmmpy_c2im
       module procedure fmmpy_im2im
       module procedure fmmpy_im2zm
       module procedure fmmpy_zm2im
       module procedure fmmpy_i2im2
       module procedure fmmpy_r2im2
       module procedure fmmpy_d2im2
       module procedure fmmpy_z2im2
       module procedure fmmpy_c2im2
       module procedure fmmpy_im2i2
       module procedure fmmpy_im2r2
       module procedure fmmpy_im2d2
       module procedure fmmpy_im2z2
       module procedure fmmpy_im2c2
       module procedure fmmpy_im2im2
       module procedure fmmpy_zm2im2
       module procedure fmmpy_im2zm2
       module procedure fmmpy_izm2
       module procedure fmmpy_rzm2
       module procedure fmmpy_dzm2
       module procedure fmmpy_zzm2
       module procedure fmmpy_czm2
       module procedure fmmpy_zmi2
       module procedure fmmpy_zmr2
       module procedure fmmpy_zmd2
       module procedure fmmpy_zmz2
       module procedure fmmpy_zmc2
       module procedure fmmpy_zmzm2
       module procedure fmmpy_zm2i
       module procedure fmmpy_zm2r
       module procedure fmmpy_zm2d
       module procedure fmmpy_zm2z
       module procedure fmmpy_zm2c
       module procedure fmmpy_i2zm
       module procedure fmmpy_r2zm
       module procedure fmmpy_d2zm
       module procedure fmmpy_z2zm
       module procedure fmmpy_c2zm
       module procedure fmmpy_zm2zm
       module procedure fmmpy_i2zm2
       module procedure fmmpy_r2zm2
       module procedure fmmpy_d2zm2
       module procedure fmmpy_z2zm2
       module procedure fmmpy_c2zm2
       module procedure fmmpy_zm2i2
       module procedure fmmpy_zm2r2
       module procedure fmmpy_zm2d2
       module procedure fmmpy_zm2z2
       module procedure fmmpy_zm2c2
       module procedure fmmpy_zm2zm2
    end interface

 contains

!                                                                   *

   function fmmpy_ifm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(fm_settings) :: qx
      call fmmpyi(ma%mfm, ival, return_value%mfm, qx)
   end function fmmpy_ifm

   function fmmpy_iim(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(fm_settings) :: qx
      call immpyi(ma%mim, ival, return_value%mim, qx)
   end function fmmpy_iim

   function fmmpy_izm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(fm_settings) :: qx
      call zmmpyi(ma%mzm, ival, return_value%mzm, qx)
   end function fmmpy_izm

   function fmmpy_rfm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmmpy(mtlvfm, ma%mfm, return_value%mfm, qx)
   end function fmmpy_rfm

   function fmmpy_rim(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      call fmmpy(mtlvfm, mulvfm, return_value%mfm, qx)
   end function fmmpy_rim

   function fmmpy_rzm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmmpy(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmmpy_rzm

   function fmmpy_dfm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmmpy(mtlvfm, ma%mfm, return_value%mfm, qx)
   end function fmmpy_dfm

   function fmmpy_dim(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      call fmmpy(mtlvfm, mulvfm, return_value%mfm, qx)
   end function fmmpy_dim

   function fmmpy_dzm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmmpy(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmmpy_dzm

   function fmmpy_zfm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
      call zmmpy(mtlvzm, mulvzm, return_value%mzm, qx)
   end function fmmpy_zfm

   function fmmpy_zim(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmmpy(mtlvzm, mulvzm, return_value%mzm, qx)
   end function fmmpy_zim

   function fmmpy_zzm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      complex :: z
      intent (in) :: z, ma
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call zmmpy(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmmpy_zzm

   function fmmpy_cfm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
      call zmmpy(mtlvzm, mulvzm, return_value%mzm, qx)
   end function fmmpy_cfm

   function fmmpy_cim(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmmpy(mtlvzm, mulvzm, return_value%mzm, qx)
   end function fmmpy_cim

   function fmmpy_czm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmmpy(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmmpy_czm

   function fmmpy_fmi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(fm_settings) :: qx
      call fmmpyi(ma%mfm, ival, return_value%mfm, qx)
   end function fmmpy_fmi

   function fmmpy_fmr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmmpy(ma%mfm, mtlvfm, return_value%mfm, qx)
   end function fmmpy_fmr

   function fmmpy_fmd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmmpy(ma%mfm, mtlvfm, return_value%mfm, qx)
   end function fmmpy_fmd

   function fmmpy_fmz(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
      call zmmpy(mulvzm, mtlvzm, return_value%mzm, qx)
   end function fmmpy_fmz

   function fmmpy_fmc(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
      call zmmpy(mulvzm, mtlvzm, return_value%mzm, qx)
   end function fmmpy_fmc

   function fmmpy_fmfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call fmmpy(ma%mfm, mb%mfm, return_value%mfm, qx)
   end function fmmpy_fmfm

   function fmmpy_fmim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      type (im) :: mb
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(mb%mim, mtlvfm, qx)
      call fmmpy(ma%mfm, mtlvfm, return_value%mfm, qx)
   end function fmmpy_fmim

   function fmmpy_fmzm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (zm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm, qx)
      call zmmpy(mtlvzm, mb%mzm, return_value%mzm, qx)
   end function fmmpy_fmzm

   function fmmpy_imi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(fm_settings) :: qx
      call immpyi(ma%mim, ival, return_value%mim, qx)
   end function fmmpy_imi

   function fmmpy_imr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      call fmmpy(mulvfm, mtlvfm, return_value%mfm, qx)
   end function fmmpy_imr

   function fmmpy_imd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      call fmmpy(mulvfm, mtlvfm, return_value%mfm, qx)
   end function fmmpy_imd

   function fmmpy_imz(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmmpy(mulvzm, mtlvzm, return_value%mzm, qx)
   end function fmmpy_imz

   function fmmpy_imc(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmmpy(mulvzm, mtlvzm, return_value%mzm, qx)
   end function fmmpy_imc

   function fmmpy_imfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (fm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmmpy(mtlvfm, mb%mfm, return_value%mfm, qx)
   end function fmmpy_imfm

   function fmmpy_imim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call immpy(ma%mim, mb%mim, return_value%mim, qx)
   end function fmmpy_imim

   function fmmpy_imzm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (zm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mulvfm, mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmmpy(mulvzm, mb%mzm, return_value%mzm, qx)
   end function fmmpy_imzm

   function fmmpy_zmi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(fm_settings) :: qx
      call zmmpyi(ma%mzm, ival, return_value%mzm, qx)
   end function fmmpy_zmi

   function fmmpy_zmr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmmpy(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmmpy_zmr

   function fmmpy_zmd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmmpy(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmmpy_zmd

   function fmmpy_zmz(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call zmmpy(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmmpy_zmz

   function fmmpy_zmc(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmmpy(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmmpy_zmc

   function fmmpy_zmfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: mb
      type (zm) :: ma, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm, qx)
      call zmmpy(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmmpy_zmfm

   function fmmpy_zmim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: mb
      type (zm) :: ma, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mulvfm, mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(mb%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmmpy(ma%mzm, mulvzm, return_value%mzm, qx)
   end function fmmpy_zmim

   function fmmpy_zmzm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call zmmpy(ma%mzm, mb%mzm, return_value%mzm, qx)
   end function fmmpy_zmzm

!             Array multiplication operations for FM.

!             (1) rank 0  *  rank 1

   function fmmpy_ifm1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(ival, mtlvfm, qx)
      do j = 1, n
         call fmmpy(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_ifm1

   function fmmpy_rfm1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, n
         call fmmpy(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_rfm1

   function fmmpy_dfm1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, n
         call fmmpy(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_dfm1

   function fmmpy_zfm1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zfm1

   function fmmpy_cfm1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_cfm1

   function fmmpy_fmi1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm, qx)
         call fmmpy(ma%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_fmi1

   function fmmpy_fmr1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmmpy(ma%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_fmr1

   function fmmpy_fmd1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmmpy(ma%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_fmd1

   function fmmpy_fmz1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_fmz1

   function fmmpy_fmc1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_fmc1

   function fmmpy_fmfm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(mb)
      do j = 1, n
         call fmmpy(ma%mfm, mb(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_fmfm1

   function fmmpy_imfm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(mb)
      call imi2fm(ma%mim, mtlvfm, qx)
      do j = 1, n
         call fmmpy(mtlvfm, mb(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_imfm1

   function fmmpy_zmfm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (fm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(mb)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n	
         call zmcmpx(mb(j)%mfm, mtlvfm, mtlvzm, qx)
         call zmmpy(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zmfm1

   function fmmpy_fmim1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (im), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(mb)
      do j = 1, n
         call imi2fm(mb(j)%mim, mtlvfm, qx)
         call fmmpy(ma%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_fmim1

   function fmmpy_fmzm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(mb)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm, qx)
      do j = 1, n
         call zmmpy(mtlvzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_fmzm1

!             (2) rank 1  *  rank 0

   function fmmpy_fm1i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(ival, mtlvfm, qx)
      do j = 1, n
         call fmmpy(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_fm1i

   function fmmpy_fm1r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, n
         call fmmpy(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_fm1r

   function fmmpy_fm1d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, n
         call fmmpy(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_fm1d

   function fmmpy_fm1z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_fm1z

   function fmmpy_fm1c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_fm1c

   function fmmpy_i1fm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm, qx)
         call fmmpy(mtlvfm, ma%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_i1fm

   function fmmpy_r1fm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmmpy(mtlvfm, ma%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_r1fm

   function fmmpy_d1fm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmmpy(mtlvfm, ma%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_d1fm

   function fmmpy_z1fm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_z1fm

   function fmmpy_c1fm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_c1fm

   function fmmpy_fm1fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmmpy(ma(j)%mfm, mb%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_fm1fm

   function fmmpy_fm1im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (im) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call imi2fm(mb%mim, mtlvfm, qx)
      do j = 1, n
         call fmmpy(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_fm1im

   function fmmpy_fm1zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mtlvfm, mtlvzm, qx)
         call zmmpy(mtlvzm, mb%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_fm1zm

   function fmmpy_im1fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call fmmpy(mtlvfm, mb%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_im1fm

   function fmmpy_zm1fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (fm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm, qx)
      do j = 1, n
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zm1fm

!             (3) rank 1  *  rank 1

   function fmmpy_fm1i1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm, qx)
         call fmmpy(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_fm1i1

   function fmmpy_fm1r1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmmpy(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_fm1r1

   function fmmpy_fm1d1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmmpy(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_fm1d1

   function fmmpy_fm1z1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_fm1z1

   function fmmpy_fm1c1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_fm1c1

   function fmmpy_i1fm1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm, qx)
         call fmmpy(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_i1fm1

   function fmmpy_r1fm1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmmpy(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_r1fm1

   function fmmpy_d1fm1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmmpy(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_d1fm1

   function fmmpy_z1fm1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(z)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_z1fm1

   function fmmpy_c1fm1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_c1fm1

   function fmmpy_fm1fm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmmpy(ma(j)%mfm, mb(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_fm1fm1

   function fmmpy_fm1im1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2fm(mb(j)%mim, mtlvfm, qx)
         call fmmpy(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_fm1im1

   function fmmpy_fm1zm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mtlvfm, mtlvzm, qx)
         call zmmpy(mtlvzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_fm1zm1

   function fmmpy_im1fm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call fmmpy(mtlvfm, mb(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_im1fm1

   function fmmpy_zm1fm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call zmcmpx(mb(j)%mfm, mtlvfm, mtlvzm, qx)
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zm1fm1

!             (4) rank 0  *  rank 2

   function fmmpy_ifm2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmmpy(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_ifm2

   function fmmpy_rfm2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmmpy(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_rfm2

   function fmmpy_dfm2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmmpy(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_dfm2

   function fmmpy_zfm2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zfm2

   function fmmpy_cfm2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_cfm2

   function fmmpy_fmi2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call fmi2m(ival(j, k), mtlvfm, qx)
            call fmmpy(ma%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_fmi2

   function fmmpy_fmr2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmmpy(ma%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_fmr2

   function fmmpy_fmd2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmmpy(ma%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_fmd2

   function fmmpy_fmz2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_fmz2

   function fmmpy_fmc2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_fmc2

   function fmmpy_fmfm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call fmmpy(ma%mfm, mb(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_fmfm2

   function fmmpy_imfm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call fmmpy(mtlvfm, mb(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_imfm2

   function fmmpy_zmfm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (fm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmcmpx(mb(j, k)%mfm, mtlvfm, mtlvzm, qx)
            call zmmpy(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zmfm2

   function fmmpy_fmim2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (im), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imi2fm(mb(j, k)%mim, mtlvfm, qx)
            call fmmpy(ma%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_fmim2

   function fmmpy_fmzm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm, qx)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmmpy(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_fmzm2

!             (5) rank 2  *  rank 0

   function fmmpy_fm2i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmmpy(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_fm2i

   function fmmpy_fm2r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmmpy(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_fm2r

   function fmmpy_fm2d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmmpy(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_fm2d

   function fmmpy_fm2z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_fm2z

   function fmmpy_fm2c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_fm2c

   function fmmpy_i2fm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call fmi2m(ival(j, k), mtlvfm, qx)
            call fmmpy(mtlvfm, ma%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_i2fm

   function fmmpy_r2fm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmmpy(mtlvfm, ma%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_r2fm

   function fmmpy_d2fm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmmpy(mtlvfm, ma%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_d2fm

   function fmmpy_z2fm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_z2fm

   function fmmpy_c2fm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_c2fm

   function fmmpy_fm2fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmmpy(ma(j, k)%mfm, mb%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_fm2fm

   function fmmpy_fm2im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(mb%mim, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmmpy(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_fm2im

   function fmmpy_fm2zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mtlvfm, mtlvzm, qx)
            call zmmpy(mtlvzm, mb%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_fm2zm

   function fmmpy_im2fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call fmmpy(mtlvfm, mb%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_im2fm

   function fmmpy_zm2fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zm2fm

!             (6) rank 2  *  rank 2

   function fmmpy_fm2i2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm, qx)
            call fmmpy(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_fm2i2

   function fmmpy_fm2r2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmmpy(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_fm2r2

   function fmmpy_fm2d2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmmpy(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_fm2d2

   function fmmpy_fm2z2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_fm2z2

   function fmmpy_fm2c2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_fm2c2

   function fmmpy_i2fm2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm, qx)
            call fmmpy(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_i2fm2

   function fmmpy_r2fm2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmmpy(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_r2fm2

   function fmmpy_d2fm2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmmpy(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_d2fm2

   function fmmpy_z2fm2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_z2fm2

   function fmmpy_c2fm2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_c2fm2

   function fmmpy_fm2fm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmmpy(ma(j, k)%mfm, mb(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_fm2fm2

   function fmmpy_fm2im2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(mb(j, k)%mim, mtlvfm, qx)
            call fmmpy(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_fm2im2

   function fmmpy_fm2zm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mtlvfm, mtlvzm, qx)
            call zmmpy(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_fm2zm2

   function fmmpy_im2fm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call fmmpy(mtlvfm, mb(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_im2fm2

   function fmmpy_zm2fm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(mb(j, k)%mfm, mtlvfm, mtlvzm, qx)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zm2fm2

!             Array multiplication operations for IM.

!             (1) rank 0  *  rank 1

   function fmmpy_iim1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      n = size(ma)
      call imi2m(ival, mtlvim, qx)
      do j = 1, n
         call immpy(mtlvim, ma(j)%mim, return_value(j)%mim, qx)
      enddo
   end function fmmpy_iim1

   function fmmpy_rim1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mulvfm, qx)
         call fmmpy(mtlvfm, mulvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_rim1

   function fmmpy_dim1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mulvfm, qx)
         call fmmpy(mtlvfm, mulvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_dim1

   function fmmpy_zim1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zim1

   function fmmpy_cim1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_cim1

   function fmmpy_imi1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim, qx)
         call immpy(ma%mim, mtlvim, return_value(j)%mim, qx)
      enddo
   end function fmmpy_imi1

   function fmmpy_imr1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      n = size(r)
      call imi2fm(ma%mim, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmmpy(mulvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_imr1

   function fmmpy_imd1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      n = size(d)
      call imi2fm(ma%mim, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmmpy(mulvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_imd1

   function fmmpy_imz1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_imz1

   function fmmpy_imc1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_imc1

   function fmmpy_imim1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (im), dimension(:) :: mb
      type (im), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(mb)
      do j = 1, n
         call immpy(ma%mim, mb(j)%mim, return_value(j)%mim, qx)
      enddo
   end function fmmpy_imim1

   function fmmpy_zmim1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (im), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mvlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(mb)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call imi2fm(mb(j)%mim, mvlvfm, qx)
         call zmcmpx(mvlvfm, mtlvfm, mtlvzm, qx)
         call zmmpy(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zmim1

   function fmmpy_imzm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mvlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(mb)
      call imi2fm(ma%mim, mvlvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mvlvfm, mtlvfm, mtlvzm, qx)
      do j = 1, n
         call zmmpy(mtlvzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_imzm1

!             (2) rank 1  *  rank 0

   function fmmpy_im1i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      n = size(ma)
      call imi2m(ival, mtlvim, qx)
      do j = 1, n
         call immpy(ma(j)%mim, mtlvim, return_value(j)%mim, qx)
      enddo
   end function fmmpy_im1i

   function fmmpy_im1r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm, qx)
         call fmmpy(mvlvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_im1r

   function fmmpy_im1d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm, qx)
         call fmmpy(mvlvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_im1d

   function fmmpy_im1z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm, qx)
         call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_im1z

   function fmmpy_im1c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm, qx)
         call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_im1c

   function fmmpy_i1im(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim, qx)
         call immpy(mtlvim, ma%mim, return_value(j)%mim, qx)
      enddo
   end function fmmpy_i1im

   function fmmpy_r1im(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      n = size(r)
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmmpy(mtlvfm, mvlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_r1im

   function fmmpy_d1im(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      n = size(d)
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmmpy(mtlvfm, mvlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_d1im

   function fmmpy_z1im(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      call imi2fm(ma%mim, mvlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_z1im

   function fmmpy_c1im(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      call imi2fm(ma%mim, m1lvfm, qx)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_c1im

   function fmmpy_im1im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im) :: mb
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call immpy(ma(j)%mim, mb%mim, return_value(j)%mim, qx)
      enddo
   end function fmmpy_im1im

   function fmmpy_im1zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
         call zmmpy(m1lvzm, mb%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_im1zm

   function fmmpy_zm1im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (im) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call imi2fm(mb%mim, m1lvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
      do j = 1, n
         call zmmpy(ma(j)%mzm, m1lvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zm1im

!             (3) rank 1  *  rank 1

   function fmmpy_im1i1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2m(ival(j), mtlvim, qx)
         call immpy(ma(j)%mim, mtlvim, return_value(j)%mim, qx)
      enddo
   end function fmmpy_im1i1

   function fmmpy_im1r1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmmpy(m1lvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_im1r1

   function fmmpy_im1d1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmmpy(m1lvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_im1d1

   function fmmpy_im1z1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_im1z1

   function fmmpy_im1c1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_im1c1

   function fmmpy_i1im1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim, qx)
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim, qx)
         call immpy(mtlvim, ma(j)%mim, return_value(j)%mim, qx)
      enddo
   end function fmmpy_i1im1

   function fmmpy_r1im1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmsp2m(r(j), mtlvfm, qx)
         call fmmpy(mtlvfm, m1lvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_r1im1

   function fmmpy_d1im1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmdp2m(d(j), mtlvfm, qx)
         call fmmpy(mtlvfm, m1lvfm, return_value(j)%mfm, qx)
      enddo
   end function fmmpy_d1im1

   function fmmpy_z1im1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(z)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_z1im1

   function fmmpy_c1im1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_c1im1

   function fmmpy_im1im1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call immpy(ma(j)%mim, mb(j)%mim, return_value(j)%mim, qx)
      enddo
   end function fmmpy_im1im1

   function fmmpy_im1zm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
         call zmmpy(m1lvzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_im1zm1

   function fmmpy_zm1im1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call imi2fm(mb(j)%mim, m1lvfm, qx)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
         call zmmpy(ma(j)%mzm, m1lvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zm1im1

!             (4) rank 0  *  rank 2

   function fmmpy_iim2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call immpy(mtlvim, ma(j, k)%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmmpy_iim2

   function fmmpy_rim2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mulvfm, qx)
            call fmmpy(mtlvfm, mulvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_rim2

   function fmmpy_dim2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mulvfm, qx)
            call fmmpy(mtlvfm, mulvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_dim2

   function fmmpy_zim2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zim2

   function fmmpy_cim2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_cim2

   function fmmpy_imi2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call imi2m(ival(j, k), mtlvim, qx)
            call immpy(ma%mim, mtlvim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmmpy_imi2

   function fmmpy_imr2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mulvfm, qx)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmmpy(mulvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_imr2

   function fmmpy_imd2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mulvfm, qx)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmmpy(mulvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_imd2

   function fmmpy_imz2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_imz2

   function fmmpy_imc2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_imc2

   function fmmpy_imim2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (im), dimension(:,:) :: mb
      type (im), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call immpy(ma%mim, mb(j, k)%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmmpy_imim2

   function fmmpy_zmim2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (im), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mvlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imi2fm(mb(j, k)%mim, mvlvfm, qx)
            call zmcmpx(mvlvfm, mtlvfm, mtlvzm, qx)
            call zmmpy(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zmim2

   function fmmpy_imzm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mvlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mvlvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mvlvfm, mtlvfm, mtlvzm, qx)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmmpy(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_imzm2

!             (5) rank 2  *  rank 0

   function fmmpy_im2i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call immpy(ma(j, k)%mim, mtlvim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmmpy_im2i

   function fmmpy_im2r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm, qx)
            call fmmpy(mvlvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_im2r

   function fmmpy_im2d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm, qx)
            call fmmpy(mvlvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_im2d

   function fmmpy_im2z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm, qx)
            call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_im2z

   function fmmpy_im2c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm, qx)
            call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_im2c

   function fmmpy_i2im(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call imi2m(ival(j, k), mtlvim, qx)
            call immpy(mtlvim, ma%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmmpy_i2im

   function fmmpy_r2im(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmmpy(mtlvfm, mvlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_r2im

   function fmmpy_d2im(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmmpy(mtlvfm, mvlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_d2im

   function fmmpy_z2im(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mvlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_z2im

   function fmmpy_c2im(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, m1lvfm, qx)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_c2im

   function fmmpy_im2im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im) :: mb
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call immpy(ma(j, k)%mim, mb%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmmpy_im2im

   function fmmpy_im2zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
            call zmmpy(m1lvzm, mb%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_im2zm

   function fmmpy_zm2im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      call imi2fm(mb%mim, m1lvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(ma(j, k)%mzm, m1lvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zm2im

!             (6) rank 2  *  rank 2

   function fmmpy_im2i2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2m(ival(j, k), mtlvim, qx)
            call immpy(ma(j, k)%mim, mtlvim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmmpy_im2i2

   function fmmpy_im2r2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmmpy(m1lvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_im2r2

   function fmmpy_im2d2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmmpy(m1lvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_im2d2

   function fmmpy_im2z2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_im2z2

   function fmmpy_im2c2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_im2c2

   function fmmpy_i2im2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2m(ival(j, k), mtlvim, qx)
            call immpy(mtlvim, ma(j, k)%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmmpy_i2im2

   function fmmpy_r2im2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmmpy(mtlvfm, m1lvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_r2im2

   function fmmpy_d2im2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmmpy(mtlvfm, m1lvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmmpy_d2im2

   function fmmpy_z2im2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_z2im2

   function fmmpy_c2im2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_c2im2

   function fmmpy_im2im2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call immpy(ma(j, k)%mim, mb(j, k)%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmmpy_im2im2

   function fmmpy_im2zm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
            call zmmpy(m1lvzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_im2zm2

   function fmmpy_zm2im2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(mb(j, k)%mim, m1lvfm, qx)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
            call zmmpy(ma(j, k)%mzm, m1lvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zm2im2

!             Array multiplication operations for ZM.

!             (1) rank 0  *  rank 1

   function fmmpy_izm1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmi2m(ival, mtlvzm, qx)
      do j = 1, n
         call zmmpy(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_izm1

   function fmmpy_rzm1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmmpy(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_rzm1

   function fmmpy_dzm1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmmpy(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_dzm1

   function fmmpy_zzm1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      do j = 1, n
         call zmmpy(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zzm1

   function fmmpy_czm1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmmpy(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_czm1

   function fmmpy_zmi1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm, qx)
         call zmmpy(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zmi1

   function fmmpy_zmr1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(r)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmmpy(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zmr1

   function fmmpy_zmd1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(d)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmmpy(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zmd1

   function fmmpy_zmz1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmmpy(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zmz1

   function fmmpy_zmc1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmmpy(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zmc1

   function fmmpy_zmzm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(mb)
      do j = 1, n
         call zmmpy(ma%mzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zmzm1

!             (2) rank 1  *  rank 0

   function fmmpy_zm1i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(ival, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zm1i

   function fmmpy_zm1r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zm1r

   function fmmpy_zm1d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zm1d

   function fmmpy_zm1z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      do j = 1, n
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zm1z

   function fmmpy_zm1c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zm1c

   function fmmpy_i1zm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm, qx)
         call zmmpy(mtlvzm, ma%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_i1zm

   function fmmpy_r1zm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(r)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmmpy(mtlvzm, ma%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_r1zm

   function fmmpy_d1zm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(d)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmmpy(mtlvzm, ma%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_d1zm

   function fmmpy_z1zm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmmpy(mtlvzm, ma%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_z1zm

   function fmmpy_c1zm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmmpy(mtlvzm, ma%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_c1zm

   function fmmpy_zm1zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmmpy(ma(j)%mzm, mb%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zm1zm

!             (3) rank 1  *  rank 1

   function fmmpy_zm1i1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm, qx)
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zm1i1

   function fmmpy_zm1r1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zm1r1

   function fmmpy_zm1d1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zm1d1

   function fmmpy_zm1z1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zm1z1

   function fmmpy_zm1c1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zm1c1

   function fmmpy_i1zm1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ival)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmmpy(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_i1zm1

   function fmmpy_r1zm1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(r)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmmpy(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_r1zm1

   function fmmpy_d1zm1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(d)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmmpy(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_d1zm1

   function fmmpy_z1zm1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmmpy(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_z1zm1

   function fmmpy_c1zm1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmmpy(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_c1zm1

   function fmmpy_zm1zm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmmpy(ma(j)%mzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmmpy_zm1zm1

!             (4) rank 0  *  rank 2

   function fmmpy_izm2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmi2m(ival, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_izm2

   function fmmpy_rzm2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_rzm2

   function fmmpy_dzm2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_dzm2

   function fmmpy_zzm2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zzm2

   function fmmpy_czm2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_czm2

   function fmmpy_zmi2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call zmi2m(ival(j, k), mtlvzm, qx)
            call zmmpy(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zmi2

   function fmmpy_zmr2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmmpy(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zmr2

   function fmmpy_zmd2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmmpy(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zmd2

   function fmmpy_zmz2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmmpy(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zmz2

   function fmmpy_zmc2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmmpy(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zmc2

   function fmmpy_zmzm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmmpy(ma%mzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zmzm2

!             (5) rank 2  *  rank 0

   function fmmpy_zm2i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zm2i

   function fmmpy_zm2r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zm2r

   function fmmpy_zm2d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zm2d

   function fmmpy_zm2z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zm2z

   function fmmpy_zm2c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zm2c

   function fmmpy_i2zm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call zmi2m(ival(j, k), mtlvzm, qx)
            call zmmpy(mtlvzm, ma%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_i2zm

   function fmmpy_r2zm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmmpy(mtlvzm, ma%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_r2zm

   function fmmpy_d2zm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmmpy(mtlvzm, ma%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_d2zm

   function fmmpy_z2zm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmmpy(mtlvzm, ma%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_z2zm

   function fmmpy_c2zm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmmpy(mtlvzm, ma%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_c2zm

   function fmmpy_zm2zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(ma(j, k)%mzm, mb%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zm2zm

!             (6) rank 2  *  rank 2

   function fmmpy_zm2i2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmi2m(ival(j, k), mtlvzm, qx)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zm2i2

   function fmmpy_zm2r2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zm2r2

   function fmmpy_zm2d2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zm2d2

   function fmmpy_zm2z2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zm2z2

   function fmmpy_zm2c2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zm2c2

   function fmmpy_i2zm2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmmpy(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_i2zm2

   function fmmpy_r2zm2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmmpy(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_r2zm2

   function fmmpy_d2zm2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmmpy(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_d2zm2

   function fmmpy_z2zm2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmmpy(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_z2zm2

   function fmmpy_c2zm2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmmpy(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_c2zm2

   function fmmpy_zm2zm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(ma(j, k)%mzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmmpy_zm2zm2

 end module fmzm_6_parallel

 module fmzm_7_parallel
    use fmzm_1_parallel

    interface operator (/)
       module procedure fmdiv_ifm
       module procedure fmdiv_iim
       module procedure fmdiv_izm
       module procedure fmdiv_rfm
       module procedure fmdiv_rim
       module procedure fmdiv_rzm
       module procedure fmdiv_dfm
       module procedure fmdiv_dim
       module procedure fmdiv_dzm
       module procedure fmdiv_zfm
       module procedure fmdiv_zim
       module procedure fmdiv_zzm
       module procedure fmdiv_cfm
       module procedure fmdiv_cim
       module procedure fmdiv_czm
       module procedure fmdiv_fmi
       module procedure fmdiv_fmr
       module procedure fmdiv_fmd
       module procedure fmdiv_fmz
       module procedure fmdiv_fmc
       module procedure fmdiv_fmfm
       module procedure fmdiv_fmim
       module procedure fmdiv_fmzm
       module procedure fmdiv_imi
       module procedure fmdiv_imr
       module procedure fmdiv_imd
       module procedure fmdiv_imz
       module procedure fmdiv_imc
       module procedure fmdiv_imfm
       module procedure fmdiv_imim
       module procedure fmdiv_imzm
       module procedure fmdiv_zmi
       module procedure fmdiv_zmr
       module procedure fmdiv_zmd
       module procedure fmdiv_zmz
       module procedure fmdiv_zmc
       module procedure fmdiv_zmfm
       module procedure fmdiv_zmim
       module procedure fmdiv_zmzm
       module procedure fmdiv_ifm1
       module procedure fmdiv_rfm1
       module procedure fmdiv_dfm1
       module procedure fmdiv_zfm1
       module procedure fmdiv_cfm1
       module procedure fmdiv_fmi1
       module procedure fmdiv_fmr1
       module procedure fmdiv_fmd1
       module procedure fmdiv_fmz1
       module procedure fmdiv_fmc1
       module procedure fmdiv_fmfm1
       module procedure fmdiv_imfm1
       module procedure fmdiv_zmfm1
       module procedure fmdiv_fmim1
       module procedure fmdiv_fmzm1
       module procedure fmdiv_fm1i
       module procedure fmdiv_fm1r
       module procedure fmdiv_fm1d
       module procedure fmdiv_fm1z
       module procedure fmdiv_fm1c
       module procedure fmdiv_i1fm
       module procedure fmdiv_r1fm
       module procedure fmdiv_d1fm
       module procedure fmdiv_z1fm
       module procedure fmdiv_c1fm
       module procedure fmdiv_fm1fm
       module procedure fmdiv_fm1im
       module procedure fmdiv_fm1zm
       module procedure fmdiv_im1fm
       module procedure fmdiv_zm1fm
       module procedure fmdiv_i1fm1
       module procedure fmdiv_r1fm1
       module procedure fmdiv_d1fm1
       module procedure fmdiv_z1fm1
       module procedure fmdiv_c1fm1
       module procedure fmdiv_fm1i1
       module procedure fmdiv_fm1r1
       module procedure fmdiv_fm1d1
       module procedure fmdiv_fm1z1
       module procedure fmdiv_fm1c1
       module procedure fmdiv_fm1fm1
       module procedure fmdiv_im1fm1
       module procedure fmdiv_zm1fm1
       module procedure fmdiv_fm1im1
       module procedure fmdiv_fm1zm1
       module procedure fmdiv_iim1
       module procedure fmdiv_rim1
       module procedure fmdiv_dim1
       module procedure fmdiv_zim1
       module procedure fmdiv_cim1
       module procedure fmdiv_imi1
       module procedure fmdiv_imr1
       module procedure fmdiv_imd1
       module procedure fmdiv_imz1
       module procedure fmdiv_imc1
       module procedure fmdiv_imim1
       module procedure fmdiv_zmim1
       module procedure fmdiv_imzm1
       module procedure fmdiv_im1i
       module procedure fmdiv_im1r
       module procedure fmdiv_im1d
       module procedure fmdiv_im1z
       module procedure fmdiv_im1c
       module procedure fmdiv_i1im
       module procedure fmdiv_r1im
       module procedure fmdiv_d1im
       module procedure fmdiv_z1im
       module procedure fmdiv_c1im
       module procedure fmdiv_im1im
       module procedure fmdiv_im1zm
       module procedure fmdiv_zm1im
       module procedure fmdiv_i1im1
       module procedure fmdiv_r1im1
       module procedure fmdiv_d1im1
       module procedure fmdiv_z1im1
       module procedure fmdiv_c1im1
       module procedure fmdiv_im1i1
       module procedure fmdiv_im1r1
       module procedure fmdiv_im1d1
       module procedure fmdiv_im1z1
       module procedure fmdiv_im1c1
       module procedure fmdiv_im1im1
       module procedure fmdiv_zm1im1
       module procedure fmdiv_im1zm1
       module procedure fmdiv_izm1
       module procedure fmdiv_rzm1
       module procedure fmdiv_dzm1
       module procedure fmdiv_zzm1
       module procedure fmdiv_czm1
       module procedure fmdiv_zmi1
       module procedure fmdiv_zmr1
       module procedure fmdiv_zmd1
       module procedure fmdiv_zmz1
       module procedure fmdiv_zmc1
       module procedure fmdiv_zmzm1
       module procedure fmdiv_zm1i
       module procedure fmdiv_zm1r
       module procedure fmdiv_zm1d
       module procedure fmdiv_zm1z
       module procedure fmdiv_zm1c
       module procedure fmdiv_i1zm
       module procedure fmdiv_r1zm
       module procedure fmdiv_d1zm
       module procedure fmdiv_z1zm
       module procedure fmdiv_c1zm
       module procedure fmdiv_zm1zm
       module procedure fmdiv_i1zm1
       module procedure fmdiv_r1zm1
       module procedure fmdiv_d1zm1
       module procedure fmdiv_z1zm1
       module procedure fmdiv_c1zm1
       module procedure fmdiv_zm1i1
       module procedure fmdiv_zm1r1
       module procedure fmdiv_zm1d1
       module procedure fmdiv_zm1z1
       module procedure fmdiv_zm1c1
       module procedure fmdiv_zm1zm1
       module procedure fmdiv_ifm2
       module procedure fmdiv_rfm2
       module procedure fmdiv_dfm2
       module procedure fmdiv_zfm2
       module procedure fmdiv_cfm2
       module procedure fmdiv_fmi2
       module procedure fmdiv_fmr2
       module procedure fmdiv_fmd2
       module procedure fmdiv_fmz2
       module procedure fmdiv_fmc2
       module procedure fmdiv_fmfm2
       module procedure fmdiv_imfm2
       module procedure fmdiv_zmfm2
       module procedure fmdiv_fmim2
       module procedure fmdiv_fmzm2
       module procedure fmdiv_fm2i
       module procedure fmdiv_fm2r
       module procedure fmdiv_fm2d
       module procedure fmdiv_fm2z
       module procedure fmdiv_fm2c
       module procedure fmdiv_i2fm
       module procedure fmdiv_r2fm
       module procedure fmdiv_d2fm
       module procedure fmdiv_z2fm
       module procedure fmdiv_c2fm
       module procedure fmdiv_fm2fm
       module procedure fmdiv_fm2im
       module procedure fmdiv_fm2zm
       module procedure fmdiv_im2fm
       module procedure fmdiv_zm2fm
       module procedure fmdiv_i2fm2
       module procedure fmdiv_r2fm2
       module procedure fmdiv_d2fm2
       module procedure fmdiv_z2fm2
       module procedure fmdiv_c2fm2
       module procedure fmdiv_fm2i2
       module procedure fmdiv_fm2r2
       module procedure fmdiv_fm2d2
       module procedure fmdiv_fm2z2
       module procedure fmdiv_fm2c2
       module procedure fmdiv_fm2fm2
       module procedure fmdiv_im2fm2
       module procedure fmdiv_zm2fm2
       module procedure fmdiv_fm2im2
       module procedure fmdiv_fm2zm2
       module procedure fmdiv_iim2
       module procedure fmdiv_rim2
       module procedure fmdiv_dim2
       module procedure fmdiv_zim2
       module procedure fmdiv_cim2
       module procedure fmdiv_imi2
       module procedure fmdiv_imr2
       module procedure fmdiv_imd2
       module procedure fmdiv_imz2
       module procedure fmdiv_imc2
       module procedure fmdiv_imim2
       module procedure fmdiv_zmim2
       module procedure fmdiv_imzm2
       module procedure fmdiv_im2i
       module procedure fmdiv_im2r
       module procedure fmdiv_im2d
       module procedure fmdiv_im2z
       module procedure fmdiv_im2c
       module procedure fmdiv_i2im
       module procedure fmdiv_r2im
       module procedure fmdiv_d2im
       module procedure fmdiv_z2im
       module procedure fmdiv_c2im
       module procedure fmdiv_im2im
       module procedure fmdiv_im2zm
       module procedure fmdiv_zm2im
       module procedure fmdiv_i2im2
       module procedure fmdiv_r2im2
       module procedure fmdiv_d2im2
       module procedure fmdiv_z2im2
       module procedure fmdiv_c2im2
       module procedure fmdiv_im2i2
       module procedure fmdiv_im2r2
       module procedure fmdiv_im2d2
       module procedure fmdiv_im2z2
       module procedure fmdiv_im2c2
       module procedure fmdiv_im2im2
       module procedure fmdiv_zm2im2
       module procedure fmdiv_im2zm2
       module procedure fmdiv_izm2
       module procedure fmdiv_rzm2
       module procedure fmdiv_dzm2
       module procedure fmdiv_zzm2
       module procedure fmdiv_czm2
       module procedure fmdiv_zmi2
       module procedure fmdiv_zmr2
       module procedure fmdiv_zmd2
       module procedure fmdiv_zmz2
       module procedure fmdiv_zmc2
       module procedure fmdiv_zmzm2
       module procedure fmdiv_zm2i
       module procedure fmdiv_zm2r
       module procedure fmdiv_zm2d
       module procedure fmdiv_zm2z
       module procedure fmdiv_zm2c
       module procedure fmdiv_i2zm
       module procedure fmdiv_r2zm
       module procedure fmdiv_d2zm
       module procedure fmdiv_z2zm
       module procedure fmdiv_c2zm
       module procedure fmdiv_zm2zm
       module procedure fmdiv_i2zm2
       module procedure fmdiv_r2zm2
       module procedure fmdiv_d2zm2
       module procedure fmdiv_z2zm2
       module procedure fmdiv_c2zm2
       module procedure fmdiv_zm2i2
       module procedure fmdiv_zm2r2
       module procedure fmdiv_zm2d2
       module procedure fmdiv_zm2z2
       module procedure fmdiv_zm2c2
       module procedure fmdiv_zm2zm2
    end interface

 contains

!                                                                   /

   function fmdiv_ifm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      call fmdiv(mtlvfm, ma%mfm, return_value%mfm, qx)
   end function fmdiv_ifm

   function fmdiv_iim(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      call imdiv(mtlvim, ma%mim, return_value%mim, qx)
   end function fmdiv_iim

   function fmdiv_izm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmdiv(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmdiv_izm

   function fmdiv_rfm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmdiv(mtlvfm, ma%mfm, return_value%mfm, qx)
   end function fmdiv_rfm

   function fmdiv_rim(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      call fmdiv(mtlvfm, mulvfm, return_value%mfm, qx)
   end function fmdiv_rim

   function fmdiv_rzm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmdiv(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmdiv_rzm

   function fmdiv_dfm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmdiv(mtlvfm, ma%mfm, return_value%mfm, qx)
   end function fmdiv_dfm

   function fmdiv_dim(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      call fmdiv(mtlvfm, mulvfm, return_value%mfm, qx)
   end function fmdiv_dim

   function fmdiv_dzm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmdiv(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmdiv_dzm

   function fmdiv_zfm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
      call zmdiv(mtlvzm, mulvzm, return_value%mzm, qx)
   end function fmdiv_zfm

   function fmdiv_zim(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmdiv(mtlvzm, mulvzm, return_value%mzm, qx)
   end function fmdiv_zim

   function fmdiv_zzm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      complex :: z
      intent (in) :: z, ma
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call zmdiv(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmdiv_zzm

   function fmdiv_cfm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
      call zmdiv(mtlvzm, mulvzm, return_value%mzm, qx)
   end function fmdiv_cfm

   function fmdiv_cim(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmdiv(mtlvzm, mulvzm, return_value%mzm, qx)
   end function fmdiv_cim

   function fmdiv_czm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmdiv(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmdiv_czm

   function fmdiv_fmi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(fm_settings) :: qx
      call fmdivi(ma%mfm, ival, return_value%mfm, qx)
   end function fmdiv_fmi

   function fmdiv_fmr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmdiv(ma%mfm, mtlvfm, return_value%mfm, qx)
   end function fmdiv_fmr

   function fmdiv_fmd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmdiv(ma%mfm, mtlvfm, return_value%mfm, qx)
   end function fmdiv_fmd

   function fmdiv_fmz(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
      call zmdiv(mulvzm, mtlvzm, return_value%mzm, qx)
   end function fmdiv_fmz

   function fmdiv_fmc(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
      call zmdiv(mulvzm, mtlvzm, return_value%mzm, qx)
   end function fmdiv_fmc

   function fmdiv_fmfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call fmdiv(ma%mfm, mb%mfm, return_value%mfm, qx)
   end function fmdiv_fmfm

   function fmdiv_fmim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      type (im) :: mb
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(mb%mim, mtlvfm, qx)
      call fmdiv(ma%mfm, mtlvfm, return_value%mfm, qx)
   end function fmdiv_fmim

   function fmdiv_fmzm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (zm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm, qx)
      call zmdiv(mtlvzm, mb%mzm, return_value%mzm, qx)
   end function fmdiv_fmzm

   function fmdiv_imi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(fm_settings) :: qx
      call imdivi(ma%mim, ival, return_value%mim, qx)
   end function fmdiv_imi

   function fmdiv_imr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      call fmdiv(mulvfm, mtlvfm, return_value%mfm, qx)
   end function fmdiv_imr

   function fmdiv_imd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      call fmdiv(mulvfm, mtlvfm, return_value%mfm, qx)
   end function fmdiv_imd

   function fmdiv_imz(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmdiv(mulvzm, mtlvzm, return_value%mzm, qx)
   end function fmdiv_imz

   function fmdiv_imc(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmdiv(mulvzm, mtlvzm, return_value%mzm, qx)
   end function fmdiv_imc

   function fmdiv_imfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (fm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmdiv(mtlvfm, mb%mfm, return_value%mfm, qx)
   end function fmdiv_imfm

   function fmdiv_imim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call imdiv(ma%mim, mb%mim, return_value%mim, qx)
   end function fmdiv_imim

   function fmdiv_imzm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (zm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mulvfm, mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmdiv(mulvzm, mb%mzm, return_value%mzm, qx)
   end function fmdiv_imzm

   function fmdiv_zmi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(fm_settings) :: qx
      call zmdivi(ma%mzm, ival, return_value%mzm, qx)
   end function fmdiv_zmi

   function fmdiv_zmr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmdiv(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmdiv_zmr

   function fmdiv_zmd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmdiv(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmdiv_zmd

   function fmdiv_zmz(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call zmdiv(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmdiv_zmz

   function fmdiv_zmc(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmdiv(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmdiv_zmc

   function fmdiv_zmfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: mb
      type (zm) :: ma, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm, qx)
      call zmdiv(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmdiv_zmfm

   function fmdiv_zmim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: mb
      type (zm) :: ma, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mulvfm, mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(mb%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmdiv(ma%mzm, mulvzm, return_value%mzm, qx)
   end function fmdiv_zmim

   function fmdiv_zmzm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call zmdiv(ma%mzm, mb%mzm, return_value%mzm, qx)
   end function fmdiv_zmzm

!             Array division operations for FM.

!             (1) rank 0  /  rank 1

   function fmdiv_ifm1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(ival, mtlvfm, qx)
      do j = 1, n
         call fmdiv(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_ifm1

   function fmdiv_rfm1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, n
         call fmdiv(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_rfm1

   function fmdiv_dfm1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, n
         call fmdiv(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_dfm1

   function fmdiv_zfm1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zfm1

   function fmdiv_cfm1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_cfm1

   function fmdiv_fmi1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm, qx)
         call fmdiv(ma%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_fmi1

   function fmdiv_fmr1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmdiv(ma%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_fmr1

   function fmdiv_fmd1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmdiv(ma%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_fmd1

   function fmdiv_fmz1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_fmz1

   function fmdiv_fmc1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_fmc1

   function fmdiv_fmfm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(mb)
      do j = 1, n
         call fmdiv(ma%mfm, mb(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_fmfm1

   function fmdiv_imfm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(mb)
      call imi2fm(ma%mim, mtlvfm, qx)
      do j = 1, n
         call fmdiv(mtlvfm, mb(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_imfm1

   function fmdiv_zmfm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (fm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(mb)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n	
         call zmcmpx(mb(j)%mfm, mtlvfm, mtlvzm, qx)
         call zmdiv(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zmfm1

   function fmdiv_fmim1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (im), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(mb)
      do j = 1, n
         call imi2fm(mb(j)%mim, mtlvfm, qx)
         call fmdiv(ma%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_fmim1

   function fmdiv_fmzm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(mb)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm, qx)
      do j = 1, n
         call zmdiv(mtlvzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_fmzm1

!             (2) rank 1  /  rank 0

   function fmdiv_fm1i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(ival, mtlvfm, qx)
      do j = 1, n
         call fmdiv(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_fm1i

   function fmdiv_fm1r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, n
         call fmdiv(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_fm1r

   function fmdiv_fm1d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, n
         call fmdiv(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_fm1d

   function fmdiv_fm1z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_fm1z

   function fmdiv_fm1c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_fm1c

   function fmdiv_i1fm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm, qx)
         call fmdiv(mtlvfm, ma%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_i1fm

   function fmdiv_r1fm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmdiv(mtlvfm, ma%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_r1fm

   function fmdiv_d1fm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmdiv(mtlvfm, ma%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_d1fm

   function fmdiv_z1fm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_z1fm

   function fmdiv_c1fm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_c1fm

   function fmdiv_fm1fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmdiv(ma(j)%mfm, mb%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_fm1fm

   function fmdiv_fm1im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (im) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call imi2fm(mb%mim, mtlvfm, qx)
      do j = 1, n
         call fmdiv(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_fm1im

   function fmdiv_fm1zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mtlvfm, mtlvzm, qx)
         call zmdiv(mtlvzm, mb%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_fm1zm

   function fmdiv_im1fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call fmdiv(mtlvfm, mb%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_im1fm

   function fmdiv_zm1fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (fm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm, qx)
      do j = 1, n
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zm1fm

!             (3) rank 1  /  rank 1

   function fmdiv_fm1i1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm, qx)
         call fmdiv(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_fm1i1

   function fmdiv_fm1r1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmdiv(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_fm1r1

   function fmdiv_fm1d1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmdiv(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_fm1d1

   function fmdiv_fm1z1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_fm1z1

   function fmdiv_fm1c1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_fm1c1

   function fmdiv_i1fm1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm, qx)
         call fmdiv(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_i1fm1

   function fmdiv_r1fm1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmdiv(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_r1fm1

   function fmdiv_d1fm1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmdiv(mtlvfm, ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_d1fm1

   function fmdiv_z1fm1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(z)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_z1fm1

   function fmdiv_c1fm1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm, qx)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_c1fm1

   function fmdiv_fm1fm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdiv(ma(j)%mfm, mb(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_fm1fm1

   function fmdiv_fm1im1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2fm(mb(j)%mim, mtlvfm, qx)
         call fmdiv(ma(j)%mfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_fm1im1

   function fmdiv_fm1zm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mtlvfm, mtlvzm, qx)
         call zmdiv(mtlvzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_fm1zm1

   function fmdiv_im1fm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call fmdiv(mtlvfm, mb(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_im1fm1

   function fmdiv_zm1fm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call zmcmpx(mb(j)%mfm, mtlvfm, mtlvzm, qx)
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zm1fm1

!             (4) rank 0  /  rank 2

   function fmdiv_ifm2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdiv(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_ifm2

   function fmdiv_rfm2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdiv(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_rfm2

   function fmdiv_dfm2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdiv(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_dfm2

   function fmdiv_zfm2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zfm2

   function fmdiv_cfm2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_cfm2

   function fmdiv_fmi2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call fmi2m(ival(j, k), mtlvfm, qx)
            call fmdiv(ma%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_fmi2

   function fmdiv_fmr2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmdiv(ma%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_fmr2

   function fmdiv_fmd2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmdiv(ma%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_fmd2

   function fmdiv_fmz2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_fmz2

   function fmdiv_fmc2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_fmc2

   function fmdiv_fmfm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call fmdiv(ma%mfm, mb(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_fmfm2

   function fmdiv_imfm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call fmdiv(mtlvfm, mb(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_imfm2

   function fmdiv_zmfm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (fm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmcmpx(mb(j, k)%mfm, mtlvfm, mtlvzm, qx)
            call zmdiv(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zmfm2

   function fmdiv_fmim2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (im), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imi2fm(mb(j, k)%mim, mtlvfm, qx)
            call fmdiv(ma%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_fmim2

   function fmdiv_fmzm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm, qx)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmdiv(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_fmzm2

!             (5) rank 2  /  rank 0

   function fmdiv_fm2i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdiv(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_fm2i

   function fmdiv_fm2r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdiv(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_fm2r

   function fmdiv_fm2d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdiv(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_fm2d

   function fmdiv_fm2z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_fm2z

   function fmdiv_fm2c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_fm2c

   function fmdiv_i2fm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call fmi2m(ival(j, k), mtlvfm, qx)
            call fmdiv(mtlvfm, ma%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_i2fm

   function fmdiv_r2fm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmdiv(mtlvfm, ma%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_r2fm

   function fmdiv_d2fm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmdiv(mtlvfm, ma%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_d2fm

   function fmdiv_z2fm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_z2fm

   function fmdiv_c2fm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_c2fm

   function fmdiv_fm2fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdiv(ma(j, k)%mfm, mb%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_fm2fm

   function fmdiv_fm2im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(mb%mim, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdiv(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_fm2im

   function fmdiv_fm2zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mtlvfm, mtlvzm, qx)
            call zmdiv(mtlvzm, mb%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_fm2zm

   function fmdiv_im2fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call fmdiv(mtlvfm, mb%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_im2fm

   function fmdiv_zm2fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zm2fm

!             (6) rank 2  /  rank 2

   function fmdiv_fm2i2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm, qx)
            call fmdiv(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_fm2i2

   function fmdiv_fm2r2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmdiv(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_fm2r2

   function fmdiv_fm2d2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmdiv(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_fm2d2

   function fmdiv_fm2z2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_fm2z2

   function fmdiv_fm2c2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_fm2c2

   function fmdiv_i2fm2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm, qx)
            call fmdiv(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_i2fm2

   function fmdiv_r2fm2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmdiv(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_r2fm2

   function fmdiv_d2fm2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmdiv(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_d2fm2

   function fmdiv_z2fm2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_z2fm2

   function fmdiv_c2fm2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm, qx)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_c2fm2

   function fmdiv_fm2fm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdiv(ma(j, k)%mfm, mb(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_fm2fm2

   function fmdiv_fm2im2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(mb(j, k)%mim, mtlvfm, qx)
            call fmdiv(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_fm2im2

   function fmdiv_fm2zm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mtlvfm, mtlvzm, qx)
            call zmdiv(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_fm2zm2

   function fmdiv_im2fm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call fmdiv(mtlvfm, mb(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_im2fm2

   function fmdiv_zm2fm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(mb(j, k)%mfm, mtlvfm, mtlvzm, qx)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zm2fm2

!             Array division operations for IM.

!             (1) rank 0  /  rank 1

   function fmdiv_iim1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      n = size(ma)
      call imi2m(ival, mtlvim, qx)
      do j = 1, n
         call imdiv(mtlvim, ma(j)%mim, return_value(j)%mim, qx)
      enddo
   end function fmdiv_iim1

   function fmdiv_rim1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mulvfm, qx)
         call fmdiv(mtlvfm, mulvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_rim1

   function fmdiv_dim1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mulvfm, qx)
         call fmdiv(mtlvfm, mulvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_dim1

   function fmdiv_zim1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zim1

   function fmdiv_cim1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_cim1

   function fmdiv_imi1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim, qx)
         call imdiv(ma%mim, mtlvim, return_value(j)%mim, qx)
      enddo
   end function fmdiv_imi1

   function fmdiv_imr1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      n = size(r)
      call imi2fm(ma%mim, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmdiv(mulvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_imr1

   function fmdiv_imd1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      n = size(d)
      call imi2fm(ma%mim, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmdiv(mulvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_imd1

   function fmdiv_imz1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_imz1

   function fmdiv_imc1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_imc1

   function fmdiv_imim1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (im), dimension(:) :: mb
      type (im), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(mb)
      do j = 1, n
         call imdiv(ma%mim, mb(j)%mim, return_value(j)%mim, qx)
      enddo
   end function fmdiv_imim1

   function fmdiv_zmim1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (im), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mvlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(mb)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call imi2fm(mb(j)%mim, mvlvfm, qx)
         call zmcmpx(mvlvfm, mtlvfm, mtlvzm, qx)
         call zmdiv(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zmim1

   function fmdiv_imzm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mvlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(mb)
      call imi2fm(ma%mim, mvlvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mvlvfm, mtlvfm, mtlvzm, qx)
      do j = 1, n
         call zmdiv(mtlvzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_imzm1

!             (2) rank 1  /  rank 0

   function fmdiv_im1i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      n = size(ma)
      call imi2m(ival, mtlvim, qx)
      do j = 1, n
         call imdiv(ma(j)%mim, mtlvim, return_value(j)%mim, qx)
      enddo
   end function fmdiv_im1i

   function fmdiv_im1r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm, qx)
         call fmdiv(mvlvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_im1r

   function fmdiv_im1d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm, qx)
         call fmdiv(mvlvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_im1d

   function fmdiv_im1z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm, qx)
         call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_im1z

   function fmdiv_im1c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm, qx)
         call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_im1c

   function fmdiv_i1im(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim, qx)
         call imdiv(mtlvim, ma%mim, return_value(j)%mim, qx)
      enddo
   end function fmdiv_i1im

   function fmdiv_r1im(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      n = size(r)
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call fmdiv(mtlvfm, mvlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_r1im

   function fmdiv_d1im(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      n = size(d)
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call fmdiv(mtlvfm, mvlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_d1im

   function fmdiv_z1im(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      call imi2fm(ma%mim, mvlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_z1im

   function fmdiv_c1im(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      call imi2fm(ma%mim, m1lvfm, qx)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_c1im

   function fmdiv_im1im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im) :: mb
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call imdiv(ma(j)%mim, mb%mim, return_value(j)%mim, qx)
      enddo
   end function fmdiv_im1im

   function fmdiv_im1zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
         call zmdiv(m1lvzm, mb%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_im1zm

   function fmdiv_zm1im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (im) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call imi2fm(mb%mim, m1lvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
      do j = 1, n
         call zmdiv(ma(j)%mzm, m1lvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zm1im

!             (3) rank 1  /  rank 1

   function fmdiv_im1i1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2m(ival(j), mtlvim, qx)
         call imdiv(ma(j)%mim, mtlvim, return_value(j)%mim, qx)
      enddo
   end function fmdiv_im1i1

   function fmdiv_im1r1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmdiv(m1lvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_im1r1

   function fmdiv_im1d1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmdiv(m1lvfm, mtlvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_im1d1

   function fmdiv_im1z1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_im1z1

   function fmdiv_im1c1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_im1c1

   function fmdiv_i1im1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim, qx)
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim, qx)
         call imdiv(mtlvim, ma(j)%mim, return_value(j)%mim, qx)
      enddo
   end function fmdiv_i1im1

   function fmdiv_r1im1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmsp2m(r(j), mtlvfm, qx)
         call fmdiv(mtlvfm, m1lvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_r1im1

   function fmdiv_d1im1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm, qx)
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmdp2m(d(j), mtlvfm, qx)
         call fmdiv(mtlvfm, m1lvfm, return_value(j)%mfm, qx)
      enddo
   end function fmdiv_d1im1

   function fmdiv_z1im1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(z)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_z1im1

   function fmdiv_c1im1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call fmi2m(0, mulvfm, qx)
         call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_c1im1

   function fmdiv_im1im1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imdiv(ma(j)%mim, mb(j)%mim, return_value(j)%mim, qx)
      enddo
   end function fmdiv_im1im1

   function fmdiv_im1zm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm, qx)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
         call zmdiv(m1lvzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_im1zm1

   function fmdiv_zm1im1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm, qx)
      do j = 1, n
         call imi2fm(mb(j)%mim, m1lvfm, qx)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
         call zmdiv(ma(j)%mzm, m1lvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zm1im1

!             (4) rank 0  /  rank 2

   function fmdiv_iim2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imdiv(mtlvim, ma(j, k)%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmdiv_iim2

   function fmdiv_rim2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mulvfm, qx)
            call fmdiv(mtlvfm, mulvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_rim2

   function fmdiv_dim2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mulvfm, qx)
            call fmdiv(mtlvfm, mulvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_dim2

   function fmdiv_zim2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zim2

   function fmdiv_cim2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_cim2

   function fmdiv_imi2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call imi2m(ival(j, k), mtlvim, qx)
            call imdiv(ma%mim, mtlvim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmdiv_imi2

   function fmdiv_imr2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mulvfm, qx)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmdiv(mulvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_imr2

   function fmdiv_imd2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mulvfm, qx)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmdiv(mulvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_imd2

   function fmdiv_imz2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_imz2

   function fmdiv_imc2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_imc2

   function fmdiv_imim2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (im), dimension(:,:) :: mb
      type (im), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imdiv(ma%mim, mb(j, k)%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmdiv_imim2

   function fmdiv_zmim2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (im), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mvlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imi2fm(mb(j, k)%mim, mvlvfm, qx)
            call zmcmpx(mvlvfm, mtlvfm, mtlvzm, qx)
            call zmdiv(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zmim2

   function fmdiv_imzm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mvlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mvlvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mvlvfm, mtlvfm, mtlvzm, qx)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmdiv(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_imzm2

!             (5) rank 2  /  rank 0

   function fmdiv_im2i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imdiv(ma(j, k)%mim, mtlvim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmdiv_im2i

   function fmdiv_im2r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm, qx)
            call fmdiv(mvlvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_im2r

   function fmdiv_im2d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm, qx)
            call fmdiv(mvlvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_im2d

   function fmdiv_im2z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm, qx)
            call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_im2z

   function fmdiv_im2c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm, qx)
            call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_im2c

   function fmdiv_i2im(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call imi2m(ival(j, k), mtlvim, qx)
            call imdiv(mtlvim, ma%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmdiv_i2im

   function fmdiv_r2im(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmdiv(mtlvfm, mvlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_r2im

   function fmdiv_d2im(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mvlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mvlvfm, qx)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmdiv(mtlvfm, mvlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_d2im

   function fmdiv_z2im(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mvlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmcmpx(mvlvfm, mulvfm, mulvzm, qx)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_z2im

   function fmdiv_c2im(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, m1lvfm, qx)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_c2im

   function fmdiv_im2im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im) :: mb
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imdiv(ma(j, k)%mim, mb%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmdiv_im2im

   function fmdiv_im2zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
            call zmdiv(m1lvzm, mb%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_im2zm

   function fmdiv_zm2im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      call imi2fm(mb%mim, m1lvfm, qx)
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(ma(j, k)%mzm, m1lvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zm2im

!             (6) rank 2  /  rank 2

   function fmdiv_im2i2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2m(ival(j, k), mtlvim, qx)
            call imdiv(ma(j, k)%mim, mtlvim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmdiv_im2i2

   function fmdiv_im2r2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmdiv(m1lvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_im2r2

   function fmdiv_im2d2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmdiv(m1lvfm, mtlvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_im2d2

   function fmdiv_im2z2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_im2z2

   function fmdiv_im2c2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_im2c2

   function fmdiv_i2im2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2m(ival(j, k), mtlvim, qx)
            call imdiv(mtlvim, ma(j, k)%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmdiv_i2im2

   function fmdiv_r2im2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call fmdiv(mtlvfm, m1lvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_r2im2

   function fmdiv_d2im2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, m1lvfm
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call fmdiv(mtlvfm, m1lvfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmdiv_d2im2

   function fmdiv_z2im2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_z2im2

   function fmdiv_c2im2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call fmi2m(0, mulvfm, qx)
            call zmcmpx(m1lvfm, mulvfm, mulvzm, qx)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_c2im2

   function fmdiv_im2im2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imdiv(ma(j, k)%mim, mb(j, k)%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmdiv_im2im2

   function fmdiv_im2zm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm, qx)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
            call zmdiv(m1lvzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_im2zm2

   function fmdiv_zm2im2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, m1lvfm, m1lvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(mb(j, k)%mim, m1lvfm, qx)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm, qx)
            call zmdiv(ma(j, k)%mzm, m1lvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zm2im2

!             Array division operations for ZM.

!             (1) rank 0  /  rank 1

   function fmdiv_izm1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmi2m(ival, mtlvzm, qx)
      do j = 1, n
         call zmdiv(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_izm1

   function fmdiv_rzm1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmdiv(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_rzm1

   function fmdiv_dzm1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmdiv(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_dzm1

   function fmdiv_zzm1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      do j = 1, n
         call zmdiv(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zzm1

   function fmdiv_czm1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmdiv(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_czm1

   function fmdiv_zmi1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm, qx)
         call zmdiv(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zmi1

   function fmdiv_zmr1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(r)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmdiv(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zmr1

   function fmdiv_zmd1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(d)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmdiv(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zmd1

   function fmdiv_zmz1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmdiv(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zmz1

   function fmdiv_zmc1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmdiv(ma%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zmc1

   function fmdiv_zmzm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(mb)
      do j = 1, n
         call zmdiv(ma%mzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zmzm1

!             (2) rank 1  /  rank 0

   function fmdiv_zm1i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmi2m(ival, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zm1i

   function fmdiv_zm1r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zm1r

   function fmdiv_zm1d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zm1d

   function fmdiv_zm1z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call zmz2m(z, mtlvzm, qx)
      do j = 1, n
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zm1z

   function fmdiv_zm1c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, n
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zm1c

   function fmdiv_i1zm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm, qx)
         call zmdiv(mtlvzm, ma%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_i1zm

   function fmdiv_r1zm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(r)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmdiv(mtlvzm, ma%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_r1zm

   function fmdiv_d1zm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(d)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmdiv(mtlvzm, ma%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_d1zm

   function fmdiv_z1zm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmdiv(mtlvzm, ma%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_z1zm

   function fmdiv_c1zm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmdiv(mtlvzm, ma%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_c1zm

   function fmdiv_zm1zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmdiv(ma(j)%mzm, mb%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zm1zm

!             (3) rank 1  /  rank 1

   function fmdiv_zm1i1(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm, qx)
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zm1i1

   function fmdiv_zm1r1(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zm1r1

   function fmdiv_zm1d1(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zm1d1

   function fmdiv_zm1z1(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zm1z1

   function fmdiv_zm1c1(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zm1c1

   function fmdiv_i1zm1(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ival)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmdiv(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_i1zm1

   function fmdiv_r1zm1(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(r)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmdiv(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_r1zm1

   function fmdiv_d1zm1(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(d)
      call fmi2m(0, mulvfm, qx)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmdiv(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_d1zm1

   function fmdiv_z1zm1(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm, qx)
         call zmdiv(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_z1zm1

   function fmdiv_c1zm1(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm, qx)
         call fmdp2m(aimag(c(j)), mulvfm, qx)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
         call zmdiv(mtlvzm, ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_c1zm1

   function fmdiv_zm1zm1(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm, qx)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmdiv(ma(j)%mzm, mb(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmdiv_zm1zm1

!             (4) rank 0  /  rank 2

   function fmdiv_izm2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmi2m(ival, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_izm2

   function fmdiv_rzm2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_rzm2

   function fmdiv_dzm2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_dzm2

   function fmdiv_zzm2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zzm2

   function fmdiv_czm2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_czm2

   function fmdiv_zmi2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call zmi2m(ival(j, k), mtlvzm, qx)
            call zmdiv(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zmi2

   function fmdiv_zmr2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmdiv(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zmr2

   function fmdiv_zmd2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmdiv(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zmd2

   function fmdiv_zmz2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmdiv(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zmz2

   function fmdiv_zmc2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmdiv(ma%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zmc2

   function fmdiv_zmzm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmdiv(ma%mzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zmzm2

!             (5) rank 2  /  rank 0

   function fmdiv_zm2i(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zm2i

   function fmdiv_zm2r(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zm2r

   function fmdiv_zm2d(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zm2d

   function fmdiv_zm2z(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zm2z

   function fmdiv_zm2c(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zm2c

   function fmdiv_i2zm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call zmi2m(ival(j, k), mtlvzm, qx)
            call zmdiv(mtlvzm, ma%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_i2zm

   function fmdiv_r2zm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmdiv(mtlvzm, ma%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_r2zm

   function fmdiv_d2zm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmdiv(mtlvzm, ma%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_d2zm

   function fmdiv_z2zm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmdiv(mtlvzm, ma%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_z2zm

   function fmdiv_c2zm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmdiv(mtlvzm, ma%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_c2zm

   function fmdiv_zm2zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(ma(j, k)%mzm, mb%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zm2zm

!             (6) rank 2  /  rank 2

   function fmdiv_zm2i2(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmi2m(ival(j, k), mtlvzm, qx)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zm2i2

   function fmdiv_zm2r2(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zm2r2

   function fmdiv_zm2d2(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zm2d2

   function fmdiv_zm2z2(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zm2z2

   function fmdiv_zm2c2(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zm2c2

   function fmdiv_i2zm2(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmdiv(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_i2zm2

   function fmdiv_r2zm2(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmdiv(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_r2zm2

   function fmdiv_d2zm2(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmdiv(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_d2zm2

   function fmdiv_z2zm2(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm, qx)
            call zmdiv(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_z2zm2

   function fmdiv_c2zm2(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm, qx)
            call fmdp2m(aimag(c(j, k)), mulvfm, qx)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
            call zmdiv(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_c2zm2

   function fmdiv_zm2zm2(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm, qx)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(ma(j, k)%mzm, mb(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmdiv_zm2zm2

 end module fmzm_7_parallel

 module fmzm_8_parallel
    use fmzm_1_parallel

    interface operator (**)
       module procedure fmpwr_ifm
       module procedure fmpwr_iim
       module procedure fmpwr_izm
       module procedure fmpwr_rfm
       module procedure fmpwr_rim
       module procedure fmpwr_rzm
       module procedure fmpwr_dfm
       module procedure fmpwr_dim
       module procedure fmpwr_dzm
       module procedure fmpwr_zfm
       module procedure fmpwr_zim
       module procedure fmpwr_zzm
       module procedure fmpwr_cfm
       module procedure fmpwr_cim
       module procedure fmpwr_czm
       module procedure fmpwr_fmi
       module procedure fmpwr_fmr
       module procedure fmpwr_fmd
       module procedure fmpwr_fmz
       module procedure fmpwr_fmc
       module procedure fmpwr_fmfm
       module procedure fmpwr_fmim
       module procedure fmpwr_fmzm
       module procedure fmpwr_imi
       module procedure fmpwr_imr
       module procedure fmpwr_imd
       module procedure fmpwr_imz
       module procedure fmpwr_imc
       module procedure fmpwr_imfm
       module procedure fmpwr_imim
       module procedure fmpwr_imzm
       module procedure fmpwr_zmi
       module procedure fmpwr_zmr
       module procedure fmpwr_zmd
       module procedure fmpwr_zmz
       module procedure fmpwr_zmc
       module procedure fmpwr_zmfm
       module procedure fmpwr_zmim
       module procedure fmpwr_zmzm
    end interface

   interface abs
      module procedure fmabs_fm
      module procedure fmabs_im
      module procedure fmabs_zm
      module procedure fmabs_fm1
      module procedure fmabs_im1
      module procedure fmabs_zm1
      module procedure fmabs_fm2
      module procedure fmabs_im2
      module procedure fmabs_zm2
   end interface

   interface acos
      module procedure fmacos_fm
      module procedure fmacos_zm
      module procedure fmacos_fm1
      module procedure fmacos_zm1
      module procedure fmacos_fm2
      module procedure fmacos_zm2
   end interface

   interface acosh
      module procedure fmacosh_fm
      module procedure fmacosh_zm
      module procedure fmacosh_fm1
      module procedure fmacosh_zm1
      module procedure fmacosh_fm2
      module procedure fmacosh_zm2
   end interface

   interface aimag
      module procedure fmaimag_zm
      module procedure fmaimag_zm1
      module procedure fmaimag_zm2
   end interface

   interface aint
      module procedure fmaint_fm
      module procedure fmaint_zm
      module procedure fmaint_fm1
      module procedure fmaint_zm1
      module procedure fmaint_fm2
      module procedure fmaint_zm2
   end interface

   interface anint
      module procedure fmanint_fm
      module procedure fmanint_zm
      module procedure fmanint_fm1
      module procedure fmanint_zm1
      module procedure fmanint_fm2
      module procedure fmanint_zm2
   end interface

   interface arg
      module procedure fmarg_zm
      module procedure fmarg_zm1
      module procedure fmarg_zm2
   end interface

   interface asin
      module procedure fmasin_fm
      module procedure fmasin_zm
      module procedure fmasin_fm1
      module procedure fmasin_zm1
      module procedure fmasin_fm2
      module procedure fmasin_zm2
   end interface

   interface asinh
      module procedure fmasinh_fm
      module procedure fmasinh_zm
      module procedure fmasinh_fm1
      module procedure fmasinh_zm1
      module procedure fmasinh_fm2
      module procedure fmasinh_zm2
   end interface

   interface atan
      module procedure fmatan_fm
      module procedure fmatan2_fm
      module procedure fmatan_zm
      module procedure fmatan_fm1
      module procedure fmatan_zm1
      module procedure fmatan_fm2
      module procedure fmatan_zm2
   end interface

   interface atanh
      module procedure fmatanh_fm
      module procedure fmatanh_zm
      module procedure fmatanh_fm1
      module procedure fmatanh_zm1
      module procedure fmatanh_fm2
      module procedure fmatanh_zm2
   end interface

   interface atan2
      module procedure fmatan2_fm
   end interface

   interface btest
      module procedure fmbtest_im
   end interface

   interface ceiling
      module procedure fmceiling_fm
      module procedure fmceiling_im
      module procedure fmceiling_zm
      module procedure fmceiling_fm1
      module procedure fmceiling_im1
      module procedure fmceiling_zm1
      module procedure fmceiling_fm2
      module procedure fmceiling_im2
      module procedure fmceiling_zm2
   end interface

   interface cmplx
      module procedure fmcmplx_fm
      module procedure fmcmplx_im
   end interface

   interface conjg
      module procedure fmconjg_zm
      module procedure fmconjg_zm1
      module procedure fmconjg_zm2
   end interface

   interface cos
      module procedure fmcos_fm
      module procedure fmcos_zm
      module procedure fmcos_fm1
      module procedure fmcos_zm1
      module procedure fmcos_fm2
      module procedure fmcos_zm2
   end interface

   interface cosh
      module procedure fmcosh_fm
      module procedure fmcosh_zm
      module procedure fmcosh_fm1
      module procedure fmcosh_zm1
      module procedure fmcosh_fm2
      module procedure fmcosh_zm2
   end interface

   interface dble
      module procedure fmdble_fm
      module procedure fmdble_im
      module procedure fmdble_zm
   end interface

   interface digits
      module procedure fmdigits_fm
      module procedure fmdigits_im
      module procedure fmdigits_zm
   end interface

   interface dim
      module procedure fmdim_fm
      module procedure fmdim_im
   end interface

   interface dint
      module procedure fmdint_fm
      module procedure fmdint_zm
   end interface

   interface dot_product
      module procedure fmdotproduct_fm
      module procedure fmdotproduct_im
      module procedure fmdotproduct_zm
   end interface

   interface epsilon
      module procedure fmepsilon_fm
   end interface

   interface exp
      module procedure fmexp_fm
      module procedure fmexp_zm
      module procedure fmexp_fm1
      module procedure fmexp_zm1
      module procedure fmexp_fm2
      module procedure fmexp_zm2
   end interface

   interface exponent
      module procedure fmexponent_fm
   end interface

   interface floor
      module procedure fmfloor_fm
      module procedure fmfloor_im
      module procedure fmfloor_zm
      module procedure fmfloor_fm1
      module procedure fmfloor_im1
      module procedure fmfloor_zm1
      module procedure fmfloor_fm2
      module procedure fmfloor_im2
      module procedure fmfloor_zm2
   end interface

   interface fraction
      module procedure fmfraction_fm
      module procedure fmfraction_zm
      module procedure fmfraction_fm1
      module procedure fmfraction_zm1
      module procedure fmfraction_fm2
      module procedure fmfraction_zm2
   end interface

   interface huge
      module procedure fmhuge_fm
      module procedure fmhuge_im
      module procedure fmhuge_zm
   end interface

   interface hypot
      module procedure fmhypot_fm
   end interface

   interface int
      module procedure fmint_fm
      module procedure fmint_im
      module procedure fmint_zm
      module procedure fmint_fm1
      module procedure fmint_im1
      module procedure fmint_zm1
      module procedure fmint_fm2
      module procedure fmint_im2
      module procedure fmint_zm2
   end interface

   interface log
      module procedure fmlog_fm
      module procedure fmlog_zm
      module procedure fmlog_fm1
      module procedure fmlog_zm1
      module procedure fmlog_fm2
      module procedure fmlog_zm2
   end interface

   interface log10
      module procedure fmlog10_fm
      module procedure fmlog10_zm
      module procedure fmlog10_fm1
      module procedure fmlog10_zm1
      module procedure fmlog10_fm2
      module procedure fmlog10_zm2
   end interface

   interface matmul
      module procedure fmmatmul22_fm
      module procedure fmmatmul12_fm
      module procedure fmmatmul21_fm
      module procedure fmmatmul22_im
      module procedure fmmatmul12_im
      module procedure fmmatmul21_im
      module procedure fmmatmul22_zm
      module procedure fmmatmul12_zm
      module procedure fmmatmul21_zm
   end interface

   interface max
      module procedure fmmax_fm
      module procedure fmmax_im
   end interface

   interface maxexponent
      module procedure fmmaxexponent_fm
   end interface

   interface maxloc
      module procedure fmmaxloc1_fm
      module procedure fmmaxloc2_fm
      module procedure fmmaxloc1_im
      module procedure fmmaxloc2_im
   end interface

   interface maxval
      module procedure fmmaxval1_fm
      module procedure fmmaxval2_fm
      module procedure fmmaxval1_im
      module procedure fmmaxval2_im
   end interface

   interface min
      module procedure fmmin_fm
      module procedure fmmin_im
   end interface

   interface minexponent
      module procedure fmminexponent_fm
   end interface

   interface minloc
      module procedure fmminloc1_fm
      module procedure fmminloc2_fm
      module procedure fmminloc1_im
      module procedure fmminloc2_im
   end interface

   interface minval
      module procedure fmminval1_fm
      module procedure fmminval2_fm
      module procedure fmminval1_im
      module procedure fmminval2_im
   end interface

   interface mod
      module procedure fmmod_fm
      module procedure fmmod_im
   end interface

   interface modulo
      module procedure fmmodulo_fm
      module procedure fmmodulo_im
   end interface

   interface nearest
      module procedure fmnearest_fm
   end interface

   interface nint
      module procedure fmnint_fm
      module procedure fmnint_im
      module procedure fmnint_zm
      module procedure fmnint_fm1
      module procedure fmnint_im1
      module procedure fmnint_zm1
      module procedure fmnint_fm2
      module procedure fmnint_im2
      module procedure fmnint_zm2
   end interface

   interface norm2
      module procedure fmnorm21_fm
   end interface

   interface precision
      module procedure fmprecision_fm
      module procedure fmprecision_zm
   end interface

   interface product
      module procedure fmproduct1_fm
      module procedure fmproduct2_fm
      module procedure fmproduct1_im
      module procedure fmproduct2_im
      module procedure fmproduct1_zm
      module procedure fmproduct2_zm
   end interface

   interface radix
      module procedure fmradix_fm
      module procedure fmradix_im
      module procedure fmradix_zm
   end interface

   interface range
      module procedure fmrange_fm
      module procedure fmrange_im
      module procedure fmrange_zm
   end interface

   interface real
      module procedure fmreal_fm
      module procedure fmreal_im
      module procedure fmreal_zm
   end interface

   interface rrspacing
      module procedure fmrrspacing_fm
   end interface

   interface scale
      module procedure fmscale_fm
      module procedure fmscale_zm
   end interface

   interface setexponent
      module procedure fmsetexponent_fm
   end interface

   interface sign
      module procedure fmsign_fm
      module procedure fmsign_im
   end interface

 contains

!                                                                  **

   function fmpwr_ifm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      call fmpwr(mtlvfm, ma%mfm, return_value%mfm, qx)
   end function fmpwr_ifm

   function fmpwr_iim(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      call impwr(mtlvim, ma%mim, return_value%mim, qx)
   end function fmpwr_iim

   function fmpwr_izm(ival, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(ival, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmpwr(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmpwr_izm

   function fmpwr_rfm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmpwr(mtlvfm, ma%mfm, return_value%mfm, qx)
   end function fmpwr_rfm

   function fmpwr_rim(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      call fmpwr(mtlvfm, mulvfm, return_value%mfm, qx)
   end function fmpwr_rim

   function fmpwr_rzm(r, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      real :: r
      intent (in) :: r, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmpwr(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmpwr_rzm

   function fmpwr_dfm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmpwr(mtlvfm, ma%mfm, return_value%mfm, qx)
   end function fmpwr_dfm

   function fmpwr_dim(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      call fmpwr(mtlvfm, mulvfm, return_value%mfm, qx)
   end function fmpwr_dim

   function fmpwr_dzm(d, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      double precision :: d
      intent (in) :: d, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmpwr(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmpwr_dzm

   function fmpwr_zfm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
      call zmpwr(mtlvzm, mulvzm, return_value%mzm, qx)
   end function fmpwr_zfm

   function fmpwr_zim(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmpwr(mtlvzm, mulvzm, return_value%mzm, qx)
   end function fmpwr_zim

   function fmpwr_zzm(z, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      complex :: z
      intent (in) :: z, ma
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call zmpwr(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmpwr_zzm

   function fmpwr_cfm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
      call zmpwr(mtlvzm, mulvzm, return_value%mzm, qx)
   end function fmpwr_cfm

   function fmpwr_cim(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmpwr(mtlvzm, mulvzm, return_value%mzm, qx)
   end function fmpwr_cim

   function fmpwr_czm(c, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmpwr(mtlvzm, ma%mzm, return_value%mzm, qx)
   end function fmpwr_czm

   function fmpwr_fmi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(fm_settings) :: qx
      call fmipwr(ma%mfm, ival, return_value%mfm, qx)
   end function fmpwr_fmi

   function fmpwr_fmr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmpwr(ma%mfm, mtlvfm, return_value%mfm, qx)
   end function fmpwr_fmr

   function fmpwr_fmd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmpwr(ma%mfm, mtlvfm, return_value%mfm, qx)
   end function fmpwr_fmd

   function fmpwr_fmz(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
      call zmpwr(mulvzm, mtlvzm, return_value%mzm, qx)
   end function fmpwr_fmz

   function fmpwr_fmc(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(ma%mfm, mulvfm, mulvzm, qx)
      call zmpwr(mulvzm, mtlvzm, return_value%mzm, qx)
   end function fmpwr_fmc

   function fmpwr_fmfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call fmpwr(ma%mfm, mb%mfm, return_value%mfm, qx)
   end function fmpwr_fmfm

   function fmpwr_fmim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      type (im) :: mb
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(mb%mim, mtlvfm, qx)
      call fmpwr(ma%mfm, mtlvfm, return_value%mfm, qx)
   end function fmpwr_fmim

   function fmpwr_fmzm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (zm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm, qx)
      call zmpwr(mtlvzm, mb%mzm, return_value%mzm, qx)
   end function fmpwr_fmzm

   function fmpwr_imi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(ival, mtlvim, qx)
      call impwr(ma%mim, mtlvim, return_value%mim, qx)
   end function fmpwr_imi

   function fmpwr_imr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      call fmpwr(mulvfm, mtlvfm, return_value%mfm, qx)
   end function fmpwr_imr

   function fmpwr_imd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call imi2fm(ma%mim, mulvfm, qx)
      call fmpwr(mulvfm, mtlvfm, return_value%mfm, qx)
   end function fmpwr_imd

   function fmpwr_imz(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmpwr(mulvzm, mtlvzm, return_value%mzm, qx)
   end function fmpwr_imz

   function fmpwr_imc(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmpwr(mulvzm, mtlvzm, return_value%mzm, qx)
   end function fmpwr_imc

   function fmpwr_imfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (fm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmpwr(mtlvfm, mb%mfm, return_value%mfm, qx)
   end function fmpwr_imfm

   function fmpwr_imim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call impwr(ma%mim, mb%mim, return_value%mim, qx)
   end function fmpwr_imim

   function fmpwr_imzm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      type (zm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mulvfm, mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmpwr(mulvzm, mb%mzm, return_value%mzm, qx)
   end function fmpwr_imzm

   function fmpwr_zmi(ma, ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(fm_settings) :: qx
      call zmipwr(ma%mzm, ival, return_value%mzm, qx)
   end function fmpwr_zmi

   function fmpwr_zmr(ma, r)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      real :: r
      intent (in) :: ma, r
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmsp2m(r, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmpwr(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmpwr_zmr

   function fmpwr_zmd(ma, d)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      double precision :: d
      intent (in) :: ma, d
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(d, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmpwr(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmpwr_zmd

   function fmpwr_zmz(ma, z)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      complex :: z
      intent (in) :: ma, z
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmz2m(z, mtlvzm, qx)
      call zmpwr(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmpwr_zmz

   function fmpwr_zmc(ma, c)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi) :: mtlvfm, mulvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm, qx)
      call fmdp2m(aimag(c), mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm, qx)
      call zmpwr(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmpwr_zmc

   function fmpwr_zmfm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: mb
      type (zm) :: ma, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmi2m(0, mtlvfm, qx)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm, qx)
      call zmpwr(ma%mzm, mtlvzm, return_value%mzm, qx)
   end function fmpwr_zmfm

   function fmpwr_zmim(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: mb
      type (zm) :: ma, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mulvfm, mulvzm(2)
      type(fm_settings) :: qx
      call imi2fm(mb%mim, mtlvfm, qx)
      call fmi2m(0, mulvfm, qx)
      call zmcmpx(mtlvfm, mulvfm, mulvzm, qx)
      call zmpwr(ma%mzm, mulvzm, return_value%mzm, qx)
   end function fmpwr_zmim

   function fmpwr_zmzm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call zmpwr(ma%mzm, mb%mzm, return_value%mzm, qx)
   end function fmpwr_zmzm

!                                                                 abs

   function fmabs_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmabs(ma%mfm, return_value%mfm, qx)
   end function fmabs_fm

   function fmabs_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call imabs(ma%mim, return_value%mim, qx)
   end function fmabs_im

   function fmabs_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (zm) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmabs(ma%mzm, return_value%mfm, qx)
   end function fmabs_zm

   function fmabs_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmabs(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmabs_fm1

   function fmabs_im1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call imabs(ma(j)%mim, return_value(j)%mim, qx)
      enddo
   end function fmabs_im1

   function fmabs_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmabs(ma(j)%mzm, return_value(j)%mfm, qx)
      enddo
   end function fmabs_zm1

   function fmabs_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmabs(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmabs_fm2

   function fmabs_im2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imabs(ma(j, k)%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmabs_im2

   function fmabs_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmabs(ma(j, k)%mzm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmabs_zm2

!                                                                acos

   function fmacos_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmacos(ma%mfm, return_value%mfm, qx)
   end function fmacos_fm

   function fmacos_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmacos(ma%mzm, return_value%mzm, qx)
   end function fmacos_zm

   function fmacos_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmacos(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmacos_fm1

   function fmacos_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmacos(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmacos_zm1

   function fmacos_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmacos(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmacos_fm2

   function fmacos_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmacos(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmacos_zm2

!                                                                acosh

   function fmacosh_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmacosh(ma%mfm, return_value%mfm, qx)
   end function fmacosh_fm

   function fmacosh_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmacosh(ma%mzm, return_value%mzm, qx)
   end function fmacosh_zm

   function fmacosh_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmacosh(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmacosh_fm1

   function fmacosh_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmacosh(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmacosh_zm1

   function fmacosh_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmacosh(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmacosh_fm2

   function fmacosh_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmacosh(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmacosh_zm2

!                                                               aimag

   function fmaimag_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (zm) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmimag(ma%mzm, return_value%mfm, qx)
   end function fmaimag_zm

   function fmaimag_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmimag(ma(j)%mzm, return_value(j)%mfm, qx)
      enddo
   end function fmaimag_zm1

   function fmaimag_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmimag(ma(j, k)%mzm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmaimag_zm2

!                                                                aint

   function fmaint_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmint(ma%mfm, return_value%mfm, qx)
   end function fmaint_fm

   function fmaint_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmint(ma%mzm, return_value%mzm, qx)
   end function fmaint_zm

   function fmaint_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmint(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmaint_fm1

   function fmaint_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmint(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmaint_zm1

   function fmaint_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmint(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmaint_fm2

   function fmaint_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmint(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmaint_zm2

!                                                               anint

   function fmanint_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmnint(ma%mfm, return_value%mfm, qx)
   end function fmanint_fm

   function fmanint_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmnint(ma%mzm, return_value%mzm, qx)
   end function fmanint_zm

   function fmanint_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmnint(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmanint_fm1

   function fmanint_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmnint(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmanint_zm1

   function fmanint_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmnint(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmanint_fm2

   function fmanint_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmnint(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmanint_zm2

!                                                                arg

   function fmarg_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (zm) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmarg(ma%mzm, return_value%mfm, qx)
   end function fmarg_zm

   function fmarg_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmarg(ma(j)%mzm, return_value(j)%mfm, qx)
      enddo
   end function fmarg_zm1

   function fmarg_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmarg(ma(j, k)%mzm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmarg_zm2

!                                                                asin

   function fmasin_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmasin(ma%mfm, return_value%mfm, qx)
   end function fmasin_fm

   function fmasin_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmasin(ma%mzm, return_value%mzm, qx)
   end function fmasin_zm

   function fmasin_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmasin(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmasin_fm1

   function fmasin_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmasin(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmasin_zm1

   function fmasin_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmasin(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmasin_fm2

   function fmasin_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmasin(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmasin_zm2

!                                                                asinh

   function fmasinh_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmasinh(ma%mfm, return_value%mfm, qx)
   end function fmasinh_fm

   function fmasinh_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmasinh(ma%mzm, return_value%mzm, qx)
   end function fmasinh_zm

   function fmasinh_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmasinh(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmasinh_fm1

   function fmasinh_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmasinh(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmasinh_zm1

   function fmasinh_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmasinh(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmasinh_fm2

   function fmasinh_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmasinh(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmasinh_zm2

!                                                                atan

   function fmatan_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmatan(ma%mfm, return_value%mfm, qx)
   end function fmatan_fm

   function fmatan_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmatan(ma%mzm, return_value%mzm, qx)
   end function fmatan_zm

   function fmatan_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmatan(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmatan_fm1

   function fmatan_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmatan(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmatan_zm1

   function fmatan_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmatan(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmatan_fm2

   function fmatan_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmatan(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmatan_zm2

!                                                                atanh

   function fmatanh_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmatanh(ma%mfm, return_value%mfm, qx)
   end function fmatanh_fm

   function fmatanh_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmatanh(ma%mzm, return_value%mzm, qx)
   end function fmatanh_zm

   function fmatanh_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmatanh(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmatanh_fm1

   function fmatanh_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmatanh(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmatanh_zm1

   function fmatanh_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmatanh(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmatanh_fm2

   function fmatanh_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmatanh(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmatanh_zm2

!                                                               atan2

   function fmatan2_fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call fmatn2(ma%mfm, mb%mfm, return_value%mfm, qx)
   end function fmatan2_fm

!                                                               btest

   function fmbtest_im(ma, pos)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer :: pos
      logical :: return_value
      intent (in) :: ma, pos
      type(multi) :: mtlvim, mulvim, mvlvim
      type(fm_settings) :: qx
      call imi2m(2, mtlvim, qx)
      call imi2m(pos, mulvim, qx)
      call impwr(mtlvim, mulvim, mvlvim, qx)
      call imdiv(ma%mim, mvlvim, mulvim, qx)
      mulvim%mp(1) = 1
      call immod(mulvim, mtlvim, mvlvim, qx)
      if (mvlvim%mp(3) == 0) then
          return_value = .false.
      else
          return_value = .true.
      endif
   end function fmbtest_im

!                                                             ceiling

   function fmceiling_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmint(ma%mfm, mtlvfm, qx)
      call fmsub(ma%mfm, mtlvfm, mulvfm, qx)
      if (mulvfm%mp(3) == 0) then
          call fmeq(ma%mfm, return_value%mfm, qx)
      else if (ma%mfm%mp(1) > 0) then
          call fmaddi(mtlvfm, 1, qx)
          call fmeq(mtlvfm, return_value%mfm, qx)
      else
          call fmeq(mtlvfm, return_value%mfm, qx)
      endif
   end function fmceiling_fm

   function fmceiling_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call imeq(ma%mim, return_value%mim, qx)
   end function fmceiling_im

   function fmceiling_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(multi) :: mtlvfm, mulvfm, mvlvfm
      type(fm_settings) :: qx
      call fmint(ma%mzm(1), mtlvfm, qx)
      call fmsub(ma%mzm(1), mtlvfm, mulvfm, qx)
      if (mulvfm%mp(3) == 0) then
          call fmeq(ma%mzm(1), mvlvfm, qx)
      else if (ma%mzm(1)%mp(1) > 0) then
          call fmaddi(mtlvfm, 1, qx)
          call fmeq(mtlvfm, mvlvfm, qx)
      else
          call fmeq(mtlvfm, mvlvfm, qx)
      endif
      call fmint(ma%mzm(2), mtlvfm, qx)
      call fmsub(ma%mzm(2), mtlvfm, mulvfm, qx)
      if (mulvfm%mp(3) == 0) then
          call fmeq(ma%mzm(2), mulvfm, qx)
      else if (ma%mzm(2)%mp(1) > 0) then
          call fmaddi(mtlvfm, 1, qx)
          call fmeq(mtlvfm, mulvfm, qx)
      else
          call fmeq(mtlvfm, mulvfm, qx)
      endif
      call zmcmpx(mvlvfm, mulvfm, return_value%mzm, qx)
   end function fmceiling_zm

   function fmceiling_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm) :: mt_fm
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fm_eq(fmceiling_fm(ma(j)), mt_fm)
         call fmeq(mt_fm%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmceiling_fm1

   function fmceiling_im1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(im) :: mt_im
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call im_eq(fmceiling_im(ma(j)), mt_im)
         call imeq(mt_im%mim, return_value(j)%mim, qx)
      enddo
   end function fmceiling_im1

   function fmceiling_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(zm) :: mt_zm
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zm_eq(fmceiling_zm(ma(j)), mt_zm)
         call zmeq(mt_zm%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmceiling_zm1

   function fmceiling_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm) :: mt_fm
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fm_eq(fmceiling_fm(ma(j, k)), mt_fm)
            call fmeq(mt_fm%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmceiling_fm2

   function fmceiling_im2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(im) :: mt_im
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call im_eq(fmceiling_im(ma(j, k)), mt_im)
            call imeq(mt_im%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmceiling_im2

   function fmceiling_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(zm) :: mt_zm
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zm_eq(fmceiling_zm(ma(j, k)), mt_zm)
            call zmeq(mt_zm%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmceiling_zm2

!                                                               cmplx

   function fmcmplx_fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      type (fm), optional :: mb
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      if (present(mb)) then
          call zmcmpx(ma%mfm, mb%mfm, return_value%mzm, qx)
      else
          call fmi2m(0, mtlvfm, qx)
          call zmcmpx(ma%mfm, mtlvfm, return_value%mzm, qx)
      endif
   end function fmcmplx_fm

   function fmcmplx_im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      type (im), optional :: mb
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      if (present(mb)) then
          call imi2fm(ma%mim, mtlvfm, qx)
          call imi2fm(mb%mim, mulvfm, qx)
          call zmcmpx(mtlvfm, mulvfm, return_value%mzm, qx)
      else
          call imi2fm(ma%mim, mtlvfm, qx)
          call fmi2m(0, mulvfm, qx)
          call zmcmpx(mtlvfm, mulvfm, return_value%mzm, qx)
      endif
   end function fmcmplx_im

!                                                               conjg

   function fmconjg_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: return_value, ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmconj(ma%mzm, return_value%mzm, qx)
   end function fmconjg_zm

   function fmconjg_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmconj(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmconjg_zm1

   function fmconjg_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmconj(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmconjg_zm2

!                                                                 cos

   function fmcos_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmcos(ma%mfm, return_value%mfm, qx)
   end function fmcos_fm

   function fmcos_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmcos(ma%mzm, return_value%mzm, qx)
   end function fmcos_zm

   function fmcos_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmcos(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmcos_fm1

   function fmcos_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmcos(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmcos_zm1

   function fmcos_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmcos(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmcos_fm2

   function fmcos_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcos(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmcos_zm2

!                                                                cosh

   function fmcosh_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmcosh(ma%mfm, return_value%mfm, qx)
   end function fmcosh_fm

   function fmcosh_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmcosh(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmcosh_fm1

   function fmcosh_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmcosh(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmcosh_zm1

   function fmcosh_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmcosh(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmcosh_fm2

   function fmcosh_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcosh(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmcosh_zm2

   function fmcosh_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmcosh(ma%mzm, return_value%mzm, qx)
   end function fmcosh_zm

!                                                                dble

   function fmdble_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmeq(ma%mfm, return_value%mfm, qx)
   end function fmdble_fm

   function fmdble_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call imi2fm(ma%mim, return_value%mfm, qx)
   end function fmdble_im

   function fmdble_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (zm) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmreal(ma%mzm, return_value%mfm, qx)
   end function fmdble_zm

!                                                              digits

   function fmdigits_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = qx%ndig
      if (allocated(ma%mfm%mp)) then
          if (size(ma%mfm%mp) <= 2) return_value = return_value - 1
      endif
   end function fmdigits_fm

   function fmdigits_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer :: return_value
      intent (in) :: ma

!             The number of possible digits for type(im) integers is limited only by the amount
!             of memory that can be allocated.  Return 10**6 since there is no fixed limit.

      return_value = 10**6
      if (allocated(ma%mim%mp)) then
          if (size(ma%mim%mp) <= 2) return_value = return_value - 1
      endif
   end function fmdigits_im

   function fmdigits_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      integer :: return_value
      type (zm) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = qx%ndig
      if (allocated(ma%mzm(1)%mp)) then
          if (size(ma%mzm(1)%mp) <= 2) return_value = return_value - 1
      endif
   end function fmdigits_zm

!                                                                 dim

   function fmdim_fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call fmdim(ma%mfm, mb%mfm, return_value%mfm, qx)
   end function fmdim_fm

   function fmdim_im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call imdim(ma%mim, mb%mim, return_value%mim, qx)
   end function fmdim_im

!                                                                dint

   function fmdint_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmint(ma%mfm, return_value%mfm, qx)
   end function fmdint_fm

   function fmdint_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmint(ma%mzm, return_value%mzm, qx)
   end function fmdint_zm

!                                                         dot_product

   function fmdotproduct_fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma(:), mb(:), return_value
      integer :: j, ja, jb, mxsave, nd2, ndsave
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mulvfm, mvlvfm, m3lvfm
      type(fm_settings) :: qx
      if (size(ma) == size(mb)) then
          ndsave = qx%ndig
          j = max(qx%ngrd52, 2)
          nd2 = max(2*qx%ndig+j, 3)
          call fmndig(nd2, qx)
          mxsave = qx%mxexp
          qx%mxexp = qx%mxexp2
          call fmi2m(0, m3lvfm, qx)
          do j = 1, size(ma)
             ja = lbound(ma, dim=1) + j - 1
             call fmequ(ma(ja)%mfm, mulvfm, ndsave, qx%ndig, qx)
             jb = lbound(mb, dim=1) + j - 1
             call fmequ(mb(jb)%mfm, mvlvfm, ndsave, qx%ndig, qx)
             call fmmpy(mulvfm, mvlvfm, mtlvfm, qx)
             call fmadd_r1(m3lvfm, mtlvfm, qx)
          enddo
          qx%mxexp = mxsave
          call fmequ(m3lvfm, return_value%mfm, qx%ndig, ndsave, qx)
          qx%ndig = ndsave
      else
          call fmi2m(1, mtlvfm, qx)
          call fmi2m(0, mulvfm, qx)
          call fmdiv(mtlvfm, mulvfm, return_value%mfm, qx)
      endif
   end function fmdotproduct_fm

   function fmdotproduct_im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma(:), mb(:), return_value
      integer :: j, ja, jb
      intent (in) :: ma, mb
      type(multi) :: mtlvim, mulvim, m3lvim
      type(fm_settings) :: qx
      if (size(ma) == size(mb)) then
          call imi2m(0, m3lvim, qx)
          do j = 1, size(ma)
             ja = lbound(ma, dim=1) + j - 1
             jb = lbound(mb, dim=1) + j - 1
             call immpy(ma(ja)%mim, mb(jb)%mim, mtlvim, qx)
             call imadd(m3lvim, mtlvim, mulvim, qx)
             call imeq(mulvim, m3lvim, qx)
          enddo
          call imeq(m3lvim, return_value%mim, qx)
      else
          call imi2m(1, mtlvim, qx)
          call imi2m(0, mulvim, qx)
          call imdiv(mtlvim, mulvim, return_value%mim, qx)
      endif
   end function fmdotproduct_im

   function fmdotproduct_zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma(:), mb(:), return_value
      integer :: j, ja, jb, mxsave, nd2, ndsave
      intent (in) :: ma, mb
      type(multi) :: mtlvzm(2), mulvzm(2), mvlvzm(2), m3lvzm(2)
      type(fm_settings) :: qx
      if (size(ma) == size(mb)) then
          ndsave = qx%ndig
          j = max(qx%ngrd52, 2)
          nd2 = max(2*qx%ndig+j, 3)
          call fmndig(nd2, qx)
          mxsave = qx%mxexp
          qx%mxexp = qx%mxexp2
          call zmi2m(0, m3lvzm, qx)
          do j = 1, size(ma)
             ja = lbound(ma, dim=1) + j - 1
             call zmequ(ma(ja)%mzm, mulvzm, ndsave, qx%ndig, qx)
             call fmnegate(mulvzm(2), qx)
             jb = lbound(mb, dim=1) + j - 1
             call zmequ(mb(jb)%mzm, mvlvzm, ndsave, qx%ndig, qx)
             call zmmpy(mulvzm, mvlvzm, mtlvzm, qx)
             call zmadd(m3lvzm, mtlvzm, mulvzm, qx)
             call zmeq(mulvzm, m3lvzm, qx)
          enddo
          qx%mxexp = mxsave
          call zmequ(m3lvzm, return_value%mzm, qx%ndig, ndsave, qx)
          qx%ndig = ndsave
      else
          call zmi2m(1, mtlvzm, qx)
          call zmi2m(0, mulvzm, qx)
          call zmdiv(mtlvzm, mulvzm, return_value%mzm, qx)
      endif
   end function fmdotproduct_zm

!                                                             epsilon

   function fmepsilon_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(1, mtlvfm, qx)
      if (allocated(ma%mfm%mp)) then
          if (size(ma%mfm%mp) <= 2) call fmi2m(2, mtlvfm, qx)
      endif
      call fmulp(mtlvfm, return_value%mfm, qx)
   end function fmepsilon_fm

!                                                                 exp

   function fmexp_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmexp(ma%mfm, return_value%mfm, qx)
      qx%ndige = 0
   end function fmexp_fm

   function fmexp_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmexp(ma%mzm, return_value%mzm, qx)
   end function fmexp_zm

   function fmexp_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmexp(ma(j)%mfm, return_value(j)%mfm, qx)
         qx%ndige = 0
      enddo
   end function fmexp_fm1

   function fmexp_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmexp(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmexp_zm1

   function fmexp_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmexp(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
            qx%ndige = 0
         enddo
      enddo
   end function fmexp_fm2

   function fmexp_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmexp(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmexp_zm2

!                                                            exponent

   function fmexponent_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer :: return_value
      intent (in) :: ma
      return_value = int(ma%mfm%mp(2))
   end function fmexponent_fm

!                                                               floor

   function fmfloor_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmint(ma%mfm, mtlvfm, qx)
      call fmsub(ma%mfm, mtlvfm, mulvfm, qx)
      if (mulvfm%mp(3) == 0) then
          call fmeq(ma%mfm, return_value%mfm, qx)
      else if (ma%mfm%mp(1) < 0) then
          call fmaddi(mtlvfm, -1, qx)
          call fmeq(mtlvfm, return_value%mfm, qx)
      else
          call fmeq(mtlvfm, return_value%mfm, qx)
      endif
   end function fmfloor_fm

   function fmfloor_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call imeq(ma%mim, return_value%mim, qx)
   end function fmfloor_im

   function fmfloor_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(multi) :: mtlvfm, mulvfm, mvlvfm
      type(fm_settings) :: qx
      call fmint(ma%mzm(1), mtlvfm, qx)
      call fmsub(ma%mzm(1), mtlvfm, mulvfm, qx)
      if (mulvfm%mp(3) == 0) then
          call fmeq(ma%mzm(1), mvlvfm, qx)
      else if (ma%mzm(1)%mp(1) < 0) then
          call fmaddi(mtlvfm, -1, qx)
          call fmeq(mtlvfm, mvlvfm, qx)
      else
          call fmeq(mtlvfm, mvlvfm, qx)
      endif
      call fmint(ma%mzm(2), mtlvfm, qx)
      call fmsub(ma%mzm(2), mtlvfm, mulvfm, qx)
      if (mulvfm%mp(3) == 0) then
          call fmeq(ma%mzm(2), mulvfm, qx)
      else if (ma%mzm(2)%mp(1) < 0) then
          call fmaddi(mtlvfm, -1, qx)
          call fmeq(mtlvfm, mulvfm, qx)
      else
          call fmeq(mtlvfm, mulvfm, qx)
      endif
      call zmcmpx(mvlvfm, mulvfm, return_value%mzm, qx)
   end function fmfloor_zm

   function fmfloor_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm) :: mt_fm
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fm_eq(fmfloor_fm(ma(j)), mt_fm)
         call fmeq(mt_fm%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmfloor_fm1

   function fmfloor_im1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(im) :: mt_im
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call im_eq(fmfloor_im(ma(j)), mt_im)
         call imeq(mt_im%mim, return_value(j)%mim, qx)
      enddo
   end function fmfloor_im1

   function fmfloor_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(zm) :: mt_zm
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zm_eq(fmfloor_zm(ma(j)), mt_zm)
         call zmeq(mt_zm%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmfloor_zm1

   function fmfloor_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm) :: mt_fm
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fm_eq(fmfloor_fm(ma(j, k)), mt_fm)
            call fmeq(mt_fm%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmfloor_fm2

   function fmfloor_im2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(im) :: mt_im
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call im_eq(fmfloor_im(ma(j, k)), mt_im)
            call imeq(mt_im%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmfloor_im2

   function fmfloor_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(zm) :: mt_zm
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zm_eq(fmfloor_zm(ma(j, k)), mt_zm)
            call zmeq(mt_zm%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmfloor_zm2

!                                                            fraction

   function fmfraction_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmeq(ma%mfm, mtlvfm, qx)
      mtlvfm%mp(2) = 0
      call fmeq(mtlvfm, return_value%mfm, qx)
   end function fmfraction_fm

   function fmfraction_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(multi) :: mtlvzm(2)
      type(fm_settings) :: qx
      call zmeq(ma%mzm, mtlvzm, qx)
      mtlvzm(1)%mp(2) = 0
      mtlvzm(2)%mp(2) = 0
      call zmeq(mtlvzm, return_value%mzm, qx)
   end function fmfraction_zm

   function fmfraction_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm) :: mt_fm
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fm_eq(fmfraction_fm(ma(j)), mt_fm)
         call fmeq(mt_fm%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmfraction_fm1

   function fmfraction_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(zm) :: mt_zm
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zm_eq(fmfraction_zm(ma(j)), mt_zm)
         call zmeq(mt_zm%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmfraction_zm1

   function fmfraction_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm) :: mt_fm
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fm_eq(fmfraction_fm(ma(j, k)), mt_fm)
            call fmeq(mt_fm%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmfraction_fm2

   function fmfraction_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(zm) :: mt_zm
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zm_eq(fmfraction_zm(ma(j, k)), mt_zm)
            call zmeq(mt_zm%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmfraction_zm2

!                                                                huge

   function fmhuge_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmbig(return_value%mfm, qx)
      if (allocated(ma%mfm%mp)) then
          if (size(ma%mfm%mp) <= 2) then
              call fmi2m(1, mtlvfm, qx)
              call fmsub_r1(return_value%mfm, mtlvfm, qx)
          endif
      endif
   end function fmhuge_fm

   function fmhuge_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, return_value
      intent (in) :: ma
      type(multi) :: mtlvim, mulvim
      type(fm_settings) :: qx
      call imbig(return_value%mim, qx)
      if (allocated(ma%mim%mp)) then
          if (size(ma%mim%mp) <= 2) then
              call imi2m(0, mtlvim, qx)
              call imsub(return_value%mim, mtlvim, mulvim, qx)
          endif
      endif
   end function fmhuge_im

   function fmhuge_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmbig(mtlvfm, qx)
      call zmcmpx(mtlvfm, mtlvfm, return_value%mzm, qx)
      if (allocated(ma%mzm(1)%mp)) then
          if (size(ma%mzm(1)%mp) <= 2) then
              call zmi2m(1, mtlvzm, qx)
              call zmsub_r1(return_value%mzm, mtlvzm, qx)
          endif
      endif
   end function fmhuge_zm
!                                                               hypot

   function fmhypot_fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call fmhypot(ma%mfm, mb%mfm, return_value%mfm, qx)
   end function fmhypot_fm

!                                                                 int

   function fmint_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (im) :: return_value
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmint(ma%mfm, mtlvfm, qx)
      call imfm2i(mtlvfm, return_value%mim, qx)
   end function fmint_fm

   function fmint_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call imeq(ma%mim, return_value%mim, qx)
   end function fmint_im

   function fmint_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (im) :: return_value
      intent (in) :: ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call zmreal(ma%mzm, mtlvfm, qx)
      call fmint(mtlvfm, mulvfm, qx)
      call imfm2i(mulvfm, return_value%mim, qx)
   end function fmint_zm

   function fmint_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(im) :: mt_im
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call im_eq(fmint_fm(ma(j)), mt_im)
         call imeq(mt_im%mim, return_value(j)%mim, qx)
      enddo
   end function fmint_fm1

   function fmint_im1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(im) :: mt_im
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call im_eq(fmint_im(ma(j)), mt_im)
         call imeq(mt_im%mim, return_value(j)%mim, qx)
      enddo
   end function fmint_im1

   function fmint_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(im) :: mt_im
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call im_eq(fmint_zm(ma(j)), mt_im)
         call imeq(mt_im%mim, return_value(j)%mim, qx)
      enddo
   end function fmint_zm1

   function fmint_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(im) :: mt_im
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call im_eq(fmint_fm(ma(j, k)), mt_im)
            call imeq(mt_im%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmint_fm2

   function fmint_im2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(im) :: mt_im
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call im_eq(fmint_im(ma(j, k)), mt_im)
            call imeq(mt_im%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmint_im2

   function fmint_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(im) :: mt_im
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call im_eq(fmint_zm(ma(j, k)), mt_im)
            call imeq(mt_im%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmint_zm2

!                                                                 log

   function fmlog_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmln(ma%mfm, return_value%mfm, qx)
      qx%ndigli = 0
   end function fmlog_fm

   function fmlog_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmln(ma(j)%mfm, return_value(j)%mfm, qx)
         qx%ndigli = 0
      enddo
   end function fmlog_fm1

   function fmlog_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmln(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmlog_zm1

   function fmlog_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmln(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
            qx%ndigli = 0
         enddo
      enddo
   end function fmlog_fm2

   function fmlog_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmln(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmlog_zm2

   function fmlog_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmln(ma%mzm, return_value%mzm, qx)
   end function fmlog_zm

!                                                               log10

   function fmlog10_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmlg10(ma%mfm, return_value%mfm, qx)
      qx%ndigli = 0
   end function fmlog10_fm

   function fmlog10_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmlg10(ma%mzm, return_value%mzm, qx)
   end function fmlog10_zm

   function fmlog10_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmlg10(ma(j)%mfm, return_value(j)%mfm, qx)
         qx%ndigli = 0
      enddo
   end function fmlog10_fm1

   function fmlog10_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmlg10(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmlog10_zm1

   function fmlog10_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmlg10(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
            qx%ndigli = 0
         enddo
      enddo
   end function fmlog10_fm2

   function fmlog10_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmlg10(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmlog10_zm2

!                                                              matmul

   function fmmatmul22_fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma(:,:), mb(:,:)
      type (fm), dimension(size(ma, dim=1), size(mb, dim=2)) :: return_value
      integer :: i, j, k, mxsave, nd2, ndsave
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mulvfm, mvlvfm, mtlv01
      type(fm_settings) :: qx
      if (size(ma, dim=2) == size(mb, dim=1)) then
          ndsave = qx%ndig
          j = max(qx%ngrd52, 2)
          nd2 = max(2*qx%ndig+j, 3)
          call fmndig(nd2, qx)
          mxsave = qx%mxexp
          do i = 1, size(ma, dim=1)
             do j = 1, size(mb, dim=2)
                qx%mxexp = qx%mxexp2
                call fmi2m(0, mtlvfm, qx)
                do k = 1, size(ma, dim=2)
                   call fmequ(ma(i, k)%mfm, mulvfm, ndsave, qx%ndig, qx)
                   call fmequ(mb(k, j)%mfm, mvlvfm, ndsave, qx%ndig, qx)
                   call fmmpy(mulvfm, mvlvfm, mtlv01, qx)
                   call fmadd_r1(mtlvfm, mtlv01, qx)
                enddo
                qx%mxexp = mxsave
                call fmequ(mtlvfm, return_value(i, j)%mfm, qx%ndig, ndsave, qx)
             enddo
          enddo
          qx%ndig = ndsave
      else
          call fmi2m(1, mtlvfm, qx)
          call fmi2m(0, mulvfm, qx)
          call fmdiv(mtlvfm, mulvfm, mvlvfm, qx)
          do i = 1, size(ma, dim=1)
             do j = 1, size(mb, dim=2)
                call fmeq(mvlvfm, return_value(i, j)%mfm, qx)
             enddo
          enddo
      endif
   end function fmmatmul22_fm

   function fmmatmul12_fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma(:), mb(:,:)
      type (fm), dimension(size(mb, dim=2)) :: return_value
      integer :: j, k, mxsave, nd2, ndsave
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mulvfm, mvlvfm, mtlv01
      type(fm_settings) :: qx
      if (size(ma) == size(mb, dim=1)) then
          ndsave = qx%ndig
          j = max(qx%ngrd52, 2)
          nd2 = max(2*qx%ndig+j, 3)
          call fmndig(nd2, qx)
          mxsave = qx%mxexp
          do j = 1, size(mb, dim=2)
             qx%mxexp = qx%mxexp2
             call fmi2m(0, mtlvfm, qx)
             do k = 1, size(ma, dim=1)
                call fmequ(ma(k)%mfm, mulvfm, ndsave, qx%ndig, qx)
                call fmequ(mb(k, j)%mfm, mvlvfm, ndsave, qx%ndig, qx)
                call fmmpy(mulvfm, mvlvfm, mtlv01, qx)
                call fmadd_r1(mtlvfm, mtlv01, qx)
             enddo
             qx%mxexp = mxsave
             call fmequ(mtlvfm, return_value(j)%mfm, qx%ndig, ndsave, qx)
          enddo
          qx%ndig = ndsave
      else
          call fmunknown(mvlvfm, qx)
          do j = 1, size(mb, dim=2)
             call fmeq(mvlvfm, return_value(j)%mfm, qx)
          enddo
      endif
   end function fmmatmul12_fm

   function fmmatmul21_fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma(:,:), mb(:)
      type (fm), dimension(size(ma, dim=1)) :: return_value
      integer :: j, k, mxsave, nd2, ndsave
      intent (in) :: ma, mb
      type(multi) :: mtlvfm, mulvfm, mvlvfm, mtlv01
      type(fm_settings) :: qx
      if (size(mb) == size(ma, dim=2)) then
          ndsave = qx%ndig
          j = max(qx%ngrd52, 2)
          nd2 = max(2*qx%ndig+j, 3)
          call fmndig(nd2, qx)
          mxsave = qx%mxexp
          do j = 1, size(ma, dim=1)
             qx%mxexp = qx%mxexp2
             call fmi2m(0, mtlvfm, qx)
             do k = 1, size(mb, dim=1)
                call fmequ(ma(j, k)%mfm, mulvfm, ndsave, qx%ndig, qx)
                call fmequ(mb(k)%mfm, mvlvfm, ndsave, qx%ndig, qx)
                call fmmpy(mulvfm, mvlvfm, mtlv01, qx)
                call fmadd_r1(mtlvfm, mtlv01, qx)
             enddo
             qx%mxexp = mxsave
             call fmequ(mtlvfm, return_value(j)%mfm, qx%ndig, ndsave, qx)
          enddo
          qx%ndig = ndsave
      else
          call fmunknown(mvlvfm, qx)
          do j = 1, size(ma, dim=1)
             call fmeq(mvlvfm, return_value(j)%mfm, qx)
          enddo
      endif
   end function fmmatmul21_fm

   function fmmatmul22_im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma(:,:), mb(:,:)
      type (im), dimension(size(ma, dim=1), size(mb, dim=2)) :: return_value
      integer :: i, j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvim, mulvim, m3lvim, mtlv01
      type(fm_settings) :: qx
      if (size(ma, dim=2) == size(mb, dim=1)) then
          do i = 1, size(ma, dim=1)
             do j = 1, size(mb, dim=2)
                call imi2m(0, mtlvim, qx)
                do k = 1, size(ma, dim=2)
                   call immpy(ma(i, k)%mim, mb(k, j)%mim, mtlv01, qx)
                   call imadd(mtlvim, mtlv01, mulvim, qx)
                   call imeq(mulvim, mtlvim, qx)
                enddo
                call imeq(mtlvim, return_value(i, j)%mim, qx)
             enddo
          enddo
      else
          call imi2m(1, mtlvim, qx)
          call imi2m(0, mulvim, qx)
          call imdiv(mtlvim, mulvim, m3lvim, qx)
          do i = 1, size(ma, dim=1)
             do j = 1, size(mb, dim=2)
                call imeq(m3lvim, return_value(i, j)%mim, qx)
             enddo
          enddo
      endif
   end function fmmatmul22_im

   function fmmatmul12_im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma(:), mb(:,:)
      type (im), dimension(size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvim, mulvim, mtlv01
      type(fm_settings) :: qx
      if (size(ma) == size(mb, dim=1)) then
          do j = 1, size(mb, dim=2)
             call imi2m(0, mtlvim, qx)
             do k = 1, size(ma, dim=1)
                call immpy(ma(k)%mim, mb(k, j)%mim, mtlv01, qx)
                call imadd(mtlvim, mtlv01, mulvim, qx)
                call imeq(mulvim, mtlvim, qx)
             enddo
             call imeq(mtlvim, return_value(j)%mim, qx)
          enddo
      else
          call imunknown(mulvim, qx)
          do j = 1, size(mb, dim=2)
             call imeq(mulvim, return_value(j)%mim, qx)
          enddo
      endif
   end function fmmatmul12_im

   function fmmatmul21_im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma(:,:), mb(:)
      type (im), dimension(size(ma, dim=1)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi) :: mtlvim, mulvim, mtlv01
      type(fm_settings) :: qx
      if (size(mb) == size(ma, dim=2)) then
          do j = 1, size(ma, dim=1)
             call imi2m(0, mtlvim, qx)
             do k = 1, size(mb, dim=1)
                call immpy(ma(j, k)%mim, mb(k)%mim, mtlv01, qx)
                call imadd(mtlvim, mtlv01, mulvim, qx)
                call imeq(mulvim, mtlvim, qx)
             enddo
             call imeq(mtlvim, return_value(j)%mim, qx)
          enddo
      else
          call imunknown(mulvim, qx)
          do j = 1, size(ma, dim=1)
             call imeq(mulvim, return_value(j)%mim, qx)
          enddo
      endif
   end function fmmatmul21_im

   function fmmatmul22_zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma(:,:), mb(:,:)
      type (zm), dimension(size(ma, dim=1), size(mb, dim=2)) :: return_value
      integer :: i, j, k, mxsave, nd2, ndsave
      intent (in) :: ma, mb
      type(multi) :: mtlvzm(2), mulvzm(2), mvlvzm(2), mzlv02(2)
      type(fm_settings) :: qx
      if (size(ma, dim=2) == size(mb, dim=1)) then
          ndsave = qx%ndig
          j = max(qx%ngrd52, 2)
          nd2 = max(2*qx%ndig+j, 3)
          call fmndig(nd2, qx)
          mxsave = qx%mxexp
          do i = 1, size(ma, dim=1)
             do j = 1, size(mb, dim=2)
                qx%mxexp = qx%mxexp2
                call zmi2m(0, mtlvzm, qx)
                do k = 1, size(ma, dim=2)
                   call zmequ(ma(i, k)%mzm, mulvzm, ndsave, qx%ndig, qx)
                   call zmequ(mb(k, j)%mzm, mvlvzm, ndsave, qx%ndig, qx)
                   call zmmpy(mulvzm, mvlvzm, mzlv02, qx)
                   call zmadd(mtlvzm, mzlv02, mulvzm, qx)
                   call zmeq(mulvzm, mtlvzm, qx)
                enddo
                qx%mxexp = mxsave
                call zmequ(mtlvzm, return_value(i, j)%mzm, qx%ndig, ndsave, qx)
             enddo
          enddo
          qx%ndig = ndsave
      else
          call zmi2m(1, mtlvzm, qx)
          call zmi2m(0, mulvzm, qx)
          call zmdiv(mtlvzm, mulvzm, mvlvzm, qx)
          do i = 1, size(ma, dim=1)
             do j = 1, size(mb, dim=2)
                call zmeq(mvlvzm, return_value(i, j)%mzm, qx)
             enddo
          enddo
      endif
   end function fmmatmul22_zm

   function fmmatmul12_zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma(:), mb(:,:)
      type (zm), dimension(size(mb, dim=2)) :: return_value
      integer :: j, k, mxsave, nd2, ndsave
      intent (in) :: ma, mb
      type(multi) :: mtlvzm(2), mulvzm(2), mvlvzm(2), mzlv01(2)
      type(fm_settings) :: qx
      if (size(ma) == size(mb, dim=1)) then
          ndsave = qx%ndig
          j = max(qx%ngrd52, 2)
          nd2 = max(2*qx%ndig+j, 3)
          call fmndig(nd2, qx)
          mxsave = qx%mxexp
          do j = 1, size(mb, dim=2)
             qx%mxexp = qx%mxexp2
             call zmi2m(0, mtlvzm, qx)
             do k = 1, size(ma, dim=1)
                call zmequ(ma(k)%mzm, mulvzm, ndsave, qx%ndig, qx)
                call zmequ(mb(k, j)%mzm, mvlvzm, ndsave, qx%ndig, qx)
                call zmmpy(mulvzm, mvlvzm, mzlv01, qx)
                call zmadd(mtlvzm, mzlv01, mulvzm, qx)
                call zmeq(mulvzm, mtlvzm, qx)
             enddo
             qx%mxexp = mxsave
             call zmequ(mtlvzm, return_value(j)%mzm, qx%ndig, ndsave, qx)
          enddo
          qx%ndig = ndsave
      else
          call zmst2m('UNKNOWN+UNKNOWN*i', mvlvzm, qx)
          do j = 1, size(mb, dim=2)
             call zmeq(mvlvzm, return_value(j)%mzm, qx)
          enddo
      endif
   end function fmmatmul12_zm

   function fmmatmul21_zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma(:,:), mb(:)
      type (zm), dimension(size(ma, dim=1)) :: return_value
      integer :: j, k, mxsave, nd2, ndsave
      intent (in) :: ma, mb
      type(multi) :: mtlvzm(2), mulvzm(2), mvlvzm(2), mzlv01(2)
      type(fm_settings) :: qx
      if (size(mb) == size(ma, dim=2)) then
          ndsave = qx%ndig
          j = max(qx%ngrd52, 2)
          nd2 = max(2*qx%ndig+j, 3)
          call fmndig(nd2, qx)
          mxsave = qx%mxexp
          do j = 1, size(ma, dim=1)
             qx%mxexp = qx%mxexp2
             call zmi2m(0, mtlvzm, qx)
             do k = 1, size(mb, dim=1)
                call zmequ(ma(j, k)%mzm, mulvzm, ndsave, qx%ndig, qx)
                call zmequ(mb(k)%mzm, mvlvzm, ndsave, qx%ndig, qx)
                call zmmpy(mulvzm, mvlvzm, mzlv01, qx)
                call zmadd(mtlvzm, mzlv01, mulvzm, qx)
                call zmeq(mulvzm, mtlvzm, qx)
             enddo
             qx%mxexp = mxsave
             call zmequ(mtlvzm, return_value(j)%mzm, qx%ndig, ndsave, qx)
          enddo
          qx%ndig = ndsave
      else
          call zmst2m('UNKNOWN+UNKNOWN*i', mvlvzm, qx)
          do j = 1, size(ma, dim=1)
             call zmeq(mvlvzm, return_value(j)%mzm, qx)
          enddo
      endif
   end function fmmatmul21_zm

!                                                                 max

   function fmmax_fm(ma, mb, mc, md, me, mf, mg, mh, mi, mj)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, return_value
      type (fm), optional :: mc, md, me, mf, mg, mh, mi, mj
      intent (in) :: ma, mb, mc, md, me, mf, mg, mh, mi, mj
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmmax(ma%mfm, mb%mfm, mtlvfm, qx)
      if (present(mc)) then
          call fmmax(mtlvfm, mc%mfm, mulvfm, qx)
          call fmeq(mulvfm, mtlvfm, qx)
      endif
      if (present(md)) then
          call fmmax(mtlvfm, md%mfm, mulvfm, qx)
          call fmeq(mulvfm, mtlvfm, qx)
      endif
      if (present(me)) then
          call fmmax(mtlvfm, me%mfm, mulvfm, qx)
          call fmeq(mulvfm, mtlvfm, qx)
      endif
      if (present(mf)) then
          call fmmax(mtlvfm, mf%mfm, mulvfm, qx)
          call fmeq(mulvfm, mtlvfm, qx)
      endif
      if (present(mg)) then
          call fmmax(mtlvfm, mg%mfm, mulvfm, qx)
          call fmeq(mulvfm, mtlvfm, qx)
      endif
      if (present(mh)) then
          call fmmax(mtlvfm, mh%mfm, mulvfm, qx)
          call fmeq(mulvfm, mtlvfm, qx)
      endif
      if (present(mi)) then
          call fmmax(mtlvfm, mi%mfm, mulvfm, qx)
          call fmeq(mulvfm, mtlvfm, qx)
      endif
      if (present(mj)) then
          call fmmax(mtlvfm, mj%mfm, mulvfm, qx)
          call fmeq(mulvfm, mtlvfm, qx)
      endif
      call fmeq(mtlvfm, return_value%mfm, qx)
   end function fmmax_fm

   function fmmax_im(ma, mb, mc, md, me, mf, mg, mh, mi, mj)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, return_value
      type (im), optional :: mc, md, me, mf, mg, mh, mi, mj
      intent (in) :: ma, mb, mc, md, me, mf, mg, mh, mi, mj
      type(multi) :: mtlvim, mulvim
      type(fm_settings) :: qx
      call immax(ma%mim, mb%mim, mtlvim, qx)
      if (present(mc)) then
          call immax(mtlvim, mc%mim, mulvim, qx)
          call imeq(mulvim, mtlvim, qx)
      endif
      if (present(md)) then
          call immax(mtlvim, md%mim, mulvim, qx)
          call imeq(mulvim, mtlvim, qx)
      endif
      if (present(me)) then
          call immax(mtlvim, me%mim, mulvim, qx)
          call imeq(mulvim, mtlvim, qx)
      endif
      if (present(mf)) then
          call immax(mtlvim, mf%mim, mulvim, qx)
          call imeq(mulvim, mtlvim, qx)
      endif
      if (present(mg)) then
          call immax(mtlvim, mg%mim, mulvim, qx)
          call imeq(mulvim, mtlvim, qx)
      endif
      if (present(mh)) then
          call immax(mtlvim, mh%mim, mulvim, qx)
          call imeq(mulvim, mtlvim, qx)
      endif
      if (present(mi)) then
          call immax(mtlvim, mi%mim, mulvim, qx)
          call imeq(mulvim, mtlvim, qx)
      endif
      if (present(mj)) then
          call immax(mtlvim, mj%mim, mulvim, qx)
          call imeq(mulvim, mtlvim, qx)
      endif
      call imeq(mtlvim, return_value%mim, qx)
   end function fmmax_im

!                                                         maxexponent

   function fmmaxexponent_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = int(qx%mxexp) + 1
      if (allocated(ma%mfm%mp)) then
          if (size(ma%mfm%mp) <= 2) return_value = return_value - 1
      endif
   end function fmmaxexponent_fm

!                                                              maxloc

   function fmmaxloc1_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma(:)
      integer :: return_value
      integer :: j, ja
      logical, external :: fmcomp
      intent (in) :: ma
      type(multi) :: m3lvfm
      type(fm_settings) :: qx
      call fmst2m(' -OVERFLOW ', m3lvfm, qx)
      return_value = lbound(ma, dim=1)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         if (fmcomp(ma(ja)%mfm, '>', m3lvfm, qx)) then
             call fmeq(ma(ja)%mfm, m3lvfm, qx)
             return_value = ja
         endif
      enddo
   end function fmmaxloc1_fm

   function fmmaxloc2_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma(:,:)
      integer :: return_value(2)
      integer :: j, k, ja, jb
      logical, external :: fmcomp
      intent (in) :: ma
      type(multi) :: m3lvfm
      type(fm_settings) :: qx
      call fmst2m(' -OVERFLOW ', m3lvfm, qx)
      return_value = (/ lbound(ma, dim=1), lbound(ma, dim=2) /)
      do k = 1, size(ma, dim=2)
         do j = 1, size(ma, dim=1)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            if (fmcomp(ma(ja, jb)%mfm, '>', m3lvfm, qx)) then
                call fmeq(ma(ja, jb)%mfm, m3lvfm, qx)
                return_value = (/ ja, jb /)
            endif
         enddo
      enddo
   end function fmmaxloc2_fm

   function fmmaxloc1_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma(:)
      integer :: return_value
      integer :: j, ja
      logical, external :: imcomp
      intent (in) :: ma
      type(multi) :: m3lvim
      type(fm_settings) :: qx
      call imst2m(' -OVERFLOW ', m3lvim, qx)
      return_value = lbound(ma, dim=1)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         if (imcomp(ma(ja)%mim, '>', m3lvim, qx)) then
             call imeq(ma(ja)%mim, m3lvim, qx)
             return_value = ja
         endif
      enddo
   end function fmmaxloc1_im

   function fmmaxloc2_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma(:,:)
      integer :: return_value(2)
      integer :: j, k, ja, jb
      logical, external :: imcomp
      intent (in) :: ma
      type(multi) :: m3lvim
      type(fm_settings) :: qx
      call imst2m(' -OVERFLOW ', m3lvim, qx)
      return_value = (/ lbound(ma, dim=1), lbound(ma, dim=2) /)
      do k = 1, size(ma, dim=2)
         do j = 1, size(ma, dim=1)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            if (imcomp(ma(ja, jb)%mim, '>', m3lvim, qx)) then
                call imeq(ma(ja, jb)%mim, m3lvim, qx)
                return_value = (/ ja, jb /)
            endif
         enddo
      enddo
   end function fmmaxloc2_im

!                                                              maxval

   function fmmaxval1_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma(:), return_value
      integer :: j, ja
      logical, external :: fmcomp
      intent (in) :: ma
      type(multi) :: m3lvfm
      type(fm_settings) :: qx
      call fmst2m(' -OVERFLOW ', m3lvfm, qx)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         if (fmcomp(ma(ja)%mfm, '>', m3lvfm, qx)) call fmeq(ma(ja)%mfm, m3lvfm,qx)
      enddo
      call fmeq(m3lvfm, return_value%mfm, qx)
   end function fmmaxval1_fm

   function fmmaxval2_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma(:,:), return_value
      integer :: j, k, ja, jb
      logical, external :: fmcomp
      intent (in) :: ma
      type(multi) :: m3lvfm
      type(fm_settings) :: qx
      call fmst2m(' -OVERFLOW ', m3lvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            if (fmcomp(ma(ja, jb)%mfm, '>', m3lvfm, qx)) call fmeq(ma(ja, jb)%mfm, m3lvfm,qx)
         enddo
      enddo
      call fmeq(m3lvfm, return_value%mfm, qx)
   end function fmmaxval2_fm

   function fmmaxval1_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma(:), return_value
      integer :: j, ja
      logical, external :: imcomp
      intent (in) :: ma
      type(multi) :: m3lvim
      type(fm_settings) :: qx
      call imst2m(' -OVERFLOW ', m3lvim, qx)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         if (imcomp(ma(ja)%mim, '>', m3lvim, qx)) call imeq(ma(ja)%mim, m3lvim,qx)
      enddo
      call imeq(m3lvim, return_value%mim, qx)
   end function fmmaxval1_im

   function fmmaxval2_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma(:,:), return_value
      integer :: j, k, ja, jb
      logical, external :: imcomp
      intent (in) :: ma
      type(multi) :: m3lvim
      type(fm_settings) :: qx
      call imst2m(' -OVERFLOW ', m3lvim, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            if (imcomp(ma(ja, jb)%mim, '>', m3lvim, qx)) call imeq(ma(ja, jb)%mim, m3lvim,qx)
         enddo
      enddo
      call imeq(m3lvim, return_value%mim, qx)
   end function fmmaxval2_im

!                                                                 min

   function fmmin_fm(ma, mb, mc, md, me, mf, mg, mh, mi, mj)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, return_value
      type (fm), optional :: mc, md, me, mf, mg, mh, mi, mj
      intent (in) :: ma, mb, mc, md, me, mf, mg, mh, mi, mj
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmmin(ma%mfm, mb%mfm, mtlvfm, qx)
      if (present(mc)) then
          call fmmin(mtlvfm, mc%mfm, mulvfm, qx)
          call fmeq(mulvfm, mtlvfm, qx)
      endif
      if (present(md)) then
          call fmmin(mtlvfm, md%mfm, mulvfm, qx)
          call fmeq(mulvfm, mtlvfm, qx)
      endif
      if (present(me)) then
          call fmmin(mtlvfm, me%mfm, mulvfm, qx)
          call fmeq(mulvfm, mtlvfm, qx)
      endif
      if (present(mf)) then
          call fmmin(mtlvfm, mf%mfm, mulvfm, qx)
          call fmeq(mulvfm, mtlvfm, qx)
      endif
      if (present(mg)) then
          call fmmin(mtlvfm, mg%mfm, mulvfm, qx)
          call fmeq(mulvfm, mtlvfm, qx)
      endif
      if (present(mh)) then
          call fmmin(mtlvfm, mh%mfm, mulvfm, qx)
          call fmeq(mulvfm, mtlvfm, qx)
      endif
      if (present(mi)) then
          call fmmin(mtlvfm, mi%mfm, mulvfm, qx)
          call fmeq(mulvfm, mtlvfm, qx)
      endif
      if (present(mj)) then
          call fmmin(mtlvfm, mj%mfm, mulvfm, qx)
          call fmeq(mulvfm, mtlvfm, qx)
      endif
      call fmeq(mtlvfm, return_value%mfm, qx)
   end function fmmin_fm

   function fmmin_im(ma, mb, mc, md, me, mf, mg, mh, mi, mj)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, return_value
      type (im), optional :: mc, md, me, mf, mg, mh, mi, mj
      intent (in) :: ma, mb, mc, md, me, mf, mg, mh, mi, mj
      type(multi) :: mtlvim, mulvim
      type(fm_settings) :: qx
      call immin(ma%mim, mb%mim, mtlvim, qx)
      if (present(mc)) then
          call immin(mtlvim, mc%mim, mulvim, qx)
          call imeq(mulvim, mtlvim, qx)
      endif
      if (present(md)) then
          call immin(mtlvim, md%mim, mulvim, qx)
          call imeq(mulvim, mtlvim, qx)
      endif
      if (present(me)) then
          call immin(mtlvim, me%mim, mulvim, qx)
          call imeq(mulvim, mtlvim, qx)
      endif
      if (present(mf)) then
          call immin(mtlvim, mf%mim, mulvim, qx)
          call imeq(mulvim, mtlvim, qx)
      endif
      if (present(mg)) then
          call immin(mtlvim, mg%mim, mulvim, qx)
          call imeq(mulvim, mtlvim, qx)
      endif
      if (present(mh)) then
          call immin(mtlvim, mh%mim, mulvim, qx)
          call imeq(mulvim, mtlvim, qx)
      endif
      if (present(mi)) then
          call immin(mtlvim, mi%mim, mulvim, qx)
          call imeq(mulvim, mtlvim, qx)
      endif
      if (present(mj)) then
          call immin(mtlvim, mj%mim, mulvim, qx)
          call imeq(mulvim, mtlvim, qx)
      endif
      call imeq(mtlvim, return_value%mim, qx)
   end function fmmin_im

!                                                         minexponent

   function fmminexponent_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = -int(qx%mxexp)
      if (allocated(ma%mfm%mp)) then
          if (size(ma%mfm%mp) <= 2) return_value = return_value - 1
      endif
   end function fmminexponent_fm

!                                                              minval

   function fmminval1_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma(:), return_value
      integer :: j, ja
      logical, external :: fmcomp
      intent (in) :: ma
      type(multi) :: m3lvfm
      type(fm_settings) :: qx
      call fmst2m(' OVERFLOW ', m3lvfm, qx)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         if (fmcomp(ma(ja)%mfm, '<', m3lvfm, qx)) call fmeq(ma(ja)%mfm, m3lvfm,qx)
      enddo
      call fmeq(m3lvfm, return_value%mfm, qx)
   end function fmminval1_fm

   function fmminval2_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma(:,:), return_value
      integer :: j, k, ja, jb
      logical, external :: fmcomp
      intent (in) :: ma
      type(multi) :: m3lvfm
      type(fm_settings) :: qx
      call fmst2m(' OVERFLOW ', m3lvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            if (fmcomp(ma(ja, jb)%mfm, '<', m3lvfm, qx)) call fmeq(ma(ja, jb)%mfm, m3lvfm,qx)
         enddo
      enddo
      call fmeq(m3lvfm, return_value%mfm, qx)
   end function fmminval2_fm

   function fmminval1_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma(:), return_value
      integer :: j, ja
      logical, external :: imcomp
      intent (in) :: ma
      type(multi) :: m3lvim
      type(fm_settings) :: qx
      call imst2m(' OVERFLOW ', m3lvim, qx)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         if (imcomp(ma(ja)%mim, '<', m3lvim, qx)) call imeq(ma(ja)%mim, m3lvim,qx)
      enddo
      call imeq(m3lvim, return_value%mim, qx)
   end function fmminval1_im

   function fmminval2_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma(:,:), return_value
      integer :: j, k, ja, jb
      logical, external :: imcomp
      intent (in) :: ma
      type(multi) :: m3lvim
      type(fm_settings) :: qx
      call imst2m(' OVERFLOW ', m3lvim, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            if (imcomp(ma(ja, jb)%mim, '<', m3lvim, qx)) call imeq(ma(ja, jb)%mim, m3lvim,qx)
         enddo
      enddo
      call imeq(m3lvim, return_value%mim, qx)
   end function fmminval2_im

!                                                              minloc

   function fmminloc1_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma(:)
      integer :: return_value
      integer :: j, ja
      logical, external :: fmcomp
      intent (in) :: ma
      type(multi) :: m3lvfm
      type(fm_settings) :: qx
      call fmst2m(' OVERFLOW ', m3lvfm, qx)
      return_value = lbound(ma, dim=1)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         if (fmcomp(ma(ja)%mfm, '<', m3lvfm, qx)) then
             call fmeq(ma(ja)%mfm, m3lvfm, qx)
             return_value = ja
         endif
      enddo
   end function fmminloc1_fm

   function fmminloc2_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma(:,:)
      integer :: return_value(2)
      integer :: j, k, ja, jb
      logical, external :: fmcomp
      intent (in) :: ma
      type(multi) :: m3lvfm
      type(fm_settings) :: qx
      call fmst2m(' OVERFLOW ', m3lvfm, qx)
      return_value = (/ lbound(ma, dim=1), lbound(ma, dim=2) /)
      do k = 1, size(ma, dim=2)
         do j = 1, size(ma, dim=1)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            if (fmcomp(ma(ja, jb)%mfm, '<', m3lvfm, qx)) then
                call fmeq(ma(ja, jb)%mfm, m3lvfm, qx)
                return_value = (/ ja, jb /)
            endif
         enddo
      enddo
   end function fmminloc2_fm

   function fmminloc1_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma(:)
      integer :: return_value
      integer :: j, ja
      logical, external :: imcomp
      intent (in) :: ma
      type(multi) :: m3lvim
      type(fm_settings) :: qx
      call imst2m(' OVERFLOW ', m3lvim, qx)
      return_value = lbound(ma, dim=1)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         if (imcomp(ma(ja)%mim, '<', m3lvim, qx)) then
             call imeq(ma(ja)%mim, m3lvim, qx)
             return_value = ja
         endif
      enddo
   end function fmminloc1_im

   function fmminloc2_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma(:,:)
      integer :: return_value(2)
      integer :: j, k, ja, jb
      logical, external :: imcomp
      intent (in) :: ma
      type(multi) :: m3lvim
      type(fm_settings) :: qx
      call imst2m(' OVERFLOW ', m3lvim, qx)
      return_value = (/ lbound(ma, dim=1), lbound(ma, dim=2) /)
      do k = 1, size(ma, dim=2)
         do j = 1, size(ma, dim=1)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            if (imcomp(ma(ja, jb)%mim, '<', m3lvim, qx)) then
                call imeq(ma(ja, jb)%mim, m3lvim, qx)
                return_value = (/ ja, jb /)
            endif
         enddo
      enddo
   end function fmminloc2_im

!                                                                 mod

   function fmmod_fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call fmmod(ma%mfm, mb%mfm, return_value%mfm, qx)
   end function fmmod_fm

   function fmmod_im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call immod(ma%mim, mb%mim, return_value%mim, qx)
   end function fmmod_im

!                                                              modulo

   function fmmodulo_fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmmod(ma%mfm, mb%mfm, mtlvfm, qx)
      if (mtlvfm%mp(3) /= 0) then
          if ((ma%mfm%mp(3) > 0 .and. ma%mfm%mp(1) > 0 .and.  &
               mb%mfm%mp(3) > 0 .and. mb%mfm%mp(1) < 0) .or.  &
              (ma%mfm%mp(3) > 0 .and. ma%mfm%mp(1) < 0 .and.  &
               mb%mfm%mp(3) > 0 .and. mb%mfm%mp(1) > 0)) then
              call fmadd_r1(mtlvfm, mb%mfm, qx)
          endif
      endif
      call fmeq(mtlvfm, return_value%mfm, qx)
   end function fmmodulo_fm

   function fmmodulo_im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(multi) :: mtlvim, mulvim
      type(fm_settings) :: qx
      call immod(ma%mim, mb%mim, mtlvim, qx)
      if (mtlvim%mp(3) /= 0) then
          if ((ma%mim%mp(3) > 0 .and. ma%mim%mp(1) > 0 .and.  &
               mb%mim%mp(3) > 0 .and. mb%mim%mp(1) < 0) .or.  &
              (ma%mim%mp(3) > 0 .and. ma%mim%mp(1) < 0 .and.  &
               mb%mim%mp(3) > 0 .and. mb%mim%mp(1) > 0)) then
              call imadd(mtlvim, mb%mim, mulvim, qx)
              call imeq(mulvim, mtlvim, qx)
          endif
      endif
      call imeq(mtlvim, return_value%mim, qx)
   end function fmmodulo_im

!                                                             nearest

   function fmnearest_fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, return_value
      integer :: krsave
      intent (in) :: ma, mb
      type(multi) :: m3lvfm
      type(fm_settings) :: qx
      krsave = qx%kround
      call fmtiny(m3lvfm, qx)
      if (ma%mfm%mp(2) /= qx%mexpun) then
          if (mb%mfm%mp(1) > 0) then
              qx%kround = 2
              call fmadd(ma%mfm, m3lvfm, return_value%mfm, qx)
          else
              qx%kround = -1
              call fmsub(ma%mfm, m3lvfm, return_value%mfm, qx)
          endif
      else
          if (ma%mfm%mp(1) > 0 .and. mb%mfm%mp(1) > 0) then
              call fmeq(m3lvfm, return_value%mfm, qx)
          else if (ma%mfm%mp(1) > 0 .and. mb%mfm%mp(1) < 0) then
              call fmi2m(0, return_value%mfm, qx)
          else if (ma%mfm%mp(1) < 0 .and. mb%mfm%mp(1) > 0) then
              call fmi2m(0, return_value%mfm, qx)
          else
              call fmmpyi_r1(m3lvfm, -1, qx)
              call fmeq(m3lvfm, return_value%mfm, qx)
          endif
      endif
      qx%kround = krsave
   end function fmnearest_fm

!                                                                nint

   function fmnint_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      type (im) :: return_value
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmnint(ma%mfm, mtlvfm, qx)
      call imfm2i(mtlvfm, return_value%mim, qx)
   end function fmnint_fm

   function fmnint_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call imeq(ma%mim, return_value%mim, qx)
   end function fmnint_im

   function fmnint_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      type (im) :: return_value
      intent (in) :: ma
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call zmreal(ma%mzm, mtlvfm, qx)
      call fmnint(mtlvfm, mulvfm, qx)
      call imfm2i(mulvfm, return_value%mim, qx)
   end function fmnint_zm

   function fmnint_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(im) :: mt_im
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call im_eq(fmnint_fm(ma(j)), mt_im)
         call imeq(mt_im%mim, return_value(j)%mim, qx)
      enddo
   end function fmnint_fm1

   function fmnint_im1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(im) :: mt_im
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call im_eq(fmnint_im(ma(j)), mt_im)
         call imeq(mt_im%mim, return_value(j)%mim, qx)
      enddo
   end function fmnint_im1

   function fmnint_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(im) :: mt_im
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call im_eq(fmnint_zm(ma(j)), mt_im)
         call imeq(mt_im%mim, return_value(j)%mim, qx)
      enddo
   end function fmnint_zm1

   function fmnint_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(im) :: mt_im
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call im_eq(fmnint_fm(ma(j, k)), mt_im)
            call imeq(mt_im%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmnint_fm2

   function fmnint_im2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(im) :: mt_im
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call im_eq(fmnint_im(ma(j, k)), mt_im)
            call imeq(mt_im%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmnint_im2

   function fmnint_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(im) :: mt_im
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call im_eq(fmnint_zm(ma(j, k)), mt_im)
            call imeq(mt_im%mim, return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmnint_zm2

!                                                             norm2

   function fmnorm21_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma(:), return_value
      type(multi), allocatable :: a(:)
      integer :: j, ja, n
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmi2m(0, return_value%mfm, qx)
      n = size(ma)
      allocate(a(n))
      do j = 1, n
         ja = lbound(ma, dim=1) + j - 1
         call fmeq(ma(ja)%mfm, a(j), qx)
      enddo
      call fmnorm2(a, n, return_value%mfm, qx)
      deallocate(a)
   end function fmnorm21_fm

!                                                           precision

   function fmprecision_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = int(log10(real(qx%mbase))*(qx%ndig-1) + 1)
      if (allocated(ma%mfm%mp)) then
          if (size(ma%mfm%mp) <= 2) return_value = return_value - 1
      endif
   end function fmprecision_fm

   function fmprecision_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = int(log10(real(qx%mbase))*(qx%ndig-1) + 1)
      if (allocated(ma%mzm(1)%mp)) then
          if (size(ma%mzm(1)%mp) <= 2) return_value = return_value - 1
      endif
   end function fmprecision_zm

!                                                             product

   function fmproduct1_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma(:), return_value
      integer :: j, ja, mxsave, nd2, ndsave
      intent (in) :: ma
      type(multi) :: mulvfm, m3lvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      j = max(qx%ngrd52, 2)
      nd2 = max(2*qx%ndig+j, 3)
      call fmndig(nd2, qx)
      mxsave = qx%mxexp
      qx%mxexp = qx%mxexp2
      call fmi2m(1, m3lvfm, qx)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         call fmequ(ma(ja)%mfm, mulvfm, ndsave, qx%ndig, qx)
         call fmmpy_r1(m3lvfm, mulvfm, qx)
      enddo
      qx%mxexp = mxsave
      call fmequ(m3lvfm, return_value%mfm, qx%ndig, ndsave, qx)
      qx%ndig = ndsave
   end function fmproduct1_fm

   function fmproduct2_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma(:,:), return_value
      integer :: j, k, ja, jb, mxsave, nd2, ndsave
      intent (in) :: ma
      type(multi) :: mulvfm, m3lvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      j = max(qx%ngrd52, 2)
      nd2 = max(2*qx%ndig+j, 3)
      call fmndig(nd2, qx)
      mxsave = qx%mxexp
      qx%mxexp = qx%mxexp2
      call fmi2m(1, m3lvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            call fmequ(ma(ja, jb)%mfm, mulvfm, ndsave, qx%ndig, qx)
            call fmmpy_r1(m3lvfm, mulvfm, qx)
         enddo
      enddo
      qx%mxexp = mxsave
      call fmequ(m3lvfm, return_value%mfm, qx%ndig, ndsave, qx)
      qx%ndig = ndsave
   end function fmproduct2_fm

   function fmproduct1_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma(:), return_value
      integer :: j, ja
      intent (in) :: ma
      type(multi) :: mtlvim, m3lvim
      type(fm_settings) :: qx
      call imi2m(1, m3lvim, qx)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         call immpy(ma(ja)%mim, m3lvim, mtlvim, qx)
         call imeq(mtlvim, m3lvim, qx)
      enddo
      call imeq(m3lvim, return_value%mim, qx)
   end function fmproduct1_im

   function fmproduct2_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma(:,:), return_value
      integer :: j, k, ja, jb
      intent (in) :: ma
      type(multi) :: mtlvim, m3lvim
      type(fm_settings) :: qx
      call imi2m(1, m3lvim, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            call immpy(ma(ja, jb)%mim, m3lvim, mtlvim, qx)
            call imeq(mtlvim, m3lvim, qx)
         enddo
      enddo
      call imeq(m3lvim, return_value%mim, qx)
   end function fmproduct2_im

   function fmproduct1_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma(:), return_value
      integer :: j, ja, mxsave, nd2, ndsave
      intent (in) :: ma
      type(multi) :: mtlvzm(2), mulvzm(2), m3lvzm(2)
      type(fm_settings) :: qx
      ndsave = qx%ndig
      j = max(qx%ngrd52, 2)
      nd2 = max(2*qx%ndig+j, 3)
      call fmndig(nd2, qx)
      mxsave = qx%mxexp
      qx%mxexp = qx%mxexp2
      call zmi2m(1, m3lvzm, qx)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         call zmequ(ma(ja)%mzm, mulvzm, ndsave, qx%ndig, qx)
         call zmmpy(mulvzm, m3lvzm, mtlvzm, qx)
         call zmeq(mtlvzm, m3lvzm, qx)
      enddo
      qx%mxexp = mxsave
      call zmequ(m3lvzm, return_value%mzm, qx%ndig, ndsave, qx)
      qx%ndig = ndsave
   end function fmproduct1_zm

   function fmproduct2_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma(:,:), return_value
      integer :: j, k, ja, jb, mxsave, nd2, ndsave
      intent (in) :: ma
      type(multi) :: mtlvzm(2), mulvzm(2), m3lvzm(2)
      type(fm_settings) :: qx
      ndsave = qx%ndig
      j = max(qx%ngrd52, 2)
      nd2 = max(2*qx%ndig+j, 3)
      call fmndig(nd2, qx)
      mxsave = qx%mxexp
      qx%mxexp = qx%mxexp2
      call zmi2m(1, m3lvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            call zmequ(ma(ja, jb)%mzm, mulvzm, ndsave, qx%ndig, qx)
            call zmmpy(mulvzm, m3lvzm, mtlvzm, qx)
            call zmeq(mtlvzm, m3lvzm, qx)
         enddo
      enddo
      qx%mxexp = mxsave
      call zmequ(m3lvzm, return_value%mzm, qx%ndig, ndsave, qx)
      qx%ndig = ndsave
   end function fmproduct2_zm

!                                                               radix

   function fmradix_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = int(qx%mbase)
      if (allocated(ma%mfm%mp)) then
          if (size(ma%mfm%mp) <= 2) return_value = return_value - 1
      endif
   end function fmradix_fm

   function fmradix_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = int(qx%mbase)
      if (allocated(ma%mim%mp)) then
          if (size(ma%mim%mp) <= 2) return_value = return_value - 1
      endif
   end function fmradix_im

   function fmradix_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = int(qx%mbase)
      if (allocated(ma%mzm(1)%mp)) then
          if (size(ma%mzm(1)%mp) <= 2) return_value = return_value - 1
      endif
   end function fmradix_zm

!                                                               range

   function fmrange_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      integer :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = nint((qx%mxexp+1)*log10(dble(qx%mbase))) - 1
      if (allocated(ma%mfm%mp)) then
          if (size(ma%mfm%mp) <= 2) return_value = return_value - 1
      endif
   end function fmrange_fm

   function fmrange_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer :: return_value
      intent (in) :: ma

!             The number of possible digits for type(im) integers is limited only by the amount
!             of memory that can be allocated.  Return 10**6 since there is no fixed limit.

      return_value = 10**6
      if (allocated(ma%mim%mp)) then
          if (size(ma%mim%mp) <= 2) return_value = return_value - 1
      endif
   end function fmrange_im

   function fmrange_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      integer :: return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      return_value = nint((qx%mxexp+1)*log10(dble(qx%mbase))) - 1
      if (allocated(ma%mzm(1)%mp)) then
          if (size(ma%mzm(1)%mp) <= 2) return_value = return_value - 1
      endif
   end function fmrange_zm


!                                                                real

   function fmreal_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmeq(ma%mfm, return_value%mfm, qx)
   end function fmreal_fm

   function fmreal_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call imi2fm(ma%mim, return_value%mfm, qx)
   end function fmreal_im

   function fmreal_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: return_value
      type (zm) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmreal(ma%mzm, return_value%mfm, qx)
   end function fmreal_zm

!                                                           rrspacing

   function fmrrspacing_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmabs(ma%mfm, mtlvfm, qx)
      mtlvfm%mp(2) = qx%ndig
      call fmeq(mtlvfm, return_value%mfm, qx)
   end function fmrrspacing_fm

!                                                               scale

   function fmscale_fm(ma, l)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      integer :: l
      intent (in) :: ma, l
      type(multi) :: mtlvfm, mulvfm, mvlvfm, m3lvfm
      type(fm_settings) :: qx
      call fmeq(ma%mfm, mtlvfm, qx)
      if (abs(mtlvfm%mp(2)+l) < qx%mxexp) then
          mtlvfm%mp(2) = mtlvfm%mp(2) + l
          call fmeq(mtlvfm, return_value%mfm, qx)
      else
          call fmi2m(int(qx%mbase), mulvfm, qx)
          call fmipwr(mulvfm, l, mvlvfm, qx)
          call fmmpy(ma%mfm, mvlvfm, m3lvfm, qx)
          call fmeq(m3lvfm, return_value%mfm, qx)
      endif
   end function fmscale_fm

   function fmscale_zm(ma, l)     result (return_value)
      use fmvals_parallel
      implicit none
      integer :: l
      type (zm) :: ma, return_value
      intent (in) :: ma, l
      type(multi) :: mtlvzm(2), mulvzm(2), mvlvzm(2), m3lvzm(2)
      type(fm_settings) :: qx
      call zmeq(ma%mzm, mtlvzm, qx)
      if (abs(mtlvzm(1)%mp(2)+l) < qx%mxexp .and. &
          abs(mtlvzm(2)%mp(2)+l) < qx%mxexp) then
          mtlvzm(1)%mp(2) = mtlvzm(1)%mp(2) + l
          mtlvzm(2)%mp(2) = mtlvzm(2)%mp(2) + l
          call zmeq(mtlvzm, return_value%mzm, qx)
      else
          call zmi2m(int(qx%mbase), mulvzm, qx)
          call zmipwr(mulvzm, l, mvlvzm, qx)
          call zmmpy(ma%mzm, mvlvzm, m3lvzm, qx)
          call zmeq(m3lvzm, return_value%mzm, qx)
      endif
   end function fmscale_zm

!                                                         setexponent

   function fmsetexponent_fm(ma, l)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      integer :: l
      intent (in) :: ma, l
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmeq(ma%mfm, mtlvfm, qx)
      mtlvfm%mp(2) = l
      call fmeq(mtlvfm, return_value%mfm, qx)
   end function fmsetexponent_fm

!                                                                sign

   function fmsign_fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call fmsign(ma%mfm, mb%mfm, return_value%mfm, qx)
   end function fmsign_fm

   function fmsign_im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call imsign(ma%mim, mb%mim, return_value%mim, qx)
   end function fmsign_im

 end module fmzm_8_parallel

 module fmzm_9_parallel
    use fmzm_1_parallel

   interface sin
      module procedure fmsin_fm
      module procedure fmsin_zm
      module procedure fmsin_fm1
      module procedure fmsin_zm1
      module procedure fmsin_fm2
      module procedure fmsin_zm2
   end interface

   interface sinh
      module procedure fmsinh_fm
      module procedure fmsinh_zm
      module procedure fmsinh_fm1
      module procedure fmsinh_zm1
      module procedure fmsinh_fm2
      module procedure fmsinh_zm2
   end interface

   interface spacing
      module procedure fmspacing_fm
   end interface

   interface sqrt
      module procedure fmsqrt_fm
      module procedure fmsqrt_zm
      module procedure fmsqrt_fm1
      module procedure fmsqrt_zm1
      module procedure fmsqrt_fm2
      module procedure fmsqrt_zm2
   end interface

   interface sum
      module procedure fmsum1_fm
      module procedure fmsum2_fm
      module procedure fmsum1_im
      module procedure fmsum2_im
      module procedure fmsum1_zm
      module procedure fmsum2_zm
   end interface

   interface tan
      module procedure fmtan_fm
      module procedure fmtan_zm
      module procedure fmtan_fm1
      module procedure fmtan_zm1
      module procedure fmtan_fm2
      module procedure fmtan_zm2
   end interface

   interface tanh
      module procedure fmtanh_fm
      module procedure fmtanh_zm
      module procedure fmtanh_fm1
      module procedure fmtanh_zm1
      module procedure fmtanh_fm2
      module procedure fmtanh_zm2
   end interface

   interface tiny
      module procedure fmtiny_fm
      module procedure fmtiny_im
      module procedure fmtiny_zm
   end interface

   interface transpose
      module procedure fmtranspose_fm
      module procedure fmtranspose_im
      module procedure fmtranspose_zm
   end interface

   interface fm_format
      module procedure fmformat_fm
   end interface

   interface im_format
      module procedure imformat_im
   end interface

   interface zm_format
      module procedure zmformat_zm
   end interface

   interface gcd
      module procedure gcd_im
   end interface

   interface multiply_mod
      module procedure multiplymod_im
   end interface

   interface power_mod
      module procedure powermod_im
   end interface

   interface bernoulli
      module procedure fmbernoulli_fm
   end interface

   interface beta
      module procedure fmbeta_fm
   end interface

   interface binomial
      module procedure fmbinomial_fm
      module procedure fmbinomial_im
      module procedure fmbinomial_i
      module procedure fmbinomial_zm
   end interface

   interface factorial
      module procedure fmfactorial_fm
      module procedure fmfactorial_fm1
      module procedure fmfactorial_fm2
      module procedure fmfactorial_im
      module procedure fmfactorial_im1
      module procedure fmfactorial_im2
      module procedure fmfactorial_zm
      module procedure fmfactorial_zm1
      module procedure fmfactorial_zm2
      module procedure fmfactorial_i
      module procedure fmfactorial_i1
      module procedure fmfactorial_i2
   end interface

   interface gamma
      module procedure fmgamma_fm
      module procedure fmgamma_fm1
      module procedure fmgamma_fm2
      module procedure fmgamma_zm
      module procedure fmgamma_zm1
      module procedure fmgamma_zm2
   end interface

   interface incomplete_beta
      module procedure fmincomplete_beta_fm
   end interface

   interface incomplete_gamma1
      module procedure fmincomplete_gamma1_fm
   end interface

   interface incomplete_gamma2
      module procedure fmincomplete_gamma2_fm
   end interface

   interface log_gamma
      module procedure fmlog_gamma_fm
      module procedure fmlog_gamma_fm1
      module procedure fmlog_gamma_fm2
      module procedure fmlog_gamma_zm
      module procedure fmlog_gamma_zm1
      module procedure fmlog_gamma_zm2
   end interface

   interface polygamma
      module procedure fmpolygamma_fm
      module procedure fmpolygamma_zm
   end interface

   interface pochhammer
      module procedure fmpochhammer_fm
   end interface

   interface psi
      module procedure fmpsi_fm
      module procedure fmpsi_fm1
      module procedure fmpsi_fm2
      module procedure fmpsi_zm
      module procedure fmpsi_zm1
      module procedure fmpsi_zm2
   end interface

   interface bessel_j
      module procedure fmbessel_j_fm
   end interface

   interface bessel_j0
      module procedure fmbessel_j0_fm
   end interface

   interface bessel_j1
      module procedure fmbessel_j1_fm
   end interface

   interface bessel_jn
      module procedure fmbessel_jn_fm
      module procedure fmbessel_jn2_fm
   end interface

   interface bessel_y
      module procedure fmbessel_y_fm
   end interface

   interface bessel_y0
      module procedure fmbessel_y0_fm
   end interface

   interface bessel_y1
      module procedure fmbessel_y1_fm
   end interface

   interface bessel_yn
      module procedure fmbessel_yn_fm
      module procedure fmbessel_yn2_fm
   end interface

   interface cos_integral
      module procedure fmcos_integral_fm
      module procedure fmcos_integral_fm1
      module procedure fmcos_integral_fm2
   end interface

   interface cosh_integral
      module procedure fmcosh_integral_fm
      module procedure fmcosh_integral_fm1
      module procedure fmcosh_integral_fm2
   end interface

   interface exp_integral_ei
      module procedure fmexp_integral_ei_fm
      module procedure fmexp_integral_ei_fm1
      module procedure fmexp_integral_ei_fm2
   end interface

   interface exp_integral_en
      module procedure fmexp_integral_en_fm
   end interface

   interface fresnel_c
      module procedure fmfresnel_c_fm
      module procedure fmfresnel_c_fm1
      module procedure fmfresnel_c_fm2
   end interface

   interface fresnel_s
      module procedure fmfresnel_s_fm
      module procedure fmfresnel_s_fm1
      module procedure fmfresnel_s_fm2
   end interface

   interface erf
      module procedure fmerf_fm
      module procedure fmerf_fm1
      module procedure fmerf_fm2
      module procedure fmerf_zm
      module procedure fmerf_zm1
      module procedure fmerf_zm2
   end interface

   interface erfc
      module procedure fmerfc_fm
      module procedure fmerfc_fm1
      module procedure fmerfc_fm2
      module procedure fmerfc_zm
      module procedure fmerfc_zm1
      module procedure fmerfc_zm2
   end interface

   interface erfc_scaled
      module procedure fmerfc_scaled_fm
      module procedure fmerfc_scaled_fm1
      module procedure fmerfc_scaled_fm2
      module procedure fmerfc_scaled_zm
      module procedure fmerfc_scaled_zm1
      module procedure fmerfc_scaled_zm2
   end interface

   interface log_erfc
      module procedure fmlog_erfc_fm
      module procedure fmlog_erfc_fm1
      module procedure fmlog_erfc_fm2
   end interface

   interface log_integral
      module procedure fmlog_integral_fm
      module procedure fmlog_integral_fm1
      module procedure fmlog_integral_fm2
   end interface

   interface sin_integral
      module procedure fmsin_integral_fm
      module procedure fmsin_integral_fm1
      module procedure fmsin_integral_fm2
   end interface

   interface sinh_integral
      module procedure fmsinh_integral_fm
      module procedure fmsinh_integral_fm1
      module procedure fmsinh_integral_fm2
   end interface

 contains

!                                                                 sin

   function fmsin_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmsin(ma%mfm, return_value%mfm, qx)
   end function fmsin_fm

   function fmsin_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmsin(ma%mzm, return_value%mzm, qx)
   end function fmsin_zm

   function fmsin_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmsin(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmsin_fm1

   function fmsin_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmsin(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsin_zm1

   function fmsin_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsin(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsin_fm2

   function fmsin_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsin(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsin_zm2

!                                                                sinh

   function fmsinh_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmsinh(ma%mfm, return_value%mfm, qx)
   end function fmsinh_fm

   function fmsinh_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmsinh(ma%mzm, return_value%mzm, qx)
   end function fmsinh_zm

   function fmsinh_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmsinh(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmsinh_fm1

   function fmsinh_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmsinh(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsinh_zm1

   function fmsinh_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsinh(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsinh_fm2

   function fmsinh_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsinh(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsinh_zm2

!                                                             spacing

   function fmspacing_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      integer :: kwrnsv
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmabs(ma%mfm, mtlvfm, qx)
      if (mtlvfm%mp(3) /= 0) then
          kwrnsv = qx%kwarn
          qx%kwarn = 0
          call fmulp(mtlvfm, return_value%mfm, qx)
          qx%kwarn = kwrnsv
          if (mtlvfm%mp(2) <= -qx%mxexp) then
              call fmtiny(return_value%mfm, qx)
          endif
      else
          call fmtiny(return_value%mfm, qx)
      endif
   end function fmspacing_fm

!                                                                sqrt

   function fmsqrt_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmsqrt(ma%mfm, return_value%mfm, qx)
   end function fmsqrt_fm

   function fmsqrt_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmsqrt(ma%mzm, return_value%mzm, qx)
   end function fmsqrt_zm

   function fmsqrt_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmsqrt(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmsqrt_fm1

   function fmsqrt_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmsqrt(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmsqrt_zm1

   function fmsqrt_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsqrt(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsqrt_fm2

   function fmsqrt_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsqrt(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmsqrt_zm2

!                                                                 sum

   function fmsum1_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma(:), return_value
      integer :: j, ja, mxsave, nd2, ndsave
      intent (in) :: ma
      type(multi) :: mulvfm, m3lvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      j = max(qx%ngrd52, 2)
      nd2 = max(2*qx%ndig+j, 3)
      call fmndig(nd2, qx)
      mxsave = qx%mxexp
      qx%mxexp = qx%mxexp2
      call fmi2m(0, m3lvfm, qx)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         call fmequ(ma(ja)%mfm, mulvfm, ndsave, qx%ndig, qx)
         call fmadd_r1(m3lvfm, mulvfm, qx)
      enddo
      qx%mxexp = mxsave
      call fmequ(m3lvfm, return_value%mfm, qx%ndig, ndsave, qx)
      qx%ndig = ndsave
   end function fmsum1_fm

   function fmsum2_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma(:,:), return_value
      integer :: j, k, ja, jb, mxsave, nd2, ndsave
      intent (in) :: ma
      type(multi) :: mulvfm, m3lvfm
      type(fm_settings) :: qx
      ndsave = qx%ndig
      j = max(qx%ngrd52, 2)
      nd2 = max(2*qx%ndig+j, 3)
      call fmndig(nd2, qx)
      mxsave = qx%mxexp
      qx%mxexp = qx%mxexp2
      call fmi2m(0, m3lvfm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            call fmequ(ma(ja, jb)%mfm, mulvfm, ndsave, qx%ndig, qx)
            call fmadd_r1(m3lvfm, mulvfm, qx)
         enddo
      enddo
      qx%mxexp = mxsave
      call fmequ(m3lvfm, return_value%mfm, qx%ndig, ndsave, qx)
      qx%ndig = ndsave
   end function fmsum2_fm

   function fmsum1_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma(:), return_value
      integer :: j, ja
      intent (in) :: ma
      type(multi) :: mtlvim, m3lvim
      type(fm_settings) :: qx
      call imi2m(0, m3lvim, qx)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         call imadd(ma(ja)%mim, m3lvim, mtlvim, qx)
         call imeq(mtlvim, m3lvim, qx)
      enddo
      call imeq(m3lvim, return_value%mim, qx)
   end function fmsum1_im

   function fmsum2_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma(:,:), return_value
      integer :: j, k, ja, jb
      intent (in) :: ma
      type(multi) :: mtlvim, m3lvim
      type(fm_settings) :: qx
      call imi2m(0, m3lvim, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            call imadd(ma(ja, jb)%mim, m3lvim, mtlvim, qx)
            call imeq(mtlvim, m3lvim, qx)
         enddo
      enddo
      call imeq(m3lvim, return_value%mim, qx)
   end function fmsum2_im

   function fmsum1_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma(:), return_value
      integer :: j, ja, mxsave, nd2, ndsave
      intent (in) :: ma
      type(multi) :: mtlvzm(2), mulvzm(2), m3lvzm(2)
      type(fm_settings) :: qx
      ndsave = qx%ndig
      j = max(qx%ngrd52, 2)
      nd2 = max(2*qx%ndig+j, 3)
      call fmndig(nd2, qx)
      mxsave = qx%mxexp
      qx%mxexp = qx%mxexp2
      call zmi2m(0, m3lvzm, qx)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         call zmequ(ma(ja)%mzm, mulvzm, ndsave, qx%ndig, qx)
         call zmadd(mulvzm, m3lvzm, mtlvzm, qx)
         call zmeq(mtlvzm, m3lvzm, qx)
      enddo
      qx%mxexp = mxsave
      call zmequ(m3lvzm, return_value%mzm, qx%ndig, ndsave, qx)
      qx%ndig = ndsave
   end function fmsum1_zm

   function fmsum2_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma(:,:), return_value
      integer :: j, k, ja, jb, mxsave, nd2, ndsave
      intent (in) :: ma
      type(multi) :: mtlvzm(2), mulvzm(2), m3lvzm(2)
      type(fm_settings) :: qx
      ndsave = qx%ndig
      j = max(qx%ngrd52, 2)
      nd2 = max(2*qx%ndig+j, 3)
      call fmndig(nd2, qx)
      mxsave = qx%mxexp
      qx%mxexp = qx%mxexp2
      call zmi2m(0, m3lvzm, qx)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            call zmequ(ma(ja, jb)%mzm, mulvzm, ndsave, qx%ndig, qx)
            call zmadd(mulvzm, m3lvzm, mtlvzm, qx)
            call zmeq(mtlvzm, m3lvzm, qx)
         enddo
      enddo
      qx%mxexp = mxsave
      call zmequ(m3lvzm, return_value%mzm, qx%ndig, ndsave, qx)
      qx%ndig = ndsave
   end function fmsum2_zm

!                                                                 tan

   function fmtan_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmtan(ma%mfm, return_value%mfm, qx)
   end function fmtan_fm

   function fmtan_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmtan(ma%mzm, return_value%mzm, qx)
   end function fmtan_zm

   function fmtan_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmtan(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmtan_fm1

   function fmtan_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmtan(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmtan_zm1

   function fmtan_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmtan(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmtan_fm2

   function fmtan_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmtan(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmtan_zm2

!                                                                tanh

   function fmtanh_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmtanh(ma%mfm, return_value%mfm, qx)
   end function fmtanh_fm

   function fmtanh_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmtanh(ma%mzm, return_value%mzm, qx)
   end function fmtanh_zm

   function fmtanh_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmtanh(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmtanh_fm1

   function fmtanh_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmtanh(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmtanh_zm1

   function fmtanh_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmtanh(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmtanh_fm2

   function fmtanh_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmtanh(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmtanh_zm2

!                                                                tiny

   function fmtiny_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmtiny(return_value%mfm, qx)
      if (allocated(ma%mfm%mp)) then
          if (size(ma%mfm%mp) <= 2) call fmmpyi_r1(return_value%mfm, 1, qx)
      endif
   end function fmtiny_fm

   function fmtiny_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, return_value
      intent (in) :: ma
      type(multi) :: mtlvim
      type(fm_settings) :: qx
      call imi2m(1, return_value%mim, qx)
      if (allocated(ma%mim%mp)) then
          if (size(ma%mim%mp) <= 2) call immpyi(return_value%mim, 1, mtlvim, qx)
      endif
   end function fmtiny_im

   function fmtiny_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(multi) :: mtlvfm, mtlvzm(2)
      type(fm_settings) :: qx
      call fmtiny(mtlvfm, qx)
      call zmcmpx(mtlvfm, mtlvfm, return_value%mzm, qx)
      if (allocated(ma%mzm(1)%mp)) then
          if (size(ma%mzm(1)%mp) <= 2) call zmmpyi(return_value%mzm, 1, mtlvzm, qx)
      endif
   end function fmtiny_zm

!                                                           transpose

   function fmtranspose_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma(:,:)
      type (fm), dimension(size(ma, dim=2), size(ma, dim=1)) :: return_value
      integer :: i, j
      intent (in) :: ma
      type(fm_settings) :: qx
      do i = 1, size(ma, dim=1)
         do j = 1, size(ma, dim=2)
            call fmeq(ma(i, j)%mfm, return_value(j, i)%mfm, qx)
         enddo
      enddo
   end function fmtranspose_fm

   function fmtranspose_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma(:,:)
      type (im), dimension(size(ma, dim=2), size(ma, dim=1)) :: return_value
      integer :: i, j
      intent (in) :: ma
      type(fm_settings) :: qx
      do i = 1, size(ma, dim=1)
         do j = 1, size(ma, dim=2)
            call imeq(ma(i, j)%mim, return_value(j, i)%mim, qx)
         enddo
      enddo
   end function fmtranspose_im

   function fmtranspose_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma(:,:)
      type (zm), dimension(size(ma, dim=2), size(ma, dim=1)) :: return_value
      integer :: i, j
      intent (in) :: ma
      type(fm_settings) :: qx
      do i = 1, size(ma, dim=1)
         do j = 1, size(ma, dim=2)
            call zmeq(ma(i, j)%mzm, return_value(j, i)%mzm, qx)
         enddo
      enddo
   end function fmtranspose_zm

!                                                           fm_format

   function fmformat_fm(fmt, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      character(*) :: fmt
      type (fm) :: ma
      character(200) :: return_value
      intent (in) :: fmt, ma
      type(fm_settings) :: qx
      call fmform(fmt, ma%mfm, return_value, qx)
   end function fmformat_fm

!                                                           im_format

   function imformat_im(fmt, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      character(*) :: fmt
      character(200) :: return_value
      type (im) :: ma
      intent (in) :: fmt, ma
      type(fm_settings) :: qx
      call imform(fmt, ma%mim, return_value, qx)
   end function imformat_im

!                                                           zm_format

   function zmformat_zm(fmtr, fmti, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      character(*) :: fmtr, fmti
      character(200) :: return_value
      type (zm) :: ma
      intent (in) :: fmtr, fmti, ma
      type(fm_settings) :: qx
      call zmform(fmtr, fmti, ma%mzm, return_value, qx)
   end function zmformat_zm

!                                                                 gcd

   function gcd_im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call imgcd(ma%mim, mb%mim, return_value%mim, qx)
   end function gcd_im

!                                                        multiply_mod

   function multiplymod_im(ma, mb, mc)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, mc, return_value
      intent (in) :: ma, mb, mc
      type(fm_settings) :: qx
      call immpym(ma%mim, mb%mim, mc%mim, return_value%mim, qx)
   end function multiplymod_im

!                                                           power_mod

   function powermod_im(ma, mb, mc)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, mc, return_value
      intent (in) :: ma, mb, mc
      type(fm_settings) :: qx
      call impmod(ma%mim, mb%mim, mc%mim, return_value%mim, qx)
   end function powermod_im

!                                                           bernoulli

   function fmbernoulli_fm(n)     result (return_value)
      use fmvals_parallel
      implicit none
      type(multi) :: mbern(lmbern)
      integer :: ndbern(lmbern)
      type (fm) :: return_value
      integer :: n
      intent (in) :: n
      type(fm_settings) :: qx
      call fmbernoulli(n, return_value%mfm, mbern, ndbern, qx)
   end function fmbernoulli_fm

!                                                                beta

   function fmbeta_fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call fmbeta(ma%mfm, mb%mfm, return_value%mfm, qx)
   end function fmbeta_fm

!                                                            binomial

   function fmbinomial_fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call fmcomb(ma%mfm, mb%mfm, return_value%mfm, qx)
   end function fmbinomial_fm

   function fmbinomial_im(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call imcomb(ma%mim, mb%mim, return_value%mim, qx)
   end function fmbinomial_im

   function fmbinomial_i(n, k)     result (return_value)
      use fmvals_parallel
      implicit none
      integer :: n, k
      type (im) :: return_value
      intent (in) :: n, k
      type(fm_settings) :: qx
      call imcombi(n, k, return_value%mim, qx)
   end function fmbinomial_i

   function fmbinomial_zm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call zmcomb(ma%mzm, mb%mzm, return_value%mzm, qx)
   end function fmbinomial_zm

!                                                           factorial

   function fmfactorial_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmfact(ma%mfm, return_value%mfm, qx)
   end function fmfactorial_fm

   function fmfactorial_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmfact(ma%mzm, return_value%mzm, qx)
   end function fmfactorial_zm

   function fmfactorial_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmfact(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmfactorial_fm1

   function fmfactorial_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmfact(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmfactorial_zm1

   function fmfactorial_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmfact(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmfactorial_fm2

   function fmfactorial_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmfact(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmfactorial_zm2

   function fmfactorial_im(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: ma, return_value
      intent (in) :: ma
      integer :: ival
      type(fm_settings) :: qx
      call imm2i(ma%mim, ival, qx)
      if (qx%kflag == 0) then
          call imfact(ival, return_value%mim, qx)
      else
          call imunknown(return_value%mim, qx)
          qx%kflag = 0
      endif
   end function fmfactorial_im

   function fmfactorial_im1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call imm2i(ma(j)%mim, ival, qx)
         if (qx%kflag == 0) then
             call imfact(ival, return_value(j)%mim, qx)
         else
             call imunknown(return_value(j)%mim, qx)
             qx%kflag = 0
         endif
      enddo
   end function fmfactorial_im1

   function fmfactorial_im2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imm2i(ma(j, k)%mim, ival, qx)
            if (qx%kflag == 0) then
                call imfact(ival, return_value(j, k)%mim, qx)
            else
                call imst2m(' UNKNOWN ', return_value(j, k)%mim, qx)
                qx%kflag = 0
            endif
         enddo
      enddo
   end function fmfactorial_im2

   function fmfactorial_i(ival)     result (return_value)
      use fmvals_parallel
      implicit none
      type (im) :: return_value
      integer :: ival
      intent (in) :: ival
      type(fm_settings) :: qx
      call imfact(ival, return_value%mim, qx)
   end function fmfactorial_i

   function fmfactorial_i1(ival)     result (return_value)
      use fmvals_parallel
      implicit none
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ival
      type(fm_settings) :: qx
      n = size(ival)
      do j = 1, n
         call imfact(ival(j), return_value(j)%mim, qx)
      enddo
   end function fmfactorial_i1

   function fmfactorial_i2(ival)     result (return_value)
      use fmvals_parallel
      implicit none
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ival
      type(fm_settings) :: qx
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call imfact(ival(j, k), return_value(j, k)%mim, qx)
         enddo
      enddo
   end function fmfactorial_i2

!                                                               gamma

   function fmgamma_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmgam(ma%mfm, return_value%mfm, qx)
   end function fmgamma_fm

   function fmgamma_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmgam(ma%mzm, return_value%mzm, qx)
   end function fmgamma_zm

   function fmgamma_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmgam(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmgamma_fm1

   function fmgamma_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmgam(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmgamma_zm1

   function fmgamma_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmgam(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmgamma_fm2

   function fmgamma_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmgam(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmgamma_zm2

!                                                     incomplete_beta

   function fmincomplete_beta_fm(mx, ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: mx, ma, mb, return_value
      intent (in) :: mx, ma, mb
      type(fm_settings) :: qx
      call fmibta(mx%mfm, ma%mfm, mb%mfm, return_value%mfm, qx)
   end function fmincomplete_beta_fm

!                                                   incomplete_gamma1

   function fmincomplete_gamma1_fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call fmigm1(ma%mfm, mb%mfm, return_value%mfm, qx)
   end function fmincomplete_gamma1_fm

!                                                   incomplete_gamma2

   function fmincomplete_gamma2_fm(ma, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(fm_settings) :: qx
      call fmigm2(ma%mfm, mb%mfm, return_value%mfm, qx)
   end function fmincomplete_gamma2_fm

!                                                           log_gamma

   function fmlog_gamma_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmlngm(ma%mfm, return_value%mfm, qx)
   end function fmlog_gamma_fm

   function fmlog_gamma_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmlngm(ma%mzm, return_value%mzm, qx)
   end function fmlog_gamma_zm

   function fmlog_gamma_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmlngm(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmlog_gamma_fm1

   function fmlog_gamma_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmlngm(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmlog_gamma_zm1

   function fmlog_gamma_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmlngm(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmlog_gamma_fm2

   function fmlog_gamma_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmlngm(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmlog_gamma_zm2

!                                                           polygamma

   function fmpolygamma_fm(n, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      integer :: n
      intent (in) :: n, ma
      type(fm_settings) :: qx
      call fmpgam(n, ma%mfm, return_value%mfm, qx)
   end function fmpolygamma_fm

   function fmpolygamma_zm(n, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      integer :: n
      intent (in) :: n, ma
      type(fm_settings) :: qx
      call zmpgam(n, ma%mzm, return_value%mzm, qx)
   end function fmpolygamma_zm

!                                                          pochhammer

   function fmpochhammer_fm(ma, n)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      integer :: n
      intent (in) :: n, ma
      type(fm_settings) :: qx
      call fmpoch(ma%mfm, n, return_value%mfm, qx)
   end function fmpochhammer_fm

!                                                                 psi

   function fmpsi_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmpsi(ma%mfm, return_value%mfm, qx)
   end function fmpsi_fm

   function fmpsi_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmpsi(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmpsi_fm1

   function fmpsi_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmpsi(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmpsi_fm2

   function fmpsi_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmpsi(ma%mzm, return_value%mzm, qx)
   end function fmpsi_zm

   function fmpsi_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmpsi(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmpsi_zm1

   function fmpsi_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmpsi(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmpsi_zm2

!                                                            bessel_j

   function fmbessel_j_fm(n, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      integer :: n
      intent (in) :: n, ma
      type(fm_settings) :: qx
      call fmbesj(n, ma%mfm, return_value%mfm, qx)
   end function fmbessel_j_fm

!                                                            bessel_j0

   function fmbessel_j0_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmbesj(0, ma%mfm, return_value%mfm, qx)
   end function fmbessel_j0_fm

!                                                            bessel_j1

   function fmbessel_j1_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmbesj(1, ma%mfm, return_value%mfm, qx)
   end function fmbessel_j1_fm

!                                                            bessel_jn

   function fmbessel_jn_fm(n, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      integer :: n
      intent (in) :: n, ma
      type(fm_settings) :: qx
      call fmbesj(n, ma%mfm, return_value%mfm, qx)
   end function fmbessel_jn_fm

!                                                            bessel_jn2

   function fmbessel_jn2_fm(n1, n2, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      integer :: n1, n2, j
      type (fm) :: ma, return_value(abs(n2-n1)+1)
      type(multi), allocatable :: a(:)
      intent (in) :: n1, n2, ma
      type(fm_settings) :: qx
      allocate(a(abs(n2-n1)+1))
      call fmbesj2(n1, n2, ma%mfm, a, qx)
      do j = 1, abs(n2-n1)+1
         call fmeq(a(j), return_value(j)%mfm, qx)
      enddo
      deallocate(a)
   end function fmbessel_jn2_fm

!                                                            bessel_y

   function fmbessel_y_fm(n, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      integer :: n
      intent (in) :: n, ma
      type(fm_settings) :: qx
      call fmbesy(n, ma%mfm, return_value%mfm, qx)
   end function fmbessel_y_fm

!                                                            bessel_y0

   function fmbessel_y0_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmbesy(0, ma%mfm, return_value%mfm, qx)
   end function fmbessel_y0_fm

!                                                            bessel_y1

   function fmbessel_y1_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmbesy(1, ma%mfm, return_value%mfm, qx)
   end function fmbessel_y1_fm

!                                                            bessel_yn

   function fmbessel_yn_fm(n, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      integer :: n
      intent (in) :: n, ma
      type(fm_settings) :: qx
      call fmbesy(n, ma%mfm, return_value%mfm, qx)
   end function fmbessel_yn_fm

!                                                            bessel_yn2

   function fmbessel_yn2_fm(n1, n2, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      integer :: n1, n2, j
      type (fm) :: ma, return_value(abs(n2-n1)+1)
      type(multi), allocatable :: a(:)
      intent (in) :: n1, n2, ma
      type(fm_settings) :: qx
      allocate(a(abs(n2-n1)+1))
      call fmbesy2(n1, n2, ma%mfm, a, qx)
      do j = 1, abs(n2-n1)+1
         call fmeq(a(j), return_value(j)%mfm, qx)
      enddo
      deallocate(a)
   end function fmbessel_yn2_fm

!                                                        cos_integral

   function fmcos_integral_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmci(ma%mfm, return_value%mfm, qx)
   end function fmcos_integral_fm

   function fmcos_integral_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmci(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmcos_integral_fm1

   function fmcos_integral_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmci(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmcos_integral_fm2

!                                                       cosh_integral

   function fmcosh_integral_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmchi(ma%mfm, return_value%mfm, qx)
   end function fmcosh_integral_fm

   function fmcosh_integral_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmchi(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmcosh_integral_fm1

   function fmcosh_integral_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmchi(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmcosh_integral_fm2

!                                                     exp_integral_ei

   function fmexp_integral_ei_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmei(ma%mfm, return_value%mfm, qx)
   end function fmexp_integral_ei_fm

   function fmexp_integral_ei_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmei(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmexp_integral_ei_fm1

   function fmexp_integral_ei_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmei(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmexp_integral_ei_fm2

!                                                     exp_integral_en

   function fmexp_integral_en_fm(n, ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      integer :: n
      intent (in) :: n, ma
      type(fm_settings) :: qx
      call fmen(n, ma%mfm, return_value%mfm, qx)
   end function fmexp_integral_en_fm

!                                                           fresnel_c

   function fmfresnel_c_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmc(ma%mfm, return_value%mfm, qx)
   end function fmfresnel_c_fm

   function fmfresnel_c_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmc(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmfresnel_c_fm1

   function fmfresnel_c_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmc(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmfresnel_c_fm2

!                                                           fresnel_s

   function fmfresnel_s_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fms(ma%mfm, return_value%mfm, qx)
   end function fmfresnel_s_fm

   function fmfresnel_s_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fms(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmfresnel_s_fm1

   function fmfresnel_s_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fms(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmfresnel_s_fm2

!                                                                 erf

   function fmerf_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmerf(ma%mfm, return_value%mfm, qx)
   end function fmerf_fm

   function fmerf_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmerf(ma%mzm, return_value%mzm, qx)
   end function fmerf_zm

   function fmerf_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmerf(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmerf_fm1

   function fmerf_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmerf(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmerf_zm1

   function fmerf_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmerf(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmerf_fm2

   function fmerf_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmerf(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmerf_zm2

!                                                                erfc

   function fmerfc_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmerfc(ma%mfm, return_value%mfm, qx)
   end function fmerfc_fm

   function fmerfc_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmerfc(ma%mzm, return_value%mzm, qx)
   end function fmerfc_zm

   function fmerfc_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmerfc(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmerfc_fm1

   function fmerfc_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmerfc(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmerfc_zm1

   function fmerfc_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmerfc(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmerfc_fm2

   function fmerfc_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmerfc(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmerfc_zm2

!                                                                erfc_scaled

   function fmerfc_scaled_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmerfcs(ma%mfm, return_value%mfm, qx)
   end function fmerfc_scaled_fm

   function fmerfc_scaled_zm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmerfcs(ma%mzm, return_value%mzm, qx)
   end function fmerfc_scaled_zm

   function fmerfc_scaled_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmerfcs(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmerfc_scaled_fm1

   function fmerfc_scaled_zm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call zmerfcs(ma(j)%mzm, return_value(j)%mzm, qx)
      enddo
   end function fmerfc_scaled_zm1

   function fmerfc_scaled_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmerfcs(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmerfc_scaled_fm2

   function fmerfc_scaled_zm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmerfcs(ma(j, k)%mzm, return_value(j, k)%mzm, qx)
         enddo
      enddo
   end function fmerfc_scaled_zm2

!                                                            log_erfc

   function fmlog_erfc_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmlerc(ma%mfm, return_value%mfm, qx)
   end function fmlog_erfc_fm

   function fmlog_erfc_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmlerc(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmlog_erfc_fm1

   function fmlog_erfc_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmlerc(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmlog_erfc_fm2

!                                                        log_integral

   function fmlog_integral_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmli(ma%mfm, return_value%mfm, qx)
   end function fmlog_integral_fm

   function fmlog_integral_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmli(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmlog_integral_fm1

   function fmlog_integral_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmli(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmlog_integral_fm2

!                                                        sin_integral

   function fmsin_integral_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmsi(ma%mfm, return_value%mfm, qx)
   end function fmsin_integral_fm

   function fmsin_integral_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmsi(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmsin_integral_fm1

   function fmsin_integral_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsi(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsin_integral_fm2

!                                                       sinh_integral

   function fmsinh_integral_fm(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmshi(ma%mfm, return_value%mfm, qx)
   end function fmsinh_integral_fm

   function fmsinh_integral_fm1(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm_settings) :: qx
      n = size(ma)
      do j = 1, n
         call fmshi(ma(j)%mfm, return_value(j)%mfm, qx)
      enddo
   end function fmsinh_integral_fm1

   function fmsinh_integral_fm2(ma)     result (return_value)
      use fmvals_parallel
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm_settings) :: qx
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmshi(ma(j, k)%mfm, return_value(j, k)%mfm, qx)
         enddo
      enddo
   end function fmsinh_integral_fm2

 end module fmzm_9_parallel

 module fmzm_10_parallel
   use fmzm_1_parallel

   contains

! Interface routines for calling with the FM, IM, and ZM derived types.

   subroutine fm_abs(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmabs(ma%mfm, mb%mfm, qx)
   end subroutine fm_abs

   subroutine fm_acos(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmacos(ma%mfm, mb%mfm, qx)
   end subroutine fm_acos

   subroutine fm_acosh(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmacosh(ma%mfm, mb%mfm, qx)
   end subroutine fm_acosh

   subroutine fm_add(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call fmadd(ma%mfm, mb%mfm, mc%mfm, qx)
   end subroutine fm_add

   subroutine fm_add_r1(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: mb
      intent (inout) :: ma
      type(fm_settings) :: qx
      call fmadd_r1(ma%mfm, mb%mfm, qx)
   end subroutine fm_add_r1

   subroutine fm_add_r2(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmadd_r2(ma%mfm, mb%mfm, qx)
   end subroutine fm_add_r2

   subroutine fm_addi(ma, ival)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      integer :: ival
      intent (in) :: ival
      type(fm_settings) :: qx
      call fmaddi(ma%mfm, ival, qx)
   end subroutine fm_addi

   subroutine fm_asin(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmasin(ma%mfm, mb%mfm, qx)
   end subroutine fm_asin

   subroutine fm_asinh(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmasinh(ma%mfm, mb%mfm, qx)
   end subroutine fm_asinh

   subroutine fm_atan(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmatan(ma%mfm, mb%mfm, qx)
   end subroutine fm_atan

   subroutine fm_atanh(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmatanh(ma%mfm, mb%mfm, qx)
   end subroutine fm_atanh

   subroutine fm_atn2(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call fmatn2(ma%mfm, mb%mfm, mc%mfm, qx)
   end subroutine fm_atn2

   subroutine fm_big(ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx
      call fmbig(ma%mfm, qx)
   end subroutine fm_big

   subroutine fm_ceiling(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmint(ma%mfm, mtlvfm, qx)
      call fmsub(ma%mfm, mtlvfm, mulvfm, qx)
      if (mulvfm%mp(3) == 0) then
          call fmeq(ma%mfm, mb%mfm, qx)
      else if (ma%mfm%mp(1) > 0) then
          call fmaddi(mtlvfm, 1, qx)
          call fmeq(mtlvfm, mb%mfm, qx)
      else
          call fmeq(mtlvfm, mb%mfm, qx)
      endif
   end subroutine fm_ceiling

   subroutine fm_changebase(ma, mb, new_mbase, new_ndig)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      integer :: new_mbase, new_ndig
      intent (in) :: ma, new_mbase, new_ndig
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmchangebase(ma%mfm, mb%mfm, new_mbase, new_ndig, qx)
   end subroutine fm_changebase

   subroutine fm_chsh(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      type(fm_settings) :: qx
      call fmchsh(ma%mfm, mb%mfm, mc%mfm, qx)
   end subroutine fm_chsh

   function fm_comp(ma, lrel, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma, mb
      intent (in) :: ma, mb
      character(*) :: lrel
      intent (in) :: lrel
      type(fm_settings) :: qx
      return_value = fmcomp(ma%mfm, lrel, mb%mfm, qx)
   end function fm_comp

   subroutine fm_cos(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmcos(ma%mfm, mb%mfm, qx)
   end subroutine fm_cos

   subroutine fm_cosh(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmcosh(ma%mfm, mb%mfm, qx)
   end subroutine fm_cosh

   subroutine fm_cssn(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      type(fm_settings) :: qx
      call fmcssn(ma%mfm, mb%mfm, mc%mfm, qx)
   end subroutine fm_cssn

   subroutine fm_dim(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call fmdim(ma%mfm, mb%mfm, mc%mfm, qx)
   end subroutine fm_dim

   subroutine fm_div(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call fmdiv(ma%mfm, mb%mfm, mc%mfm, qx)
   end subroutine fm_div

   subroutine fm_div_r1(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: mb
      intent (inout) :: ma
      type(fm_settings) :: qx
      call fmdiv_r1(ma%mfm, mb%mfm, qx)
   end subroutine fm_div_r1

   subroutine fm_div_r2(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmdiv_r2(ma%mfm, mb%mfm, qx)
   end subroutine fm_div_r2

   subroutine fm_divi(ma, ival, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival
      intent (in) :: ival
      type(fm_settings) :: qx
      call fmdivi(ma%mfm, ival, mb%mfm, qx)
   end subroutine fm_divi

   subroutine fm_divi_r1(ma, ival)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      integer :: ival
      intent (in) :: ival
      type(fm_settings) :: qx
      call fmdivi_r1(ma%mfm, ival, qx)
   end subroutine fm_divi_r1

   subroutine fm_dp2m(x, ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      double precision :: x
      intent (in) :: x
      type(fm_settings) :: qx
      call fmdp2m(x, ma%mfm, qx)
   end subroutine fm_dp2m

   subroutine fm_dpm(x, ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      double precision :: x
      intent (in) :: x
      type(fm_settings) :: qx
      call fmdpm(x, ma%mfm, qx)
   end subroutine fm_dpm

   subroutine fm_epsilon(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmi2m(1, mtlvfm, qx)
      call fmulp(mtlvfm, mb%mfm, qx)
      if (allocated(ma%mfm%mp)) then
          if (size(ma%mfm%mp) <= 2) call fmmpyi(mb%mfm, 1, mtlvfm, qx)
      endif
   end subroutine fm_epsilon

   subroutine fm_equ(ma, mb, na, nb)

!  Set mb (having nb digits) equal to ma (having na digits).

!  If mb has less precision than ma the result is rounded to nb digits.

!  If mb has more precision the result has zero digits padded on the right, and will have
!  its size increased if needed.

      use fmvals_parallel
      implicit none
      integer :: ka, kb, na, nb, ndsave
      intent (in) :: na, nb
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      ka = na
      kb = nb
      ndsave = qx%ndig
      call fmndig(ka, qx)
      call fmequ(ma%mfm, mb%mfm, ka, kb, qx)
      qx%ndig = ndsave
   end subroutine fm_equ

   subroutine fm_equ_r1(ma, na, nb)

!  Change precision of ma from na digits on input to nb digits on output.

!  If mb has less precision than ma the result is rounded to nb digits.

!  If nb is greater than na the result has zero digits padded on the right, and will have
!  its size increased if needed.

      use fmvals_parallel
      implicit none
      integer :: ka, kb, na, nb, ndsave
      intent (in) :: na, nb
      type (fm) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx
      ka = na
      kb = nb
      ndsave = qx%ndig
      call fmndig(ka, qx)
      call fmequ_r1(ma%mfm, ka, kb, qx)
      qx%ndig = ndsave
   end subroutine fm_equ_r1

   subroutine fm_exp(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmexp(ma%mfm, mb%mfm, qx)
      qx%ndige = 0
   end subroutine fm_exp

   subroutine fm_flag(k)
      use fmvals_parallel
      implicit none
      integer :: k
      intent (inout) :: k
      type(fm_settings) :: qx
      call fmflag(k, qx)
   end subroutine fm_flag

   subroutine fm_form(form, ma, string)
      use fmvals_parallel
      implicit none
      character(*) :: form, string
      intent (in) :: form
      intent (inout) :: string
      type (fm) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmform(form, ma%mfm, string, qx)
   end subroutine fm_form

   subroutine fm_floor(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(multi) :: mtlvfm, mulvfm
      type(fm_settings) :: qx
      call fmint(ma%mfm, mtlvfm, qx)
      call fmsub(ma%mfm, mtlvfm, mulvfm, qx)
      if (mulvfm%mp(3) == 0) then
          call fmeq(ma%mfm, mb%mfm, qx)
      else if (ma%mfm%mp(1) < 0) then
          call fmaddi(mtlvfm, -1, qx)
          call fmeq(mtlvfm, mb%mfm, qx)
      else
          call fmeq(mtlvfm, mb%mfm, qx)
      endif
   end subroutine fm_floor

   subroutine fm_fprt(form, ma)
      use fmvals_parallel
      implicit none
      character(*) :: form
      intent (in) :: form
      type (fm) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmfprt(form, ma%mfm, qx)
   end subroutine fm_fprt

   subroutine fm_fraction(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmeq(ma%mfm, mtlvfm, qx)
      mtlvfm%mp(2) = 0
      call fmeq(mtlvfm, mb%mfm, qx)
   end subroutine fm_fraction

   subroutine fm_hypot(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call fmhypot(ma%mfm, mb%mfm, mc%mfm, qx)
   end subroutine fm_hypot

   subroutine fm_i2m(ival, ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      integer :: ival
      intent (in) :: ival
      type(fm_settings) :: qx
      call fmi2m(ival, ma%mfm, qx)
   end subroutine fm_i2m

   subroutine fm_inp(line, ma, la, lb)
      use fmvals_parallel
      implicit none
      integer :: la, lb
      intent (in) :: la, lb
      character :: line(lb)
      intent (in) :: line
      type (fm) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx
      call fminp(line, ma%mfm, la, lb, qx)
   end subroutine fm_inp

   subroutine fm_int(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmint(ma%mfm, mb%mfm, qx)
   end subroutine fm_int

   subroutine fm_ipwr(ma, ival, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival
      intent (in) :: ival
      type(fm_settings) :: qx
      call fmipwr(ma%mfm, ival, mb%mfm, qx)
   end subroutine fm_ipwr

   subroutine fm_lg10(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmlg10(ma%mfm, mb%mfm, qx)
      qx%ndigli = 0
   end subroutine fm_lg10

   subroutine fm_ln(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmln(ma%mfm, mb%mfm, qx)
      qx%ndigli = 0
   end subroutine fm_ln

   subroutine fm_lni(ival, ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      integer :: ival
      intent (in) :: ival
      type(fm_settings) :: qx
      call fmlni(ival, ma%mfm, qx)
      qx%ndigli = 0
   end subroutine fm_lni

   subroutine fm_m2dp(ma, x)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (in) :: ma
      double precision :: x
      intent (inout) :: x
      type(fm_settings) :: qx
      call fmm2dp(ma%mfm, x, qx)
   end subroutine fm_m2dp

   subroutine fm_m2i(ma, ival)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (in) :: ma
      integer :: ival
      intent (inout) :: ival
      type(fm_settings) :: qx
      call fmm2i(ma%mfm, ival, qx)
   end subroutine fm_m2i

   subroutine fm_m2sp(ma, x)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (in) :: ma
      real :: x
      intent (inout) :: x
      type(fm_settings) :: qx
      call fmm2sp(ma%mfm, x, qx)
   end subroutine fm_m2sp

   subroutine fm_max(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call fmmax(ma%mfm, mb%mfm, mc%mfm, qx)
   end subroutine fm_max

   subroutine fm_min(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call fmmin(ma%mfm, mb%mfm, mc%mfm, qx)
   end subroutine fm_min

   subroutine fm_mod(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call fmmod(ma%mfm, mb%mfm, mc%mfm, qx)
   end subroutine fm_mod

   subroutine fm_modulo(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmmod(ma%mfm, mb%mfm, mtlvfm, qx)
      if (mtlvfm%mp(3) /= 0) then
          if ((ma%mfm%mp(3) > 0 .and. ma%mfm%mp(1) > 0 .and.  &
               mb%mfm%mp(3) > 0 .and. mb%mfm%mp(1) < 0) .or.  &
              (ma%mfm%mp(3) > 0 .and. ma%mfm%mp(1) < 0 .and.  &
               mb%mfm%mp(3) > 0 .and. mb%mfm%mp(1) > 0)) then
              call fmadd_r1(mtlvfm, mb%mfm, qx)
          endif
      endif
      call fmeq(mtlvfm, mc%mfm, qx)
   end subroutine fm_modulo

   subroutine fm_mpy(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call fmmpy(ma%mfm, mb%mfm, mc%mfm, qx)
   end subroutine fm_mpy

   subroutine fm_mpy_r1(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: mb
      intent (inout) :: ma
      type(fm_settings) :: qx
      call fmmpy_r1(ma%mfm, mb%mfm, qx)
   end subroutine fm_mpy_r1

   subroutine fm_mpy_r2(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmmpy_r2(ma%mfm, mb%mfm, qx)
   end subroutine fm_mpy_r2

   subroutine fm_mpyi(ma, ival, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival
      intent (in) :: ival
      type(fm_settings) :: qx
      call fmmpyi(ma%mfm, ival, mb%mfm, qx)
   end subroutine fm_mpyi

   subroutine fm_mpyi_r1(ma, ival)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      integer :: ival
      intent (in) :: ival
      type(fm_settings) :: qx
      call fmmpyi_r1(ma%mfm, ival, qx)
   end subroutine fm_mpyi_r1

   subroutine fm_nearest(ma, mb, mc)
      use fmvals_parallel
      use fmzm_8_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_eq(fmnearest_fm(ma, mb), mc)
   end subroutine fm_nearest

   subroutine fm_nint(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmnint(ma%mfm, mb%mfm, qx)
   end subroutine fm_nint

   subroutine fm_out(ma, line, lb)
      use fmvals_parallel
      implicit none
      integer :: lb
      intent (in) :: lb
      character :: line(lb)
      intent (inout) :: line
      type (fm) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmout(ma%mfm, line, lb, qx)
   end subroutine fm_out

   subroutine fm_pi(ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx
      call fmpi(ma%mfm, qx)
      qx%ndigpi = 0
   end subroutine fm_pi

   subroutine fm_prnt(ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmprnt(ma%mfm, qx)
   end subroutine fm_prnt

   subroutine fm_pwr(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call fmpwr(ma%mfm, mb%mfm, mc%mfm, qx)
   end subroutine fm_pwr

   subroutine fm_read(kread, ma)
      use fmvals_parallel
      implicit none
      integer :: kread
      type (fm) :: ma
      intent (in) :: kread
      intent (inout) :: ma
      type(fm_settings) :: qx
      call fmread(kread, ma%mfm, qx)
   end subroutine fm_read

   subroutine fm_rpwr(ma, ival, jval, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival, jval
      intent (in) :: ival, jval
      type(fm_settings) :: qx
      call fmrpwr(ma%mfm, ival, jval, mb%mfm, qx)
   end subroutine fm_rpwr

   subroutine fm_rrspacing(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmabs(ma%mfm, mtlvfm, qx)
      mtlvfm%mp(2) = qx%ndig
      call fmeq(mtlvfm, mb%mfm, qx)
   end subroutine fm_rrspacing

   subroutine fm_set(nprec)
      use fmvals_parallel
      implicit none
      integer :: nprec
      intent (in) :: nprec
      type(fm_settings) :: qx
      call fmset(nprec, qx)
   end subroutine fm_set

   subroutine fm_setvar(string)
      use fmvals_parallel
      implicit none
      character(*) :: string
      intent (in) :: string
      type(fm_settings) :: qx
      call fmsetvar(string, qx)
   end subroutine fm_setvar

   subroutine fm_sign(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call fmsign(ma%mfm, mb%mfm, mc%mfm, qx)
   end subroutine fm_sign

   subroutine fm_sin(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmsin(ma%mfm, mb%mfm, qx)
   end subroutine fm_sin

   subroutine fm_sinh(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmsinh(ma%mfm, mb%mfm, qx)
   end subroutine fm_sinh

   subroutine fm_sp2m(x, ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      real :: x
      intent (in) :: x
      type(fm_settings) :: qx
      call fmsp2m(x, ma%mfm, qx)
   end subroutine fm_sp2m

   subroutine fm_spacing(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(multi) :: mtlvfm
      type(fm_settings) :: qx
      call fmabs(ma%mfm, mtlvfm, qx)
      call fmulp(mtlvfm, mb%mfm, qx)
   end subroutine fm_spacing

   subroutine fm_sqr(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmsqr(ma%mfm, mb%mfm, qx)
   end subroutine fm_sqr

   subroutine fm_sqr_r1(ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx
      call fmsqr_r1(ma%mfm, qx)
   end subroutine fm_sqr_r1

   subroutine fm_sqrt(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmsqrt(ma%mfm, mb%mfm, qx)
   end subroutine fm_sqrt

   subroutine fm_sqrt_r1(ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx
      call fmsqrt_r1(ma%mfm, qx)
   end subroutine fm_sqrt_r1

   subroutine fm_st2m(string, ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      character(*) :: string
      intent (in) :: string
      type(fm_settings) :: qx
      call fmst2m(string, ma%mfm, qx)
   end subroutine fm_st2m

   subroutine fm_sub(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call fmsub(ma%mfm, mb%mfm, mc%mfm, qx)
   end subroutine fm_sub

   subroutine fm_sub_r1(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: mb
      intent (inout) :: ma
      type(fm_settings) :: qx
      call fmsub_r1(ma%mfm, mb%mfm, qx)
   end subroutine fm_sub_r1

   subroutine fm_sub_r2(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmsub_r2(ma%mfm, mb%mfm, qx)
   end subroutine fm_sub_r2

   subroutine fm_tan(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmtan(ma%mfm, mb%mfm, qx)
   end subroutine fm_tan

   subroutine fm_tanh(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmtanh(ma%mfm, mb%mfm, qx)
   end subroutine fm_tanh

   subroutine fm_tiny(ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx
      call fmtiny(ma%mfm, qx)
   end subroutine fm_tiny

   subroutine fm_ulp(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmulp(ma%mfm, mb%mfm, qx)
   end subroutine fm_ulp

   subroutine fm_vars(qx)
      use fmvals_parallel
      implicit none
      type(fm_settings) :: qx
      call fmvars(qx)
   end subroutine fm_vars

   subroutine fm_writ(kwrite, ma)
      use fmvals_parallel
      implicit none
      integer :: kwrite
      intent (in) :: kwrite
      type (fm) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call fmwrit(kwrite, ma%mfm, qx)
   end subroutine fm_writ

   subroutine im_abs(ma, mb)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call imabs(ma%mim, mb%mim, qx)
   end subroutine im_abs

   subroutine im_add(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call imadd(ma%mim, mb%mim, mc%mim, qx)
   end subroutine im_add

   subroutine im_big(ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx
      call imbig(ma%mim, qx)
   end subroutine im_big

   subroutine im_comb(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call imcomb(ma%mim, mb%mim, mc%mim, qx)
   end subroutine im_comb

   function im_comp(ma, lrel, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma, mb
      intent (in) :: ma, mb
      character(*) :: lrel
      intent (in) :: lrel
      type(fm_settings) :: qx
      return_value = imcomp(ma%mim, lrel, mb%mim, qx)
   end function im_comp

   subroutine im_dim(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call imdim(ma%mim, mb%mim, mc%mim, qx)
   end subroutine im_dim

   subroutine im_div(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call imdiv(ma%mim, mb%mim, mc%mim, qx)
   end subroutine im_div

   subroutine im_divi(ma, ival, mb)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival
      intent (in) :: ival
      type(fm_settings) :: qx
      call imdivi(ma%mim, ival, mb%mim, qx)
   end subroutine im_divi

   subroutine im_divr(ma, mb, mc, md)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, mc, md
      intent (in) :: ma, mb
      intent (inout) :: mc, md
      type(fm_settings) :: qx
      call imdivr(ma%mim, mb%mim, mc%mim, md%mim, qx)
   end subroutine im_divr

   subroutine im_dvir(ma, ival, mb, irem)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival, irem
      intent (in) :: ival
      intent (inout) :: irem
      type(fm_settings) :: qx
      call imdvir(ma%mim, ival, mb%mim, irem, qx)
   end subroutine im_dvir

   subroutine im_fact(ival, ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      integer :: ival
      intent (in) :: ival
      intent (inout) :: ma
      type(fm_settings) :: qx
      call imfact(ival, ma%mim, qx)
   end subroutine im_fact

   subroutine im_fm2i(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (in) :: ma
      type (im) :: mb
      intent (inout) :: mb
      type(fm_settings) :: qx
      call imfm2i(ma%mfm, mb%mim, qx)
   end subroutine im_fm2i

   subroutine im_form(form, ma, string)
      use fmvals_parallel
      implicit none
      character(*) :: form, string
      intent (in) :: form, ma
      type (im) :: ma
      intent (inout) :: string
      type(fm_settings) :: qx
      call imform(form, ma%mim, string, qx)
   end subroutine im_form

   subroutine im_fprt(form, ma)
      use fmvals_parallel
      implicit none
      character(*) :: form
      intent (in) :: form
      type (im) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call imfprt(form, ma%mim, qx)
   end subroutine im_fprt

   subroutine im_gcd(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call imgcd(ma%mim, mb%mim, mc%mim, qx)
   end subroutine im_gcd

   subroutine im_i2fm(ma, mb)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      intent (in) :: ma
      type (fm) :: mb
      intent (inout) :: mb
      type(fm_settings) :: qx
      call imi2fm(ma%mim, mb%mfm, qx)
   end subroutine im_i2fm

   subroutine im_i2m(ival, ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      intent (inout) :: ma
      integer :: ival
      intent (in) :: ival
      type(fm_settings) :: qx
      call imi2m(ival, ma%mim, qx)
   end subroutine im_i2m

   subroutine im_inp(line, ma, la, lb)
      use fmvals_parallel
      implicit none
      integer :: la, lb
      intent (in) :: la, lb
      character :: line(lb)
      intent (in) :: line
      type (im) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx
      call iminp(line, ma%mim, la, lb, qx)
   end subroutine im_inp

   subroutine im_m2dp(ma, x)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      intent (in) :: ma
      double precision :: x
      intent (inout) :: x
      type(fm_settings) :: qx
      call imm2dp(ma%mim, x, qx)
   end subroutine im_m2dp

   subroutine im_m2i(ma, ival)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      intent (in) :: ma
      integer :: ival
      intent (inout) :: ival
      type(fm_settings) :: qx
      call imm2i(ma%mim, ival, qx)
   end subroutine im_m2i

   subroutine im_max(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call immax(ma%mim, mb%mim, mc%mim, qx)
   end subroutine im_max

   subroutine im_min(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call immin(ma%mim, mb%mim, mc%mim, qx)
   end subroutine im_min

   subroutine im_mod(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call immod(ma%mim, mb%mim, mc%mim, qx)
   end subroutine im_mod

   subroutine im_mpy(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call immpy(ma%mim, mb%mim, mc%mim, qx)
   end subroutine im_mpy

   subroutine im_mpyi(ma, ival, mb)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival
      intent (in) :: ival
      type(fm_settings) :: qx
      call immpyi(ma%mim, ival, mb%mim, qx)
   end subroutine im_mpyi

   subroutine im_mpym(ma, mb, mc, md)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md
      type(fm_settings) :: qx
      call immpym(ma%mim, mb%mim, mc%mim, md%mim, qx)
   end subroutine im_mpym

   subroutine im_out(ma, line, lb)
      use fmvals_parallel
      implicit none
      integer :: lb
      intent (in) :: lb
      character :: line(lb)
      intent (inout) :: line
      type (im) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call imout(ma%mim, line, lb, qx)
   end subroutine im_out

   subroutine im_pmod(ma, mb, mc, md)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md
      type(fm_settings) :: qx
      call impmod(ma%mim, mb%mim, mc%mim, md%mim, qx)
   end subroutine im_pmod

   subroutine im_prnt(ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call imprnt(ma%mim, qx)
   end subroutine im_prnt

   subroutine im_pwr(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call impwr(ma%mim, mb%mim, mc%mim, qx)
   end subroutine im_pwr

   subroutine im_read(kread, ma)
      use fmvals_parallel
      implicit none
      integer :: kread
      intent (in) :: kread
      type (im) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx
      call imread(kread, ma%mim, qx)
   end subroutine im_read

   subroutine im_sign(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call imsign(ma%mim, mb%mim, mc%mim, qx)
   end subroutine im_sign

   subroutine im_sqr(ma, mb)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call imsqr(ma%mim, mb%mim, qx)
   end subroutine im_sqr

   subroutine im_st2m(string, ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      intent (inout) :: ma
      character(*) :: string
      intent (in) :: string
      type(fm_settings) :: qx
      call imst2m(string, ma%mim, qx)
   end subroutine im_st2m

   subroutine im_sub(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call imsub(ma%mim, mb%mim, mc%mim, qx)
   end subroutine im_sub

   subroutine im_writ(kwrite, ma)
      use fmvals_parallel
      implicit none
      integer :: kwrite
      intent (in) :: kwrite
      type (im) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call imwrit(kwrite, ma%mim, qx)
   end subroutine im_writ

   subroutine zm_abs(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      intent (in) :: ma
      type (fm) :: mb
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmabs(ma%mzm, mb%mfm, qx)
   end subroutine zm_abs

   subroutine zm_acos(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmacos(ma%mzm, mb%mzm, qx)
   end subroutine zm_acos

   subroutine zm_acosh(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmacosh(ma%mzm, mb%mzm, qx)
   end subroutine zm_acosh

   subroutine zm_add(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call zmadd(ma%mzm, mb%mzm, mc%mzm, qx)
   end subroutine zm_add

   subroutine zm_addi(ma, ival)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      intent (inout) :: ma
      integer :: ival
      intent (in) :: ival
      type(fm_settings) :: qx
      call zmaddi(ma%mzm, ival, qx)
   end subroutine zm_addi

   subroutine zm_arg(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      intent (in) :: ma
      type (fm) :: mb
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmarg(ma%mzm, mb%mfm, qx)
   end subroutine zm_arg

   subroutine zm_asin(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmasin(ma%mzm, mb%mzm, qx)
   end subroutine zm_asin

   subroutine zm_asinh(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmasinh(ma%mzm, mb%mzm, qx)
   end subroutine zm_asinh

   subroutine zm_atan(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmatan(ma%mzm, mb%mzm, qx)
   end subroutine zm_atan

   subroutine zm_atanh(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmatanh(ma%mzm, mb%mzm, qx)
   end subroutine zm_atanh

   subroutine zm_chsh(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      type(fm_settings) :: qx
      call zmchsh(ma%mzm, mb%mzm, mc%mzm, qx)
   end subroutine zm_chsh

   subroutine zm_cmpx(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma, mb
      type (zm) :: mc
      intent (inout) :: mc
      type(fm_settings) :: qx
      call zmcmpx(ma%mfm, mb%mfm, mc%mzm, qx)
   end subroutine zm_cmpx

   subroutine zm_conj(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmconj(ma%mzm, mb%mzm, qx)
   end subroutine zm_conj

   subroutine zm_cos(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmcos(ma%mzm, mb%mzm, qx)
   end subroutine zm_cos

   subroutine zm_cosh(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmcosh(ma%mzm, mb%mzm, qx)
   end subroutine zm_cosh

   subroutine zm_cssn(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      type(fm_settings) :: qx
      call zmcssn(ma%mzm, mb%mzm, mc%mzm, qx)
   end subroutine zm_cssn

   subroutine zm_div(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call zmdiv(ma%mzm, mb%mzm, mc%mzm, qx)
   end subroutine zm_div

   subroutine zm_divi(ma, ival, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival
      intent (in) :: ival
      type(fm_settings) :: qx
      call zmdivi(ma%mzm, ival, mb%mzm, qx)
   end subroutine zm_divi

   subroutine zm_equ(ma, mb, na, nb)

!  Set mb (having nb digits) equal to ma (having na digits).

!  If mb has less precision than ma the result is rounded to nb digits.

!  If mb has more precision the result has zero digits padded on the right, and will have
!  its size increased if needed.

      use fmvals_parallel
      implicit none
      integer :: na, nb
      intent (in) :: na, nb
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmequ(ma%mzm, mb%mzm, na, nb, qx)
   end subroutine zm_equ

   subroutine zm_equ_r1(ma, na, nb)

!  Set ma (having nb digits) equal to ma (having na digits).

!  If nb is less than na the result is rounded to nb digits.

!  If nb is greater than na the result has zero digits padded on the right.

      use fmvals_parallel
      implicit none
      integer :: na, nb
      intent (in) :: na, nb
      type (zm) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx
      call zmequ_r1(ma%mzm, na, nb, qx)
   end subroutine zm_equ_r1

   subroutine zm_exp(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmexp(ma%mzm, mb%mzm, qx)
   end subroutine zm_exp

   subroutine zm_form(form1, form2, ma, string)
      use fmvals_parallel
      implicit none
      character(*) :: form1, form2, string
      intent (in) :: form1, form2
      intent (inout) :: string
      type (zm) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmform(form1, form2, ma%mzm, string, qx)
   end subroutine zm_form

   subroutine zm_fprt(form1, form2, ma)
      use fmvals_parallel
      implicit none
      character(*) :: form1, form2
      intent (in) :: form1, form2
      type (zm) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmfprt(form1, form2, ma%mzm, qx)
   end subroutine zm_fprt

   subroutine zm_i2m(ival, ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      intent (inout) :: ma
      integer :: ival
      intent (in) :: ival
      type(fm_settings) :: qx
      call zmi2m(ival, ma%mzm, qx)
   end subroutine zm_i2m

   subroutine zm_2i2m(ival1, ival2, ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      intent (inout) :: ma
      integer :: ival1, ival2
      intent (in) :: ival1, ival2
      type(fm_settings) :: qx
      call zm2i2m(ival1, ival2, ma%mzm, qx)
   end subroutine zm_2i2m

   subroutine zm_imag(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      intent (in) :: ma
      type (fm) :: mb
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmimag(ma%mzm, mb%mfm, qx)
   end subroutine zm_imag

   subroutine zm_inp(line, ma, la, lb)
      use fmvals_parallel
      implicit none
      integer :: la, lb
      intent (in) :: la, lb
      character :: line(lb)
      intent (in) :: line
      type (zm) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx
      call zminp(line, ma%mzm, la, lb, qx)
   end subroutine zm_inp

   subroutine zm_int(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmint(ma%mzm, mb%mzm, qx)
   end subroutine zm_int

   subroutine zm_ipwr(ma, ival, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival
      intent (in) :: ival
      type(fm_settings) :: qx
      call zmipwr(ma%mzm, ival, mb%mzm, qx)
   end subroutine zm_ipwr

   subroutine zm_lg10(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmlg10(ma%mzm, mb%mzm, qx)
   end subroutine zm_lg10

   subroutine zm_ln(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmln(ma%mzm, mb%mzm, qx)
   end subroutine zm_ln

   subroutine zm_m2i(ma, ival)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      intent (in) :: ma
      integer :: ival
      intent (inout) :: ival
      type(fm_settings) :: qx
      call zmm2i(ma%mzm, ival, qx)
   end subroutine zm_m2i

   subroutine zm_m2z(ma, zval)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      intent (in) :: ma
      complex :: zval
      intent (inout) :: zval
      type(fm_settings) :: qx
      call zmm2z(ma%mzm, zval, qx)
   end subroutine zm_m2z

   subroutine zm_mpy(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call zmmpy(ma%mzm, mb%mzm, mc%mzm, qx)
   end subroutine zm_mpy

   subroutine zm_mpyi(ma, ival, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival
      intent (in) :: ival
      type(fm_settings) :: qx
      call zmmpyi(ma%mzm, ival, mb%mzm, qx)
   end subroutine zm_mpyi

   subroutine zm_nint(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmnint(ma%mzm, mb%mzm, qx)
   end subroutine zm_nint

   subroutine zm_out(ma, line, lb, last1, last2)
      use fmvals_parallel
      implicit none
      integer :: lb, last1, last2
      intent (in) :: lb
      character :: line(lb)
      intent (inout) :: line, last1, last2
      type (zm) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmout(ma%mzm, line, lb, last1, last2, qx)
   end subroutine zm_out

   subroutine zm_prnt(ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmprnt(ma%mzm, qx)
   end subroutine zm_prnt

   subroutine zm_pwr(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call zmpwr(ma%mzm, mb%mzm, mc%mzm, qx)
   end subroutine zm_pwr

   subroutine zm_read(kread, ma)
      use fmvals_parallel
      implicit none
      integer :: kread
      intent (in) :: kread
      type (zm) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx
      call zmread(kread, ma%mzm, qx)
   end subroutine zm_read

   subroutine zm_real(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      intent (in) :: ma
      type (fm) :: mb
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmreal(ma%mzm, mb%mfm, qx)
   end subroutine zm_real

   subroutine zm_rpwr(ma, ival, jval, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival, jval
      intent (in) :: ival, jval
      type(fm_settings) :: qx
      call zmrpwr(ma%mzm, ival, jval, mb%mzm, qx)
   end subroutine zm_rpwr

   subroutine zm_set(nprec)
      use fmvals_parallel
      implicit none
      integer :: nprec
      intent (in) :: nprec
      type(fm_settings) :: qx
      call zmset(nprec, qx)
   end subroutine zm_set

   subroutine zm_sin(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmsin(ma%mzm, mb%mzm, qx)
   end subroutine zm_sin

   subroutine zm_sinh(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmsinh(ma%mzm, mb%mzm, qx)
   end subroutine zm_sinh

   subroutine zm_sqr(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmsqr(ma%mzm, mb%mzm, qx)
   end subroutine zm_sqr

   subroutine zm_sqrt(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmsqrt(ma%mzm, mb%mzm, qx)
   end subroutine zm_sqrt

   subroutine zm_st2m(string, ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      intent (inout) :: ma
      character(*) :: string
      intent (in) :: string
      type(fm_settings) :: qx
      call zmst2m(string, ma%mzm, qx)
   end subroutine zm_st2m

   subroutine zm_sub(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call zmsub(ma%mzm, mb%mzm, mc%mzm, qx)
   end subroutine zm_sub

   subroutine zm_tan(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmtan(ma%mzm, mb%mzm, qx)
   end subroutine zm_tan

   subroutine zm_tanh(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmtanh(ma%mzm, mb%mzm, qx)
   end subroutine zm_tanh

   subroutine zm_writ(kwrite, ma)
      use fmvals_parallel
      implicit none
      integer :: kwrite
      intent (in) :: kwrite
      type (zm) :: ma
      intent (in) :: ma
      type(fm_settings) :: qx
      call zmwrit(kwrite, ma%mzm, qx)
   end subroutine zm_writ

   subroutine zm_z2m(zval, ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      intent (inout) :: ma
      complex :: zval
      intent (in) :: zval
      type(fm_settings) :: qx
      call zmz2m(zval, ma%mzm, qx)
   end subroutine zm_z2m

   subroutine zm_erf(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmerf(ma%mzm, mb%mzm, qx)
   end subroutine zm_erf

   subroutine zm_erfc(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmerfc(ma%mzm, mb%mzm, qx)
   end subroutine zm_erfc

   subroutine zm_erfcs(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmerfcs(ma%mzm, mb%mzm, qx)
   end subroutine zm_erfcs

   subroutine zm_lngm(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmlngm(ma%mzm, mb%mzm, qx)
   end subroutine zm_lngm

   subroutine zm_gam(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmgam(ma%mzm, mb%mzm, qx)
   end subroutine zm_gam

   subroutine zm_fact(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call zmfact(ma%mzm, mb%mzm, qx)
   end subroutine zm_fact

   subroutine fm_atan2(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_atn2(ma, mb, mc)
   end subroutine fm_atan2

   subroutine fm_cosh_sinh(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      call fm_chsh(ma, mb, mc)
   end subroutine fm_cosh_sinh

   function fm_compare(ma, lrel, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      character(*) :: lrel
      type (fm) :: ma, mb
      intent (in) :: ma, lrel, mb
      type(fm_settings) :: qx
      return_value = fmcomp(ma%mfm, lrel, mb%mfm, qx)
   end function fm_compare

   subroutine fm_cos_sin(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      call fm_cssn(ma, mb, mc)
   end subroutine fm_cos_sin

   subroutine fm_euler(ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      call fm_eulr(ma)
   end subroutine fm_euler

   subroutine fm_fprint(form, ma)
      use fmvals_parallel
      implicit none
      character(*) :: form
      type (fm) :: ma
      intent (in) :: form, ma
      call fm_fprt(form, ma)
   end subroutine fm_fprint

   subroutine fm_ipower(ma, ival, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      call fm_ipwr(ma, ival, mb)
   end subroutine fm_ipower

   subroutine fm_log10(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_lg10(ma, mb)
   end subroutine fm_log10

   subroutine fm_print(ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (in) :: ma
      call fm_prnt(ma)
   end subroutine fm_print

   subroutine fm_power(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_pwr(ma, mb, mc)
   end subroutine fm_power

   subroutine fm_rational_power(ma, ival, jval, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      integer :: ival, jval
      intent (in) :: ma, ival, jval
      intent (inout) :: mb
      call fm_rpwr(ma, ival, jval, mb)
   end subroutine fm_rational_power

   subroutine fm_write(kwrite, ma)
      use fmvals_parallel
      implicit none
      integer :: kwrite
      type (fm) :: ma
      intent (in) :: kwrite, ma
      call fm_writ(kwrite, ma)
   end subroutine fm_write

   function im_compare(ma, lrel, mb)     result (return_value)
      use fmvals_parallel
      implicit none
      logical :: return_value
      logical, external :: imcomp
      character(*) :: lrel
      type (im) :: ma, mb
      intent (in) :: ma, lrel, mb
      type(fm_settings) :: qx
      return_value = imcomp(ma%mim, lrel, mb%mim, qx)
   end function im_compare

   subroutine im_fprint(form, ma)
      use fmvals_parallel
      implicit none
      character(*) :: form
      type (im) :: ma
      intent (in) :: form, ma
      call im_fprt(form, ma)
   end subroutine im_fprint

   subroutine im_mpy_mod(ma, mb, mc, md)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md
      call im_mpym(ma, mb, mc, md)
   end subroutine im_mpy_mod

   subroutine im_power_mod(ma, mb, mc, md)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md
      call im_pmod(ma, mb, mc, md)
   end subroutine im_power_mod

   subroutine im_print(ma)
      use fmvals_parallel
      implicit none
      type (im) :: ma
      intent (in) :: ma
      call im_prnt(ma)
   end subroutine im_print

   subroutine im_power(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call im_pwr(ma, mb, mc)
   end subroutine im_power

   subroutine im_write(kwrite, ma)
      use fmvals_parallel
      implicit none
      integer :: kwrite
      intent (in) :: kwrite
      type (im) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx
      call imwrite(kwrite, ma%mim, qx)
   end subroutine im_write

   subroutine zm_cosh_sinh(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      call zm_chsh(ma, mb, mc)
   end subroutine zm_cosh_sinh

   subroutine zm_complex(mafm, mbfm, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: mafm, mbfm
      type (zm) :: mc
      intent (in) :: mafm, mbfm
      intent (inout) :: mc
      call zm_cmpx(mafm, mbfm, mc)
   end subroutine zm_complex

   subroutine zm_conjugate(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call zm_conj(ma, mb)
   end subroutine zm_conjugate

   subroutine zm_cos_sin(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      call zm_cssn(ma, mb, mc)
   end subroutine zm_cos_sin

   subroutine zm_fprint(form1, form2, ma)
      use fmvals_parallel
      implicit none
      character(*) :: form1, form2
      type (zm) :: ma
      intent (in) :: form1, form2, ma
      call zm_fprt(form1, form2, ma)
   end subroutine zm_fprint

   subroutine zm_ipower(ma, ival, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      call zm_ipwr(ma, ival, mb)
   end subroutine zm_ipower

   subroutine zm_log10(ma, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call zm_lg10(ma, mb)
   end subroutine zm_log10

   subroutine zm_print(ma)
      use fmvals_parallel
      implicit none
      type (zm) :: ma
      intent (in) :: ma
      call zm_prnt(ma)
   end subroutine zm_print

   subroutine zm_power(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call zm_pwr(ma, mb, mc)
   end subroutine zm_power

   subroutine zm_rational_power(ma, ival, jval, mb)
      use fmvals_parallel
      implicit none
      type (zm) :: ma, mb
      integer :: ival, jval
      intent (in) :: ma, ival, jval
      intent (inout) :: mb
      call zm_rpwr(ma, ival, jval, mb)
   end subroutine zm_rational_power

   subroutine zm_write(kwrite, ma)
      use fmvals_parallel
      implicit none
      integer :: kwrite
      type (zm) :: ma
      intent (in) :: kwrite, ma
      call zm_writ(kwrite, ma)
   end subroutine zm_write

   subroutine fm_bernoulli(n, ma)
      use fmvals_parallel
      implicit none
      type(multi) :: mbern(lmbern)
      integer :: ndbern(lmbern)
      type (fm) :: ma
      intent (inout) :: ma
      integer :: n
      intent (in) :: n
      type(fm_settings) :: qx
      call fmbernoulli(n, ma%mfm, mbern, ndbern, qx)
   end subroutine fm_bernoulli

   subroutine fm_bern(n, ma, mb)
      use fmvals_parallel
      implicit none
      type(multi) :: mbern(lmbern)
      integer :: ndbern(lmbern)
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: n
      intent (in) :: n
      type(fm_settings) :: qx
      call fmbern(n, ma%mfm, mb%mfm, mbern, ndbern, qx)
   end subroutine fm_bern

   subroutine fm_beta(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call fmbeta(ma%mfm, mb%mfm, mc%mfm, qx)
   end subroutine fm_beta

   subroutine fm_comb(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call fmcomb(ma%mfm, mb%mfm, mc%mfm, qx)
   end subroutine fm_comb

   subroutine fm_eulr(ma)
      use fmvals_parallel
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      type(fm_settings) :: qx
      call fmeulr(ma%mfm, qx)
      qx%ndgeul = 0
   end subroutine fm_eulr

   subroutine fm_fact(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmfact(ma%mfm, mb%mfm, qx)
   end subroutine fm_fact

   subroutine fm_gam(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmgam(ma%mfm, mb%mfm, qx)
   end subroutine fm_gam

   subroutine fm_ibta(ma, mb, mc, md)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md
      type(fm_settings) :: qx
      call fmibta(ma%mfm, mb%mfm, mc%mfm, md%mfm, qx)
   end subroutine fm_ibta

   subroutine fm_igm1(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call fmigm1(ma%mfm, mb%mfm, mc%mfm, qx)
   end subroutine fm_igm1

   subroutine fm_igm2(ma, mb, mc)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(fm_settings) :: qx
      call fmigm2(ma%mfm, mb%mfm, mc%mfm, qx)
   end subroutine fm_igm2

   subroutine fm_lngm(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmlngm(ma%mfm, mb%mfm, qx)
   end subroutine fm_lngm

   subroutine fm_pgam(n, ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: n
      intent (in) :: n
      type(fm_settings) :: qx
      call fmpgam(n, ma%mfm, mb%mfm, qx)
   end subroutine fm_pgam

   subroutine fm_poch(ma, n, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: n
      intent (in) :: n
      type(fm_settings) :: qx
      call fmpoch(ma%mfm, n, mb%mfm, qx)
   end subroutine fm_poch

   subroutine fm_psi(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmpsi(ma%mfm, mb%mfm, qx)
   end subroutine fm_psi

   subroutine fm_besj(n, ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: n
      intent (in) :: n
      type(fm_settings) :: qx
      call fmbesj(n, ma%mfm, mb%mfm, qx)
   end subroutine fm_besj

   subroutine fm_besy(n, ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: n
      intent (in) :: n
      type(fm_settings) :: qx
      call fmbesy(n, ma%mfm, mb%mfm, qx)
   end subroutine fm_besy

   subroutine fm_chi(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmchi(ma%mfm, mb%mfm, qx)
   end subroutine fm_chi

   subroutine fm_ci(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmci(ma%mfm, mb%mfm, qx)
   end subroutine fm_ci

   subroutine fm_ei(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmei(ma%mfm, mb%mfm, qx)
   end subroutine fm_ei

   subroutine fm_en(n, ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: n
      intent (in) :: n
      type(fm_settings) :: qx
      call fmen(n, ma%mfm, mb%mfm, qx)
   end subroutine fm_en

   subroutine fm_c(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmc(ma%mfm, mb%mfm, qx)
   end subroutine fm_c

   subroutine fm_s(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fms(ma%mfm, mb%mfm, qx)
   end subroutine fm_s

   subroutine fm_erf(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmerf(ma%mfm, mb%mfm, qx)
   end subroutine fm_erf

   subroutine fm_erfc(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmerfc(ma%mfm, mb%mfm, qx)
   end subroutine fm_erfc

   subroutine fm_erfcs(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmerfcs(ma%mfm, mb%mfm, qx)
   end subroutine fm_erfcs

   subroutine fm_erfc_scaled(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmerfcs(ma%mfm, mb%mfm, qx)
   end subroutine fm_erfc_scaled

   subroutine fm_lerc(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmlerc(ma%mfm, mb%mfm, qx)
   end subroutine fm_lerc

   subroutine fm_li(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmli(ma%mfm, mb%mfm, qx)
   end subroutine fm_li

   subroutine fm_shi(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmshi(ma%mfm, mb%mfm, qx)
   end subroutine fm_shi

   subroutine fm_si(ma, mb)
      use fmvals_parallel
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(fm_settings) :: qx
      call fmsi(ma%mfm, mb%mfm, qx)
   end subroutine fm_si

 end module fmzm_10_parallel

 module fmzm_parallel

   use fmzm_1_parallel
   use fmzm_2_parallel
   use fmzm_3_parallel
   use fmzm_4_parallel
   use fmzm_5_parallel
   use fmzm_6_parallel
   use fmzm_7_parallel
   use fmzm_8_parallel
   use fmzm_9_parallel
   use fmzm_10_parallel

 end module fmzm_parallel





!  Version 1.4

!  This file collects all the various FM routines from the "More sample programs" page on the
!  FM web site.  See that page for the programs that call these routines and illustrate their
!  use.  Here is a list of the user-callable routines in this file (see the documentation at
!  the top of each routine for explanation of each of the arguments to the routines).

!  1.  Find a minimum or maximum function value of a real function of one variable.

!                   subroutine fm_find_min(min_or_max, ax, bx, tol, xval, fval, f, nf, kprt, ku)

!  2.  n-th derivative of a real function of one variable.

!                   function fm_fprime(n, a, f, nf)

!  3.  n-th derivative of a complex function of one variable.

!                   function zm_fprime(n, a, f, nf)

!  4.  Definite integral for a real function of one variable.

!                   subroutine fm_integrate(f, n, a, b, tol, result, kprt, nw)

!  5.  Inverse matrix for a real n x n matrix.

!                   subroutine fm_inverse(a, n, b, det)

!  6.  Inverse matrix for a complex n x n matrix.

!                   subroutine zm_inverse(a, n, b, det)

!  7.  Generate the real linear system of normal equations for a least square fit.

!                   subroutine fm_geneq(f, a, b, k, x, y, n)

!  8.  Solve a real n x n linear system of equations.

!                   subroutine fm_lin_solve(a, x, b, n, det)

!  9.  Solve a complex n x n linear system of equations.

!                   subroutine zm_lin_solve(a, x, b, n, det)

! 10.  Solve a real differential equation (initial value problem).

!                   subroutine fm_rk14(a, b, n_order, n_function, s, tol, s1)

! 11.  Find a root of a real function of one variable.

!                   subroutine fm_secant(ax, bx, f, nf, root, kprt, ku)

! 12.  Find a root of a complex function of one variable.

!                   subroutine zm_secant(ax, bx, f, nf, root, kprt, ku)

! 13.  Find nr roots of a complex function of one variable.

!                   subroutine zm_roots(nr, f, nf, n_found, list_of_roots, kprt, ku)



      subroutine fm_find_min(min_or_max, ax, bx, tol, xval, fval, f, nf, kprt, ku)
      use fmvals_parallel

!  min_or_max having value 1 means minimize the function, otherwise maximize.
!  ax, bx     define the endpoints of an interval in which the search takes place.
!             Note that the extreme point returned can be an endpoint, ax or bx.
!             For example, to find a relative minimum inside the interval, make sure the
!             function values at ax and bx are not smaller than the relative minimum.
!  tol        is the tolerance for the minimum.  Usually tol should be no less than epsilon(ax),
!             meaning the x-coordinate xval of the extreme point will be accurate to about all
!             the digits carried.  The y-coordinate fval should also be accurate to nearly
!             full precision.
!             The typical graph is nearly parabolic near the minimum, and within sqrt(epsilon(ax))
!             of the minimum all the function values are essentially identical at the user's
!             level of precision.
!             This routine raises precision above the user's level in order to deal with the
!             cancellation error caused by a parabolic-type extreme point (one for which the
!             derivative of f has a simple root).
!             For cases where derivative of f has a multiple root, the cancellation is more
!             severe, and the location of the max or min may not achieve full precision.
!  xval       is returned as the value of x that minimizes (or maximizes) function f(x,nf).
!             It is a relative extreme point, and may not be the global extreme point if the
!             function has more than one extremum on the interval.
!  fval       is returned as the function value at xval.
!  f(x,nf)    is the function to be minimized.  x is the argument and nf is the function
!             number, in case several functions are defined within f.
!  kprt       controls printing within the routine:
!             kprt = 0 for no output
!             kprt = 1 for the approximation to the root and the function
!                      value to be printed once at the end of the routine.
!             kprt = 2 for the approximation to the root and the function
!                      value to be printed each iteration.
!  ku         is the unit number for output if kprt > 0.

!  The method used is a combination of golden section search and successive parabolic interpolation.
!  Convergence is never much slower than that for a fibonacci search.  If f has a continuous second
!  derivative which is positive at the minimum (which is not at ax or bx), then convergence is
!  superlinear, and usually of the order of about 1.324....

!  This routine is a slightly modified translation of function fval from netlib, which was adapted
!  from the algol 60 procedure localmin given by Richard Brent in Algorithms For Minimization
!  Without Derivatives, Prentice-Hall (1973).

      implicit none
      integer :: min_or_max, nf, kprt, ku
      type (fm) :: ax, bx, tol, xval, fval
      type (multi), external :: f
      intent (in) :: min_or_max, ax, bx, tol, nf, kprt, ku
      intent (inout) :: xval, fval

      character(80) :: st1, st2
      character(10) str_format
      integer :: j, kl, minv, ndsave
      type (multi) :: a, ax2, b, bx2, c, d, e, eps, xm, p, q, r, t2, u, v, w, fu, fv, fw, fx,  &
                      x, tol1, tol2, tol3, mxy(4)
      logical, external :: fmcomp
      type(fm_settings) :: qx

!             Raise precision.

      ndsave = qx%ndig
      qx%ndig = 3*qx%ndig
      call fmequ(ax%mfm, ax2, ndsave, qx%ndig, qx)
      call fmequ(bx%mfm, bx2, ndsave, qx%ndig, qx)
      call fmequ(tol%mfm, tol2, ndsave, qx%ndig, qx)

      minv = 1
      if (min_or_max /= 1) minv = -1

!             str_format is the format used for tracing output if kprt > 0.

      j = min(log10(dble(qx%mbase))*(ndsave-1)+1, dble(50))
      write (str_format, "(a, i2, a, i2)") 'es', j+15, '.', j

!             c is the squared inverse of the golden ratio.

      call fmi2m(5, mxy(1), qx)
      call fmsqrt(mxy(1), mxy(2), qx)
      call fmi2m(3, mxy(1), qx)
      call fmsub(mxy(1), mxy(2), mxy(3), qx)
      call fmdivi(mxy(3), 2, c, qx)

!             eps is approximately the square root of the relative machine precision.

      call fmi2m(1, mxy(1), qx)
      call fmulp(mxy(1), eps, qx)
      call fmadd(eps, mxy(1), tol1, qx)
      call fmsqrt_r1(eps, qx)

      call fmmin(ax2, bx2, a, qx)
      call fmmax(ax2, bx2, b, qx)
      call fmsub(b, a, mxy(1), qx)
      call fmmpy(c, mxy(1), mxy(2), qx)
      call fmadd(a, mxy(2), v, qx)
      call fmeq(v, w, qx)
      call fmeq(v, x, qx)
      call fmi2m(0, e, qx)
      call fmeq(f(x, nf, qx), fx, qx)
      call fmmpyi_r1(fx, minv, qx)
      call fmeq(fx, fv, qx)
      call fmeq(fx, fw, qx)
      call fmdivi(tol2, 3, tol3, qx)
      j = 1

      if (kprt == 2) then
          write (ku,*) ' '
          if (min_or_max == 1) then
              write (ku,*) ' fm_find_min.  Begin trace of all iterations.'
              write (ku,*) '               Search for a relative minimum on the interval'
              call fmform('es20.10', ax2, st1, qx)
              call fmform('es20.10', bx2, st2, qx)
              write (ku, "(13x, a, '    to ', a/)") trim(st1), trim(st2)
          else
              write (ku,*) ' fm_find_min.  Begin trace of all iterations.'
              write (ku,*) '               Search for a relative maximum on the interval'
              call fmform('es20.10', ax2, st1, qx)
              call fmform('es20.10', bx2, st2, qx)
              write (ku, "(13x, a, '    to ', a/)") trim(st1), trim(st2)
          endif
          call fmform(str_format, x, st1, qx)
          call fmmpyi(fx, minv, mxy(1), qx)
          call fmform(str_format, mxy(1), st2, qx)
          write (ku, "('      j =', i3, 4x, '  x  = ', a)") j, trim(st1)
          write (ku, "('         ', 3x, 4x, 'f(x) = ', a/)") trim(st2)
      endif

!             The main loop starts here.

      kl = 1
      do while (kl == 1)
         kl = 0
         call fmadd(a, b, mxy(1), qx)
         call fmdivi(mxy(1), 2, xm, qx)
         call fmabs(x, mxy(1), qx)
         call fmmpy(eps, mxy(1), mxy(2), qx)
         call fmadd(mxy(2), tol3, tol1, qx)
         call fmmpyi(tol1, 2, t2, qx)

!             Check the stopping criterion.

         call fmsub(x, xm, mxy(1), qx)
         call fmabs(mxy(1), mxy(2), qx)
         call fmsub(b, a, mxy(1), qx)
         call fmdivi_r1(mxy(1), 2, qx)
         call fmsub(t2, mxy(1), mxy(3), qx)
         if (fmcomp(mxy(2), '<=', mxy(3), qx)) exit
         call fmi2m(0, p, qx)
         call fmi2m(0, q, qx)
         call fmi2m(0, r, qx)
         call fmabs(e, mxy(1), qx)
         if (fmcomp(mxy(1), '>', tol1, qx)) then

!                  Fit a parabola.

             call fmsub(x, w, mxy(1), qx)
             call fmsub(fx, fv, mxy(2), qx)
             call fmmpy(mxy(1), mxy(2), r, qx)
             call fmsub(x, v, mxy(1), qx)
             call fmsub(fx, fw, mxy(2), qx)
             call fmmpy(mxy(1), mxy(2), q, qx)
             call fmsub(x, v, mxy(1), qx)
             call fmmpy_r1(mxy(1), q, qx)
             call fmsub(x, w, mxy(2), qx)
             call fmmpy_r1(mxy(2), r, qx)
             call fmsub(mxy(1), mxy(2), p, qx)
             call fmsub(q, r, mxy(1), qx)
             call fmmpyi(mxy(1), 2, q, qx)
             if (q%mp(1) > 0) then
                 call fmnegate(p, qx)
             else
                 call fmnegate(q, qx)
             endif
             call fmeq(e, r, qx)
             call fmeq(d, e, qx)
         endif

         call fmabs(p, mxy(1), qx)
         call fmmpy(q, r, mxy(2), qx)
         call fmdivi_r1(mxy(2), 2, qx)
         mxy(2)%mp(1) = 1
         call fmsub(a, x, mxy(3), qx)
         call fmmpy_r2(q, mxy(3), qx)
         call fmsub(b, x, mxy(4), qx)
         call fmmpy_r2(q, mxy(4), qx)
         if (fmcomp(mxy(1), '>=', mxy(2), qx) .or. fmcomp(p, '<=', mxy(3), qx) .or.  &
             fmcomp(p, '>=', mxy(4), qx)) then

!                  Make a golden-section step.

             if (fmcomp(x, '<', xm, qx)) then
                 call fmsub(b, x, e, qx)
             else
                 call fmsub(a, x, e, qx)
             endif
             call fmmpy(c, e, d, qx)
         else

!                  Make a parabolic-interpolation step.

             call fmdiv(p, q, d, qx)
             call fmadd(x, d, u, qx)

!                  f must not be evaluated too close to ax or bx.

             call fmsub(u, a, mxy(1), qx)
             call fmsub(b, u, mxy(2), qx)
             if (.not. (fmcomp(mxy(1), '>=', t2, qx) .and. fmcomp(mxy(2), '>=', t2, qx))) then
                 call fmeq(tol1, d, qx)
                 if (fmcomp(x, '>=', xm, qx)) call fmnegate(d, qx)
             endif
         endif

!              f must not be evaluated too close to x.

         call fmabs(d, mxy(1), qx)
         if (fmcomp(mxy(1), '>=', tol1, qx)) then
             call fmadd(x, d, u, qx)
         else
             if (d%mp(1) > 0) then
                 call fmadd(x, tol1, u, qx)
             else
                 call fmsub(x, tol1, u, qx)
             endif
         endif
         call fmeq(f(u, nf, qx), fu, qx)
         call fmmpyi_r1(fu, minv, qx)

         j = j + 1
         if (kprt == 2) then
             call fmform(str_format, u, st1, qx)
             call fmmpyi(fu, minv, mxy(1), qx)
             call fmform(str_format, mxy(1), st2, qx)
             write (ku, "('      j =', i3, 4x, '  x  = ', a)") j, trim(st1)
             write (ku, "('         ', 3x, 4x, 'f(x) = ', a/)") trim(st2)
         endif

!             update  a, b, v, w, and x.

         if (fmcomp(fx, '<=', fu, qx)) then
             if (fmcomp(u, '<', x, qx)) then
                 call fmeq(u, a, qx)
             else
                 call fmeq(u, b, qx)
             endif
         endif
         if (fmcomp(fu, '<=', fx, qx)) then
             if (fmcomp(u, '<', x, qx)) then
                 call fmeq(x, b, qx)
             else
                 call fmeq(x, a, qx)
             endif
             call fmeq(w, v, qx)
             call fmeq(fw, fv, qx)
             call fmeq(x, w, qx)
             call fmeq(fx, fw, qx)
             call fmeq(u, x, qx)
             call fmeq(fu, fx, qx)
             kl = 1
             cycle
         endif

         if (.not. (fmcomp(fu, '>', fw, qx) .and. fmcomp(w, '/=', x, qx))) then
             call fmeq(w, v, qx)
             call fmeq(fw, fv, qx)
             call fmeq(u, w, qx)
             call fmeq(fu, fw, qx)
             kl = 1
             cycle
         endif

         if (fmcomp(fu, '>', fv, qx) .and. fmcomp(v, '/=', x, qx) .and. fmcomp(v, '/=', w, qx)) then
             kl = 1
             cycle
         endif
         call fmeq(u, v, qx)
         call fmeq(fu, fv, qx)
         kl = 1
      enddo

!             end of main loop.  Round the results back to the user's precision.

      call fmequ(x, xval%mfm, qx%ndig, ndsave, qx)
      call fmmpyi(fx, minv, mxy(1), qx)
      call fmequ(mxy(1), fval%mfm, qx%ndig, ndsave, qx)
      qx%ndig = ndsave

      if (kprt >= 1) then
          if (kprt == 1) write (ku,*) ' '
          if (min_or_max == 1) then
              call fmform('es20.10', ax%mfm, st1, qx)
              call fmform('es20.10', bx%mfm, st2, qx)
              write (ku, "('  fm_find_min.   Function ', i3, i6, ' iterations.  A relative " //  &
                         "minimum on interval'/13x, a, '    to ', a, '  is')")                   &
                     nf, j, trim(st1), trim(st2)
              call fmform(str_format, xval%mfm, st1, qx)
              call fmform(str_format, fval%mfm, st2, qx)
              write (ku, "(15x, '   x  = ', a)") trim(st1)
              write (ku, "(15x, ' f(x) = ', a)") trim(st2)
          else
              call fmform('es20.10', ax%mfm, st1, qx)
              call fmform('es20.10', bx%mfm, st2, qx)
              write (ku, "('  fm_find_min.   Function ', i3, i6, ' iterations.  A relative " //  &
                         "maximum on interval'/13x, a, '    to ', a, '  is')")                   &
                     nf, j, trim(st1), trim(st2)
              call fmform(str_format, xval%mfm, st1, qx)
              call fmform(str_format, fval%mfm, st2, qx)
              write (ku, "(15x, '   x  = ', a)") trim(st1)
              write (ku, "(15x, ' f(x) = ', a)") trim(st2)
          endif
          write (ku,*) ' '
      endif

      return
      end subroutine fm_find_min

      function fm_fprime(n, a, f, nf)     result (return_value)
      use fmvals_parallel
      implicit none

!  This routine finds the n-th derivative of f(x,nf), evaluated at a.
!  nf is passed on to function f to indicate which function to use in cases where several
!  different functions may be defined there.

!  f must be defined in an interval containing a, so that f can be sampled on both sides of a.

!  n may be zero, so that in cases where f suffers cancellation error at a, an accurate
!  function value is returned.

!  fm_fprime tries to return full accuracy for the derivative, by raising precision above
!  the user's level and using difference formulas.

      integer :: n, nf
      type (fm) :: a, return_value
      type (multi), external :: f
      intent (in) :: n, a, nf

      type(fm_settings) :: qx

      call fmfprime2(n, a%mfm, f, nf, return_value%mfm, qx)

      return
      end function fm_fprime

      subroutine fmfprime2(n, a, f, nf, return_value, qx)
      use fmvals_parallel
      implicit none

      integer :: n, nf
      type (multi) :: a, return_value
      type (multi), external :: f
      type(fm_settings) :: qx
      intent (in) :: n, a, nf
      intent (inout) :: return_value, qx

      integer :: j, k, kwarn_save, ndsave
      type (multi) :: d1, d2, f1, f2, fmh, fph, h, tol, tol2, x1, xmh, xph, mxy(4)
      logical, external :: fmcomp

!             Raise precision slightly.

      ndsave = qx%ndig
      qx%ndig = qx%ndig + qx%ngrd52
      call fmequ(a, x1, ndsave, qx%ndig, qx)
      kwarn_save = qx%kwarn
      qx%kwarn = 0

      call fmi2m(0, d2, qx)
      call fmeq(f(x1, nf, qx), f1, qx)
      if (fmcomp(f1, '/=', d2, qx)) then
          call fmulp(f1, tol, qx)
      else
          call fmi2m(1, mxy(1), qx)
          call fmulp(mxy(1), tol, qx)
      endif
      call fmabs(tol, mxy(2), qx)
      call fmeq(mxy(2), tol, qx)

!             Check for a legal function value.

      if (f1%mp(2) == qx%munkno .or. f1%mp(2) == qx%mexpov .or.  &
          f1%mp(2) == qx%mexpun .or. n < 0) then
          call fmunknown(d2, qx)
          call fmequ(d2, return_value, qx%ndig, ndsave, qx)
          qx%ndig = ndsave
          qx%kwarn = kwarn_save
          return
      endif
      call fmeq(f1, f2, qx)

!             Loop at increasing precision until the difference formula is accurate.

      do j = 1, 100
         qx%ndig = 2*qx%ndig

!             Define the variables used below at the new higher precision.

         call fmequ(d2, d1, qx%ndig/2, qx%ndig, qx)
         call fmequ(f2, f1, qx%ndig/2, qx%ndig, qx)
         call fmequ(tol, tol2, ndsave, qx%ndig, qx)
         call fmequ(a, x1, ndsave, qx%ndig, qx)

!             Special case for n = 0.

         if (n == 0) then
             call fmeq(f(x1, nf, qx), f2, qx)
             call fmeq(f2, d2, qx)
             call fmsub(f2, f1, mxy(1), qx)
             call fmabs(mxy(1), mxy(2), qx)
             if (fmcomp(mxy(2), '<', tol2, qx)) then
                 call fmequ(d2, return_value, qx%ndig, ndsave, qx)
                 qx%ndig = ndsave
                 qx%kwarn = kwarn_save
                 return
             endif
             cycle
         endif
         call fmeq(f1, f2, qx)

!             Special case for n = 1.

         if (n == 1) then
             if (x1%mp(3) /= 0) then
                 call fmulp(x1, h, qx)
             else
                 call fmi2m(1, mxy(1), qx)
                 call fmulp(mxy(1), h, qx)
             endif
             h%mp(1) = 1
             call fmsqrt_r1(h, qx)
             call fmadd(x1, h, xph, qx)
             call fmsub(x1, h, xmh, qx)
             call fmeq(f(xph, nf, qx), fph, qx)
             call fmeq(f(xmh, nf, qx), fmh, qx)
             call fmsub(fph, fmh, d2, qx)
             call fmdivi_r1(d2, 2, qx)
             call fmdiv_r1(d2, h, qx)
             call fmsub(d2, d1, mxy(1), qx)
             mxy(1)%mp(1) = 1
             if (fmcomp(mxy(1), '<', tol2, qx) .and. j > 1) then
                 call fmequ(d2, return_value, qx%ndig, ndsave, qx)
                 qx%ndig = ndsave
                 qx%kwarn = kwarn_save
                 return
             endif
             cycle
         endif

!             General case for even n > 1.

         if (mod(n, 2) == 0) then
             if (x1%mp(3) /= 0) then
                 call fmulp(x1, h, qx)
             else
                 call fmi2m(1, mxy(1), qx)
                 call fmulp(mxy(1), h, qx)
             endif
             call fmi2m(1, mxy(1), qx)
             call fmdivi_r1(mxy(1), n+2, qx)
             call fmabs(h, mxy(2), qx)
             call fmpwr(mxy(2), mxy(1), h, qx)
             call fmeq(f(x1, nf, qx), fph, qx)
             call fmi2m(n, mxy(1), qx)
             call fmi2m(n/2, mxy(2), qx)
             call fmcomb(mxy(1), mxy(2), mxy(3), qx)
             call fmmpy(mxy(3), fph, d2, qx)
             call fmmpyi_r1(d2,(-1)**(n/2), qx)
             do k = 0, n/2-1
                call fmmpyi(h, n/2-k, mxy(1), qx)
                call fmadd(x1, mxy(1), xph, qx)
                call fmeq(f(xph, nf, qx), fph, qx)
                call fmsub(x1, mxy(1), xmh, qx)
                call fmeq(f(xmh, nf, qx), fmh, qx)
                call fmadd(fph, fmh, mxy(4), qx)
                call fmi2m(n, mxy(1), qx)
                call fmi2m(k, mxy(2), qx)
                call fmcomb(mxy(1), mxy(2), mxy(3), qx)
                call fmmpy_r2(mxy(3), mxy(4), qx)
                call fmmpyi_r1(mxy(4),(-1)**k, qx)
                call fmadd_r1(d2, mxy(4), qx)
             enddo
             call fmipwr(h, n, mxy(1), qx)
             call fmdiv_r1(d2, mxy(1), qx)
             call fmsub(d2, d1, mxy(1), qx)
             call fmabs(mxy(1), mxy(2), qx)
             if (fmcomp(mxy(2), '<', tol2, qx) .and. j > 1) then
                 call fmequ(d2, return_value, qx%ndig, ndsave, qx)
                 qx%ndig = ndsave
                 qx%kwarn = kwarn_save
                 return
             endif
             cycle
         endif

!             General case for odd n > 1.

         if (mod(n, 2) == 1) then
             if (x1%mp(3) /= 0) then
                 call fmulp(x1, h, qx)
             else
                 call fmi2m(1, mxy(1), qx)
                 call fmulp(mxy(1), h, qx)
             endif
             call fmi2m(1, mxy(1), qx)
             call fmdivi_r1(mxy(1), n+2, qx)
             call fmabs(h, mxy(2), qx)
             call fmpwr(mxy(2), mxy(1), h, qx)
             call fmi2m(0, d2, qx)
             do k = 0, n/2
                call fmmpyi(h, n/2-k+1, mxy(1), qx)
                call fmadd(x1, mxy(1), mxy(2), qx)
                call fmeq(f(mxy(2), nf, qx), mxy(3), qx)
                call fmsub(x1, mxy(1), mxy(2), qx)
                call fmeq(f(mxy(2), nf, qx), mxy(4), qx)
                call fmsub_r2(mxy(3), mxy(4), qx)
                call fmi2m(n-1, mxy(1), qx)
                call fmi2m(k, mxy(2), qx)
                call fmcomb(mxy(1), mxy(2), mxy(3), qx)
                call fmmpy_r2(mxy(3), mxy(4), qx)
                call fmmpyi_r1(mxy(4),(-1)**k, qx)
                call fmmpyi_r1(mxy(4), n*(n+1-2*k), qx)
                call fmdivi_r1(mxy(4),(n-k)*(n+1-k), qx)
                call fmadd_r1(d2, mxy(4), qx)
             enddo
             call fmipwr(h, n, mxy(1), qx)
             call fmmpyi_r1(mxy(1), 2, qx)
             call fmdiv_r1(d2, mxy(1), qx)
             call fmsub(d2, d1, mxy(1), qx)
             call fmabs(mxy(1), mxy(2), qx)
             if (fmcomp(mxy(2), '<', tol2, qx) .and. j > 1) exit
             cycle
         endif
      enddo

!             Round and return.

      call fmequ(d2, return_value, qx%ndig, ndsave, qx)
      qx%ndig = ndsave
      qx%kwarn = kwarn_save
      end subroutine fmfprime2

      subroutine fm_geneq(f, a, b, k, x, y, n)
      use fmvals_parallel
      implicit none

!  Generate the k x k matrix a and k x 1 vector b of normal equations for the least square
!  fit of the k-parameter model

!     y = c(1)*f(1,x) + ... + c(k)*f(k,x)

!  to the data points (x(j),y(j)), j = 1, 2, ..., n.

!  a and b are returned, and then the coefficients c can be found by solving the
!  linear system  a * c = b.

!  Function l in the model evaluated at x is referenced by f(l,x) in this routine,
!  and f should be supplied as an external function subprogram by the user.

      integer :: k, n
      type (fm) :: a(k, k), b(k), x(n), y(n)
      type (multi), external :: f
      intent (in) :: k, x, y, n
      intent (inout) :: a, b

      type (multi), allocatable :: fxi(:)
      integer :: i, j, l, ndsave
      type (multi) :: xi, yi, fxil, mxy(2)
      type(fm_settings) :: qx

      if (n <= 0 .or. k <= 0) then
          write (*, "(/' Error in fm_geneq.  k, n=', 2i8/)") k, n
          stop
      endif

      allocate(fxi(k), stat=j)
      if (j /= 0) then
          write (*, "(/' Error in fm_geneq.  Unable to allocate fxi with size ', i8/)") k
          stop
      endif

!             Raise precision.

      ndsave = qx%ndig
      qx%ndig = 2*qx%ndig

!             Initialize the upper triangle of a.

      do i = 1, k
         do j = i, k
            call fmi2m(0, a(i, j)%mfm, qx)
         enddo
         call fmi2m(0, b(i)%mfm, qx)
      enddo

!             Loop over the data points.

      do i = 1, n
         call fmequ(x(i)%mfm, xi, ndsave, qx%ndig, qx)
         call fmequ(y(i)%mfm, yi, ndsave, qx%ndig, qx)

!             Compute the k function values at x(i).

         do j = 1, k
            call fmeq(f(j, xi, qx), fxi(j), qx)
         enddo

!             Multiply the function values and add the products to the matrix.

         do l = 1, k
            call fmeq(fxi(l), fxil, qx)
            do j = l, k
               call fmmpy(fxil, fxi(j), mxy(1), qx)
               call fmadd_r1(a(l, j)%mfm, mxy(1), qx)
            enddo

!             Sum the right-hand-side term.

            call fmmpy(fxil, yi, mxy(1), qx)
            call fmadd_r1(b(l)%mfm, mxy(1), qx)
         enddo
      enddo

!             Round back to the user's precision.

      do i = 1, k
         do j = i, k
            call fmequ_r1(a(i, j)%mfm, qx%ndig, ndsave, qx)
         enddo
         call fmequ_r1(b(i)%mfm, qx%ndig, ndsave, qx)
      enddo
      qx%ndig = ndsave

!             Fill the lower triangle of the a matrix using symmetry.

      if (k >= 2) then
          do i = 2, k
             do j = 1, i-1
                call fmeq(a(j, i)%mfm, a(i, j)%mfm, qx)
             enddo
          enddo
      endif

      deallocate(fxi)
      end subroutine fm_geneq

      subroutine fm_integrate(f, n, a, b, tol, result, kprt, nw)
      use fmvals_parallel
      implicit none

!  High-precision numerical integration.

!  Integrate f(x,n) from a to b.  n is passed on to function f to indicate which function to use in
!  cases where several different functions may be defined there.


!  warning:  If the function f being integrated or one of its derivatives does not exist at one or
!            both of the endpoints (a,b), the endpoints should be exactly representable in fm's
!            number system.  For non-exact numbers like 1/3, sqrt(2), or pi/2, when fm_integrate
!            raises precision to evaluate the integration formula the endpoints are not accurate
!            enough at the higher precision.

!  Example:  Integrate  sqrt( tan( x ) )  from  0  to  pi/2.
!            First, pi/2 is not exact as an FM number.  At some precisions it may have rounded up,
!            making tan(x) negative and causing an error in sqrt.  Using sqrt( abs( tan( x ) ) )
!            is safer.
!            Second, b = pi/2 has been computed at the user's precision, so when fm_integrate
!            raises precision, the value of b is just zero-padded on the end, which does not give
!            enough information about how f(x) behaves near the singularity at pi/2.
!
!            Make the endpoints exact by changing variables.  Change the interval to [ 0 , 1 ]:
!
!                                        u = ( 2/pi ) * x   =>   du = ( 2/pi ) * dx
!            so
!                                        x = ( pi/2 ) * u   =>   dx = ( pi/2 ) * du
!            new limits
!                                        x = 0  =>  u = 0  and  x = pi/2  =>  u = 1
!
!            New integral:   Integrate  (pi/2) * sqrt( abs( tan( pi*u/2 ) ) )  from  0  to  1.
!
!            Now the function f should declare a local saved type(fm) variable pi, and then use
!            call fm_pi(pi) each time f is called to make sure the value of pi is correct at the
!            higher precision being used by fm_integrate when f is called.

      type (fm) :: a, b, result, tol
      integer :: n, kprt, nw
      type (multi), external :: f
      intent (in) :: n, a, b, tol, kprt, nw
      intent (inout) :: result

      type(fm_settings) :: qx

!  a,b,tol, and result are all type (fm) variables, and function f returns a type (fm) result.

!  result is returned as the value of the integral, with abs((result-true)/true) less than tol
!         (i.e., tol is a relative error tolerance).
!         For example, to get 30 significant digits correct for the integral, set tol = 1.0e-30.

!  FM precision must be set high enough in the calling program (using fm_set) so that 1+tol > 1
!  at that precision.  Using tol = epsilon(to_fm(1)) will usually get a full precision result,
!  but for some functions this might fail.  A better strategy is to set precision higher than
!  the accuracy required for the integral.  For example, to get the integral to 50 significant
!  digits, call fmset(60) and then set tol = to_fm(' 1.0e-50 ') before the call to fm_integrate.

!  kprt can be used to show intermediate results on unit nw.
!  kprt = 0 for no output
!       = 1 prints a summary for each call to fm_integrate
!       = 2 prints a trace of all iterations.

!  nw is the unit number used for kprt output and any error or warning messages.

!  No method for numerical integration is foolproof.  Since it samples only a finite number of
!  function values, any numerical integration algorithm can be made to fail by choosing a
!  sufficiently badly-behaved function.  Such functions often vary by many orders of magnitude
!  over relatively small fractions of the interval (a,b).

!  f should be well-behaved in the interior of the interval (a,b).
!  The routine tries to handle any singularities of f or f' at a and/or b, so cases with interior
!  singularities should be done as separate calls having the singularities as endpoints.
!  The routine will try to handle cases where f or f' has singularities inside (a,b), but then
!  the time will be much slower and the routine might fail.

!  For a function with a removable singularity in the interior of the interval, such as
!  f(x) = 1/ln(x) - 1/(x-1), define f(x,n) to check for x = 1 and return the correct limiting
!  value, 0.5 in this case, when x is 1.

!  Among functions with no singularities, examples of badly behaved functions are those with one
!  or more extremely narrow tall spikes in their graphs. If possible, identify the peaks of any
!  such spikes first, then make separate calls with the peaks as endpoints of the intervals of
!  integration.

!  If the value of the integral is zero or very close to zero, relative error may be undefined, so
!  this routine may fail to converge and then return unknown.  For these cases, try breaking the
!  integral into two pieces and calling twice to get two non-zero results.  These two results can
!  then be added, often giving the original integral with sufficiently small absolute error even
!  though small relative error could not be attained.

!  If the function values are too extreme, it can cause problems.  For example, if an exponential
!  in f underflows and then is multiplied by something bigger than one, then f will return unknown.
!  If the result of the integral is much larger than the underflow threshold (tiny(to_fm(1))), then
!  it is safe to set the underflowed results in f to zero to avoid getting unknown.

!  If the function is nearly divergent fm_integrate may fail.  1/x from 0 to b is divergent.
!  1/x**0.99 converges, but so slowly that fm_integrate may run a long time and then might fail.
!  1/x**0.9999 converges even more slowly and fm_integrate may fail by declaring that the integral
!  seems divergent.

!  When the integrand is highly (or infinitely) oscillatory, fm_integrate may fail.
!  If f has more than about 100 oscillations on the interval (a,b), it may be necessary to break
!  the interval into smaller intervals and call fm_integrate several times.
!  For infinitely many oscillations, like sin(1/x) from 0 to 1, first turn the integral into an
!  infinite series by calling fm_integrate to integrate each separate loop between roots of
!  sin(1/x).  The function is well-behaved for each call, so fm_integrate can get high precision
!  quickly for each.  Next form a sequence of k partial sums for this series.  The series converges
!  slowly, with 50 or 100 terms giving only 3 or 4 significant digits of the sum, so an
!  extrapolation method can be used to get a more accurate value of the sum of this series from
!  its first k terms. For an alternating series like this, the extrapolation method of Cohen,
!  Villegas, and Zagier often works very well.
!  Repeated Aitken extrapolation could be used instead -- it is a more widely known method.
!  Sample program Oscillate.f95 computes this integral.


      call fmintegrate2(f, n, a%mfm, b%mfm, tol%mfm, result%mfm, kprt, nw, qx)

      end subroutine fm_integrate

      recursive subroutine fmintegrate2(f, n, a, b, tol, result, kprt, nw, qx)
      use fmvals_parallel
      implicit none

      type (multi) :: a, b, result, tol
      type (multi), external :: f
      integer :: n, kprt, nw
      type(fm_settings) :: qx
      intent (in) :: n, a, b, tol, kprt, nw
      intent (inout) :: result, qx

!             m  is the maximum level for the integration algorithm.  The number of function
!                evaluations roughly doubles for each successive level until the tolerance is met.
!                Using m = 12 allows up to about 5,000 digits for most integrals, but the upper
!                limit for a given m depends on the function.
!                Raising m further will approximately double the maximum precision for each
!                extra level, but will also double the memory usage for each extra level.

      integer, parameter :: m = 12
      integer, parameter :: nt = 20*2**m
      integer :: absign, i, istep, k, kl, nds, ndsave, nretry
      integer :: r_level, num_f
      logical, external :: fmcomp

      type (multi) :: a1, ab2, b1, c1, c2, ci, ct, d, eps, err1, err2, f1, f2, fmax, h, last_h,  &
                      pi, prior_hs, s, s1, s2, si, st, t, tol1, tol2, x, x1, x2, xf, hf, xmax,   &
                      v, w, mxy(3)

      character(80) :: st1, st2
      logical :: spike_found

!             Iterative tanh-sinh integration is used, increasing the order until convergence
!             is obtained, or m levels have been done.

      call fmi2m(0, result, qx)
      r_level = 0
      num_f = 0

      qx%ncall = qx%ncall + 1
      qx%namest(qx%ncall) = 'integrate'
      r_level = r_level + 1
      nretry = 0
      if (kprt >= 2) then
          write (nw, "(a)") ' '
          write (nw, "(a, i9, a)") ' Input to fm_integrate.    Function n = ', n, '.    a, b ='
          call fmprint(a, qx)
          call fmprint(b, qx)
          call fmform('es20.8', tol, st1, qx)
          write (nw, "(a, a)") ' tol =', trim(st1)
      endif

!             Check for special cases.

      if (fmcomp(a, '==', b, qx)) then
          call fmeq(f(a, n, qx), a1, qx)
          if (r_level <= 1) then
              num_f = 1
          else
              num_f = num_f + 1
          endif
          if (a1%mp(2) == qx%munkno) then
              call fm_f_fail(a, n, nw, qx)
              call fmeq(a1, prior_hs, qx)
              call fm_int_end(prior_hs, result, ndsave, n, a, b, tol, num_f, r_level, kprt, nw, qx)
              return
          else
              call fmi2m(0, prior_hs, qx)
              call fm_int_end(prior_hs, result, ndsave, n, a, b, tol, num_f, r_level, kprt, nw, qx)
              return
          endif
      endif

!             Check to make sure the user has set precision high enough for the value of tol chosen.

      call fmeq(tol, tol1, qx)
      call fmi2m(1, mxy(1), qx)
      call fmulp(mxy(1), mxy(2), qx)
      if (fmcomp(tol, '<', mxy(2), qx)) then
          write (nw, "(a)") ' '
          write (nw, "(a)") ' Error in fm_integrate.  tol is '
          call fmprint(tol, qx)
          write (nw, "(a)") ' This is too small for the current precision level.  Current epsilon ='
          call fmeq(mxy(2), tol1, qx)
          call fmprint(tol1, qx)
          write (nw, "(a)") ' This larger value will be used.  tol ='
          call fmprint(tol1, qx)
          write (nw, "(a)") ' Use fm_set to set a higher precision before the call to'
          write (nw, "(a)") ' fm_integrate if the smaller tol is needed.'
      endif

!             Raise the precision.
!             Check for an integrable singularity at either endpoint, and increase precision
!             if it seems that a retry would be needed at the first precision.

      ndsave = qx%ndig
      call fmsub(b, a, mxy(1), qx)
      call fmst2m(' 1.0E-10 ', mxy(2), qx)
      call fmmpy_r2(mxy(1), mxy(2), qx)
      call fmadd(a, mxy(2), x1, qx)
      call fmeq(f(x1, n, qx), f1, qx)
      call fmst2m(' 1.0E-20 ', mxy(2), qx)
      call fmmpy_r2(mxy(1), mxy(2), qx)
      call fmadd(a, mxy(2), x2, qx)
      call fmeq(f(x2, n, qx), f2, qx)
      call fmdiv(f1, f2, mxy(3), qx)
      call fmlg10(mxy(3), mxy(1), qx)
      call fmdivi(mxy(1), 10, a1, qx)
      call fmsub(b, a, mxy(1), qx)
      call fmst2m(' 1.0E-10 ', mxy(2), qx)
      call fmmpy_r2(mxy(1), mxy(2), qx)
      call fmsub(b, mxy(2), x1, qx)
      call fmeq(f(x1, n, qx), f1, qx)
      call fmst2m(' 1.0E-20 ', mxy(2), qx)
      call fmmpy_r2(mxy(1), mxy(2), qx)
      call fmsub(b, mxy(2), x2, qx)
      call fmeq(f(x2, n, qx), f2, qx)
      call fmdiv(f1, f2, mxy(3), qx)
      call fmlg10(mxy(3), mxy(1), qx)
      call fmdivi(mxy(1), 10, b1, qx)
      if (r_level <= 1) then
          num_f = 4
      else
          num_f = num_f + 4
      endif
      call fmst2m('-0.999', mxy(1), qx)
      if (fmcomp(a1, '<', mxy(1), qx) .or. fmcomp(b1, '<', mxy(1), qx)) then
          call fmunknown(prior_hs, qx)
          write (nw, "(a)") ' '
          write (nw, "(a, i9, a)") ' fm_integrate failed -- f(x, n) for n = ', n,  &
                                ' seems to have a non-integrable singularity'
          write (nw, "(a)")      '                        at an endpoint.  a, b ='
          call fmprint(a, qx)
          call fmprint(b, qx)
          write (nw, "(a)") ' Check the limits of integration, function number (n), and' // &
                           ' function definition.'
          write (nw, "(a)") ' '
          call fm_int_end(prior_hs, result, ndsave, n, a, b, tol, num_f, r_level, kprt, nw, qx)
          return
      endif
      qx%ndig = qx%ndig+int(30/qx%alogmt)
      call fmequ_r1(a1, ndsave, qx%ndig, qx)
      call fmequ_r1(b1, ndsave, qx%ndig, qx)
      call fmst2m('-0.2', mxy(1), qx)
      if (fmcomp(a1, '<', mxy(1), qx) .or. fmcomp(b1, '<', mxy(1), qx)) then
          qx%ndig = 2*qx%ndig
      endif

!             Start here when doing a retry.

      kl = 1
      do while (kl == 1)
         kl = 0
         nretry = nretry + 1
         call fmequ(a, a1, ndsave, qx%ndig, qx)
         call fmequ(b, b1, ndsave, qx%ndig, qx)
         absign = 1
         if (fmcomp(a1, '>', b1, qx)) then
             call fmequ(b, a1, ndsave, qx%ndig, qx)
             call fmequ(a, b1, ndsave, qx%ndig, qx)
             absign = -1
         else if (fmcomp(a1, '==', b1, qx)) then
             call fmi2m(0, prior_hs, qx)
             call fm_int_end(prior_hs, result, ndsave, n, a, b, tol, num_f, r_level, kprt, nw, qx)
             return
         endif
         call fmequ(tol1, tol2, ndsave, qx%ndig, qx)

         if (kprt >= 2) then
             write (nw, "(a)") ' '
             write (nw, "(a, i9, a, i5)") ' Begin fm_integrate.  ndig = ', qx%ndig,  &
                                         '   Recursion level = ', r_level
         endif

         call fmi2m(0, s, qx)
         call fmi2m(0, prior_hs, qx)
         call fmi2m(1, err2, qx)
         call fmulp(err2, eps, qx)
         call fmsub(b1, a1, mxy(1), qx)
         call fmdivi(mxy(1), 100, d, qx)
         d%mp(1) = 1
         call fmi2m(0, fmax, qx)
         call fmeq(a1, xmax, qx)
         call fmi2m(1, h, qx)
         call fmdivi(h, 2**m, last_h, qx)
         call fmpi(pi, qx)

         call fmsub(b1, a1, mxy(1), qx)
         call fmdivi(mxy(1), 2, hf, qx)
         call fmadd(a1, hf, ab2, qx)
         do k = 1, m
            call fmdivi_r1(h, 2, qx)
            istep = 2**(m-k)
            if (k > 1) then
                call fmmpyi(last_h, istep, t, qx)
                call fmchsh(t, c1, s1, qx)
                call fmmpy(s1, c1, mxy(1), qx)
                call fmmpyi(mxy(1), 2, t, qx)
                call fmsqr(c1, mxy(1), qx)
                call fmsqr(s1, mxy(2), qx)
                call fmadd(mxy(1), mxy(2), c2, qx)
                call fmeq(t, s2, qx)
            endif
            do i = 0, nt, istep
               if (mod(i, 2*istep) /= 0 .or. k == 1) then

!                The + or -x values are the abscissas for interval (-1,1).
!                xf translates these to the interval (a,b).

                   if (i == 0) then
                       call fmi2m(0, x, qx)
                       call fmdivi(pi, 2, w, qx)
                       call fmmpy(hf, x, mxy(1), qx)
                       call fmadd(mxy(1), ab2, xf, qx)
                       call fmeq(f(xf, n, qx), t, qx)
                       num_f = num_f + 1
                       if (t%mp(2) == qx%munkno) then
                           call fm_f_fail(xf, n, nw, qx)
                           call fmeq(t, prior_hs, qx)
                           call fm_int_end(prior_hs, result, ndsave, n, a, b, tol, num_f,  &
                                           r_level, kprt, nw, qx)
                           return
                       endif
                       call fmabs(t, mxy(1), qx)
                       call fmadd(a1, d, mxy(2), qx)
                       call fmsub(b1, d, mxy(3), qx)
                       if (fmcomp(mxy(1), '>', fmax, qx) .and. fmcomp(xf, '>', mxy(2), qx) .and.  &
                        fmcomp(xf, '<', mxy(3), qx)) then
                           call fmeq(mxy(1), fmax, qx)
                           call fmeq(xf, xmax, qx)
                       endif
                       call fmmpy(w, hf, mxy(1), qx)
                       call fmmpy(mxy(1), t, mxy(2), qx)
                       call fmadd_r1(s, mxy(2), qx)
                   else
                       if (k == 1) then
                           call fmmpyi(last_h, i, t, qx)
                           call fmchsh(t, ci, si, qx)
                       else

!                       Use the hyperbolic addition formulas to get the next cosh and sinh
!                       quickly when evaluated at i*last_h.

                           if (i == istep) then
                               call fmeq(c1, ci, qx)
                               call fmeq(s1, si, qx)
                           else
                               call fmmpy(si, c2, mxy(1), qx)
                               call fmmpy(ci, s2, mxy(2), qx)
                               call fmadd(mxy(1), mxy(2), t, qx)
                               call fmmpy(ci, c2, mxy(1), qx)
                               call fmmpy(si, s2, mxy(2), qx)
                               call fmadd(mxy(1), mxy(2), ci, qx)
                               call fmeq(t, si, qx)
                               call fmeq(ci, c1, qx)
                               call fmeq(si, s1, qx)
                           endif
                       endif
                       call fmmpy(pi, si, mxy(1), qx)
                       call fmdivi(mxy(1), 2, t, qx)
                       call fmchsh(t, ct, st, qx)
                       call fmdivi(pi, 2, mxy(1), qx)
                       call fmmpy_r1(mxy(1), ci, qx)
                       call fmsqr(ct, mxy(2), qx)
                       call fmdiv(mxy(1), mxy(2), w, qx)
                       if (fmcomp(w, '<', eps, qx)) exit
                       call fmdiv(st, ct, x, qx)
                       call fmmpy(hf, x, mxy(1), qx)
                       call fmsub(ab2, mxy(1), xf, qx)
                       if (fmcomp(xf, '>', a1, qx)) then
                           call fmeq(f(xf, n, qx), t, qx)
                           num_f = num_f + 1
                           if (t%mp(2) == qx%munkno) then
                               call fm_f_fail(xf, n, nw, qx)
                               call fmeq(t, prior_hs, qx)
                               call fm_int_end(prior_hs, result, ndsave, n, a, b, tol, num_f,  &
                                               r_level, kprt, nw, qx)
                               return
                           endif
                           call fmabs(t, mxy(1), qx)
                           call fmadd(a1, d, mxy(2), qx)
                           call fmsub(b1, d, mxy(3), qx)
                           if (fmcomp(mxy(1), '>', fmax, qx) .and. fmcomp(xf, '>', mxy(2), qx) .and.  &
                               fmcomp(xf, '<', mxy(3), qx)) then
                               call fmabs(t, fmax, qx)
                               call fmeq(xf, fmax, qx)
                           endif
                           call fmmpy(w, hf, mxy(1), qx)
                           call fmmpy(mxy(1), t, mxy(2), qx)
                           call fmadd_r1(s, mxy(2), qx)
                       endif
                       call fmmpy(hf, x, mxy(1), qx)
                       call fmadd(ab2, mxy(1), xf, qx)
                       if (fmcomp(xf, '<', b1, qx)) then
                           call fmeq(f(xf, n, qx), t, qx)
                           num_f = num_f + 1
                           if (t%mp(2) == qx%munkno) then
                               call fm_f_fail(xf, n, nw, qx)
                               call fmeq(t, prior_hs, qx)
                               call fm_int_end(prior_hs, result, ndsave, n, a, b, tol, num_f,  &
                                               r_level, kprt, nw, qx)
                               return
                           endif
                           call fmabs(t, mxy(1), qx)
                           call fmadd(a1, d, mxy(2), qx)
                           call fmsub(b1, d, mxy(3), qx)
                           if (fmcomp(mxy(1), '>', fmax, qx) .and. fmcomp(xf, '>', mxy(2), qx) .and.  &
                               fmcomp(xf, '<', mxy(3), qx)) then
                               call fmabs(t, fmax, qx)
                               call fmeq(xf, xmax, qx)
                           endif
                           call fmmpy(w, hf, mxy(1), qx)
                           call fmmpy(mxy(1), t, mxy(2), qx)
                           call fmadd_r1(s, mxy(2), qx)
                       endif
                   endif
               endif
            enddo
            if (kprt >= 2) then
                write (nw, "(a)") ' '
                write (nw, "(a, i9, a, i9, a)") ' k = ', k, '   ', num_f,  &
                                           ' function calls so far.   Integral approximation ='
                call fmmpy(h, s, v, qx)
                call fmprint(v, qx)
            endif
            if (k > 1) then
                call fmeq(err2, err1, qx)
                if (s%mp(3) /= 0) then
                    call fmmpy(h, s, mxy(1), qx)
                    call fmsub(prior_hs, mxy(1), mxy(2), qx)
                    call fmdiv(mxy(2), mxy(1), mxy(3), qx)
                    call fmabs(mxy(3), err2, qx)
                else
                    call fmmpy(h, s, mxy(1), qx)
                    call fmsub(prior_hs, mxy(1), mxy(2), qx)
                    call fmabs(mxy(2), err2, qx)
                endif
                if (kprt >= 2) then
                    call fmform('es15.3', err2, st1, qx)
                    write (nw, "(a, a)") '      relative error of the last two ' //  &
                                         'approximations = ', trim(st1)
                endif

!             Check for convergence.

                call fmdivi(tol2, 10, mxy(1), qx)
                call fmi2m(0, mxy(2), qx)
                if (k > 3 .and. fmcomp(err2, '>', mxy(2), qx) .and. fmcomp(err2, '<', mxy(1), qx)) exit
                if (k > 5 .and. fmcomp(err2, '==', mxy(2), qx)) exit

!             If the errors do not decrease fast enough, raise precision and try again.

                if (k > 3*nretry .and. fmcomp(err1, '>', mxy(2), qx) .and.  &
                    fmcomp(err2, '>', mxy(2), qx)) then
                    call fmln(err1, mxy(1), qx)
                    call fmln(err2, mxy(2), qx)
                    call fmdiv(mxy(2), mxy(1), mxy(3), qx)
                    call fmst2m('1.2', mxy(1), qx)
                    call fmst2m('1.0E-6', mxy(2), qx)
                    if (fmcomp(mxy(3), '<', mxy(1), qx) .and. fmcomp(err1, '<', mxy(2), qx)) then
                        qx%ndig = 2*qx%ndig
                        if (kprt >= 2) then
                            write (nw, "(a, i9, a, i9)")                    &
                                       ' fm_integrate Retry.  So far, ' //  &
                                       ' num_f = ', num_f, '   New ndig = ', qx%ndig
                        endif
                        if (nretry <= 3) then
                            kl = 1
                            exit
                        endif
                        qx%ndig = qx%ndig/2
                    endif
                endif
            endif
            call fmmpy(h, s, prior_hs, qx)

!             No convergence in m iterations.
!             Before giving up, look for an interior singularity or tall spike.  If one is found,
!             split (a,b) into two intervals with the interior singularity as an endpoint, and try
!             again as two integrals.

            call fmst2m('1.0e-7', mxy(1), qx)
            call fmabs(tol2, mxy(2), qx)
            call fmst2m('1.0e-16', mxy(3), qx)
            if (k == m .or.  &
                (k >= 9 .and. fmcomp(err2, '>', mxy(1), qx) .and. fmcomp(mxy(2), '<', mxy(3), qx))) then
                if (kprt >= 2) then
                    write (nw, "(a)") ' '
                    write (nw, "(a, i6, a)") ' No convergence in ', m,  &
                                 ' iterations.  Look for an interior singularity.'
                    call fmform('es25.6', xmax, st1, qx)
                    call fmform('es25.6', fmax, st2, qx)
                    write (nw, "(i9, a, a, a)") num_f, ' function calls so far.   xmax, fmax =',  &
                                                trim(st1), trim(st2)
                endif
                call fm_spike(f, n, a1, b1, xmax, fmax, num_f, spike_found, kprt, nw, qx)
                call fmequ_r1(a1, qx%ndig, ndsave, qx)
                call fmequ_r1(b1, qx%ndig, ndsave, qx)
                call fmequ_r1(xmax, qx%ndig, ndsave, qx)
                nds = qx%ndig
                qx%ndig = ndsave
                if (spike_found) then
                    call fmsub(a, xmax, mxy(1), qx)
                    mxy(1)%mp(1) = 1
                    call fmsub(b, xmax, mxy(2), qx)
                    mxy(2)%mp(1) = 1
                    call fmmin(mxy(1), mxy(2), mxy(3), qx)
                    call fmmpyi(d, 101, mxy(1), qx)
                    call fmdivi(mxy(1), 100, mxy(2), qx)
                    if (fmcomp(mxy(3), '<', mxy(2), qx)) then
                        qx%ndig = 2*nds
                        if (nretry <= 5) then
                            kl = 1
                            exit
                        endif
                        qx%ndig = ndsave
                    endif
                    if (kprt >= 2) then
                        write (nw, "(a)") ' '
                        write (nw, "(a)") ' Split the integral.  First half:  a, b = '
                        call fmprint(a1, qx)
                        call fmprint(xmax, qx)
                    endif
                    call fmintegrate2(f, n, a1, xmax, tol, c1, kprt, nw, qx)
                    if (c1%mp(2) == qx%munkno) then
                        call fmeq(c1, prior_hs, qx)
                        call fm_int_end(prior_hs, result, ndsave, n, a, b, tol, num_f,  &
                                        r_level, kprt, nw, qx)
                        return
                    endif
                    if (kprt >= 2) then
                        write (nw, "(a)") ' '
                        write (nw, "(a)") ' Split the integral.  Second half:  a, b = '
                        call fmprint(xmax, qx)
                        call fmprint(b1, qx)
                    endif
                    call fmintegrate2(f, n, xmax, b1, tol, c2, kprt, nw, qx)
                    call fmadd(c1, c2, prior_hs, qx)
                    call fm_int_end(prior_hs, result, ndsave, n, a, b, tol, num_f,  &
                                    r_level, kprt, nw, qx)
                    return
                endif
                call fm_int_fail(n, a, b, tol, m, err2, prior_hs, nw, qx)
                call fmunknown(prior_hs, qx)
                call fm_int_end(prior_hs, result, ndsave, n, a, b, tol, num_f,  &
                                r_level, kprt, nw, qx)
                return
            endif
         enddo
      enddo

      call fmmpy(h, s, mxy(1), qx)
      call fmmpyi(mxy(1), absign, prior_hs, qx)

!             Round the result and return.

      call fm_int_end(prior_hs, result, ndsave, n, a, b, tol, num_f, r_level, kprt, nw, qx)

      return
      end subroutine fmintegrate2

      subroutine fm_int_end(prior_hs, result, ndsave, n, a, b, tol, num_f, r_level, kprt, nw, qx)
      use fmvals_parallel
      implicit none
      integer :: ndsave, r_level, kprt, nw, n, num_f
      type (multi) :: prior_hs, result, a, b, tol
      type(fm_settings) :: qx
      intent (in) :: prior_hs, ndsave, n, a, b, tol, num_f, kprt, nw
      intent (inout) :: result, r_level, qx

      character(80) :: st1

      call fmequ(prior_hs, result, qx%ndig, ndsave, qx)

      qx%ndig = ndsave
      qx%ncall = qx%ncall - 1

      if (kprt >= 2 .or. ( r_level <= 1 .and. kprt == 1 ) ) then
          write (nw, "(a)") ' '
          write (nw, "(a, i9, a)") ' Return from fm_integrate.    Function n = ', n, '.    a, b ='
          call fmprint(a, qx)
          call fmprint(b, qx)
          call fmform('es20.8', tol, st1, qx)
          write (nw, "(a, a)") ' tol =', trim(st1)
          write (nw, "(1x, i9, a)") num_f, ' function calls were made.'
          call fmprint(result, qx)
      endif
      r_level = r_level - 1

      return
      end subroutine fm_int_end

      subroutine fm_int_fail(n, a, b, tol, m, err, val, nw, qx)
      use fmvals_parallel
      implicit none
      integer :: n, m, nw
      type (multi) :: a, b, tol, err, val
      type(fm_settings) :: qx
      intent (in) :: n, a, b, tol, m, err, val, nw
      intent (inout) :: qx

      write (nw,*) ' '
      write (nw,*) ' fm_integrate failed -- no convergence in ', m, ' iterations.'
      write (nw,*) ' unknown has been returned in result.'
      write (nw,*) ' Possible causes:  (1) highly oscillatory integrand'
      write (nw,*) '                   (2) non-convergent integral'
      write (nw,*) '                   (3) integrable singularity in the interior of interval (a, b)'
      write (nw,*) '                   (4) narrow spike in the interior of interval (a, b)'
      write (nw,*) '                   (5) integral too close to zero'
      write (nw,*) ' a possible remedy for the last 3 is to split the integral into two pieces, '
      write (nw,*) ' making two calls to fm_integrate and then adding the two results.'
      write (nw,*) ' Put singularities or spikes at the endpoints of the intervals of integration.'
      write (nw,*) ' '
      write (nw,*) ' Function n = ', n, '.    a, b ='
      call fmprint(a, qx)
      call fmprint(b, qx)
      write (nw,*) ' tol ='
      call fmprint(tol, qx)
      write (nw,*) ' The last integral approximation ='
      call fmprint(val, qx)
      write (nw,*) ' The estimated relative error in the last integral approximation ='
      call fmprint(err, qx)
      write (nw,*) ' '

      end subroutine fm_int_fail

      subroutine fm_f_fail(x, n, nw, qx)
      use fmvals_parallel
      implicit none
      integer :: n, nw
      type (multi) :: x
      type(fm_settings) :: qx
      intent (in) :: x, n, nw
      intent (inout) :: qx

      write (nw,*) ' '
      write (nw,*) ' fm_integrate failed -- f(x, n) gave unknown for n = ', n, '   and x ='
      call fmprint(x, qx)
      write (nw,*) ' Check the limits of integration, function number (n), and' // &
                   ' function definition.'
      write (nw,*) ' Be careful of rounding at an irrational endpoint producing an' // &
                   ' illegal function argument.'
      write (nw,*) ' Example:  Integrate  log( cos( t ) ) from 0 to pi/2'
      write (nw,*) ' At some precisions the computed value of pi/2 rounds up, giving' // &
                   ' a small negative cos(t), '
      write (nw,*) ' which then causes the log function to return unknown.'
      write (nw,*) ' Possible fixes:'
      write (nw,*) '     Change variables to get an integral from 0 to 1'
      write (nw,*) '     Change the function to log( abs( cos( t ) ) )'
      write (nw,*) '     Compute pi/2 with rounding toward -infinity'
      write (nw,*) ' '

      end subroutine fm_f_fail

      subroutine fm_spike(f, n, a, b, xmax, fmax, num_f, spike_found, kprt, nw, qx)
      use fmvals_parallel
      implicit none

!  look for an interior singularity or tall spike in f(x,n).
!  After getting no convergence in m iterations in fm_integrate, fmax = abs(f(xmax,n)) was
!  the largest magnitude found for f on the interval (a+d,b-d), where d = abs(b-a)/100.

      type (multi) :: a, b, xmax, fmax
      type (multi), external :: f
      integer :: n, num_f, kprt, nw
      logical :: spike_found
      type(fm_settings) :: qx
      intent (in) :: n, a, b, kprt, nw
      intent (inout) :: xmax, fmax, num_f, spike_found, qx

      type (multi) :: ab, average, d, dx, fpmax, eps, f1, f2, h, t, x1, xpmax, mxy(3)
      integer :: j
      logical, external :: fmcomp

      spike_found = .false.
      if (kprt >= 2) then
          write (nw, "(a)") ' Enter fm_spike'
      endif

      call fmsub(b, a, mxy(1), qx)
      mxy(1)%mp(1) = 1
      call fmdivi(mxy(1), 100, dx, qx)
      call fmsub(xmax, a, mxy(1), qx)
      call fmsub(b, xmax, mxy(2), qx)
      call fmmin(mxy(1), mxy(2), mxy(3), qx)
      call fmdivi(mxy(3), 2, h, qx)

      call fmi2m(0, average, qx)
      do j = 1, 99
         call fmsub(b, a, mxy(1), qx)
         call fmmpyi_r1(mxy(1), j, qx)
         call fmdivi_r1(mxy(1), 100, qx)
         call fmadd(a, mxy(1), x1, qx)
         call fmeq(f(x1, n, qx), f1, qx)
         num_f = num_f + 1
         if (f1%mp(2) == qx%munkno) then
             call fmeq(x1, xmax, qx)
             call fmeq(f1, fmax, qx)
             fmax%mp(1) = 1
             spike_found = .true.
             return
         else
             call fmabs(f1, mxy(1), qx)
             call fmadd_r1(average, mxy(1), qx)
         endif
      enddo
      call fmdivi_r1(average, 99, qx)

!             Search for a singularity in f.

      do
         call fmadd(xmax, h, x1, qx)
         call fmadd(a, dx, mxy(1), qx)
         call fmsub(b, dx, mxy(2), qx)
         if (fmcomp(x1, '>', mxy(1), qx) .and. fmcomp(x1, '<', mxy(2), qx)) then
             call fmeq(f(x1, n, qx), f1, qx)
             num_f = num_f + 1
             if (f1%mp(2) == qx%munkno) then
                 call fmeq(x1, xmax, qx)
                 call fmabs(f1, fmax, qx)
                 spike_found = .true.
                 return
             endif
             call fmabs(f1, mxy(1), qx)
             if (fmcomp(mxy(1), '>', fmax, qx)) then
                 call fmeq(x1, xmax, qx)
                 call fmabs(f1, fmax, qx)
                 call fmmpyi(h, -14, mxy(1), qx)
                 call fmdivi(mxy(1), 10, h, qx)
             endif
         endif
         call fmmpyi(h, -10, mxy(1), qx)
         call fmdivi(mxy(1), 14, h, qx)
         call fmabs(a, mxy(1), qx)
         call fmabs(b, mxy(2), qx)
         call fmmax(mxy(1), mxy(2), ab, qx)
         call fmulp(ab, eps, qx)
         call fmabs(h, mxy(1), qx)
         call fmabs(eps, mxy(2), qx)
         if (fmcomp(mxy(1), '<', mxy(2), qx)) then
             call fmmpyi(average, 50, mxy(1), qx)
             if (fmcomp(fmax, '>', mxy(1), qx)) then
                 spike_found = .true.
                 return
             else
                 exit
             endif
         endif
      enddo

!             Search for a singularity in f'.

      call fmi2m(-1, fpmax, qx)
      call fmi2m(0, average, qx)
      call fmabs(a, mxy(1), qx)
      call fmabs(b, mxy(2), qx)
      call fmmax(mxy(1), mxy(2), ab, qx)
      call fmulp(ab, eps, qx)
      call fmsqrt_r1(eps, qx)
      do j = 1, 99
         call fmsub(b, a, mxy(1), qx)
         call fmmpyi_r1(mxy(1), j, qx)
         call fmdivi_r1(mxy(1), 100, qx)
         call fmadd(a, mxy(1), x1, qx)
         call fmsub(x1, eps, t, qx)
         if (fmcomp(t, '<=', a, qx)) cycle
         call fmeq(f(t, n, qx), f1, qx)
         call fmadd(x1, eps, t, qx)
         if (fmcomp(t, '>=', b, qx)) cycle
         call fmeq(f(t, n, qx), f2, qx)
         num_f = num_f + 2
         if (f1%mp(2) == qx%munkno .or. f2%mp(2) == qx%munkno) then
             if (f1%mp(2) == qx%munkno) then
                 call fmsub(x1, eps, xmax, qx)
                 call fmabs(f1, fmax, qx)
             else
                 call fmadd(x1, eps, xmax, qx)
                 call fmabs(f2, fmax, qx)
             endif
             spike_found = .true.
             return
         else
             call fmsub(f2, f1, mxy(1), qx)
             call fmdivi_r1(mxy(1), 2, qx)
             call fmdiv_r1(mxy(1), eps, qx)
             call fmabs(mxy(1), d, qx)
             call fmadd_r1(average, d, qx)
             if (fmcomp(d, '>', fpmax, qx)) then
                 call fmeq(x1, xpmax, qx)
                 call fmeq(d, fpmax, qx)
             endif
         endif
      enddo
      call fmdivi_r1(average, 99, qx)

      call fmsub(xpmax, a, mxy(1), qx)
      call fmsub(b, xpmax, mxy(2), qx)
      call fmmin(mxy(1), mxy(2), mxy(3), qx)
      call fmdivi(mxy(3), 2, h, qx)
      do
         call fmadd(xpmax, h, x1, qx)
         call fmadd(a, dx, mxy(1), qx)
         call fmsub(b, dx, mxy(2), qx)
         if (fmcomp(x1, '>', mxy(1), qx) .and. fmcomp(x1, '<', mxy(2), qx)) then
             call fmsub(x1, eps, t, qx)
             call fmeq(f(t, n, qx), f1, qx)
             num_f = num_f + 1
             if (f1%mp(2) == qx%munkno) then
                 call fmeq(x1, xpmax, qx)
                 call fmabs(f1, fpmax, qx)
                 spike_found = .true.
                 return
             endif
             call fmadd(x1, eps, t, qx)
             call fmeq(f(t, n, qx), f2, qx)
             num_f = num_f + 1
             if (f2%mp(2) == qx%munkno) then
                 call fmadd(x1, eps, xpmax, qx)
                 call fmabs(f2, fpmax, qx)
                 spike_found = .true.
                 return
             endif
             call fmsub(f2, f1, mxy(1), qx)
             call fmdivi_r1(mxy(1), 2, qx)
             call fmdiv_r1(mxy(1), eps, qx)
             call fmabs(mxy(1), d, qx)
             if (fmcomp(d, '>', fpmax, qx)) then
                 call fmeq(x1, xpmax, qx)
                 call fmeq(d, fpmax, qx)
                 call fmmpyi(h, -14, mxy(1), qx)
                 call fmdivi(mxy(1), 10, h, qx)
             endif
         endif
         call fmmpyi(h, -10, mxy(1), qx)
         call fmdivi(mxy(1), 14, h, qx)
         call fmabs(a, mxy(1), qx)
         call fmabs(b, mxy(2), qx)
         call fmmax(mxy(1), mxy(2), ab, qx)
         call fmulp(ab, t, qx)
         call fmabs(h, mxy(1), qx)
         call fmabs(t, mxy(2), qx)
         if (fmcomp(mxy(1), '<', mxy(2), qx)) then
             call fmmpyi(average, 50, mxy(1), qx)
             if (fmcomp(fpmax, '>', mxy(1), qx)) then
                 spike_found = .true.
                 call fmeq(xpmax, xmax, qx)
                 call fmeq(fpmax, fmax, qx)
                 return
             else
                 exit
             endif
         endif
      enddo

      end subroutine fm_spike

      subroutine fm_inverse(a, n, b, det)
      use fmvals_parallel
      implicit none

!  Return b as the inverse of the n x n matrix a, and det as the determinant of a.

!  a and b are type (fm) (real) multiprecision arrays.

      integer :: n
      type (fm) :: a(n, n), b(n, n), det
      intent (in) :: n, a
      intent (inout) :: b, det

      type (multi) :: d1, tol, mxy(3)
      type (multi), allocatable :: a1(:,:), a2(:,:), b1(:), r1(:), x1(:)
      integer, allocatable :: kswap(:)
      integer :: i, j, k, kl, kwarn_save, ndsave
      logical, external :: fmcomp
      type(fm_settings) :: qx

      call fmi2m(1, mxy(1), qx)
      call fmulp(mxy(1), mxy(2), qx)
      mxy(2)%mp(2) = mxy(2)%mp(2) - 1
      call fmst2m('1.0E+10', mxy(3), qx)
      call fmdiv(mxy(2), mxy(3), tol, qx)

      allocate(a1(n, n), a2(n, n), b1(n), r1(n), x1(n), kswap(n), stat=j)
      if (j /= 0) then
          write (*, "(/' Error in fm_inverse.  Unable to allocate arrays with n = ', i8/)") n
          stop
      endif

!             Raise precision.

      ndsave = qx%ndig
      qx%ndig = 2*qx%ndig
      kwarn_save = qx%kwarn
      qx%kwarn = 0

!             Copy a to a1 with higher precision.

      kl = 1
      do while (kl == 1)
         kl = 0
         call fmequ_r1(tol, ndsave, qx%ndig, qx)
         do i = 1, n
            do j = 1, n
               call fmequ(a(i, j)%mfm, a1(i, j), ndsave, qx%ndig, qx)
               call fmeq(a1(i, j), a2(i, j), qx)
            enddo
         enddo

!             Factor a into l*u form.

         call fmfactor_lu2(a1, n, d1, kswap, qx)
         if (d1%mp(3) == 0 .or. d1%mp(2) == qx%munkno) then
             if (qx%kwarn > 0) then
                 write (qx%kw, "(/' Error in fm_inverse.  The matrix is singular.'/)")
             endif
             if (qx%kwarn >= 2) stop
             do i = 1, n
                do j = 1, n
                   call fmunknown(b(i, j)%mfm, qx)
                enddo
             enddo
             exit
         endif

!             Solve for the inverse matrix one column at a time.

         do k = 1, n
            do j = 1, n
               call fmi2m(0, b1(j), qx)
            enddo
            call fmi2m(1, b1(k), qx)
            call fmsolve_lu2(a1, n, b1, x1, kswap, qx)

!             Do an iterative refinement.

            call fmmatmul21(n, a2, x1, r1, qx)
            do i = 1, n
               call fmsub_r1(r1(i), b1(i), qx)
            enddo

            call fmsolve_lu2(a1, n, r1, b1, kswap, qx)
            do i = 1, n
               call fmsub_r1(x1(i), b1(i), qx)
            enddo

!             Check for accuracy at the user's precision.

            call fmnorm2(b1, n, mxy(1), qx)
            if (fmcomp(mxy(1), '>', tol, qx)) then
                qx%ndig = 2*qx%ndig
                kl = 1
                exit
            endif

!             Round the results and store column k in the b matrix.

            do i = 1, n
               call fmequ(x1(i), b(i, k)%mfm, qx%ndig, ndsave, qx)
            enddo
         enddo
      enddo

      call fmequ(d1, det%mfm, qx%ndig, ndsave, qx)
      deallocate(a1, a2, b1, r1, x1, kswap)

      qx%ndig = ndsave
      qx%kwarn = kwarn_save
      end subroutine fm_inverse

      subroutine fm_lin_solve(a, x, b, n, det)
      use fmvals_parallel
      implicit none

!  Gauss elimination to solve the linear system  a x = b, where:

!  a   is the matrix of the system, containing the  n x n coefficient matrix.

!  b   is the  n x 1  right-hand-side vector.

!  x   is the returned  n x 1  solution vector.

!  det is returned as the determinant of a.
!      Nonzero det means a solution was found.
!      det = 0 is returned if the system is singular.

!  a,x,b,det are all type (fm) multiprecision variables.

      integer :: n
      type (fm) :: a(n, n), b(n), x(n), det
      intent (in) :: a, b, n
      intent (inout) :: x, det

      type (multi) :: d1, tol, mxy(3)
      type (multi), allocatable :: a1(:,:), a2(:,:), b1(:), r1(:), x1(:)
      integer, allocatable :: kswap(:)
      integer :: i, j, kl, ndsave
      type(fm_settings) :: qx
      logical, external :: fmcomp

      allocate(a1(n, n), a2(n, n), b1(n), r1(n), x1(n), kswap(n), stat=j)
      if (j /= 0) then
          write (*, "(/' Error in fm_lin_solve.  Unable to allocate arrays with n = ', i8/)") n
          stop
      endif

      call fmi2m(1, mxy(1), qx)
      call fmulp(mxy(1), mxy(2), qx)
      mxy(2)%mp(2) = mxy(2)%mp(2) - 1
      call fmst2m('1.0E+10', mxy(3), qx)
      call fmdiv(mxy(2), mxy(3), tol, qx)

      ndsave = qx%ndig
      qx%ndig = 2*qx%ndig

!             Copy a and b to a1 and b1 with higher precision.

      kl = 1
      do while (kl == 1)
         kl =0
         call fmequ_r1(tol, ndsave, qx%ndig, qx)
         do i = 1, n
            do j = 1, n
               call fmequ(a(i, j)%mfm, a1(i, j), ndsave, qx%ndig, qx)
               call fmeq(a1(i, j), a2(i, j), qx)
            enddo
            call fmequ(b(i)%mfm, b1(i), ndsave, qx%ndig, qx)
         enddo

!             Solve the system.

         call fmfactor_lu2(a1, n, d1, kswap, qx)
         if (d1%mp(3) == 0 .or. d1%mp(2) == qx%munkno) then
             if (qx%kwarn > 0) then
                 write (qx%kw, "(/' Error in fm_lin_solve.  The matrix is singular.'/)")
             endif
             if (qx%kwarn >= 2) stop
             do j = 1, n
                call fmunknown(x1(j), qx)
             enddo
             exit
         endif
         call fmsolve_lu2(a1, n, b1, x1, kswap, qx)

!             Do an iterative refinement.

         call fmmatmul21(n, a2, x1, r1, qx)
         do i = 1, n
            call fmsub_r1(r1(i), b1(i), qx)
         enddo

         call fmsolve_lu2(a1, n, r1, b1, kswap, qx)
         do i = 1, n
            call fmsub_r1(x1(i), b1(i), qx)
         enddo

!             Check for accuracy at the user's precision.

         call fmnorm2(b1, n, mxy(1), qx)
         if (fmcomp(mxy(1), '>', tol, qx)) then
             qx%ndig = 2*qx%ndig
             kl = 1
         endif
      enddo

!             Round and return x and det.

      do i = 1, n
         call fmequ(x1(i), x(i)%mfm, qx%ndig, ndsave, qx)
      enddo
      call fmequ(d1, det%mfm, qx%ndig, ndsave, qx)
      qx%ndig = ndsave

      deallocate(a1, a2, b1, r1, x1, kswap)

      end subroutine fm_lin_solve

      subroutine fm_factor_lu(a, n, det, kswap)
      use fmvals_parallel
      implicit none

!  Gauss elimination to factor the n x n matrix a (lu decomposition).

!  The time is proportional to  n**3.

!  Once this factorization has been done, a linear system  a x = b
!  with the same coefficient matrix a and n x 1 vector b can be solved
!  for x using routine fm_solve_lu in time proportional to  n**2.

!  det is returned as the determinant of a.
!      Nonzero det means there is a unique solution.
!      det = 0 is returned if the system is singular.

!  kswap is a list of row interchanges made by the partial pivoting strategy during the
!        elimination phase.

!  After returning, the values in matrix a have been replaced by the multipliers
!  used during elimination.  This is equivalent to factoring the a matrix into
!  a lower triangular matrix l times an upper triangular matrix u.


      integer :: n, kswap(n)
      type (fm) :: a(n, n), det
      intent (in) :: n
      intent (inout) :: a, det, kswap

      type (multi), allocatable :: a1(:,:)
      integer :: i, j
      type(fm_settings) :: qx

      allocate(a1(n, n), stat=j)
      if (j /= 0) then
          write (*, "(/' Error in fm_factor_lu.  Unable to allocate array with n = ', i8/)") n
          stop
      endif

      do i = 1, n
         do j = 1, n
            call fmeq(a(i, j)%mfm, a1(i, j), qx)
         enddo
      enddo

      call fmfactor_lu2(a1, n, det%mfm, kswap, qx)

      do i = 1, n
         do j = 1, n
            call fmeq(a1(i, j), a(i, j)%mfm, qx)
         enddo
      enddo

      return
      end subroutine fm_factor_lu

      subroutine fmfactor_lu2(a, n, det, kswap, qx)
      use fmvals_parallel
      implicit none

      integer :: n, kswap(n)
      type (multi) :: a(n, n), det
      type(fm_settings) :: qx
      intent (in) :: n
      intent (inout) :: a, det, kswap, qx

      integer :: jcol, jdiag, jmax, jrow
      type (multi) :: amax, amult, temp
      logical, external :: fmcomp

      call fmi2m(1, det, qx)
      kswap(1:n) = 1
      if (n <= 0) then
          call fmi2m(0, det, qx)
          return
      endif
      if (n == 1) then
          kswap(1) = 1
          call fmeq(a(1, 1), det, qx)
          return
      endif

!             Do the elimination phase.
!             jdiag is the current diagonal element below which the elimination proceeds.

      do jdiag = 1, n-1

!             Pivot to put the element with the largest absolute value on the diagonal.

         call fmabs(a(jdiag, jdiag), amax, qx)
         jmax = jdiag
         do jrow = jdiag+1, n
            call fmabs(a(jrow, jdiag), temp, qx)
            if (fmcomp(temp, '>', amax, qx)) then
                call fmeq(temp, amax, qx)
                jmax = jrow
            endif
         enddo

!             If amax is zero here then the system is singular.

         if (amax%mp(3) == 0) then
             call fmi2m(0, det, qx)
             return
         endif

!             Swap rows jdiag and jmax unless they are the same row.

         kswap(jdiag) = jmax
         if (jmax /= jdiag) then
             call fmnegate(det, qx)
             do jcol = jdiag, n
                call fmeq(a(jdiag, jcol), temp, qx)
                call fmeq(a(jmax, jcol), a(jdiag, jcol), qx)
                call fmeq(temp, a(jmax, jcol), qx)
             enddo
         endif
         call fmmpy_r1(det, a(jdiag, jdiag), qx)

!             For jrow = jdiag+1, ..., n, eliminate a(jrow,jdiag) by replacing row jrow by
!                 row jrow - a(jrow,jdiag) * row jdiag / a(jdiag,jdiag)

         do jrow = jdiag+1, n
            if (a(jrow, jdiag)%mp(3) == 0) cycle
            call fmdiv(a(jrow, jdiag), a(jdiag, jdiag), amult, qx)

!             Save the multiplier for use later by fm_solve_lu.

            call fmeq(amult, a(jrow, jdiag), qx)
            do jcol = jdiag+1, n
               call fmmpy_sub(a(jrow, jcol), amult, a(jdiag, jcol), qx)
            enddo
         enddo
      enddo
      call fmmpy_r1(det, a(n, n), qx)

      end subroutine fmfactor_lu2

      subroutine fm_solve_lu(a, n, b, x, kswap)
      use fmvals_parallel
      implicit none

!  Solve a linear system  a x = b.
!  a is the n x n coefficient matrix, after having been factored by fm_factor_lu.
!  b is the n x 1 right-hand-side vector.
!  x is returned with the solution of the linear system.
!  kswap is a list of row interchanges made by the partial pivoting strategy during the
!        elimination phase in fm_factor_lu.
!  Time for this call is proportional to  n**2.

      integer :: n, kswap(n)
      type (fm) :: a(n, n), b(n), x(n)
      intent (in) :: a, n, b, kswap
      intent (inout) :: x

      type (multi), allocatable :: a1(:,:), b1(:), x1(:)
      integer :: i, j
      type(fm_settings) :: qx

      allocate(a1(n, n), stat=j)
      if (j /= 0) then
          write (*, "(/' Error in fm_solve_lu.  Unable to allocate array with n = ', i8/)") n
          stop
      endif

      do i = 1, n
         do j = 1, n
            call fmeq(a(i, j)%mfm, a1(i, j), qx)
         enddo
         call fmeq(b(i)%mfm, b1(i), qx)
      enddo

      call fmsolve_lu2(a1, n, b1, x1, kswap, qx)

      do i = 1, n
         call fmeq(x1(i), x(i)%mfm, qx)
      enddo

      return
      end subroutine fm_solve_lu

      subroutine fmsolve_lu2(a, n, b, x, kswap, qx)
      use fmvals_parallel
      implicit none

!  Solve a linear system  a x = b.
!  a is the n x n coefficient matrix, after having been factored by fm_factor_lu.
!  b is the n x 1 right-hand-side vector.
!  x is returned with the solution of the linear system.
!  kswap is a list of row interchanges made by the partial pivoting strategy during the
!        elimination phase in fm_factor_lu.
!  Time for this call is proportional to  n**2.

      integer :: n, kswap(n)
      type (multi) :: a(n, n), b(n), x(n)
      type(fm_settings) :: qx
      intent (in) :: a, n, b, kswap
      intent (inout) :: x, qx

      integer :: j, jdiag, jmax
      type (multi) :: temp

      if (n <= 0) then
          return
      endif
      if (n == 1) then
          call fmdiv(b(1), a(1, 1), x(1), qx)
          return
      endif
      do j = 1, n
         call fmeq(b(j), x(j), qx)
      enddo

!             Do the elimination phase operations only on x.
!             jdiag is the current diagonal element below which the elimination proceeds.

      do jdiag = 1, n-1

!             Pivot to put the element with the largest absolute value on the diagonal.

         jmax = kswap(jdiag)

!             Swap rows jdiag and jmax unless they are the same row.

         if (jmax /= jdiag) then
             call fmeq(x(jdiag), temp, qx)
             call fmeq(x(jmax), x(jdiag), qx)
             call fmeq(temp, x(jmax), qx)
         endif

!             For jrow = jdiag+1, ..., n, eliminate a(jrow,jdiag) by replacing row jrow by
!                 row jrow - a(jrow,jdiag) * row jdiag / a(jdiag,jdiag)
!             After factoring, a(jrow,jdiag) is the original a(jrow,jdiag) / a(jdiag,jdiag).

         do j = jdiag+1, n
            call fmmpy_sub(x(j), a(j, jdiag), x(jdiag), qx)
         enddo
      enddo

!             Do the back substitution.

      do jdiag = n, 1, -1

!             Divide row jdiag by the diagonal element.

         call fmdiv_r1(x(jdiag), a(jdiag, jdiag), qx)

!             Zero above the diagonal in column jdiag by replacing row jrow by
!                 row jrow - a(jrow,jdiag) * row jdiag
!             For jrow = 1, ..., jdiag-1.

         if (jdiag == 1) exit
         do j = 1, jdiag-1
            call fmmpy_sub(x(j), a(j, jdiag), x(jdiag), qx)
         enddo
      enddo

      end subroutine fmsolve_lu2

      subroutine fmmatmul21(n, ma, mb, mc, qx)
      use fmvals_parallel
      implicit none
      integer :: n
      type (multi) :: ma(n, n), mb(n), mc(n)
      type(fm_settings) :: qx
      intent (in) :: n, ma, mb
      intent (inout) :: mc, qx

      integer :: j, k, mxsave, nd2, ndsave
      type(multi) :: mtlvfm, mulvfm, mvlvfm, mtlv01

      ndsave = qx%ndig
      j = max(qx%ngrd52, 2)
      nd2 = max(2*qx%ndig+j, 2)
      qx%ndig = nd2
      mxsave = qx%mxexp
      do j = 1, n
         qx%mxexp = qx%mxexp2
         call fmi2m(0, mtlvfm, qx)
         do k = 1, n
            call fmequ(ma(j, k), mulvfm, ndsave, qx%ndig, qx)
            call fmequ(mb(k), mvlvfm, ndsave, qx%ndig, qx)
            call fmmpy(mulvfm, mvlvfm, mtlv01, qx)
            call fmadd_r1(mtlvfm, mtlv01, qx)
         enddo
         qx%mxexp = mxsave
         call fmequ(mtlvfm, mc(j), qx%ndig, ndsave, qx)
      enddo
      qx%ndig = ndsave

      end subroutine fmmatmul21

      subroutine fmmpy_sub(ma, mb, mc, qx)
      use fmvals_parallel
      implicit none

!  Fused multiply-subtract operation.  Return  ma = ma - mb*mc
!  This is an internal FM routine used by fm_factor_lu.  It doesn't always return correctly
!  rounded results, since precision will have already been raised by fm_lin_solve before
!  calling fm_factor_lu.

      type(multi) :: ma, mb, mc
      type(fm_settings) :: qx
      intent (in) :: mb, mc
      intent (inout) :: ma, qx

      type(multi) :: mxy
      integer :: j, k, k1, kl, kpta, kptc, ma_vs_mbmc
      double precision :: a1, a2, b, b1, b2, c1, c2, dpa, dpbc
      real (kind(1.0d0)) :: mbj, mgd

!             Special cases.

      if (mb%mp(3) == 0 .or. mc%mp(3) == 0 .or.  &
          ma%mp(2) - 1 > mb%mp(2) + mc%mp(2) + qx%ndig) then
          return
      endif
      if (ma%mp(3) == 0 .or.  &
          mb%mp(2) + mc%mp(2) - 1 > ma%mp(2) + qx%ndig) then
          call fmmpy(mb, mc, ma, qx)
          if (ma%mp(2) /= qx%munkno) ma%mp(1) = -ma%mp(1)
          return
      endif

      if (abs(ma%mp(2)) > qx%mexpab .or. abs(mb%mp(2)) > qx%mexpab .or.                  &
          abs(mc%mp(2)) > qx%mexpab .or. qx%mbase < 1000 .or. qx%mbase**2 > maxint .or.  &
          qx%ndig > 900 .or. qx%ndig > maxint/qx%mbase**2) then
          call fmmpy(mb, mc, mxy, qx)
          call fmsub_r1(ma, mxy, qx)
          return
      endif

!             Determine which of abs(ma) and abs(mb*mc) is larger.

      ma_vs_mbmc = 0
      b = qx%mbase

      kl = 1
      do while (kl == 1)
         kl = 0
         if (ma%mp(2) <= mb%mp(2) + mc%mp(2) - 2) then
             ma_vs_mbmc = -1
             kl = 2
             exit
         endif
         if (ma%mp(2) >= mb%mp(2) + mc%mp(2) + 1) then
             ma_vs_mbmc = 1
             kl = 2
             exit
         endif
         a1 = ma%mp(3)
         a2 = ma%mp(4)
         b1 = mb%mp(3)
         b2 = mb%mp(4)
         c1 = mc%mp(3)
         c2 = mc%mp(4)
         if (ma%mp(2) == mb%mp(2) + mc%mp(2) - 1) then
             dpa = a1 * b + a2 + 1
             dpbc = b1 * c1 * b  +  b1 * c2  +  b2 * c1  +  c2 * b2 / b
             if (dpa < dpbc) then
                 ma_vs_mbmc = -1
                 kl = 2
                 exit
             endif

             dpa = a1 * b + a2
             dpbc = b1 * c1 * b  +  b1 * (c2+1)  +  (b2+1) * c1  +  (c2+1) * (b2+1) / b
             if (dpa > dpbc) then
                 ma_vs_mbmc = 1
                 kl = 2
                 exit
             endif
         else if (ma%mp(2) == mb%mp(2) + mc%mp(2)) then
             dpa = a1 * b + a2 + 1
             dpbc = b1 * c1  +  ( b1 * c2 + b2 * c1 ) / b  +  c2 * b2 / b**2
             if (dpa < dpbc) then
                 ma_vs_mbmc = -1
                 kl = 2
                 exit
             endif

             dpa = a1 * b + a2
             dpbc = b1 * c1  +  ( b1 * (c2+1) + (b2+1) * c1 ) / b  +  (c2+1) * (b2+1) / b**2
             if (dpa > dpbc) then
                 ma_vs_mbmc = 1
                 kl = 2
                 exit
             endif
         endif
      enddo

!             If it is not easy to determine which term is larger, make separate calls to
!             multiply and subtract.

      if (kl == 0) then
          call fmmpy(mb, mc, mxy, qx)
          call fmsub_r1(ma, mxy, qx)
          return
      endif

!             Handle the operation using 4 cases, depending on which term is larger and whether
!             ma and mb*mc have opposite signs or not.

      if (ma%mp(1) * mb%mp(1) * mc%mp(1) < 0) then
          if (ma_vs_mbmc == 1) then
              mgd = 0
              k1 = 2 + ma%mp(2) - mb%mp(2) - mc%mp(2)
              do j = k1, qx%ndig
                 mbj = mb%mp(3+j-k1)
                 kpta = 2+j
                 kptc = 3
                 do k = j, qx%ndig
                    ma%mp(kpta) = ma%mp(kpta) + mbj * mc%mp(kptc)
                    kpta = kpta + 1
                    kptc = kptc + 1
                 enddo
                 if (kptc <= 2+qx%ndig) mgd = mgd + mbj * mc%mp(kptc)
              enddo
              k1 = ma%mp(2)
              ma%mp(2) = 0
              kpta = 3+qx%ndig
              ma%mp(kpta-1) = ma%mp(kpta-1) + nint( mgd / qx%mbase )
              do j = qx%ndig, 1, -1
                 kpta = kpta - 1
                 if (ma%mp(kpta) >= qx%mbase) then
                     k = ma%mp(kpta) / qx%mbase
                     ma%mp(kpta) = ma%mp(kpta) - k * qx%mbase
                     ma%mp(kpta-1) = ma%mp(kpta-1) + k
                 endif
              enddo
              if (ma%mp(2) > 0) then
                  do j = qx%ndig, 1, -1
                     ma%mp(2+j) = ma%mp(2+j-1)
                  enddo
                  k1 = k1 + 1
              endif
              ma%mp(2) = k1
              if (ma%mp(3) >= qx%mbase) then
                  do j = qx%ndig, 3, -1
                     ma%mp(2+j) = ma%mp(2+j-1)
                  enddo
                  k = ma%mp(3) / qx%mbase
                  ma%mp(4) = ma%mp(3) - k * qx%mbase
                  ma%mp(3) = k
                  ma%mp(2) = ma%mp(2) + 1
              endif
          endif

          if (ma_vs_mbmc == -1) then
              mgd = 0
              k1 = mb%mp(2) + mc%mp(2) - 1
              k = mb%mp(2) + mc%mp(2) - ma%mp(2) - 1
              ma%mp(2) = 0
              if (k > 0) then
                  if (k <= qx%ndig) mgd = ma%mp(2+qx%ndig+1-k)
                  do j = qx%ndig, k+1, -1
                     ma%mp(2+j) = ma%mp(2+j-k)
                  enddo
                  do j = 1, min(k, qx%ndig)
                     ma%mp(2+j) = 0
                  enddo
              else if (k == -1) then
                  do j = 1, qx%ndig
                     ma%mp(1+j) = ma%mp(1+j+1)
                  enddo
                  ma%mp(2+qx%ndig) = 0
              endif

              do j = 1, qx%ndig
                 mbj = mb%mp(2+j)
                 kpta = 2+j
                 kptc = 3
                 do k = j, qx%ndig
                    ma%mp(kpta) = ma%mp(kpta) + mbj * mc%mp(kptc)
                    kpta = kpta + 1
                    kptc = kptc + 1
                 enddo
                 if (kptc <= 2+qx%ndig) mgd = mgd + mbj * mc%mp(kptc)
              enddo
              kpta = 3+qx%ndig
              ma%mp(kpta-1) = ma%mp(kpta-1) + nint( mgd / qx%mbase )
              do j = qx%ndig, 1, -1
                 kpta = kpta - 1
                 if (ma%mp(kpta) >= qx%mbase) then
                     k = ma%mp(kpta) / qx%mbase
                     ma%mp(kpta) = ma%mp(kpta) - k * qx%mbase
                     ma%mp(kpta-1) = ma%mp(kpta-1) + k
                 endif
              enddo
              if (ma%mp(2) > 0) then
                  do j = qx%ndig, 1, -1
                     ma%mp(2+j) = ma%mp(2+j-1)
                  enddo
                  k1 = k1 + 1
              endif
              ma%mp(2) = k1
              if (ma%mp(3) >= qx%mbase) then
                  do j = qx%ndig, 3, -1
                     ma%mp(2+j) = ma%mp(2+j-1)
                  enddo
                  k = ma%mp(3) / qx%mbase
                  ma%mp(4) = ma%mp(3) - k * qx%mbase
                  ma%mp(3) = k
                  ma%mp(2) = ma%mp(2) + 1
              endif
          endif

      else
          call fmeq(ma, mxy, qx)

          if (ma_vs_mbmc == 1) then
              mgd = 0
              k1 = 2 + ma%mp(2) - mb%mp(2) - mc%mp(2)
              do j = k1, qx%ndig
                 mbj = mb%mp(3+j-k1)
                 kpta = 2+j
                 kptc = 3
                 do k = j, qx%ndig
                    ma%mp(kpta) = ma%mp(kpta) - mbj * mc%mp(kptc)
                    kpta = kpta + 1
                    kptc = kptc + 1
                 enddo
                 if (kptc <= 2+qx%ndig) mgd = mgd - mbj * mc%mp(kptc)
              enddo
              k1 = ma%mp(2)
              ma%mp(2) = 0
              kpta = 3+qx%ndig
              ma%mp(kpta-1) = ma%mp(kpta-1) + nint( mgd / qx%mbase )
              do j = qx%ndig, 1, -1
                 kpta = kpta - 1
                 if (ma%mp(kpta) < 0) then
                     k = (-ma%mp(kpta)-1) / qx%mbase + 1
                     ma%mp(kpta) = ma%mp(kpta) + k * qx%mbase
                     ma%mp(kpta-1) = ma%mp(kpta-1) - k
                 else if (ma%mp(kpta) >= qx%mbase) then
                     k = ma%mp(kpta) / qx%mbase
                     ma%mp(kpta) = ma%mp(kpta) - k * qx%mbase
                     ma%mp(kpta-1) = ma%mp(kpta-1) + k
                 endif
              enddo
              if (ma%mp(2) > 0) then
                  do j = qx%ndig, 1, -1
                     ma%mp(2+j) = ma%mp(2+j-1)
                  enddo
                  k1 = k1 + 1
              endif
              ma%mp(2) = k1
              if (ma%mp(3) == 0) then
                  call fmmpy(mb, mc, ma, qx)
                  call fmsub_r2(mxy, ma, qx)
                  return
              endif
          endif

          if (ma_vs_mbmc == -1) then
              mgd = 0
              k1 = mb%mp(2) + mc%mp(2) - 1
              k = mb%mp(2) + mc%mp(2) - ma%mp(2) - 1
              ma%mp(2) = 0
              if (k > 0) then
                  if (k <= qx%ndig) mgd = -ma%mp(2+qx%ndig+1-k)
                  do j = qx%ndig, k+1, -1
                     ma%mp(2+j) = -ma%mp(2+j-k)
                  enddo
                  do j = 1, min(k, qx%ndig)
                     ma%mp(2+j) = 0
                  enddo
              else if (k == -1) then
                  do j = 1, qx%ndig
                     ma%mp(1+j) = -ma%mp(1+j+1)
                  enddo
                  ma%mp(2+qx%ndig) = 0
              else if (k == 0) then
                  do j = 1, qx%ndig
                     ma%mp(2+j) = -ma%mp(2+j)
                  enddo
              endif

              do j = 1, qx%ndig
                 mbj = mb%mp(2+j)
                 kpta = 2+j
                 kptc = 3
                 do k = j, qx%ndig
                    ma%mp(kpta) = ma%mp(kpta) + mbj * mc%mp(kptc)
                    kpta = kpta + 1
                    kptc = kptc + 1
                 enddo
                 if (kptc <= 2+qx%ndig) mgd = mgd + mbj * mc%mp(kptc)
              enddo
              kpta = 3+qx%ndig
              ma%mp(kpta-1) = ma%mp(kpta-1) + nint( mgd / qx%mbase )
              do j = qx%ndig, 1, -1
                 kpta = kpta - 1
                 if (ma%mp(kpta) >= qx%mbase) then
                     k = ma%mp(kpta) / qx%mbase
                     ma%mp(kpta) = ma%mp(kpta) - k * qx%mbase
                     ma%mp(kpta-1) = ma%mp(kpta-1) + k
                 else if (ma%mp(kpta) < 0) then
                     k = (-ma%mp(kpta)-1) / qx%mbase + 1
                     ma%mp(kpta) = ma%mp(kpta) + k * qx%mbase
                     ma%mp(kpta-1) = ma%mp(kpta-1) - k
                 endif
              enddo
              if (ma%mp(2) > 0) then
                  do j = qx%ndig, 1, -1
                     ma%mp(2+j) = ma%mp(2+j-1)
                  enddo
                  k1 = k1 + 1
              endif
              ma%mp(2) = k1
              ma%mp(1) = -ma%mp(1)
              if (ma%mp(3) == 0) then
                  call fmmpy(mb, mc, ma, qx)
                  call fmsub_r2(mxy, ma, qx)
                  return
              endif
          endif

          return
      endif
      end subroutine fmmpy_sub

      subroutine fm_rk14( a, b, n_order, f, n_function, s, tol, s1 )
      use fmvals_parallel
      implicit none

!  Solve the vector first-order differential equation s' = f(x,s).

!  This routine uses 14th order Runge-Kutta with adjustable step size, starting at x = a
!  with state vector s (initial conditions), and returns state vector s1 as the solution
!  at x = b.

!  n_order is the order of the differential equation (length of vectors s and s1).

!  n_function is the function number (used in subroutine f) identifying which function f(x,s)
!             defines the right-hand-side of the differential equation to be solved.

!  tol is the absolute error tolerance.  Because the coefficients are defined with no more than
!      about 85-digit precision, tol should not be less than 1.0e-75.

!  The FM precision level should be set to at least 10 digits more than tol.
!  For example, set precision with call fm_set(30) if fm_rk14 will be called with tol = 1.0e-20.

!  The error estimate that is used to control step size will fail if f(x,s) is a function of
!  x only, not depending on s.  In this case, the differential equation is really just an
!  integration problem and should be done as a numerical integration.


      integer, parameter :: maximum_order = 3
      integer :: n_order, n_function
      type (fm) :: a, b, tol, s(maximum_order), s1(maximum_order)
      external :: f
      intent (in) :: a, b, n_order, n_function, tol
      intent (inout) :: s, s1

      integer :: j
      type (multi) :: ca(0:34), cb(0:34, 0:34), cc(0:34)
      type (multi) :: error_est, h, tol2, x, mxy(3), sl(maximum_order), s1l(maximum_order)
      logical :: last_step
      logical, external :: fmcomp
      type(fm_settings) :: qx


      call fmst2m('1.0e-75', mxy(1), qx)
      if (fmcomp(tol%mfm, '<', mxy(1), qx)) then
          write (*,*) ' '
          write (*,*) ' Error in input to fm_rk14.  tol should not be less than 1.0e-75.  It was'
          call fmprint(tol%mfm, qx)
          write (*,*) ' '
          stop
      endif

      do j = 1, n_order
         call fmeq(s(j)%mfm, sl(j), qx)
      enddo
      call fmrk14_coeffs(ca, cb, cc, qx)

!             Pick an initial step size.

      call fmabs(tol%mfm, tol2, qx)
      call fmdivi_r1(tol2, 1000, qx)
      call fmi2m(1, mxy(1), qx)
      call fmdivi(mxy(1), 14, mxy(2), qx)
      call fmpwr(tol2, mxy(2), h, qx)

      call fmeq(a%mfm, x, qx)
      last_step = .false.

      do j = 1, 10**7
         call fmadd(x, h, mxy(1), qx)
         if (fmcomp(mxy(1), '>=', b%mfm, qx)) then
             call fmsub(b%mfm, x, h, qx)
             last_step = .true.
         endif
         call fmrk14_step( n_order, f, n_function, ca, cb, cc, x, sl, h, error_est, s1l, qx)

!             If the error is too big, try again with halved step size.

         if (fmcomp(error_est, '>', tol2, qx)) then
             call fmdivi_r1(h, 2, qx)
             cycle
         endif

!             Make the step.

         if (last_step) then
             exit
         endif
         sl(1:n_order) = s1l(1:n_order)
         call fmadd_r1(x, h, qx)

!             If the error is much smaller than tol2, try doubling the step size.
!             Otherwise, if the error is less than tol2/10, try to fine-tune the
!             step size by increasing h slightly.

         call fmdivi(tol2, 100000, mxy(1), qx)
         call fmdivi(tol2, 10, mxy(2), qx)
         if (fmcomp(error_est, '<', mxy(1), qx)) then
             call fmmpyi_r1(h, 2, qx)
         else if (fmcomp(error_est, '<', mxy(2), qx)) then
             call fmmpyi(h, 105, mxy(3), qx)
             call fmdivi(mxy(3), 100, h, qx)
         endif
      enddo

      do j = 1, n_order
         call fmeq(s1l(j), s1(j)%mfm, qx)
      enddo

      end subroutine fm_rk14

      subroutine fmrk14_step( n_order, f, n_function, a, b, c, x, s, h, error_est, s1 , qx)

!  Do one step of 14th order Runge-Kutta, starting with state vector s(x) and returning
!  state vector s1(x+h) after a step of h.
!  n_order is the order of the differential equation (length of vector s).
!  n_function is the function number (used in f) identifying which function is to be solved.

      use fmvals_parallel
      implicit none

      integer, parameter :: maximum_order = 3
      integer :: n_stages, n_order, n_function
      type (multi) :: a(0:34), b(0:34, 0:34), c(0:34)
      type (multi) :: h, error_est, s(maximum_order), s1(maximum_order), x
      type(fm_settings) :: qx
      external :: f
      intent (in) :: n_order, n_function, a, b, c, x, s, h
      intent (inout) :: s1, error_est, qx

      integer :: j, k, l
      type (multi) :: fi_j(maximum_order, 0:34), fi(maximum_order), t,  &
                      yk(0:34, maximum_order), y(maximum_order), mxy(3)

      n_stages = 35

!             Do the step.

      do j = 1, n_order
         call fmeq(s(j), yk(0, j), qx)
      enddo
      do k = 1, n_stages - 1
         do l = 1, n_order
            call fmi2m(0, yk(k, l), qx)
         enddo
         do j = 0, k-1
            if (j == k-1) then
                do l = 1, n_order
                   call fmeq(yk(j, l), y(l), qx)
                enddo
                call fmmpy(a(j), h, mxy(1), qx)
                call fmadd(x, mxy(1), t, qx)
                call f(n_order, n_function, t, y, fi, qx)
                do l = 1, n_order
                   call fmeq(fi(l), fi_j(l, j), qx)
                enddo
            endif
            if (b(k, j)%mp(3) /= 0) then
                do l = 1, n_order
                   call fmmpy(b(k, j), fi_j(l, j), mxy(1), qx)
                   call fmadd_r1(yk(k, l), mxy(1), qx)
                enddo
            endif
         enddo
         do l = 1, n_order
            call fmmpy(h, yk(k, l), mxy(1), qx)
            call fmadd(yk(0, l), mxy(1), yk(k, l), qx)
         enddo
      enddo

      do l = 1, n_order
         call fmi2m(0, s1(l), qx)
      enddo
      do k = 0, n_stages - 1
         if (k == n_stages-1) then
             do l = 1, n_order
                call fmeq(yk(k, l), y(l), qx)
             enddo
             call fmmpy(a(k), h, mxy(1), qx)
             call fmadd(x, mxy(1), t, qx)
             call f(n_order, n_function, t, y, fi, qx)
             do l = 1, n_order
                call fmmpy(c(k), fi(l), mxy(1), qx)
                call fmadd_r1(s1(l), mxy(1), qx)
             enddo
         else
             do l = 1, n_order
                call fmmpy(c(k), fi_j(l, k), mxy(1), qx)
                call fmadd_r1(s1(l), mxy(1), qx)
             enddo
         endif
      enddo

      do l = 1, n_order
         call fmmpy(h, s1(l), mxy(1), qx)
         call fmadd(s(l), mxy(1), s1(l), qx)
      enddo

      call fmi2m(0, mxy(1), qx)
      do l = 1, n_order
         call fmsub(fi_j(l, 33), fi_j(l, 1), mxy(2), qx)
         call fmsqr(mxy(2), mxy(3), qx)
         call fmadd_r1(mxy(1), mxy(3), qx)
      enddo
      call fmsqrt(mxy(1), mxy(2), qx)
      call fmmpy(h, mxy(2), mxy(3), qx)
      call fmdivi(mxy(3), 1000, error_est, qx)

      end subroutine fmrk14_step

      subroutine fmrk14_coeffs(a, b, c, qx)

!  Define the coefficients used in the RK14 formula (85 digits).

!  These came from:
!  http://www.peterstone.name/Maplepgs/Maple/nmthds/RKcoeff/Runge_Kutta_schemes/RK14/RKcoeff14a_1.pdf

      use fmvals_parallel
      implicit none

      type (multi) :: a(0:34), b(0:34, 0:34), c(0:34)
      type(fm_settings) :: qx
      intent (inout) :: a, b, c, qx

      integer :: j, k

!             Many of the coefficients are zero.  Initialize A, B, and C here, then
!             skip those definitions below.

      do j = 0, 34
         do k = 0, 34
            call fmi2m(0, b(j, k), qx)
         enddo
         call fmi2m(0, a(j), qx)
         call fmi2m(0, c(j), qx)
      enddo

      call fmst2m('1', a(1), qx)
      call fmdivi_r1(a(1), 9, qx)
      call fmst2m('5', a(2), qx)
      call fmdivi_r1(a(2), 9, qx)
      call fmst2m('5', a(3), qx)
      call fmdivi_r1(a(3), 6, qx)
      call fmst2m('1', a(4), qx)
      call fmdivi_r1(a(4), 3, qx)
      call fmst2m('1', a(5), qx)
      call fmst2m('.6699869792727729217646837855059985139388452296384603532851421391683474428303956826239', a(6), qx)
      call fmst2m('.2970683842138183573895847168082194132233320946989156873791682903324708698499266217383', a(7), qx)
      call fmst2m('8', a(8), qx)
      call fmdivi_r1(a(8), 11, qx)
      call fmst2m('.1401527990421887652761874879669467176298064630825329362873230163439023340348096838456', a(9), qx)
      call fmst2m('.7007010397701507371510998548307493379414070492655464089692218490447945746638665522966', a(10), qx)
      call fmst2m('4', a(11), qx)
      call fmdivi_r1(a(11), 11, qx)
      call fmst2m('5', a(12), qx)
      call fmdivi_r1(a(12), 19, qx)
      call fmst2m('.392172246650270859125196642501208648863714315266128052078483e-1', a(13), qx)
      call fmst2m('.8129175029283767629833931592780365061896123726172385507744269795906758195776958783707', a(14), qx)
      call fmst2m('1', a(15), qx)
      call fmdivi_r1(a(15), 6, qx)
      call fmst2m('9', a(16), qx)
      call fmdivi_r1(a(16), 10, qx)
      call fmst2m('.6412992574519669233127711938966828094810966516150832254029235721305050295351572963693e-1', a(17), qx)
      call fmst2m('.2041499092834288489277446343010234050271495052413337516288702042649259099754335560687', a(18), qx)
      call fmst2m('.3953503910487605656156713698273243723522272974566594505545766538389345381768585023057', a(19), qx)
      call fmst2m('.6046496089512394343843286301726756276477727025433405494454233461610654618231414976943', a(20), qx)
      call fmst2m('.7958500907165711510722553656989765949728504947586662483711297957350740900245664439313', a(21), qx)
      call fmst2m('.9358700742548033076687228806103317190518903348384916774597076427869494970464842703631', a(22), qx)
      call fmst2m('1', a(23), qx)
      call fmdivi_r1(a(23), 6, qx)
      call fmst2m('.8129175029283767629833931592780365061896123726172385507744269795906758195776958783707', a(24), qx)
      call fmst2m('.392172246650270859125196642501208648863714315266128052078483e-1', a(25), qx)
      call fmst2m('4', a(26), qx)
      call fmdivi_r1(a(26), 11, qx)
      call fmst2m('.7007010397701507371510998548307493379414070492655464089692218490447945746638665522966', a(27), qx)
      call fmst2m('.1401527990421887652761874879669467176298064630825329362873230163439023340348096838456', a(28), qx)
      call fmst2m('.2970683842138183573895847168082194132233320946989156873791682903324708698499266217383', a(29), qx)
      call fmst2m('.6699869792727729217646837855059985139388452296384603532851421391683474428303956826239', a(30), qx)
      call fmst2m('1', a(31), qx)
      call fmdivi_r1(a(31), 3, qx)
      call fmst2m('5', a(32), qx)
      call fmdivi_r1(a(32), 9, qx)
      call fmst2m('1', a(33), qx)
      call fmdivi_r1(a(33), 9, qx)
      call fmst2m('1', a(34), qx)

      call fmst2m('1', c(0), qx)
      call fmdivi_r1(c(0), 56, qx)
      call fmst2m('3', c(1), qx)
      call fmdivi_r1(c(1), 512, qx)
      call fmst2m('3', c(2), qx)
      call fmdivi_r1(c(2), 256, qx)
      call fmst2m('9', c(4), qx)
      call fmdivi_r1(c(4), 512, qx)
      call fmst2m('3', c(6), qx)
      call fmdivi_r1(c(6), 128, qx)
      call fmst2m('15', c(7), qx)
      call fmdivi_r1(c(7), 512, qx)
      call fmst2m('9', c(9), qx)
      call fmdivi_r1(c(9), 256, qx)
      call fmst2m('21', c(10), qx)
      call fmdivi_r1(c(10), 512, qx)
      call fmst2m('3', c(11), qx)
      call fmdivi_r1(c(11), 64, qx)
      call fmst2m('27', c(13), qx)
      call fmdivi_r1(c(13), 512, qx)
      call fmst2m('15', c(14), qx)
      call fmdivi_r1(c(14), 256, qx)
      call fmst2m('33', c(15), qx)
      call fmdivi_r1(c(15), 512, qx)
      call fmst2m('.1053521135717530196914960328878781622276730830805238840416702908213176249782427570033', c(17), qx)
      call fmst2m('.1705613462417521823821203385538740858875554878027908047375010369442754416180982144816', c(18), qx)
      call fmst2m('.2062293973293519407835264857011048947419142862595424540779715293772640762608018856579', c(19), qx)
      call fmst2m('.2062293973293519407835264857011048947419142862595424540779715293772640762608018856579', c(20), qx)
      call fmst2m('.1705613462417521823821203385538740858875554878027908047375010369442754416180982144816', c(21), qx)
      call fmst2m('.1053521135717530196914960328878781622276730830805238840416702908213176249782427570033', c(22), qx)
      call fmst2m('-33', c(23), qx)
      call fmdivi_r1(c(23), 512, qx)
      call fmst2m('-15', c(24), qx)
      call fmdivi_r1(c(24), 256, qx)
      call fmst2m('-27', c(25), qx)
      call fmdivi_r1(c(25), 512, qx)
      call fmst2m('-3', c(26), qx)
      call fmdivi_r1(c(26), 64, qx)
      call fmst2m('-21', c(27), qx)
      call fmdivi_r1(c(27), 512, qx)
      call fmst2m('-9', c(28), qx)
      call fmdivi_r1(c(28), 256, qx)
      call fmst2m('-15', c(29), qx)
      call fmdivi_r1(c(29), 512, qx)
      call fmst2m('-3', c(30), qx)
      call fmdivi_r1(c(30), 128, qx)
      call fmst2m('-9', c(31), qx)
      call fmdivi_r1(c(31), 512, qx)
      call fmst2m('-3', c(32), qx)
      call fmdivi_r1(c(32), 256, qx)
      call fmst2m('-3', c(33), qx)
      call fmdivi_r1(c(33), 512, qx)
      call fmst2m('1', c(34), qx)
      call fmdivi_r1(c(34), 56, qx)

      call fmst2m('1', b(1, 0), qx)
      call fmdivi_r1(b(1, 0), 9, qx)
      call fmst2m('-5', b(2, 0), qx)
      call fmdivi_r1(b(2, 0), 6, qx)
      call fmst2m('25', b(2, 1), qx)
      call fmdivi_r1(b(2, 1), 18, qx)
      call fmst2m('5', b(3, 0), qx)
      call fmdivi_r1(b(3, 0), 24, qx)
      call fmst2m('5', b(3, 2), qx)
      call fmdivi_r1(b(3, 2), 8, qx)
      call fmst2m('29', b(4, 0), qx)
      call fmdivi_r1(b(4, 0), 150, qx)
      call fmst2m('11', b(4, 2), qx)
      call fmdivi_r1(b(4, 2), 50, qx)
      call fmst2m('-2', b(4, 3), qx)
      call fmdivi_r1(b(4, 3), 25, qx)
      call fmst2m('1', b(5, 0), qx)
      call fmdivi_r1(b(5, 0), 10, qx)
      call fmst2m('2', b(5, 3), qx)
      call fmdivi_r1(b(5, 3), 5, qx)
      call fmst2m('1', b(5, 4), qx)
      call fmdivi_r1(b(5, 4), 2, qx)
      call fmst2m('.1034845616366797766729935465119103444997447982019713166066629728281981965079290745983', b(6, 0), qx)
      call fmst2m('.1220688873064072225896440828689620771395927148341621347412746563709055937325311521675', b(6, 3), qx)
      call fmst2m('.4825744903312466224751347801256881128659190238501680496794015023696413273862321544150', b(6, 4), qx)
      call fmst2m('-.3814096000156069997308862400056202056641130724784114774219699240039767479629669855696e-1', b(6, 5), qx)
      call fmst2m('.1243805266540944128815164208687993162684914663596714231632892354628068537117612942798', b(7, 0), qx)
      call fmst2m('.2261202821975843014222386629792029011967523207426331439651447460281196206643404356021', b(7, 4), qx)
      call fmst2m('.1378858876180808806076958370164778145309694174914933853635428709475288586061552782365e-1', b(7, 5), qx)
      call fmst2m('-.6722101339966844497493995074143058569500863415253821828561997825320849038679063596730e-1', b(7, 6), qx)
      call fmst2m('.9369190656596738155308854560830059338663496952177500856556033862893464429241815101000e-1', b(8, 0), qx)
      call fmst2m('-.6134068434505109872294989956416647356209145071288588710070986068372475355320835997035e-2', b(8, 5), qx)
      call fmst2m('.2160198256255030637088600976598665734909794332781173201886676706066128640340557614360', b(8, 6), qx)
      call fmst2m('.4236950635157619373376190739609767532058674695441235326831157041055522397561196508237', b(8, 7), qx)
      call fmst2m('.8384798124090526646169687913728140859805331392249111310693346670107922625197375034871e-1', b(9, 0), qx)
      call fmst2m('-.1179493671009738143197550560312957753679619605907361507776128268875265788248790903515e-1', b(9, 5), qx)
      call fmst2m('-.2472990205688126523394738387431945983259928403533401326974984247503501083158412965835', b(9, 6), qx)
      call fmst2m('.9780808583677290122593130140812916655037406554767339407565991037499621093437371932341e-1', b(9, 7), qx)
      call fmst2m('.2175906892434206313600086517678603183441681200247821768799893467069296630467914197921', b(9, 8), qx)
      call fmst2m('.6152553597694282279545623896143147143334239690648211074539397569215087099333654844097e-1', b(10, 0), qx)
      call fmst2m('.5922327803245033080429900057980465247383895604442571368349896773084347972825775455007e-2', b(10, 5), qx)
      call fmst2m('.4703261599638411122172243032058941134553625307461088250108483236601604516650193568134', b(10, 6), qx)
      call fmst2m('.2996888638486790008539818370961923991368311216717812791841936858888827504094204242461', b(10, 7), qx)
      call fmst2m('-.2476568775939949146899922763298108258539580692639470955481886317480090967647905771626', b(10, 8), qx)
      call fmst2m('.1108950297714376828939998518390617145224451736006787182086245987785252503880550245038', b(10, 9), qx)
      call fmst2m('.4197000733627825798617928647872777872134836565431046112459945389674655429048057710370e-1', b(11, 0), qx)
      call fmst2m('-.317987696266205093901912847692712407988609169703103952205634e-2', b(11, 5), qx)
      call fmst2m('.8063977149061920772608217115203795063935431115674197501197468839656405367779525213500', b(11, 6), qx)
      call fmst2m('.9759831264123889790935228506842888513146720480030545503571875185550549213299958241991e-1', b(11, 7), qx)
      call fmst2m('.7785755781583989090275124464529272389997634605941819649588520345133050850477185489203', b(11, 8), qx)
      call fmst2m('.2048904238315994281894992020981056033120292350814206535748293420400885242747823516625', b(11, 9), qx)
      call fmst2m('-1.562615796274681883070709439505278252114628922364243608928053762634922556160297217820', b(11, 10), qx)
      call fmst2m('.4377267822337301635744652424953398116882149670716141232569729223172939742940416733395e-1', b(12, 0), qx)
      call fmst2m('.6243650275201952087943586285809336252816312169030959172012504609444028241438248581173e-2', b(12, 8), qx)
      call fmst2m('.2000430971095773149944351654696478568290662322182649696087680691197048872391143823078', b(12, 9), qx)
      call fmst2m('-.8053283678049830368238571620489029119233928873370293148442058928084075077460302544840e-2', b(12, 10), qx)
      call fmst2m('.2115175280673965219157119035233996013168778251575505730512208770404786743066139905871e-1', b(12, 11), qx)
      call fmst2m('.2834992503635145630950235919207173122471376548964770977684956012393009143065795513785e-1', b(13, 0), qx)
      call fmst2m('.2491632048558174075389491488059951494598846535854176800982219995075912885766744587193e-2', b(13, 8), qx)
      call fmst2m('.2301387878545931496383998463737427687720871226381422342236583655735620108657836993957e-1', b(13, 9), qx)
      call fmst2m('-.3221559566929770987244760924671208781894636047606204610433085107190031098987004938258e-2', b(13, 10), qx)
      call fmst2m('.9884425494476646689463354144878852560408199827860146481292993078049373245839618405001e-2', b(13, 11), qx)
      call fmst2m('-.2130107713288873513843076428759273848866345654295724666320922464722154754985568313136e-1', b(13, 12), qx)
      call fmst2m('.3435118942902430010494322347351479430833531749807014262686507474123120416010457867571', b(14, 0), qx)
      call fmst2m('.2104519120236273856090970119990106557888074052256267000419050051487632641518018732685', b(14, 8), qx)
      call fmst2m('1.034274520572304119364829268288257099386679996983247401666929134177931632176349026735', b(14, 9), qx)
      call fmst2m('.6003036458644224870512404482066405749390780924061569454673075686417142117164254262878e-2', b(14, 10), qx)
      call fmst2m('.8559381250996195375780121060024077289150626526164160058172684354881277648341960563008', b(14, 11), qx)
      call fmst2m('-.9772350050367668108722648523725256330131076568928396776974412446349105799705851506077', b(14, 12), qx)
      call fmst2m('-.6600269804792946946162250138563276937205739812199748747775581736879654453322759683463', b(14, 13), qx)
      call fmst2m('-.1435740016721680695382063999350763666577559543783998809757153672896315044426183882232e-1', b(15, 0), qx)
      call fmst2m('-.3662532700490399702936857968489747917331190817335522078657913621382824038988807796287e-1', b(15, 8), qx)
      call fmst2m('.3502549756362136819768494069798465243467890824711035742020654749717518291597210559354e-1', b(15, 9), qx)
      call fmst2m('.3609460163621135089317866587583352398236899298642376718895880083960486970547825683491e-1', b(15, 10), qx)
      call fmst2m('-.2652199675536811063515959468346019236496270124574642848667252606942739787160130682669e-1', b(15, 11), qx)
      call fmst2m('.4456990113056981196389115375088399081043363230822267716707629092315111479614958673268e-1', b(15, 12), qx)
      call fmst2m('.1243430933313582432862255957417864480389734088951067419167759990001419776217292554191', b(15, 13), qx)
      call fmst2m('.4138296932394806944035124962043359604261929086744760344472227418812310333088685698274e-2', b(15, 14), qx)
      call fmst2m('.3560324044251202909756091163980891762641062223797488026536968101501275805051289760823', b(16, 0), qx)
      call fmst2m('-.450192758947562595966821779075956175110645100214763601190349', b(16, 8), qx)
      call fmst2m('.430527907083710898626656292808782917793030154094709462877146', b(16, 9), qx)
      call fmst2m('.5119730290110222376685569603940716920771257870306513863906805244405042813755411512463', b(16, 10), qx)
      call fmst2m('.9083036388864042603901591246381102139974962148199046305445452541870528153933236088278', b(16, 11), qx)
      call fmst2m('-1.239210933719339317573724691515340288544138892486057261860887966510000755220957594942', b(16, 12), qx)
      call fmst2m('-.6490486616717614651416723488790625539054028319671910976544025456235491510559878435372', b(16, 13), qx)
      call fmst2m('.2517089045868192922104805299489705414048878529314474912189256354259853776829630937658', b(16, 14), qx)
      call fmst2m('.7799064703455863988107567952823344760235405934115501870206452879298798513199886085571', b(16, 15), qx)
      call fmst2m('.1309356874065130664068812064188349801274704382131924878449566575565302965696195341197e-1', b(17, 0), qx)
      call fmst2m('-.9320530679851139459084619627671082378586315096846671421247697017556505173897578610165e-4', b(17, 12), qx)
      call fmst2m('.5053743342622993596400904431385907267709423447161223817027456630856526555478831396014e-1', b(17, 13), qx)
      call fmst2m('.8044703419444879791095791096101977976413118689308653610493721999399129417586629251430e-6', b(17, 14), qx)
      call fmst2m('.5917260294941711905287557427777172598443409719243215281782302034071342229921661278343e-3', b(17, 15), qx)
      call fmst2m('-.4016147221545573370646916849063755877322642479500938046774565993013424294867398455789e-6', b(17, 16), qx)
      call fmst2m('.2079264844660530125419445440007656521672552061443734079797586969853055549175505457737e-1', b(18, 0), qx)
      call fmst2m('.5826959188000859151019026978372841089514061030298715701031065480360641416298102920851e-3', b(18, 12), qx)
      call fmst2m('-.8017007323588159390833421865258527466405584659196335246554992680506588169863285718822e-2', b(18, 13), qx)
      call fmst2m('.4038476438471369403751708217435605704841172903308955066191655368223862388605213690921e-5', b(18, 14), qx)
      call fmst2m('.8546099980555061442250561145675356025101146220336224918025961310211940592009621595606e-1', b(18, 15), qx)
      call fmst2m('-.2044864809358042427067075696910043079044428375526774562331430989116458814609927891477e-5', b(18, 16), qx)
      call fmst2m('.1053285788244318933997994029790939973542409042351728431465827473723673651882417656762', b(18, 17), qx)
      call fmst2m('1.401534497957360214154462473557713067184864529175977331289881318884096354294079099114', b(19, 0), qx)
      call fmst2m('-.2302520009842212616162724103674156212611302982744556219175010157057031125814669239016', b(19, 12), qx)
      call fmst2m('-7.211068404669129056595822371068742471658564935099615697324849532576890894506619405031', b(19, 13), qx)
      call fmst2m('.3729015606948363352369953278521323402177595666786623882373057096229137360164435411243e-2', b(19, 14), qx)
      call fmst2m('-4.714154957271250206787781793922247570113233732218200980194845522013711035054762664884', b(19, 15), qx)
      call fmst2m('-.1763676575453492420538419950327976735749038866956001340593194717236122233799126229446e-2', b(19, 16), qx)
      call fmst2m('7.641305480386987655630293108802376511851733678139370059818519661401442202665741111270', b(19, 17), qx)
      call fmst2m('3.506020436597518349898960829497447109682129498933753736341591881470708008233521976557', b(19, 18), qx)
      call fmst2m('11.95146506941206867993723858307164016744736108265535168242754934626543968357331742096', b(20, 0), qx)
      call fmst2m('7.794809321081759687835167002317643882202842795989809549197917776161588225206322580459', b(20, 12), qx)
      call fmst2m('-56.45013938673257925235609911209042814404681000613405538635967763011214022629172907669', b(20, 13), qx)
      call fmst2m('.9123763069306449013445304492902766457096074504036737047499704936582270274950128398912e-1', b(20, 14), qx)
      call fmst2m('-12.73362799254348862019455243091992750381627175299189605168457824373779389828110581300', b(20, 15), qx)
      call fmst2m('-.3968959219047197123135428109397366747123830704331478729319411886202118671113516172493e-1', b(20, 16), qx)
      call fmst2m('54.43921418835708869962257651553077918614383784233053341001985423053366890118247056463', b(20, 17), qx)
      call fmst2m('-3.644116379215692368464069903613506458067214784092667356589342345057374050114156075061', b(20, 18), qx)
      call fmst2m('-.8045032499105099108990307879585794993156949132107878807481027183961246894903442258757', b(20, 19), qx)
      call fmst2m('-148.8094265071004884278388682686476255619306120821485965777899951377767737092911763254', b(21, 0), qx)
      call fmst2m('-91.72952782912564843579356624023216234952287290363542836291360346578688265538801398361', b(21, 12), qx)
      call fmst2m('707.6561449715983598345757192863357161548211289666495623584804744987957677893379157809', b(21, 13), qx)
      call fmst2m('-1.10563611857482440905296961311590930801338308942637769555540', b(21, 14), qx)
      call fmst2m('176.1345918838113725878598980760556604069995167623016865882869129962911416096097878945', b(21, 15), qx)
      call fmst2m('.4913848242148806622688983451644545574168846314027647925019604519368994965045299923826', b(21, 16), qx)
      call fmst2m('-684.2780004498149443582375356108950819560771678936002751371799726829821841834791232605', b(21, 17), qx)
      call fmst2m('27.99106049983982589842243321243804074460025184006686868209688958109916979926727384229', b(21, 18), qx)
      call fmst2m('13.19397100302823334436709643711532384350641596237449753683872220663989495376087330358', b(21, 19), qx)
      call fmst2m('1.251287812839804454501149741480560063172688300773964063605141347518040989702499199856', b(21, 20), qx)
      call fmst2m('-9.673079469481967636441261184332193958399514085718772596349277868068021458303626779169', b(22, 0), qx)
      call fmst2m('-4.469901508585055314438462277019603604978306814087514357488023393670679083633020106516', b(22, 12), qx)
      call fmst2m('45.51271286909526819682419504000527511789059078173984816890412459840121969200961260987', b(22, 13), qx)
      call fmst2m('-.713085086183826912791492024438246129930559805352394367050813e-1', b(22, 14), qx)
      call fmst2m('11.22736140684127415825906244799393842078268007767944830815221105133516977144595052189', b(22, 15), qx)
      call fmst2m('.1262443767176227245162379129091388093617868898191054263714925416869147773104813482457', b(22, 16), qx)
      call fmst2m('-43.54393395494833136058106249072421076238143044676214056937881652359375369765457150165', b(22, 17), qx)
      call fmst2m('.7871743075430589783987929949965509020645460914432340378113766124779028133099797867162', b(22, 18), qx)
      call fmst2m('.5322646967446842156693007086038866907853957768215038536520118921656033723449302296244', b(22, 19), qx)
      call fmst2m('.4224227339963253260102251274713887725750865388096033468497941673910509540050957057177', b(22, 20), qx)
      call fmst2m('.8591312495030671073084380314998594434411150562941549563989586466154235621165245563192e-1', b(22, 21), qx)
      call fmst2m('-10.06640324470547024033966069004268914722028247579687652710623604380152449409080444899', b(23, 0), qx)
      call fmst2m('-.3662532700490399702936857968489747917331190817335522078657913621382824038988807796287e-1', b(23, 8), qx)
      call fmst2m('.3502549756362136819768494069798465243467890824711035742020654749717518291597210559354e-1', b(23, 9), qx)
      call fmst2m('.3609460163621135089317866587583352398236899298642376718895880083960486970547825683491e-1', b(23, 10), qx)
      call fmst2m('-.2652199675536811063515959468346019236496270124574642848667252606942739787160130682669e-1', b(23, 11), qx)
      call fmst2m('-6.270889721814641435905531494788716038393561229573960230194057818533161624674313994502', b(23, 12), qx)
      call fmst2m('48.20792374425629890907021030081950639234925931416361161278899187780407980462426656808', b(23, 13), qx)
      call fmst2m('-.694471689136165640882395180583732834557754169149088630301342e-1', b(23, 14), qx)
      call fmst2m('12.68106902048502956983413709136098070661084838114121251454273060707937017246509534894', b(23, 15), qx)
      call fmst2m('.119671168968323754838161435501011294100927813964199613229864e-1', b(23, 16), qx)
      call fmst2m('-46.72497649924824080033582682426626955932013216597956070401309263301039263373634230581', b(23, 17), qx)
      call fmst2m('1.330296133266267113147100392982165913990335111912271192356479099067512051132965697343', b(23, 18), qx)
      call fmst2m('1.007667875033982983534389036199266577711627177936617199056121787956529680139072027935', b(23, 19), qx)
      call fmst2m('.2095120519336650916641223884754807028927707538644872411247284065032940106679251005781e-1', b(23, 20), qx)
      call fmst2m('.2101347063312641773177354243313964074244121884437574908902263894855162847478911411134e-1', b(23, 21), qx)
      call fmst2m('.9521960144171217941751015424545759073763602336583562405468424451848266905185171865534e-2', b(23, 22), qx)
      call fmst2m('-409.4780816777437087725890974093703576244243416067520683455326035855162023776088699896', b(24, 0), qx)
      call fmst2m('.2104519120236273856090970119990106557888074052256267000419050051487632641518018732685', b(24, 8), qx)
      call fmst2m('1.034274520572304119364829268288257099386679996983247401666929134177931632176349026735', b(24, 9), qx)
      call fmst2m('.6003036458644224870512404482066405749390780924061569454673075686417142117164254262878e-2', b(24, 10), qx)
      call fmst2m('.8559381250996195375780121060024077289150626526164160058172684354881277648341960563008', b(24, 11), qx)
      call fmst2m('-250.5169985474478604927776577293161303865840504207820779326393997812026874735614210230', b(24, 12), qx)
      call fmst2m('1946.424666523884277660537503282647585958298508957614274560610260899186136259514015246', b(24, 13), qx)
      call fmst2m('-3.045038821023103655061058090868608827869505440976021016842196622317831446605499698935', b(24, 14), qx)
      call fmst2m('490.6263795282817135212082652991680838415985422740616633051003594128766152337185220086', b(24, 15), qx)
      call fmst2m('1.566475895312709071154840670135974457395956152459667753199388690841173424714434871921', b(24, 16), qx)
      call fmst2m('-1881.974289940111733622172673770358706192159066384530557689275696031792911993357071098', b(24, 17), qx)
      call fmst2m('75.25922247248471752788377136433031498216206189142459440229301807516615379972994062700', b(24, 18), qx)
      call fmst2m('34.57343569803310676224343447365546896967286447935510158001529990937243976348724448442', b(24, 19), qx)
      call fmst2m('3.211476794409689614354173618470737551690229667488916278855754113243135684398993410117', b(24, 20), qx)
      call fmst2m('-.4604080417384143913072014042370588488672450952653828208427296561415079214017074427602', b(24, 21), qx)
      call fmst2m('-.8707183398418105224318841379579862457242520473889365722145748143125162133630944128398e-1', b(24, 22), qx)
      call fmst2m('-7.393518141583030675670169521955210639991857732491329543926346613193825315394087286297', b(24, 23), qx)
      call fmst2m('3.433474758535508789210934962575967811206238910720084588712755786644583035514752699598', b(25, 0), qx)
      call fmst2m('.2491632048558174075389491488059951494598846535854176800982219995075912885766744587193e-2', b(25, 8), qx)
      call fmst2m('.2301387878545931496383998463737427687720871226381422342236583655735620108657836993957e-1', b(25, 9), qx)
      call fmst2m('-.3221559566929770987244760924671208781894636047606204610433085107190031098987004938258e-2', b(25, 10), qx)
      call fmst2m('.9884425494476646689463354144878852560408199827860146481292993078049373245839618405001e-2', b(25, 11), qx)
      call fmst2m('2.162527993779225077883078419047573540457592253357327094851479956564246957314476133478', b(25, 12), qx)
      call fmst2m('-16.26998645464574213280656406601394890069875520402288517985775075363232756881970486667', b(25, 13), qx)
      call fmst2m('-.1285345021205245528435834174709350105380290375426545062302651848844352856037884822181', b(25, 14), qx)
      call fmst2m('-8.98915042666504253089307820833379330486511746063552853023189', b(25, 15), qx)
      call fmst2m('-.3485953632320253333870802018510136501924017672505137649688730136175086767654181319387e-2', b(25, 16), qx)
      call fmst2m('15.79361941133398075362351873886955741358533870251397376656158275266140525531011608606', b(25, 17), qx)
      call fmst2m('-.5744033309140950656281654820173358201483836631956754708231458398423255984252281047127', b(25, 18), qx)
      call fmst2m('-.3456020390213932966927224966081249825352372288276553067081833889419898565070467534157', b(25, 19), qx)
      call fmst2m('-.6622414902065850917316199913837577811330679927074186873906450413385445874036001388495e-2', b(25, 20), qx)
      call fmst2m('-.7777881292422041640325464586073643097593472096267591120155367761150273183248441708392e-2', b(25, 21), qx)
      call fmst2m('-.3560841924022749133388272326974373646752408187917065879526063406092336300493607300593e-2', b(25, 22), qx)
      call fmst2m('4.792825064499307996497977496298401894572969341393590555417712618624354747222657791607', b(25, 23), qx)
      call fmst2m('.153725464873068577844576387402512082757034273069877432944621', b(25, 24), qx)
      call fmst2m('32.30385208719854423269947344400315350913649750477846297617061421719281146058139852238', b(26, 0), qx)
      call fmst2m('-.317987696266205093901912847692712407988609169703103952205634e-2', b(26, 5), qx)
      call fmst2m('.8063977149061920772608217115203795063935431115674197501197468839656405367779525213500', b(26, 6), qx)
      call fmst2m('.9759831264123889790935228506842888513146720480030545503571875185550549213299958241991e-1', b(26, 7), qx)
      call fmst2m('.7785755781583989090275124464529272389997634605941819649588520345133050850477185489203', b(26, 8), qx)
      call fmst2m('.2048904238315994281894992020981056033120292350814206535748293420400885242747823516625', b(26, 9), qx)
      call fmst2m('-1.562615796274681883070709439505278252114628922364243608928053762634922556160297217820', b(26, 10), qx)
      call fmst2m('16.34298918823105706485042439739271747087533535041545512917666902744198799725970841669', b(26, 12), qx)
      call fmst2m('-154.5445552935436212307301896314710363993166836696091165017078152549564923882084122674', b(26, 13), qx)
      call fmst2m('1.569710887033348726920342834176217614662635935824970859658624964687079589089479471888', b(26, 14), qx)
      call fmst2m('3.276855450872481313214298172699007311655224049747336000450385269517693130775985884604', b(26, 15), qx)
      call fmst2m('-.5034892451936531763480407271997836265340810956916323972462042700071863164675818955838e-1', b(26, 16), qx)
      call fmst2m('153.3211518580416650705937678859146940112243631025945564907021486707139114294996134941', b(26, 17), qx)
      call fmst2m('7.175681863277204958467664848147841435678263080348653386540185145833155908488128910568', b(26, 18), qx)
      call fmst2m('-2.940367486753004819459176598969309892153205943807775979427615740476908865098135595635', b(26, 19), qx)
      call fmst2m('-.6658459460768031444707496760226288702819204931972568878708744783028558369468497032253e-1', b(26, 20), qx)
      call fmst2m('-.4623460549908436612292486685622172611769665140168592842374268449140643068786760618896e-1', b(26, 21), qx)
      call fmst2m('-.2041987335856794015393882286172697788485797748215817776751235910664984352284968100100e-1', b(26, 22), qx)
      call fmst2m('-53.35231064387358505159534411659981079740450904957915977996876390672711239156977103431', b(26, 23), qx)
      call fmst2m('-1.355487147150786549787321867059964040175545016141913251148206738329360142936656282958', b(26, 24), qx)
      call fmst2m('-1.571962758012327518829017351714592491776872191144425834618663282570958684038698495739', b(26, 25), qx)
      call fmst2m('-16.64514674863415128720312944039317587645603711308189782044257016154825923946758475845', b(27, 0), qx)
      call fmst2m('.5922327803245033080429900057980465247383895604442571368349896773084347972825775455007e-2', b(27, 5), qx)
      call fmst2m('.4703261599638411122172243032058941134553625307461088250108483236601604516650193568134', b(27, 6), qx)
      call fmst2m('.2996888638486790008539818370961923991368311216717812791841936858888827504094204242461', b(27, 7), qx)
      call fmst2m('-.2476568775939949146899922763298108258539580692639470955481886317480090967647905771626', b(27, 8), qx)
      call fmst2m('.1108950297714376828939998518390617145224451736006787182086245987785252503880550245038', b(27, 9), qx)
      call fmst2m('-.4917190438462291470706666287041940976780819072106730449888664749836403474888832394921', b(27, 11), qx)
      call fmst2m('-11.47431544272894969683894925643525363508424541308531757856483965863898534849416840511', b(27, 12), qx)
      call fmst2m('80.25931665762302725417024858864844001527933666235899875893849400507278534931158408231', b(27, 13), qx)
      call fmst2m('-.3841323039800428476253125267590291037469268413420882192068133107492120348263618466046', b(27, 14), qx)
      call fmst2m('7.281476674681075834713269509261361157676125818628777243483988994104498714011047355205', b(27, 15), qx)
      call fmst2m('-.1326993846122483795105717081760352748368273416167518843018178653526280269065470590467', b(27, 16), qx)
      call fmst2m('-81.07998325257307266746792897522552400060707166336329885641562357237166810196760593013', b(27, 17), qx)
      call fmst2m('-1.250374928356206395217681856561791199622537474924031863192434629401819729868852090550', b(27, 18), qx)
      call fmst2m('2.592635949695436810237763795043773249942264473592968880837586883560068434349818491911', b(27, 19), qx)
      call fmst2m('-.3014402983464045398301639972605268752644315372756414953420797074457552586137488110716', b(27, 20), qx)
      call fmst2m('.2213844607898323374517064515727737916952468390573184143179573617704323166985265217363', b(27, 21), qx)
      call fmst2m('.8275772747718929319559898709746931529962764354298098905497078729734353980896315305691e-1', b(27, 22), qx)
      call fmst2m('18.99606620406115204646724500372432639981751614122371589366718674999943569769696943522', b(27, 23), qx)
      call fmst2m('.2692319464096396856234680151283341674600519103489128451211866688910668614577677735665', b(27, 24), qx)
      call fmst2m('1.626748274470665374629893649296289339881250292841836802790201430504847697803528636395', b(27, 25), qx)
      call fmst2m('.4917190438462291470706666287041940976780819072106730449888664749836403474888832394921', b(27, 26), qx)
      call fmst2m('.8384798124090526646169687913728140859805331392249111310693346670107922625197375034871e-1', b(28, 0), qx)
      call fmst2m('-.1179493671009738143197550560312957753679619605907361507776128268875265788248790903515e-1', b(28, 5), qx)
      call fmst2m('-.2472990205688126523394738387431945983259928403533401326974984247503501083158412965835', b(28, 6), qx)
      call fmst2m('.9780808583677290122593130140812916655037406554767339407565991037499621093437371932341e-1', b(28, 7), qx)
      call fmst2m('.2175906892434206313600086517678603183441681200247821768799893467069296630467914197921', b(28, 8), qx)
      call fmst2m('.1375856067633252248656596321967877466474472229750848659754400903987833771639575727867', b(28, 10), qx)
      call fmst2m('.4398702297150466850587900923415450260461038902942613590425808839943205635447284745074e-1', b(28, 11), qx)
      call fmst2m('-.5137008137681933419570044566186303037387573636419640300869712169933398305905931343468', b(28, 13), qx)
      call fmst2m('.8263556911513155086442113083991534587014231586161685769224194977471882335420141183213', b(28, 14), qx)
      call fmst2m('25.70181397198118326258738829725199395111365563419600781824702737091645129169813134401', b(28, 15), qx)
      call fmst2m('-25.70181397198118326258738829725199395111365563419600781824702737091645129169813134401', b(28, 23), qx)
      call fmst2m('-.8263556911513155086442113083991534587014231586161685769224194977471882335420141183213', b(28, 24), qx)
      call fmst2m('.5137008137681933419570044566186303037387573636419640300869712169933398305905931343468', b(28, 25), qx)
      call fmst2m('-.4398702297150466850587900923415450260461038902942613590425808839943205635447284745074e-1', b(28, 26), qx)
      call fmst2m('-.1375856067633252248656596321967877466474472229750848659754400903987833771639575727867', b(28, 27), qx)
      call fmst2m('.1243805266540944128815164208687993162684914663596714231632892354628068537117612942798', b(29, 0), qx)
      call fmst2m('.2261202821975843014222386629792029011967523207426331439651447460281196206643404356021', b(29, 4), qx)
      call fmst2m('.1378858876180808806076958370164778145309694174914933853635428709475288586061552782365e-1', b(29, 5), qx)
      call fmst2m('-.6722101339966844497493995074143058569500863415253821828561997825320849038679063596730e-1', b(29, 6), qx)
      call fmst2m('-.8562389750854283547553497698795017721121215974115638028550665385850612741040225222977', b(29, 9), qx)
      call fmst2m('-1.963375228668589089282628500280938139881804405182674045535756631526916950083353845169', b(29, 10), qx)
      call fmst2m('-.2323328227241194012372462573089218472501081992304199949782180319905262045718872259601', b(29, 11), qx)
      call fmst2m('4.306607190864533494616689368765629477724325620534780926267640393608500758570100495873', b(29, 13), qx)
      call fmst2m('-2.927229632494654826597879112023904466876873949506336126307786635262992367484998786517', b(29, 14), qx)
      call fmst2m('-82.31316663978589444544923341054587077357619664281386893950601309356417181948645997040', b(29, 15), qx)
      call fmst2m('82.31316663978589444544923341054587077357619664281386893950601309356417181948645997040', b(29, 23), qx)
      call fmst2m('2.927229632494654826597879112023904466876873949506336126307786635262992367484998786517', b(29, 24), qx)
      call fmst2m('-4.306607190864533494616689368765629477724325620534780926267640393608500758570100495873', b(29, 25), qx)
      call fmst2m('.2323328227241194012372462573089218472501081992304199949782180319905262045718872259601', b(29, 26), qx)
      call fmst2m('1.963375228668589089282628500280938139881804405182674045535756631526916950083353845169', b(29, 27), qx)
      call fmst2m('.8562389750854283547553497698795017721121215974115638028550665385850612741040225222977', b(29, 28), qx)
      call fmst2m('.1034845616366797766729935465119103444997447982019713166066629728281981965079290745983', b(30, 0), qx)
      call fmst2m('.1220688873064072225896440828689620771395927148341621347412746563709055937325311521675', b(30, 3), qx)
      call fmst2m('.4825744903312466224751347801256881128659190238501680496794015023696413273862321544150', b(30, 4), qx)
      call fmst2m('-.3814096000156069997308862400056202056641130724784114774219699240039767479629669855696e-1', b(30, 5), qx)
      call fmst2m('-.5504995253108023241383885070205081774114143110000375617128363206424473498745141065969', b(30, 7), qx)
      call fmst2m('-.7119158115851892278876482620437943875782918824067455704957652139710574799878630163853', b(30, 9), qx)
      call fmst2m('-.5841296056715513404329887301584808720953353296452275957070524410065417676683463009109', b(30, 10), qx)
      call fmst2m('2.110463081258649321287173000466227503003750542789369878507182287710881470618943318741', b(30, 13), qx)
      call fmst2m('-.8374947367395721355257420230010379926952601753351235177405529298334532793741463162845e-1', b(30, 14), qx)
      call fmst2m('5.100214990723209140752959690433441131075450608628042491597346388445135412965217165555', b(30, 15), qx)
      call fmst2m('-5.100214990723209140752959690433441131075450608628042491597346388445135412965217165555', b(30, 23), qx)
      call fmst2m('.8374947367395721355257420230010379926952601753351235177405529298334532793741463162845e-1', b(30, 24), qx)
      call fmst2m('-2.110463081258649321287173000466227503003750542789369878507182287710881470618943318741', b(30, 25), qx)
      call fmst2m('.5841296056715513404329887301584808720953353296452275957070524410065417676683463009109', b(30, 27), qx)
      call fmst2m('.7119158115851892278876482620437943875782918824067455704957652139710574799878630163853', b(30, 28), qx)
      call fmst2m('.5504995253108023241383885070205081774114143110000375617128363206424473498745141065969', b(30, 29), qx)
      call fmst2m('29', b(31, 0), qx)
      call fmdivi_r1(b(31, 0), 150, qx)
      call fmst2m('11', b(31, 2), qx)
      call fmdivi_r1(b(31, 2), 50, qx)
      call fmst2m('-2', b(31, 3), qx)
      call fmdivi_r1(b(31, 3), 25, qx)
      call fmst2m('.1099934255807247039194624048650683408451190582958464264636524271459687549994002654752', b(31, 6), qx)
      call fmst2m('-.2542970480762701613840685069971531221418356269767039208462421656164179875269042982442', b(31, 7), qx)
      call fmst2m('.8655707771166942543437703438210982818328474012330118593467368132762510892051242759318', b(31, 9), qx)
      call fmst2m('3.324164491140930831067995527865720183368600929369864071601998386039920635781409865040', b(31, 10), qx)
      call fmst2m('-12.01022233159779338823523851486618412603019426339968151272769528462035002110216728101', b(31, 13), qx)
      call fmst2m('.4766014662424932394304427768620618996029637820035802094825720242694315551196576125507', b(31, 14), qx)
      call fmst2m('-29.02430112210363905258026232136540995962512213324709106915239870601916450708546744075', b(31, 15), qx)
      call fmst2m('29.02430112210363905258026232136540995962512213324709106915239870601916450708546744075', b(31, 23), qx)
      call fmst2m('-.4766014662424932394304427768620618996029637820035802094825720242694315551196576125507', b(31, 24), qx)
      call fmst2m('12.01022233159779338823523851486618412603019426339968151272769528462035002110216728101', b(31, 25), qx)
      call fmst2m('-3.324164491140930831067995527865720183368600929369864071601998386039920635781409865040', b(31, 27), qx)
      call fmst2m('-.8655707771166942543437703438210982818328474012330118593467368132762510892051242759318', b(31, 28), qx)
      call fmst2m('.2542970480762701613840685069971531221418356269767039208462421656164179875269042982442', b(31, 29), qx)
      call fmst2m('-.1099934255807247039194624048650683408451190582958464264636524271459687549994002654752', b(31, 30), qx)
      call fmst2m('-5', b(32, 0), qx)
      call fmdivi_r1(b(32, 0), 6, qx)
      call fmst2m('25', b(32, 1), qx)
      call fmdivi_r1(b(32, 1), 18, qx)
      call fmst2m('-3', b(32, 4), qx)
      call fmdivi_r1(b(32, 4), 4, qx)
      call fmst2m('-.4925295437180263044226820491140213202002146815806577847190740839644346370048749342561', b(32, 6), qx)
      call fmst2m('.4925295437180263044226820491140213202002146815806577847190740839644346370048749342561', b(32, 30), qx)
      call fmst2m('3', b(32, 31), qx)
      call fmdivi_r1(b(32, 31), 4, qx)
      call fmst2m('1', b(33, 0), qx)
      call fmdivi_r1(b(33, 0), 9, qx)
      call fmst2m('-2', b(33, 2), qx)
      call fmdivi_r1(b(33, 2), 9, qx)
      call fmst2m('2', b(33, 32), qx)
      call fmdivi_r1(b(33, 32), 9, qx)
      call fmst2m('.2858351403889715587960888421638364148529275378945964668924322897553490152559792262023', b(34, 0), qx)
      call fmst2m('7', b(34, 1), qx)
      call fmdivi_r1(b(34, 1), 24, qx)
      call fmst2m('7', b(34, 2), qx)
      call fmdivi_r1(b(34, 2), 32, qx)
      call fmst2m('21', b(34, 4), qx)
      call fmdivi_r1(b(34, 4), 128, qx)
      call fmst2m('.2181943549455566583271882415813521070932888243221879411415164327116967439531911272777', b(34, 6), qx)
      call fmst2m('.1803928984786977668636352219467754377196200536418492285624347210514163759703679527180', b(34, 7), qx)
      call fmst2m('.2057138394048450188591207551229295422775700949828089053939914789386228504942804843989', b(34, 9), qx)
      call fmst2m('.2427157915817702399702829279594465157627459713866705419485763522859549196625913978401', b(34, 10), qx)
      call fmst2m('.2464657808136293058336092911818914077992281038693057051370210135284213379790417930740', b(34, 11), qx)
      call fmst2m('-3.449919407908908249798341546016226620603704606149316442883265523381128452524989278943', b(34, 12), qx)
      call fmst2m('.2288755621600360817607290607384585842942203725527402184592948392511281334278617959957', b(34, 13), qx)
      call fmst2m('.2832905997021514153215274190567333359784365954938557898314048426595070708424182066065', b(34, 14), qx)
      call fmst2m('3.210851258377666409601314905442367870055573203322387098512984999880577120008173123283', b(34, 15), qx)
      call fmst2m('-.2235387773648456999202337562141625079641252300836740320899016275445898395177373582441', b(34, 16), qx)
      call fmst2m('-.7071211572044190735187272862074872121300912319552061607910521928571247612111795934106', b(34, 17), qx)
      call fmst2m('3.211233451502870804081747292028565008932600344430223743249588034157195885590228893622', b(34, 18), qx)
      call fmst2m('1.409543483096697660304144743011231757690459455735489863573218752821178310978199657967', b(34, 19), qx)
      call fmst2m('-.1513620534437426131216022767425181110909630262036760559494590353712667648924754181285', b(34, 20), qx)
      call fmst2m('.3723505745270142764547240802146199843971210282021482987373568243836683323798121465643', b(34, 21), qx)
      call fmst2m('.2529787464063613367221999077621412859157757281294143192610824780367182739421617243696', b(34, 22), qx)
      call fmst2m('-3.210851258377666409601314905442367870055573203322387098512984999880577120008173123283', b(34, 23), qx)
      call fmst2m('-.2832905997021514153215274190567333359784365954938557898314048426595070708424182066065', b(34, 24), qx)
      call fmst2m('-.2288755621600360817607290607384585842942203725527402184592948392511281334278617959957', b(34, 25), qx)
      call fmst2m('-.2464657808136293058336092911818914077992281038693057051370210135284213379790417930740', b(34, 26), qx)
      call fmst2m('-.2427157915817702399702829279594465157627459713866705419485763522859549196625913978401', b(34, 27), qx)
      call fmst2m('-.2057138394048450188591207551229295422775700949828089053939914789386228504942804843989', b(34, 28), qx)
      call fmst2m('-.1803928984786977668636352219467754377196200536418492285624347210514163759703679527180', b(34, 29), qx)
      call fmst2m('-.2181943549455566583271882415813521070932888243221879411415164327116967439531911272777', b(34, 30), qx)
      call fmst2m('-21', b(34, 31), qx)
      call fmdivi_r1(b(34, 31), 128, qx)
      call fmst2m('-7', b(34, 32), qx)
      call fmdivi_r1(b(34, 32), 32, qx)
      call fmst2m('-7', b(34, 33), qx)
      call fmdivi_r1(b(34, 33), 24, qx)

      end subroutine fmrk14_coeffs

      subroutine fm_secant(ax, bx, f, nf, root, kprt, ku)
      use fmvals_parallel
      implicit none

!  This routine finds a root of f(x,nf) = 0 using ax and bx as starting points.
!  ax and bx do not have to bracket a root in the sense that f(ax,nf) and f(bx,nf) have opposite
!  signs on input.  This means the search can fail if ax and bx are not close enough to any roots
!  or if the function has no real roots or is badly behaved.

!  When a root is found, fm_secant tries to return full accuracy even in the case of multiple
!  or closely-spaced roots, by raising precision above the user's level.

!  root  is the value returned as the approximate root of the equation.

!  kprt  controls printing within the routine:
!        kprt = 0 for no output
!        kprt = 1 for the approximation to the root and the function
!                 value to be printed once at the end of the routine.
!        kprt = 2 for the approximation to the root and the function
!                 value to be printed each iteration.

!  ku    is the unit number for output.

      type (fm) :: ax, bx, root
      integer :: nf, kprt, ku
      type (multi), external :: f
      intent (in) :: ax, bx, nf, kprt, ku
      intent (inout) :: root

      character (80) :: str
      integer :: j, kl, kwarn_save, maxit, ndsave
      logical :: use_f_over_fp
      type (multi) :: err, err1, f1, f2, f1p, f2p, tol, x1, x1old, x2, x3, mxy(4)
      logical, external :: fmcomp
      type(fm_settings) :: qx

      if (kprt == 2) then
          write (ku,*) ' '
          write (ku,*) ' fm_secant.  Begin trace of all iterations.'
      endif

!             Raise precision slightly.

      ndsave = qx%ndig
      qx%ndig = qx%ndig + qx%ngrd52
      call fmequ(ax%mfm, x1, ndsave, qx%ndig, qx)
      call fmequ(bx%mfm, x2, ndsave, qx%ndig, qx)
      kwarn_save = qx%kwarn
      qx%kwarn = 0

      maxit = 1000
      call fmi2m(1, err, qx)
      call fmulp(err, mxy(1), qx)
      call fmmpyi(mxy(1), 100, tol, qx)
      use_f_over_fp = .false.
      call fmeq(f(x1, nf, qx), f1, qx)
      call fmeq(f(x2, nf, qx), f2, qx)

!             Check for legal function values.

      if (f1%mp(2) == qx%munkno .or. f1%mp(2) == qx%mexpov) then
          do j = 1, 3
             call fmi2m(4-j, mxy(1), qx)
             call fmdivi(mxy(1), 4, mxy(2), qx)
             call fmmpy(mxy(2), x1, x3, qx)
             call fmi2m(4-(4-j), mxy(1), qx)
             call fmdivi(mxy(1), 4, mxy(2), qx)
             call fmmpy(mxy(2), x2, mxy(1), qx)
             call fmadd_r1(x3, mxy(1), qx)
             call fmeq(f(x3, nf, qx), f1, qx)
             if (.not. (f1%mp(2) == qx%munkno .or. f1%mp(2) == qx%mexpov)) then
                 call fmeq(x3, x1, qx)
                 exit
             endif
          enddo
          if (f1%mp(2) == qx%munkno .or. f1%mp(2) == qx%mexpov) then
              do j = 1, 3
                 call fmi2m(4+j, mxy(1), qx)
                 call fmdivi(mxy(1), 4, mxy(2), qx)
                 call fmmpy(mxy(2), x1, x3, qx)
                 call fmi2m(4-(4+j), mxy(1), qx)
                 call fmdivi(mxy(1), 4, mxy(2), qx)
                 call fmmpy(mxy(2), x2, mxy(1), qx)
                 call fmadd_r1(x3, mxy(1), qx)
                 call fmeq(f(x3, nf, qx), f1, qx)
                 if (.not. (f1%mp(2) == qx%munkno .or. f1%mp(2) == qx%mexpov)) then
                     call fmeq(x3, x1, qx)
                     exit
                 endif
                 call fmi2m(4+j, mxy(1), qx)
                 call fmdivi(mxy(1), 4, mxy(2), qx)
                 call fmmpy(mxy(2), x2, x3, qx)
                 call fmi2m(4-(4+j), mxy(1), qx)
                 call fmdivi(mxy(1), 4, mxy(2), qx)
                 call fmmpy(mxy(2), x1, mxy(1), qx)
                 call fmadd_r1(x3, mxy(1), qx)
                 call fmeq(f(x3, nf, qx), f1, qx)
                 if (.not. (f1%mp(2) == qx%munkno .or. f1%mp(2) == qx%mexpov)) then
                     call fmeq(x3, x1, qx)
                     exit
                 endif
              enddo
          endif
      endif

      kl = 1
      do while (kl == 1)
         kl = 0
         if (f1%mp(2) == qx%munkno .or. f1%mp(2) == qx%mexpov) then
             write (ku,*) ' '
             write (ku,*) ' Invalid input for fm_secant.  ',  &
                          'Unknown or overflowed function value for ax ='
             call fmprint(x1, qx)
             write (ku,*) ' '
             j = 0
             call fmunknown(x2, qx)
             call fmunknown(err, qx)
             kl = 2
             exit
         endif

         if (f2%mp(2) == qx%munkno .or. f2%mp(2) == qx%mexpov) then
             do j = 1, 3
                call fmi2m(4-j, mxy(1), qx)
                call fmdivi(mxy(1), 4, mxy(2), qx)
                call fmmpy(mxy(2), x1, x3, qx)
                call fmi2m(4-(4-j), mxy(1), qx)
                call fmdivi(mxy(1), 4, mxy(2), qx)
                call fmmpy(mxy(2), x2, mxy(1), qx)
                call fmadd_r1(x3, mxy(1), qx)
                call fmeq(f(x3, nf, qx), f2, qx)
                if (.not. (f2%mp(2) == qx%munkno .or. f2%mp(2) == qx%mexpov)) then
                    call fmeq(x3, x2, qx)
                    exit
                endif
             enddo
             if (f2%mp(2) == qx%munkno .or. f2%mp(2) == qx%mexpov) then
                 do j = 1, 3
                    call fmi2m(4+j, mxy(1), qx)
                    call fmdivi(mxy(1), 4, mxy(2), qx)
                    call fmmpy(mxy(2), x1, x3, qx)
                    call fmi2m(4-(4+j), mxy(1), qx)
                    call fmdivi(mxy(1), 4, mxy(2), qx)
                    call fmmpy(mxy(2), x2, mxy(1), qx)
                    call fmadd_r1(x3, mxy(1), qx)
                    call fmeq(f(x3, nf, qx), f2, qx)
                    if (.not. (f2%mp(2) == qx%munkno .or. f2%mp(2) == qx%mexpov)) then
                        call fmeq(x3, x2, qx)
                        exit
                    endif
                    call fmi2m(4+j, mxy(1), qx)
                    call fmdivi(mxy(1), 4, mxy(2), qx)
                    call fmmpy(mxy(2), x2, x3, qx)
                    call fmi2m(4-(4+j), mxy(1), qx)
                    call fmdivi(mxy(1), 4, mxy(2), qx)
                    call fmmpy(mxy(2), x1, mxy(1), qx)
                    call fmadd_r1(x3, mxy(1), qx)
                    call fmeq(f(x3, nf, qx), f2, qx)
                 if (.not. (f2%mp(2) == qx%munkno .or. f2%mp(2) == qx%mexpov)) then
                        call fmeq(x3, x2, qx)
                        exit
                    endif
                 enddo
             endif
         endif
         if (f2%mp(2) == qx%munkno .or. f2%mp(2) == qx%mexpov) then
             write (ku,*) ' '
             write (ku,*) ' Invalid input for fm_secant.  ',  &
                          'Unknown or overflowed function value for bx ='
             call fmprint(x2, qx)
             write (ku,*) ' '
             j = 0
             call fmunknown(x2, qx)
             call fmunknown(err, qx)
             kl = 2
             exit
         endif

         if (kprt == 2) then
             call fmform('es20.10', f1, str, qx)
             write (ku, "('  j =', i3, 3x, 'f(ax) = ', a, '    x:')") 0, str(1:25)
             call fmprint(x1, qx)
             call fmform('es20.10', f2, str, qx)
             write (ku, "('  j =', i3, 3x, 'f(bx) = ', a, '    x:')") 0, str(1:25)
             call fmprint(x2, qx)
         endif

!             This loop does the iteration.

         do j = 1, maxit

            call fmsub(f2, f1, mxy(1), qx)
            if (mxy(1)%mp(3) /= 0) then
                call fmsub(x2, x1, mxy(2), qx)
                call fmmpy(f2, mxy(2), mxy(3), qx)
                call fmdiv(mxy(3), mxy(1), mxy(2), qx)
                call fmsub(x2, mxy(2), x3, qx)
            else
                call fmi2m(1, mxy(1), qx)
                call fmadd(x2, mxy(1), x3, qx)
            endif

!             Multiple roots cause very slow convergence and loss of accuracy.
!             If the slope is very small, try to improve convergence and accuracy by using
!             the (slower) function  f(x)/f'(x)  which has no multiple roots.

            call fmeq(x1, x1old, qx)
            call fmsub(f2, f1, mxy(1), qx)
            call fmsub(x2, x1, mxy(2), qx)
            call fmdiv(mxy(1), mxy(2), mxy(3), qx)
            mxy(3)%mp(1) = 1
            call fmst2m('1.0E-2', mxy(1), qx)
            call fmabs(f2, mxy(2), qx)
            call fmst2m('1.0E-4', mxy(4), qx)
            if ((fmcomp(mxy(3), '<', mxy(1), qx) .and. fmcomp(mxy(2), '<', mxy(4), qx)) .or.  &
                use_f_over_fp) then
                use_f_over_fp = .true.
                call fmeq(x2, x1, qx)
                call fmeq(x3, x2, qx)
                call fmeq(f2, f1, qx)
                call fmfprime2(0, x3, f, nf, f1p, qx)
                call fmfprime2(1, x3, f, nf, f2p, qx)
                call fmdiv(f1p, f2p, f2, qx)
            else
                call fmeq(x2, x1, qx)
                call fmeq(x3, x2, qx)
                call fmeq(f2, f1, qx)
                call fmeq(f(x3, nf, qx), f2, qx)
            endif

!             If f2 is one of the FM non-numbers, +-underflow, +-overflow, unknown,
!             then replace it by something representable, so that the next x3 will be
!             closer to x1.  Also swap x1 and x2, making the bad x go away first.

            if (f2%mp(2) == qx%munkno .or. f2%mp(2) == qx%mexpov) then
                call fmmpyi(f1, -2, f2, qx)
                call fmeq(x1, x3, qx)
                call fmeq(x2, x1, qx)
                call fmeq(x3, x2, qx)
                call fmeq(f1, x3, qx)
                call fmeq(f2, f1, qx)
                call fmeq(x3, f2, qx)
            endif

            if (kprt == 2) then
                call fmform('es20.10', f2, str, qx)
                write (ku, "('  j =', i3, 4x, 'f(x) = ' , a, '    x:')") j, str(1:25)
                call fmprint(x2, qx)
            endif

            call fmeq(err, err1, qx)
            if (x2%mp(3) /= 0) then
                call fmsub(x2, x1, mxy(1), qx)
                call fmdiv(mxy(1), x2, err, qx)
                err%mp(1) = 1
            else
                call fmsub(x2, x1, err, qx)
                err%mp(1) = 1
            endif

!             If the error is less than the tolerance, double check to make sure the previous
!             error was small along with the current function value.  Some divergent iterations
!             can get err < tol without being close to a root.

            if (fmcomp(err, '<', tol, qx) .or. f2%mp(3) == 0) then
                call fmsqrt(tol, mxy(1), qx)
                call fmsqrt(mxy(1), mxy(2), qx)
                call fmabs(f2, mxy(3), qx)
                call fmi2m(1, mxy(1), qx)
                call fmulp(mxy(1), mxy(4), qx)
                call fmsqrt_r1(mxy(4), qx)
                if (fmcomp(err1, '>', mxy(2), qx) .and. fmcomp(mxy(3), '>', mxy(4), qx)) then
                    write (ku, "(/' Possible false convergence in fm_secant after', i5, "//  &
                              "' iterations.  ', 'Last two approximations =')") j
                    call fmprint(x1, qx)
                    call fmprint(x2, qx)
                    write (ku, "(/' These agree to the convergence tolerance, but the previous"//  &
                              " iteration was suspiciously far away:')")
                    call fmprint(x1old, qx)
                    write (ku, "(/' and the function value of the last iteration was"//  &
                              " suspiciously far from zero:')")
                    call fmprint(f2, qx)
                endif
                kl = 2
                exit
            endif

         enddo
      enddo

      if (kl == 0) then

!               No convergence after maxit iterations.

          write (ku, "(/' No convergence in fm_secant after', i5, ' iterations.  ', "//  &
                    "'Last two approximations =')") maxit
          call fmprint(x1, qx)
          call fmprint(x2, qx)
          call fmunknown(x2, qx)
          write (ku, "(/' Unknown has been returned.')")
      endif

!             The root was found.

      call fmequ(x2, root%mfm, qx%ndig, ndsave, qx)
      qx%ndig = ndsave
      if (kprt >= 1) then
          call fmulp(x2, err1, qx)
          if (.not.( err1%mp(2) == qx%munkno .or. err1%mp(2) == qx%mexpun )) then
              call fmdiv(err1, x2, mxy(1), qx)
              call fmdivi(mxy(1), 2, err1, qx)
              err1%mp(1) = 1
              if (fmcomp(err, '<', err1, qx)) err = err1
          endif
          call fmform('es16.6', err, str, qx)
          write (ku,*) ' '
          write (ku, "('  fm_secant.   Function ', i3, i7, ' iterations.'/17x"// &
                    "'Estimated relative error =', a, ',    Root:')") nf, j, trim(str)
          call fmprint(root%mfm, qx)
          write (ku,*) ' '
      endif

      qx%kwarn = kwarn_save
      end subroutine fm_secant

      function zm_fprime(n, a, f, nf)     result (return_value)
      use fmvals_parallel
      implicit none
    interface
      function f(xi, ni, qx)
      use fmvals_parallel
      implicit none
      type (multi) :: xi(2)
      integer :: ni
      type (multi), dimension(2) :: f
      type(fm_settings) :: qx
      end function f
    end interface

!  This routine finds the n-th derivative of f(x,nf), evaluated at a.
!  nf is passed on to function f to indicate which function to use in cases where several
!  different functions may be defined there.

!  f must be defined in an interval containing a, so that f can be sampled on both sides of a.

!  n may be zero, so that in cases where f suffers cancellation error at a, an accurate
!  function value is returned.

!  zm_fprime tries to return full accuracy for the derivative, by raising precision above
!  the user's level and using difference formulas.

      type (zm) :: a, return_value
      integer :: n, nf
      intent (in) :: n, a, nf
      type(fm_settings) :: qx

      call zmfprime2(n, a%mzm, f, nf, return_value%mzm, qx)

      return
      end function zm_fprime

      subroutine zmfprime2(n, a, f, nf, return_value, qx)
      use fmvals_parallel
      implicit none
    interface
      function f(xi, ni, qx)
      use fmvals_parallel
      implicit none
      type (multi) :: xi(2)
      integer :: ni
      type (multi), dimension(2) :: f
      type(fm_settings) :: qx
      end function f
    end interface

      type (multi) :: a(2), return_value(2)
      integer :: n, nf
      type(fm_settings) :: qx
      intent (in) :: n, a, nf
      intent (inout) :: return_value, qx

      integer :: j, k, kl, kwarn_save, ndsave
      type (multi), dimension(2) :: d1, d2, f1, f1p, f2, f1m, z1, z1p, z1m, mz1, mz2
      type (multi) :: h, t, tol, tol2, mxy(2)
      logical, external :: fmcomp

!             Raise precision slightly.

      ndsave = qx%ndig
      qx%ndig = qx%ndig + qx%ngrd52
      call zmequ(a, z1, ndsave, qx%ndig, qx)
      kwarn_save = qx%kwarn
      qx%kwarn = 0

      call zmi2m(0, d2, qx)
      call zmeq(f(z1, nf, qx), f1, qx)
      call zmabs(f1, t, qx)
      call fmi2m(0, mxy(1), qx)
      if (fmcomp(t, '/=', mxy(1), qx)) then
          call fmulp(t, tol, qx)
      else
          call fmi2m(1, t, qx)
          call fmulp(t, tol, qx)
      endif

!             Check for a legal function value.


      kl = 1
      do while (kl == 1)
         kl = 0
         call zmabs(f1, t, qx)
         if (t%mp(2) == qx%munkno .or. t%mp(2) == qx%mexpov .or. t%mp(2) == qx%mexpun .or.  &
             n < 0) then
             call zmunknown(d2, qx)
             exit
         endif
         call zmeq(f1, f2, qx)

!             Loop at increasing precision until the difference formula is accurate.

         do j = 1, 100

            qx%ndig = 2*qx%ndig

!             Define the variables used below at the new higher precision.

            call zmequ(d2, d1, qx%ndig/2, qx%ndig, qx)
            call zmequ(f2, f1, qx%ndig/2, qx%ndig, qx)
            call fmequ(tol, tol2, ndsave, qx%ndig, qx)
            call zmequ(a, z1, ndsave, qx%ndig, qx)

!             Special case for n = 0.

            if (n == 0) then
                call zmeq(f(z1, nf, qx), f2, qx)
                call zmeq(f2, d2, qx)
                call zmsub(f2, f1, mz1, qx)
                call zmabs(mz1, mxy(1), qx)
                if (fmcomp(mxy(1), '<', tol2, qx)) exit
                cycle
            endif
            call zmeq(f1, f2, qx)

!             Special case for n = 1.

            if (n == 1) then
                call zmabs(z1, mxy(1), qx)
                call fmi2m(0, mxy(2), qx)
                if (fmcomp(mxy(1), '/=', mxy(2), qx)) then
                    call fmulp(mxy(1), h, qx)
                else
                    call fmi2m(1, mxy(1), qx)
                    call fmulp(mxy(1), h, qx)
                endif
                call fmabs(h, mxy(1), qx)
                call fmsqrt(mxy(1), h, qx)
                call fmadd(z1(1), h, z1p(1), qx)
                call fmeq(z1(2), z1p(2), qx)
                call zmeq(f(z1p, nf, qx), f1p, qx)
                call fmsub(z1(1), h, z1m(1), qx)
                call fmeq(z1(2), z1m(2), qx)
                call zmeq(f(z1m, nf, qx), f1m, qx)
                call zmsub(f1p, f1m, mz1, qx)
                call zmi2m(0, mz2, qx)
                call fmmpyi(h, 2, mz2(1), qx)
                call zmdiv(mz1, mz2, d2, qx)
                call zmsub(d2, d1, mz1, qx)
                call zmabs(mz1, mxy(1), qx)
                if (fmcomp(mxy(1), '<', tol2, qx) .and. j > 1) exit
                cycle
            endif

!             General case for even n > 1.

            if (mod(n, 2) == 0) then
                call zmabs(z1, mxy(1), qx)
                call fmi2m(0, mxy(2), qx)
                if (fmcomp(mxy(1), '/=', mxy(2), qx)) then
                    call fmulp(mxy(1), h, qx)
                else
                    call fmi2m(1, mxy(1), qx)
                    call fmulp(mxy(1), h, qx)
                endif
                call fmi2m(1, mxy(1), qx)
                call fmdivi_r1(mxy(1), n+2, qx)
                call fmabs(h, mxy(2), qx)
                call fmpwr(mxy(2), mxy(1), h, qx)
                call zmeq(f(z1, nf, qx), f1, qx)
                call fmcmbi(n, n/2, mxy(1), qx)
                call fmmpyi_r1(mxy(1),(-1)**(n/2), qx)
                call fmi2m(0, mxy(2), qx)
                call zmcmpx(mxy(1), mxy(2), mz1, qx)
                call zmmpy(mz1, f1, d2, qx)
                do k = 0, n/2-1
                   call fmmpyi(h, n/2-k, mxy(1), qx)
                   call fmadd(z1(1), mxy(1), z1p(1), qx)
                   call fmeq(z1(2), z1p(2), qx)
                   call zmeq(f(z1p, nf, qx), f1p, qx)
                   call fmsub(z1(1), mxy(1), z1m(1), qx)
                   call fmeq(z1(2), z1m(2), qx)
                   call zmeq(f(z1m, nf, qx), f1m, qx)
                   call fmcmbi(n, k, mxy(1), qx)
                   call fmmpyi_r1(mxy(1),(-1)**k, qx)
                   call zmadd(f1p, f1m, mz1, qx)
                   call fmmpy_r2(mxy(1), mz1(1), qx)
                   call fmmpy_r2(mxy(1), mz1(2), qx)
                   call zmadd_r1(d2, mz1, qx)
                enddo
                call fmipwr(h, n, mxy(1), qx)
                call fmdiv_r1(d2(1), mxy(1), qx)
                call fmdiv_r1(d2(2), mxy(1), qx)
                call zmsub(d2, d1, mz1, qx)
                call zmabs(mz1, mxy(1), qx)
                if (fmcomp(mxy(1), '<', tol2, qx) .and. j > 1) exit
                cycle
            endif

!             General case for odd n > 1.

            if (mod(n, 2) == 1) then
                call zmabs(z1, mxy(1), qx)
                call fmi2m(0, mxy(2), qx)
                if (fmcomp(mxy(1), '/=', mxy(2), qx)) then
                    call fmulp(mxy(1), h, qx)
                else
                    call fmi2m(1, mxy(1), qx)
                    call fmulp(mxy(1), h, qx)
                endif
                call fmi2m(1, mxy(1), qx)
                call fmdivi_r1(mxy(1), n+2, qx)
                call fmabs(h, mxy(2), qx)
                call fmpwr(mxy(2), mxy(1), h, qx)
                call zmi2m(0, d2, qx)
                do k = 0, n/2
                   call fmmpyi(h, n/2-k+1, mxy(1), qx)
                   call fmadd(z1(1), mxy(1), z1p(1), qx)
                   call fmeq(z1(2), z1p(2), qx)
                   call zmeq(f(z1p, nf, qx), f1p, qx)
                   call fmsub(z1(1), mxy(1), z1m(1), qx)
                   call fmeq(z1(2), z1m(2), qx)
                   call zmeq(f(z1m, nf, qx), f1m, qx)
                   call fmcmbi(n-1, k, mxy(1), qx)
                   call fmmpyi_r1(mxy(1),(-1)**k, qx)
                   call zmsub(f1p, f1m, mz1, qx)
                   call fmmpy_r2(mxy(1), mz1(1), qx)
                   call fmmpy_r2(mxy(1), mz1(2), qx)
                   call zmmpyi_r1(mz1, n*(n+1-2*k), qx)
                   call zmdivi_r1(mz1,(n-k)*(n+1-k), qx)
                   call zmadd_r1(d2, mz1, qx)
                enddo
                call fmipwr(h, n, mxy(1), qx)
                call fmmpyi_r1(mxy(1), 2, qx)
                call fmdiv_r1(d2(1), mxy(1), qx)
                call fmdiv_r1(d2(2), mxy(1), qx)
                call zmsub(d2, d1, mz1, qx)
                call zmabs(mz1, mxy(1), qx)
                if (fmcomp(mxy(1), '<', tol2, qx) .and. j > 1) exit
                cycle
            endif

         enddo
      enddo

!             Round and return.

      call zmequ(d2, return_value, qx%ndig, ndsave, qx)
      qx%ndig = ndsave
      qx%kwarn = kwarn_save
      end subroutine zmfprime2

      subroutine zm_inverse(a, n, b, det)
      use fmvals_parallel
      implicit none

!  Return b as the inverse of the n x n matrix a, and det as the determinant of a.

!  a and b are type (zm) (complex) multiprecision arrays.

      integer :: n
      type (zm) :: a(n, n), b(n, n), det
      intent (in) :: a, n
      intent (inout) :: b, det

      type (multi) :: tol, mxy(3)
      type (zm), allocatable :: a1(:,:), a2(:,:), b1(:), r1(:), x1(:)
      integer, allocatable :: kswap(:)
      integer :: i, j, k, kl, kwarn_save, ndsave
      logical, external :: fmcomp
      type(fm_settings) :: qx

      call fmi2m(1, mxy(1), qx)
      call fmulp(mxy(1), mxy(2), qx)
      mxy(2)%mp(2) = mxy(2)%mp(2) - 1
      call fmst2m('1.0e10', mxy(3), qx)
      call fmdiv(mxy(2), mxy(3), tol, qx)

      allocate(a1(n, n), a2(n, n), b1(n), r1(n), x1(n), kswap(n), stat=j)
      if (j /= 0) then
          write (*, "(/' Error in zm_inverse.  Unable to allocate arrays with n = ', i8/)") n
          stop
      endif

!             Raise precision.

      ndsave = qx%ndig
      qx%ndig = 2*qx%ndig
      kwarn_save = qx%kwarn
      qx%kwarn = 0

!             Copy a to a1 with higher precision.

      kl = 1
      do while (kl == 1)
         kl = 0
         call fmequ_r1(tol, ndsave, qx%ndig, qx)
         do i = 1, n
            do j = 1, n
               call zmequ(a(i, j)%mzm, a1(i, j)%mzm, ndsave, qx%ndig, qx)
               call zmeq(a1(i, j)%mzm, a2(i, j)%mzm, qx)
            enddo
         enddo

!             Factor a into l*u form.

         call zmfactor_lu2(a1, n, det, kswap, qx)
         if ( (det%mzm(1)%mp(3) == 0 .and. det%mzm(2)%mp(3) == 0) .or.  &
              (det%mzm(1)%mp(2) == qx%munkno .or. det%mzm(2)%mp(2) == qx%munkno) ) then
             if (qx%kwarn > 0) then
                 write (*, "(/' Error in zm_inverse.  The matrix is singular.'/)")
             endif
             if (qx%kwarn >= 2) stop
             do i = 1, n
                do j = 1, n
                   call zmunknown(b(i, j)%mzm, qx)
                enddo
             enddo
             exit
         endif

!             Solve for the inverse matrix one column at a time.

         do k = 1, n
            do i = 1, n
               call zmi2m(0, b1(i)%mzm, qx)
            enddo
            call zmi2m(1, b1(k)%mzm, qx)

            call zmsolve_lu2(a1, n, b1, x1, kswap, qx)

!             Do an iterative refinement.

            call zmmatmul21(n, a2, x1, r1, qx)
            do i = 1, n
               call zmsub_r1(r1(i)%mzm, b1(i)%mzm, qx)
            enddo

            call zmsolve_lu2(a1, n, r1, b1, kswap, qx)
            do i = 1, n
               call zmsub_r1(x1(i)%mzm, b1(i)%mzm, qx)
            enddo

!             Check for accuracy at the user's precision.

            call zmnorm2(b1, n, mxy(2), qx)
            if (fmcomp(mxy(2), '>', tol, qx)) then
                qx%ndig = 2*qx%ndig
                kl = 1
                exit
            endif

!             Round the result and store column k in the b matrix.

            do i = 1, n
               call zmequ(x1(i)%mzm, b(i, k)%mzm, qx%ndig, ndsave, qx)
            enddo
         enddo
      enddo

      call zmequ_r1(det%mzm, qx%ndig, ndsave, qx)

      deallocate(a1, a2, b1, r1, x1, kswap)

      qx%ndig = ndsave
      qx%kwarn = kwarn_save
      end subroutine zm_inverse

      subroutine zmmatmul21(n, ma, mb, mc, qx)
      use fmvals_parallel
      implicit none
      integer :: n
      type (zm) :: ma(n, n), mb(n), mc(n)
      type(fm_settings) :: qx
      intent (in) :: n, ma, mb
      intent (inout) :: mc, qx

      integer :: j, k, mxsave, nd2, ndsave
      type(zm) :: mtlvzm, mulvzm, mvlvzm, mtlv01

      ndsave = qx%ndig
      j = max(qx%ngrd52, 2)
      nd2 = max(2*qx%ndig+j, 2)
      qx%ndig = nd2
      mxsave = qx%mxexp
      do j = 1, n
         qx%mxexp = qx%mxexp2
         call zmi2m(0, mtlvzm%mzm, qx)
         do k = 1, n
            call zmequ(ma(j, k)%mzm, mulvzm%mzm, ndsave, qx%ndig, qx)
            call zmequ(mb(k)%mzm, mvlvzm%mzm, ndsave, qx%ndig, qx)
            call zmmpy(mulvzm%mzm, mvlvzm%mzm, mtlv01%mzm, qx)
            call zmadd_r1(mtlvzm%mzm, mtlv01%mzm, qx)
         enddo
         qx%mxexp = mxsave
         call zmequ(mtlvzm%mzm, mc(j)%mzm, qx%ndig, ndsave, qx)
      enddo
      qx%ndig = ndsave
      end subroutine zmmatmul21

      subroutine zmnorm2(ma, n, mc, qx)
      use fmvals_parallel
      implicit none
      integer :: n
      type (zm) :: ma(n)
      type(multi) :: mc
      type(fm_settings) :: qx
      intent (in) :: ma, n
      intent (inout) :: mc, qx

      integer :: j, mxsave, nd2, ndsave
      type(multi) :: mulvfm, mvlvfm, m3lvfm

      ndsave = qx%ndig
      j = max(qx%ngrd52, 2)
      nd2 = max(qx%ndig+j, 2)
      qx%ndig = nd2
      mxsave = qx%mxexp
      qx%mxexp = qx%mxexp2
      call fmi2m(0, m3lvfm, qx)
      do j = 1, n
         call fmequ(ma(j)%mzm(1), mulvfm, ndsave, qx%ndig, qx)
         call fmsqr(mulvfm, mvlvfm, qx)
         call fmadd_r1(m3lvfm, mvlvfm, qx)
         call fmequ(ma(j)%mzm(2), mulvfm, ndsave, qx%ndig, qx)
         call fmsqr(mulvfm, mvlvfm, qx)
         call fmadd_r1(m3lvfm, mvlvfm, qx)
      enddo
      call fmsqrt_r1(m3lvfm, qx)
      qx%mxexp = mxsave
      call fmequ(m3lvfm, mc, qx%ndig, ndsave, qx)
      qx%ndig = ndsave
      end subroutine zmnorm2

      subroutine zm_lin_solve(a, x, b, n, det)
      use fmvals_parallel
      implicit none

!  Gauss elimination to solve the linear system  a x = b, where:

!  a   is the matrix of the system, containing the  n x n coefficient matrix.

!  b   is the  n x 1  right-hand-side vector.

!  x   is the returned  n x 1  solution vector.

!  det is returned as the determinant of a.
!      Nonzero det means a solution was found.
!      det = 0 is returned if the system is singular.

!  a,x,b,det are all type (zm) complex multiprecision variables.

      integer :: n
      type (zm) :: a(n, n), b(n), x(n), det
      intent (in) :: a, b, n
      intent (inout) :: x, det

      type (multi) :: tol, mxy(3)
      type (zm), allocatable :: a1(:,:), a2(:,:), b1(:), r1(:), x1(:)
      type (zm) :: det1
      integer, allocatable :: kswap(:)
      integer :: i, j, kl, ndsave
      logical, external :: fmcomp
      type(fm_settings) :: qx

      allocate(a1(n, n), a2(n, n), b1(n), r1(n), x1(n), kswap(n), stat=j)
      if (j /= 0) then
          write (*, "(/' Error in zm_lin_solve.  Unable to allocate arrays with n = ', i8/)") n
          stop
      endif

      call fmi2m(1, mxy(1), qx)
      call fmulp(mxy(1), mxy(2), qx)
      mxy(2)%mp(2) = mxy(2)%mp(2) - 1
      call fmst2m('1.0e10', mxy(3), qx)
      call fmdiv(mxy(2), mxy(3), tol, qx)

      ndsave = qx%ndig
      qx%ndig = 2*qx%ndig

!             Copy a and b to a1 and b1 with higher precision.

      kl = 1
      do while (kl == 1)
         kl = 0
         call fmequ_r1(tol, ndsave, qx%ndig, qx)
         do i = 1, n
            do j = 1, n
               call zmequ(a(i, j)%mzm, a1(i, j)%mzm, ndsave, qx%ndig, qx)
               call zmeq(a1(i, j)%mzm, a2(i, j)%mzm, qx)
            enddo
            call zmequ(b(i)%mzm, b1(i)%mzm, ndsave, qx%ndig, qx)
         enddo

!             Solve the system.

         call zmfactor_lu2(a1, n, det1, kswap, qx)
         if ( (det1%mzm(1)%mp(3) == 0 .and. det1%mzm(2)%mp(3) == 0) .or.  &
              (det1%mzm(1)%mp(2) == qx%munkno .or. det1%mzm(2)%mp(2) == qx%munkno) ) then
             if (qx%kwarn > 0) then
                 write (qx%kw, "(/' Error in zm_lin_solve.  The matrix is singular.'/)")
             endif
             if (qx%kwarn >= 2) stop
             do i = 1, n
                call zmunknown(x1(i)%mzm, qx)
             enddo
             exit
         endif

         call zmsolve_lu2(a1, n, b1, x1, kswap, qx)

!             Do an iterative refinement.

         call zmmatmul21(n, a2, x1, r1, qx)
         do i = 1, n
            call zmsub_r1(r1(i)%mzm, b1(i)%mzm, qx)
         enddo

         call zmsolve_lu2(a1, n, r1, b1, kswap, qx)
         do i = 1, n
            call zmsub_r1(x1(i)%mzm, b1(i)%mzm, qx)
         enddo

!             Check for accuracy at the user's precision.

         call zmnorm2(b1, n, mxy(2), qx)
         if (fmcomp(mxy(2), '>', tol, qx)) then
             qx%ndig = 2*qx%ndig
             kl = 1
         endif
      enddo

!             Round and return x and det.

      do i = 1, n
         call zmequ(x1(i)%mzm, x(i)%mzm, qx%ndig, ndsave, qx)
      enddo
      call zmequ(det1%mzm, det%mzm, qx%ndig, ndsave, qx)

      qx%ndig = ndsave

      deallocate(a1, a2, b1, r1, x1, kswap)

      end subroutine zm_lin_solve

      subroutine zm_factor_lu(a, n, det, kswap)
      use fmvals_parallel
      implicit none

!  Gauss elimination to factor the n x n matrix a (lu decomposition).

!  The time is proportional to  n**3.

!  Once this factorization has been done, a linear system  a x = b
!  with the same coefficient matrix a and n x 1 vector b can be solved
!  for x using routine zm_solve_lu in time proportional to  n**2.

!  det is returned as the determinant of a.
!      Nonzero det means there is a unique solution.
!      det = 0 is returned if the system is singular.

!  kswap is a list of row interchanges made by the partial pivoting strategy during the
!        elimination phase.

!  After returning, the values in matrix a have been replaced by the multipliers
!  used during elimination.  This is equivalent to factoring the a matrix into
!  a lower triangular matrix l times an upper triangular matrix u.

      integer :: n, kswap(n)
      type (zm) :: a(n, n), det
      intent (in) :: n
      intent (inout) :: a, det, kswap

      type(fm_settings) :: qx

      call zmfactor_lu2(a, n, det, kswap, qx)

      return
      end subroutine zm_factor_lu

      subroutine zmfactor_lu2(a, n, det, kswap, qx)
      use fmvals_parallel
      implicit none

      integer :: n, kswap(n)
      type (zm) :: a(n, n), det
      type(fm_settings) :: qx
      intent (in) :: n
      intent (inout) :: a, det, kswap, qx

      integer :: jcol, jdiag, jmax, jrow
      type (zm) :: amult, temp
      type (fm) :: amax, t
      logical, external :: fmcomp

      call zmi2m(1, det%mzm, qx)
      kswap(1:n) = 1
      if (n <= 0) then
          call zmi2m(0, det%mzm, qx)
          return
      endif
      if (n == 1) then
          kswap(1) = 1
          call zmeq(a(1, 1)%mzm, det%mzm, qx)
          return
      endif

!             Do the elimination phase.
!             jdiag is the current diagonal element below which the elimination proceeds.

      do jdiag = 1, n-1

!             Pivot to put the element with the largest absolute value on the diagonal.

         call zmabs(a(jdiag, jdiag)%mzm, amax%mfm, qx)
         jmax = jdiag
         do jrow = jdiag+1, n
            call zmabs(a(jrow, jdiag)%mzm, t%mfm, qx)
            if (fmcomp(t%mfm, '>', amax%mfm, qx)) then
                call fmeq(t%mfm, amax%mfm, qx)
                jmax = jrow
            endif
         enddo

!             If amax is zero here then the system is singular.

         if (amax%mfm%mp(3) == 0) then
             call zmi2m(0, det%mzm, qx)
             return
         endif

!             Swap rows jdiag and jmax unless they are the same row.

         kswap(jdiag) = jmax
         if (jmax /= jdiag) then
             call zmnegate(det%mzm, qx)
             do jcol = jdiag, n
                call zmeq(a(jdiag, jcol)%mzm, temp%mzm, qx)
                call zmeq(a(jmax, jcol)%mzm, a(jdiag, jcol)%mzm, qx)
                call zmeq(temp%mzm, a(jmax, jcol)%mzm, qx)
             enddo
         endif
         call zmmpy_r1(det%mzm, a(jdiag, jdiag)%mzm, qx)

!             For jrow = jdiag+1, ..., n, eliminate a(jrow,jdiag) by replacing row jrow by
!                 row jrow - a(jrow,jdiag) * row jdiag / a(jdiag,jdiag)

         call fmi2m(0, t%mfm, qx)
         do jrow = jdiag+1, n
            if (fmcomp(a(jrow, jdiag)%mzm(1), '==', t%mfm, qx) .and.  &
                fmcomp(a(jrow, jdiag)%mzm(2), '==', t%mfm, qx)) cycle
            call zmdiv(a(jrow, jdiag)%mzm, a(jdiag, jdiag)%mzm, amult%mzm, qx)

!             Save the multiplier for use later by zm_solve_lu.

            call zmeq(amult%mzm, a(jrow, jdiag)%mzm, qx)
            do jcol = jdiag+1, n
               call zmmpy(amult%mzm, a(jdiag, jcol)%mzm, temp%mzm, qx)
               call zmsub_r1(a(jrow, jcol)%mzm, temp%mzm, qx)
            enddo
         enddo
      enddo
      call zmmpy_r1(det%mzm, a(n, n)%mzm, qx)

      end subroutine zmfactor_lu2

      subroutine zm_solve_lu(a, n, b, x, kswap)
      use fmvals_parallel
      implicit none

!  Solve a linear system  a x = b.
!  a is the n x n coefficient matrix, after having been factored by zm_factor_lu.
!  b is the n x 1 right-hand-side vector.
!  x is returned with the solution of the linear system.
!  kswap is a list of row interchanges made by the partial pivoting strategy during the
!        elimination phase in zm_factor_lu.
!  Time for this call is proportional to  n**2.

      integer :: n, kswap(n)
      type (zm) :: a(n, n), b(n), x(n)
      intent (in) :: a, n, b, kswap
      intent (inout) :: x

      type(fm_settings) :: qx

      call zmsolve_lu2(a, n, b, x, kswap, qx)

      return
      end subroutine zm_solve_lu

      subroutine zmsolve_lu2(a, n, b, x, kswap, qx)
      use fmvals_parallel
      implicit none

      integer :: n, kswap(n)
      type (zm) :: a(n, n), b(n), x(n)
      type(fm_settings) :: qx
      intent (in) :: a, n, b, kswap
      intent (inout) :: x, qx

      integer :: j, jdiag, jmax
      type (zm) :: temp

      if (n <= 0) then
          return
      endif
      if (n == 1) then
          call zmdiv(b(1)%mzm, a(1, 1)%mzm, x(1)%mzm, qx)
          return
      endif
      do j = 1, n
         call zmeq(b(j)%mzm, x(j)%mzm, qx)
      enddo

!             Do the elimination phase operations only on x.
!             jdiag is the current diagonal element below which the elimination proceeds.

      do jdiag = 1, n-1

!             Pivot to put the element with the largest absolute value on the diagonal.

         jmax = kswap(jdiag)

!             Swap rows jdiag and jmax unless they are the same row.

         if (jmax /= jdiag) then
             call zmeq(x(jdiag)%mzm, temp%mzm, qx)
             call zmeq(x(jmax)%mzm, x(jdiag)%mzm, qx)
             call zmeq(temp%mzm, x(jmax)%mzm, qx)
         endif

!             For jrow = jdiag+1, ..., n, eliminate a(jrow,jdiag) by replacing row jrow by
!                 row jrow - a(jrow,jdiag) * row jdiag / a(jdiag,jdiag)
!             After factoring, a(jrow,jdiag) is the original a(jrow,jdiag) / a(jdiag,jdiag).

         do j = jdiag+1, n
            call zmmpy(a(j, jdiag)%mzm, x(jdiag)%mzm, temp%mzm, qx)
            call zmsub_r1(x(j)%mzm, temp%mzm, qx)
         enddo
      enddo

!             Do the back substitution.

      do jdiag = n, 1, -1

!             Divide row jdiag by the diagonal element.

         call zmdiv_r1(x(jdiag)%mzm, a(jdiag, jdiag)%mzm, qx)

!             Zero above the diagonal in column jdiag by replacing row jrow by
!                 row jrow - a(jrow,jdiag) * row jdiag
!             For jrow = 1, ..., jdiag-1.

         if (jdiag == 1) exit
         do j = 1, jdiag-1
            call zmmpy(a(j, jdiag)%mzm, x(jdiag)%mzm, temp%mzm, qx)
            call zmsub_r1(x(j)%mzm, temp%mzm, qx)
         enddo
      enddo

      end subroutine zmsolve_lu2

      subroutine zm_roots(nr, f, nf, n_found, list_of_roots, kprt, ku)
      use fmvals_parallel
      implicit none

!  This routine searches for nr roots of f(x,nf) = 0.
!  nf is the function number in case roots to several functions are needed.

!  n_found is returned as the number of roots found.
!  list_of_roots is an array returned with the roots found.  They are complex type (zm) numbers,
!                even when the actual root is real.

!  kprt  controls printing within the routine:
!        kprt = 0 for no output
!        kprt = 1 for the approximation to each root to be printed as they are found.

!  ku    is the unit number for output.

!  The search for roots begins with fairly small magnitude complex values, so small roots are
!  often found before larger roots, but there is no guarantee of this, and the order in which
!  the roots are found is fairly random.  The user can sort list_of_roots and print them after
!  all have been found.

!  The secant method often fails to converge to any root for a given pair of starting points.
!  This routine may call zm_root1 many more than nr times before nr roots are found.  It can
!  also happen that zm_roots eventually gives up and returns n_found < nr roots.

!  The user's function f is divided by the product of (x - list_of_roots(j)) over the roots that
!  have been found so far.  This tries keep the zm_root1 routine from returning to a root that is
!  already on the list (unless it is a root of multiplicity m > 1).

    interface
      function f(xi, ni, qx)
      use fmvals_parallel
      implicit none
      type (multi) :: xi(2)
      integer :: ni
      type (multi), dimension(2) :: f
      type(fm_settings) :: qx
      end function f
    end interface

      integer :: nr, nf, n_found, kprt, ku
      type (zm) :: list_of_roots(nr)
      intent (in) :: nr, nf, kprt, ku
      intent (inout) :: n_found, list_of_roots

      integer :: j, kwarn_save, ndig_of_roots, ndsave
      double precision :: value
      logical :: remove_previous_roots, retry
      type (multi) :: ax(2), bx(2), x1(2), mxy(4), mz1(2), mz2(2)
      logical, external :: fmcomp
      type(fm_settings) :: qx


!             Raise precision slightly.

      ndsave = qx%ndig
      qx%ndig = qx%ndig + qx%ngrd52
      kwarn_save = qx%kwarn
      qx%kwarn = 0
      retry = .false.

      n_found = 0
      do j = 1, nr
         call zmunknown(list_of_roots(j)%mzm, qx)
      enddo
      ndig_of_roots = qx%ndig

      do j = 1, 10*nr
         if (retry) then
             value = (mod(277*j, 1001) + 1) / 1002.0d0
             if (mod(j, 4) == 0) then
                 call zmst2m(' 1.1 + 1.2 i ', mz1, qx)
                 call fmdp2m((2+j)*value+1, mxy(1), qx)
                 call fmi2m(0, mxy(2), qx)
                 call zmcmpx(mxy(1), mxy(2), mz2, qx)
                 call zmmpy(mz1, mz2, ax, qx)
             else if (mod(j, 4) == 1) then
                 call zmst2m(' 1.1 - 0.8 i ', mz1, qx)
                 call fmdp2m((2+j)*value+1, mxy(1), qx)
                 call fmi2m(0, mxy(2), qx)
                 call zmcmpx(mxy(1), mxy(2), mz2, qx)
                 call zmmpy(mz1, mz2, ax, qx)
             else if (mod(j, 4) == 2) then
                 call zmst2m(' -0.8 - 1.2 i ', mz1, qx)
                 call fmdp2m((2+j)*value+1, mxy(1), qx)
                 call fmi2m(0, mxy(2), qx)
                 call zmcmpx(mxy(1), mxy(2), mz2, qx)
                 call zmmpy(mz1, mz2, ax, qx)
             else if (mod(j, 4) == 3) then
                 call zmst2m(' -1.1 + 0.8 i ', mz1, qx)
                 call fmdp2m((2+j)*value+1, mxy(1), qx)
                 call fmi2m(0, mxy(2), qx)
                 call zmcmpx(mxy(1), mxy(2), mz2, qx)
                 call zmmpy(mz1, mz2, ax, qx)
             endif
             call zmst2m(' 0.87 + 0.5 i ', mz1, qx)
             call zmmpy(mz1, ax, bx, qx)
         else
             call zmst2m(' 1.1 + 1.2 i ', ax, qx)
             call zmst2m(' 3.4 + 4.5 i ', bx, qx)
         endif
         remove_previous_roots = .true.
         call zm_root1(ax, bx, nr, f, nf, remove_previous_roots, n_found, list_of_roots,  &
                       ndig_of_roots, x1, -1, ku, qx)
         call zmabs(x1, mxy(1), qx)
         if (.not. (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov)) then
             n_found = n_found + 1
             call zmeq(x1, list_of_roots(n_found)%mzm, qx)

!             Some roots, primarily multiple roots, may have lost some accuracy due to the
!             divisions by previously found roots.  Refine them using f without dividing.

             call fmdp2m(1+1.0d-10, mxy(1), qx)
             call fmi2m(0, mxy(2), qx)
             call zmcmpx(mxy(1), mxy(2), mz2, qx)
             call zmmpy(list_of_roots(n_found)%mzm, mz2, ax, qx)
             call fmdp2m(1+1.0d-15, mxy(1), qx)
             call fmi2m(0, mxy(2), qx)
             call zmcmpx(mxy(1), mxy(2), mz2, qx)
             call zmmpy(list_of_roots(n_found)%mzm, mz2, bx, qx)
             remove_previous_roots = .false.
             call zm_root1(ax, bx, nr, f, nf, remove_previous_roots, n_found, list_of_roots,  &
                           ndig_of_roots, x1, -1, ku, qx)
             call fmabs(x1(1), mxy(1), qx)
             call fmi2m(1, mxy(3), qx)
             call fmulp(mxy(3), mxy(2), qx)
             call zmabs(x1, mxy(4), qx)
             call fmmpy_r1(mxy(2), mxy(4), qx)
             if (fmcomp(mxy(1), '<', mxy(2), qx)) then
                 call fmi2m(0, x1(1), qx)
             endif
             call fmabs(x1(2), mxy(1), qx)
             call fmi2m(1, mxy(3), qx)
             call fmulp(mxy(3), mxy(2), qx)
             call zmabs(x1, mxy(4), qx)
             call fmmpy_r1(mxy(2), mxy(4), qx)
             if (fmcomp(mxy(1), '<', mxy(2), qx)) then
                 call fmi2m(0, x1(2), qx)
             endif
             call zmeq(x1, list_of_roots(n_found)%mzm, qx)

             if (kprt > 0) then
                 write (*, "(a, i9, a, i6, a)") ' zm_roots.  Function ', nf, ' Root ', n_found, ' ='
                 call zmprint(x1, qx)
             endif
             if (n_found == nr) exit

!             Check to see if the conjugate of this root is also a root.

             call fmabs(x1(2), mxy(1), qx)
             call fmi2m(1, mxy(3), qx)
             call fmulp(mxy(3), mxy(2), qx)
             call fmmpyi_r1(mxy(2), 100, qx)
             if (fmcomp(mxy(1), '<', mxy(2), qx)) cycle
             call fmmpyi_r1(ax(2), -1, qx)
             call fmmpyi_r1(bx(2), -1, qx)
             remove_previous_roots = .true.
             call zm_root1(ax, bx, nr, f, nf, remove_previous_roots, n_found, list_of_roots,  &
                           ndig_of_roots, x1, -1, ku, qx)
             call zmabs(x1, mxy(1), qx)
             if (.not. (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov)) then
                 n_found = n_found + 1
                 call zmeq(x1, list_of_roots(n_found)%mzm, qx)
                 call fmdp2m(1+1.0d-10, mxy(1), qx)
                 call fmi2m(0, mxy(2), qx)
                 call zmcmpx(mxy(1), mxy(2), mz2, qx)
                 call zmmpy(list_of_roots(n_found)%mzm, mz2, ax, qx)
                 call fmdp2m(1+1.0d-15, mxy(1), qx)
                 call fmi2m(0, mxy(2), qx)
                 call zmcmpx(mxy(1), mxy(2), mz2, qx)
                 call zmmpy(list_of_roots(n_found)%mzm, mz2, bx, qx)
                 remove_previous_roots = .false.
                 call zm_root1(ax, bx, nr, f, nf, remove_previous_roots, n_found, list_of_roots,  &
                               ndig_of_roots, x1, -1, ku, qx)
                 call fmabs(x1(1), mxy(1), qx)
                 call fmi2m(1, mxy(3), qx)
                 call fmulp(mxy(3), mxy(2), qx)
                 call zmabs(x1, mxy(4), qx)
                 call fmmpy_r1(mxy(2), mxy(4), qx)
                 if (fmcomp(mxy(1), '<', mxy(2), qx)) then
                     call fmi2m(0, x1(1), qx)
                 endif
                 call fmabs(x1(2), mxy(1), qx)
                 call fmi2m(1, mxy(3), qx)
                 call fmulp(mxy(3), mxy(2), qx)
                 call zmabs(x1, mxy(4), qx)
                 call fmmpy_r1(mxy(2), mxy(4), qx)
                 if (fmcomp(mxy(1), '<', mxy(2), qx)) then
                     call fmi2m(0, x1(2), qx)
                 endif
                 call zmeq(x1, list_of_roots(n_found)%mzm, qx)
                 if (kprt > 0) then
                     write (*, "(a, i9, a, i6, a)") ' zm_roots.  Function ', nf, ' Root ',  &
                                                   n_found, ' ='
                     call zmprint(x1, qx)
                 endif
                 if (n_found == nr) exit
             endif
             retry = .false.
         else
             retry = .true.
         endif
      enddo

!             Round the roots to the user's precision.

      do j = 1, n_found
         call zmeq(list_of_roots(j)%mzm, x1, qx)
         call zmequ(x1, list_of_roots(j)%mzm, qx%ndig, ndsave, qx)
      enddo

      qx%ndig = ndsave
      qx%kwarn = kwarn_save
      end subroutine zm_roots

      subroutine zm_root1(ax, bx, nr, f, nf, remove_previous_roots, n_found, list_of_roots,  &
                          ndig_of_roots, root, kprt, ku, qx)
      use fmvals_parallel
      implicit none

!  This is a special version of zm_secant, modified to work with zm_roots so that some calls
!  will use f and others will use f divided by all the (x - r) terms of the roots found so far.

!  remove_previous_roots is a logical input variable telling this routine whether or not to
!  divide f by the product of (x - list_of_roots(j)) over the roots that have been found so far.
!  This tries keep the zm_root1 routine from returning to a root that is already on the list
!  (unless it is a root of multiplicity m > 1).

!  This routine searches for a root of f(x,nf) = 0 using ax and bx as starting points.
!  ax and bx are complex, and the search can fail if ax and bx are not close enough to any roots
!  or if the function is badly behaved.

!  When a root is found, zm_root1 tries to return full accuracy even in the case of multiple
!  or closely-spaced roots, by raising precision above the user's level.

!  root  is the value returned as the approximate root of the equation.

!  kprt  controls printing within the routine:
!        kprt = -1 for no output
!        kprt =  0 for no output except warning and error messages.
!        kprt =  1 for the approximation to the root and the function
!                  value to be printed once at the end of the routine.
!        kprt =  2 for the approximation to the root and the function
!                  value to be printed each iteration.

!  ku    is the unit number for output.

    interface
      function f(xi, ni, qx)
      use fmvals_parallel
      implicit none
      type (multi) :: xi(2)
      integer :: ni
      type (multi), dimension(2) :: f
      type(fm_settings) :: qx
      end function f
    end interface

      type (multi) :: ax(2), bx(2), root(2)
      integer :: nr, nf, n_found, ndig_of_roots, kprt, ku
      logical :: remove_previous_roots
      type (zm) :: list_of_roots(nr)
      type(fm_settings) :: qx
      intent (in) :: ax, bx, nr, nf, remove_previous_roots, n_found, list_of_roots,  &
                     ndig_of_roots, kprt, ku
      intent (inout) :: root, qx

      integer :: j, jset, k, kl, kwarn_save, maxit, ndsave
      character (80) :: str
      double precision :: value
      logical :: use_f_over_fp
      type (multi) :: f1(2), f1old(2), f2(2), fp0(2), fp1(2), fs(2), s(2), x1(2), x1old(2),  &
                      x2(2), x3(2), mz1(2), mz2(2)
      type (multi) :: err, err1, t, tol, mxy(6)
      logical, external :: fmcomp

      if (kprt == 2) then
          write (ku, "(a)") ' '
          write (ku, "(a)") ' zm_root1.  Begin trace of all iterations.'
      endif

!             Raise precision slightly.

      ndsave = qx%ndig
      qx%ndig = qx%ndig + qx%ngrd52
      call zmequ(ax, x1, ndsave, qx%ndig, qx)
      call zmequ(bx, x2, ndsave, qx%ndig, qx)
      kwarn_save = qx%kwarn
      qx%kwarn = 0

      maxit = 1000
      jset = 50
      call fmi2m(1, err, qx)
      call fmulp(err, mxy(1), qx)
      call fmmpyi(mxy(1), 100, tol, qx)
      use_f_over_fp = .false.
      call zmroot_f(x1, f, nf, remove_previous_roots, n_found, list_of_roots, ndig_of_roots, f1, qx)
      call zmroot_f(x2, f, nf, remove_previous_roots, n_found, list_of_roots, ndig_of_roots, f2, qx)

!             Check for legal function values.

      call zmabs(f1, mxy(1), qx)
      if (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov) then
          do j = 1, 3
             call zmmpyi(x1, 4-j, mz1, qx)
             call zmdivi_r1(mz1, 4, qx)
             call zmmpyi(x2, j, mz2, qx)
             call zmdivi_r1(mz2, 4, qx)
             call zmadd(mz1, mz2, x3, qx)
             call zmroot_f(x3, f, nf, remove_previous_roots, n_found, list_of_roots,  &
                           ndig_of_roots, f1, qx)
             call zmabs(f1, mxy(1), qx)
             if (.not. (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov)) then
                 call zmeq(x3, x1, qx)
                 exit
             endif
          enddo
          call zmabs(f1, mxy(1), qx)
          if (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov) then
              do j = 1, 3
                 call zmmpyi(x1, 4+j, mz1, qx)
                 call zmdivi_r1(mz1, 4, qx)
                 call zmmpyi(x2, -j, mz2, qx)
                 call zmdivi_r1(mz2, 4, qx)
                 call zmadd(mz1, mz2, x3, qx)
                 call zmroot_f(x3, f, nf, remove_previous_roots, n_found, list_of_roots,  &
                               ndig_of_roots, f1, qx)
                 call zmabs(f1, mxy(1), qx)
                 if (.not. (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov)) then
                     call zmeq(x3, x1, qx)
                     exit
                 endif
                 call zmmpyi(x1, -j, mz1, qx)
                 call zmdivi_r1(mz1, 4, qx)
                 call zmmpyi(x2, 4+j, mz2, qx)
                 call zmdivi_r1(mz2, 4, qx)
                 call zmadd(mz1, mz2, x3, qx)
                 call zmroot_f(x3, f, nf, remove_previous_roots, n_found, list_of_roots,  &
                               ndig_of_roots, f1, qx)
                 call zmabs(f1, mxy(1), qx)
                 if (.not. (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov)) then
                     call zmeq(x3, x1, qx)
                     exit
                 endif
              enddo
          endif
      endif

      kl = 1
      do while (kl ==1)
         kl = 0
         call zmabs(f1, mxy(1), qx)
         if (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov) then
             if (kprt >= 0) then
                 write (ku, "(a)") ' '
                 write (ku, "(a, a)") ' Invalid input for zm_root1. ',  &
                                    ' Unknown or overflowed function value for ax ='
                 call zmprint(x1, qx)
                 write (ku, "(a)") ' '
             endif
             j = 0
             call zmunknown(x2, qx)
             call fmunknown(err, qx)
             exit
         endif

         call zmabs(f2, mxy(1), qx)
         if (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov) then
             do j = 1, 3
                call zmmpyi(x1, 4-j, mz1, qx)
                call zmdivi_r1(mz1, 4, qx)
                call zmmpyi(x2, j, mz2, qx)
                call zmdivi_r1(mz2, 4, qx)
                call zmadd(mz1, mz2, x3, qx)
                call zmroot_f(x3, f, nf, remove_previous_roots, n_found, list_of_roots,  &
                              ndig_of_roots, f2, qx)
                call zmabs(f2, mxy(1), qx)
                if (.not. (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov)) then
                    call zmeq(x3, x2, qx)
                    exit
                endif
             enddo
             call zmabs(f2, mxy(1), qx)
             if (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov) then
                 do j = 1, 3
                    call zmmpyi(x1, 4+j, mz1, qx)
                    call zmdivi_r1(mz1, 4, qx)
                    call zmmpyi(x2, -j, mz2, qx)
                    call zmdivi_r1(mz2, 4, qx)
                    call zmadd(mz1, mz2, x3, qx)
                    call zmroot_f(x3, f, nf, remove_previous_roots, n_found, list_of_roots,  &
                                  ndig_of_roots, f2, qx)
                    call zmabs(f2, mxy(1), qx)
                    if (.not. (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov)) then
                        call zmeq(x3, x2, qx)
                        exit
                    endif
                    call zmmpyi(x1, -j, mz1, qx)
                    call zmdivi_r1(mz1, 4, qx)
                    call zmmpyi(x2, 4+j, mz2, qx)
                    call zmdivi_r1(mz2, 4, qx)
                    call zmadd(mz1, mz2, x3, qx)
                    call zmroot_f(x3, f, nf, remove_previous_roots, n_found, list_of_roots,  &
                                  ndig_of_roots, f2, qx)
                    call zmabs(f2, mxy(1), qx)
                    if (.not. (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov)) then
                        call zmeq(x3, x2, qx)
                        exit
                    endif
                 enddo
             endif
         endif
         call zmabs(f2, mxy(1), qx)
         if (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov) then
             if (kprt >= 0) then
                 write (ku, "(a)") ' '
                 write (ku, "(a, a)") ' Invalid input for zm_root1. ',  &
                                      ' Unknown or overflowed function value for bx ='
                 call zmprint(x2, qx)
                 write (ku, "(a)") ' '
             endif
             j = 0
             call zmunknown(x2, qx)
             call fmunknown(err, qx)
             exit
         endif

!             Secant does not do well if the magnitudes of the two starting function values differ
!             by too much.  Adjust if necessary.

         do j = 1, 10
            call zmdiv(f2, f1, mz1, qx)
            call zmabs(mz1, mxy(1), qx)
            call zmdiv(f1, f2, mz1, qx)
            call zmabs(mz1, mxy(2), qx)
            call fmi2m(10, mxy(3), qx)
            if (fmcomp(mxy(1), '>', mxy(3), qx)) then
                call zmadd(x1, x2, mz1, qx)
                call zmdivi(mz1, 2, x2, qx)
                call zmroot_f(x2, f, nf, remove_previous_roots, n_found, list_of_roots,  &
                              ndig_of_roots, f2, qx)
            else if (fmcomp(mxy(2), '>', mxy(3), qx)) then
                call zmadd(x1, x2, mz1, qx)
                call zmdivi(mz1, 2, x1, qx)
                call zmroot_f(x1, f, nf, remove_previous_roots, n_found, list_of_roots,  &
                              ndig_of_roots, f1, qx)
            else
                exit
            endif
         enddo

         if (kprt == 2) then
             call zmform('es20.10', 'es20.10', f1, str, qx)
             write (ku, "('  j =', i3, 3x, 'f(ax) = ', a, '    x:')") 0, trim(str)
             call zmprint(x1, qx)
             call zmform('es20.10', 'es20.10', f2, str, qx)
             write (ku, "('  j =', i3, 3x, 'f(bx) = ', a, '    x:')") 0, trim(str)
             call zmprint(x2, qx)
         endif

!             This loop does the iteration.

         do j = 1, maxit

            call zmsub(f2, f1, mz1, qx)
            call zmabs(mz1, mxy(1), qx)
            if (mxy(1)%mp(3) /= 0) then
                call zmsub(x2, x1, mz1, qx)
                call zmsub(f2, f1, mz2, qx)
                call zmdiv_r1(mz1, mz2, qx)
                call zmmpy_r1(mz1, f2, qx)
                call zmsub(x2, mz1, x3, qx)
            else
                call zmi2m(1, mz1, qx)
                call zmadd(x2, mz1, x3, qx)
            endif

!             Multiple roots cause very slow convergence and loss of accuracy.
!             If the slope is very small, try to improve convergence and accuracy by using
!             the (slower) function  f(x)/f'(x)  which has no multiple roots.

            call zmeq(x1, x1old, qx)
            call zmeq(f1, f1old, qx)
            call zmsub(x2, x1, mz1, qx)
            call zmsub(f2, f1, mz2, qx)
            call zmdiv_r1(mz2, mz1, qx)
            call zmabs(mz2, mxy(1), qx)
            call fmst2m('1.0d-2', mxy(2), qx)
            call zmabs(f2, mxy(3), qx)
            call fmst2m('1.0d-4', mxy(4), qx)
            call zmdiv(f2, mz2, mz1, qx)
            call zmabs(mz1, mxy(5), qx)
            call zmdivi(x2, 10000, mz1, qx)
            call zmabs(mz1, mxy(6), qx)
            if ( (fmcomp(mxy(1), '<', mxy(2), qx) .and. fmcomp(mxy(3), '<', mxy(4), qx) .and.  &
                  fmcomp(mxy(5), '<', mxy(6), qx)) .or. use_f_over_fp) then
                use_f_over_fp = .true.
                call zmeq(x2, x1, qx)
                call zmeq(x3, x2, qx)
                call zmeq(f2, f1, qx)
                if (remove_previous_roots) then
                    call zmfprime2(0, x3, f, nf, fp0, qx)
                    call zmfprime2(1, x3, f, nf, fp1, qx)
                    call zmi2m(0, s, qx)
                    call zmi2m(1, mz1, qx)
                    do k = 1, n_found
                       call zmequ(list_of_roots(k)%mzm, mz2, ndig_of_roots, qx%ndig, qx)
                       call zmsub_r2(x3, mz2, qx)
                       call zmdiv_r2(mz1, mz2, qx)
                       call zmadd_r1(s, mz2, qx)
                    enddo
                    call zmmpy(fp0, s, mz1, qx)
                    call zmsub(fp1, mz1, mz2, qx)
                    call zmdiv(fp0, mz2, f2, qx)
                else
                    call zmfprime2(0, x3, f, nf, fp0, qx)
                    call zmfprime2(1, x3, f, nf, fp1, qx)
                    call zmdiv(fp0, fp1, f2, qx)
                endif
            else
                call zmeq(x2, x1, qx)
                call zmeq(x3, x2, qx)
                call zmeq(f2, f1, qx)
                call zmroot_f(x3, f, nf, remove_previous_roots, n_found, list_of_roots,  &
                              ndig_of_roots, f2, qx)

!             If the function has a large number of roots, like a high-degree polynomial, then
!             from a distance the function looks like it has multiple roots even though once we
!             get closer the roots appear distinct.  This can slow the rate of convergence in
!             the early iterations.  Try an Aitken extrapolation once every few steps to try to
!             speed up this initial phase of convergence.

                call zmmpyi(x1, 2, mz1, qx)
                call zmsub(x2, mz1, mz2, qx)
                call zmadd(mz2, x1old, mz1, qx)
                call zmabs(mz1, mxy(1), qx)
                if (mod(j, 5) == 0 .and. mxy(1)%mp(3) /= 0) then
                    call zmsub(x2, x1, mz2, qx)
                    call zmdiv_r1(mz2, mz1, qx)
                    call zmsub(x2, mz2, s, qx)
                    call zmroot_f(s, f, nf, remove_previous_roots, n_found, list_of_roots,  &
                                  ndig_of_roots, fs, qx)
                    call zmabs(f1, mxy(1), qx)
                    call zmabs(f2, mxy(2), qx)
                    call fmmax(mxy(1), mxy(2), mxy(3), qx)
                    call zmabs(fs, mxy(1), qx)
                    if (fmcomp(mxy(1), '<', mxy(3), qx)) then
                        call zmeq(x2, x1, qx)
                        call zmeq(f2, f1, qx)
                        call zmeq(s, x2, qx)
                        call zmeq(fs, f2, qx)
                    endif
                endif
            endif

!             If f2 is one of the FM non-numbers, +-underflow, +-overflow, unknown,
!             then replace it by something representable, so that the next x3 will be
!             closer to x1.  Also swap x1 and x2, making the bad x go away first.

            call zmabs(f2, mxy(1), qx)
            if (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov) then
                call zmmpyi(f1, -2, f2, qx)
                call zmeq(x1, x3, qx)
                call zmeq(x2, x1, qx)
                call zmeq(x3, x2, qx)
                call zmeq(f1, x3, qx)
                call zmeq(f2, f1, qx)
                call zmeq(x3, f2, qx)
            endif

!             A common failure mode for secant is to get into a pattern that repeats x1 and x2
!             close together with nearly equal function values and x3 farther away with a much
!             larger function value.  Check for this, and re-start the iteration by choosing
!             a different x3.

            call zmabs(f2, mxy(1), qx)
            call zmabs(f1old, mxy(2), qx)
            call zmabs(f1, mxy(3), qx)
            call fmmax(mxy(2), mxy(3), mxy(4), qx)
            call fmmpyi(mxy(4), 100, mxy(2), qx)
            if (fmcomp(mxy(1), '>', mxy(2), qx) .and. j >= jset) then
                if (jset >= 200) then
                    maxit = j
                    exit
                endif
                jset = jset + 50
                value = (mod(277*j, 1001) + 1) / 1002.0d0
                value = 9*value - 4
                call fmdp2m(value, mxy(1), qx)
                call fmi2m(0, mxy(2), qx)
                call zmcmpx(mxy(1), mxy(2), mz1, qx)
                call zmi2m(1, mz2, qx)
                call zmsub_r1(mz2, mz1, qx)
                call zmmpy_r1(mz1, x1, qx)
                call zmmpy_r1(mz2, x2, qx)
                call zmadd(mz1, mz2, x2, qx)
                call zmroot_f(x2, f, nf, remove_previous_roots, n_found, list_of_roots,  &
                              ndig_of_roots, f2, qx)
            endif

            if (kprt == 2) then
                call zmform('es20.10', 'es20.10', f2, str, qx)
                write (ku, "('  j =', i3, 4x, 'f(x) = ' , a, '    x:')") j, trim(str)
                call zmprint(x2, qx)
            endif

            call fmeq(err, err1, qx)
            call zmabs(x2, mxy(1), qx)
            if (mxy(1)%mp(3) /= 0) then
                call zmsub(x2, x1, mz1, qx)
                call zmdiv_r1(mz1, x2, qx)
                call zmabs(mz1, err, qx)
            else
                call zmsub(x2, x1, mz1, qx)
                call zmabs(mz1, err, qx)
            endif

!             If the error is less than the tolerance, double check to make sure the previous
!             error was small along with the current function value.  Some divergent iterations
!             can get err < tol without being close to a root.

            call zmabs(f2, mxy(1), qx)
            if (fmcomp(err, '<', tol, qx) .or. mxy(1)%mp(3) == 0) then
                call fmsqrt(tol, mxy(3), qx)
                call fmsqrt(mxy(3), mxy(2), qx)
                call fmi2m(1, mxy(3), qx)
                call fmulp(mxy(3), mxy(4), qx)
                call fmsqrt(mxy(4), mxy(3), qx)
                if (fmcomp(err1, '>', mxy(2), qx) .and. fmcomp(mxy(1), '>', mxy(3), qx)) then
                    if (kprt >= 0) then
                        write (ku, "(/' Possible false convergence in zm_root1 after', i5, "//  &
                                  "' iterations.  ', 'Last two approximations =')") j
                        call zmprint(x1, qx)
                        call zmprint(x2, qx)
                        write (ku, "(/' These agree to the convergence tolerance, but the"//  &
                                  " previous iteration was suspiciously far away:')")
                        call zmprint(x1old, qx)
                        write (ku, "(/' and the function value of the last iteration was"//  &
                                  " suspiciously far from zero:')")
                        call zmprint(f2, qx)
                        write (ku, "(/' Unknown has been returned.')")
                    endif
                    call zmunknown(x2, qx)
                endif
                kl = 2
                exit
            endif

         enddo

!             No convergence after maxit iterations.

         if (kl == 0) then
             if (kprt >= 0) then
                 write (ku, "(/' No convergence in zm_root1 after', i5, ' iterations.  ', "//  &
                           "'Last two approximations =')") maxit
                 call zmprint(x1, qx)
                 call zmprint(x2, qx)
                 write (ku, "(/' Unknown has been returned.')")
             endif
             call zmunknown(x2, qx)
         endif

      enddo

!             The root was found.

      call zmequ(x2, root, qx%ndig, ndsave, qx)
      qx%ndig = ndsave
      if (kprt >= 1) then
          call zmabs(x2, t, qx)
          call fmulp(t, err1, qx)
          if (.not. (err1%mp(2) == qx%munkno .or. err1%mp(2) == qx%mexpun)) then
              call fmdiv(err1, t, mxy(1), qx)
              call fmdivi(mxy(1), 2, err1, qx)
              if (fmcomp(err, '<', err1, qx)) call fmeq(err1, err, qx)
          endif
          call fmform('es16.6', err, str, qx)
          write (ku, "(a)") ' '
          write (ku, "('  zm_root1.   Function ', i3, i7, ' iterations.'/17x"// &
                    "'Estimated relative error =', a, ',    Root:')") nf, j, trim(str)
          call zmprint(root, qx)
          write (ku, "(a)") ' '
      endif

      qx%kwarn = kwarn_save
      end subroutine zm_root1

      subroutine zmroot_f(x, f, nf, remove_previous_roots, n_found, list_of_roots,  &
                          ndig_of_roots, return_value, qx)
      use fmvals_parallel
      implicit none

!  zmroot_f is used here to evaluate the user's function f and divide f by the product of
!  (x - list_of_roots(j)) over the roots that have been found so far.  This should keep the
!  zm_root1 routine from returning to a root that is already on the list (unless it is a
!  root of multiplicity m > 1).

!  When remove_previous_roots is false, just evaluate f without doing the division.

!  x  is the argument to the function.
!  nf is the function number.

    interface
      function f(xi, ni, qx)
      use fmvals_parallel
      implicit none
      type (multi) :: xi(2)
      integer :: ni
      type (multi), dimension(2) :: f
      type(fm_settings) :: qx
      end function f
    end interface

      integer :: nf, n_found, ndig_of_roots
      logical :: remove_previous_roots
      type (zm) :: list_of_roots(n_found)
      type (multi) :: x(2), return_value(2)
      type(fm_settings) :: qx
      intent (in) :: x, nf, remove_previous_roots, n_found, list_of_roots, ndig_of_roots
      intent (inout) :: return_value, qx

      integer :: j
      type (multi) :: d(2), s(2), mxy

      if (remove_previous_roots) then
          call zmeq(f(x, nf, qx), s, qx)
          do j = 1, n_found
             call zmequ(list_of_roots(j)%mzm, d, ndig_of_roots, qx%ndig, qx)
             call zmsub_r2(x, d, qx)
             call zmabs(d, mxy, qx)
             if (mxy%mp(3) /= 0) then
                 call zmdiv_r1(s, d, qx)
             endif
          enddo
          call zmeq(s, return_value, qx)
      else
          call zmeq(f(x, nf, qx), return_value, qx)
      endif

      end subroutine zmroot_f

      subroutine zm_secant(ax, bx, f, nf, root, kprt, ku)
      use fmvals_parallel
      implicit none

!  This routine searches for a root of f(x,nf) = 0 using ax and bx as starting points.
!  ax and bx are complex, and the search can fail if ax and bx are not close enough to any roots
!  or if the function is badly behaved.

!  When a root is found, zm_secant tries to return full accuracy even in the case of multiple
!  or closely-spaced roots, by raising precision above the user's level.

!  root  is the value returned as the approximate root of the equation.

!  kprt  controls printing within the routine:
!        kprt = -1 for no output
!        kprt =  0 for no output except warning and error messages.
!        kprt =  1 for the approximation to the root and the function
!                  value to be printed once at the end of the routine.
!        kprt =  2 for the approximation to the root and the function
!                  value to be printed each iteration.

!  ku    is the unit number for output.

    interface
      function f(xi, ni, qx)
      use fmvals_parallel
      implicit none
      type (multi) :: xi(2)
      integer :: ni
      type (multi), dimension(2) :: f
      type(fm_settings) :: qx
      end function f
    end interface

      type (zm) :: ax, bx, root
      integer :: nf, kprt, ku
      intent (in) :: ax, bx, nf, kprt, ku
      intent (inout) :: root

      integer :: j, jset, kl, kwarn_save, maxit, ndsave
      character (80) :: str
      double precision :: value
      logical :: use_f_over_fp
      type (multi) :: f1(2), f1old(2), f2(2), fp0(2), fp1(2), mz1(2), mz2(2), z1(2),  &
                      z1old(2), z2(2), z3(2)
      type (multi) :: err, err1, t, tol, mxy(6)
      logical, external :: fmcomp
      type(fm_settings) :: qx

      if (kprt == 2) then
          write (ku,*) ' '
          write (ku,*) ' zm_secant.  Begin trace of all iterations.'
      endif

!             Raise precision slightly.

      ndsave = qx%ndig
      qx%ndig = qx%ndig + qx%ngrd52
      call zmequ(ax%mzm, z1, ndsave, qx%ndig, qx)
      call zmequ(bx%mzm, z2, ndsave, qx%ndig, qx)
      kwarn_save = qx%kwarn
      qx%kwarn = 0

      maxit = 1000
      jset = 50
      call fmi2m(1, err, qx)
      call fmulp(err, mxy(1), qx)
      call fmmpyi(mxy(1), 100, tol, qx)
      use_f_over_fp = .false.
      call zmeq(f(z1, nf, qx), f1, qx)
      call zmeq(f(z2, nf, qx), f2, qx)

!             Check for legal function values.

      call zmabs(f1, mxy(1), qx)
      if (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov) then
          do j = 1, 3
             call zmmpyi(z1, 4-j, mz1, qx)
             call zmdivi_r1(mz1, 4, qx)
             call zmmpyi(z2, j, mz2, qx)
             call zmdivi_r1(mz2, 4, qx)
             call zmadd(mz1, mz2, z3, qx)
             call zmeq(f(z3, nf, qx), f1, qx)
             call zmabs(f1, mxy(1), qx)
             if (.not. (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov)) then
                 call zmeq(z3, z1, qx)
                 exit
             endif
          enddo
          call zmabs(f1, mxy(1), qx)
          if (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov) then
              do j = 1, 3
                 call zmmpyi(z1, 4+j, mz1, qx)
                 call zmdivi_r1(mz1, 4, qx)
                 call zmmpyi(z2, -j, mz2, qx)
                 call zmdivi_r1(mz2, 4, qx)
                 call zmadd(mz1, mz2, z3, qx)
                 call zmeq(f(z3, nf, qx), f1, qx)
                 call zmabs(f1, mxy(1), qx)
                 if (.not. (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov)) then
                     call zmeq(z3, z1, qx)
                     exit
                 endif
                 call zmmpyi(z1, -j, mz1, qx)
                 call zmdivi_r1(mz1, 4, qx)
                 call zmmpyi(z2, 4+j, mz2, qx)
                 call zmdivi_r1(mz2, 4, qx)
                 call zmadd(mz1, mz2, z3, qx)
                 call zmeq(f(z3, nf, qx), f1, qx)
                 call zmabs(f1, mxy(1), qx)
                 if (.not. (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov)) then
                     call zmeq(z3, z1, qx)
                     exit
                 endif
              enddo
          endif
      endif

      kl = 1
      do while (kl == 1)
         kl = 0
         call zmabs(f1, mxy(1), qx)
         if (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov) then
             if (kprt >= 0) then
                 write (ku,*) ' '
                 write (ku,*) ' Invalid input for zm_secant. ',  &
                              ' Unknown or overflowed function value for ax ='
                 call zmprint(z1, qx)
                 write (ku,*) ' '
             endif
             j = 0
             call zmunknown(z2, qx)
             call fmunknown(err, qx)
             exit
         endif

         call zmabs(f2, mxy(1), qx)
         if (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov) then
             do j = 1, 3
                call zmmpyi(z1, 4-j, mz1, qx)
                call zmdivi_r1(mz1, 4, qx)
                call zmmpyi(z2, j, mz2, qx)
                call zmdivi_r1(mz2, 4, qx)
                call zmadd(mz1, mz2, z3, qx)
                call zmeq(f(z3, nf, qx), f2, qx)
                call zmabs(f2, mxy(1), qx)
                if (.not. (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov)) then
                    call zmeq(z3, z2, qx)
                    exit
                endif
             enddo
             call zmabs(f2, mxy(1), qx)
             if (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov) then
                 do j = 1, 3
                    call zmmpyi(z1, 4+j, mz1, qx)
                    call zmdivi_r1(mz1, 4, qx)
                    call zmmpyi(z2, -j, mz2, qx)
                    call zmdivi_r1(mz2, 4, qx)
                    call zmadd(mz1, mz2, z3, qx)
                    call zmeq(f(z3, nf, qx), f2, qx)
                    call zmabs(f2, mxy(1), qx)
                    if (.not. (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov)) then
                        call zmeq(z3, z2, qx)
                        exit
                    endif
                    call zmmpyi(z1, -j, mz1, qx)
                    call zmdivi_r1(mz1, 4, qx)
                    call zmmpyi(z2, 4+j, mz2, qx)
                    call zmdivi_r1(mz2, 4, qx)
                    call zmadd(mz1, mz2, z3, qx)
                    call zmeq(f(z3, nf, qx), f2, qx)
                    call zmabs(f2, mxy(1), qx)
                    if (.not. (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov)) then
                        call zmeq(z3, z2, qx)
                        exit
                    endif
                 enddo
             endif
         endif
         call zmabs(f2, mxy(1), qx)
         if (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov) then
             if (kprt >= 0) then
                 write (ku,*) ' '
                 write (ku,*) ' Invalid input for zm_secant. ',  &
                              ' Unknown or overflowed function value for bx ='
                 call zmprint(z2, qx)
                 write (ku,*) ' '
             endif
             j = 0
             call zmunknown(z2, qx)
             call fmunknown(err, qx)
             exit
         endif

!             Secant does not do well if the magnitude of the two starting function values differ
!             by too much.  Adjust if necessary.

         do j = 1, 10
            call zmdiv(f2, f1, mz1, qx)
            call zmabs(mz1, mxy(1), qx)
            call zmdiv(f1, f2, mz1, qx)
            call zmabs(mz1, mxy(2), qx)
            call fmi2m(10, mxy(3), qx)
            if (fmcomp(mxy(1), '>', mxy(3), qx)) then
                call zmadd(z1, z2, mz1, qx)
                call zmdivi(mz1, 2, z2, qx)
                call zmeq(f(z2, nf, qx), f2, qx)
            else if (fmcomp(mxy(2), '>', mxy(3), qx)) then
                call zmadd(z1, z2, mz1, qx)
                call zmdivi(mz1, 2, z1, qx)
                call zmeq(f(z1, nf, qx), f1, qx)
            else
                exit
            endif
         enddo

         if (kprt == 2) then
             call zmform('es20.10', 'es20.10', f1, str, qx)
             write (ku, "('  j =', i3, 3x, 'f(ax) = ', a, '    x:')") 0, trim(str)
             call zmprint(z1, qx)
             call zmform('es20.10', 'es20.10', f2, str, qx)
             write (ku, "('  j =', i3, 3x, 'f(bx) = ', a, '    x:')") 0, trim(str)
             call zmprint(z2, qx)
         endif

!             This loop does the iteration.

         do j = 1, maxit

            call zmsub(f2, f1, mz1, qx)
            call zmabs(mz1, mxy(1), qx)
            if (mxy(1)%mp(3) /= 0) then
                call zmsub(z2, z1, mz1, qx)
                call zmsub(f2, f1, mz2, qx)
                call zmdiv_r1(mz1, mz2, qx)
                call zmmpy_r1(mz1, f2, qx)
                call zmsub(z2, mz1, z3, qx)
            else
                call zmi2m(1, mz1, qx)
                call zmadd(z2, mz1, z3, qx)
            endif

!             Multiple roots cause very slow convergence and loss of accuracy.
!             If the slope is very small, try to improve convergence and accuracy by using
!             the (slower) function  f(x)/f'(x)  which has no multiple roots.

            call zmeq(z1, z1old, qx)
            call zmeq(f1, f1old, qx)
            call zmsub(z2, z1, mz1, qx)
            call zmsub(f2, f1, mz2, qx)
            call zmdiv_r1(mz2, mz1, qx)
            call zmabs(mz2, mxy(1), qx)
            call fmst2m('1.0D-2', mxy(2), qx)
            call zmabs(f2, mxy(3), qx)
            call fmst2m('1.0D-4', mxy(4), qx)
            call zmdiv(f2, mz2, mz1, qx)
            call zmabs(mz1, mxy(5), qx)
            call zmdivi(z2, 10000, mz1, qx)
            call zmabs(mz1, mxy(6), qx)
            if ( (fmcomp(mxy(1), '<', mxy(2), qx) .and. fmcomp(mxy(3), '<', mxy(4), qx) .and.  &
                  fmcomp(mxy(5), '<', mxy(6), qx)) .or. use_f_over_fp) then
                use_f_over_fp = .true.
                call zmeq(z2, z1, qx)
                call zmeq(z3, z2, qx)
                call zmeq(f2, f1, qx)
                call zmfprime2(0, z3, f, nf, fp0, qx)
                call zmfprime2(1, z3, f, nf, fp1, qx)
                call zmdiv(fp0, fp1, f2, qx)
            else
                call zmeq(z2, z1, qx)
                call zmeq(z3, z2, qx)
                call zmeq(f2, f1, qx)
                call zmeq(f(z3, nf, qx), f2, qx)
            endif

!             If f2 is one of the FM non-numbers, +-underflow, +-overflow, unknown,
!             then replace it by something representable, so that the next z3 will be
!             closer to z1.  Also swap z1 and z2, making the bad x go away first.

            call zmabs(f2, mxy(1), qx)
            if (mxy(1)%mp(2) == qx%munkno .or. mxy(1)%mp(2) == qx%mexpov) then
                call zmmpyi(f1, -2, f2, qx)
                call zmeq(z1, z3, qx)
                call zmeq(z2, z1, qx)
                call zmeq(z3, z2, qx)
                call zmeq(f1, z3, qx)
                call zmeq(f2, f1, qx)
                call zmeq(z3, f2, qx)
            endif

!             A common failure mode for secant is to get into a pattern that repeats z1 and z2
!             close together with nearly equal function values and z3 farther away with much
!             larger function value.  Check for this, and re-start the iteration by choosing
!             a different z3.

            call zmabs(f2, mxy(1), qx)
            call zmabs(f1old, mxy(2), qx)
            call zmabs(f1, mxy(3), qx)
            call fmmax(mxy(2), mxy(3), mxy(4), qx)
            call fmmpyi(mxy(4), 100, mxy(2), qx)
            if (fmcomp(mxy(1), '>', mxy(2), qx) .and. j >= jset) then
                if (jset >= 200) then
                    maxit = j
                    exit
                endif
                jset = jset + 50
                value = (mod(277*j, 1001) + 1) / 1002.0d0
                value = 9*value - 4
                call fmdp2m(value, mxy(1), qx)
                call fmi2m(0, mxy(2), qx)
                call zmcmpx(mxy(1), mxy(2), mz1, qx)
                call zmi2m(1, mz2, qx)
                call zmsub_r1(mz2, mz1, qx)
                call zmmpy_r1(mz1, z1, qx)
                call zmmpy_r1(mz2, z2, qx)
                call zmadd(mz1, mz2, z2, qx)
                call zmeq(f(z2, nf, qx), f2, qx)
            endif

            if (kprt == 2) then
                call zmform('es20.10', 'es20.10', f2, str, qx)
                write (ku, "('  j =', i3, 4x, 'f(x) = ' , a, '    x:')") j, trim(str)
                call zmprint(z2, qx)
            endif

            call fmeq(err, err1, qx)
            call zmabs(z2, mxy(1), qx)
            if (mxy(1)%mp(3) /= 0) then
                call zmsub(z2, z1, mz1, qx)
                call zmdiv_r1(mz1, z2, qx)
                call zmabs(mz1, err, qx)
            else
                call zmsub(z2, z1, mz1, qx)
                call zmabs(mz1, err, qx)
            endif

!             If the error is less than the tolerance, double check to make sure the previous
!             error was small along with the current function value.  Some divergent iterations
!             can get err < tol without being close to a root.

            call zmabs(f2, mxy(1), qx)
            if (fmcomp(err, '<', tol, qx) .or. mxy(1)%mp(3) == 0) then
                call fmsqrt(tol, mxy(3), qx)
                call fmsqrt(mxy(3), mxy(2), qx)
                call fmi2m(1, mxy(3), qx)
                call fmulp(mxy(3), mxy(4), qx)
                call fmsqrt(mxy(4), mxy(3), qx)
                if (fmcomp(err1, '>', mxy(2), qx) .and. fmcomp(mxy(1), '>', mxy(3), qx)) then
                    if (kprt >= 0) then
                        write (ku, "(/' Possible false convergence in zm_secant after', i5, "//  &
                                  "' iterations.  ', 'Last two approximations =')") j
                        call zmprint(z1, qx)
                        call zmprint(z2, qx)
                        write (ku, "(/' These agree to the convergence tolerance, but the"//  &
                                  " previous iteration was suspiciously far away:')")
                        call zmprint(z1old, qx)
                        write (ku, "(/' and the function value of the last iteration was"//  &
                                  " suspiciously far from zero:')")
                        call zmprint(f2, qx)
                        write (ku, "(/' Unknown has been returned.')")
                    endif
                    call zmunknown(z2, qx)
                endif
                kl = 2
                exit
            endif

         enddo

         if (kl == 0) then

!                  No convergence after maxit iterations.

             if (kprt >= 0) then
                 write (ku, "(/' No convergence in zm_secant after', i5, ' iterations.  ', "//  &
                           "'Last two approximations =')") maxit
                 call zmprint(z1, qx)
                 call zmprint(z2, qx)
                 write (ku, "(/' Unknown has been returned.')")
             endif
             call zmunknown(z2, qx)
         endif

      enddo

!             The root was found.

      call zmequ(z2, root%mzm, qx%ndig, ndsave, qx)
      qx%ndig = ndsave
      if (kprt >= 1) then
          call zmabs(z2, t, qx)
          call fmulp(t, err1, qx)
          if (.not. (err1%mp(2) == qx%munkno .or. err1%mp(2) == qx%mexpun)) then
              call fmdiv(err1, t, mxy(1), qx)
              call fmdivi(mxy(1), 2, err1, qx)
              if (fmcomp(err, '<', err1, qx)) call fmeq(err1, err, qx)
          endif
          call fmform('es16.6', err, str, qx)
          write (ku,*) ' '
          write (ku, "('  zm_secant.   Function ', i3, i7, ' iterations.'/17x"// &
                    "'Estimated relative error =', a, ',    Root:')") nf, j, trim(str)
          call zmprint(root%mzm, qx)
          write (ku,*) ' '
      endif

      qx%kwarn = kwarn_save
      end subroutine zm_secant
