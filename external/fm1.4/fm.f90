
!     FM 1.4                              David M. Smith                           2023-12-20



!  The routines in this package perform multiple precision arithmetic and functions
!  on three kinds of numbers.
!  FM routines handle floating-point real multiple precision numbers,
!  IM routines handle integer multiple precision numbers, and
!  ZM routines handle floating-point complex multiple precision numbers.
!  References to FM numbers below mean the low-level array form of the number used by the routines
!  in fm.f95, and not the derived type(fm) numbers handled by the fmzm module.  Logically, both may
!  refer to the same multiple precision number, but the syntax for dealing with the two types of
!  objects is different.  The same is true of references to IM numbers and ZM numbers below.

!  These are the basic routines for the FM package, and the expectation is that the user will not
!  call these routines directly.  The typical usage is for a program to declare multiple precision
!  variables with the three derived types defined in module fmzm in file fmzm90.f95.  Then that
!  module provides the interface between the user's program and the routines in this file.  See the
!  documentation in the FM_User_Manual.txt file for advice on using the fmzm module.
!  The information below is intended as a technical reference on the inner workings of FM, and most
!  FM users should not need to study it.


!  1. INITIALIZING THE PACKAGE

!  The variables that contain values to be shared by the different routines are located in module
!  fmvals in file fmsave.f95.  Variables that are described below for controlling various features
!  of the FM package are found in this module.  They are initialized to default values assuming
!  32-bit integers and 64-bit double precision representation of the arrays holding multiple
!  precision numbers.  The base and number of digits to be used are initialized to give slightly
!  more than 50 decimal digits.  Subroutine fmvars can be used to get a list of these variables
!  and their values.

!  The intent of module fmvals is to hide the FM internal variables from the user's program, so that
!  no name conflicts can occur.  Subroutine fmsetvar can be used to change the variables listed
!  below to new values.  It is not always safe to try to change these variables directly by putting
!  use fmvals into the calling program and then changing them by hand.  Some of the saved constants
!  depend upon others, so that changing one variable may cause errors if others depending on that
!  one are not also changed.  fmsetvar automatically updates any others that depend upon the one
!  being changed.

!  Subroutine fmset also initializes these variables.  It tries to compute the best value for each,
!  and it checks several of the default values set in fmvals to see that they are reasonable for a
!  given machine.  fmset can also be called to set or change the current precision level for the
!  multiple precision numbers.

!  Calling fmset is optional starting in version 1.2 of the FM package.  In previous versions one
!  call was required before any other routine in the package could be used.

!  The routine zmset from version 1.1 is no longer needed, and the complex operations are
!  automatically initialized in fmvals.  It has been left in the package for compatibility with
!  version 1.1.


!  2.  REPRESENTATION OF FM NUMBERS

!  mbase is the base in which the arithmetic is done.  mbase must be bigger than one, and less than
!        or equal to the square root of the largest representable integer.  For best efficiency
!        mbase should be large, but no more than about 1/4 of the square root of the largest
!        representable integer.  Input and output conversions are much faster when mbase is a
!        power of ten.

!  ndig  is the number of base mbase digits that are carried in the multiple precision numbers.
!        ndig must be at least three.  The upper limit for ndig is restricted only by the amount
!        of memory available.

!  Sometimes it is useful to dynamically vary ndig during the program.  Routine fmequ should be used
!  to round numbers to lower precision or zero-pad them to higher precision when changing ndig.

!  The default value of mbase is a large power of ten.  fmset also sets mbase to a large power of
!  ten.  For an application where another base is used, such as simulating a given machine's base
!  two arithmetic, use subroutine fmsetvar to change mbase, so that the other internal values
!  depending on mbase will be changed accordingly.

!  There are two representations for a floating point multiple precision number.  The unpacked
!  representation used by the routines while doing the computations is base mbase and is stored
!  in ndig+3 words.  A packed representation is available to store the numbers in compressed form.
!  In this format, the ndig (base mbase) digits of the mantissa are packed two per word to conserve
!  storage.  Thus the external, packed form of a number requires (ndig+1)/2+3 words.

!  The unpacked format of a floating multiple precision number is as follows.  A number ma refers
!  to elements of an array with the multiple precision number stored as follows:
!       1  Sign of the number
!       2  Exponent of the number
!       3  First digit of the number
!     ...
!  ndig+2  Last digit of the number.

!  The exponent is a power of mbase and the implied radix point is immediately before the first
!  digit of the mantissa.  The exponent is a signed integer.  The overflow threshold is
!  mbase**(mxexp+1), and the underflow threshold is mbase**(-mxexp-1).  This means the valid
!  exponents for an FM number can range from -mxexp to mxexp+1 (inclusive).
!  Every nonzero number is normalized so that the first digit of the mantissa is nonzero.

!  For mbase = 10,000 and ndig = 4, if ma is the number -pi, it would have these representations:

!                   Word 1         2         3         4         5         6

!         Unpacked:     -1         1         3      1415      9265      3590
!         Packed:       -1         1     31415  92653590

!  The number represented is (-1)*(10000**1)*(.0003141592653590).

!  Because of the normalization of the digits with a large base, the equivalent number of base 10
!  significant digits for an FM number may be as small as log10(mbase)*(ndig-1) + 1.  In the -pi
!  example above, this is 4*3 + 1 = 13.

!  The integer routines use the FM format to represent numbers, without the number of digits (ndig)
!  being fixed.  Integers in IM format are essentially variable precision, using the minimum number
!  of words to represent each value.

!  The unpacked format is the default.  As machines' memories have gotten bigger, few applications
!  need the packed format.  A program that uses packed format numbers should not use the fmzm module
!  or the multiple precision derived types defined in fmzm.

!  For programs using both FM and IM numbers, FM routines should not be called with IM numbers, and
!  IM routines should not be called with FM numbers, since the implied value of ndig used for an IM
!  number may not match the explicit ndig expected by an FM routine.  Use the conversion routines
!  imfm2i and imi2fm to change between the FM and IM formats.

!  The format for complex FM numbers (called ZM numbers below) is very similar to that for real FM
!  numbers.  Each ZM number consists of two FM numbers representing the real and imaginary parts of
!  a complex number.

!  Besides these representable FM numbers there are three exception categories, called
!  overflow, underflow, and unknown.  They have special exponents that are outside the range of
!  exponents for representable numbers, with words 1,2,3 defining which type of category the
!  number is in.

!  FM numbers in these categories do not have full precision, but use words 4,5 to preserve some
!  information about where in each category the values lie.  This allows more robust handling of
!  exceptions.


!  3. INPUT/OUTPUT ROUTINES

!  All versions of the input routines perform free-format conversion from characters to FM numbers.

!  a. Conversion to or from a character array

!     fminp converts from a character(1) array to an FM number.

!     fmout converts an FM number to base 10 and formats it for output as an array of type
!           character(1).  The output is left justified in the array, and the format is defined
!           by two variables in module fmvals, so that a separate format definition does not have
!           to be provided for each output call.

!     jform1 and jform2 define a default output format.

!     jform1 = 0     e   format       ( .314159M+6 )
!            = 1     es  format       ( 3.14159M+5 )
!            = 2     f   format       ( 314159.000 )

!     jform2 is the number of significant digits to display (if jform1 = 0 or 1).
!            If jform2 = 0 then a default number of digits is chosen.  The default is roughly
!            the full precision of the number.
!     jform2 is the number of digits after the decimal point (if jform1 = 2).
!            See the fmout documentation for more details.

!  b. Conversion to or from a character string

!     fmst2m converts from a character string to an FM number.

!     fmform converts an FM number to a character string according to a format provided in each
!            call.  The format description is more like that of a Fortran format statement, and
!            integer or fixed-point output is right justified.

!  c. Direct read or write

!     fmprint uses fmout to print one FM number.

!     fmfprint uses fmform to print one FM number.

!     fmwrite writes FM numbers for later input using fmread.

!     fmread reads FM numbers written by fmwrite.

!  The values given to jform1 and jform2 can be used to define a default output format when fmout
!  or fmprint are called.  The explicit format used in a call to fmform or fmfprint overrides the
!  settings of jform1 and jform2.

!  kw is the unit number to be used for standard output from the package, including error and
!  warning messages, and trace output.

!  For multiple precision integers, the corresponding routines iminp, imout, imst2m, imform,
!  imprint, imfprint, imwrite, and imread provide similar input and output conversions.  For output
!  of IM numbers, jform1 and jform2 are ignored and integer format (jform1=2, jform2=0) is used.

!  For ZM numbers, the corresponding routines zminp, zmout, zmst2m, zmform, zmprint, zmfprint,
!  zmwrite, and zmread provide similar input and output conversions.

!  For the output format of ZM numbers, jform1 and jform2 determine the default format for the
!  individual parts of a complex number as with FM numbers.

!     jformz determines the combined output format of the real and imaginary parts.

!     jformz = 1  normal setting    :    1.23 - 4.56 i
!            = 2  use capital I     :    1.23 - 4.56 I
!            = 3  parenthesis format:  ( 1.23 , -4.56 )

!     jprntz controls whether to print real and imaginary parts on one line whenever possible.

!     jprntz = 1  print both parts as a single string :
!                     1.23456789M+321 - 9.87654321M-123 i
!            = 2  print on separate lines without the 'i' :
!                     1.23456789M+321
!                    -9.87654321M-123

!  For further description of these routines, see section 8 below.


!  4. ARITHMETIC TRACING

!  ntrace and lvltrc control trace printout from the package.

!  ntrace =  0   No output except warnings and errors.  (Default)
!         =  1   The result of each call to one of the routines is printed in base 10, using fmout.
!         = -1   The result of each call to one of the routines is printed in internal base mbase
!                     format.
!         =  2   The input arguments and result of each call to one of the routines is printed in
!                     base 10, using fmout.
!         = -2   The input arguments and result of each call to one of the routines is printed in
!                     base mbase format.

!  lvltrc defines the call level to which the trace is done.  lvltrc = 1 means only FM routines
!         called directly by the user are traced, lvltrc = 2 also prints traces for FM routines
!         called by other FM routines called directly by the user, etc.  Default is 1.

!  In the above description, internal mbase format means the number is printed as it appears in the
!  array --- the sign, exponent, then the ndig base mbase digits.


!  5. ERROR CONDITIONS

!  kflag is a condition value returned by the package after each call to one of the routines.
!        Negative values indicate conditions for which a warning message will be printed unless
!        kwarn = 0.
!        Positive values indicate conditions that may be of interest but are not errors.  No warning
!        message is printed if kflag is nonnegative.

!  Subroutine fmflag is provided to give the user access to the current condition code.  For
!  example, to set the user's local variable lflag to FM's internal kflag value:
!        call fmflag(lflag)

!    kflag =  0     Normal operation.

!          =  1     One of the operands in fmadd or fmsub was insignificant with respect to the
!                       other.  This means that in the default (symmetric) rounding mode the result
!                       is equal to the argument of larger magnitude.  kflag = 1 is still returned
!                       with the other three rounding modes (see kround below), but the result may
!                       not be equal to either input argument.
!          =  2     In converting an FM number to a one word integer in fmm2i, the FM number was
!                       not exactly an integer.  The next integer toward zero was returned.

!          = -1     ndig was less than 3.
!          = -2     mbase was less than 2 or more than mxbase.
!          = -3     An exponent was out of range.
!          = -4     Invalid input argument(s) to an FM routine.  unknown was returned.
!          = -5     + or - overflow was generated as a result from an FM routine.
!          = -6     + or - underflow was generated as a result from an FM routine.
!          = -7     The input string (array) to fminp was not legal.
!          = -8     The character array was not large enough in an input or output routine.
!          = -9     Precision could not be raised enough to provide all requested guard digits,
!                        or allocation of memory for a multiple-precision number failed.
!                        This means the program has run out of memory.
!                        The current version of FM stops the program at that point, instead of
!                        returning kflag.
!
!          = -10    An FM input argument was too small in magnitude to convert to the machine's
!                        single or double precision in fmm2sp or fmm2dp.  Check that the definitions
!                        of spmax and dpmax in file fmsave.f95 are correct for the current machine.
!                        Zero was returned.
!          = -11    Array mbern is not dimensioned large enough for the requested number of
!                        Bernoulli numbers.
!          = -12    Array mjsums is not dimensioned large enough for the number of coefficients
!                        needed in the reflection formula in fmpgam.

!  When a negative kflag condition is encountered, the value of kwarn determines the action to
!  be taken.

!  kwarn = 0     Execution continues and no message is printed.
!        = 1     A warning message is printed and execution continues.
!        = 2     A warning message is printed and execution stops.

!  The default setting is kwarn = 1.

!  When an overflow or underflow is generated for an operation in which an input argument was
!  already an overflow or underflow, no additional message is printed.  When an unknown result
!  is generated and an input argument was already unknown, no additional message is printed.
!  In these cases the negative kflag value is still returned.

!  IM routines handle exceptions like overflow or unknown in the same way as FM routines, but there
!  are some differences because the number of digits carried for IM numbers is not fixed.  For
!  example, in computing the product of two large integers FM will try to allocate more space rather
!  than returning +overflow.  If this allocation fails, FM will write an error message indicating it
!  could not get more memory, and the program will stop.  The routines immpy_mod and impower_mod can
!  be used to obtain modular products and powers without as much chance of running out of memory.


!  6. OTHER OPTIONS

!  krad = 0     All angles in the real trigonometric functions and inverse functions are measured
!                   in degrees.
!       = 1     All angles are measured in radians.  (Default)

!  kround = -1  All results are rounded toward minus infinity.
!         =  0  All results are rounded toward zero (chopped).
!         =  1  All results are rounded to the nearest FM number, or to the value with an even last
!                   digit if the result is exactly halfway between two FM numbers.  (Default)
!         =  2  All results are rounded toward plus infinity.

!  kswide defines the maximum screen width to be used for all unit kw output.  Default is 80.

!  keswch controls the action taken in fminp and other input routines for strings like 'e7' that
!         have no digits before the exponent field.  This is sometimes a convenient abbreviation
!         when doing interactive keyboard input.
!         keswch = 1 causes 'e7' to translate like '1.0e+7'.  (Default)
!         keswch = 0 causes 'e7' to translate like '0.0e+7' and give 0.

!  cmchar defines the exponent letter to be used for FM variable output.
!         Default is 'M', as in 1.2345M+678.
!         Change it to 'e' for output to be read by a non-FM program.

!  See module fmvals in file fmsave.f95 for additional description of these and other variables
!  defining various FM conditions.


!  7. PORTABILITY

!  In fmset several variables are set to machine-dependent values, and many of the variables
!  initialized in module fmvals in file fmsave.f95 are checked to see that they have reasonable
!  values.  fmset will print warning messages on unit kw for any of the fmvals variables that
!  seem to be poorly initialized.

!  If an FM run fails, call fmvars to get a list of all the fmvals variables printed on unit kw.

!  In the routines for special functions, several constants are used that require the machine's
!  integer word size to be at least 32 bits.


!  8.  LIST OF ROUTINES

!  First are the routines that deal with multiple precision real numbers.  All of these are
!  subroutines except logical function fmcompare.

!  ma, mb, mc refer to FM format numbers (i.e., low-level type(multi) as opposed to the type(fm),
!  (im), or (zm) that are defined in file fmzm90.f95)

!  In Fortran-90 and later versions of the Fortran standard, it is potentially unsafe to use the
!  same variable both as input and output arguments in the calling sequence.
!  The operation ma = ma + mb should not be written as
!        call fmadd(ma,mb,ma)
!  since the code for the subroutine may not know that the first and third arguments are the same,
!  and some code optimizations under the assumption that all three arguments are different could
!  cause errors.

!  One solution is to use a third array and then put the result back in ma:
!        call fmadd(ma,mb,mc)
!        call fmeq(mc,ma)

!  When the first call is doing one of the "fast" operations like addition, the extra call to move
!  the result back to ma can cause a noticeable loss in efficiency.  To avoid this, separate
!  routines are provided for the basic arithmetic operations when the result is to be returned in
!  the same array as one of the inputs.

!  A routine name with a suffix of  "_r1" returns the result in the first input array, and a suffix
!  of "_r2" returns the result in the second input array.  The example above would then be:
!        call fmadd_r1(ma,mb)

!  These routines each have one less argument than the original version, since the output is
!  re-directed to one of the inputs.  The result array should not be the same as any input array
!  when the original version of the routine is used.

!  The routines that can be used this way are listed below.  For others, like
!        call fmexp(ma,ma)
!  the relative cost of doing an extra copy is small.  This one should become
!        call fmexp(ma,mb)
!        call fmeq(mb,ma)

!  When the derived-type interface from fmzm is used, as in
!        type(fm), save :: a, b
!        ...
!        a = a + b
!  there is no problem putting the result back into a, since the interface routine creates a
!  temporary scratch array for the result of a + b.

!  For each of these routines there is also a version available for which the argument list is
!  the same but all FM numbers are in packed format.  The routines using packed numbers have the
!  same names except 'fm' is replaced by 'fp' at the start of each name.

!  Some of the routine names were restricted to 6 characters in earlier versions of FM.  The old
!  names have been retained for compatibility, but new names that are longer and more readable
!  have been added.  For example, the old routine fmcssn can now also be called as fmcos_sin.
!  Both old and new names are listed below.


!  fmabs(ma,mb)              mb = abs(ma)

!  fmacos(ma,mb)             mb = acos(ma)

!  fmacosh(ma,mb)            mb = acosh(ma)

!  fmadd(ma,mb,mc)           mc = ma + mb

!  fmadd_r1(ma,mb)           ma = ma + mb

!  fmadd_r2(ma,mb)           mb = ma + mb

!  fmaddi(ma,ival)           ma = ma + ival   Increment an FM number by a one word integer.
!                                             Note this call does not have an "mb" result
!                                             like fmdivi and fmmpyi.

!  fmasin(ma,mb)             mb = asin(ma)

!  fmasinh(ma,mb)            mb = asinh(ma)

!  fmatan(ma,mb)             mb = atan(ma)

!  fmatanh(ma,mb)            mb = atanh(ma)

!  fmatan2(ma,mb,mc)         mc = atan2(ma,mb)     < old name: fmatn2 >

!  fmbig(ma)                 ma = Biggest FM number less than overflow.

!  fmchangebase(ma,mb,new_mbase,new_ndig)
!                            mb is returned with the base new_mbase and precision new_ndig
!                               representation of ma, where ma is given in the current base (mbase)
!                               and precision (ndig).  This routine is primarily meant to be used
!                               for input and output conversion when a base is being used that is
!                               not a power of ten.

!  fmcompare(ma,lrel,mb)     Logical comparison of ma and mb.     < old name: fmcomp >
!                            lrel is a character(2) value identifying which of the six comparisons
!                                 is to be made.
!                            Example:  if (fmcompare(ma,'>=',mb)) ...
!                            Also can be:  if (fmcompare(ma,'ge',mb)) ...
!                            character(1) is ok:  if (fmcompare(ma,'>',mb)) ...

!  fmcons                    Set several saved constants that depend on mbase, the base being used.
!                            fmcons should be called immediately after changing mbase.

!  fmcos(ma,mb)              mb = cos(ma)

!  fmcos_sin(ma,mb,mc)       mb = cos(ma),  mc = sin(ma).     < old name: fmcssn >
!                                 Faster than making two separate calls.

!  fmcosh(ma,mb)             mb = cosh(ma)

!  fmcosh_sinh(ma,mb,mc)     mb = cosh(ma),  mc = sinh(ma).     < old name: fmchsh >
!                                 Faster than making two separate calls.

!  fmdig(nstack,kst)         Find a set of precisions to use during Newton iteration for finding a
!                            simple root starting with about double precision accuracy.

!  fmdim(ma,mb,mc)           mc = dim(ma,mb)

!  fmdiv(ma,mb,mc)           mc = ma / mb

!  fmdiv_r1(ma,mb)           ma = ma / mb

!  fmdiv_r2(ma,mb)           mb = ma / mb

!  fmdivi(ma,ival,mb)        mb = ma/ival   ival is a one word integer.

!  fmdivi_r1(ma,ival)        ma = ma/ival

!  fmdp2m(x,ma)              ma = x    Convert from double precision to FM.

!  fmdpm(x,ma)               ma = x    Convert from double precision to FM.
!                                      Faster than fmdp2m, but ma agrees with x only to d.p.
!                                      accuracy.  See the comments in the two routines.

!  fmeq(ma,mb)               mb = ma   Both have precision ndig.
!                                      This is the version to use for standard  b = a  statements.

!  fmequ(ma,mb,na,nb)        mb = ma   Version for changing precision.
!                                      ma has na digits (i.e., ma was computed using ndig = na), and
!                                      mb will be defined having nb digits.
!                                      mb is rounded if nb < na
!                                      mb is zero-padded if nb > na

!  fmexp(ma,mb)              mb = exp(ma)

!  fmflag(k)                 k = kflag  get the value of the FM condition flag -- stored in the
!                                       internal FM variable kflag in module fmvals.

!  fmform(form,ma,string)    ma is converted to a character string using format form and returned in
!                               string.  form can represent i, f, e, or es formats.  Example:
!                               call fmform('f60.40',ma,string)

!  fmfprint(form,ma)         Print ma on unit kw using form format.     < old name: fmfprt >

!  fmhypot(ma,mb,mc)         ma = sqrt(ma**2 + mb**2)

!  fmi2m(ival,ma)            ma = ival   Convert from one word integer to FM.

!  fminp(line,ma,la,lb)      ma = line   Input conversion.
!                                        Convert line(la) through line(lb) from characters to FM.

!  fmint(ma,mb)              mb = int(ma)    Integer part of ma.

!  fmipower(ma,ival,mb)      mb = ma**ival   Raise an FM number to a one word integer power.
!                                            < old name: fmipwr >

!  fmlog10(ma,mb)            mb = log10(ma)     < old name: fmlg10 >

!  fmln(ma,mb)               mb = log(ma)

!  fmlni(ival,ma)            ma = log(ival)   Natural log of a one word integer.

!  fmm2dp(ma,x)              x  = ma     Convert from FM to double precision.

!  fmm2i(ma,ival)            ival = ma   Convert from FM to integer.

!  fmm2sp(ma,x)              x  = ma     Convert from FM to single precision.

!  fmmax(ma,mb,mc)           mc = max(ma,mb)

!  fmmin(ma,mb,mc)           mc = min(ma,mb)

!  fmmod(ma,mb,mc)           mc = ma mod mb

!  fmmpy(ma,mb,mc)           mc = ma * mb

!  fmmpy_r1(ma,mb)           ma = ma * mb

!  fmmpy_r2(ma,mb)           mb = ma * mb

!  fmmpyi(ma,ival,mb)        mb = ma*ival    Multiply by a one word integer.

!  fmmpyi_r1(ma,ival)        ma = ma*ival

!  fmnint(ma,mb)             mb = nint(ma)   Nearest FM integer.

!  fmnorm2(ma,n,mb)          mb = sqrt( ma(1)**2 + ma(2)**2 + ... + ma(n)**2 )

!  fmout(ma,line,lb)         line = ma   Convert from FM to character.
!                                        line is a character array of length lb.

!  fmpi(ma)                  ma = pi

!  fmprint(ma)               Print ma on unit kw using current format.     < old name: fmprnt >

!  fmpower(ma,mb,mc)         mc = ma**mb     < old name: fmpwr >

!  fm_random_number(x)       x is returned as a double precision random number, uniformly
!                            distributed on the open interval (0,1).  It is a high-quality,
!                            long-period generator based on 49-digit prime numbers.
!                            A default initial seed is used if fm_random_number is called without
!                            calling fm_random_seed_put first.

!  fm_random_seed_get(seed)  returns the seven integers seed(1) through seed(7) as the current seed
!                            for the fm_random_number generator.

!  fm_random_seed_put(seed)  initializes the fm_random_number generator using the seven integers
!                            seed(1) through seed(7). These get and put functions are slower than
!                            fm_random_number, so fm_random_number should be called many times
!                            between fm_random_seed_put calls.  Also, some generators that used a
!                            9-digit modulus have failed randomness tests when used with only a few
!                            numbers being generated between calls to re-start with a new seed.

!  fm_random_seed_size(size) returns integer size as the size of the seed array used by the
!                            fm_random_number generator.  Currently, size = 7.

!  fmrational_power(ma,k,j,mb)
!                            mb = ma**(k/j)  Rational power.     < old name: fmrpwr >
!                            Faster than fmpower for functions like the cube root.

!  fmread(kread,ma)          ma   is returned after reading one (possibly multi-line) FM number
!                                 on unit kread.  This routine reads numbers written by fmwrite.

!  fmset(nprec)              Set the internal FM variables so that the precision is at least nprec
!                            base 10 digits plus three base 10 guard digits.

!  fmsetvar(string)          Define a new value for one of the internal FM variables in module
!                            fmvals that controls one of the FM options.  string has the form
!                                  variable = value.
!                            Example:  To change the screen width for FM output:
!                                  call fmsetvar(' kswide = 120 ')
!                            The variables that can be changed and the options they control are
!                            listed in sections 2 through 6 above.  Only one variable can be set
!                            per call.  The variable name in string must have no embedded blanks.
!                            The value part of string can be in any numerical format, except in
!                            the case of variable cmchar, which is character type.  To set cmchar
!                            to 'e', don't use any quotes in string:
!                                  call fmsetvar(' cmchar = e ')

!  fmsign(ma,mb,mc)          mc = sign(ma,mb)   Returns the absolute value of ma times the sign
!                                               of mb.

!  fmsin(ma,mb)              mb = sin(ma)

!  fmsinh(ma,mb)             mb = sinh(ma)

!  fmsp2m(x,ma)              ma = x   Convert from single precision to FM.

!  fmsqr(ma,mb)              mb = ma * ma   Faster than fmmpy.

!  fmsqr_r1(ma)              ma = ma * ma

!  fmsqrt(ma,mb)             mb = sqrt(ma)

!  fmsqrt_r1(ma)             ma = sqrt(ma)

!  fmst2m(string,ma)         ma = string
!                                 Convert from character string to FM.  string may be in any
!                                 numerical format.  fmst2m is often more convenient than fminp,
!                                 which converts an array of character(1) values.  Example:
!                                       call fmst2m('123.4',ma)

!  fmsub(ma,mb,mc)           mc = ma - mb

!  fmsub_r1(ma,mb)           ma = ma - mb

!  fmsub_r2(ma,mb)           mb = ma - mb

!  fmtan(ma,mb)              mb = tan(ma)

!  fmtanh(ma,mb)             mb = tanh(ma)

!  fmtiny(ma)                ma = Smallest positive FM number greater than underflow.

!  fmulp(ma,mb)              mb = One Unit in the Last Place of ma.  For positive ma this is the
!                                 same as the Fortran function spacing, but mb < 0 if ma < 0.
!                                 Examples:  If mbase = 10 and ndig = 30, then ulp(1.0) = 1.0e-29,
!                                            ulp(-4.5e+67) = -1.0e+38.

!  fmvars                    Write the current values of the internal FM variables on unit kw.

!  fmwrite(kwrite,ma)        Write ma on unit kwrite.     < old name: fmwrit >
!                            Multi-line numbers will have '&' as the last nonblank character on all
!                            but the last line.  These numbers can then be read easily using fmread.


!  These are the available mathematical special functions.

!  fmbernoulli(n,ma)         ma = b(n)      Nth Bernoulli number

!  fmbesj(n,ma,mb)           mb = j(n,ma)   Bessel function of the first kind

!  fmbesj2(n1,n2,ma,mb)      mb = (/  j(n1,ma) , ..., j(n2,ma)  /)  returns an array

!  fmbesy(n,ma,mb)           mb = y(n,ma)   Bessel function of the second kind

!  fmbesy2(n1,n2,ma,mb)      mb = (/  y(n1,ma) , ..., y(n2,ma)  /)  returns an array

!  fmbeta(ma,mb,mc)          mc = Beta(ma,mb)

!  fmc(ma,mb)                mb = c(ma)     Fresnel Cosine Integral

!  fmchi(ma,mb)              mb = Chi(ma)   Hyperbolic Cosine Integral

!  fmci(ma,mb)               mb = Ci(ma)    Cosine Integral

!  fmcomb(ma,mb,mc)          mc = Combination ma choose mb  (Binomial coefficient)

!  fmei(ma,mb)               mb = Ei(ma)    Exponential Integral

!  fmen(n,ma,mb)             mb = e(n,ma)   Exponential Integral E_n

!  fmerf(ma,mb)              mb = Erf(ma)   Error function

!  fmerfc(ma,mb)             mb = Erfc(ma)  Complimentary Error function

!  fmerfcs(ma,mb)            mb = Erfc_Scaled(ma)  Scaled Complimentary Error function

!  fmeuler(ma)               ma = Euler's constant ( 0.5772156649... )     < old name: fmeulr >

!  fmfact(ma,mb)             mb = ma Factorial  (Gamma(ma+1))

!  fmgam(ma,mb)              mb = Gamma(ma)

!  fmibta(mx,ma,mb,mc)       mc = Incomplete Beta(mx,ma,mb)

!  fmigm1(ma,mb,mc)          mc = Incomplete Gamma(ma,mb).  Lower case Gamma(a,x)

!  fmigm2(ma,mb,mc)          mc = Incomplete Gamma(ma,mb).  Upper case Gamma(a,x)

!  fmlerc(ma,mb)             mb = Ln(Erfc(ma))  Log Erfc

!  fmli(ma,mb)               mb = Li(ma)    Logarithmic Integral

!  fmlngm(ma,mb)             mb = Ln(Gamma(ma))

!  fmpgam(n,ma,mb)           mb = Polygamma(n,ma)  (Nth derivative of Psi)

!  fmpoch(ma,n,mb)           mb = ma*(ma+1)*(ma+2)*...*(ma+n-1)  (Pochhammer)

!  fmpsi(ma,mb)              mb = Psi(ma)   (Derivative of Ln(Gamma(ma))

!  fms(ma,mb)                mb = s(ma)     Fresnel Sine Integral

!  fmshi(ma,mb)              mb = Shi(ma)   Hyperbolic Sine Integral

!  fmsi(ma,mb)               mb = Si(ma)    Sine Integral


!  These are the routines that deal with multiple precision integer numbers.
!  All are subroutines except logical function imcompare.  ma, mb, mc refer to IM format numbers.
!  In each case the version of the routine to handle packed IM numbers has the same name, with
!  'im' replaced by 'ip'.

!  imabs(ma,mb)              mb = abs(ma)

!  imadd(ma,mb,mc)           mc = ma + mb

!  imbig(ma)                 ma = 10**(10**6).
!                                 Larger IM numbers can be obtained, but setting ma to the largest
!                                 possible value would leave no room for any other numbers.

!  imcompare(ma,lrel,mb)     Logical comparison of ma and mb.     < old name: imcomp >
!                            lrel is a character(2) value identifying which of the six comparisons
!                                 is to be made.
!                            Example:  if (imcompare(ma,'ge',mb)) ...
!                            Also can be:  if (imcompare(ma,'>=',mb))
!                            character(1) is ok:  if (imcompare(ma,'>',mb)) ...

!  imdim(ma,mb,mc)           mc = dim(ma,mb)

!  imdiv(ma,mb,mc)           mc = int(ma/mb)
!                                 Use imdivr if the remainder is also needed.

!  imdivi(ma,ival,mb)        mb = int(ma/ival)
!                                 ival is a one word integer.  Use imdvir to get the remainder also.

!  imdivr(ma,mb,mc,md)       mc = int(ma/mb),   md = ma mod mb
!                                 When both the quotient and remainder are needed, this routine is
!                                 twice as fast as calling both imdiv and immod.

!  imdvir(ma,ival,mb,irem)   mb = int(ma/ival),   irem = ma mod ival
!                            ival and irem are one word integers.

!  imeq(ma,mb)               mb = ma

!  imfm2i(mafm,mb)           mb = mafm  Convert from real (fm) format to integer (im) format.

!  imform(form,ma,string)    ma is converted to a character string using format form and
!                               returned in string.  form can represent i, f, e, or es formats.
!                               Example: call imform('i70',ma,string)

!  imfprint(form,ma)         Print ma on unit kw using form format.     < old name: imfprt >

!  imgcd(ma,mb,mc)           mc = greatest common divisor of ma and mb.

!  imi2fm(ma,mbfm)           mbfm = ma  Convert from integer (im) format to real (fm) format.

!  imi2m(ival,ma)            ma = ival   Convert from one word integer to IM.

!  iminp(line,ma,la,lb)      ma = line   Input conversion.
!                                        Convert line(la) through line(lb) from characters to IM.

!  imm2dp(ma,x)              x  = ma     Convert from IM to double precision.

!  imm2i(ma,ival)            ival = ma   Convert from IM to one word integer.

!  imm2sp(ma,x)              x  = ma     Convert from IM to single precision.

!  immax(ma,mb,mc)           mc = max(ma,mb)

!  immin(ma,mb,mc)           mc = min(ma,mb)

!  immod(ma,mb,mc)           mc = ma mod mb

!  immpy(ma,mb,mc)           mc = ma*mb

!  immpyi(ma,ival,mb)        mb = ma*ival    Multiply by a one word integer.

!  immpy_mod(ma,mb,mc,md)    md = ma*mb mod mc     < old name: immpym >
!                                 Slightly faster than calling immpy and immod separately.

!  imout(ma,line,lb)         line = ma   Convert from IM to character.
!                                        line is a character array of length lb.

!  impower(ma,mb,mc)         mc = ma**mb     < old name: impwr >

!  impower_mod(ma,mb,mc,md)  md = ma**mb mod mc     < old name: impmod >

!  imprint(ma)               Print ma on unit kw.     < old name: imprnt >

!  imread(kread,ma)          ma   is returned after reading one (possibly multi-line)
!                                 IM number on unit kread.
!                                 This routine reads numbers written by imwrite.

!  imsign(ma,mb,mc)          mc = sign(ma,mb)   Returns the absolute value of ma times the
!                                               sign of mb.

!  imsqr(ma,mb)              mb = ma*ma   Faster than immpy.

!  imst2m(string,ma)         ma = string
!                                 Convert from character string to IM.
!                                 imst2m is often more convenient than iminp, which converts
!                                 an array of character(1) values.  Example:
!                                      call imst2m('12345678901',ma)

!  imsub(ma,mb,mc)           mc = ma - mb

!  imwrite(kwrite,ma)        Write ma on unit kwrite.
!                            Multi-line numbers will have '&' as the last nonblank character on all
!                            but the last line.  These numbers can then be read easily using imread.


!  These are the routines that deal with multiple precision complex numbers.
!  All are subroutines, and in each case the version of the routine to handle packed ZM numbers has
!  the same name, with 'zm' replaced by 'zp'.

!  ma, mb, mc refer to ZM format complex numbers.
!  mafm, mbfm, mcfm refer to FM format real numbers.
!  integ is a Fortran integer variable.
!  zval is a Fortran complex variable.

!  zmabs(ma,mbfm)            mbfm = abs(ma)    Result is real.

!  zmacos(ma,mb)             mb = acos(ma)

!  zmacosh(ma,mb)            mb = acosh(ma)

!  zmadd(ma,mb,mc)           mc = ma + mb

!  zmaddi(ma,integ)          ma = ma + integ  Increment an ZM number by a one word integer.
!                                             Note this call does not have an "mb" result
!                                             like zmdivi and zmmpyi.

!  zmarg(ma,mbfm)            mbfm = Argument(ma)    Result is real.

!  zmasin(ma,mb)             mb = asin(ma)

!  zmasinh(ma,mb)            mb = asinh(ma)

!  zmatan(ma,mb)             mb = atan(ma)

!  zmatanh(ma,mb)            mb = atanh(ma)

!  zmcomplex(mafm,mbfm,mc)   mc = cmplx(mafm,mbfm)     < old name: zmcmpx >

!  zmconjugate(ma,mb)        mb = conjg(ma)     < old name: zmconj >

!  zmcos(ma,mb)              mb = cos(ma)

!  zmcos_sin(ma,mb,mc)       mb = cos(ma),  mc = sin(ma).     < old name: zmcssn >
!                                 Faster than 2 calls.

!  zmcosh(ma,mb)             mb = cosh(ma)

!  zmcosh_sinh(ma,mb,mc)     mb = cosh(ma),  mc = sinh(ma).     < old name: zmchsh >
!                                 Faster than 2 calls.

!  zmdiv(ma,mb,mc)           mc = ma / mb

!  zmdivi(ma,integ,mb)       mb = ma / integ

!  zmeq(ma,mb)               mb = ma

!  zmequ(ma,mb,nda,ndb)      mb = ma    Version for changing precision.
!                                       (nda and ndb are as in fmequ)

!  zmerf(ma,mb)              mb = erf(ma)    Error function

!  zmerfc(ma,mb)             mb = erfc(ma)   Complimentary error function

!  zmerfcs(ma,mb)            mb = erfc_scaled(ma)   Scaled complimentary error function

!  zmexp(ma,mb)              mb = exp(ma)

!  zmfact(ma,mb)             mb = ma!              Factorial function

!  zmform(form1,form2,ma,string)
!                            string = ma
!                            ma is converted to a character string using format form1 for the real
!                            part and form2 for the imaginary part.  The result is returned in
!                            string.  form1 and form2 can represent i, f, e, or es formats.
!                            Example:
!                                  call zmform('f20.10','f15.10',ma,string)

!  zmfprint(form1,form2,ma)  Print ma on unit kw using formats form1 and form2.
!                            < old name: zmfprt >

!  zmgam(ma,mb)              mb = Gamma(ma)        Gamma function

!  zmi2m(integ,ma)           ma = cmplx(integ,0)

!  zm2i2m(integ1,integ2,ma)  ma = cmplx(integ1,integ2)

!  zmimag(ma,mbfm)           mbfm = imag(ma)    Imaginary part.

!  zminp(line,ma,la,lb)      ma = line   Input conversion.
!                                 Convert line(la) through line(lb) from characters to ZM.
!                                 line is a character array of length at least lb.

!  zmint(ma,mb)              mb = int(ma)       Integer part of both Real and Imaginary parts of ma.

!  zmipower(ma,integ,mb)     mb = ma**integ   Integer power function.     < old name: zmipwr >

!  zmlog10(ma,mb)            mb = log10(ma)     < old name: zmlg10 >

!  zmln(ma,mb)               mb = log(ma)

!  zmlngm(ma,mb)             mb = Log_Gamma(ma)

!  zmm2i(ma,integ)           integ = int(real(ma))

!  zmm2z(ma,zval)            zval = ma

!  zmmpy(ma,mb,mc)           mc = ma * mb

!  zmmpyi(ma,integ,mb)       mb = ma * integ

!  zmnint(ma,mb)             mb = nint(ma)   Nearest integer of both Real and Imaginary.

!  zmout(ma,line,lb,last1,last2)
!                            line = ma
!                            Convert from FM to character.
!                            line  is the returned character(1) array.
!                            lb    is the dimensioned size of line.
!                            last1 is returned as the position in line of the last character
!                                  of real(ma)
!                            last2 is returned as the position in line of the last character
!                                  of aimag(ma)

!  zmpower(ma,mb,mc)         mc = ma**mb     < old name: zmpwr >

!  zmprint(ma)               Print ma on unit kw using current format.     < old name: zmprnt >

!  zmrational_power(ma,ival,jval,mb)
!                            mb = ma**(ival/jval)     < old name: zmrpwr >

!  zmread(kread,ma)          ma   is returned after reading one (possibly multi-line) ZM number on
!                                 unit kread.  This routine reads numbers written by zmwrite.

!  zmreal(ma,mbfm)           mbfm = real(ma)    Real part.

!  zmset(nprec)              Set precision to the equivalent of a few more than nprec base 10
!                            digits.  This is now the same as fmset, but is retained for
!                            compatibility with earlier versions of the package.

!  zmsin(ma,mb)              mb = sin(ma)

!  zmsinh(ma,mb)             mb = sinh(ma)

!  zmsqr(ma,mb)              mb = ma*ma    Faster than zmmpy.

!  zmsqrt(ma,mb)             mb = sqrt(ma)

!  zmst2m(string,ma)         ma = string
!                                 Convert from character string to ZM.  zmst2m is often more
!                                 convenient than zminp, which converts an array of character(1)
!                                 values.  Example:
!                                       call zmst2m('123.4+5.67i',ma).

!  zmsub(ma,mb,mc)           mc = ma - mb

!  zmtan(ma,mb)              mb = tan(ma)

!  zmtanh(ma,mb)             mb = tanh(ma)

!  zmwrite(kwrite,ma)        Write ma on unit kwrite.  Multi-line numbers are formatted for
!                            automatic reading with zmread.     < old name: zmwrit >

!  zmz2m(zval,ma)            ma = zval


!  9. NEW FOR VERSION 1.3

!  The first edition of version 1.3 appeared in ACM Transactions on Mathematical Software (2-2011).
!  Since then several additions have been made.
!  (a) New Fortran-08 functions are available in fmzm
!      acosh(x), asinh(x), atanh(x) for real and complex x
!      atan(x,y) can be used in place of atan2(x,y)
!      bessel_j0(x), bessel_j1(x), bessel_jn(n,x), bessel_jn(n1,n2,x)
!      bessel_y0(x), bessel_y1(x), bessel_yn(n,x), bessel_yn(n1,n2,x)
!         The older FM names, bessel_j(n,x) and bessel_y(n,x) are still available.
!      erfc_scaled(x) for exp(x**2) * erfc(x)
!         The older FM function log_erfc(x) is also still available for avoiding underflow in erfc.
!      hypot(x,y) for sqrt(x**2 + y**2)
!      norm2(a) for sqrt( a(1)**2 + a(2)**2 + ... + a(n)**2 )
!         This could previously have been done with array operations as sqrt(dot_product(a,a)).
!  (b) Many of the elementary and special functions are now faster, after some code-tuning was
!      done and a few new methods were added.

!  The routines for the exponential integral function and related mathematical special functions
!  are new in version 1.3.  These routines are:
!  fmbesj, fmbesy, fmc, fmchi, fmci, fmei, fmen, fmerf, fmerfc, fmlerc, fmli, fms, fmshi, fmsi.

!  Some of the routines were moved between files fm.f95 and fmzm90.f95 so that now all routines
!  using the module fmzm (in file fmzm90.f95) for multiple precision derived types and operator
!  overloading are located in fmzm90.f95.  This means that programs not using derived types can
!  skip compiling and/or linking fmzm90.f95.

!  The array function dotproduct in fmzm has been re-named dot_product to agree with the Fortran
!  standard.  For type ZM complex arguments its definition has been changed to agree with the
!  Fortran intrinsic function.  When x and y are complex, dot_product(x,y) is not just the sum of
!  the products of the corresponding array elements, as it is for types FM and IM.  For type zm,
!  the formula is the sum of conjg(x(j)) * y(j).  This definition is used so that the complex dot
!  product will be an inner product in the mathematical sense.

!  New routines have been added to module fmzm to provide array syntax for the three multiple
!  precision derived types.  This means statements like v = 1 and a = b + c now work when these
!  variables are vectors or matrices of multiple precision numbers.

!  One routine from FM 1.2 has been split into three routines in version 1.3.  The routine
!  fm_random_seed from FM 1.2 has become three subroutines, so that the optional arguments and
!  the need for an explicit interface can be avoided.  See the three routines starting with
!  fm_random_seed in the list above.  The same multiplicative congruential generator as before
!  is used, but the shuffling of those values has been removed, so that saving seeds and
!  re-starting the generator now works more like the standard Fortran random function.

!  Multiple precision variables were separate fixed-size arrays in previous versions.  Now they are
!  single integers that serve as index values to a single large array (mwk, defined in file
!  fmsave.f95) where the actual values are stored.  This often improves both efficiency and memory
!  utilization, since many compilers implemented the derived type operations using copy in and copy
!  out of the arguments for a given operation.  Copying entire arrays was slower, and there were
!  often memory leaks when the compiler automatically created temporary derived type objects while
!  evaluating derived type expressions.  The static arrays in previous versions also meant that
!  memory was wasted when only a few kinds of operations were used at high precision.  Now the
!  space needed by any unused operations never gets allocated.

!  Some new error checking is now done for the derived type multiple precision variables. Attempting
!  to use an undefined variable will cause an error message to be printed.

!  Much higher precision can be attained in version 1.3, since machines are faster and have more
!  memory.  To support higher precision, a routine for fft-based multiplication has been included,
!  and when precision gets high enough, the algorithms for multiplication, division, squares, square
!  roots, etc., will switch to the fft routine.

!  Binary splitting algorithms are used for the mathematical constants at high precision.  At the
!  time version 1.3 was released, computing a million digits of e, pi, or the logarithm of a small
!  integer took a few seconds, while a million digits of Euler's constant took a few minutes.

!  Perfect rounding is now done all the time.  In version 1.2 perfect rounding was an option, but
!  the default rounding could round the wrong direction once every few million operations, when the
!  exact result was very close to halfway between two adjacent representable numbers.


!  10. NEW FOR VERSION 1.4

!  The changes in version 1.4 were made to enable a thread-safe special version of FM to be created.
!  See file FM_parallel.f95 for the thread-safe version.

!  The memory model for multi-precision variables has been changed from having one global database
!  kept in module fmvals that holds all the numbers to making the multi-precision variables local
!  to the routines using them.

!  The way in which the user declares and uses type(fm), etc., variables is the same in this
!  version as before.

!  Improvements from the user's point of view are:
!     a.  No longer needing to insert calls into the user's routines to fm_enter_function, etc.
!     b.  No need to call fm_deallocate before deallocating a multi-precision variable.

!  Starting with the 2023 version of FM, numbers in the overflow, underflow, and unknown categories
!  have been enhanced with some "tracking" information.  This allows better handling of exceptions.
!  For example, in the expression  (2 + 3*exp(-x*x)),  when the exp underflowed in previous versions
!  of FM, unknown would be returned for the value of the expression.  When multiplying an underflow
!  by 3 we would not know whether the true result was still in the underflow region or whether it
!  should be a representable FM number, so unknown was returned.

!  Now the underflow retains some extra information, so the 3*exp(-x*x) can be recognized as being
!  insignificant compared to 2 and the expression evaluates to 2.

! --------------------------------------------------------------------------------------------------
! --------------------------------------------------------------------------------------------------



      subroutine fmset(nprec)

!  Initialize the global FM variables that must be set before calling other FM routines.
!  These variables are initialized to fairly standard values in the fmsave.f95 file (module fmvals),
!  so calling fmset at the beginning of a program is now optional.  fmset is a convenient way to set
!  or change the precision being used, and it also checks to see that the generic values chosen for
!  several machine-dependent variables are valid.

!  Base and precision will be set to give at least nprec+3 decimal digits of precision (giving the
!  user at least three base ten guard digits).  When the base is large, each extra word contains
!  several extra digits when viewed in base ten.  This means that some choices of nprec will give
!  a few more than three base ten guard digits.

!  mbase (base for FM arithmetic) is set to a large power of ten.
!  jform1 and jform2 (default output format controls) are set to es format displaying nprec
!  significant digits.

!  Several FM options were set here in previous versions of the package, and are now initialized to
!  their default values in module fmvals.
!  Here are the initial settings:

!  The trace option is set off.
!  The mode for angles in trig functions is set to radians.
!  The rounding mode is set to symmetric rounding.
!  Warning error message level is set to 1.
!  Cancellation error monitor is set off.
!  Screen width for output is set to 80 columns.
!  The exponent character for FM output is set to 'M'.
!  Debug error checking is set off.

      use fmvals
      implicit none

      integer :: nprec
      intent (in) :: nprec

      real (kind(1.0d0)) :: maxint_chk, mxexp2_chk, mexpov_chk, mexpun_chk, munkno_chk
      double precision :: dpeps_chk, dpmax_chk, spmax_chk, temp
      integer :: intmax_chk, k, npsave

!             maxint should be set to a very large integer, possibly the largest representable
!                    integer for the current machine.  For most 32-bit machines, maxint is set
!                    to  2**53 - 1 = 9.007d+15  when double precision arithmetic is used for
!                    m-variables.  Using integer m-variables usually gives
!                    maxint = 2**31 - 1 = 2147483647.

!                    Setting maxint to a smaller number is ok, but this unnecessarily restricts
!                    the permissible range of mbase and mxexp.

      maxint_chk = max_representable_m_var
      if (maxint > maxint_chk) then
          write (kw,*) ' '
          write (kw,*) ' In routine FMSET it appears that FM internal variable'
          write (kw,*) ' MAXINT was set to ', maxint, ' in file FMSAVE.f95'
          write (kw,*) ' For this machine it should be no more than ', maxint_chk
          write (kw,*) ' Change the initialization in FMSAVE.f95 to this value.'
          write (kw,*) ' For this run, MAXINT has been changed to ', maxint_chk
          write (kw,*) ' '
          maxint = maxint_chk
      else if (maxint < maxint_chk/2) then
          write (kw,*) ' '
          write (kw,*) ' In routine FMSET it appears that FM internal variable'
          write (kw,*) ' MAXINT was set to ', maxint, ' in file FMSAVE.f95'
          write (kw,*) ' For better performance set it to ', maxint_chk
          write (kw,*) ' Change the initialization in FMSAVE.f95 to this value.'
          write (kw,*) ' For this run, MAXINT has been changed to ', maxint_chk
          write (kw,*) ' '
          maxint = maxint_chk
      endif

!             intmax is a large value close to the overflow threshold for integer variables.
!                    It is usually 2**31 - 1 for machines with 32-bit integer arithmetic.

!                    The following code sets intmax_chk to the largest representable integer.
!                    Then intmax is checked against this value.

      intmax_chk = huge(i_two)
      if (intmax > intmax_chk) then
          write (kw,*) ' '
          write (kw,*) ' In routine FMSET it appears that FM internal variable'
          write (kw,*) ' INTMAX was set to ', intmax, ' in file FMSAVE.f95'
          write (kw,*) ' For this machine it should be no more than ', intmax_chk
          write (kw,*) ' Change the initialization in FMSAVE.f95 to this value.'
          write (kw,*) ' For this run, INTMAX has been changed to ', intmax_chk
          write (kw,*) ' '
          intmax = intmax_chk
      else if (intmax < intmax_chk/2) then
          write (kw,*) ' '
          write (kw,*) ' In routine FMSET it appears that FM internal variable'
          write (kw,*) ' INTMAX was set to ', intmax, ' in file FMSAVE.f95'
          write (kw,*) ' For better performance set it to ', intmax_chk
          write (kw,*) ' Change the initialization in FMSAVE.f95 to this value.'
          write (kw,*) ' For this run, INTMAX has been changed to ', intmax_chk
          write (kw,*) ' '
          intmax = intmax_chk
      endif

!             dpmax should be set to a value near the machine's double precision overflow threshold,
!                   so that dpmax and 1.0d0/dpmax are both representable in double precision.

      dpmax_chk = huge(dp_two)/5
      if (dpmax > dpmax_chk) then
          write (kw,*) ' '
          write (kw,*) ' In routine FMSET it appears that FM internal variable'
          write (kw,*) ' DPMAX was set to ', dpmax, ' in file FMSAVE.f95'
          write (kw,*) ' For this machine it should be no more than ', dpmax_chk
          write (kw,*) ' Change the initialization in FMSAVE.f95 to this value.'
          write (kw,*) ' For this run, DPMAX has been changed to ', dpmax_chk
          write (kw,*) ' '
          dpmax = dpmax_chk
      else if (dpmax < dpmax_chk/1.0d2) then
          write (kw,*) ' '
          write (kw,*) ' In routine FMSET it appears that FM internal variable'
          write (kw,*) ' DPMAX was set to ', dpmax, ' in file FMSAVE.f95'
          write (kw,*) ' For better performance set it to ', dpmax_chk
          write (kw,*) ' Change the initialization in FMSAVE.f95 to this value.'
          write (kw,*) ' For this run, DPMAX has been changed to ', dpmax_chk
          write (kw,*) ' '
          dpmax = dpmax_chk
      endif

!             spmax should be set to a value near the machine's single precision overflow threshold,
!                   so that 1.01*spmax and 1.0/spmax are both representable in single precision.

      spmax_chk = huge(r_two)/5
      if (spmax > spmax_chk) then
          write (kw,*) ' '
          write (kw,*) ' In routine FMSET it appears that FM internal variable'
          write (kw,*) ' SPMAX was set to ', spmax, ' in file FMSAVE.f95'
          write (kw,*) ' For this machine it should be no more than ', spmax_chk
          write (kw,*) ' Change the initialization in FMSAVE.f95 to this value.'
          write (kw,*) ' For this run, SPMAX has been changed to ', spmax_chk
          write (kw,*) ' '
          spmax = spmax_chk
      else if (spmax < spmax_chk/1.0d2) then
          write (kw,*) ' '
          write (kw,*) ' In routine FMSET it appears that FM internal variable'
          write (kw,*) ' SPMAX was set to ', spmax, ' in file FMSAVE.f95'
          write (kw,*) ' For better performance set it to ', spmax_chk
          write (kw,*) ' Change the initialization in FMSAVE.f95 to this value.'
          write (kw,*) ' For this run, SPMAX has been changed to ', spmax_chk
          write (kw,*) ' '
          spmax = spmax_chk
      endif

!             mxbase is the maximum value for mbase.

      temp = maxint
      temp = int(min(dble(intmax), sqrt(temp)))
      if (mxbase > temp) then
          write (kw,*) ' '
          write (kw,*) ' In routine FMSET it appears that FM internal variable'
          write (kw,*) ' MXBASE was set to ', mxbase, ' in file FMSAVE.f95'
          write (kw,*) ' For this machine it should be no more than ', temp
          write (kw,*) ' Change the initialization in FMSAVE.f95 to this value.'
          write (kw,*) ' For this run, MXBASE has been changed to ', temp
          write (kw,*) ' '
          mxbase = temp
      else if (mxbase < temp/2) then
          write (kw,*) ' '
          write (kw,*) ' In routine FMSET it appears that FM internal variable'
          write (kw,*) ' MXBASE was set to ', mxbase, ' in file FMSAVE.f95'
          write (kw,*) ' For better performance set it to ', temp
          write (kw,*) ' Change the initialization in FMSAVE.f95 to this value.'
          write (kw,*) ' For this run, MXBASE has been changed to ', temp
          write (kw,*) ' '
          mxbase = temp
      endif

!             kround controls the rounding mode.  Set it to symmetric rounding.

      kround = 1

!             mbase is the currently used base for arithmetic.

      k = int(log10(dble(mxbase)/4))
      mbase = 10**k

!             ndig is the number of digits currently being carried.

      npsave = nprec
      ndig = 2 + (nprec+2)/k
      if (ndig < 3) then
          ndig = max(3, ndig)
          write (kw,                                                        &
                 "(//' Precision out of range when calling FMSET.', "   //  &
                 "'  NPREC =', I20/' The nearest valid NDIG will be', " //  &
                 "' used instead:   NDIG =', I20//)"                        &
                ) nprec, ndig
          npsave = 0
      endif

!             ncall is the call stack pointer.

      ncall = 0

!             mxexp  is the current maximum exponent.
!             mxexp2 is the internal maximum exponent.  This is used to define the overflow and
!                    underflow thresholds.

!             These values are chosen so that FM routines can raise the overflow/underflow limit
!             temporarily while computing intermediate results, and so that exp(intmax) is greater
!             than mxbase**(mxexp2+1).

!             The overflow threshold is mbase**(mxexp+1), and the underflow threshold is
!             mbase**(-mxexp-1).  This means the valid exponents in the first word of an FM number
!             can range from -mxexp to mxexp+1 (inclusive).

      mxexp = aint( max_exponent / 2.01d0 + 0.5d0 )
      mxexp0 = aint( max_exponent / 2.01d0 + 0.5d0 )
      mxexp2_chk = max_exponent
      if (mxexp2 > mxexp2_chk*1.01) then
          write (kw,*) ' '
          write (kw,*) ' In routine FMSET it appears that FM internal variable'
          write (kw,*) ' MXEXP2 was set to ', mxexp2, ' in file FMSAVE.f95'
          write (kw,*) ' For this machine it should be no more than ', mxexp2_chk
          write (kw,*) ' Change the initialization in FMSAVE.f95 to this value.'
          write (kw,*) ' For this run, MXEXP2 has been changed to ', mxexp2_chk
          write (kw,*) ' '
          mxexp2 = mxexp2_chk
      else if (mxexp2 < mxexp2_chk*0.99) then
          write (kw,*) ' '
          write (kw,*) ' In routine FMSET it appears that FM internal variable'
          write (kw,*) ' MXEXP2 was set to ', mxexp2, ' in file FMSAVE.f95'
          write (kw,*) ' For this machine it should be no less than ', mxexp2_chk
          write (kw,*) ' Change the initialization in FMSAVE.f95 to this value.'
          write (kw,*) ' For this run, MXEXP2 has been changed to ', mxexp2_chk
          write (kw,*) ' '
          mxexp2 = mxexp2_chk
      endif

!             mexpun is the exponent used as a special symbol for underflowed results.

      mexpun_chk = aint( -max_exponent * 1.01d0 )
      if (mexpun < mexpun_chk*1.01) then
          write (kw,*) ' '
          write (kw,*) ' In routine FMSET it appears that FM internal variable'
          write (kw,*) ' MEXPUN was set to ', mexpun, ' in file FMSAVE.f95'
          write (kw,*) ' For this machine it should be no less than ', mexpun_chk
          write (kw,*) ' Change the initialization in FMSAVE.f95 to this value.'
          write (kw,*) ' For this run, MEXPUN has been changed to ', mexpun_chk
          write (kw,*) ' '
          mexpun = mexpun_chk
      else if (mexpun > mexpun_chk) then
          write (kw,*) ' '
          write (kw,*) ' In routine FMSET it appears that FM internal variable'
          write (kw,*) ' MEXPUN was set to ', mexpun, ' in file FMSAVE.f95'
          write (kw,*) ' For this machine it should be no more than ', mexpun_chk
          write (kw,*) ' Change the initialization in FMSAVE.f95 to this value.'
          write (kw,*) ' For this run, MEXPUN has been changed to ', mexpun_chk
          write (kw,*) ' '
          mexpun = mexpun_chk
      endif

!             mexpov is the exponent used as a special symbol for overflowed results.

      mexpov_chk = -mexpun
      if (mexpov /= mexpov_chk) then
          write (kw,*) ' '
          write (kw,*) ' In routine FMSET it appears that FM internal variable'
          write (kw,*) ' MEXPOV was set to ', mexpov, ' in file FMSAVE.f95'
          write (kw,*) ' For this machine it should be ', mexpov_chk
          write (kw,*) ' Change the initialization in FMSAVE.f95 to this value.'
          write (kw,*) ' For this run, MEXPOV has been changed to ', mexpov_chk
          write (kw,*) ' '
          mexpov = mexpov_chk
      endif

!             munkno is the exponent used as a special symbol for unknown FM results
!                    (1/0, sqrt(-3.0), ...).

      munkno_chk = aint( max_exponent * 1.0201d0 )
      if (munkno > munkno_chk*1.01) then
          write (kw,*) ' '
          write (kw,*) ' In routine FMSET it appears that FM internal variable'
          write (kw,*) ' MUNKNO was set to ', munkno, ' in file FMSAVE.f95'
          write (kw,*) ' For this machine it should be no more than ', munkno_chk
          write (kw,*) ' Change the initialization in FMSAVE.f95 to this value.'
          write (kw,*) ' For this run, MUNKNO has been changed to ', munkno_chk
          write (kw,*) ' '
          munkno = munkno_chk
      else if (munkno < munkno_chk) then
          write (kw,*) ' '
          write (kw,*) ' In routine FMSET it appears that FM internal variable'
          write (kw,*) ' MUNKNO was set to ', munkno, ' in file FMSAVE.f95'
          write (kw,*) ' For this machine it should be no less than ', munkno_chk
          write (kw,*) ' Change the initialization in FMSAVE.f95 to this value.'
          write (kw,*) ' For this run, MUNKNO has been changed to ', munkno_chk
          write (kw,*) ' '
          munkno = munkno_chk
      endif

!             runkno is returned from FM to real or double conversion routines when no valid result
!                    can be expressed in real or double precision.  On systems that provide a value
!                    for undefined results (e.g., Not A Number) setting runkno to that value is
!                    reasonable.  On other systems set it to a value that is likely to make any
!                    subsequent results obviously wrong that use it.  In either case a kflag = -4
!                    condition is also returned.

      runkno = -1.01*spmax

!             iunkno is returned from FM to integer conversion routines when no valid result can be
!                    expressed as a one word integer.  kflag = -4 is also set.

      iunkno = -int(mxexp2)

!             dpeps is the approximate machine precision.

      dpeps_chk = epsilon(dp_two)
      if (dpeps > dpeps_chk*1.01) then
          write (kw,*) ' '
          write (kw,*) ' In routine FMSET it appears that FM internal variable'
          write (kw,*) ' DPEPS was set to ', dpeps, ' in file FMSAVE.f95'
          write (kw,*) ' For this machine it should be no more than ', dpeps_chk
          write (kw,*) ' Change the initialization in FMSAVE.f95 to this value.'
          write (kw,*) ' For this run, DPEPS has been changed to ', dpeps_chk
          write (kw,*) ' '
          dpeps = dpeps_chk
      else if (dpeps < dpeps_chk*0.99) then
          write (kw,*) ' '
          write (kw,*) ' In routine FMSET it appears that FM internal variable'
          write (kw,*) ' DPEPS was set to ', dpeps, ' in file FMSAVE.f95'
          write (kw,*) ' For this machine it should be no less than ', dpeps_chk
          write (kw,*) ' Change the initialization in FMSAVE.f95 to this value.'
          write (kw,*) ' For this run, DPEPS has been changed to ', dpeps_chk
          write (kw,*) ' '
          dpeps = dpeps_chk
      endif

!             jform1 indicates the format used by fmout.

      jform1 = 1

!             jform2 indicates the number of digits used in fmout.

      jform2 = npsave

!             Set jformz to ' 1.23 + 4.56 i ' format.

      jformz = 1

!             Set jprntz to print real and imaginary parts on one line whenever possible.

      jprntz = 1

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      call fmhtbl

!             fmcons sets several real and double precision constants.

      call fmcons

      return
      end subroutine fmset

      subroutine fmabs(ma, mb)

!  mb = abs(ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      integer :: kwrnsv

      call fmalloc(mb, ndig+2)

      ncall = ncall + 1
      namest(ncall) = 'FMABS'
      call fmntr_inp1(ma)

      kflag = 0
      kwrnsv = kwarn
      kwarn = 0
      call fmeq(ma, mb)
      mb%mp(1) = 1
      kwarn = kwrnsv
      call fmntr_out1(mb)
      ncall = ncall - 1

      return
      end subroutine fmabs

      subroutine fmacos(ma, mb)

!  mb = acos(ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(5), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmacos_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmacos_m1(ma, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmacos

      subroutine fmacos_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing acos(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      integer :: krndsave

      krndsave = kround
      kround = 1
      call fmequ(ma, mresult, ndsave, ndig)

!             Use acos(x) = atan(sqrt(1-x*x)/x)

      mresult%mp(1) = 1
      call fmi2m(1, mxy(4))
      call fmsub(mxy(4), mresult, mxy(2))
      call fmadd(mxy(4), mresult, mxy(3))
      call fmmpy_r2(mxy(2), mxy(3))
      call fmsqrt_r1(mxy(3))
      call fmdiv(mxy(3), mresult, mxy(5))
      call fmatan(mxy(5), mresult)

      if (ma%mp(1) < 0) then
          if (krad == 1) then
              call fmpi(mxy(4))
          else
              call fmi2m(180, mxy(4))
          endif
          call fmsub_r2(mxy(4), mresult)
      endif

      kround = krndsave

      return
      end subroutine fmacos_m1

      subroutine fmacos_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = acos(ma).

!  kresult = 1 is returned if a special case gives the value of acos(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j
      double precision :: xe
      logical, external :: fmcomp

      kresult = 0

      namest(ncall) = 'FMACOS   '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, mxy(5), ndsave, ndig)
      call fmovun_xe(mxy(5), xe)
      if (mxy(5)%mp(2) == munkno .and. mxy(5)%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif
      if (mxy(5)%mp(3) == 0) then
          if (krad == 0) then
              call fmi2m(90, mresult)
          else
              call fmpi(mxy(2))
              call fmdivi(mxy(2), 2, mresult)
          endif
          kresult = 1
          return
      endif
      call fmabs(mxy(5), mxy(1))
      call fmi2m(1, mxy(2))
      if (fmcomp(mxy(1), '==', mxy(2))) then
          if (mxy(5)%mp(1) < 0) then
              if (krad == 0) then
                  call fmi2m(180, mresult)
              else
                  call fmpi(mresult)
              endif
          else
              call fmi2m(0, mresult)
          endif
          kresult = 1
          return
      endif
      if (xe >= 1) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      call fmequ(ma, mresult, ndsave, ndig)
      if (kround /= 1 .and. krad /= 1) then
          call fmst2m('0.5', mxy(1))
          call fmsub(mresult, mxy(1), mxy(2))
          if (mxy(2)%mp(3) == 0) then
              call fmst2m('60', mresult)
              return
          endif
          call fmadd(mresult, mxy(1), mxy(2))
          if (mxy(2)%mp(3) == 0) then
              call fmst2m('120', mresult)
              return
          endif
      endif
      if (kround /= 1 .and. xe < -ndsave) then
          if (krad == 0) then
              call fmi2m(180, mxy(1))
              call fmpi(mxy(2))
              call fmdiv(mxy(1), mxy(2), mxy(3))
              call fmmpy(mxy(3), mxy(5), mxy(2))
              call fmi2m(90, mxy(1))
              call fmsub(mxy(1), mxy(2), mresult)
          else
              ndig = ndig + ngrd22
              call fmequ(mxy(5), mxy(1), ndig-ngrd22, ndig)
              call fmpi(mxy(2))
              call fmdivi_r1(mxy(2), 2)
              call fmsub(mxy(2), mxy(1), mresult)
              ndig = ndig - ngrd22
              call fmequ_r1(mresult, ndig+ngrd22, ndig)
          endif
          if (kflag > 0) kflag = 0
          kresult = 1
          return
      endif
      if (mxy(5)%mp(2) == mexpun .or. mxy(5)%mp(2) == munkno) then
          if (xe < -ndsave .and. mxy(5)%mp(5) < 0) then
              if (krad == 1) then
                  call fmpi(mxy(1))
                  call fmdivi(mxy(1), 2, mresult)
              else
                  call fmi2m(90, mresult)
              endif
              kresult = 1
              return
          endif
      endif

      return
      end subroutine fmacos_sc

      subroutine fmacosh(ma, mb)

!  mb = acosh(ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(3), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmacosh_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmacosh_m1(ma, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmacosh

      subroutine fmacosh_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing acosh(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(3), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      integer :: iextra, krndsave
      double precision :: xe

      krndsave = kround
      kround = 1
      call fmequ(ma, mxy(1), ndsave, ndig)

      call fmovun_xe(ma, xe)
      if (xe <= 0 .or. mxy(1)%mp(1) < 0) then
          call fmunknown(mresult)
      else if (4.0*(xe-1) > ndig) then
          call fmmpyi(mxy(1), 2, mresult)
          if (mresult%mp(2) == mexpov) then
              call fmln(mxy(1), mresult)
              call fmlni(2, mxy(2))
              call fmadd_r1(mresult, mxy(2))
          else
              call fmi2m(1, mxy(2))
              call fmsqr(mresult, mxy(3))
              call fmdiv_r2(mxy(2), mxy(3))
              call fmln(mresult, mxy(2))
              call fmsub(mxy(2), mxy(3), mresult)
          endif
      else
          iextra = mxy(1)%mp(2)
          if (abs(mxy(1)%mp(2)) >= mexpov) iextra = 0
          if (iextra > 0) then
              call fmequ_r1(mxy(1), ndig, ndig+iextra)
              ndig = ndig + iextra
          endif
          call fmi2m(1, mresult)
          call fmsub(mxy(1), mresult, mxy(2))
          call fmadd(mxy(1), mresult, mxy(3))
          call fmmpy_r1(mxy(2), mxy(3))
          call fmsqrt_r1(mxy(2))
          call fmdiv_r1(mxy(2), mxy(1))
          call fmatanh(mxy(2), mresult)
      endif

      kround = krndsave

      return
      end subroutine fmacosh_m1

      subroutine fmacosh_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = acosh(ma).

!  kresult = 1 is returned if a special case gives the value of acosh(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(3), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j

      kresult = 0

      namest(ncall) = 'FMACOSH  '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, mxy(1), ndsave, ndig)

      if (mxy(1)%mp(2) == munkno .and. mxy(1)%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      return
      end subroutine fmacosh_sc

      subroutine fmadd(ma, mb, mc)

!  mc = ma + mb

!  This routine performs the trace printing for addition.  fmadd2 is used to do the arithmetic.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: kovun


      ncall = ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == mexpov .or. abs(mb%mp(2)) == mexpov) kovun = 1
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) kovun = 2
      if (ntrace /= 0) then
          namest(ncall) = 'FMADD'
          call fmntr_inp2(ma, mb)
      endif

      call fmadd2(ma, mb, mc)

      if ((abs(mc%mp(2)) == mexpov .and. kovun == 0) .or.  &
          (abs(mc%mp(2)) == munkno .and. kovun < 2)) then
          namest(ncall) = 'FMADD'
          call fmwarn
      endif
      if (ntrace /= 0) then
          call fmntr_out1(mc)
      endif
      ncall = ncall - 1

      return
      end subroutine fmadd

      subroutine fmadd2(ma, mb, mc)

!  Internal addition routine.  mc = ma + mb

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      logical :: retry
      integer :: jsign, kresult

      call fmalloc(mc, ndig+2)
      call fmalloc(mwa, 2*ndig+30)
      call fmadd_sc(ma, mb, mc, kresult)
      if (kresult > 0) then
          return
      endif

      if (mblogs /= mbase) call fmcons

      kround_retry = 0
      jsign = 1
      retry = .true.
      do while (retry)
         retry = .false.
         call fmadd_m1(ma, mb, jsign, retry)
      enddo

!             Transfer to mc and fix the sign of the result.

      call fmmove(mwa, mc)
      mc%mp(1) = 1
      if (jsign < 0 .and. mc%mp(3) /= 0) mc%mp(1) = -1

      kround_retry = 0

      return
      end subroutine fmadd2

      subroutine fmadd2_r1(ma, mb)

!  Internal addition routine.  ma = ma + mb

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: mb
      intent (inout) :: ma

      logical :: retry
      integer :: jsign, kresult
      type(multi), save :: mxy

      call fmalloc(mwa, 2*ndig+30)
      call fmadd_sc(ma, mb, mxy, kresult)
      if (kresult > 0) then
          call fmeq(mxy, ma)
          return
      endif

      if (mblogs /= mbase) call fmcons

      kround_retry = 0
      jsign = 1
      retry = .true.
      do while (retry)
         retry = .false.
         call fmadd_m1(ma, mb, jsign, retry)
      enddo

!             Transfer to ma and fix the sign of the result.

      call fmmove(mwa, ma)
      ma%mp(1) = 1
      if (jsign < 0 .and. ma%mp(3) /= 0) ma%mp(1) = -1

      kround_retry = 0

      return
      end subroutine fmadd2_r1

      subroutine fmadd2_r2(ma, mb)

!  Internal addition routine.  mb = ma + mb

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      logical :: retry
      integer :: jsign, kresult
      type(multi), save :: mxy

      call fmalloc(mwa, 2*ndig+30)
      call fmadd_sc(ma, mb, mxy, kresult)
      if (kresult > 0) then
          call fmeq(mxy, mb)
          return
      endif

      if (mblogs /= mbase) call fmcons

      kround_retry = 0
      jsign = 1
      retry = .true.
      do while (retry)
         retry = .false.
         call fmadd_m1(ma, mb, jsign, retry)
      enddo

!             Transfer to mb and fix the sign of the result.

      call fmmove(mwa, mb)
      mb%mp(1) = 1
      if (jsign < 0 .and. mb%mp(3) /= 0) mb%mp(1) = -1

      kround_retry = 0

      return
      end subroutine fmadd2_r2

      subroutine fmadd_m1(ma, mb, jsign, retry)

!  Internal routine for computing mwa = ma + mb.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: jsign
      logical :: retry
      intent (in) :: ma, mb
      intent (inout) :: jsign, retry

      integer :: j, jcomp, nguard
      real (kind(1.0d0)) :: mbs

      kflag = 0

!             nguard is the number of guard digits used.

      if (ncall > 1) then
          nguard = ngrd21
          if (nguard > ndig) nguard = ndig + 1
      else
          nguard = ngrd52
          if (nguard > ndig) nguard = ndig + 1
      endif
      if (kround_retry >= 1) then
          nguard = ndig + 1
      endif

!             jsign is the sign of the result of ma + mb.

      jsign = 1
      mbs = mb%mp(1)
      if (ksub == 1) mbs = -mbs

!             See which one is larger in absolute value.

      jcomp = 2
      if (ma%mp(2) > mb%mp(2)) then
          jcomp = 1
      else if (mb%mp(2) > ma%mp(2)) then
          jcomp = 3
      else
          do j = 3, ndig+2
             if (ma%mp(j) > mb%mp(j)) then
                 jcomp = 1
                 exit
             endif
             if (mb%mp(j) > ma%mp(j)) then
                 jcomp = 3
                 exit
             endif
          enddo
      endif

      if (jcomp < 3) then
          if (ma%mp(1) < 0) jsign = -1
          jrsign = jsign
          if (ma%mp(1)*mbs > 0) then
              call fmaddp(ma, mb, nguard)
          else
              call fmaddn(ma, mb, nguard)
          endif
      else
          if (mbs < 0) jsign = -1
          jrsign = jsign
          if (ma%mp(1)*mbs > 0) then
              call fmaddp(mb, ma, nguard)
          else
              call fmaddn(mb, ma, nguard)
          endif
      endif

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      if (kround_retry == 1 .and. nguard < ndig) then
          kround_retry = 2
          retry = .true.
          return
      endif

      return
      end subroutine fmadd_m1

      subroutine fmadd_r1(ma, mb)

!  ma = ma + mb

!  This routine performs the trace printing for addition.  fmadd2_r1 is used to do the arithmetic.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb

      integer :: kovun

      ncall = ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == mexpov .or. abs(mb%mp(2)) == mexpov) kovun = 1
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) kovun = 2
      if (ntrace /= 0) then
          namest(ncall) = 'FMADD_R1'
          call fmntr_inp2(ma, mb)
      endif

      call fmadd2_r1(ma, mb)

      if ((abs(ma%mp(2)) == mexpov .and. kovun == 0) .or.  &
          (abs(ma%mp(2)) == munkno .and. kovun < 2)) then
          namest(ncall) = 'FMADD_R1'
          call fmwarn
      endif
      if (ntrace /= 0) then
          call fmntr_out1(ma)
      endif
      ncall = ncall - 1

      return
      end subroutine fmadd_r1

      subroutine fmadd_r2(ma, mb)

!  mb = ma + mb

!  This routine performs the trace printing for addition.  fmadd2_r2 is used to do the arithmetic.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      integer :: kovun

      ncall = ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == mexpov .or. abs(mb%mp(2)) == mexpov) kovun = 1
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) kovun = 2
      if (ntrace /= 0) then
          namest(ncall) = 'FMADD_R2'
          call fmntr_inp2(ma, mb)
      endif

      call fmadd2_r2(ma, mb)

      if ((abs(mb%mp(2)) == mexpov .and. kovun == 0) .or.  &
          (abs(mb%mp(2)) == munkno .and. kovun < 2)) then
          namest(ncall) = 'FMADD_R2'
          call fmwarn
      endif
      if (ntrace /= 0) then
          call fmntr_out1(mb)
      endif
      ncall = ncall - 1

      return
      end subroutine fmadd_r2

      subroutine fmadd_sc(ma, mb, mc, kresult)

!  Check for special cases for mc = ma + mb.

!  kresult = 1 is returned if a special case gives the value of mc.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      integer :: kresult
      intent (in) :: ma, mb
      intent (inout) :: mc, kresult

      integer :: jrssav

      kresult = 0
      jrssav = jrsign
      if ((ma%mp(2) == munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc)
          kresult = 1
          return
      endif
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) then
          if (ksub == 0) then
              call fmovun_add(ma, mb, mc)
          else
              call fmovun_sub(ma, mb, mc)
          endif
          kresult = 1
          return
      endif
      if (abs(ma%mp(2)) == mexpov .or. abs(mb%mp(2)) == mexpov) then
          if (ksub == 0) then
              call fmovun_add(ma, mb, mc)
          else
              call fmovun_sub(ma, mb, mc)
          endif
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0) then
          call fmeq(mb, mc)
          kflag = 1
          if (ksub == 1) then
              call fmnegate(mc)
              kflag = 0
          endif
          jrsign = jrssav
          kresult = 1
          return
      endif
      if (mb%mp(3) == 0) then
          call fmeq(ma, mc)
          kflag = 1
          jrsign = jrssav
          kresult = 1
          return
      endif
      if (mb%mp(2) <= ma%mp(2)-ndig-1) then
          if (kround == 1) then
              call fmeq(ma, mc)
              kflag = 1
              jrsign = jrssav
              kresult = 1
              return
          endif
      endif
      if (ma%mp(2) <= mb%mp(2)-ndig-1) then
          if (kround == 1) then
              call fmeq(mb, mc)
              kflag = 1
              if (ksub == 1) then
                  call fmnegate(mc)
                  kflag = 0
              endif
              jrsign = jrssav
              kresult = 1
              return
          endif
      endif

      return
      end subroutine fmadd_sc

      subroutine fmaddi(ma, ival)

!  ma = ma + ival

!  Increment ma by one word integer ival.

!  This routine is faster than fmadd when ival is small enough so that it can be added to a single
!  word of ma without often causing a carry.  Otherwise fmi2m and fmadd are used.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (inout) :: ma
      intent (in) :: ival

      real (kind(1.0d0)) :: maexp, mksum
      integer :: j, kptma
      type(multi), save :: mxy


      ncall = ncall + 1
      if (ntrace /= 0) then
          namest(ncall) = 'FMADDI'
          call fmntr_inp1i(ma, ival)
      endif
      kflag = 0

      j = 0
      maexp = ma%mp(2)
      if (maexp > 0 .and. maexp <= ndig) then
          kptma = int(maexp) + 2
          if (ma%mp(1) < 0) then
              mksum = ma%mp(kptma) - ival
          else
              mksum = ma%mp(kptma) + ival
          endif
          if (mksum < mbase .and. mksum >= 0) then
              if (.not. (kptma == 3 .and. mksum == 0)) then
                  ma%mp(kptma) = mksum
                  j = 1
              endif
          endif
      endif

      if (j == 0) then
          call fmi2m(ival, mxy)
          call fmadd2_r1(ma, mxy)
      endif

      if (ntrace /= 0) then
          call fmntr_out1(ma)
      endif
      ncall = ncall - 1

      return
      end subroutine fmaddi

      subroutine fmaddn(ma, mb, nguard)

!  Internal addition routine.  mwa = ma - mb
!  The arguments are such that ma >= mb >= 0.

!  nguard is the number of guard digits being carried.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: nguard
      intent (in) :: ma, mb, nguard

      real (kind(1.0d0)) :: mr
      double precision :: err
      integer :: j, kl, ksh, ksh2, n2

      ksh = ma%mp(2) - mb%mp(2)
      ksh2 = ksh
      n2 = min(2+ksh, 2+ndig)
      do j = 1, n2
         mwa%mp(j) = ma%mp(j)
      enddo

!             Subtract.

      if (ksh < ndig) then
          do j = 3+ksh, ndig+2
             mwa%mp(j) = ma%mp(j) - mb%mp(j-ksh)
          enddo
          if (ksh > 0) then
              n2 = min(ndig+2+ksh, ndig+2+nguard)
              do j = ndig+3, n2
                 mwa%mp(j) = -mb%mp(j-ksh)
              enddo
          endif
          if (ndig+2+ksh < ndig+2+nguard) then
              do j = ndig+3+ksh, ndig+2+nguard
                 mwa%mp(j) = 0
              enddo
          endif
      else if (ksh > ndig) then
          if (kround == 1) then
              mwa%mp(ndig+3) = 0
              kflag = 1
              return
          endif
          n2 = min(2+ksh, ndig+2+nguard)
          do j = ndig+3, n2
             mwa%mp(j) = 0
          enddo
          if (3+ksh <= ndig+2+nguard) then
              n2 = min(ndig+2+ksh, ndig+2+nguard)
              do j = 3+ksh, n2
                 mwa%mp(j) = -mb%mp(j-ksh)
              enddo
          endif
          if (ndig+2+ksh < ndig+2+nguard) then
              do j = ndig+2+ksh, ndig+2+nguard
                 mwa%mp(j) = 0
              enddo
          endif
          if (ksh > ndig+3) then
              mwa%mp(ndig+3) = 0
              mwa%mp(ndig+4) = -1
              ksh2 = ndig + 1
          endif
          kflag = 1
      else if (ksh == ndig) then
          n2 = min(ndig+2+ksh, ndig+2+nguard)
          do j = ndig+3, n2
             mwa%mp(j) = -mb%mp(j-ksh)
          enddo
          if (n2 < ndig+2+nguard) then
              do j = n2+1, ndig+2+nguard
                 mwa%mp(j) = 0
              enddo
          endif
      endif

!             Normalize.  Fix the sign of any negative digit.

      do j = ndig+2+nguard, 4, -1
         if (mwa%mp(j) < 0) then
             mwa%mp(j) = mwa%mp(j) + mbase
             mwa%mp(j-1) = mwa%mp(j-1) - 1
         else if (j <= 3+ksh2) then
             exit
         endif
      enddo

!             Shift left if there are any leading zeros in the mantissa.

      ksh = ndig
      do j = 3, ndig+2
         if (mwa%mp(j) > 0) then
             ksh = j - 3
             exit
         endif
      enddo
      if (ksh == ndig+1) then
          mwa%mp(2) = 0
          return
      endif

      if (ksh > 0) then
          kl = ndig + 2 + nguard - ksh
          do j = 3, kl
             mwa%mp(j) = mwa%mp(j+ksh)
          enddo
          do j = kl+1, ndig+2+nguard
             mwa%mp(j) = 0
          enddo
          mwa%mp(2) = mwa%mp(2) - ksh
      endif

!             Round the result.

      if (ncall >= 1) then
          kl = min(nguard, int(3*dlogtn/dlogmb + 2.5))
          err = 0
          do j = kl, 1, -1
             err = (err + mwa%mp(j+ndig+2)) / mbase
          enddo
          if ( (kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
               (kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) kround_retry = kround_retry + 1
      endif
      mr = 2*mwa%mp(ndig+3) + 1
      if (kround == -1 .or. kround == 2) then
          call fmrnd(mwa, ndig, nguard, 0)
      else if (mr >= mbase) then
          if (mr-1 > mbase .and. mwa%mp(ndig+2) < mbase-1) then
              if (kround /= 0) then
                  mwa%mp(ndig+2) = mwa%mp(ndig+2) + 1
                  mwa%mp(ndig+3) = 0
              endif
          else
              call fmrnd(mwa, ndig, nguard, 0)
          endif
      endif

!             See if the result is equal to one of the input arguments.

      if (abs(ma%mp(2)-mb%mp(2)) < ndig) return
      if (abs(ma%mp(2)-mb%mp(2)) > ndig+1) then
          kflag = 1
          return
      endif

      n2 = ndig + 4
      do j = ndig+2, 1, -1
         if (mwa%mp(j) /= ma%mp(j)) return
      enddo
      kflag = 1

      return
      end subroutine fmaddn

      subroutine fmaddp(ma, mb, nguard)

!  Internal addition routine.  mwa = ma + mb
!  The arguments are such that ma >= mb >= 0.

!  nguard is the number of guard digits being carried.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: nguard
      intent (in) :: ma, mb, nguard

      real (kind(1.0d0)) :: mr
      double precision :: err
      integer :: j, kl, ksh, n2

      ksh = ma%mp(2) - mb%mp(2)
      n2 = min(2+ksh, 2+ndig)
      do j = 1, n2
         mwa%mp(j) = ma%mp(j)
      enddo

!             Add.

      if (ksh < ndig) then
          do j = 3+ksh, ndig+2
             mwa%mp(j) = ma%mp(j) + mb%mp(j-ksh)
          enddo
          if (ksh > 0) then
              n2 = min(ndig+2+ksh, ndig+2+nguard)
              do j = ndig+3, n2
                 mwa%mp(j) = mb%mp(j-ksh)
              enddo
          endif
          if (ndig+2+ksh < ndig+2+nguard) then
              do j = ndig+3+ksh, ndig+2+nguard
                 mwa%mp(j) = 0
              enddo
          endif
      else if (ksh > ndig) then
          if (kround == 1) then
              mwa%mp(ndig+3) = 0
              kflag = 1
              return
          endif
          n2 = min(2+ksh, ndig+2+nguard)
          do j = ndig+3, n2
             mwa%mp(j) = 0
          enddo
          if (3+ksh <= ndig+2+nguard) then
              n2 = min(ndig+2+ksh, ndig+2+nguard)
              do j = 3+ksh, n2
                 mwa%mp(j) = mb%mp(j-ksh)
              enddo
          endif
          if (ndig+2+ksh < ndig+2+nguard) then
              do j = ndig+2+ksh, ndig+2+nguard
                 mwa%mp(j) = 0
              enddo
          endif
          if (ksh > ndig+1) then
              mwa%mp(ndig+3) = 0
              mwa%mp(ndig+4) = 1
          endif
          kflag = 1
      else if (ksh == ndig) then
          n2 = min(ndig+2+ksh, ndig+2+nguard)
          do j = ndig+3, n2
             mwa%mp(j) = mb%mp(j-ksh)
          enddo
          if (n2 < ndig+2+nguard) then
              do j = n2+1, ndig+2+nguard
                 mwa%mp(j) = 0
              enddo
          endif
      endif

!             Normalize any digits >= mbase.

      if (ksh < ndig) then
          do j = ndig+2, 4, -1
             if (mwa%mp(j) >= mbase) then
                 mwa%mp(j) = mwa%mp(j) - mbase
                 mwa%mp(j-1) = mwa%mp(j-1) + 1
             endif
          enddo
      endif

!             If the first digit (mwa%mp(3)) is bigger than mbase, shift right one digit
!             and adjust the exponent.

      if (mwa%mp(3) >= mbase) then
          do j = ndig+2+nguard, 4, -1
             mwa%mp(j) = mwa%mp(j-1)
          enddo
          mwa%mp(4) = mwa%mp(4) - mbase
          mwa%mp(3) = 1
          mwa%mp(2) = mwa%mp(2) + 1
      endif

!             Round the result.

      if (ncall >= 1) then
          kl = min(nguard, int(3*dlogtn/dlogmb + 2.5))
          err = 0
          do j = kl, 1, -1
             err = (err + mwa%mp(j+ndig+2)) / mbase
          enddo
          if ( (kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
               (kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) kround_retry = kround_retry + 1
      endif
      mr = 2*mwa%mp(ndig+3) + 1
      if (kround == -1 .or. kround == 2) then
          call fmrnd(mwa, ndig, nguard, 0)
      else if (mr >= mbase) then
          if (mr-1 > mbase .and. mwa%mp(ndig+2) < mbase-1) then
              if (kround /= 0) then
                  mwa%mp(ndig+2) = mwa%mp(ndig+2) + 1
                  mwa%mp(ndig+3) = 0
              endif
          else
              call fmrnd(mwa, ndig, nguard, 0)
          endif
      endif

!             See if the result is equal to one of the input arguments.

      if (abs(ma%mp(2)-mb%mp(2)) < ndig) return
      if (abs(ma%mp(2)-mb%mp(2)) > ndig+1) then
          kflag = 1
          return
      endif

      n2 = ndig + 4
      do j = ndig+2, 1, -1
         if (mwa%mp(j) /= ma%mp(j)) return
      enddo
      kflag = 1

      return
      end subroutine fmaddp

      subroutine fmalloc(ma, n_size)

!  Allocate ma with size n_size.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: n_size
      intent (in) :: n_size
      intent (inout) :: ma

      if (.not. allocated(ma%mp)) then
          allocate(ma%mp(max(n_size, 5)), stat=k_stat)
          if (k_stat /= 0) call fmdefine_error
      else if (size(ma%mp) < max(n_size, 5)) then
          deallocate(ma%mp)
          allocate(ma%mp(max(n_size, 5)), stat=k_stat)
          if (k_stat /= 0) call fmdefine_error
      endif
      if (ndig < 3) then
          kflag = -1
          call fmwarn
      endif
      if (mbase < 2 .or. mbase > mxbase) then
          kflag = -2
          call fmwarn
      endif

      return
      end subroutine fmalloc

      subroutine fmasin(ma, mb)

!  mb = asin(ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(4), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmasin_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmasin_m1(ma, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmasin

      subroutine fmasin_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing asin(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      integer :: krndsave

      krndsave = kround
      kround = 1
      call fmequ(ma, mresult, ndsave, ndig)
      if (kround /= 1 .and. krad /= 1) then
          call fmst2m('0.5', mxy(1))
          call fmsub(mresult, mxy(1), mxy(2))
          if (mxy(2)%mp(3) == 0) then
              call fmst2m('30', mresult)
              return
          endif
          call fmadd(mresult, mxy(1), mxy(2))
          if (mxy(2)%mp(3) == 0) then
              call fmst2m('-30', mresult)
              return
          endif
      endif

!             Use asin(x) = atan(x/sqrt(1-x*x))

      call fmi2m(1, mxy(3))
      call fmsub(mxy(3), mresult, mxy(1))
      call fmadd(mxy(3), mresult, mxy(2))
      call fmmpy_r2(mxy(1), mxy(2))
      call fmsqrt_r1(mxy(2))
      call fmdiv(mresult, mxy(2), mxy(4))
      call fmatan(mxy(4), mresult)

      kround = krndsave

      return
      end subroutine fmasin_m1

      subroutine fmasin_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = asin(ma).

!  kresult = 1 is returned if a special case gives the value of asin(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j
      double precision :: xe
      logical, external :: fmcomp

      kresult = 0

      namest(ncall) = 'FMASIN   '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, mxy(1), ndsave, ndig)

      if (mxy(1)%mp(2) == munkno .and. mxy(1)%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif
      if (mxy(1)%mp(3) == 0) then
          call fmi2m(0, mresult)
          kresult = 1
          return
      endif
      call fmabs(mxy(1), mxy(3))
      call fmi2m(1, mxy(2))
      if (fmcomp(mxy(3), '==', mxy(2))) then
          if (mxy(1)%mp(1) > 0) then
              if (krad == 0) then
                  call fmi2m(90, mresult)
              else
                  call fmpi(mresult)
                  call fmdivi_r1(mresult, 2)
              endif
          else
              if (krad == 0) then
                  call fmi2m(-90, mresult)
              else
                  call fmpi(mresult)
                  call fmdivi_r1(mresult, -2)
              endif
          endif
          kresult = 1
          return
      endif
      call fmovun_xe(mxy(1), xe)
      if (xe >= 1) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif
      if (mxy(1)%mp(2) == munkno .and. mxy(1)%mp(5) < 0) then
          if (2*xe < -ndsave) then
              if (krad == 1) then
                  call fmeq(mxy(1), mresult)
              else
                  call fmmpyi(mxy(1), 180, mxy(3))
                  call fmpi(mxy(2))
                  call fmdiv(mxy(3), mxy(2), mresult)
              endif
              kresult = 1
              return
          endif
      endif
      if (mxy(1)%mp(2) == mexpun) then
          call fmeq(mxy(1), mresult)
          if (krad == 0) then
              call fmpi(mxy(1))
              call fmdiv(mresult, mxy(1), mxy(2))
              call fmmpyi(mxy(2), 180, mresult)
          endif
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (kround /= 1 .and. mxy(1)%mp(2) < -ndsave .and. krad == 1) then
          call fmsqr(mxy(1), mxy(4))
          call fmmpy(mxy(1), mxy(4), mxy(2))
          call fmdivi(mxy(2), 6, mxy(3))
          call fmadd(mxy(1), mxy(3), mresult)
          if (kflag > 0) kflag = 0
          kresult = 1
          return
      endif
      if (mxy(1)%mp(3) == 0) then
          call fmi2m(0, mresult)
          kresult = 1
          return
      endif

      return
      end subroutine fmasin_sc

      subroutine fmasinh(ma, mb)

!  mb = asinh(ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(4), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmasinh_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmasinh_m1(ma, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmasinh

      subroutine fmasinh_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing asinh(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      integer :: krndsave
      double precision :: xe

      krndsave = kround
      kround = 1
      call fmequ(ma, mxy(1), ndsave, ndig)

      call fmovun_xe(mxy(1), xe)
      if (mxy(1)%mp(3) == 0) then
          call fmi2m(0, mresult)
      else if (4.0*(xe-1) > ndig) then
          call fmmpyi(mxy(1), 2, mresult)
          if (mresult%mp(2) == mexpov) then
              if (mxy(1)%mp(1) < 0) then
                  call fmabs(mxy(1), mxy(3))
                  call fmln(mxy(3), mresult)
                  call fmlni(2, mxy(3))
                  call fmadd_r1(mresult, mxy(3))
                  call fmnegate(mresult)
              else
                  call fmln(mxy(1), mresult)
                  call fmlni(2, mxy(3))
                  call fmadd_r1(mresult, mxy(3))
              endif
          else
              if (mxy(1)%mp(1) < 0) then
                  call fmi2m(1, mxy(3))
                  call fmsqr(mresult, mxy(4))
                  call fmdiv_r2(mxy(3), mxy(4))
                  call fmabs(mresult, mxy(3))
                  call fmln(mxy(3), mresult)
                  call fmadd_r1(mresult, mxy(4))
                  call fmnegate(mresult)
              else
                  call fmi2m(1, mxy(3))
                  call fmsqr(mresult, mxy(4))
                  call fmdiv_r2(mxy(3), mxy(4))
                  call fmln(mresult, mxy(3))
                  call fmadd(mxy(3), mxy(4), mresult)
              endif
          endif
      else if (xe > 0) then
          if (mxy(1)%mp(1) < 0) then
              call fmsqr(mxy(1), mxy(3))
              call fmi2m(1, mresult)
              call fmadd_r1(mxy(3), mresult)
              call fmsqrt_r1(mxy(3))
              call fmsub_r1(mxy(3), mxy(1))
              call fmln(mxy(3), mresult)
              call fmnegate(mresult)
          else
              call fmsqr(mxy(1), mxy(3))
              call fmi2m(1, mresult)
              call fmadd_r1(mxy(3), mresult)
              call fmsqrt_r1(mxy(3))
              call fmadd_r2(mxy(1), mxy(3))
              call fmln(mxy(3), mresult)
          endif
      else
          call fmsqr(mxy(1), mxy(3))
          call fmi2m(1, mresult)
          call fmadd_r1(mxy(3), mresult)
          call fmsqrt_r1(mxy(3))
          call fmdiv_r2(mxy(1), mxy(3))
          call fmatanh(mxy(3), mresult)
      endif

      kround = krndsave

      return
      end subroutine fmasinh_m1

      subroutine fmasinh_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = asinh(ma).

!  kresult = 1 is returned if a special case gives the value of asinh(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j
      double precision :: xe

      kresult = 0

      namest(ncall) = 'FMASINH  '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, mxy(1), ndsave, ndig)

      if (mxy(1)%mp(2) == munkno .and. mxy(1)%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      call fmovun_xe(mxy(1), xe)
      if (4*xe < -ndsave) then
          call fmsqr(mxy(1), mxy(2))
          call fmmpy_r2(mxy(1), mxy(2))
          call fmdivi_r1(mxy(2), 6)
          call fmsub(mxy(1), mxy(2), mresult)
          if (kflag == 1) kflag = 0
          kresult = 1
          return
      endif

      return
      end subroutine fmasinh_sc

      subroutine fmatan(ma, mb)

!  mb = atan(ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(5), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmatan_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmatan_m(ma, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmatan

      subroutine fmatan_m(ma, mxy, mresult, ndsave)

!  Method selection for computing mresult = atan(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      real (kind(1.0d0)) :: maexp, masign
      double precision :: xe
      integer :: krndsave, kradsave, ndsv, nmethd

      krndsave = kround
      kround = 1
      ndig = ndig + ndig/100
      call fmequ(ma, mxy(3), ndsave, ndig)
      if (kround /= 1 .and. krad /= 1) then
          call fmi2m(1, mxy(1))
          call fmsub(mxy(3), mxy(1), mxy(2))
          if (mxy(2)%mp(3) == 0) then
              call fmst2m('45', mresult)
              kround = krndsave
              return
          endif
          call fmadd(mxy(3), mxy(1), mxy(2))
          if (mxy(2)%mp(3) == 0) then
              call fmst2m('-45', mresult)
              kround = krndsave
              return
          endif
      endif

!             If ma >= 1 work with 1/ma.

      call fmovun_xe(mxy(3), xe)
      maexp = xe
      masign = ma%mp(1)
      mxy(3)%mp(1) = 1
      if (maexp >= 1) then
          call fmi2m(1, mxy(5))
          call fmdiv_r2(mxy(5), mxy(3))
      endif

      kradsave = krad
      krad = 1

!             In case pi has not been computed at the current precision and will be needed here,
!             get it to full precision first to avoid repeated calls at increasing precision during
!             Newton iteration.

      if (maexp >= 1 .or. kradsave == 0) then
          if (mbspi /= mbase .or. ndigpi < ndig) then
              ndsv = ndig
              ndig = ndig + 2
              call fmpi(mxy(5))
              ndig = ndsv
          endif
      endif

      nmethd = 1
      if (ndig*alogmt > 2000) nmethd = 2
      call fmovun_xe(mxy(3), xe)
      if (xe < -ndsave) nmethd = 1

      if (nmethd == 1) then
          call fmatan_m1(mxy, mresult)
      else
          call fmatan_m2(mxy, mresult)
      endif

!             if ma >= 1 use pi/2 - atan(1/ma)

      if (maexp >= 1) then
          call fmpi(mxy(5))
          call fmdivi(mxy(5), 2, mxy(4))
          call fmsub_r2(mxy(4), mresult)
      endif

!             Convert to degrees if necessary.

      krad = kradsave
      if (krad == 0) then
          call fmmpyi_r1(mresult, 180)
          call fmpi(mxy(5))
          call fmdiv_r1(mresult, mxy(5))
      endif
      if (masign < 0) call fmnegate(mresult)

      if (kflag == 1) kflag = 0

      kround = krndsave

      return
      end subroutine fmatan_m

      subroutine fmatan_m1(mxy, mresult)

!  Method 1 for computing atan(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(5), mresult

      intent (inout) :: mxy, mresult

      double precision :: x, xe, ye
      real (kind(1.0d0)) :: maxv
      integer :: j, j2, k, k2, kl, ktwo, ndsav1, nterm
      type(multi), save :: mjsums(ljsums)

!             Method 1.  Reduce the argument and use the Taylor series.
!                        Atan(x) = x - x**3 / 3 + x**5 / 5 - ...

      k2 = max(2, int(0.67*(ndig*alogmt)**0.3333 + 0.4))
      k2 = max(k2, 3)
      call fmovun_xe(mxy(3), xe)
      if (xe <= -ndig/3) then
          k2 = 0
      else
          if (xe*dlogmb < log(2.0d0**(-k2))) then
              k2 = 0
          else
              call fmm2dp(mxy(3), x)
              k = k2 + 1
              do j = 0, k
                 if (x < 0.375d0/2.0d0**(j)) then
                     k2 = k2 - 1
                     if (k2 <= 0) exit
                 endif
              enddo
          endif
      endif
      call fmeq(mxy(3), mxy(1))
      call fmi2m(1, mxy(4))
      do j = 1, k2
         call fmsqr(mxy(1), mxy(2))
         call fmadd_r2(mxy(4), mxy(2))
         call fmsqrt_r1(mxy(2))
         call fmsub_r1(mxy(2), mxy(4))
         call fmdiv_r2(mxy(2), mxy(1))
      enddo

      j2 = int(0.96*(ndig*alogmt)**0.3333 - 1.7)
      j2 = max(2, min(j2+mod(j2, 2), ljsums))

!             Split into j2 concurrent sums and reduce ndig while computing each term in the sum
!             as the terms get smaller.

      nterm = 1
      do j = 1, j2
         if (nterm > 1) then
             call fmcsdivi(mxy(1), nterm, mjsums(j))
         else
             call fmeq(mxy(1), mjsums(j))
         endif
         nterm = nterm + 2
      enddo
      ndsav1 = ndig
      call fmeq(mxy(1), mxy(4))
      call fmsqr_r1(mxy(1))
      call fmovun_xe(mxy(1), xe)
      if (xe >= -ndig) then
          call fmipwr(mxy(1), j2, mxy(2))
          kl = 1
          do while (kl == 1)
             call fmcsmpy_r1(mxy(4), mxy(2))
             do j = 1, j2
                call fmcsdivi(mxy(4), nterm, mresult)
                ndig = ndsav1
                call fmcsaddnn_r1(mjsums(j), mresult)
                if (kflag /= 0) then
                    kl = 0
                    exit
                endif
                call fmovun_xe(mjsums(j), xe)
                call fmovun_xe(mresult, ye)
                ndig = ndsav1 - int(xe-ye)
                if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                nterm = nterm + 2
             enddo
          enddo
      endif

!             Put the j2 separate sums back together.

      kflag = 0
      call fmcsnsums(j2, mjsums)
      call fmeq(mjsums(j2), mresult)
      call fmnegate(mxy(1))
      do j = 2, j2
         call fmcsmpy_r1(mresult, mxy(1))
         call fmadd_r1(mresult, mjsums(j2-j+1))
      enddo

!             Reverse the argument reduction.

      ktwo = 1
      maxv = mxbase/2
      do j = 1, k2
         ktwo = 2*ktwo
         if (ktwo > maxv) then
             call fmcsmpyi_r1(mresult, ktwo)
             ktwo = 1
         endif
      enddo
      if (ktwo > 1) call fmcsmpyi_r1(mresult, ktwo)

      return
      end subroutine fmatan_m1

      subroutine fmatan_m2(mxy, mresult)

!  Method 2 for computing atan(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(5), mresult
      intent (inout) :: mxy, mresult

      double precision :: x, xe
      integer :: j, kst, nstack(49)

!             Method 2.  Newton iteration.

      call fmi2m(0, mxy(1))
      call fmi2m(0, mxy(2))
      call fmi2m(0, mxy(4))

      call fmovun_xe(mxy(3), xe)
      if (xe*dlogmb < -46) then
          call fmeq(mxy(3), mresult)
      else
          call fmm2dp(mxy(3), x)
          x = atan(x)
          call fmdpm(x, mresult)
      endif
      call fmdig(nstack, kst)

!             Newton iteration.

      do j = 1, kst
         ndig = nstack(j)
         call fmsin(mresult, mxy(4))
         call fmovun_xe(mresult, xe)
         if (2*xe <= -ndig) then
             call fmi2m(1, mxy(2))
             call fmsub(mxy(2), mxy(4), mxy(1))
             call fmadd_r1(mxy(2), mxy(4))
             call fmmpy_r1(mxy(1), mxy(2))
             call fmsqrt(mxy(1), mxy(2))
             call fmdiv_r2(mxy(4), mxy(2))
             call fmsub_r1(mxy(2), mxy(3))
             call fmmpy_r2(mxy(1), mxy(2))
             call fmsub_r1(mresult, mxy(2))
         else
             call fmsqr(mxy(4), mxy(1))
             call fmi2m(1, mxy(2))
             call fmsub_r2(mxy(2), mxy(1))
             call fmsqrt(mxy(1), mxy(2))
             call fmdiv_r2(mxy(4), mxy(2))
             call fmsub_r1(mxy(2), mxy(3))
             call fmmpy_r2(mxy(1), mxy(2))
             call fmsub_r1(mresult, mxy(2))
         endif
      enddo

      return
      end subroutine fmatan_m2

      subroutine fmatan_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = atan(ma).

!  kresult = 1 is returned if a special case gives the value of atan(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j
      double precision :: xe
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMATAN   '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      call fmovun_xe(malocal, xe)
      if (2*xe < -ndsave) then
          kflag = 0
          call fmeq(malocal, mxy(1))
          if (krad == 1) then
              call fmeq(mxy(1), mxy(3))
              if (kround /= 1) then
                  call fmipwr(mxy(1), 3, mxy(3))
                  call fmdivi_r1(mxy(3), 6)
                  call fmsub_r2(mxy(1), mxy(3))
              endif
          else
              call fmi2m(180, mxy(2))
              call fmpi(mxy(3))
              call fmdiv_r2(mxy(2), mxy(3))
              call fmmpy_r2(mxy(1), mxy(3))
          endif
          call fmeq(mxy(3), mresult)
          kresult = 1
          return
      endif

      if (2*xe > ndig) then
          call fmeq(malocal, mxy(1))
          if (krad == 1) then
              call fmi2m(1, mxy(2))
              call fmdiv_r2(mxy(2), mxy(1))
              call fmpi(mxy(2))
              mxy(2)%mp(1) = malocal%mp(1)
              call fmdivi_r1(mxy(2), 2)
              call fmsub(mxy(2), mxy(1), mxy(3))
          else
              call fmpi(mxy(3))
              call fmi2m(180, mxy(2))
              call fmdiv_r2(mxy(2), mxy(3))
              call fmdiv_r1(mxy(3), mxy(1))
              call fmi2m(90, mxy(2))
              mxy(2)%mp(1) = malocal%mp(1)
              call fmsub_r2(mxy(2), mxy(3))
          endif
          call fmeq(mxy(3), mresult)
          kresult = 1
          return
      endif

      return
      end subroutine fmatan_sc

      subroutine fmatan2(ma, mb, mc)

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      call fmatn2(ma, mb, mc)

      return
      end subroutine fmatan2

      subroutine fmatanh(ma, mb)

!  mb = atanh(ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(4), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmatanh_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmatanh_m(ma, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmatanh

      subroutine fmatanh_m(ma, mxy, mresult, ndsave)

!  Method selection for computing atanh(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      double precision :: x, xe
      integer :: krndsave, nmethd

      krndsave = kround
      kround = 1
      ndig = ndig + ndig/100
      call fmequ(ma, mxy(3), ndsave, ndig)
      mxy(3)%mp(1) = 1

      nmethd = 1
      call fmm2dp(mxy(3), x)
      call fmovun_xe(mxy(3), xe)
      if (xe >= -ndig) then
          if (abs(x) >= 1234.0/(ndig*alogmt)**2) nmethd = 2
      endif

      if (nmethd == 1) then
          call fmatanh_m1(mxy, mresult)
      else
          call fmatanh_m2(mxy, mresult)
      endif

      if (ma%mp(1) < 0) mresult%mp(1) = -1

      kround = krndsave

      return
      end subroutine fmatanh_m

      subroutine fmatanh_m1(mxy, mresult)

!  Method 1 for computing atanh(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(4), mresult

      intent (inout) :: mxy, mresult

      double precision :: x, xe, ye
      real (kind(1.0d0)) :: maxv
      integer :: j, j2, k, k2, kl, ktwo, ndsav1, nterm
      type(multi), save :: mjsums(ljsums)

!             Method 1.  Reduce the argument and use the Taylor series.
!                        Atanh(x) = x + x**3 / 3 + x**5 / 5 + ...

      k2 = max(2, int(0.67*(ndig*alogmt)**0.3333 + 0.4))
      k2 = max(k2, 3)
      call fmm2dp(mxy(3), x)
      call fmovun_xe(mxy(3), xe)
      if (xe <= -ndig/3) then
          k2 = 0
      else
          if (xe*dlogmb < log(2.0d0**(-k2))) then
              k2 = 0
          else
              k = k2 + 1
              do j = 0, k
                 if (x < 0.375d0/2.0d0**(j)) then
                     k2 = k2 - 1
                     if (k2 <= 0) exit
                 endif
              enddo
          endif
      endif
      call fmeq(mxy(3), mxy(1))
      call fmi2m(1, mxy(4))
      do j = 1, k2
         call fmsqr(mxy(1), mxy(2))
         call fmsub_r2(mxy(4), mxy(2))
         call fmsqrt_r1(mxy(2))
         call fmsub_r2(mxy(4), mxy(2))
         call fmdiv_r2(mxy(2), mxy(1))
      enddo

      j2 = int(0.96*(ndig*alogmt)**0.3333 - 1.7)
      j2 = max(1, min(j2, ljsums))

!             Split into j2 concurrent sums and reduce ndig while computing each term in the sum
!             as the terms get smaller.

      nterm = 1
      do j = 1, j2
         if (nterm > 1) then
             call fmcsdivi(mxy(1), nterm, mjsums(j))
         else
             call fmeq(mxy(1), mjsums(j))
         endif
         nterm = nterm + 2
      enddo
      ndsav1 = ndig
      call fmeq(mxy(1), mxy(4))
      call fmsqr_r1(mxy(1))
      call fmovun_xe(mxy(1), xe)
      if (xe >= -ndig) then
          call fmipwr(mxy(1), j2, mxy(2))
          kl = 1
          do while (kl == 1)
             call fmcsmpy_r1(mxy(4), mxy(2))
             do j = 1, j2
                call fmcsdivi(mxy(4), nterm, mresult)
                ndig = ndsav1
                call fmcsaddnn_r1(mjsums(j), mresult)
                if (kflag /= 0) then
                    kl = 0
                    exit
                endif
                call fmovun_xe(mjsums(j), xe)
                call fmovun_xe(mresult, ye)
                ndig = ndsav1 - int(xe-ye)
                if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                nterm = nterm + 2
             enddo
          enddo
      endif

!             Put the j2 separate sums back together.

      kflag = 0
      call fmcsnsums(j2, mjsums)
      call fmeq(mjsums(j2), mresult)
      do j = 2, j2
         call fmcsmpy_r1(mresult, mxy(1))
         call fmadd_r1(mresult, mjsums(j2-j+1))
      enddo

!             Reverse the argument reduction.

      ktwo = 1
      maxv = mxbase/2
      do j = 1, k2
         ktwo = 2*ktwo
         if (ktwo > maxv) then
             call fmcsmpyi_r1(mresult, ktwo)
             ktwo = 1
         endif
      enddo
      if (ktwo > 1) call fmcsmpyi_r1(mresult, ktwo)

      return
      end subroutine fmatanh_m1

      subroutine fmatanh_m2(mxy, mresult)

!  Method 2 for computing atanh(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(4), mresult
      intent (inout) :: mxy, mresult

      integer :: iextra

!             Method 2.  Atanh(x) =  ln( (1+x) / (1-x) ) / 2

      iextra = -mxy(3)%mp(2)
      if (abs(mxy(3)%mp(2)) >= mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(3), ndig, ndig+iextra)
          ndig = ndig + iextra
      endif
      call fmi2m(1, mxy(1))
      call fmadd(mxy(1), mxy(3), mxy(4))
      call fmsub(mxy(1), mxy(3), mresult)
      call fmdiv(mxy(4), mresult, mxy(2))
      call fmln(mxy(2), mresult)
      call fmdivi_r1(mresult, 2)

      return
      end subroutine fmatanh_m2

      subroutine fmatanh_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = atanh(ma).

!  kresult = 1 is returned if a special case gives the value of atanh(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j
      double precision :: xe
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMATANH  '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      call fmovun_xe(malocal, xe)
      if (xe >= 1) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif
      if (malocal%mp(3) == 0) then
          call fmi2m(0, mresult)
          kresult = 1
          return
      endif
      if (2*xe < -ndsave) then
          call fmeq(malocal, mxy(1))
          if (kround /= 1) then
              call fmipwr(mxy(1), 3, mxy(2))
              call fmdivi_r1(mxy(2), 3)
              call fmadd_r1(mxy(1), mxy(2))
          endif
          call fmeq(mxy(1), mresult)
          kflag = 0
          kresult = 1
          return
      endif

      return
      end subroutine fmatanh_sc

      subroutine fmatn2(ma, mb, mc)

!  mc = atan2(ma, mb)

!  mc is returned as the angle between -pi and pi (or -180 and 180 if degree mode is selected) for
!  which tan(mc) = ma/mb.  mc is an angle for the point (mb,ma) in polar coordinates.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(5), mresult

      call fmalloc(mc, ndig+2)
      call fmenter2(ma, mb, kovun, mxsave, ndsave)
      call fmatn2_sc(ma, mb, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mc, kovun, mxsave, ndsave)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmatn2_m1(ma, mb, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mc, kovun, mxsave, ndsave)

      return
      end subroutine fmatn2

      subroutine fmatn2_m1(ma, mb, mxy, mresult, ndsave)

!  Method 1 for computing atan2(ma,mb).

      use fmvals
      implicit none

      type(multi) :: ma, mb, mxy(5), mresult
      integer :: ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult

      integer :: jquad, krndsave

      krndsave = kround
      kround = 1
      call fmequ(ma, mxy(1), ndsave, ndig)
      call fmequ(mb, mxy(2), ndsave, ndig)

!             Determine the quadrant for the result, then use fmatan.

      jquad = 1
      if (ma%mp(1) >= 0 .and. mb%mp(1) < 0) jquad = 2
      if (ma%mp(1)  < 0 .and. mb%mp(1) < 0) jquad = 3
      if (ma%mp(1)  < 0 .and. mb%mp(1) > 0) jquad = 4

      call fmdiv(mxy(1), mxy(2), mxy(4))
      mxy(4)%mp(1) = 1
      call fmatan(mxy(4), mresult)

      if (jquad == 2 .or. jquad == 3) then
          if (krad == 0) then
              call fmi2m(180, mxy(3))
              call fmsub_r2(mxy(3), mresult)
          else
              call fmpi(mxy(3))
              call fmsub_r2(mxy(3), mresult)
          endif
      endif

      if (jquad == 3 .or. jquad == 4) call fmnegate(mresult)

      kround = krndsave

      return
      end subroutine fmatn2_m1

      subroutine fmatn2_sc(ma, mb, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = atan2(ma,mb).

!  kresult = 1 is returned if a special case gives the value of atan2(ma,mb).

      use fmvals
      implicit none

      type(multi) :: ma, mb, mxy(5), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult, kresult

      type(multi), save :: malocal, mblocal
      real (kind(1.0d0)) :: mxexp1
      double precision :: a_xe, b_xe, xe, ye
      integer :: j, kl

      kresult = 0

      namest(ncall) = 'FMATN2   '
      j = ndig
      ndig = ndsave
      call fmntr_inp2(ma, mb)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)
      call fmequ(mb, mblocal, ndsave, ndig)

      if ((malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) .or.  &
          (mblocal%mp(2) == munkno .and. mblocal%mp(5) >= 0)) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      if ((abs(malocal%mp(2)) >= mexpov .or. abs(mblocal%mp(2)) >= mexpov) .and.  &
          mblocal%mp(3) /= 0) then
          call fmovun_xe(malocal, a_xe)
          call fmovun_xe(mblocal, b_xe)
          call fmeq(malocal, mxy(4))
          call fmeq(mblocal, mxy(5))
          call fmdiv(mxy(4), mxy(5), mxy(1))
          if (abs(mxy(1)%mp(2)) >= mexpov) then
              if (a_xe - b_xe > ndig) then
                  call fmi2m(1, mxy(1))
                  mxy(1)%mp(2) = 2*ndig
                  mxy(1)%mp(1) = malocal%mp(1) * mblocal%mp(1)
              else if (b_xe - a_xe > ndig .and. mblocal%mp(1) < 0) then
                  call fmi2m(1, mxy(1))
                  mxy(1)%mp(2) = -2*ndig
                  mxy(1)%mp(1) = malocal%mp(1) * mblocal%mp(1)
              endif
          endif
          call fmatan(mxy(1), mxy(2))
          if (mblocal%mp(1) > 0) then
              call fmeq(mxy(2), mresult)
          else if (malocal%mp(1) > 0) then
              if (krad == 1) then
                  call fmpi(mxy(3))
              else
                  call fmi2m(180, mxy(3))
              endif
              call fmadd(mxy(2), mxy(3), mresult)
          else
              if (krad == 1) then
                  call fmpi(mxy(3))
              else
                  call fmi2m(180, mxy(3))
              endif
              call fmsub(mxy(2), mxy(3), mresult)
          endif
          if (( mresult%mp(2) /= mexpun .and. mresult%mp(2) < 0 ) .or.  &
              mresult%mp(2) == munkno) then
              if (mresult%mp(2) == munkno .and. mresult%mp(5) <= 0) then
                  kflag = -4
              else
                  kflag = -4
                  call fmunknown(mresult)
              endif
          endif
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (kround /= 1 .and. mblocal%mp(1) >= 0 .and. krad == 1) then
          call fmdiv(malocal, mblocal, mxy(1))
          call fmovun_xe(mxy(1), xe)
          if (xe < -ndsave) then
              if (mxy(1)%mp(2) == mexpun) then
                  call fmeq(mxy(1), mxy(3))
              else
                  call fmsqr(mxy(1), mxy(2))
                  call fmmpy_r1(mxy(2), mxy(1))
                  call fmdivi_r1(mxy(2), 3)
                  if (mxy(2)%mp(2) /= mexpun) then
                      call fmsub(mxy(1), mxy(2), mxy(3))
                  else if (mxy(1)%mp(1) < 0 .and. (kround == 2 .or. kround == 0)) then
                      kl = mxy(1)%mp(2)
                      mxy(1)%mp(2) = 0
                      call fmulp(mxy(1), mxy(2))
                      call fmsub(mxy(1), mxy(2), mxy(4))
                      mxy(4)%mp(2) = kl + mxy(4)%mp(2)
                      call fmeq(mxy(4), mxy(3))
                  else if (mxy(1)%mp(1) >= 0 .and. (kround == -1 .or. kround == 0)) then
                      kl = mxy(1)%mp(2)
                      mxy(1)%mp(2) = 0
                      call fmulp(mxy(1), mxy(2))
                      call fmsub(mxy(1), mxy(2), mxy(4))
                      mxy(4)%mp(2) = kl + mxy(4)%mp(2)
                      call fmeq(mxy(4), mxy(3))
                  else
                      call fmeq(mxy(1), mxy(3))
                  endif
              endif
              kflag = 0
              call fmeq(mxy(3), mresult)
              kresult = 1
              return
          endif
      endif
      if (malocal%mp(2) == munkno .or. mblocal%mp(2) == munkno .or.  &
         (malocal%mp(3) == 0 .and. mblocal%mp(3) == 0)) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif
      if (kround /= 1 .and. krad /= 1) then
          if (malocal%mp(2) == mexpun) then
              call fmtiny(mxy(3))
          else if (malocal%mp(2) == mexpov) then
              call fmbig(mxy(3))
          else
              call fmeq(malocal, mxy(3))
          endif
          mxy(3)%mp(1) = malocal%mp(1)
          if (mblocal%mp(2) == mexpun) then
              call fmtiny(mxy(4))
          else if (mblocal%mp(2) == mexpov) then
              call fmbig(mxy(4))
          else
              call fmeq(mblocal, mxy(4))
          endif
          mxy(4)%mp(1) = mblocal%mp(1)
          call fmovun_xe(mxy(3), xe)
          call fmovun_xe(mxy(4), ye)
          if (xe > ye+ndig) then
              if (malocal%mp(1) > 0) then
                  call fmdiv(mxy(4), mxy(3), mresult)
                  call fmmpyi_r1(mresult, 180)
                  call fmpi(mxy(3))
                  call fmdiv(mresult, mxy(3), mxy(4))
                  call fmi2m(90, mxy(3))
                  call fmsub(mxy(3), mxy(4), mresult)
                  kresult = 1
                  return
              endif
              if (malocal%mp(1) < 0) then
                  call fmdiv(mxy(4), mxy(3), mresult)
                  call fmmpyi_r1(mresult, 180)
                  call fmpi(mxy(3))
                  call fmdiv(mresult, mxy(3), mxy(4))
                  call fmi2m(-90, mxy(3))
                  call fmsub(mxy(3), mxy(4), mresult)
                  kresult = 1
                  return
              endif
          endif
          if (ye > xe+ndig .and. mblocal%mp(1) < 0) then
              if (malocal%mp(1) > 0) then
                  call fmdiv(mxy(3), mxy(4), mresult)
                  call fmmpyi_r1(mresult, 180)
                  call fmpi(mxy(3))
                  call fmdiv(mresult, mxy(3), mxy(4))
                  call fmi2m(180, mxy(3))
                  call fmadd(mxy(3), mxy(4), mresult)
                  kresult = 1
                  return
              endif
              if (malocal%mp(1) < 0) then
                  call fmdiv(mxy(3), mxy(4), mresult)
                  call fmmpyi_r1(mresult, 180)
                  call fmpi(mxy(3))
                  call fmdiv(mresult, mxy(3), mxy(4))
                  call fmi2m(-180, mxy(3))
                  call fmadd(mxy(3), mxy(4), mresult)
                  kresult = 1
                  return
              endif
          endif
      endif

      if (mblocal%mp(3) == 0 .and. malocal%mp(1) > 0) then
          if (krad == 0) then
              call fmi2m(90, mresult)
          else
              call fmpi(mresult)
              call fmdivi_r1(mresult, 2)
          endif
          kresult = 1
          return
      endif

      if (mblocal%mp(3) == 0 .and. malocal%mp(1) < 0) then
          if (krad == 0) then
              call fmi2m(-90, mresult)
          else
              call fmpi(mresult)
              call fmdivi_r1(mresult, -2)
          endif
          kresult = 1
          return
      endif

      mxexp1 = int(mxexp2/2.01d0)
      call fmovun_xe(mblocal, xe)
      if (malocal%mp(2) == mexpov .and. xe < mxexp1-ndsave-2) then
          if (krad == 0) then
              call fmi2m(90, mresult)
          else
              call fmpi(mresult)
              call fmdivi_r1(mresult, 2)
          endif
          if (malocal%mp(1) < 0) mresult%mp(1) = -1
          kresult = 1
          return
      endif

      if (malocal%mp(2) == mexpun .and. -xe < mxexp1-ndsave-2 .and.  &
                                 mblocal%mp(1) < 0) then
          if (krad == 0) then
              call fmi2m(180, mresult)
          else
              call fmpi(mresult)
          endif
          if (malocal%mp(1) < 0) mresult%mp(1) = -1
          kresult = 1
          return
      endif

      call fmovun_xe(malocal, xe)
      if (mblocal%mp(2) == mexpov .and. xe < mxexp1-ndsave-2 .and.  &
                                mblocal%mp(1) < 0) then
          if (krad == 0) then
              call fmi2m(180, mresult)
          else
              call fmpi(mresult)
          endif
          if (malocal%mp(1) < 0) mresult%mp(1) = -1
          kresult = 1
          return
      endif

      if (mblocal%mp(2) == mexpun .and. malocal%mp(3) == 0) then
          if (mblocal%mp(1) < 0) then
              if (krad == 0) then
                  call fmi2m(180, mresult)
              else
                  call fmpi(mresult)
              endif
          else
              call fmi2m(0, mresult)
          endif
          kresult = 1
          return
      endif

      if (mblocal%mp(2) == mexpun .and. -xe < mxexp1-ndsave-2) then
          if (krad == 0) then
              call fmi2m(90, mresult)
          else
              call fmpi(mresult)
              call fmdivi_r1(mresult, 2)
          endif
          if (malocal%mp(1) < 0) mresult%mp(1) = -1
          kresult = 1
          return
      endif

      return
      end subroutine fmatn2_sc

      subroutine fmber2(n, ma, mb)

!  Internal routine for small Bernoulli numbers.

!  mb = ma*b(n) for n an even integer between 2 and 26.

      use fmvals
      implicit none

      integer :: n
      type(multi) :: ma, mb
      intent (in) :: n, ma
      intent (inout) :: mb

      integer :: n2
      integer :: nbtop(13) = (/  &
              1,   1,  1,   1,  5, -691, 7, -3617, 43867, -174611, 854513, -236364091, 8553103 /)
      integer :: nbbot(13) = (/  &
              6, -30, 42, -30, 66, 2730, 6,   510,   798,     330,    138,       2730,       6 /)

      if (n <= 0) then
          call fmeq(ma, mb)
          return
      else if (n == 1) then
          call fmdivi(ma, -2, mb)
          return
      else if (mod(n, 2) == 1) then
          call fmi2m(0, mb)
          return
      endif

      n2 = n/2

      if (n <= 26) then
          if (nbtop(n2) == 1) then
              call fmdivi(ma, nbbot(n2), mb)
          else
              call fmmpyi(ma, nbtop(n2), mb)
              call fmdivi_r1(mb, nbbot(n2))
          endif
      endif

      return
      end subroutine fmber2

      subroutine fmbern(n, ma, mb)

!  mb = ma*b(n)      b(n) is the nth Bernoulli number.  (Internal routine used by special functions)

      use fmvals
      implicit none

      integer :: n
      type(multi) :: ma, mb
      intent (in) :: n, ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(5), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmbern_sc(n, ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call fmbern_m1(n, ma, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmbern

      subroutine fmbern_m1(n, ma, mxy, mresult, ndsave)

!  Method 1 for computing ma*b(n).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: n, ndsave
      intent (in) :: n, ma, ndsave
      intent (inout) :: mxy, mresult

      double precision :: u, uj, x, b
      real (kind(1.0d0)) :: mnexp
      integer :: intndg, j, j2, k, l, large, larged, n2, nbot, ndiv, ndp,  &
                 ndsav1, ndsav2, nextd, nextn, nmpy, nstart, ntd, ntn, ntop, nx

      call fmequ(ma, mxy(5), ndsave, ndig)

!             See if b(n) has already been computed with sufficient precision.

      n2 = n/2
      if (mbase == mbsbrn) then
          if (n <= numbrn) then
              if (allocated(mbern(n2)%mp)) then
                  if (size(mbern(n2)%mp) >= ndig+2) then
                      if (ndbern(n2) >= ndig) then
                          call fmmpy(mbern(n2), mxy(5), mresult)
                          return
                      endif
                  endif
              endif
          endif
      else
          do j = 28, numbrn, 2
             ndbern(j/2) = 0
          enddo
          numbrn = 0
      endif

!             Compute more Bernoulli numbers.

      x = 1.0d0
      b = dble(mbase)
      ndp = 0
      do j = 1, 80
         x = x/b
         if ((1.0d0+x) <= 1.0d0) then
             ndp = j-1
             if (ndig <= ndp) x = 4.0d0*dppi*dppi
             exit
         endif
      enddo
      intndg = int(alogmx/alogmb + 1.0)
      nx = int(dble(ndig)*dlogmb/dlogtw + 2.0d0)
      nstart = 28
      if (mbsbrn == mbase .and. numbrn >= 28) then
          nstart = numbrn + 2
          do j = 28, numbrn, 2
             if (size(mbern(j/2)%mp) < ndig+3 .or. ndbern(j/2) < ndig) then
                 nstart = j
                 exit
             endif
          enddo
      endif

      do j = nstart, n, 2

!             Check to see if j is large enough so that the formula
!             b(j) = -b(j-2)*(j-1)*j/(2*pi)**2 can be used.

         if (j >= nx .and. ndig <= ndp .and. j > 28) then
             j2 = j/2
             mnexp = mbern(j2-1)%mp(2)
             mbern(j2-1)%mp(2) = 0
             call fmm2dp(mbern(j2-1), u)
             mbern(j2-1)%mp(2) = mnexp
             uj = j
             u = -u*(uj*uj-uj)/x
             numbrn = j
             mbsbrn = mbase
             call fmdpm(u, mbern(j2))
             mbern(j2)%mp(2) = mbern(j2)%mp(2) + mnexp
             ndbern(j2) = ndig
             cycle
         endif

         if (j >= nx .and. j > 28) then
             large = int(intmax/j)
             j2 = j/2
             numbrn = j
             mbsbrn = mbase
             call fmpi(mxy(2))
             call fmsqr_r1(mxy(2))
             if (mod(j, 4) == 0 .or. mod(j, 4) == 1) then
                 if (j < large) then
                     l = -(j*j-j)/4
                     call fmcsmpyi(mbern(j2-1), l, mxy(3))
                 else
                     call fmcsmpyi(mbern(j2-1), -j, mxy(3))
                     call fmcsmpyi_r1(mxy(3), j-1)
                     call fmcsdivi_r1(mxy(3), 4)
                 endif
             else
                 if (j < large) then
                     l = -(j*j-j)
                     call fmcsmpyi(mbern(j2-1), l, mxy(3))
                     call fmcsdivi_r1(mxy(3), 4)
                 else
                     call fmcsmpyi(mbern(j2-1), -j, mxy(3))
                     call fmcsmpyi_r1(mxy(3), j-1)
                     call fmcsdivi_r1(mxy(3), 4)
                 endif
             endif
             call fmcsdiv(mxy(3), mxy(2), mbern(j2))
             ndbern(j2) = ndig
             cycle
         endif

!             Use the recurrence involving a sum of binomial coefficients times previous b's.

         ntop = j + 3
         nbot = j - 6
         large = int(intmax/ntop)
         larged = min(large, int(mxbase))
         call fmcmbi(ntop, nbot, mxy(2))
         if (nbot <= 26) then
             call fmber2(nbot, mxy(2), mxy(3))
         else
             call fmmpy(mbern(nbot/2), mxy(2), mxy(3))
         endif
         ndsav1 = ndig
         do nbot = j-12, 0, -6
            ntn = nbot + 6
            ntd = ntop - nbot - 5
            nextn = ntn
            nextd = ntd
            if (nbot >= 6) then
                ndsav2 = ndig
                do k = 1, 5
                   nextn = nextn - 1
                   nextd = nextd + 1
                   nmpy = ntn*nextn
                   ndiv = ntd*nextd
                   if (nmpy <= large .and. ndiv <= larged) then
                       ntn = nmpy
                       ntd = ndiv
                   else
                       call fmgcdi(nmpy, ndiv)
                       if (nmpy <= large .and. ndiv <= larged) then
                           ntn = nmpy
                           ntd = ndiv
                       else
                           ndig = max(ngrd22, min(ndsav2, int(mxy(2)%mp(2))+intndg))
                           ndig = max(3, ndig)
                           call fmcsmpyi_r1(mxy(2), ntn)
                           call fmcsdivi_r1(mxy(2), ntd)
                           ntn = nextn
                           ntd = nextd
                       endif
                   endif
                enddo
                ndig = max(ngrd22, min(ndsav2, int(mxy(2)%mp(2))+intndg))
                ndig = max(3, ndig)
                call fmcsmpyi_r1(mxy(2), ntn)
                call fmcsdivi_r1(mxy(2), ntd)
                ndig = ndsav2
            else
                call fmcmbi(ntop, nbot, mxy(2))
            endif

!             Now mxy(2) is the combination ntop choose nbot.

            if (nbot <= 26) then
                call fmber2(nbot, mxy(2), mxy(4))
            else
                call fmmpy(mbern(nbot/2), mxy(2), mxy(4))
            endif
            ndig = ndsav1
            call fmcsadd_r1(mxy(3), mxy(4))
            ndig = max(ngrd22, ndsav1-int(mxy(3)%mp(2)-mxy(4)%mp(2)))
            ndig = max(3, ndig)
         enddo

         ndig = ndsav1
         if (mod(j, 6) == 4) then
             call fmi2m(ntop, mxy(1))
             call fmcsdivi(mxy(1), -6, mxy(4))
             call fmsub_r2(mxy(4), mxy(3))
         else
             call fmi2m(ntop, mxy(1))
             call fmcsdivi(mxy(1), 3, mxy(4))
             call fmsub_r2(mxy(4), mxy(3))
         endif

         j2 = j/2
         numbrn = j
         mbsbrn = mbase

         call fmcsmpyi_r1(mxy(3), 6)
         ntn = ntop*(ntop-1)
         large = int(intmax/ntop)
         if (ntn > mxbase .or. ntop > large) then
             call fmcsdivi_r1(mxy(3), ntop)
             ntn = ntop - 1
             call fmcsdivi_r1(mxy(3), ntn)
             ntn = ntop - 2
             call fmcsdivi(mxy(3), ntn, mbern(j2))
         else if (ntn > mxbase/(ntop-2) .or. ntn > large) then
             call fmcsdivi_r1(mxy(3), ntn)
             ntn = ntop - 2
             call fmcsdivi(mxy(3), ntn, mbern(j2))
         else
             ntn = ntn*(ntop-2)
             call fmcsdivi(mxy(3), ntn, mbern(j2))
         endif
         ndbern(j2) = ndig
      enddo

      call fmmpy(mbern(n2), mxy(5), mresult)

      return
      end subroutine fmbern_m1

      subroutine fmbern_sc(n, ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = ma*b(n).

!  kresult = 1 is returned if a special case gives the value of ma*b(n).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: n, kresult, ndsave
      intent (in) :: n, ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j
      type(multi), save :: malocal, mr, ms, mt

      kresult = 0

      namest(ncall) = 'FMBERN   '
      j = ndig
      ndig = ndsave
      call fmntr_inpi1(n, ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      if (n >= 2 .and. n <= 26) then
          call fmber2(n, malocal, mresult)
          kresult = 1
          return
      else if (n == 0) then
          call fmeq(malocal, mresult)
          kresult = 1
          return
      else if (n == 1) then
          call fmdivi(malocal, -2, mresult)
          kresult = 1
          return
      else if (malocal%mp(3) == 0) then
          call fmi2m(0, mresult)
          kresult = 1
          return
      else if (mod(n, 2) == 1 .or. n < 0) then
          call fmi2m(0, mresult)
          kresult = 1
          return
      endif

      if (n/2 > lmbern) then
          call fmi2m(1, ms)
          do j = 2, 10000
             call fmi2m(j, mxy(2))
             call fmipwr(mxy(2), -n, mxy(3))
             call fmcsadd_r1(ms, mxy(3))
             if (kflag == 1) exit
          enddo
          call fmi2m(0, mr)
          do j = 2, 2*lmbern, 2
             call fmi2m(n, mxy(3))
             call fmipwr(mxy(3), -(j-1), mt)
             call fmdivi_r1(mt, j)
             call fmdivi_r1(mt, j-1)
             if (j >= 2 .and. j <= 26) then
                 call fmber2(j, mt, mresult)
             else
                 call fmbern_m1(j, mt, mxy, mresult, ndsave)
             endif
             call fmadd_r1(mr, mresult)
             if (kflag == 1 .and. j > 2) exit

             if (j == 2*lmbern) then
                 kflag = -11
                 write (kw,*) ' '
                 write (kw,*) ' Too many Bernoulli numbers were needed in FMBERN.'
                 write (kw,*) ' B(', n, ') was requested, and the current maximum is B(',  &
                              2*lmbern, ').'
                 write (kw,*) ' '
                 write (kw,*) ' Array MBERN is not large enough.'
                 write (kw,*) ' '
                 call fmunknown(mresult)
                 kresult = 1
                 return
             endif
          enddo
          call fmexp(mr, mxy(3))
          call fmi2m(-1, mxy(2))
          call fmexp(mxy(2), mxy(4))
          call fmmpyi_r1(mxy(4), n)
          call fmipwr(mxy(4), n, mxy(5))
          call fmmpy(mxy(3), mxy(5), mxy(2))
          call fmpi(mxy(3))
          call fmmpyi_r1(mxy(3), 2)
          call fmmpyi_r1(mxy(3), n)
          call fmsqrt(mxy(3), mxy(4))
          call fmmpy_r1(mxy(2), mxy(4))
          call fmpi(mxy(3))
          call fmmpyi_r1(mxy(3), 2)
          call fmipwr(mxy(3), n, mxy(5))
          call fmdiv_r2(mxy(2), mxy(5))
          call fmmpy_r2(ms, mxy(5))
          call fmmpyi(mxy(5), 2, mxy(4))
          if (mod(n/2+1, 2) == 1) call fmnegate(mxy(4))

          call fmmpy(mxy(4), malocal, mresult)
          kresult = 1
          return
      endif

      return
      end subroutine fmbern_sc

      subroutine fmbernoulli(n, ma)

!  ma = b(n)  where b(n) is the nth Bernoulli number.

      use fmvals
      implicit none

      integer :: n
      type(multi) :: ma
      intent (in) :: n
      intent (inout) :: ma

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(4), mresult

      call fmalloc(ma, ndig+2)
      call fmenter0(kovun, mxsave, ndsave)
      call fmbernoulli_sc(n, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, ma, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call fmbernoulli_m1(n, mxy, mresult)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, ma, kovun, mxsave, ndsave)

      return
      end subroutine fmbernoulli

      subroutine fmbernoulli_m1(n, mxy, mresult)

!  Method 1 for computing b(n).

      use fmvals
      implicit none

      type(multi) :: mxy(4), mresult
      integer :: n
      intent (in) :: n
      intent (inout) :: mxy, mresult

      integer :: j, k
      double precision :: b

      if (ncall == 1) then
          k = int(5.0/alogmt + 2.0 + (real(ndig)*alogmt)**0.35/alogmt)
          ndig = max(ndig+k, 3)
      endif

!             For functions that sum series using Bernoulli numbers, n will normally be numbrn+2
!             here, or possibly 28 when numbrn is zero.  Check to see if this n is much larger than
!             numbrn and can be computed directly from the zeta(n) series without computing
!             and saving the intermediate Bernoulli numbers, otherwise call fmbern.

      b = ndig*log(dble(mbase))/6.91
      if (n > numbrn+100 .and. n > b) then
          call fmi2m(1, mxy(1))
          do j = 2, 10000
             call fmi2m(j, mxy(2))
             call fmipwr(mxy(2), -n, mxy(3))
             call fmcsadd_r1(mxy(1), mxy(3))
             if (kflag == 1) exit
          enddo
          call fmi2m(n, mxy(3))
          call fmfact(mxy(3), mxy(2))
          call fmmpy_r1(mxy(1), mxy(2))
          call fmmpyi_r1(mxy(1), 2*(-1)**(n/2+1))
          call fmpi(mxy(2))
          call fmmpyi_r1(mxy(2), 2)
          call fmipwr(mxy(2), n, mxy(3))
          call fmdiv(mxy(1), mxy(3), mxy(4))
      else
          call fmi2m(1, mxy(1))
          call fmbern(n, mxy(1), mxy(4))
      endif

      call fmeq(mxy(4), mresult)

      return
      end subroutine fmbernoulli_m1

      subroutine fmbernoulli_sc(n, ndsave, mresult, kresult)

!  Check for special cases for mresult = b(n).

!  kresult = 1 is returned if a special case gives the value of b(n).

      use fmvals
      implicit none

      type(multi) :: mresult
      integer :: n, kresult, ndsave
      intent (in) :: n, ndsave
      intent (inout) :: mresult, kresult

      integer :: j

      kresult = 0

      namest(ncall) = 'BERNOULLI'
      j = ndig
      ndig = ndsave
      call fmntr_inpi(n)
      ndig = j

      if ((mod(n, 2) == 1 .and. n > 2) .or. n < 0) then
          call fmi2m(0, mresult)
          kresult = 1
      endif

      return
      end subroutine fmbernoulli_sc

      subroutine fmbesj(n, ma, mb)

!  mb = bessel j(n,ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: n
      intent (in) :: n, ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(17), mresult, mretry

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmbesj_sc(n, ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      n_acc = nint(ndig*alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmbesj_m(n, ma, mxy, mresult, ndsave, numtry, retry, n_acc)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmbesj

      subroutine fmbesj_m(n, ma, mxy, mresult, ndsave, numtry, retry, n_acc)

!  Method selection for computing bessel j(n,ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(17), mresult
      integer :: n, ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: n, ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc

      double precision :: cbig, cklog, crhs, dbig, dklog, drhs, xe, xf, xlog
      integer :: iextra, j, k, kd, nmethd
      double precision, external :: fmdplg

      retry = .true.

      n_acc = nint(ndig*alogm2)
      call fmequ(ma, mxy(1), ndsave, ndig)
      mxy(1)%mp(1) = 1

!             Check for special cases.

      if (n < 0) then
          call fmunknown(mresult)
          kflag = -4
          retry = .false.
          return
      endif
      if (mxy(1)%mp(3) == 0) then
          if (n == 0) then
              call fmi2m(1, mresult)
          else
              call fmi2m(0, mresult)
          endif
          retry = .false.
          return
      endif
      call fmovun_xexf(mxy(1), xe, xf)
      if (2*xe < -ndig-1) then
          call fmdivi(mxy(1), 2, mxy(12))
          call fmipwr(mxy(12), n, mxy(15))
          call fmfcti(n, mxy(14))
          call fmdiv(mxy(15), mxy(14), mresult)
          if (ma%mp(1) == -1) then
              if (mod(n, 2) == 1) call fmnegate(mresult)
          endif
          return
      endif

!             Determine which method to use.

!             nmethd = 1 means use the convergent series
!                    = 2 means use the asymptotic series

      nmethd = 1
      call fmabs(mxy(1), mxy(15))
      if (mxy(15)%mp(2) == munkno .and. mxy(15)%mp(5) < 0) then
          call fmovun_xexf(mxy(15), xe, xf)
          cklog = xe
          xlog = xf
          xlog = log(xlog) + cklog*dlogmb
      else
          cklog = mxy(15)%mp(2)
          mxy(15)%mp(2) = 0
          call fmm2dp(mxy(15), xlog)
          xlog = log(xlog) + cklog*dlogmb
      endif

!             c(k) is the absolute value of the kth term of the convergent series.
!             The number of terms needed at this precision is roughly the smallest k for which
!             |c(k)/c(0)| < mbase**(-ndig) * 10**(-20).
!             Check log(|c(k)|) < log(|c(0)|) - ndig*log(mbase) - 20*log(10)

      crhs = n*(xlog-dlogtw) - fmdplg(dble(n+1)) - ndig*dlogmb - 20*dlogtn

!             d(k) is the absolute value of the kth term of the asymptotic series.
!             The number of terms needed at this precision is roughly the smallest k for which
!             |d(k)/d(0)| < mbase**(-ndig) * 10**(-20).
!             Check log(|d(k)|) < log(|d(0)|) - ndig*log(mbase) - 20*log(10)

      drhs = n
      drhs = min(0.0d0, log(abs(4*drhs*drhs-1))-xlog-3*dlogtw) - ndig*dlogmb - 20*dlogtn - 50

      cbig = n*(xlog-dlogtw) - fmdplg(dble(n+1))
      dbig = 1
      k = 1
      do j = 0, 50
         k = 2*k
         cklog = (2*k+n)*xlog - (2*k+n)*dlogtw - fmdplg(dble(k+1)) - fmdplg(dble(n+k+1))
         cbig = max(cbig, cklog)
         if (cklog < crhs) then
             nmethd = 1
             cklog = min(0.0d0, n*xlog - n*dlogtw - fmdplg(dble(n+1)))
             iextra = ((cbig-cklog)/dlogmb + 3)*1.2 - 14/alogmt
             ndig = ndig+max(0, iextra)
             call fmequ_r1(mxy(1), ndsave, ndig)
             exit
         endif
         kd = k/2
         if (n-2*kd < 0) then
             dklog = fmdplg(dble(2*kd+n+0.5)) + fmdplg(dble(2*kd-n+0.5)) -  &
                     2*kd*dlogtw - 2*kd*xlog - fmdplg(dble(2*kd+1))
         else
             dklog = fmdplg(dble(2*kd+n+0.5)) - fmdplg(dble(n-2*kd+0.5)) -  &
                     2*kd*dlogtw - 2*kd*xlog - fmdplg(dble(2*kd+1))
         endif
         dbig = max(dbig, dklog)
         if (dklog < drhs) then
             nmethd = 2
             iextra = (dbig/dlogmb + 3)*1.2 - 14/alogmt
             ndig = ndig+max(0, iextra)
             call fmequ_r1(mxy(1), ndsave, ndig)
             exit
         endif
      enddo
      if (numtry <= 0 .and. ncall <= 1 .and. n <= 100) then
          ndig = max(ndsave+ngrd52, ndig-2)
      endif
      n_acc = nint(ndig*alogm2)

      if (nmethd == 1) then
          call fmbesj_m1(n, mxy, mresult, n_acc)
      else if (nmethd == 2) then
          call fmbesj_m2(n, mxy, mresult)
      endif

      if (ma%mp(1) == -1) then
          if (mod(n, 2) == 1) call fmnegate(mresult)
      endif

      return
      end subroutine fmbesj_m

      subroutine fmbesj_m1(n, mxy, mresult, n_acc)

!  Method 1 for computing bessel j(n,ma).

      use fmvals
      implicit none

      type(multi) :: mxy(17), mresult
      integer :: n, n_acc
      intent (in) :: n
      intent (inout) :: mxy, mresult, n_acc

      integer :: j, j2, k, kl, ndig2, ndsav1, nterm
      double precision :: x, xe, xf
      type(multi), save :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 1.  Sum the convergent series.
!                        j(n,x) = sum( (-1)**k (x/2)**(2k+n) / ( k! (n+k)! )

      call fmm2dp(mxy(1), x)
      x = abs(x)
      call fmovun_xexf(mxy(1), xe, xf)
      j2 = 2
      if (kflag == 0 .and. x <= sqrt(huge(x))) then
          j2 = int(0.63*sqrt(fmnterms(x*x/4, 1, 1, n, 1)) - 1)
      else if (xe < 0) then
          j2 = 2
      else if (xe > 0) then
          call fmunknown(mresult)
          return
      endif
      j2 = max(2, min(j2+mod(j2, 2), ljsums))

!             mxy(1) is x
!             mxy(14) is x**2/4
!             mxy(15) is mxy(14)**j2
!             mxy(13) is the current term in the sum
!             mjsums holds the partial sums

      ndsav1 = ndig
      call fmsqr(mxy(1), mxy(14))
      call fmdivi_r1(mxy(14), 4)
      call fmipwr(mxy(14), j2, mxy(15))
      call fmi2m(1, mxy(10))
      call fmfcti(n, mxy(11))
      call fmdiv(mxy(10), mxy(11), mxy(13))
      do j = 1, j2
         nterm = j
         call fmeq(mxy(13), mjsums(j))
         if (j > 1) call fmcsdivi_r1(mxy(13), j)
         call fmcsdivi_r1(mxy(13), n+j)
      enddo

      nterm = j2
      ndig2 = ndig
      kl = 1
      do while (kl == 1)
         call fmcsmpy_r1(mxy(13), mxy(15))
         ndig = ndig2
         do j = 1, j2
            ndig = ndsav1
            call fmcsaddnn_r1(mjsums(j), mxy(13))
            if (kflag /= 0) then
                kl = 0
                exit
            else
                ndig = max(ngrd22, ndsav1-int(mjsums(j)%mp(2) - mxy(13)%mp(2)))
                ndig = min(ndsav1, ndig)
                if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                nterm = nterm + 1
                call fmcsdivi_r1(mxy(13), nterm)
                call fmcsdivi_r1(mxy(13), n+nterm)
            endif
         enddo
      enddo

!             Put the j2 concurrent sums back together.

      ndig = ndsav1
      call fmcsnsums(j2, mjsums)
      call fmeq(mjsums(1), mxy(11))
      mxy(14)%mp(1) = -1
      if (mxy(11)%mp(1) > 0) then
          call fmeq(mxy(11), mxy(16))
          call fmi2m(0, mxy(17))
      else
          call fmeq(mxy(11), mxy(17))
          call fmi2m(0, mxy(16))
      endif
      call fmeq(mxy(14), mxy(12))
      do j = 1, j2-1
         call fmmpy(mxy(12), mjsums(j+1), mxy(3))
         if (mxy(3)%mp(1) > 0) then
             call fmadd_r1(mxy(16), mxy(3))
         else
             call fmadd_r1(mxy(17), mxy(3))
         endif
         call fmmpy_r1(mxy(12), mxy(14))
      enddo
      call fmadd(mxy(16), mxy(17), mjsums(1))
      call fmcancel(mxy(16), mxy(17), mjsums(1), k)
      n_acc = n_acc - k
      call fmcsdivi(mxy(1), 2, mxy(11))
      call fmipwr(mxy(11), n, mxy(12))
      call fmmpy_r1(mxy(12), mjsums(1))

      call fmeq(mxy(12), mresult)

      return
      end subroutine fmbesj_m1

      subroutine fmbesj_m2(n, mxy, mresult)

!  Method 2 for computing bessel j(n,ma).

      use fmvals
      implicit none

      type(multi) :: mxy(17), mresult
      integer :: n
      intent (in) :: n
      intent (inout) :: mxy, mresult

      integer :: j, j2, k, kl, krsave, large, ndsav1, nterm, nterms
      double precision :: x, xe, xf
      type(multi), save :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 2.  Sum the asymptotic series.
!                        j(n,x) = sqrt(2/(pi*x)) * (cos(c)*sum(a(k)) - sin(c)*sum(b(k)))
!                        c = x - n*pi/2 - pi/4
!                        a(k) = (-1)**k * gamma(2k+n+0.5) / ((2x)**(2k) * (2k)! * gamma(-2k+n+0.5))
!                        b(k) = (-1)**k * gamma(2k+n+1.5) /
!                               ( (2x)**(2k+1) * (2k+1)! * gamma(-2k+n-0.5) )

!             mxy(1) is x
!             mxy(15) is the current term for the series
!             mxy(14) is 1/x**2
!             mxy(13) is mxy(14)**j2
!             mxy(12) is the sum of the a(k) series
!             mxy(11) is the sum of the b(k) series

      ndsav1 = ndig
      call fmm2dp(mxy(1), x)
      x = abs(x)
      call fmovun_xexf(mxy(1), xe, xf)
      j2 = 2
      if (kflag == 0 .and. x <= sqrt(huge(x))) then
          j2 = nint(0.41*sqrt(fmnterms(2*x, 2, 1, n, 0)) + 0.02)
      else if (xe > 0) then
          j2 = 1
      else if (xe < 0) then
          call fmunknown(mresult)
          return
      endif
      j2 = max(1, min(ljsums, j2))

!             Sum the a(k) series.

      call fmi2m(1, mxy(15))
      call fmsqr(mxy(1), mxy(14))
      call fmdiv_r2(mxy(15), mxy(14))
      call fmipwr(mxy(14), j2, mxy(13))
      large = sqrt(mxbase+1.0d-3)
      nterm = 0
      do j = 1, j2
         nterm = j - 1
         call fmeq(mxy(15), mjsums(j))
         if (3+4*nterm+2*n > large) then
             call fmcsmpyi_r1(mxy(15), 1+4*nterm-2*n)
             call fmcsmpyi_r1(mxy(15), 3+4*nterm-2*n)
             call fmcsmpyi_r1(mxy(15), 1+4*nterm+2*n)
             call fmcsmpyi_r1(mxy(15), 3+4*nterm+2*n)
             call fmcsdivi_r1(mxy(15), -128)
             call fmcsdivi_r1(mxy(15), 1+nterm)
             call fmcsdivi_r1(mxy(15), 1+2*nterm)
         else
             call fmcsmpyi_r1(mxy(15), (1+4*nterm-2*n)*(3+4*nterm-2*n))
             call fmcsmpyi_r1(mxy(15), (1+4*nterm+2*n)*(3+4*nterm+2*n))
             call fmcsdivi_r1(mxy(15), -128)
             call fmcsdivi_r1(mxy(15), (1+nterm)*(1+2*nterm))
         endif
      enddo
      nterms = int(intmax/10)

      kl = 1
      do k = 1, nterms
         call fmcsmpy_r1(mxy(15), mxy(13))
         do j = 1, j2
            ndig = ndsav1
            call fmadd_r1(mjsums(j), mxy(15))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            ndig = max(ngrd22, ndsav1-int(mjsums(j)%mp(2) - mxy(15)%mp(2)))
            ndig = min(ndsav1, ndig)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
            nterm = nterm + 1
            if (3+4*nterm+2*n > large) then
                call fmcsmpyi_r1(mxy(15), 1+4*nterm-2*n)
                call fmcsmpyi_r1(mxy(15), 3+4*nterm-2*n)
                call fmcsmpyi_r1(mxy(15), 1+4*nterm+2*n)
                call fmcsmpyi_r1(mxy(15), 3+4*nterm+2*n)
                call fmcsdivi_r1(mxy(15), -128)
                call fmcsdivi_r1(mxy(15), 1+nterm)
                call fmcsdivi_r1(mxy(15), 1+2*nterm)
            else
                call fmcsmpyi_r1(mxy(15), (1+4*nterm-2*n)*(3+4*nterm-2*n))
                call fmcsmpyi_r1(mxy(15), (1+4*nterm+2*n)*(3+4*nterm+2*n))
                call fmcsdivi_r1(mxy(15), -128)
                call fmcsdivi_r1(mxy(15), (1+nterm)*(1+2*nterm))
            endif
         enddo
         if (kl == 0) exit
         if (k == nterms) then
             call fmunknown(mresult)
             return
         endif
      enddo

!             Put the j2 concurrent sums back together.

      ndig = ndsav1
      if (j2 > 1) then
          call fmeq(mjsums(j2), mxy(11))
          do j = j2-1, 1, -1
             call fmcsmpy_r1(mxy(11), mxy(14))
             call fmadd_r1(mxy(11), mjsums(j))
          enddo
          call fmeq(mxy(11), mxy(12))
      else
          call fmeq(mjsums(1), mxy(12))
      endif

!             Sum the b(k) series.

      ndig = ndsav1
      if (n < large) then
          call fmi2m(4*n*n-1, mxy(15))
      else
          call fmi2m(n, mxy(15))
          call fmsqr_r1(mxy(15))
          call fmmpyi_r1(mxy(15), 4)
          call fmaddi(mxy(15), -1)
      endif
      call fmcsdivi_r1(mxy(15), 8)
      call fmdiv_r1(mxy(15), mxy(1))
      nterm = 0
      do j = 1, j2
         nterm = j - 1
         call fmeq(mxy(15), mjsums(j))
         if (3+4*nterm+2*n > large) then
             call fmcsmpyi_r1(mxy(15), 3+4*nterm-2*n)
             call fmcsmpyi_r1(mxy(15), 5+4*nterm-2*n)
             call fmcsmpyi_r1(mxy(15), 3+4*nterm+2*n)
             call fmcsmpyi_r1(mxy(15), 5+4*nterm+2*n)
             call fmcsdivi_r1(mxy(15), -128)
             call fmcsdivi_r1(mxy(15), 1+nterm)
             call fmcsdivi_r1(mxy(15), 3+2*nterm)
         else
             call fmcsmpyi_r1(mxy(15), (3+4*nterm-2*n)*(5+4*nterm-2*n))
             call fmcsmpyi_r1(mxy(15), (3+4*nterm+2*n)*(5+4*nterm+2*n))
             call fmcsdivi_r1(mxy(15), -128)
             call fmcsdivi_r1(mxy(15), (1+nterm)*(3+2*nterm))
         endif
      enddo
      nterms = int(intmax/10)

      kl = 1
      do k = 1, nterms
         call fmcsmpy_r1(mxy(15), mxy(13))
         do j = 1, j2
            ndig = ndsav1
            call fmadd_r1(mjsums(j), mxy(15))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            ndig = max(ngrd22, ndsav1-int(mjsums(j)%mp(2) - mxy(15)%mp(2)))
            ndig = min(ndsav1, ndig)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
            nterm = nterm + 1
            if (3+4*nterm+2*n > large) then
                call fmcsmpyi_r1(mxy(15), 3+4*nterm-2*n)
                call fmcsmpyi_r1(mxy(15), 5+4*nterm-2*n)
                call fmcsmpyi_r1(mxy(15), 3+4*nterm+2*n)
                call fmcsmpyi_r1(mxy(15), 5+4*nterm+2*n)
                call fmcsdivi_r1(mxy(15), -128)
                call fmcsdivi_r1(mxy(15), 1+nterm)
                call fmcsdivi_r1(mxy(15), 3+2*nterm)
            else
                call fmcsmpyi_r1(mxy(15), (3+4*nterm-2*n)*(5+4*nterm-2*n))
                call fmcsmpyi_r1(mxy(15), (3+4*nterm+2*n)*(5+4*nterm+2*n))
                call fmcsdivi_r1(mxy(15), -128)
                call fmcsdivi_r1(mxy(15), (1+nterm)*(3+2*nterm))
            endif
         enddo
         if (kl == 0) exit
         if (k == nterms) then
             call fmunknown(mresult)
             return
         endif
      enddo

!             Put the j2 concurrent sums back together.

      ndig = ndsav1
      if (j2 > 1) then
          call fmeq(mjsums(j2), mxy(11))
          do j = j2-1, 1, -1
             call fmcsmpy_r1(mxy(11), mxy(14))
             call fmadd_r1(mxy(11), mjsums(j))
          enddo
      else
          call fmeq(mjsums(1), mxy(11))
      endif

!             To minimize cancellation error for very large x, with c = x - n*pi/2 - pi/4,
!             then we have
!             cos(c) = (k1*sin(x) + k2*cos(x)) / sqrt(2)
!             sin(c) = (k2*sin(x) - k1*cos(x)) / sqrt(2),  where
!             k1 = cos(n*pi/2) + sin(n*pi/2)
!             k2 = cos(n*pi/2) - sin(n*pi/2)
!             This is equivalent to
!             mod( n, 4 ) =   0   1   2   3
!                      k1 =   1   1  -1  -1
!                      k2 =   1  -1  -1   1

      krsave = krad
      krad = 1
      call fmcssn(mxy(1), mxy(7), mxy(8))
      krad = krsave
      k = mod(n, 4)
      if (k == 0) then
          call fmadd(mxy(8), mxy(7), mxy(9))
          call fmsub(mxy(8), mxy(7), mxy(10))
      else if (k == 1) then
          call fmsub(mxy(8), mxy(7), mxy(9))
          call fmadd(mxy(8), mxy(7), mxy(10))
          call fmnegate(mxy(10))
      else if (k == 2) then
          call fmadd(mxy(8), mxy(7), mxy(9))
          call fmnegate(mxy(9))
          call fmsub(mxy(7), mxy(8), mxy(10))
      else
          call fmsub(mxy(7), mxy(8), mxy(9))
          call fmadd(mxy(8), mxy(7), mxy(10))
      endif
      call fmi2m(2, mxy(5))
      call fmsqrt(mxy(5), mxy(6))
      call fmdiv(mxy(9), mxy(6), mxy(7))
      call fmdiv(mxy(10), mxy(6), mxy(8))

      call fmmpy_r2(mxy(7), mxy(12))
      call fmmpy_r2(mxy(8), mxy(11))
      call fmsub(mxy(12), mxy(11), mxy(9))
      call fmpi(mxy(10))
      call fmmpy(mxy(10), mxy(1), mxy(8))
      call fmi2m(2, mxy(7))
      call fmdiv(mxy(7), mxy(8), mxy(6))
      call fmsqrt(mxy(6), mxy(7))
      call fmmpy(mxy(7), mxy(9), mxy(12))

      call fmeq(mxy(12), mresult)

      return
      end subroutine fmbesj_m2

      subroutine fmbesj_sc(n, ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = bessel j(n,ma).

!  kresult = 1 is returned if a special case gives the value of bessel j(n,ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(17), mresult
      integer :: n, kresult, ndsave
      intent (in) :: n, ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      double precision :: xe, xf, ye, yf
      integer :: j, k, krsave, nds
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMBESJ   '
      j = ndig
      ndig = ndsave
      call fmntr_inpi1(n, ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      call fmovun_xexf(malocal, xe, xf)
      if (kround /= 1 .and. n >= 0 .and. xe < -ndsave) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          krsave = kround
          kround = 1
          nds = ndig
          ndig = ndig + ngrd52
          call fmequ(malocal, mxy(1), nds, ndig)
          call fmdivi(mxy(1), 2, mxy(3))
          call fmipwr(mxy(3), n, mxy(2))
          call fmi2m(n, mxy(4))
          call fmfact(mxy(4), mxy(5))
          call fmdiv(mxy(2), mxy(5), mxy(4))
          call fmmpy(mxy(4), mxy(3), mxy(5))
          call fmmpy(mxy(5), mxy(3), mxy(6))
          call fmdivi(mxy(6), n+1, mxy(5))
          call fmovun_xexf(mxy(4), xe, xf)
          call fmovun_xexf(mxy(5), ye, yf)
          if (xe - ye > ndsave+1 .and. xe < mexpov) then
              call fmequ(mxy(4), mxy(10), ndig, nds)
              call fmequ(mxy(4), mxy(6), ndig, nds)
              call fmequ(mxy(6), mxy(8), nds, ndig)
              call fmsub(mxy(4), mxy(8), mxy(6))
              if (mxy(6)%mp(3) == 0) then
                  call fmequ(mxy(4), mxy(6), ndig, nds)
                  call fmequ(mxy(5), mxy(7), ndig, nds)
                  ndig = nds
                  kround = krsave
                  call fmsub(mxy(6), mxy(7), mresult)
              else
                  kround = krsave
                  call fmequ(mxy(4), mresult, ndig, nds)
              endif
              kflag = 0
              ntrace = j
              kwarn = k
              ndig = nds
              kround = krsave
              kresult = 1
              return
          endif
          kflag = 0
          ntrace = j
          kwarn = k
          ndig = nds
          kround = krsave
      endif

      return
      end subroutine fmbesj_sc

      subroutine fmbesj2(n1, n2, x, array)

!  array = (/  j(n1,x) , ..., j(n2,x)  /)

      use fmvals
      implicit none

      integer :: n1, n2
      type(multi) :: array(abs(n2-n1)+1), x
      intent (in) :: n1, n2, x
      intent (inout) :: array

      integer :: j, k, n, ndsave
      type(multi), save :: mxy(4)

      n = abs(n2-n1) + 1
      do j = 1, n
         call fmalloc(array(j), ndig+2)
      enddo
      ndsave = ndig

      if (n1 < 0 .or. n2 < 0) then
          do j = 1, size(array)
             call fmunknown(array(j))
          enddo
          return
      endif

!             The last two entries in the array are done with calls to fmbesj.
!             The rest use this recurrence:

!             j(k-1,x) = 2*k*j(k,x) / x  -  j(k+1,x)

      ndig = ndig + ngrd52
      call fmequ(x, mxy(1), ndsave, ndig)
      k = max(n1, n2)
      call fmbesj(k, mxy(1), mxy(4))
      call fmequ(mxy(4), array(n), ndig, ndsave)
      if (n <= 1) then
          ndig = ndsave
          return
      endif
      call fmbesj(k-1, mxy(1), mxy(3))
      call fmequ(mxy(3), array(n-1), ndig, ndsave)
      if (n <= 2) then
          ndig = ndsave
          return
      endif

      do j = k-2, min(n1, n2), -1
         call fmmpyi(mxy(3), 2*(j+1), mxy(2))
         call fmdiv_r1(mxy(2), mxy(1))
         call fmsub_r1(mxy(2), mxy(4))
         call fmequ(mxy(2), array(j-min(n1, n2)+1), ndig, ndsave)
         if (j == min(n1, n2)) exit
         call fmeq(mxy(3), mxy(4))
         call fmeq(mxy(2), mxy(3))
      enddo

!             Reverse the list if n2 < n1.

      if (n2 < n1) then
          ndig = ndsave
          do j = 1, n/2
             call fmeq(array(j), mxy(4))
             call fmeq(array(n+1-j), array(j))
             call fmeq(mxy(4), array(n+1-j))
          enddo
      endif

      ndig = ndsave

      return
      end subroutine fmbesj2

      subroutine fmbesy(n, ma, mb)

!  mb = bessel y(n,ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: n
      intent (in) :: n, ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(17), mresult, mretry

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmbesy_sc(n, ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      n_acc = nint(ndig*alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmbesy_m(n, ma, mxy, mresult, ndsave, numtry, retry, n_acc)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmbesy

      subroutine fmbesy_m(n, ma, mxy, mresult, ndsave, numtry, retry, n_acc)

!  Method selection for computing bessel y(n,ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(17), mresult
      integer :: n, ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: n, ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc

      double precision :: cbig, cklog, crhs, dbig, dklog, drhs, xe, xf, xlog
      integer :: iextra, j, k, kd, nmethd
      double precision, external :: fmdplg

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, ndig)

      call fmovun_xexf(mxy(1), xe, xf)
      if (2*xe <= -ndig) then
          if (n == 0) then
              call fmdivi(mxy(1), 2, mxy(4))
              call fmln(mxy(4), mxy(2))
              call fmeulr(mxy(3))
              call fmadd_r2(mxy(2), mxy(3))
              call fmmpyi_r1(mxy(3), 2)
              call fmpi(mxy(1))
              call fmdiv(mxy(3), mxy(1), mresult)
              retry = .false.
              return
          else
              call fmi2m(2, mxy(13))
              call fmdiv(mxy(13), mxy(1), mxy(12))
              call fmipwr(mxy(12), n, mxy(13))
              call fmfcti(n-1, mxy(12))
              call fmmpy(mxy(12), mxy(13), mxy(14))
              call fmpi(mxy(12))
              call fmdiv(mxy(14), mxy(12), mresult)
              call fmnegate(mresult)
              retry = .false.
              return
          endif
      endif

!             Determine which method to use.

!             nmethd = 1 means use the convergent series
!                    = 2 means use the asymptotic series

      nmethd = 1
      call fmabs(mxy(1), mxy(12))
      if (mxy(12)%mp(2) == munkno .and. mxy(12)%mp(5) < 0) then
          call fmovun_xexf(mxy(12), xe, xf)
          cklog = xe
          xlog = xf
          xlog = log(xlog) + cklog*dlogmb
      else
          cklog = mxy(12)%mp(2)
          mxy(12)%mp(2) = 0
          call fmm2dp(mxy(12), xlog)
          xlog = abs(xlog)
          xlog = log(xlog) + cklog*dlogmb
      endif

!             c(k) is the absolute value of the kth term of the convergent series.  The psi terms
!                  grow logarithmically, so they are ignored for this estimate.
!             The number of terms needed at this precision is roughly the smallest k for which
!             |c(k)/c(0)| < mbase**(-ndig) * 10**(-20).
!             Check Log(|c(k)|) < Log(|c(0)|) - ndig*Log(mbase) - 20*Log(10)

      crhs = n*(xlog-dlogtw) - fmdplg(dble(n+1)) - ndig*dlogmb - 20*dlogtn

!             d(k) is the absolute value of the kth term of the asymptotic series.
!             The number of terms needed at this precision is roughly the smallest k for which
!             |d(k)/d(0)| < mbase**(-ndig) * 10**(-20).
!             Check Log(|d(k)|) < Log(|d(0)|) - ndig*Log(mbase) - 20*Log(10)

      drhs = n
      drhs = min(0.0d0, log(abs(4*drhs*drhs-1))-xlog-3*dlogtw) - ndig*dlogmb - 20*dlogtn - 50

      cbig = n*(xlog-dlogtw) - fmdplg(dble(n+1))
      dbig = 1
      k = 1
      do j = 0, 50
         k = 2*k
         cklog = (2*k+n)*xlog - (2*k+n)*dlogtw - fmdplg(dble(k+1)) - fmdplg(dble(n+k+1))
         cbig = max(cbig, cklog)
         if (cklog < crhs) then
             nmethd = 1
             cklog = min(0.0d0, n*xlog - n*dlogtw - fmdplg(dble(n+1)))
             iextra = ((cbig-cklog)/dlogmb + 3)*1.2 - 14/alogmt
             ndig = ndig+max(0, iextra)
             n_acc = nint(ndig*alogm2)
             call fmequ_r1(mxy(1), ndsave, ndig)
             exit
         endif
         kd = k
         if (n-2*kd < 0) then
             dklog = fmdplg(dble(2*kd+n+0.5)) + fmdplg(dble(2*kd-n+0.5)) -  &
                     2*kd*dlogtw - 2*kd*xlog - fmdplg(dble(2*kd+1))
         else
             dklog = fmdplg(dble(2*kd+n+0.5)) - fmdplg(dble(n-2*kd+0.5)) -  &
                     2*kd*dlogtw - 2*kd*xlog - fmdplg(dble(2*kd+1))
         endif
         dbig = max(dbig, dklog)
         if (dklog < drhs) then
             nmethd = 2
             iextra = (dbig/dlogmb + 3)*1.2 - 14/alogmt
             ndig = ndig+max(0, iextra)
             n_acc = nint(ndig*alogm2)
             call fmequ_r1(mxy(1), ndsave, ndig)
             exit
         endif
      enddo
      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig-2)
      endif
      n_acc = nint(ndig*alogm2)

      if (nmethd == 1) then
          call fmbesy_m1(n, mxy, mresult, n_acc)
      else if (nmethd == 2) then
          call fmbesy_m2(n, mxy, mresult)
      endif

      return
      end subroutine fmbesy_m

      subroutine fmbesy_m1(n, mxy, mresult, n_acc)

!  Method 1 for computing bessel y(n,ma).

      use fmvals
      implicit none

      type(multi) :: mxy(17), mresult
      integer :: n, n_acc
      intent (in) :: n
      intent (inout) :: mxy, mresult, n_acc

      integer :: j, k, kl
      double precision :: x, xe, xf

!             Method 1.  Sum the convergent series.
!                        y(n,x) = (-1/pi)*
!                        sum( (-1)**k (psi(k+1) + psi(n+k+1)) (x/2)**(2k+n) / ( k! (n+k)! )
!                        - (1/pi)*sum( (n-k-1)! (x/2)**(2k-n) / k! ) + (2/pi)*ln(x/2)*j(n,x)

!                        The first sum above (involving psi) runs from k=0 to infinity, but the
!                        second sum is finite, for k=0 to k=n-1.

      call fmm2dp(mxy(1), x)

!             Sum( (-1)**k (psi(k+1) + psi(n+k+1)) (x/2)**(2k+n) / ( k! (n+k)! )

!             mxy(1) is x
!             mxy(11) is -x**2/4
!             mxy(13) is psi(k+1)
!             mxy(14) is psi(n+k+1)
!             mxy(10) is the current value of (-1)**k (x/2)**(2k+n) / ( k! (n+k)! )
!             mxy(12) holds the partial sum

      call fmeulr(mxy(13))
      mxy(13)%mp(1) = -1
      if (n < 5000) then
          call fmeq(mxy(13), mxy(14))
          if (n > 0) then
              call fmi2m(1, mxy(7))
              do j = 1, n
                 call fmcsdivi(mxy(7), j, mxy(8))
                 call fmadd_r1(mxy(14), mxy(8))
              enddo
          endif
      else
          call fmi2m(n+1, mxy(12))
          call fmpsi(mxy(12), mxy(14))
      endif
      call fmcsdivi(mxy(1), 2, mxy(8))
      call fmipwr(mxy(8), n, mxy(9))
      call fmsqr(mxy(1), mxy(11))
      call fmcsdivi_r1(mxy(11), 4)
      mxy(11)%mp(1) = -1
      call fmi2m(1, mxy(7))
      call fmfcti(n, mxy(8))
      call fmadd(mxy(13), mxy(14), mxy(6))
      call fmdiv(mxy(6), mxy(8), mxy(2))
      call fmmpy(mxy(2), mxy(9), mxy(3))
      call fmeq(mxy(3), mxy(12))
      if (mxy(12)%mp(1) > 0) then
          call fmeq(mxy(12), mxy(16))
          call fmi2m(0, mxy(17))
      else
          call fmeq(mxy(12), mxy(17))
          call fmi2m(0, mxy(16))
      endif
      call fmovun_xexf(mxy(3), xe, xf)
      kl = 1
      do while (kl == 1)
         kl = 0
         if (xe <= mexpun) then
             call fmeq(mxy(3), mxy(9))
             call fmnegate(mxy(9))
             if (mxy(9)%mp(1) > 0) then
                 call fmeq(mxy(9), mxy(16))
                 call fmi2m(0, mxy(17))
             else
                 call fmadd_r1(mxy(9), mxy(17))
                 call fmi2m(0, mxy(16))
             endif
             exit
         endif
         call fmovun_xexf(mxy(1), xe, xf)
         if (xe < -ndig) then
             call fmpi(mxy(6))
             mxy(6)%mp(1) = -1
             call fmdiv(mxy(3), mxy(6), mxy(9))
             if (mxy(9)%mp(1) > 0) then
                 call fmeq(mxy(9), mxy(16))
                 call fmi2m(0, mxy(17))
             else
                 call fmadd_r1(mxy(9), mxy(17))
                 call fmi2m(0, mxy(16))
             endif
             exit
         endif
         call fmdiv(mxy(9), mxy(8), mxy(10))
         call fmi2m(1, mxy(4))

         do k = 1, 10**8
            call fmmpy_r1(mxy(10), mxy(11))
            call fmdivi_r1(mxy(10), k)
            call fmdivi_r1(mxy(10), n+k)
            call fmdivi(mxy(4), k, mxy(3))
            call fmadd_r1(mxy(13), mxy(3))
            call fmdivi(mxy(4), n+k, mxy(3))
            call fmadd_r1(mxy(14), mxy(3))
            call fmadd(mxy(13), mxy(14), mxy(3))
            call fmmpy_r1(mxy(3), mxy(10))
            if (mxy(3)%mp(1) > 0) then
                call fmadd_r1(mxy(16), mxy(3))
            else
                call fmadd_r1(mxy(17), mxy(3))
            endif
            call fmadd_r1(mxy(12), mxy(3))
            if (kflag /= 0) exit
         enddo
         call fmpi(mxy(6))
         mxy(6)%mp(1) = -1
         call fmdiv_r1(mxy(12), mxy(6))
         call fmdiv_r1(mxy(16), mxy(6))
         call fmdiv_r1(mxy(17), mxy(6))
      enddo

!             Sum( (n-k-1)! (x/2)**(2k-n) / k! )

      if (n > 0) then
          mxy(11)%mp(1) = 1
          call fmcsdivi(mxy(1), 2, mxy(6))
          call fmipwr(mxy(6), -n, mxy(7))
          call fmfcti(n-1, mxy(6))
          call fmcsmpy_r1(mxy(7), mxy(6))
          call fmeq(mxy(7), mxy(8))
          if (mxy(8)%mp(2) == mexpov) then
              mxy(8)%mp(1) = -1
          else
              do j = 1, n-1
                 call fmcsmpy_r1(mxy(7), mxy(11))
                 call fmcsdivi_r1(mxy(7), n-j)
                 call fmcsdivi_r1(mxy(7), j)
                 call fmadd_r1(mxy(8), mxy(7))
              enddo
              call fmpi(mxy(6))
              mxy(6)%mp(1) = -1
              call fmdiv_r1(mxy(8), mxy(6))
          endif

          if (mxy(8)%mp(1) > 0) then
              call fmadd_r1(mxy(16), mxy(8))
          else
              call fmadd_r1(mxy(17), mxy(8))
          endif
      endif

!             Add the j(n,x) term.

      call fmbesj(n, mxy(1), mxy(15))
      if (mxy(15)%mp(2) == mexpun) then
          mxy(15)%mp(1) = -1
      else
          call fmcsdivi(mxy(1), 2, mxy(6))
          call fmln(mxy(6), mxy(7))
          call fmmpy(mxy(15), mxy(7), mxy(8))
          call fmpi(mxy(6))
          call fmdiv_r1(mxy(8), mxy(6))
          call fmcsmpyi(mxy(8), 2, mxy(15))
      endif

      if (mxy(15)%mp(1) > 0) then
          call fmadd_r1(mxy(16), mxy(15))
      else
          call fmadd_r1(mxy(17), mxy(15))
      endif
      call fmadd(mxy(16), mxy(17), mxy(9))
      call fmcancel(mxy(16), mxy(17), mxy(9), k)
      n_acc = n_acc - k

      call fmeq(mxy(9), mresult)

      return
      end subroutine fmbesy_m1

      subroutine fmbesy_m2(n, mxy, mresult)

!  Method 2 for computing bessel y(n,ma).

      use fmvals
      implicit none

      type(multi) :: mxy(17), mresult
      integer :: n
      intent (in) :: n
      intent (inout) :: mxy, mresult

      integer :: j, j2, k, kl, krsave, large, ndsav1, nterm, nterms
      double precision :: x, xe, xf
      type(multi), save :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 2.  Sum the asymptotic series.
!                        y(n,x) = sqrt(2/(pi*x))*(sin(c)*sum(a(k)) + cos(c)*sum(b(k)))
!                        c = x - n*pi/2 - pi/4
!                        a(k) = (-1)**k * gamma(2k+n+0.5) / ( (2x)**(2k)*(2k)! * gamma(-2k+n+0.5) )
!                        b(k) = (-1)**k * gamma(2k+n+1.5) /
!                               ( (2x)**(2k+1) * (2k+1)! * gamma(-2k+n-0.5) )

!             mxy(1) is x
!             mxy(12) is the current term for the series
!             mxy(11) is 1/x**2
!             mxy(10) is mxy(11)**j2
!             mxy(9) is the sum of the a(k) series
!             mxy(8) is the sum of the b(k) series

      ndsav1 = ndig
      call fmm2dp(mxy(1), x)
      x = abs(x)
      call fmovun_xexf(mxy(1), xe, xf)
      j2 = 2
      if (kflag == 0 .and. x <= sqrt(huge(x))) then
          j2 = nint(0.41*sqrt(fmnterms(2*x, 2, 1, n, 0)) + 0.02)
      else if (xe > 0) then
          j2 = 1
      else if (xe < 0) then
          call fmunknown(mresult)
          return
      endif
      j2 = max(1, min(ljsums, j2))

!             Sum the a(k) series.

      call fmi2m(1, mxy(12))
      call fmsqr(mxy(1), mxy(11))
      call fmdiv_r2(mxy(12), mxy(11))
      call fmipwr(mxy(11), j2, mxy(10))
      large = sqrt(mxbase+1.0d-3)
      nterm = 0
      do j = 1, j2
         nterm = j - 1
         call fmeq(mxy(12), mjsums(j))
         if (3+4*nterm+2*n > large) then
             call fmcsmpyi_r1(mxy(12), 1+4*nterm-2*n)
             call fmcsmpyi_r1(mxy(12), 3+4*nterm-2*n)
             call fmcsmpyi_r1(mxy(12), 1+4*nterm+2*n)
             call fmcsmpyi_r1(mxy(12), 3+4*nterm+2*n)
             call fmcsdivi_r1(mxy(12), -128)
             call fmcsdivi_r1(mxy(12), 1+nterm)
             call fmcsdivi_r1(mxy(12), 1+2*nterm)
         else
             call fmcsmpyi_r1(mxy(12), (1+4*nterm-2*n)*(3+4*nterm-2*n))
             call fmcsmpyi_r1(mxy(12), (1+4*nterm+2*n)*(3+4*nterm+2*n))
             call fmcsdivi_r1(mxy(12), -128)
             call fmcsdivi_r1(mxy(12), (1+nterm)*(1+2*nterm))
         endif
      enddo
      nterms = int(intmax/10)

      kl = 1
      do k = 1, nterms
         call fmcsmpy_r1(mxy(12), mxy(10))
         do j = 1, j2
            ndig = ndsav1
            call fmadd_r1(mjsums(j), mxy(12))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            ndig = max(ngrd22, ndsav1-int(mjsums(j)%mp(2) - mxy(12)%mp(2)))
            ndig = min(ndsav1, ndig)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
            nterm = nterm + 1
            if (3+4*nterm+2*n > large) then
                call fmcsmpyi_r1(mxy(12), 1+4*nterm-2*n)
                call fmcsmpyi_r1(mxy(12), 3+4*nterm-2*n)
                call fmcsmpyi_r1(mxy(12), 1+4*nterm+2*n)
                call fmcsmpyi_r1(mxy(12), 3+4*nterm+2*n)
                call fmcsdivi_r1(mxy(12), -128)
                call fmcsdivi_r1(mxy(12), 1+nterm)
                call fmcsdivi_r1(mxy(12), 1+2*nterm)
            else
                call fmcsmpyi_r1(mxy(12), (1+4*nterm-2*n)*(3+4*nterm-2*n))
                call fmcsmpyi_r1(mxy(12), (1+4*nterm+2*n)*(3+4*nterm+2*n))
                call fmcsdivi_r1(mxy(12), -128)
                call fmcsdivi_r1(mxy(12), (1+nterm)*(1+2*nterm))
            endif
         enddo
         if (kl == 0) exit
         if (k == nterms) then
             call fmunknown(mresult)
             return
         endif
      enddo

!             Put the j2 concurrent sums back together.

      ndig = ndsav1
      if (j2 > 1) then
          call fmeq(mjsums(j2), mxy(8))
          do j = j2-1, 1, -1
             call fmcsmpy_r1(mxy(8), mxy(11))
             call fmadd_r1(mxy(8), mjsums(j))
          enddo
          call fmeq(mxy(8), mxy(9))
      else
          call fmeq(mjsums(1), mxy(9))
      endif

!             Sum the b(k) series.

      ndig = ndsav1
      if (n < large) then
          call fmi2m(4*n*n-1, mxy(12))
      else
          call fmi2m(n, mxy(12))
          call fmsqr_r1(mxy(12))
          call fmcsmpyi_r1(mxy(12), 4)
          call fmaddi(mxy(12), -1)
      endif
      call fmcsdivi_r1(mxy(12), 8)
      call fmdiv_r1(mxy(12), mxy(1))
      do j = 1, j2
         nterm = j - 1
         call fmeq(mxy(12), mjsums(j))
         if (3+4*nterm+2*n > large) then
             call fmcsmpyi_r1(mxy(12), 3+4*nterm-2*n)
             call fmcsmpyi_r1(mxy(12), 5+4*nterm-2*n)
             call fmcsmpyi_r1(mxy(12), 3+4*nterm+2*n)
             call fmcsmpyi_r1(mxy(12), 5+4*nterm+2*n)
             call fmcsdivi_r1(mxy(12), -128)
             call fmcsdivi_r1(mxy(12), 1+nterm)
             call fmcsdivi_r1(mxy(12), 3+2*nterm)
         else
             call fmcsmpyi_r1(mxy(12), (3+4*nterm-2*n)*(5+4*nterm-2*n))
             call fmcsmpyi_r1(mxy(12), (3+4*nterm+2*n)*(5+4*nterm+2*n))
             call fmcsdivi_r1(mxy(12), -128)
             call fmcsdivi_r1(mxy(12), (1+nterm)*(3+2*nterm))
         endif
      enddo
      nterms = int(intmax/10)

      kl = 1
      do k = 1, nterms
         call fmcsmpy_r1(mxy(12), mxy(10))
         do j = 1, j2
            ndig = ndsav1
            call fmadd_r1(mjsums(j), mxy(12))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            ndig = max(ngrd22, ndsav1-int(mjsums(j)%mp(2) - mxy(12)%mp(2)))
            ndig = min(ndsav1, ndig)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
            nterm = nterm + 1
            if (3+4*nterm+2*n > large) then
                call fmcsmpyi_r1(mxy(12), 3+4*nterm-2*n)
                call fmcsmpyi_r1(mxy(12), 5+4*nterm-2*n)
                call fmcsmpyi_r1(mxy(12), 3+4*nterm+2*n)
                call fmcsmpyi_r1(mxy(12), 5+4*nterm+2*n)
                call fmcsdivi_r1(mxy(12), -128)
                call fmcsdivi_r1(mxy(12), 1+nterm)
                call fmcsdivi_r1(mxy(12), 3+2*nterm)
            else
                call fmcsmpyi_r1(mxy(12), (3+4*nterm-2*n)*(5+4*nterm-2*n))
                call fmcsmpyi_r1(mxy(12), (3+4*nterm+2*n)*(5+4*nterm+2*n))
                call fmcsdivi_r1(mxy(12), -128)
                call fmcsdivi_r1(mxy(12), (1+nterm)*(3+2*nterm))
            endif
         enddo
         if (kl == 0) exit
         if (k == nterms) then
             call fmunknown(mresult)
             return
         endif
      enddo

!             Put the j2 concurrent sums back together.

      ndig = ndsav1
      if (j2 > 1) then
          call fmeq(mjsums(j2), mxy(8))
          do j = j2-1, 1, -1
             call fmcsmpy_r1(mxy(8), mxy(11))
             call fmadd_r1(mxy(8), mjsums(j))
          enddo
      else
          call fmeq(mjsums(1), mxy(8))
      endif

!             To minimize cancellation error for very large x, with c = x - n*Pi/2 - Pi/4,
!             then we have
!             cos(c) = (k1*sin(x) + k2*cos(x)) / sqrt(2)
!             sin(c) = (k2*sin(x) - k1*cos(x)) / sqrt(2),  where
!             k1 = cos(n*Pi/2) + sin(n*Pi/2)
!             k2 = cos(n*Pi/2) - sin(n*Pi/2)
!             This is equivalent to
!             Mod( n, 4 ) =   0   1   2   3
!                      k1 =   1   1  -1  -1
!                      k2 =   1  -1  -1   1

      krsave = krad
      krad = 1
      call fmcssn(mxy(1), mxy(4), mxy(5))
      krad = krsave
      k = mod(n, 4)
      if (k == 0) then
          call fmadd(mxy(5), mxy(4), mxy(6))
          call fmsub(mxy(5), mxy(4), mxy(7))
      else if (k == 1) then
          call fmsub(mxy(5), mxy(4), mxy(6))
          call fmadd(mxy(5), mxy(4), mxy(7))
          call fmnegate(mxy(7))
      else if (k == 2) then
          call fmadd(mxy(5), mxy(4), mxy(6))
          call fmnegate(mxy(6))
          call fmsub(mxy(4), mxy(5), mxy(7))
      else
          call fmsub(mxy(4), mxy(5), mxy(6))
          call fmadd(mxy(5), mxy(4), mxy(7))
      endif
      call fmi2m(2, mxy(2))
      call fmsqrt(mxy(2), mxy(3))
      call fmdiv(mxy(6), mxy(3), mxy(4))
      call fmdiv(mxy(7), mxy(3), mxy(5))

      call fmmpy_r2(mxy(5), mxy(9))
      call fmmpy_r2(mxy(4), mxy(8))
      call fmadd(mxy(9), mxy(8), mxy(6))
      call fmpi(mxy(7))
      call fmmpy(mxy(7), mxy(1), mxy(5))
      call fmi2m(2, mxy(4))
      call fmdiv(mxy(4), mxy(5), mxy(3))
      call fmsqrt(mxy(3), mxy(4))
      call fmmpy(mxy(4), mxy(6), mxy(9))

      call fmeq(mxy(9), mresult)

      return
      end subroutine fmbesy_m2

      subroutine fmbesy_sc(n, ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = bessel y(n,ma).

!  kresult = 1 is returned if a special case gives the value of bessel y(n,ma).

      use fmvals
      implicit none

      type(multi) :: ma, mresult
      integer :: n, kresult, ndsave
      intent (in) :: n, ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMBESY   '
      j = ndig
      ndig = ndsave
      call fmntr_inpi1(n, ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      if (n < 0 .or. malocal%mp(3) == 0 .or. malocal%mp(1) == -1) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      return
      end subroutine fmbesy_sc

      subroutine fmbesy2(n1, n2, x, array)

!  array = (/  y(n1,x) , ..., y(n2,x)  /)


      use fmvals
      implicit none

      integer :: n1, n2
      type(multi) :: array(abs(n2-n1)+1), x
      intent (in) :: n1, n2, x
      intent (inout) :: array

      integer :: j, k, n, ndsave
      type(multi), save :: mxy(4)

      n = abs(n2-n1) + 1
      do j = 1, n
         call fmalloc(array(j), ndig+2)
      enddo
      ndsave = ndig

      if (n1 < 0 .or. n2 < 0) then
          do j = 1, size(array)
             call fmunknown(array(j))
          enddo
          return
      endif

!             The first two entries in the array are done with calls to fmbesy.
!             The rest use this recurrence:

!             y(k+1,x) = 2*k*y(k,x) / x  -  y(k-1,x)

      ndig = ndig + ngrd52
      call fmequ(x, mxy(1), ndsave, ndig)
      k = min(n1, n2)
      call fmbesy(k, mxy(1), mxy(4))
      call fmequ(mxy(4), array(1), ndig, ndsave)
      if (n <= 1) then
          ndig = ndsave
          return
      endif
      call fmbesy(k+1, mxy(1), mxy(3))
      call fmequ(mxy(3), array(2), ndig, ndsave)
      if (n <= 2) then
          ndig = ndsave
          return
      endif

      do j = k+2, max(n1, n2)
         call fmmpyi(mxy(3), 2*(j-1), mxy(2))
         call fmdiv_r1(mxy(2), mxy(1))
         call fmsub_r1(mxy(2), mxy(4))
         call fmequ(mxy(2), array(j-k+1), ndig, ndsave)
         if (j == min(n1, n2)) exit
         call fmeq(mxy(3), mxy(4))
         call fmeq(mxy(2), mxy(3))
      enddo

!             Reverse the list if n2 < n1.

      if (n2 < n1) then
          ndig = ndsave
          do j = 1, n/2
             call fmeq(array(j), mxy(4))
             call fmeq(array(n+1-j), array(j))
             call fmeq(mxy(4), array(n+1-j))
          enddo
      endif

      ndig = ndsave

      return
      end subroutine fmbesy2

      subroutine fmbeta(ma, mb, mc)

!  mc = beta(ma,mb)

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(22), mresult

      call fmalloc(mc, ndig+2)
      call fmenter2(ma, mb, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmbeta_sc(ma, mb, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mc, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call fmbeta_m1(ma, mb, mxy, mresult, mxsave, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mc, kovun, mxsave, ndsave)

      return
      end subroutine fmbeta

      subroutine fmbeta_m1(ma, mb, mxy, mresult, mxsave, ndsave)

!  Method 1 for computing beta(ma,mb).

      use fmvals
      implicit none

      type(multi) :: ma, mb, mxy(22), mresult
      integer :: ndsave
      real (kind(1.0d0)) :: mxsave
      intent (in) :: ma, mb, mxsave, ndsave
      intent (inout) :: mxy, mresult

      real (kind(1.0d0)) :: mzero, mt1
      real :: x
      double precision :: d
      integer :: iextra, j, jr, k, k10, k11, kb, kc, kflkb, kflnkb, kl,  &
                 kwrnsv, n, nb, nbot, ndsav2, nk, nkb
      type(multi), save :: malocal, mblocal
      logical, external :: fmcomp

      call fmequ(ma, malocal, ndsave, ndig)
      call fmequ(mb, mblocal, ndsave, ndig)

      if ((ma%mp(2) == mexpov .or. (ma%mp(2) == munkno .and. ma%mp(5) < 0 .and.  &
          ma%mp(4) > ndig)) .and. ma%mp(1) > 0) then
          if (huge(mbase)/mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          if (mb%mp(2) == mexpov .and. mb%mp(1) > 0) then
              call fmunderflow(1, mresult)
              kflag = -6
              mresult%mp(4) = -huge(mbase)/d
              mresult%mp(5) = -(1.0d0 - epsilon(1.0d0)) * maxint
          else
              call fmgam(mblocal, mxy(2))
              if (mxy(2)%mp(2) == mexpov .and. mxy(2)%mp(4) == huge(mbase)/d) then
                  call fmunderflow(1, mresult)
                  kflag = -6
                  mresult%mp(4) = -huge(mbase)/d
                  mresult%mp(5) = -(1.0d0 - epsilon(1.0d0)) * maxint
              else
                  call fmpwr(malocal, mblocal, mxy(3))
                  call fmdiv(mxy(2), mxy(3), mresult)
              endif
          endif
          if (mresult%mp(2) == munkno)  kflag = -4
          return
      else if ((mb%mp(2) == mexpov .or. (mb%mp(2) == munkno .and.  &
               mb%mp(5) < 0 .and. mb%mp(4) > ndig)) .and. mb%mp(1) > 0) then
          if (huge(mbase)/mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          call fmgam(malocal, mxy(2))
          if (mxy(2)%mp(2) == mexpov .and. mxy(2)%mp(4) == huge(mbase)/d) then
              call fmunderflow(1, mresult)
              kflag = -6
              mresult%mp(4) = -huge(mbase)/d
              mresult%mp(5) = -(1.0d0 - epsilon(1.0d0)) * maxint
          else
              call fmpwr(mblocal, malocal, mxy(3))
              call fmdiv(mxy(2), mxy(3), mresult)
          endif
          if (mresult%mp(2) == munkno)  kflag = -4
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      kl = 1
      do while (kl == 1)
         kl = 0
         if (kround /= 1 .and. (ma%mp(2) < -ndig .or. mb%mp(2) < -ndig) .and.  &
             ma%mp(2) > -mxexp .and. mb%mp(2) > -mxexp                  .and.  &
             ma%mp(2) /= munkno .and. mb%mp(2) /= munkno) then
             j = ntrace
             ntrace = 0
             k = kwarn
             kwarn = 0
             ndsav2 = ndig
             ndig = 2*ndig + ngrd52
             if (ma%mp(2) <= mb%mp(2)) then
                 call fmequ(ma, mxy(1), ndsave, ndig)
                 call fmequ(mb, mxy(2), ndsave, ndig)
             else
                 call fmequ(ma, mxy(2), ndsave, ndig)
                 call fmequ(mb, mxy(1), ndsave, ndig)
             endif
             call fmabs(mxy(1), mxy(3))
             call fmabs(mxy(2), mxy(4))
             call fmadd(mxy(3), mxy(4), mxy(7))
             call fmsqr(mxy(7), mxy(3))
             if (mxy(3)%mp(2) <= mxy(7)%mp(2) - ndsave) then
                 call fmi2m(1, mxy(3))
                 call fmdiv(mxy(3), mxy(1), mxy(4))
                 call fmdiv(mxy(3), mxy(2), mxy(6))
                 if (mxy(4)%mp(2) < mexpov) then
                     call fmadd(mxy(1), mxy(2), mxy(7))
                     call fmpi(mxy(8))
                     call fmsqr_r1(mxy(8))
                     call fmmpy(mxy(7), mxy(8), mxy(9))
                     call fmdivi_r1(mxy(9), 6)
                     call fmsub(mxy(6), mxy(9), mxy(10))
                     call fmadd_r2(mxy(4), mxy(10))
                     call fmeq(mxy(10), mresult)
                     kflag = 0
                     ntrace = j
                     kwarn = k
                     if (mresult%mp(2) < -mxexp .or. mresult%mp(2) > mxexp+1) then
                         ndig = ndsav2
                         exit
                     endif
                     return
                 endif
             else
                 call fmi2m(1, mxy(3))
                 call fmsub(mxy(2), mxy(3), mxy(4))
                 if (mxy(4)%mp(3) == 0) then
                     call fmdiv(mxy(3), mxy(1), mresult)
                     kflag = 0
                     ntrace = j
                     kwarn = k
                     if (mresult%mp(2) < -mxexp .or. mresult%mp(2) > mxexp+1) then
                         ndig = ndsav2
                         exit
                     endif
                     return
                 else
                     call fmdiv(mxy(3), mxy(1), mxy(4))
                     call fmeulr(mxy(5))
                     call fmpsi(mxy(2), mxy(6))
                     call fmadd(mxy(5), mxy(6), mxy(7))
                     call fmsub(mxy(4), mxy(7), mxy(8))
                     call fmeq(mxy(8), mresult)
                     kflag = 0
                     ntrace = j
                     kwarn = k
                     if (mresult%mp(2) < -mxexp .or. mresult%mp(2) > mxexp+1) then
                         ndig = ndsav2
                         exit
                     endif
                     return
                 endif
             endif
             kflag = 0
             ntrace = j
             kwarn = k
         endif
      enddo

      call fmequ(ma, mxy(1), ndsave, ndig)
      call fmequ(mb, mxy(2), ndsave, ndig)
      call fmeq(mxy(1), mxy(21))

      jr = kround
      kround = 1
      call fmadd(mxy(1), mxy(2), mxy(17))
      kround = jr
      if (mxy(1)%mp(3) == 0 .or. mxy(2)%mp(3) == 0) then
          call fmunknown(mresult)
          kflag = -4
          return
      endif

!             See if any of the terms are negative integers.

      call fmint(mxy(1), mxy(8))
      if (mxy(1)%mp(1) < 0) then
          if (fmcomp(mxy(1), '==', mxy(8))) then
              call fmunknown(mresult)
              kflag = -4
              return
          endif
      endif
      call fmint(mxy(2), mxy(9))
      if (mxy(2)%mp(1) < 0) then
          if (fmcomp(mxy(2), '==', mxy(9))) then
              call fmunknown(mresult)
              kflag = -4
              return
          endif
      endif
      if (fmcomp(mxy(17), '==', mxy(1))) then
          if (mxy(2)%mp(2) > mexpab) then
              call fmabs(mxy(2), mxy(13))
              call fmdpm(dlogmb, mxy(6))
              call fmmpy_r2(mxy(6), mxy(13))
              j = (mxy(1)%mp(2)+1)
              call fmmpyi_r1(mxy(13), j)
          else
              call fmabs(mxy(2), mxy(13))
          endif
          call fmi2m(1, mxy(6))
          call fmulp(mxy(6), mxy(7))
          if (fmcomp(mxy(13), '<=', mxy(7))) then
              call fmgam(mxy(2), mresult)
              return
          endif
      endif
      if (fmcomp(mxy(17), '==', mxy(2))) then
          if (mxy(1)%mp(2) > mexpab) then
              call fmabs(mxy(1), mxy(13))
              call fmdpm(dlogmb, mxy(6))
              call fmmpy_r2(mxy(6), mxy(13))
              j = (mxy(2)%mp(2)+1)
              call fmmpyi_r1(mxy(13), j)
          else
              call fmabs(mxy(1), mxy(13))
          endif
          call fmi2m(1, mxy(6))
          call fmulp(mxy(6), mxy(7))
          if (fmcomp(mxy(13), '<=', mxy(7))) then
              call fmgam(mxy(1), mresult)
              return
          endif
      endif
      if (mxy(17)%mp(3) == 0) then
          call fmi2m(0, mresult)
          return
      else if (mxy(17)%mp(1) < 0) then
          call fmsub(mxy(1), mxy(8), mxy(6))
          call fmsub(mxy(2), mxy(9), mxy(13))
          call fmadd_r2(mxy(6), mxy(13))
          call fmint(mxy(13), mxy(14))
          if (fmcomp(mxy(13), '==', mxy(14))) then
              call fmi2m(0, mresult)
              return
          endif
      endif

!             See if any of the terms are small integers.

      kwrnsv = kwarn
      kwarn = 0
      call fmm2i(mxy(1), n)
      kflkb = kflag
      call fmm2i(mxy(2), k)
      kflnkb = kflag
      call fmm2i(mxy(17), nk)
      kwarn = kwrnsv
      nb = nk - 2
      kb = n - 1
      nkb = k - 1

      if (kflkb == 0 .and. kflnkb == 0 .and. kflag == 0) then
          if (min(kb, nkb) <= 200) then
              call fmcmbi(nb, kb, mxy(22))
              call fmi2m(n+k-1, mxy(8))
              call fmmpy_r1(mxy(22), mxy(8))
              call fmi2m(1, mxy(6))
              call fmdiv(mxy(6), mxy(22), mresult)
              return
          endif
      endif
      nbot = 0
      if (kflkb == 0 .and. n <= 200) then
          call fmeq(mxy(2), mxy(20))
          call fmpoch(mxy(20), n, mxy(5))
          call fmfcti(kb, mxy(11))
          call fmdiv(mxy(11), mxy(5), mxy(21))
          if (abs(mxy(21)%mp(2)) < mxsave) then
              call fmeq(mxy(21), mresult)
              return
          endif
          nbot = 1
      else if (kflnkb == 0 .and. k <= 200) then
          call fmeq(mxy(1), mxy(20))
          call fmpoch(mxy(20), k, mxy(5))
          call fmfcti(nkb, mxy(11))
          call fmdiv(mxy(11), mxy(5), mxy(21))
          if (abs(mxy(21)%mp(2)) < mxsave) then
              call fmeq(mxy(21), mresult)
              return
          endif
          nbot = 1
      endif
      if (nbot == 1) then
          call fmequ(ma, mxy(1), ndsave, ndig)
          call fmequ(mb, mxy(2), ndsave, ndig)
          call fmeq(mxy(1), mxy(21))
          call fmadd(mxy(1), mxy(2), mxy(17))
      endif

!             General case.  Use fmgam, unless one of the numbers is too big.  If so, use fmlngm.

      x = alogmb*real(mxexp)
      call fmsp2m(x/log(x), mxy(7))
      call fmabs(mxy(17), mxy(18))
      call fmabs(mxy(1), mxy(19))
      call fmabs(mxy(2), mxy(3))
      if (fmcomp(mxy(18), '>=', mxy(7)) .or. fmcomp(mxy(19), '>=', mxy(7)) .or.  &
          fmcomp(mxy(3), '>=', mxy(7))) then

!             See if one argument is not very large and the other is
!             much larger.  For many of these cases, Stirling's formula
!             can be used to simplify Beta and avoid cancellation.

          if (mxy(1)%mp(2) > mxy(2)%mp(2)) then
              call fmeq(mxy(1), mxy(10))
              call fmeq(mxy(2), mxy(11))
          else
              call fmeq(mxy(2), mxy(10))
              call fmeq(mxy(1), mxy(11))
          endif
          if (mxy(10)%mp(2) > ndig .and.  &
              mxy(10)%mp(2) >= mxy(11)%mp(2)+ndig) then
              if (mxy(11)%mp(1) < 0) then
                  if (mxy(11)%mp(2) > ndig) then
                      kflag = -4
                      call fmunknown(mresult)
                      return
                  else
                      call fmi2m(2, mxy(18))
                      call fmeq(mxy(11), mxy(19))
                      call fmnegate(mxy(19))
                      call fmint(mxy(19), mxy(6))
                      call fmmod(mxy(6), mxy(18), mxy(12))
                      if (mxy(12)%mp(3) == 0) then
                          call fmadd(mxy(10), mxy(11), mxy(16))
                          call fmln(mxy(16), mxy(6))
                          call fmmpy(mxy(11), mxy(6), mxy(16))
                          call fmi2m(1, mxy(6))
                          call fmadd(mxy(11), mxy(6), mxy(17))
                          call fmeq(mxy(11), mxy(20))
                          call fmlngm(mxy(17), mxy(4))
                          call fmsub(mxy(4), mxy(16), mxy(6))
                          call fmexp(mxy(6), mxy(13))
                          call fmdiv_r1(mxy(13), mxy(20))
                          call fmeq(mxy(13), mresult)
                          return
                      endif
                  endif
              endif
              call fmadd(mxy(10), mxy(11), mxy(16))
              call fmln(mxy(16), mxy(6))
              call fmmpy(mxy(11), mxy(6), mxy(16))
              call fmeq(mxy(11), mxy(20))
              call fmlngm(mxy(20), mxy(17))
              call fmsub(mxy(17), mxy(16), mxy(6))
              call fmexp(mxy(6), mxy(13))
              call fmeq(mxy(13), mresult)
              return
          endif

!             See if both arguments are large.  For many of these cases, Stirling's formula can be
!             used to detect cases where the result will underflow.

          call fmdpm(1.0d7, mxy(6))
          if (fmcomp(mxy(1), '>', mxy(6)) .and. fmcomp(mxy(2), '>', mxy(6))) then
              call fmadd(mxy(1), mxy(2), mxy(6))
              call fmln(mxy(6), mxy(15))
              call fmmpy_r2(mxy(6), mxy(15))
              call fmnegate(mxy(15))
              call fmln(mxy(1), mxy(6))
              call fmmpy_r2(mxy(1), mxy(6))
              call fmadd_r1(mxy(15), mxy(6))
              call fmln(mxy(2), mxy(6))
              call fmmpy_r2(mxy(2), mxy(6))
              call fmadd_r1(mxy(15), mxy(6))
              call fmexp(mxy(15), mxy(16))
              if (mxy(16)%mp(2) == mexpun) then
                  call fmeq(mxy(16), mresult)
                  return
              endif
          endif

!             Compute iextra, the number of extra digits required to compensate for
!             cancellation error.

          mzero = 0
          mt1 = max(mxy(17)%mp(2), mxy(1)%mp(2))
          mt1 = max(mt1, mxy(2)%mp(2))
          iextra = int(max(mt1, mzero))
          mt1 = max(mxy(17)%mp(2), mxy(1)%mp(2))
          if (max(mt1, mxy(2)%mp(2)) >= mexpov)  &
              iextra = 0
          if (iextra > 0) then
              call fmequ_r1(mxy(1), ndig, ndig+iextra)
              call fmequ_r1(mxy(2), ndig, ndig+iextra)
          endif
          ndig = ndig + iextra
          call fmadd(mxy(1), mxy(2), mxy(17))
          call fmi2m(1, mxy(10))
          call fmi2m(2, mxy(11))
          call fmeq(mxy(17), mxy(22))
          k10 = 0
          k11 = 0
          kc = 0
          if (mxy(1)%mp(1) < 0) then
              call fmint(mxy(1), mxy(12))
              call fmmod(mxy(12), mxy(11), mxy(13))
              if (mxy(13)%mp(3) == 0) then
                  k10 = 1
                  call fmadd_r1(mxy(1), mxy(10))
              endif
          endif
          if (mxy(2)%mp(1) < 0) then
              call fmint(mxy(2), mxy(12))
              call fmmod(mxy(12), mxy(11), mxy(13))
              if (mxy(13)%mp(3) == 0) then
                  k11 = 1
                  call fmadd_r1(mxy(2), mxy(10))
              endif
          endif
          if (mxy(22)%mp(1) < 0) then
              call fmint(mxy(22), mxy(12))
              call fmmod(mxy(12), mxy(11), mxy(13))
              if (mxy(13)%mp(3) == 0) then
                  kc = 1
                  call fmadd_r1(mxy(22), mxy(10))
              endif
          endif
          call fmlngm(mxy(1), mxy(17))
          call fmlngm(mxy(2), mxy(20))
          call fmadd_r1(mxy(17), mxy(20))
          call fmlngm(mxy(22), mxy(20))
          call fmsub(mxy(17), mxy(20), mxy(6))
          call fmexp(mxy(6), mxy(17))
          if (k10 == 1 .or. k11 == 1 .or. kc == 1) then
              call fmi2m(1, mxy(10))
              if (k10 == 1) then
                  call fmsub_r1(mxy(1), mxy(10))
                  call fmdiv_r1(mxy(17), mxy(1))
              endif
              if (k11 == 1) then
                  call fmsub_r1(mxy(2), mxy(10))
                  call fmdiv_r1(mxy(17), mxy(2))
              endif
              if (kc == 1) then
                  call fmsub_r1(mxy(22), mxy(10))
                  call fmmpy_r1(mxy(17), mxy(22))
              endif
          endif
          call fmeq(mxy(17), mxy(22))
      else
          call fmgam(mxy(1), mxy(20))
          call fmgam(mxy(2), mxy(1))
          call fmgam(mxy(17), mxy(22))
          call fmmpy(mxy(20), mxy(1), mxy(8))
          call fmdiv_r2(mxy(8), mxy(22))
      endif

      call fmeq(mxy(22), mresult)

      return
      end subroutine fmbeta_m1

      subroutine fmbeta_sc(ma, mb, ndsave, mresult, kresult)

!  Check for special cases for mresult = beta(ma,mb).

!  kresult = 1 is returned if a special case gives the value of beta(ma,mb).

      use fmvals
      implicit none

      type(multi) :: ma, mb, mresult
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal, mblocal

      kresult = 0

      namest(ncall) = 'FMBETA   '
      j = ndig
      ndig = ndsave
      call fmntr_inp2(ma, mb)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)
      call fmequ(mb, mblocal, ndsave, ndig)

      if ((malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) .or.  &
          (mblocal%mp(2) == munkno .and. mblocal%mp(5) >= 0)) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      return
      end subroutine fmbeta_sc

      subroutine fmbig(ma)

!     ma = The biggest representable FM number using the current base and precision.
!          The smallest positive number is then 1.0/ma.
!          In some rounding modes, 1.0/(1.0/ma) may then overflow.

      use fmvals
      implicit none

      type(multi) :: ma
      intent (inout) :: ma
      integer :: j

      call fmalloc(ma, ndig+2)
      ncall = ncall + 1
      namest(ncall) = 'FMBIG    '

      if (mblogs /= mbase) call fmcons
      kflag = 0
      do j = 3, ndig+2
         ma%mp(j) = mbase - 1
      enddo
      ma%mp(2) = mxexp0 + 1
      ma%mp(1) = 1

      call fmntr_out1(ma)
      ncall = ncall - 1

      return
      end subroutine fmbig

      subroutine fmc(ma, mb)

!  mb = c(ma)    Fresnel Cosine Integral.

!  Integral from 0 to ma of cos(pi*t**2/2) dt.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(16), mresult, mretry

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmc_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      n_acc = nint(ndig*alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmc_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc)
         if (ma%mp(1) == -1) then
             call fmnegate(mresult)
         endif
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmc

      subroutine fmc_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc)

!  Method selection for computing c(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(16), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc

      double precision :: x, xe, y
      integer :: iextra, k, kflagx, nmethd
      logical, external :: fmcomp

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, ndig)
      mxy(1)%mp(1) = 1

!             Check for special cases.

      if (mxy(1)%mp(3) == 0) then
          call fmeq(mxy(1), mresult)
          retry = .false.
          return
      endif
      call fmovun_xe(mxy(1), xe)
      if (4*xe < -ndig) then
          call fmeq(mxy(1), mresult)
          retry = .false.
          return
      endif
      call fmint(mxy(1), mxy(8))
      call fmovun_xe(mxy(1), xe)
      if (3*xe > ndig .and. fmcomp(mxy(1), '==', mxy(8)) .and. xe < mexpov) then
          mxy(1)%mp(1) = ma%mp(1)
          if (mod(int(mbase), 2) == 0 .and. xe > ndsave) then
              k = 0
          else
              call fmi2m(2, mxy(8))
              call fmmod(mxy(1), mxy(8), mxy(7))
              call fmm2i(mxy(7), k)
          endif
          call fmi2m(1, mxy(8))
          if (mxy(1)%mp(1) < 0) then
              call fmdivi(mxy(8), -2, mxy(10))
          else
              call fmdivi(mxy(8), 2, mxy(10))
          endif
          if (k == 0) then
              call fmipwr(mxy(1), 3, mxy(7))
              call fmpi(mxy(6))
              call fmsqr_r1(mxy(6))
              call fmmpy_r1(mxy(6), mxy(7))
              call fmdiv_r2(mxy(8), mxy(6))
              call fmsub_r1(mxy(10), mxy(6))
          else
              call fmpi(mxy(6))
              call fmmpy_r1(mxy(6), mxy(1))
              call fmdiv_r2(mxy(8), mxy(6))
              call fmadd_r1(mxy(10), mxy(6))
          endif
          if (ma%mp(1) < 0) call fmnegate(mxy(10))
          call fmeq(mxy(10), mresult)
          retry = .false.
          return
      endif
      call fmovun_xe(mxy(1), xe)
      if (xe > ndig) then
          call fmi2m(1, mxy(8))
          if (mxy(1)%mp(1) < 0) then
              call fmdivi(mxy(8), -2, mresult)
          else
              call fmdivi(mxy(8), 2, mresult)
          endif
          retry = .false.
          return
      endif

!             x is a double precision approximation to the input argument to this function.

      call fmm2dp(mxy(1), x)
      kflagx = kflag
      call fmovun_xe(mxy(1), xe)
      if (kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif

!             If ma is large in magnitude, use more guard digits.

      iextra = min(max(int(mxy(1)%mp(2)), 0) , int(2.0+alogmx/alogmb))
      if (mxy(1)%mp(2) >= mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(1), ndig, ndig+iextra)
      endif
      ndig = ndig + iextra
      n_acc = nint(ndig*alogm2)

!             Determine which method to use.

!             nmethd = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      if (kflagx == 0) then
          if (abs(x) < sqrt(huge(x)/(4*log(huge(x))))) then
              y = (dppi*x*x-1)/2
              y = (2*y+1.5)*log(2*y+2) - (2*y+1) - y*dlogtw - (y+0.5)*log(y+1) + y - y*log(dppi*x*x)
              if (y <= -(ndig+1)*dlogmb) then
                  nmethd = 2
              else
                  nmethd = 1
              endif
          else
              nmethd = 2
          endif
      else
          call fmovun_xe(mxy(1), xe)
          if (xe <= 0) then
              nmethd = 1
          else
              nmethd = 2
          endif
      endif

      if (nmethd == 1) then
          call fmc_m1(mxy, mresult, ndsave, numtry, n_acc, kflagx, x)
      else if (nmethd == 2) then
          call fmc_m2(mxy, mresult, ndsave, numtry, n_acc)
      endif

      return
      end subroutine fmc_m

      subroutine fmc_m1(mxy, mresult, ndsave, numtry, n_acc, kflagx, x)

!  Method 1 for computing c(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(16), mresult
      integer :: ndsave, numtry, n_acc, kflagx
      double precision :: x
      intent (in) :: numtry, ndsave, kflagx, x
      intent (inout) :: mxy, mresult, n_acc

      double precision :: xe
      double precision, external :: fmnterms
      integer :: iextra, j, j2, k, kl, large, nbot, ndsav1, nterm
      type(multi), save :: mjsums(ljsums)

!             Method 1.  Use x times the series (-1)**n*(pi*x*x/2)**(2*n)/((4*n+1)*(2*n)!).

      iextra = 0
      if (kflagx == 0) then
          iextra = max(0.0d0, (0.096*x*x + 0.033*abs(x) - 0.5)*log(1.0e7)/alogmb)*1.02
          if (iextra > 0) then
              call fmequ_r1(mxy(1), ndig, ndig+iextra)
          endif
      endif
      ndig = ndig + iextra
      n_acc = nint(ndig*alogm2)
      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig-1)
      endif

      if (kflagx == 0) then
          j2 = int(0.68*sqrt(fmnterms(3.14159d0*x*x/2, 2, 0, 0, 1)) - 1.6)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = ndig

!             Split into j2 concurrent sums.

      call fmsqr(mxy(1), mxy(4))
      call fmcsdivi(mxy(4), 2, mxy(9))
      call fmpi(mxy(3))
      call fmcsmpy_r1(mxy(9), mxy(3))
      call fmi2m(1, mxy(6))
      call fmi2m(1, mjsums(1))
      nterm = 0
      do j = 2, j2
         nterm = nterm + 2
         nbot = nterm*(nterm-1)
         large = int(intmax/nterm)
         if (nterm > large .or. nbot > mxbase) then
             if (nterm > 2) call fmcsdivi_r1(mxy(6), nterm-1)
             call fmcsdivi_r1(mxy(6), nterm)
         else
             call fmcsdivi_r1(mxy(6), nbot)
         endif
         call fmcsdivi(mxy(6), 2*nterm+1, mjsums(j))
      enddo
      call fmovun_xe(mxy(1), xe)
      if (xe < -ndig) then
          kl = 0
      else
          kl = 1
          call fmipwr(mxy(9), 2*j2, mxy(7))
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(6), mxy(7))
         do j = 1, j2
            nterm = nterm + 2
            large = int(intmax/nterm)
            if (nterm > large .or. nterm > mxbase/(nterm-1)) then
                call fmcsdivi_r1(mxy(6), nterm-1)
                call fmcsdivi_r1(mxy(6), nterm)
            else
                nbot = nterm*(nterm-1)
                call fmcsdivi_r1(mxy(6), nbot)
            endif
            call fmcsdivi(mxy(6), 2*nterm+1, mxy(2))
            ndig = ndsav1
            call fmcsaddnn_r1(mjsums(j), mxy(2))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            ndig = ndsav1 - int(mjsums(j)%mp(2) - mxy(6)%mp(2))
            ndig = min(ndsav1, ndig)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         enddo
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call fmcsnsums(j2, mjsums)
      call fmsqr(mxy(9), mxy(8))
      mxy(8)%mp(1) = -1
      if (mjsums(1)%mp(1) > 0) then
          call fmeq(mjsums(1), mxy(15))
          call fmi2m(0, mxy(16))
      else
          call fmeq(mjsums(1), mxy(16))
          call fmi2m(0, mxy(15))
      endif
      call fmeq(mxy(8), mxy(12))
      do j = 1, j2-1
         call fmmpy(mxy(12), mjsums(j+1), mxy(3))
         if (mxy(3)%mp(1) > 0) then
             call fmadd_r1(mxy(15), mxy(3))
         else
             call fmadd_r1(mxy(16), mxy(3))
         endif
         call fmmpy_r1(mxy(12), mxy(8))
      enddo
      call fmadd(mxy(15), mxy(16), mxy(10))
      call fmcancel(mxy(15), mxy(16), mxy(10), k)
      n_acc = n_acc - k
      call fmmpy_r1(mxy(10), mxy(1))

      call fmeq(mxy(10), mresult)

      return
      end subroutine fmc_m1

      subroutine fmc_m2(mxy, mresult, ndsave, numtry, n_acc)

!  Method 2 for computing c(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(16), mresult
      integer :: ndsave, numtry, n_acc
      intent (in) :: ndsave, numtry
      intent (inout) :: mxy, mresult, n_acc

      integer :: krsave

!             Method 2.  use the two n!/x**n asymptotic series for f(x) and g(x).
!                        then c(x) = 0.5 + f(x)*sin(pi*x*x/2) - g(x)*cos(pi*x*x/2).

      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig-1)
      endif
      n_acc = nint(ndig*alogm2)
      call fmfgfi(mxy(1), mxy(11), mxy(12))
      call fmsqr(mxy(1), mxy(4))
      krsave = krad
      krad = 0
      call fmmpyi(mxy(4), 90, mxy(7))
      call fmcssn(mxy(7), mxy(13), mxy(14))
      krad = krsave
      if (mxy(1)%mp(2) == munkno .and. mxy(1)%mp(5) < 0 .and.        &
          ( (mxy(13)%mp(2) == munkno .and. mxy(13)%mp(5) >= 0) .or.  &
            (mxy(14)%mp(2) == munkno .and. mxy(14)%mp(5) >= 0) )) then
          call fmunknown(mxy(10))
          mxy(10)%mp(4) = 0
          mxy(10)%mp(5) = -maxint * 0.5d0
      else
          call fmmpy(mxy(11), mxy(14), mxy(10))
          call fmmpy(mxy(12), mxy(13), mxy(7))
          call fmi2m(1, mxy(4))
          call fmdivi(mxy(4), 2, mxy(5))
          call fmadd(mxy(5), mxy(10), mxy(6))
          call fmsub(mxy(6), mxy(7), mxy(10))
      endif

      call fmeq(mxy(10), mresult)

      return
      end subroutine fmc_m2

      subroutine fmc_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = c(ma).

!  kresult = 1 is returned if a special case gives the value of c(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(16), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      double precision :: xe, ye
      integer :: j, k, kl, krsave, nds
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMC      '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      k = 0
      if (kround /= 1) then
          j = ntrace
          ntrace = 0
          kl = kwarn
          kwarn = 0
          call fmdp2m(1.0d-10, mxy(1))
          call fmulp(mxy(1), mxy(2))
          call fmsqrt(mxy(2), mxy(3))
          call fmsqrt(mxy(3), mxy(2))
          call fmabs(malocal, mxy(3))
          call fmsub(mxy(3), mxy(2), mxy(4))
          if (mxy(4)%mp(1) < 0) k = 1
          ntrace = j
          kwarn = kl
      endif
      if (kround /= 1 .and. k == 1) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          krsave = kround
          kround = 1
          nds = ndig
          ndig = ndig + ngrd52
          call fmequ(malocal, mxy(1), nds, ndig)
          call fmipwr(mxy(1), 5, mxy(2))
          call fmpi(mxy(3))
          call fmsqr(mxy(3), mxy(4))
          call fmdivi(mxy(4), 40, mxy(3))
          call fmmpy(mxy(2), mxy(3), mxy(5))
          call fmeq(mxy(1), mxy(4))
          call fmovun_xe(mxy(4), xe)
          call fmovun_xe(mxy(5), ye)
          if (xe - ye > ndsave .and. mxy(4)%mp(2) > mexpun) then
              call fmequ(mxy(4), mxy(10), ndig, nds)
              call fmequ(mxy(4), mxy(6), ndig, nds)
              call fmequ(mxy(6), mxy(8), nds, ndig)
              call fmsub(mxy(4), mxy(8), mxy(6))
              if (mxy(6)%mp(3) == 0) then
                  call fmequ(mxy(4), mxy(6), ndig, nds)
                  call fmequ(mxy(5), mxy(7), ndig, nds)
                  ndig = nds
                  kround = krsave
                  call fmsub(mxy(6), mxy(7), mresult)
                  if (mresult%mp(2) >= mexpov) then
                      if (mxy(6)%mp(1) > 0) then
                          if (mxy(7)%mp(1) > 0 .and. (kround == -1 .or. kround == 0)) then
                              call fmeq(mxy(6), mxy(1))
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2))
                              call fmsub(mxy(1), mxy(2), mxy(3))
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mresult)
                          else if (mxy(7)%mp(1) < 0 .and. kround == 2) then
                              call fmeq(mxy(6), mxy(1))
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2))
                              call fmadd(mxy(1), mxy(2), mxy(3))
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mresult)
                          else
                              kround = krsave
                              call fmeq(mxy(10), mresult)
                          endif
                      else
                          if (mxy(7)%mp(1) > 0 .and. kround == -1) then
                              call fmeq(mxy(6), mxy(1))
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2))
                              call fmadd(mxy(1), mxy(2), mxy(3))
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mresult)
                          else if (mxy(7)%mp(1) < 0 .and. (kround == 2 .or. kround == 0)) then
                              call fmeq(mxy(6), mxy(1))
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2))
                              call fmsub(mxy(1), mxy(2), mxy(3))
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mresult)
                          else
                              kround = krsave
                              call fmeq(mxy(10), mresult)
                          endif
                      endif
                  endif
              else
                  kround = krsave
                  call fmequ(mxy(4), mresult, ndig, nds)
              endif
              kflag = 0
              ntrace = j
              kwarn = k
              ndig = nds
              kround = krsave
              kresult = 1
              return
          endif
          kflag = 0
          ntrace = j
          kwarn = k
          ndig = nds
          kround = krsave
      endif

      return
      end subroutine fmc_sc

      subroutine fmcancel(ma, mb, mc, nc)
      use fmvals
      implicit none

!  Return nc as the number of bits of precision lost to cancellation after
!  mc = ma + mb or mc = ma - mb.

      type(multi) :: ma, mb, mc
      integer :: nc
      intent (in) :: ma, mb, mc
      intent (inout) :: nc

      type(multi), save :: mxy(5)

      if (ma%mp(3) == 0 .or. ma%mp(3) == 0) then
          nc = 0
          return
      endif
      if (mc%mp(3) == 0) then
          nc = nint(ndig*alogm2)
          return
      endif
      if (abs(ma%mp(2)) >= mexpov .or. abs(mb%mp(2)) >= mexpov .or.  &
          abs(mc%mp(2)) >= mexpov) then
          nc = 0
          return
      endif

      call fmabs(ma, mxy(1))
      call fmabs(mb, mxy(2))
      call fmabs(mc, mxy(3))
      call fmmax(mxy(1), mxy(2), mxy(4))
      call fmdiv(mxy(4), mxy(3), mxy(5))
      nc = ( mxy(5)%mp(2)*log(dble(mbase)) +  &
           log(mxy(5)%mp(3)/dble(mbase) + mxy(5)%mp(4)/dble(mbase)**2) ) / 0.69314718056d0

      return
      end subroutine fmcancel

      subroutine fmchangebase(ma, mb, new_mbase, new_ndig)

!  Change the internal representation of a number from one base to another.
!  ma is given with ndig digits in base mbase (the current precision and base).
!  mb is returned as the same number, approximated with new_ndig digits in base new_mbase.

!  Note ndig and mbase are unchanged after calling fmchangebase, but if mb is to be used
!  in further operations, ndig and mbase should be changed to the new values in the calling program.
!
!  This routine is primarily meant to be used by the input and output conversion routines when the
!  base being used is not a power of ten.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: new_mbase, new_ndig
      intent (in) :: ma, new_mbase, new_ndig
      intent (inout) :: mb

      type(multi), save :: mxy(4), mresult
      integer :: j, kovun, ndsave
      real (kind(1.0d0)) :: mbsave, mxsave

      j = ntrace
      ntrace = 0
      call fmalloc(mb, new_ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      ndig = ndsave
      mbsave = mbase
      mbase = new_mbase
      call fmchangebase_sc(ma, mbsave, new_ndig)
      call fmalloc(mresult, ndig+2)

      call fmchangebase_m1(ma, mxy, mresult, mbsave, ndsave)

      call fmequ(mresult, mb, ndig, new_ndig)
      ncall = ncall - 1
      ntrace = j
      mbase = mbsave
      mxexp = mxsave
      ndig = ndsave
      call fmcons

      return
      end subroutine fmchangebase

      subroutine fmchangebase_m1(ma, mxy, mresult, mbsave, ndsave)

!  Method 1 for computing changebase(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: ndsave
      real (kind(1.0d0)) :: mbsave
      intent (in) :: ma, mbsave, ndsave
      intent (inout) :: mxy, mresult

      type(multi), save :: mbpowers(9)
      integer :: k, krndsave

!             The change of base is done by summing this series in the new base:
!                 d(1)/b + d(2)/b**2 + ... + d(k)/b**k
!             where d(i) is the i-th digit in the old base, b.

!             Initialize the array of powers of the base.

      krndsave = kround
      kround = 1
      call imi2m2(1, mxy(3))
      do k = 1, 9
         call immpyi2(mxy(3), int(mbsave), mbpowers(k))
         call imeq(mbpowers(k), mxy(3))
      enddo

      call fmchangebase_tq(ma, mbsave, 0, ndsave-1, mxy(1), mxy(2), mbpowers)

      call imi2fm(mxy(1), mxy(3))
      call imi2fm(mxy(2), mxy(4))
      call fmdiv2(mxy(3), mxy(4), mxy(2))

!             Put the exponent and sign on mresult.

      k = mbsave
      call fmi2m2(k, mxy(3))
      k = ma%mp(2)
      if (k /= 0) then
          call fmipwr2(mxy(3), k, mxy(4))
          call fmmpy2(mxy(2), mxy(4), mxy(1))
          call fmeq(mxy(1), mxy(2))
      endif
      mxy(2)%mp(1) = ma%mp(1)
      call fmeq(mxy(2), mresult)
      kround = krndsave

      return
      end subroutine fmchangebase_m1

      subroutine fmchangebase_sc(ma, mbsave, new_ndig)

!  Reset base and precision for the base conversion.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: new_ndig
      real (kind(1.0d0)) :: mbsave
      intent (in) :: ma, mbsave, new_ndig

      integer :: iextra

      call fmcons
      ndig = new_ndig + ngrd52

!             If the exponent is large, raise the precision.

      iextra = max(0, abs(int(log(max(1.0d0, dble(abs(ma%mp(2)))))/log(dble(mbsave))))+1)
      if (abs(ma%mp(2)) >= mexpov) iextra = 0
      ndig = ndig + iextra

      return
      end subroutine fmchangebase_sc

      recursive subroutine fmchangebase_tq(ma, mbsave, a, b, mt, mq, mbpowers)

!  This routine does the binary splitting for computing a change of base.

      use fmvals
      implicit none

      type(multi) :: ma, mt, mq, mbpowers(9)
      integer :: a, b
      real (kind(1.0d0)) :: mbsave
      intent (in) :: ma, a, b, mbsave, mbpowers
      intent (inout) :: mt, mq

      type(multi) :: mxy(4)
      integer :: digit, j, k, m, old_base, result_size
      real (kind(0.0d0)) :: da, db, dm

      da = a
      db = b
      dm = mbsave
      old_base = mbsave
      result_size = ( (db-da+1)*log(dm) + 5 ) / dlogmb + 8
      result_size = max(5, result_size)
      call fmalloc(mt, result_size)
      call fmalloc(mq, result_size)

      if (b-a < 9) then
          call fmalloc(mxy(1), result_size)
          call fmalloc(mxy(2), result_size)
          digit = ma%mp(a+3)
          call imi2m2(digit, mt)
          do j = a+1, b
             call immpyi2(mt, old_base, mxy(2))
             digit = ma%mp(j+3)
             call imi2m2(digit, mxy(1))
             call imadd2(mxy(2), mxy(1), mt)
          enddo

!             There may be thousands of calls, all with k = 5,6,7,8,9.
!             These powers are saved instead of re-computing them each time.

          k = b - a + 1
          call imeq(mbpowers(k), mq)
          return
      endif

      m = a/2 + b/2 + mod(a, 2)*mod(b, 2)
      call fmchangebase_tq(ma, mbsave, a, m-1, mxy(1), mxy(2), mbpowers)
      call fmchangebase_tq(ma, mbsave, m, b, mxy(3), mxy(4), mbpowers)
      call immpy2(mxy(1), mxy(4), mq)
      call imadd2(mxy(3), mq, mt)

      call immpy2(mxy(2), mxy(4), mq)

      return
      end subroutine fmchangebase_tq

      subroutine fmcheck_accuracy(ma, ndsave, retry)

!  Internal routine used by routines that need to check for rounding accuracy.

!  Return retry = .true. if we need to try again with more guard digits because the current
!  guard digits in ma are too close to 1/2 ulp.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: ndsave
      logical :: retry
      intent (in) :: ma, ndsave
      intent (inout) :: retry

      integer :: j, kl
      double precision :: err

      if (abs(ma%mp(2)) >= mexpov) return
      if (ndig >= 2*ndsave+10) return
      if (ncall <= 1) then
          kl = min(ndig-ndsave, int(3*dlogtn/dlogmb + 2.5))
          err = 0
          do j = kl, 1, -1
             err = (err + ma%mp(j+ndsave+2)) / mbase
          enddo
          if ((kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
              (kround /= 1 .and. (err > 0.998 .or. err < 0.002))) then
              ndig = 2*ndsave+10
              retry = .true.
          endif
      endif

      return
      end subroutine fmcheck_accuracy

      subroutine fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)

!  FM special functions monitor cancellation error to see if a retry is needed at higher precision.

      use fmvals
      implicit none

      integer :: n_acc, ndsave, numtry
      type(multi) :: mresult, mretry
      logical :: retry
      intent (in) :: mresult, ndsave
      intent (inout) :: n_acc, numtry, mretry, retry

      integer :: iextra, j, kl, ndold, ngoal, ndgoal

      if (ncall >= 1 .and. abs(mresult%mp(2)) <= mxexp) then
          ngoal = int(real(ndsave)*alogm2) + 17
      else
          ngoal = int(-mxexp2)
      endif

      if (n_acc <= ngoal) then
          if (numtry > 0) then
              ndgoal = int(real(ngoal)/alogm2 + 1.0)
              kl = 0
              do j = 1, ndgoal+1
                 if (mretry%mp(j+1) /= mresult%mp(j+1)) then
                     kl = 1
                     exit
                 endif
              enddo
              if (kl == 0) then
                  return
              endif
          endif
          iextra = int(real(ngoal-n_acc)/alogm2 + 23.03/alogmb) + 1
          ndold = ndig
          ndig = ndig + iextra
          call fmequ(mresult, mretry, ndold, ndig)
          retry = .true.
      endif

      return
      end subroutine fmcheck_cancellation

      subroutine fmchi(ma, mb)

!  mb = hyperbolic cosine integral(ma)

!  eulergamma + ln(ma) + integral from 0 to ma of ( cosh(t) - 1 ) / t  dt.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(11), mresult, mretry

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmchi_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      n_acc = nint(ndig*alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmchi_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmchi

      subroutine fmchi_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc)

!  Method selection for computing hyperbolic cosine integral(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(11), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc

      double precision :: x, y
      double precision :: d, xe
      integer :: iextra, kflagx, nmethd

      retry = .true.

      n_acc = nint(ndig*alogm2)
      call fmequ(ma, mxy(1), ndsave, ndig)

!             x is a double precision approximation to the input argument to this function.

      call fmm2dp(mxy(1), x)
      kflagx = kflag
      call fmovun_xe(mxy(1), xe)
      if (kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif

!             If ma is large in magnitude, use more guard digits.

      iextra = min(max(int(mxy(1)%mp(2)), 0) , int(2.0+alogmx/alogmb))
      if (mxy(1)%mp(2) >= mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(1), ndig, ndig+iextra)
      endif
      ndig = ndig + iextra
      n_acc = nint(ndig*alogm2)

!             Check for special cases.

      if (mxy(1)%mp(1) == -1 .or. mxy(1)%mp(3) == 0) then
          call fmunknown(mresult)
          kflag = -4
          retry = .false.
          return
      endif
      if (mxy(1)%mp(2) == mexpov) then
          call fmoverflow(1, mxy(7))
          if (huge(mbase)/mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          mxy(7)%mp(4) = huge(mbase)/d
          mxy(7)%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
          kflag = -5
          call fmeq(mxy(7), mresult)
          retry = .false.
          return
      endif

!             Determine which method to use.

!             nmethd = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      nmethd = 1
      if (kflagx /= 0) then
          call fmovun_xe(mxy(1), xe)
          if (xe <= 0) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          y = (ndig+5)*dlogmb
          if (abs(x) > y+(dlogtp+log(y))/2.0d0) nmethd = 2
      endif

      if (nmethd == 1) then
          call fmchi_m1(mxy, mresult, ndsave, numtry, kflagx, n_acc, x)
      else if (nmethd == 2) then
          call fmchi_m2(mxy, mresult, ndsave, numtry, n_acc)
      endif

      return
      end subroutine fmchi_m

      subroutine fmchi_m1(mxy, mresult, ndsave, numtry, kflagx, n_acc, x)

!  Method 1 for computing hyperbolic cosine integral(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(11), mresult
      integer :: ndsave, numtry, kflagx, n_acc
      double precision :: x
      intent (in) :: numtry, ndsave, kflagx, x
      intent (inout) :: mxy, mresult, n_acc

      double precision, external :: fmnterms
      double precision :: xe
      integer :: j, j2, k, kl, large, nbot, ndsav1, nterm
      type(multi), save :: mjsums(ljsums)

!             Method 1.  Use the gamma + ln(x) + x**(2*n)/((2*n)*(2*n)!) series.

      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig-1)
      endif
      n_acc = nint(ndig*alogm2)
      if (kflagx == 0) then
          j2 = int(0.62*sqrt(fmnterms(x, 2, 0, 0, 1)) - 1.3)
          j2 = max(1, min(ljsums, j2))
      else
          j2 = 2
      endif
      ndsav1 = ndig

!             Split into j2 concurrent sums.

      call fmsqr(mxy(1), mxy(2))
      call fmcsdivi(mxy(2), 2, mxy(6))
      call fmcsdivi(mxy(6), 2, mjsums(1))
      nterm = 2
      do j = 2, j2
         nterm = nterm + 1
         call fmcsdivi_r1(mxy(6), nterm)
         nterm = nterm + 1
         nbot = nterm
         call fmcsdivi_r1(mxy(6), nbot)
         call fmcsdivi(mxy(6), nterm, mjsums(j))
      enddo
      call fmovun_xe(mxy(1), xe)
      if (xe < -ndig) then
          kl = 0
      else
          kl = 1
          call fmipwr(mxy(1), 2*j2, mxy(4))
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(6), mxy(4))
         do j = 1, j2
            nterm = nterm + 2
            large = int(intmax/nterm)
            if (nterm > large .or. nterm > mxbase/(nterm-1)) then
                call fmcsdivi_r1(mxy(6), nterm)
                nbot = (nterm - 1)
                call fmcsdivi_r1(mxy(6), nbot)
            else
                nbot = nterm*(nterm-1)
                call fmcsdivi_r1(mxy(6), nbot)
            endif
            call fmcsdivi(mxy(6), nterm, mxy(3))
            ndig = ndsav1
            call fmcsaddnn_r1(mjsums(j), mxy(3))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            ndig = ndsav1 - int(mjsums(j)%mp(2) - mxy(3)%mp(2))
            ndig = min(ndsav1, ndig)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         enddo
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call fmcsnsums(j2, mjsums)
      call fmeq(mjsums(j2), mxy(7))
      if (j2 >= 2) then
          call fmsqr(mxy(1), mxy(5))
          do j = 2, j2
             call fmcsmpy_r1(mxy(7), mxy(5))
             call fmadd_r1(mxy(7), mjsums(j2-j+1))
          enddo
      endif
      call fmeulr(mxy(9))
      call fmadd(mxy(7), mxy(9), mxy(3))
      call fmln(mxy(1), mxy(2))
      call fmadd(mxy(3), mxy(2), mxy(7))
      call fmcancel(mxy(3), mxy(2), mxy(7), k)
      n_acc = n_acc - k

      call fmeq(mxy(7), mresult)

      return
      end subroutine fmchi_m1

      subroutine fmchi_m2(mxy, mresult, ndsave, numtry, n_acc)

!  Method 2 for computing hyperbolic cosine integral(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(11), mresult
      integer :: ndsave, numtry, n_acc
      intent (in) :: ndsave, numtry
      intent (inout) :: mxy, mresult, n_acc

      double precision :: xe

!             Method 2.  Use the two n!/x**n asymptotic series for f(x) and g(x).
!                        then chi(x) = f(x)*sinh(x) + g(x)*cosh(x).

      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig-2)
      endif
      n_acc = nint(ndig*alogm2)
      call fmfhgh(mxy(1), mxy(8), mxy(9))
      call fmchsh(mxy(1), mxy(10), mxy(11))
      call fmovun_xe(mxy(10), xe)
      if (xe < mexpov) then
          call fmmpy(mxy(8), mxy(11), mxy(7))
          call fmmpy(mxy(9), mxy(10), mxy(4))
          call fmadd_r1(mxy(7), mxy(4))
      else
          call fmadd(mxy(8), mxy(9), mxy(4))
          call fmdivi_r1(mxy(4), 2)
          call fmln(mxy(4), mxy(7))
          call fmadd(mxy(1), mxy(7), mxy(4))
          call fmexp(mxy(4), mxy(7))
      endif

      call fmeq(mxy(7), mresult)

      return
      end subroutine fmchi_m2

      subroutine fmchi_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = hyperbolic cosine integral(ma).

!  kresult = 1 is returned if a special case gives the value of hyperbolic cosine integral(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMCHI    '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      return
      end subroutine fmchi_sc

      subroutine fmchsh(ma, mb, mc)

!  mb = cosh(ma),    mc = sinh(ma)

!  If both the hyperbolic sine and cosine are needed, this routine is faster than calling both
!  fmcosh and fmsinh.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc

      type(multi), save :: mresult1, mresult2
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(3)

      call fmalloc(mb, ndig+2)
      call fmalloc(mc, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmchsh_sc(ma, mxy, ndsave, mresult1, mresult2, kresult)
      if (kresult > 0) then
          call fmexit2(mresult1, mresult2, mb, mc, kovun, mxsave, ndsave)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmchsh_m1(ma, mxy, mresult1, mresult2, ndsave)
         call fmcheck_accuracy(mresult1, ndsave, retry)
         if (retry) cycle
         call fmcheck_accuracy(mresult2, ndsave, retry)
      enddo

      call fmexit2(mresult1, mresult2, mb, mc, kovun, mxsave, ndsave)

      return
      end subroutine fmchsh

      subroutine fmchsh_m1(ma, mxy, mresult1, mresult2, ndsave)

!  Method 1 for computing fmchsh(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(3), mresult1, mresult2
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult1, mresult2

      integer :: k
      integer :: krndsave

      krndsave = kround
      kround = 1
      call fmequ(ma, mxy(3), ndsave, ndig)
      mxy(3)%mp(1) = 1

      k = 1
      if (mxy(3)%mp(2) == 0 .and. mxy(3)%mp(3) /= 0) then
          if (mbase/mxy(3)%mp(3) >= 100) k = 2
      endif
      if (mxy(3)%mp(2) >= 0 .and. mxy(3)%mp(3) /= 0 .and. k == 1) then
          call fmcosh(mxy(3), mresult1)
          if (mresult1%mp(2) > ndig) then
              call fmeq(mresult1, mresult2)
              mresult2%mp(1) = ma%mp(1)
              return
          endif
          call fmsqr(mresult1, mxy(2))
          call fmi2m(-1, mxy(1))
          call fmadd_r1(mxy(2), mxy(1))
          call fmsqrt(mxy(2), mresult2)
      else
          call fmsinh(mxy(3), mresult2)
          call fmsqr(mresult2, mxy(2))
          call fmi2m(1, mxy(1))
          call fmadd_r1(mxy(2), mxy(1))
          call fmsqrt(mxy(2), mresult1)
      endif
      mresult2%mp(1) = ma%mp(1)

      kround = krndsave

      return
      end subroutine fmchsh_m1

      subroutine fmchsh_sc(ma, mxy, ndsave, mresult1, mresult2, kresult)

!  Check for special cases for fmchsh(ma).

!  kresult = 1 is returned if a special case gives the values of the two results.

      use fmvals
      implicit none

      type(multi) :: ma, mxy(3), mresult1, mresult2
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult1, mresult2, kresult

      integer :: j

      kresult = 0

      namest(ncall) = 'FMCHSH   '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, mxy(1), ndsave, ndig)

      if (mxy(1)%mp(2) == munkno .and. mxy(1)%mp(5) >= 0) then
          call fmunknown(mresult1)
          call fmunknown(mresult2)
          kresult = 1
          return
      endif

      if (abs(mxy(1)%mp(2)) >= mexpov) then
          call fmcosh(mxy(1), mresult1)
          call fmsinh(mxy(1), mresult2)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (kround /= 1 .and. mxy(1)%mp(2) < -ndsave) then
          call fmcosh(mxy(1), mresult1)
          call fmsinh(mxy(1), mresult2)
          kresult = 1
          return
      endif
      if (abs(mxy(1)%mp(2)) > mexpab) then
          call fmcosh(mxy(1), mresult1)
          call fmsinh(mxy(1), mresult2)
          kresult = 1
          return
      endif

      return
      end subroutine fmchsh_sc

      subroutine fmci(ma, mb)

!  mb = cosine integral(ma)

!  Integral from ma to infinity of -cos(t) / t  dt.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(13), mresult, mretry

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmci_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      n_acc = nint(ndig*alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmci_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmci

      subroutine fmci_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc)

!  Method selection for computing cosine integral(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc

      double precision :: x, xe, y
      integer :: iextra, kflagx, nmethd

      retry = .true.

      n_acc = nint(ndig*alogm2)
      call fmequ(ma, mxy(1), ndsave, ndig)

!             x is a double precision approximation to the input argument to this function.

      call fmm2dp(mxy(1), x)
      kflagx = kflag
      call fmovun_xe(mxy(1), xe)
      if (kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif

!             If ma is large in magnitude, use more guard digits.

      iextra = min(max(int(mxy(1)%mp(2)), 0) , int(2.0+alogmx/alogmb))
      if (mxy(1)%mp(2) >= mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(1), ndig, ndig+iextra)
      endif
      ndig = ndig + iextra
      n_acc = nint(ndig*alogm2)

!             Determine which method to use.

!             nmethd = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      nmethd = 1
      if (kflagx /= 0) then
          call fmovun_xe(mxy(1), xe)
          if (xe <= 0) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          y = (ndig+5)*dlogmb
          if (abs(x) > y+(dlogtp+log(y))/2.0d0) nmethd = 2
      endif

      if (nmethd == 1) then
          call fmci_m1(mxy, mresult, numtry, n_acc, kflagx, x)
      else if (nmethd == 2) then
          call fmci_m2(mxy, mresult)
      endif

      return
      end subroutine fmci_m

      subroutine fmci_m1(mxy, mresult, numtry, n_acc, kflagx, x)

!  Method 1 for computing cosine integral(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(13), mresult
      integer :: numtry, n_acc, kflagx
      double precision :: x
      intent (in) :: numtry, kflagx, x
      intent (inout) :: mxy, mresult, n_acc

      double precision :: xe, y
      integer :: iextra, j, j2, k, kl, large, nbot, ndsav1, nterm
      type(multi), save :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 1.  Use the  gamma + ln(x) + (-1)**n*x**(2*n)/((2*n)*(2*n)!) series.

      iextra = 0
      if (kflagx == 0) then
          y = nint(abs(x)/2)
          y = 2*y*log(abs(x)+1.0e-9) - log(2*y+1.0e-9) - (2*y+0.5)*log(2*y+1) + 2*y
          y = 1.03*y/dlogmb
          iextra = max(0, int(y+1))
      endif
      if (iextra > 0) then
          call fmequ_r1(mxy(1), ndig, ndig+iextra)
      endif
      if (abs(x) < 5 .and. numtry <= 0) then
          ndig = ndig - 2
          n_acc = nint(ndig*alogm2)
          iextra = 0
      endif
      ndig = ndig + iextra
      n_acc = nint(ndig*alogm2)

      if (kflagx == 0) then
          j2 = int(0.64*sqrt(fmnterms(x, 2, 0, 0, 1)) - 1.4)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = ndig
      call fmi2m(0, mxy(12))
      call fmi2m(0, mxy(13))

!             Split into j2 concurrent sums.

      call fmsqr(mxy(1), mxy(2))
      call fmcsdivi(mxy(2), 2, mxy(6))
      call fmcsdivi(mxy(6), 2, mjsums(1))
      nterm = 2
      do j = 2, j2
         nterm = nterm + 2
         large = int(intmax/nterm)
         nbot = nterm*(nterm-1)
         if (nterm > large .or. nbot > mxbase) then
             call fmcsdivi_r1(mxy(6), nterm-1)
             call fmcsdivi_r1(mxy(6), nterm)
         else
             call fmcsdivi_r1(mxy(6), nbot)
         endif
         call fmcsdivi(mxy(6), nterm, mjsums(j))
      enddo
      call fmovun_xe(mxy(1), xe)
      if (xe < -ndig) then
          kl = 0
      else
          kl = 1
          call fmipwr(mxy(1), 2*j2, mxy(4))
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(6), mxy(4))
         do j = 1, j2
            nterm = nterm + 2
            large = int(intmax/nterm)
            if (nterm > large .or. nterm > mxbase/(nterm-1)) then
                call fmcsdivi_r1(mxy(6), nterm-1)
                call fmcsdivi_r1(mxy(6), nterm)
            else
                nbot = nterm*(nterm-1)
                call fmcsdivi_r1(mxy(6), nbot)
            endif
            call fmcsdivi(mxy(6), nterm, mxy(3))
            ndig = ndsav1
            call fmcsaddnn_r1(mjsums(j), mxy(3))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            ndig = ndsav1 - int(mjsums(j)%mp(2) - mxy(3)%mp(2))
            ndig = min(ndsav1, ndig)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         enddo
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call fmcsnsums(j2, mjsums)
      call fmsqr(mxy(1), mxy(5))
      mxy(5)%mp(1) = -1
      if (mjsums(1)%mp(1) > 0) then
          call fmeq(mjsums(1), mxy(12))
          call fmi2m(0, mxy(13))
      else
          call fmeq(mjsums(1), mxy(13))
          call fmi2m(0, mxy(12))
      endif
      call fmeq(mxy(5), mxy(7))
      do j = 1, j2-1
         call fmmpy(mxy(7), mjsums(j+1), mxy(3))
         if (mxy(3)%mp(1) > 0) then
             call fmadd_r1(mxy(12), mxy(3))
         else
             call fmadd_r1(mxy(13), mxy(3))
         endif
         call fmmpy_r1(mxy(7), mxy(5))
      enddo
      call fmmpyi(mxy(12), -1, mxy(3))
      call fmmpyi(mxy(13), -1, mxy(12))
      call fmeq(mxy(3), mxy(13))
      call fmeulr(mxy(9))
      call fmadd_r1(mxy(12), mxy(9))
      call fmln(mxy(1), mxy(2))
      if (mxy(2)%mp(1) > 0) then
          call fmadd_r1(mxy(12), mxy(2))
      else
          call fmadd_r1(mxy(13), mxy(2))
      endif
      call fmadd(mxy(12), mxy(13), mxy(7))
      call fmcancel(mxy(12), mxy(13), mxy(7), k)
      n_acc = n_acc - k

      call fmeq(mxy(7), mresult)

      return
      end subroutine fmci_m1

      subroutine fmci_m2(mxy, mresult)

!  Method 2 for computing cosine integral(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(13), mresult
      intent (inout) :: mxy, mresult

      integer :: krsave

!             Method 2.  Use the two n!/x**n asymptotic series for f(x) and g(x).
!                        Then ci(x) = f(x)*sin(x) - g(x)*cos(x).

      call fmfxgx(mxy(1), mxy(8), mxy(9))
      krsave = krad
      krad = 1
      call fmcssn(mxy(1), mxy(10), mxy(11))
      krad = krsave
      call fmmpy(mxy(8), mxy(11), mxy(7))
      call fmmpy(mxy(9), mxy(10), mxy(4))
      call fmsub_r1(mxy(7), mxy(4))

      call fmeq(mxy(7), mresult)

      return
      end subroutine fmci_m2

      subroutine fmci_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = cosine integral(ma).

!  kresult = 1 is returned if a special case gives the value of cosine integral(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMCI     '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      if (malocal%mp(1) < 0 .or. malocal%mp(3) == 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      if (malocal%mp(2) == mexpov) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      return
      end subroutine fmci_sc

      subroutine fmcmbi(n, k, ma)

!  Internal routine for computing binomial coefficients for integers.

!  ma = n choose k.

      use fmvals
      implicit none

      integer :: n, k
      type(multi) :: ma
      intent (in) :: n, k
      intent (inout) :: ma

      integer :: intndg, j, kstart, kt, l, large, larged, ndiv, ndsave, nextd, nextn, nmpy, ntd, ntn

      if (mblogs /= mbase) call fmcons
      l = min(k, n-k)
      if (k < 0 .or. k > n) then
          call fmi2m(0,ma)
          return
      endif
      if (l <= 0) then
          call fmi2m(1, ma)
          return
      endif
      if (l <= 1) then
          call fmi2m(n, ma)
          return
      endif

!             Find the largest value for n choose j using integers.

      ntn = n
      ntd = 1
      large = int(intmax/n)
      do j = 2, l
         if (ntn <= large) then
             ntn = (ntn*((n+1)-j))/j
         else
             call fmi2m(ntn, ma)
             ntn = (n+1) - j
             ntd = j
             exit
         endif
      enddo

      if (ntd == 1) then
          call fmi2m(ntn, ma)
          return
      endif

      intndg = int(alogmx/alogmb + 1.0)
      nextn = ntn
      nextd = ntd
      kstart = ntd + 1
      ndsave = ndig

!             Compute the rest of n choose k.

      larged = min(large, int(mxbase))
      do kt = kstart, l
         nextn = nextn - 1
         nextd = nextd + 1
         if (ntn >= large .or. ntd >= larged) then
             ndig = max(3, min(ndsave, int(ma%mp(2))+intndg))
             call fmcsmpyi_r1(ma, ntn)
             call fmcsdivi_r1(ma, ntd)
             ntn = nextn
             ntd = nextd
             cycle
         endif
         nmpy = ntn*nextn
         ndiv = ntd*nextd
         if (nmpy <= large .and. ndiv <= larged) then
             ntn = nmpy
             ntd = ndiv
         else
             call fmgcdi(nmpy, ndiv)
             if (nmpy <= large .and. ndiv <= larged) then
                 ntn = nmpy
                 ntd = ndiv
             else
                 ndig = max(3, min(ndsave, int(ma%mp(2))+intndg))
                 call fmcsmpyi_r1(ma, ntn)
                 call fmcsdivi_r1(ma, ntd)
                 ntn = nextn
                 ntd = nextd
             endif
         endif
      enddo
      ndig = max(3, min(ndsave, int(ma%mp(2))+intndg))
      call fmgcdi(ntn, ntd)
      call fmcsmpyi_r1(ma, ntn)
      call fmcsdivi_r1(ma, ntd)
      ndig = ndsave

      return
      end subroutine fmcmbi

      subroutine fmcomb(ma, mb, mc)

!  mc = ma choose mb.  (Binomial coefficient -- uses gamma for non-integers)

!  mc = (ma)! / ( (mb)! * (ma-mb)! )

!  This routine extends this definition to allow negative integer values for ma and/or mb.
!  The standard recurrence comb(n,k) = comb(n-1,k-1) + comb(n-1,k) can be used to define
!  comb(n,k) for all integers n,k starting from the initializing definitions
!  comb(0,k) = 0, for all k except 0,
!  comb(n,0) = 1, for all n.
!  Ex:  n = 1, k = 1 => comb(1,1) = comb(0,0)   +  comb(0,1)
!                    => comb(1,1) =         1   +          0,  so  comb(1,1)   =  1
!       n = 0, k = 0 => comb(0,0) = comb(-1,-1) + comb(-1,0)
!                    =>         1 = comb(-1,-1) +          1,  so  comb(-1,-1) =  0
!       n = 0, k = 1 => comb(0,1) = comb(-1,0)  + comb(-1,1)
!                    =>         0 =          1  + comb(-1,1),  so  comb(-1,1)  = -1

!  This definition agrees with the standard factorial definition when n and k are non-negative
!  integers.  The factorial definition is undefined when n or k is a negative integer, since
!  x! has singularities at negative integers.

!  For negative integer n or k, this extended definition simplifies to:
!  if k < 0,             comb(n,k) = 0
!  if k >= 0 and n < 0,  comb(n,k) = (-1)**k * comb(-n+k-1,k)

!  These extended definitions are useful in some combinatorial applications.
!  Reference:  Concrete Mathematics - Graham, Knuth, Patashnik, Addison-Wesley, 1989.


      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(17), mresult

      call fmalloc(mc, ndig+2)
      call fmenter2(ma, mb, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmcomb_sc(ma, mb, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mc, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call fmcomb_m1(ma, mb, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mc, kovun, mxsave, ndsave)

      return
      end subroutine fmcomb

      subroutine fmcomb_m1(ma, mb, mxy, mresult, ndsave)

!  Method 1 for computing comb(ma,mb).

      use fmvals
      implicit none

      type(multi) :: ma, mb, mxy(17), mresult
      integer :: ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult

      real (kind(1.0d0)) :: mzero, mt1
      real :: x
      integer :: iextra, j, jr, k, k09, k10, k11, kbot, kc, kflgk, kflgnk,  &
                 ksign, kwrnsv, large, n, nbot, nk
      logical :: lc1, lc2, lc3
      logical, external :: fmcomp

      call fmequ(ma, mxy(1), ndsave, ndig)
      call fmequ(mb, mxy(2), ndsave, ndig)

      k = 0
      if (ma%mp(1) < 0) then
          k10 = ntrace
          ntrace = 0
          k11 = kwarn
          kwarn = 0
          call fmm2i(mxy(1), j)
          if (kflag == 0) k = 1
          ntrace = k10
          kwarn = k11
      endif

      if (ma%mp(2) >= mexpov .or. mb%mp(2) >= mexpov) then
          call fmint(mxy(1), mxy(11))
          call fmint(mxy(2), mxy(12))
          if (ma%mp(2) == mexpov .and. ma%mp(1) < 0 .and.  &
              fmcomp(mxy(2), '==', mxy(12))) then
              if (mxy(2)%mp(3) == 0) then
                  call fmi2m(1, mresult)
              else if (mxy(2)%mp(1) < 0) then
                  call fmi2m(0, mresult)
              else
                  call fmpwr(mxy(1), mxy(2), mxy(3))
                  call fmfact(mxy(2), mxy(4))
                  call fmdiv(mxy(3), mxy(4), mresult)
              endif
          else if (mxy(2)%mp(2) == mexpov .and. mxy(2)%mp(1) > 0 .and.         &
                   fmcomp(mxy(1), '==', mxy(11)) .and. mxy(1)%mp(1) > 0 .and.  &
                   fmcomp(mxy(1), '<', mxy(2))) then
              call fmi2m(0, mresult)
          else if (mxy(1)%mp(1) < 0 .or. mxy(2)%mp(1) < 0 .or.  &
                   fmcomp(mxy(2), '>=', mxy(1))) then
              call fmunknown(mresult)
          else if (mxy(2)%mp(3) == 0) then
              call fmi2m(1, mresult)
          else
              call fmsub(mxy(1), mxy(2), mxy(12))
              call fmi2m(1, mxy(3))
              call fmadd(mxy(12), mxy(3), mxy(4))
              call fmbeta(mxy(2), mxy(4), mxy(5))
              call fmmpy(mxy(2), mxy(5), mxy(4))
              call fmdiv(mxy(3), mxy(4), mresult)
          endif
          if (mresult%mp(2) == munkno) then
              kflag = -4
          endif
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (kround /= 1 .and. mxy(2)%mp(2) < -ndsave .and. k == 0) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          if (mxy(1)%mp(2) == mexpun) then
              call fmtiny(mxy(11))
              mxy(11)%mp(1) = mxy(1)%mp(1)
          else
              call fmeq(mxy(1), mxy(11))
          endif
          if (mxy(2)%mp(2) == mexpun) then
              call fmtiny(mxy(12))
              mxy(12)%mp(1) = mxy(2)%mp(1)
          else
              call fmeq(mxy(2), mxy(12))
          endif
          call fmsub(mxy(11), mxy(12), mxy(3))
          if (mxy(3)%mp(3) /= 0) then
              call fmpi(mxy(4))
              call fmsqr(mxy(4), mxy(5))
              call fmdivi(mxy(5), 6, mxy(4))
              call fmi2m(1, mxy(6))
              call fmpgam(2, mxy(6), mxy(5))
              call fmmpy_r1(mxy(5), mxy(11))
              call fmdivi_r1(mxy(5), 2)
              call fmadd_r1(mxy(4), mxy(5))
              call fmmpy_r1(mxy(3), mxy(4))
              call fmmpy_r1(mxy(3), mxy(12))
              call fmadd_r2(mxy(6), mxy(3))
          else
              call fmi2m(1, mxy(3))
          endif
          kflag = 0
          ntrace = j
          kwarn = k
          call fmeq(mxy(3), mresult)
          return
      endif

      ksign = 1

      call fmequ(ma, mxy(1), ndsave, ndig)
      call fmequ(mb, mxy(2), ndsave, ndig)

      call fmsub(mxy(1), mxy(2), mxy(15))
      if (mxy(2)%mp(3) == 0) then
          call fmi2m(1, mresult)
          mresult%mp(1) = ksign*mresult%mp(1)
          return
      endif
      call fmi2m(1, mxy(3))
      call fmsub(mxy(2), mxy(3), mxy(4))
      if (mxy(4)%mp(3) == 0) then
          call fmeq(mxy(1), mresult)
          mresult%mp(1) = ksign*mresult%mp(1)
          return
      endif

!             See if any of the terms are negative integers.

      call fmi2m(1, mxy(11))
      k10 = 0
      if (mxy(1)%mp(1) < 0) then
          call fmint(mxy(1), mxy(7))
          if (fmcomp(mxy(1), '==', mxy(7))) k10 = -1
          if (ma%mp(2) == mexpov)  k10 = -1
      endif
      k11 = 0
      if (mxy(2)%mp(1) < 0) then
          call fmint(mxy(2), mxy(8))
          if (fmcomp(mxy(2), '==', mxy(8))) k11 = -1
          if (mb%mp(2) == mexpov)  k11 = -1
      endif
      k09 = 0
      if (fmcomp(mxy(1), '<', mxy(2))) then
          call fmmod(mxy(1), mxy(11), mxy(9))
          call fmmod(mxy(2), mxy(11), mxy(10))
          call fmsub_r2(mxy(9), mxy(10))
          call fmint(mxy(10), mxy(9))
          if (fmcomp(mxy(10), '==', mxy(9))) k09 = -1
      endif

      call fmi2m(2, mxy(10))

      if (k11 == -1) then
          call fmi2m(0, mresult)
          mresult%mp(1) = ksign*mresult%mp(1)
          return
      else if (mxy(15)%mp(3) == 0) then
          call fmi2m(1, mresult)
          mresult%mp(1) = ksign*mresult%mp(1)
          return
      else if (k09 == -1 .and. k10 == 0) then
          call fmi2m(0, mresult)
          mresult%mp(1) = ksign*mresult%mp(1)
          return
      else if (k10 == -1 .and. k09 == 0) then
          call fmunknown(mresult)
          kflag = -4
          mresult%mp(1) = ksign*mresult%mp(1)
          return
      else if (k10 == -1 .and. k09 == -1) then
          jr = kround
          kround = 1
          call fmmod(mxy(2), mxy(10), mxy(12))
          if (mxy(12)%mp(3) /= 0) ksign = -1
          call fmsub(mxy(2), mxy(1), mxy(12))
          call fmsub(mxy(12), mxy(11), mxy(1))
          call fmsub(mxy(1), mxy(2), mxy(15))
          kround = jr
      endif
      if (mxy(1)%mp(2) >= 10000) then
          call fmi2m(1, mxy(5))
          if (fmcomp(mxy(2), '>', mxy(5)) .and. fmcomp(mxy(2), '<', mxy(1))) then
              call fmsub(mxy(1), mxy(2), mxy(5))
              call fmmin(mxy(2), mxy(5), mxy(13))
              call fmsub(mxy(1), mxy(13), mxy(5))
              call fmaddi(mxy(5), 1)
              call fmdiv(mxy(5), mxy(13), mxy(12))
              call fmln(mxy(12), mxy(5))
              call fmaddi(mxy(5), 1)
              call fmmpy(mxy(13), mxy(5), mxy(12))
              call fmdpm(6.283185d0, mxy(3))
              call fmmpy(mxy(3), mxy(13), mxy(5))
              call fmln(mxy(5), mxy(3))
              call fmdivi(mxy(3), 2, mxy(5))
              call fmsub_r1(mxy(12), mxy(5))
              call fmexp(mxy(12), mxy(4))
              if (mxy(4)%mp(2) == mexpov) then
                  call fmeq(mxy(4), mresult)
                  kflag = -5
                  mresult%mp(1) = ksign*mresult%mp(1)
                  return
              endif
          endif
      endif

!             See if any of the terms are small integers.

      kwrnsv = kwarn
      kwarn = 0
      call fmm2i(mxy(1), n)
      call fmm2i(mxy(2), k)
      kflgk = kflag
      call fmm2i(mxy(15), nk)
      kflgnk = kflag
      kwarn = kwrnsv

      call fmi2m(1, mxy(5))
      jr = kround
      kround = 1
      call fmadd(mxy(1), mxy(5), mxy(3))
      call fmsub_r1(mxy(3), mxy(5))
      kround = jr
      if (kflgk == 0 .and. mxy(3)%mp(3) == 0) then
          call fmi2m(2, mxy(17))
          call fmmod(mxy(2), mxy(17), mxy(5))
          call fmeq(mxy(5), mxy(17))
          if (mxy(17)%mp(3) == 0) then
              call fmdiv(mxy(1), mxy(2), mxy(17))
              call fmnegate(mxy(17))
          else
              call fmdiv(mxy(1), mxy(2), mxy(17))
          endif
          call fmeq(mxy(17), mresult)
          mresult%mp(1) = ksign*mresult%mp(1)
          return
      endif
      if (kflgk == 0 .and. kflgnk == 0 .and. n /= 0) then
          if (min(k, nk) <= 200) then
              call fmcmbi(n, k, mresult)
              mresult%mp(1) = ksign*mresult%mp(1)
              return
          endif
      endif
      nbot = 0
      if (kflgk == 0 .and. k <= 200) nbot = k
      if (kflgnk == 0 .and. nk <= 200) nbot = nk
      if (nbot > 0) then
          large = int(mxbase/nbot)
          kbot = 1
          call fmeq(mxy(1), mxy(7))
          call fmeq(mxy(1), mxy(8))
          call fmi2m(-1, mxy(9))
          do j = 2, nbot
             call fmadd_r1(mxy(7), mxy(9))
             call fmmpy_r2(mxy(7), mxy(8))
             kbot = kbot*j
             if (kbot >= large) then
                 call fmdivi_r1(mxy(8), kbot)
                 kbot = 1
             endif
          enddo
          call fmdivi(mxy(8), kbot, mresult)
          mresult%mp(1) = ksign*mresult%mp(1)
          return
      endif

!             General case.  Use fmfact, unless one of the numbers is too big.  If so, use fmlngm.

      x = alogmb*real(mxexp)
      call fmsp2m(x/log(x), mxy(6))
      call fmabs(mxy(15), mxy(5))
      lc1 = fmcomp(mxy(5), '>=', mxy(6))
      call fmabs(mxy(1), mxy(5))
      lc2 = fmcomp(mxy(5), '>=', mxy(6))
      call fmabs(mxy(2), mxy(5))
      lc3 = fmcomp(mxy(5), '>=', mxy(6))
      if (lc1 .or. lc2 .or. lc3) then

!             See if the second argument is not very large and the first is much larger.
!             For many of these cases, Stirling's formula can be used to simplify Comb
!             and avoid cancellation.

          if (mxy(1)%mp(2) > mxy(2)%mp(2) .and. mxy(1)%mp(1) > 0 .and.  &
              mxy(2)%mp(1) > 0) then
              call fmeq(mxy(1), mxy(9))
              call fmeq(mxy(2), mxy(10))
          else
              call fmi2m(1, mxy(9))
              call fmi2m(1, mxy(10))
          endif
          if (mxy(9)%mp(2) > ndig .and.  &
              mxy(9)%mp(2) >= mxy(10)%mp(2)+ndig) then
              call fmi2m(1, mxy(5))
              call fmadd(mxy(10), mxy(5), mxy(16))
              call fmln(mxy(9), mxy(5))
              call fmaddi(mxy(5), -1)
              call fmmpy(mxy(10), mxy(5), mxy(14))
              call fmadd_r2(mxy(10), mxy(14))
              call fmlngm(mxy(16), mxy(15))
              call fmsub(mxy(14), mxy(15), mxy(5))
              call fmexp(mxy(5), mxy(12))
              call fmeq(mxy(12), mresult)
              mresult%mp(1) = ksign*mresult%mp(1)
              return
          endif

!             Compute iextra, the number of extra digits required to compensate for
!             cancellation error.

          mzero = 0
          mt1 = max(mxy(15)%mp(2), mxy(1)%mp(2))
          mt1 = max(mt1, mxy(2)%mp(2))
          iextra = int(max(mt1, mzero))
          if (mt1 >= mexpov) iextra = 0
          if (ndig+iextra > 3*10**5) then
              kflag = -4
              call fmunknown(mresult)
              mresult%mp(1) = ksign*mresult%mp(1)
              return
          endif
          if (iextra > 0) then
              call fmequ_r1(mxy(1), ndig, ndig+iextra)
              call fmequ_r1(mxy(2), ndig, ndig+iextra)
          endif
          ndig = ndig + iextra
          if (k10 == -1 .and. k09 == -1) then
              jr = kround
              kround = 1
              call fmequ(ma, mxy(1), ndsave, ndig)
              call fmm2i(mxy(1), n)
              call fmequ(mb, mxy(2), ndsave, ndig)
              call fmsub(mxy(2), mxy(1), mxy(12))
              call fmi2m(1, mxy(11))
              call fmsub(mxy(12), mxy(11), mxy(1))
              kround = jr
          endif

          call fmsub(mxy(1), mxy(2), mxy(15))
          call fmi2m(1, mxy(9))
          call fmi2m(2, mxy(10))
          call fmadd(mxy(15), mxy(9), mxy(17))
          call fmadd_r1(mxy(1), mxy(9))
          call fmadd_r1(mxy(2), mxy(9))
          k10 = 0
          k11 = 0
          kc = 0
          if (mxy(1)%mp(1) < 0) then
              call fmint(mxy(1), mxy(11))
              call fmmod(mxy(11), mxy(10), mxy(12))
              if (mxy(12)%mp(3) == 0) then
                  k10 = 1
                  call fmadd_r1(mxy(1), mxy(9))
              endif
          endif
          if (mxy(2)%mp(1) < 0) then
              call fmint(mxy(2), mxy(11))
              call fmmod(mxy(11), mxy(10), mxy(12))
              if (mxy(12)%mp(3) == 0) then
                  k11 = 1
                  call fmadd_r1(mxy(2), mxy(9))
              endif
          endif
          if (mxy(17)%mp(1) < 0) then
              call fmint(mxy(17), mxy(11))
              call fmmod(mxy(11), mxy(10), mxy(12))
              if (mxy(12)%mp(3) == 0) then
                  kc = 1
                  call fmadd_r1(mxy(17), mxy(9))
              endif
          endif
          call fmlngm(mxy(1), mxy(15))
          call fmlngm(mxy(2), mxy(16))
          call fmsub_r1(mxy(15), mxy(16))
          call fmlngm(mxy(17), mxy(16))
          call fmsub_r1(mxy(15), mxy(16))
          call fmexp(mxy(15), mxy(4))
          if (k10 == 1 .or. k11 == 1 .or. kc == 1) then
              call fmi2m(1, mxy(9))
              if (k10 == 1) then
                  call fmsub_r1(mxy(1), mxy(9))
                  call fmdiv_r1(mxy(4), mxy(1))
              endif
              if (k11 == 1) then
                  call fmsub_r1(mxy(2), mxy(9))
                  call fmmpy_r1(mxy(4), mxy(2))
              endif
              if (kc == 1) then
                  call fmsub_r1(mxy(17), mxy(9))
                  call fmmpy_r1(mxy(4), mxy(17))
              endif
          endif
          call fmeq(mxy(4), mxy(17))
      else
          call fmfact(mxy(1), mxy(16))
          call fmfact(mxy(2), mxy(3))
          call fmfact(mxy(15), mxy(17))
          call fmmpy(mxy(17), mxy(3), mxy(7))
          call fmdiv(mxy(16), mxy(7), mxy(17))
      endif

      mxy(17)%mp(1) = ksign*mxy(17)%mp(1)

      call fmeq(mxy(17), mresult)

      return
      end subroutine fmcomb_m1

      subroutine fmcomb_sc(ma, mb, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = comb(ma,mb).

!  kresult = 1 is returned if a special case gives the value of comb(ma,mb).

      use fmvals
      implicit none

      type(multi) :: ma, mb, mxy(17), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j
      type(multi), save :: malocal, mblocal
      logical, external :: fmcomp

      kresult = 0

      namest(ncall) = 'FMCOMB   '
      j = ndig
      ndig = ndsave
      call fmntr_inp2(ma, mb)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)
      call fmequ(mb, mblocal, ndsave, ndig)

      if ((malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) .or.  &
          (mblocal%mp(2) == munkno .and. mblocal%mp(5) >= 0)) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      if (mblocal%mp(1) < 0) then
          call fmint(mblocal, mxy(2))
          if (fmcomp(mblocal, '==', mxy(2))) then
              call fmi2m(0, mresult)
              kresult = 1
              return
          endif
      endif

      if (malocal%mp(1) > 0 .and. mblocal%mp(1) > 0) then
          if (fmcomp(malocal, '>', mblocal)) then
              call fmsub(malocal, mblocal, mxy(5))
              call fmmin(mblocal, mxy(5), mxy(1))
              call fmdpm(0.99d+10, mxy(3))
              if (fmcomp(mxy(1), '>', mxy(3))) then

                  call fmln(malocal, mxy(1))
                  call fmaddi(mxy(1), -1)
                  call fmmpy_r1(mxy(1), malocal)

                  call fmln(mblocal, mxy(2))
                  call fmaddi(mxy(2), -1)
                  call fmmpy_r1(mxy(2), mblocal)
                  call fmsub_r1(mxy(1), mxy(2))

                  call fmln(mxy(5), mxy(2))
                  call fmaddi(mxy(2), -1)
                  call fmmpy_r1(mxy(2), mxy(5))
                  call fmsub_r1(mxy(1), mxy(2))

                  call fmpi(mxy(3))
                  call fmmpyi_r1(mxy(3), 2)
                  call fmmpy_r1(mxy(3), mblocal)
                  call fmmpy_r1(mxy(3), mxy(5))
                  call fmdiv_r2(malocal, mxy(3))
                  call fmln(mxy(3), mxy(2))
                  call fmdivi_r1(mxy(2), 2)
                  call fmadd_r1(mxy(1), mxy(2))

                  call fmexp(mxy(1), mresult)

                  if (mresult%mp(2) == mexpov) then
                      kresult = 1
                      return
                  endif
              endif
          endif
      endif

      return
      end subroutine fmcomb_sc

      function fmcomp(ma, lrel, mb)

!  Logical comparison of FM numbers ma and mb.

!  lrel is a character description of the comparison to be done:
!  lrel = 'eq' returns fmcomp = .true. if ma == mb
!       = 'ne', 'ge', 'gt', 'le', 'lt' also work like a logical if.
!       = '==', '/=', '<', '<=', '>', '>=' may be used.

!  For comparisons involving 'unknown' or two identical special symbols such as
!  +overflow,'eq',+overflow, fmcomp is returned false and a kflag = -4 error condition is returned.

      use fmvals
      implicit none

      logical :: fmcomp
      character(*) :: lrel
      type(multi) :: ma, mb
      intent (in) :: ma, lrel, mb
      character(2) :: jrel
      integer :: jcomp
      logical :: comp


      ncall = ncall + 1
      namest(ncall) = 'FMCOMP'

      if (ncall <= lvltrc .and. abs(ntrace) >= 2) then
          write (kw, "(' Input to FMCOMP')")

          if (ntrace > 0) then
              call fmprnt(ma)
              if (index('=/<>', lrel(1:1)) > 0) then
                  write (kw, "(8X, A)") lrel
              else
                  write (kw, "(7X, '.', A, '.')") lrel
              endif
              call fmprnt(mb)
          else
              call fmntrj(ma, ndig)
              if (index('=/<>', lrel(1:1)) > 0) then
                  write (kw, "(8X, A)") lrel
              else
                  write (kw, "(7X, '.', A, '.')") lrel
              endif
              call fmntrj(mb, ndig)
          endif
      endif

!             jcomp will be 1 if ma >  mb
!                           2 if ma == mb
!                           3 if ma <  mb

!             Check for special cases.

      jrel = lrel
      if (lrel /= 'EQ' .and. lrel /= 'NE' .and. lrel /= 'LT' .and.  &
          lrel /= 'GT' .and. lrel /= 'LE' .and. lrel /= 'GE') then
          if (lrel == 'eq' .or. lrel == '==') then
              jrel = 'EQ'
          else if (lrel == 'ne' .or. lrel == '/=') then
              jrel = 'NE'
          else if (lrel == 'lt' .or. lrel == '<') then
              jrel = 'LT'
          else if (lrel == 'gt' .or. lrel == '>') then
              jrel = 'GT'
          else if (lrel == 'le' .or. lrel == '<=') then
              jrel = 'LE'
          else if (lrel == 'ge' .or. lrel == '>=') then
              jrel = 'GE'
          else
              fmcomp = .false.
              comp = .false.
              kflag = -4
              if (ncall /= 1 .or. kwarn <= 0) then
                  call fmcomp3(comp)
                  return
              endif
              if (kwarn <= 0) then
                  call fmcomp3(comp)
                  return
              endif
              write (kw,                                                        &
                     "(/' Error of type KFLAG = -4 in FM package in', "     //  &
                     "' routine FMCOMP'//1X, A, ' is not one of the six', " //  &
                     "' recognized comparisons.'//' .FALSE. has been', "    //  &
                     "' returned.'/)"                                           &
                    ) lrel
              if (kwarn >= 2) then
                  stop
              endif
              call fmcomp3(comp)
              return
          endif
      endif

      if ((ma%mp(2) == munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == munkno .and. mb%mp(5) >= 0)) then
          fmcomp = .false.
          comp = .false.
          kflag = -4
          call fmcomp3(comp)
          return
      endif

      call fmcomp2(ma, mb, jcomp)
      if (jcomp == 4) then
          fmcomp = .false.
          return
      endif

!             Match the jcomp value to the requested comparison.

      if (jcomp == 1 .and. ma%mp(1) < 0) then
          jcomp = 3
      else if (jcomp == 3 .and. mb%mp(1) < 0) then
          jcomp = 1
      endif

      fmcomp = .false.
      comp = .false.
      if (jcomp == 1 .and. (jrel == 'GT' .or. jrel == 'GE' .or. jrel == 'NE')) then
          fmcomp = .true.
          comp = .true.
      endif
      if (jcomp == 2 .and. (jrel == 'EQ' .or. jrel == 'GE' .or. jrel == 'LE')) then
          fmcomp = .true.
          comp = .true.
      endif
      if (jcomp == 3 .and. (jrel == 'NE' .or. jrel == 'LT' .or. jrel == 'LE')) then
          fmcomp = .true.
          comp = .true.
      endif
      call fmcomp3(comp)

      return
      end function fmcomp

      subroutine fmcomp2(ma, mb, jcomp)

!  Return  jcomp = 1 if ma >  mb
!                = 2 if ma == mb
!                = 3 if ma <  mb

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: jcomp
      intent (in) :: ma, mb
      intent (inout) :: jcomp

      integer :: j, nlast
      double precision :: d, xe, xf, ye, yf
      logical :: comp

      if (abs(ma%mp(2)) == mexpov .and. ma%mp(2) == mb%mp(2) .and.  &
          ma%mp(3) == mb%mp(3) .and. ma%mp(1) == mb%mp(1)) then
          xe = ma%mp(4)
          xf = ma%mp(5)
          xf = -xf/maxint
          ye = mb%mp(4)
          yf = mb%mp(5)
          yf = -yf/maxint
          if (xe > ye) then
              jcomp = 1
          else if (xe < ye) then
              jcomp = 3
          else
              if (xf > yf) then
                  jcomp = 1
              else if (xf < yf) then
                  jcomp = 3
              else
                  jcomp = 2
                  if (huge(mbase)/mexpov > 1.0d+20) then
                      d = 1.0d+10
                  else
                      d = 4
                  endif
                  if (abs(xe) == huge(mbase)/d) then
                      comp = .false.
                      kflag = -4
                      if (ncall /= 1 .or. kwarn <= 0) then
                          call fmcomp3(comp)
                          jcomp = 4
                          return
                      endif
                      if (kwarn <= 0) then
                          call fmcomp3(comp)
                          jcomp = 4
                          return
                      endif
                      write (kw,                                                            &
                             "(/' Error of type KFLAG = -4 in FM package in routine', " //  &
                             "' FMCOMP'//' Two numbers in the same overflow or', "      //  &
                             "' underflow category are beyond the tracking range.'//"   //  &
                             "' .FALSE. has been returned.'/)"                              &
                             )
                      call fmcomp3(comp)
                      jcomp = 4
                      return
                  endif
              endif
          endif
          return
      endif
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) then
          if (ma%mp(1) == mb%mp(1)) then
              call fmovun_xexf(ma, xe, xf)
              call fmovun_xexf(mb, ye, yf)
              if (xe > ye) then
                  jcomp = 1
              else if (xe < ye) then
                  jcomp = 3
              else
                  if (xf > yf) then
                      jcomp = 1
                  else if (xf < yf) then
                      jcomp = 3
                  else
                      jcomp = 2
                      if (huge(mbase)/mexpov > 1.0d+20) then
                          d = 1.0d+10
                      else
                          d = 4
                      endif
                      if (abs(xe) == huge(mbase)/d) then
                          comp = .false.
                          kflag = -4
                          if (ncall /= 1 .or. kwarn <= 0) then
                              call fmcomp3(comp)
                              jcomp = 4
                              return
                          endif
                          write (kw,                                                            &
                                 "(/' Error of type KFLAG = -4 in FM package in routine', " //  &
                                 "' FMCOMP'//' Two numbers in the same overflow or', "      //  &
                                 "' underflow category are beyond the tracking range.'//"   //  &
                                 "' .FALSE. has been returned.'/)"                              &
                                 )
                          call fmcomp3(comp)
                          jcomp = 4
                          return
                      endif
                  endif
              endif
              return
          endif
      endif

!             Check for zero.

      kflag = 0
      if (ma%mp(3) == 0) then
          jcomp = 2
          if (mb%mp(3) == 0) return
          if (mb%mp(1) < 0) jcomp = 1
          if (mb%mp(1) > 0) jcomp = 3
          return
      endif
      if (mb%mp(3) == 0) then
          jcomp = 1
          if (ma%mp(1) < 0) jcomp = 3
          return
      endif

!             Check for opposite signs.

      if (ma%mp(1) > 0 .and. mb%mp(1) < 0) then
          jcomp = 1
          return
      endif
      if (mb%mp(1) > 0 .and. ma%mp(1) < 0) then
          jcomp = 3
          return
      endif

!             See which one is larger in absolute value.

      if (ma%mp(2) > mb%mp(2)) then
          jcomp = 1
          return
      endif
      if (mb%mp(2) > ma%mp(2)) then
          jcomp = 3
          return
      endif
      nlast = ndig + 1

      do j = 2, nlast
         if (abs(ma%mp(j+1)) > abs(mb%mp(j+1))) then
             jcomp = 1
             return
         endif
         if (abs(mb%mp(j+1)) > abs(ma%mp(j+1))) then
             jcomp = 3
             return
         endif
      enddo

      jcomp = 2

      return
      end subroutine fmcomp2

      subroutine fmcomp3(comp)

!  Trace printing for fmcomp.

      use fmvals
      implicit none

      logical :: comp
      intent (in) :: comp

      if (ntrace /= 0) then
          if (ncall <= lvltrc .and. abs(ntrace) >= 1) then
              if (kflag == 0) then
                  write (kw,                                                         &
                         "(' FMCOMP', 15X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                         "I10, 5X, 'NDIG =', I10)"                                   &
                        ) ncall, int(mbase), ndig
              else
                  write (kw,                                                        &
                         "(' FMCOMP', 6X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                         "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"               &
                        ) ncall, int(mbase), ndig, kflag
              endif
              if (comp) then
                  write (kw, "(7X, '.TRUE.')")
              else
                  write (kw, "(7X, '.FALSE.')")
              endif
          endif
      endif
      ncall = ncall - 1

      return
      end subroutine fmcomp3

      function fmcompare(ma, lrel, mb)

      use fmvals
      implicit none

      logical :: fmcompare
      character(*) :: lrel
      type(multi) :: ma, mb
      intent (in) :: ma, lrel, mb

      logical, external :: fmcomp

      fmcompare = fmcomp(ma, lrel, mb)

      return
      end function fmcompare

      subroutine fmcons

!  Set several saved machine precision constants.

      use fmvals
      implicit none

      mblogs = mbase
      alogmb = log(real(mbase))
      alogm2 = alogmb/log(2.0)
      alogmx = log(real(maxint))
      alogmt = alogmb/log(10.0)
      ngrd21 = int(2.0/alogmt + 1.0)
      ngrd52 = int(5.0/alogmt + 2.0)
      ngrd22 = int(2.0/alogmt + 2.0)
      if (mbase < 1000) then
          ngrd21 = 2*ngrd21
          ngrd52 = 4*ngrd52
          ngrd22 = 2*ngrd22
      else
          ngrd21 = ngrd21 + 1
          ngrd52 = ngrd52 + 1
          ngrd22 = ngrd22 + 1
      endif
      mexpab = aint (mxexp2/5)
      dlogmb = log(dble(mbase))
      dlogtn = log(10.0d0)
      dlogtw = log(2.0d0)
      dppi = 4.0d0*atan(1.0d0)
      dlogtp = log(2.0d0*dppi)
      dlogpi = log(dppi)
      dlogeb = -log(dpeps)/dlogmb

      return
      end subroutine fmcons

      subroutine fmcos(ma, mb)

!  mb = cos(ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(6), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmcos_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call fmcos_m1(ma, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmcos

      subroutine fmcos_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing cos(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(6), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      integer :: jcos, jsin, jswap, krndsave, kwrnsv, ndsv

      krndsave = kround
      kround = 1
      call fmequ(ma, mresult, ndsave, ndig)
      mresult%mp(1) = 1
      if (ma%mp(2) > 3*10**5 .and. krad == 1) then
          call fmunknown(mresult)
          kround = krndsave
          return
      endif
      call fmeq(mresult, mxy(5))
      kwrnsv = kwarn
      kwarn = 0

!             Reduce the argument, convert to radians if the input is in degrees, and evaluate
!             the function.

      call fmrdc(mresult, jsin, jcos, jswap)
      if (kround /= 1 .and. krad /= 1) then
          call fmi2m(30, mxy(1))
          call fmsub(mresult, mxy(1), mxy(2))
          if (mxy(2)%mp(3) == 0 .and. jswap == 1) then
              call fmst2m('0.5', mxy(1))
              call fmmpyi(mxy(1), jcos, mresult)
              kround = krndsave
              return
          endif
      endif
      kwarn = kwrnsv
      if (mresult%mp(2) == munkno) then
          if (krad /= 1 .or. jswap == 1) then
              call fmeq(mxy(5), mresult)
              call fmrdc(mresult, jsin, jcos, jswap)
              kround = krndsave
              return
          endif
          if (mbspi /= mbase .or. ndigpi < ndig) then
              ndsv = ndig
              ndig = ndig + 2
              call fmpi(mxy(3))
              ndig = ndsv
          endif
          call fmpi(mxy(6))
          call fmdiv(mxy(5), mxy(6), mxy(3))
          call fmnint(mxy(3), mxy(2))
          call fmmpy(mxy(2), mxy(6), mxy(1))
          call fmsub_r2(mxy(5), mxy(1))
          if (mxy(1)%mp(3) == 0) call fmulp(mxy(5), mxy(1))
          call fmi2m(1, mxy(3))
          call fmsqr_r1(mxy(1))
          call fmdivi_r1(mxy(1), 2)
          call fmsub_r2(mxy(3), mxy(1))
          call fmsub_r1(mxy(1), mxy(3))
          if (mxy(1)%mp(3) == 0) then
              call fmi2m(jcos, mresult)
          else
              call fmeq(mxy(5), mresult)
              call fmrdc(mresult, jsin, jcos, jswap)
          endif
          kround = krndsave
          return
      endif
      if (krad == 0) then
          if (mbspi /= mbase .or. ndigpi < ndig) then
              ndsv = ndig
              ndig = ndig + 2
              call fmpi(mxy(4))
              ndig = ndsv
          endif
          call fmpi(mxy(6))
          call fmmpy_r1(mresult, mxy(6))
          call fmdivi_r1(mresult, 180)
      endif
      if (mresult%mp(2) /= munkno) then
          if (jswap == 0) then
              call fmcos2(mresult, mxy(4))
              call fmeq(mxy(4), mresult)
          else
              if (mresult%mp(2) < 0 .or. ndig <= 50) then
                  call fmsin2(mresult, mxy(4))
                  call fmeq(mxy(4), mresult)
              else
                  call fmcos2(mresult, mxy(4))
                  call fmi2m(1, mxy(2))
                  call fmsqr(mxy(4), mresult)
                  call fmsub_r2(mxy(2), mresult)
                  call fmsqrt_r1(mresult)
              endif
          endif
      endif

!             Append the sign and return.

      if (jcos == -1) call fmnegate(mresult)

      kround = krndsave

      return
      end subroutine fmcos_m1

      subroutine fmcos_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = cos(ma).

!  kresult = 1 is returned if a special case gives the value of cos(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(6), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j, k
      double precision :: b, pi, x, xe, xf

      kresult = 0

      namest(ncall) = 'FMCOS    '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, mxy(5), ndsave, ndig)

      if (mxy(5)%mp(2) == munkno .and. mxy(5)%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      call fmovun_xexf(mxy(5), xe, xf)
      if (2*xe < -ndsave .and. kround == 1) then
          call fmi2m(1, mresult)
          kresult = 1
          return
      endif

      if (mxy(5)%mp(2) == munkno .and. mxy(5)%mp(5) < 0) then
          if (2*xe < -ndsave) then
              call fmi2m(1, mxy(2))
              if (krad == 1) then
                  call fmsqr(mxy(5), mxy(3))
                  call fmdivi_r1(mxy(3), 2)
                  call fmsub(mxy(2), mxy(3), mresult)
              else
                  call fmpi(mxy(3))
                  call fmmpy_r2(mxy(5), mxy(3))
                  call fmdivi_r1(mxy(3), 180)
                  call fmsqr_r1(mxy(3))
                  call fmdivi_r1(mxy(3), 2)
                  call fmsub(mxy(2), mxy(3), mresult)
              endif
          else
              call fmunknown(mresult)
              if (xe*dlogmb+log(xf) < log(1.0d+12)) then
                  b = mbase
                  if (krad == 1) then
                      x = cos(xf*b**xe)
                  else
                      pi = acos(-1.0d0)
                      x = cos(pi*xf*b**xe/180.0d0)
                  endif
                  if (x < 0) then
                      mresult%mp(1) = -1
                      x = -x
                  endif
                  if (x == 1.0d0) then
                      xe = 1
                      xf = 1/b
                  else
                      xe = 0
                      xf = x
                  endif
                  do j = 1, 5
                     if (xf >= 1) then
                         xe = xe + 1
                         xf = xf / b
                     else if (xf < 1.0d0/b) then
                         xe = xe - 1
                         xf = xf * b
                     else
                         exit
                     endif
                  enddo
                  mresult%mp(4) = xe
                  mresult%mp(5) = -xf*maxint
              endif
          endif
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      call fmovun_xexf(mxy(5), xe, xf)
      if (kround /= 1 .and. mxy(5)%mp(2) < -ndsave) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          call fmsqr(mxy(5), mxy(1))
          if (krad == 0) then
              call fmpi(mxy(2))
              call fmsqr(mxy(2), mxy(3))
              call fmdivi_r1(mxy(3), 32400)
              call fmmpy_r1(mxy(1), mxy(3))
          endif
          call fmdivi(mxy(1), -2, mxy(3))
          if (mxy(3)%mp(2) > mexpun) then
              call fmi2m(1, mxy(1))
              call fmadd(mxy(1), mxy(3), mresult)
          else if (mxy(5)%mp(2) == mexpun) then
              call fmi2m(1, mxy(1))
              call fmadd(mxy(1), mxy(3), mresult)
          else if (kround == -1 .or. kround == 0) then
              call fmi2m(1, mxy(1))
              call fmdp2m(0.9d0, mxy(2))
              call fmulp(mxy(2), mxy(3))
              call fmsub(mxy(1), mxy(3), mresult)
          else
              call fmi2m(1, mresult)
          endif
          if (kflag > 0) kflag = 0
          ntrace = j
          kwarn = k
          kresult = 1
      endif

      return
      end subroutine fmcos_sc

      subroutine fmcos2(ma, mb)

!  internal subroutine for mb = cos(ma) where 0 <= ma <= 1.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: maxv
      integer :: j, j2, k2, kl, ktwo, kwrnsv, l, l2, large, n2, nbot, ndsav1, ndsave, nterm
      real :: alog2, alogt, t
      type(multi), save :: mxy(3), mjsums(ljsums)
      double precision :: tj, xe, xf

      call fmalloc(mb, ndig+2)

      if (mblogs /= mbase) call fmcons
      if (ma%mp(3) == 0) then
          call fmi2m(1, mb)
          return
      endif
      ndsave = ndig
      kwrnsv = kwarn
      kwarn = 0

!             Use the direct series:  cos(x) = 1 - x**2/2! + x**4/4! - ...

!             The argument will be divided by 2**k2 before the series is summed.  The series will be
!             added as j2 concurrent series.

!             Since x is small when the series is summed, cos(x) - 1 is computed.  Then a version of
!             the recovery formula can be used that does not suffer from severe cancellation.

      t = max(ndig-ngrd52, 2)
      alog2 = log(2.0)
      alogt = log(t)
      tj = 0.69*(ndig*alogmt)**0.3333
      j2 = int(tj)
      j2 = max(2, min(j2+mod(j2, 2), ljsums))
      if (ndig > 2000) then
          j2 = -4.0 + 3.0*alogt
      endif
      k2 = max(2, int(1.25*(ndig*alogmt)**0.3333 - 3.4))


      call fmovun_xexf(ma, xe, xf)
      tj = - ( xe*dlogmb + log(xf) ) / dlogtw
      if (tj >= k2) then
          l = k2
      else if (tj > 0) then
          l = int(tj)
      else
          l = 0
      endif
      k2 = k2 - l
      if (ndig > 2000) then
          k2 = 5.8*alogmb - 263 + (35 - 0.58*alogmb)*alogt
      endif
      if (k2 <= 0) then
          k2 = 0
          j2 = int(.43*sqrt(t*alogmb/(alogt+real(l)*alog2)) + .33)
          j2 = max(1, min(j2, ljsums))
      endif

      n2 = int(t*alogmb/(alogt+real(l)*alog2))
      l2 = int(log(real(n2)+2.0d0**k2)/alogmb)
      ndig = ndig + max(l2, 0)
      ndsav1 = ndig
      j2 = max(2, min(j2+mod(j2, 2), ljsums))

!             Divide the argument by 2**k2.

      call fmequ(ma, mxy(1), ndsave, ndig)
      ktwo = 1
      maxv = mxbase/2
      if (k2 > 0) then
          do j = 1, k2
             ktwo = 2*ktwo
             if (ktwo > maxv) then
                 call fmcsdivi_r1(mxy(1), ktwo)
                 ktwo = 1
             endif
          enddo
          if (ktwo > 1) call fmcsdivi_r1(mxy(1), ktwo)
      endif

!             Split into j2 concurrent sums and reduce ndig while computing each term in the sum as
!             the terms get smaller.

      nterm = 2
      call fmi2m(1, mxy(2))
      do j = 1, j2
         nbot = nterm*(nterm-1)
         call fmcsdivi_r1(mxy(2), nbot)
         call fmeq(mxy(2), mjsums(j))
         nterm = nterm + 2
      enddo
      kl = 1
      if (mxy(1)%mp(2) < -ndig) then
          kl = 0
      else
          call fmsqr_r1(mxy(1))
          call fmipwr(mxy(1), j2, mxy(3))
          if (mxy(3)%mp(2) < -ndig) kl = 0
      endif

      if (kl > 0) then
          do while (kl > 0)
             call fmcsmpy_r1(mxy(2), mxy(3))
             do j = 1, j2
                large = int(intmax/nterm)
                if (nterm > large .or. nterm > mxbase/(nterm-1)) then
                    call fmcsdivi_r1(mxy(2), nterm)
                    nbot = nterm - 1
                    call fmcsdivi_r1(mxy(2), nbot)
                else
                    nbot = nterm*(nterm-1)
                    call fmcsdivi_r1(mxy(2), nbot)
                endif
                ndig = ndsav1
                call fmcsaddnn_r1(mjsums(j), mxy(2))
                if (kflag /= 0) then
                    kl = 0
                    exit
                endif
                ndig = ndsav1 - int(mjsums(j)%mp(2)-mxy(2)%mp(2))
                if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                nterm = nterm + 2
             enddo
          enddo
      endif

!             Put the j2 separate sums back together.

      kflag = 0
      call fmcsnsums(j2, mjsums)
      call fmeq(mjsums(j2), mxy(3))
      call fmnegate(mxy(1))
      do j = 2, j2
         call fmcsmpy_r1(mxy(3), mxy(1))
         call fmadd_r1(mxy(3), mjsums(j2-j+1))
      enddo
      call fmcsmpy_r1(mxy(3), mxy(1))

!             Reverse the effect of reducing the argument to compute cos(ma).

      ndig = ndsav1
      if (k2 > 0) then
          if (ndsave <= 20) then
              call fmi2m(2, mxy(1))
              do j = 1, k2
                 call fmadd(mxy(3), mxy(1), mxy(2))
                 call fmcsmpy_r1(mxy(2), mxy(3))
                 call fmadd(mxy(2), mxy(2), mxy(3))
              enddo
          else
              do j = 1, k2
                 call fmsqr(mxy(3), mxy(2))
                 call fmadd(mxy(3), mxy(3), mxy(1))
                 call fmadd_r1(mxy(2), mxy(1))
                 call fmadd(mxy(2), mxy(2), mxy(3))
              enddo
          endif
      endif
      call fmi2m(1, mxy(2))
      call fmadd_r2(mxy(2), mxy(3))

      call fmequ(mxy(3), mb, ndsav1, ndsave)
      ndig = ndsave
      kwarn = kwrnsv

      return
      end subroutine fmcos2

      subroutine fmcos_sin(ma, mb, mc)

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc

      call fmcssn(ma, mb, mc)

      return
      end subroutine fmcos_sin

      subroutine fmcosh(ma, mb)

!  mb = cosh(ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(3), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmcosh_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmcosh_m1(ma, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmcosh

      subroutine fmcosh_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing cosh(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(3), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      integer :: krndsave, nmethd
      double precision :: xe

      krndsave = kround
      kround = 1
      call fmequ(ma, mresult, ndsave, ndig)

!             Use a series for small arguments, fmexp for large ones.

      if (mresult%mp(2) == munkno) return
      call fmovun_xe(mresult, xe)
      if (mbase > 99) then
          if (xe <= 0) then
              nmethd = 1
          else if (xe >= 2) then
              nmethd = 2
          else if (abs(mresult%mp(3)) < 10) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          if (xe <= 0) then
              nmethd = 1
          else
              nmethd = 2
          endif
      endif

      if (nmethd == 1) then
          call fmcosh2(mresult, mxy(1))
          call fmeq(mxy(1), mresult)
      else
          call fmexp(mresult, mxy(1))
          call fmeq(mxy(1), mresult)
          if (mresult%mp(2) == mexpov) then
              return
          endif
          call fmovun_xe(mresult, xe)
          if (xe <= (ndig+1)/2) then
              call fmi2m(1, mxy(1))
              call fmdiv_r1(mxy(1), mresult)
              call fmadd_r1(mresult, mxy(1))
          endif
          call fmdivi_r1(mresult, 2)
      endif

      kround = krndsave

      return
      end subroutine fmcosh_m1

      subroutine fmcosh_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = cosh(ma).

!  kresult = 1 is returned if a special case gives the value of mresult for cosh(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(3), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j
      double precision :: xe, ye

      kresult = 0

      namest(ncall) = 'FMCOSH   '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, mxy(1), ndsave, ndig)

      if (mxy(1)%mp(2) == munkno .and. mxy(1)%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif
      if (mxy(1)%mp(2) == munkno) then
          if (mxy(1)%mp(5) < 0) then
              call fmovun_xe(mxy(1), xe)
              if (2*xe < -ndsave) then
                  call fmi2m(1, mxy(3))
                  call fmsqr(mxy(1), mxy(2))
                  call fmdivi_r1(mxy(2), 2)
                  call fmadd(mxy(3), mxy(2), mresult)
              else
                  call fmexp(mxy(1), mxy(2))
                  call fmi2m(1, mxy(3))
                  call fmdiv_r1(mxy(3), mxy(2))
                  call fmadd_r2(mxy(2), mxy(3))
                  call fmdivi(mxy(3), 2, mresult)
              endif
          else
              call fmunknown(mresult)
          endif
          kresult = 1
          return
      endif

      mxy(1)%mp(1) = 1
      if (mxy(1)%mp(3) == 0) then
          call fmi2m(1, mresult)
          kresult = 1
          return
      endif
      if (mxy(1)%mp(2) == mexpov) then
          call fmabs(mxy(1), mxy(3))
          call fmexp(mxy(3), mresult)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      call fmovun_xe(mxy(1), xe)
      if (kround /= 1 .and. xe < -ndsave) then
          call fmsqr(mxy(1), mxy(3))
          call fmdivi(mxy(3), 2, mxy(2))
          call fmovun_xe(mxy(1), ye)
          if (ye > mexpun) then
              call fmi2m(1, mxy(3))
              call fmadd(mxy(3), mxy(2), mresult)
          else if (mxy(1)%mp(2) == mexpun) then
              call fmi2m(1, mxy(3))
              call fmadd(mxy(3), mxy(2), mresult)
          else if (kround == 2) then
              call fmi2m(1, mxy(3))
              call fmulp(mxy(3), mxy(2))
              call fmadd(mxy(3), mxy(2), mresult)
          else
              call fmi2m(1, mresult)
          endif
          if (kflag > 0) kflag = 0
          kresult = 1
          return
      endif
      if (xe < -ndsave) then
          call fmi2m(1, mresult)
          kresult = 1
          return
      endif

      return
      end subroutine fmcosh_sc

      subroutine fmcosh2(ma, mb)

!  Internal subroutine for mb = cosh(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: maxv
      integer :: j, j2, k, k2, kexp, kl, ktwo, kwrnsv, l, l2, large, n2, nbot, ndsav1, ndsave, nterm
      real :: alog2, alogt, b, t, tj
      double precision :: xe
      type(multi), save :: mxy(3), mjsums(ljsums)

      if (mblogs /= mbase) call fmcons
      if (ma%mp(3) == 0) then
          call fmi2m(1, mb)
          return
      endif
      ndsave = ndig
      kwrnsv = kwarn
      kwarn = 0

!             Use the direct series:  cosh(x) = 1 + x**2/2! + x**4/4! - ...

!             The argument will be divided by 2**k2 before the series is summed.  The series will be
!             added as j2 concurrent series.

!             Since x is small when the series is summed, cosh(x) - 1 is computed.  Then a version
!             of the recovery formula can be used that does not suffer from severe cancellation.

      b = real(mbase)
      k = ngrd52
      t = max(ndig-k, 2)
      alog2 = log(2.0)
      alogt = log(t)
      tj = 0.65*(ndig*alogmt)**0.3333 - 2.0
      j2 = int(tj)
      j2 = max(2, min(j2+mod(j2, 2), ljsums))
      k2 = int(1.38*(ndig*alogmt)**0.3333 - 1.8)

      tj = -(real(ma%mp(2))*alogmb +  &
             log(real(ma%mp(3))/b + real(ma%mp(4))/(b*b)))/alog2 - 0.3
      if (tj >= k2) then
          l = k2
      else if (tj > 0) then
          l = int(tj)
      else
          l = 0
      endif
      k2 = k2 - l
      if (k2 <= 0) then
          k2 = 0
          j2 = int(.43*sqrt(t*alogmb/(alogt+real(l)*alog2)) + .33)
          j2 = max(1, min(j2, ljsums))
      endif
      if (j2 <= 1) j2 = 1

      n2 = int(t*alogmb/(alogt+real(l)*alog2))
      l2 = int(log(real(n2)+2.0d0**k2)/alogmb)
      ndig = ndig + l2
      ndsav1 = ndig
      call fmequ(ma, mxy(1), ndsave, ndig)

!             Divide the argument by 2**k2.

      ktwo = 1
      maxv = mxbase/2
      if (k2 > 0) then
          do j = 1, k2
             ktwo = 2*ktwo
             if (ktwo > maxv) then
                 call fmcsdivi_r1(mxy(1), ktwo)
                 ktwo = 1
             endif
          enddo
          if (ktwo > 1) call fmcsdivi_r1(mxy(1), ktwo)
      endif

!             Split into j2 concurrent sums and reduce ndig while computing each term in the sum as
!             the terms get smaller.

      call fmsqr_r1(mxy(1))
      call fmeq(mxy(1), mxy(2))
      nterm = 2
      do j = 1, j2
         nbot = nterm*(nterm-1)
         call fmcsdivi_r1(mxy(2), nbot)
         nterm = nterm + 2
         call fmeq(mxy(2), mjsums(j))
      enddo
      call fmovun_xe(mxy(1), xe)
      if (xe < -ndig) then
          kl = 0
      else
          kl = 1
          call fmipwr(mxy(1), j2, mxy(3))
      endif

      do while (kl > 0)
         call fmcsmpy_r1(mxy(2), mxy(3))
         do j = 1, j2
            large = int(intmax/nterm)
            if (nterm > large .or. nterm > mxbase/(nterm-1)) then
                call fmcsdivi_r1(mxy(2), nterm)
                nbot = nterm - 1
                call fmcsdivi_r1(mxy(2), nbot)
            else
                nbot = nterm*(nterm-1)
                call fmcsdivi_r1(mxy(2), nbot)
            endif
            ndig = ndsav1
            call fmcsaddnn_r1(mjsums(j), mxy(2))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            ndig = ndsav1 - int(mjsums(j)%mp(2)-mxy(2)%mp(2))
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
            nterm = nterm + 2
         enddo
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call fmcsnsums(j2, mjsums)
      call fmeq(mjsums(j2), mxy(3))
      do j = 2, j2
         call fmcsmpy_r1(mxy(3), mxy(1))
         call fmadd_r1(mxy(3), mjsums(j2-j+1))
      enddo

!             Reverse the effect of reducing the argument to compute cosh(ma).

      ndig = ndsav1
      if (k2 > 0) then
          if (ndsave <= 20) then
              call fmi2m(2, mxy(1))
              do j = 1, k2
                 kexp = mxy(3)%mp(2)
                 if (mbase == 2 .or. kexp > 0) then
                     call fmadd(mxy(3), mxy(1), mxy(2))
                 else
                     do k = 1, 3-kexp
                        mxy(2)%mp(k) = mxy(1)%mp(k)
                     enddo
                     do k = 4-kexp, ndig+2
                        mxy(2)%mp(k) = mxy(3)%mp(k-1+kexp)
                     enddo
                 endif
                 call fmcsmpy_r1(mxy(2), mxy(3))
                 call fmcsmpyi(mxy(2), 2, mxy(3))
              enddo
          else
              do j = 1, k2
                 call fmsqr(mxy(3), mxy(2))
                 call fmadd(mxy(3), mxy(3), mxy(1))
                 call fmadd_r1(mxy(2), mxy(1))
                 call fmadd(mxy(2), mxy(2), mxy(3))
              enddo
          endif
      endif
      call fmi2m(1, mxy(2))
      call fmadd_r2(mxy(2), mxy(3))

      call fmequ(mxy(3), mb, ndsav1, ndsave)
      ndig = ndsave
      kwarn = kwrnsv

      return
      end subroutine fmcosh2

      subroutine fmcosh_sinh(ma, mb, mc)

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc

      call fmchsh(ma, mb, mc)

      return
      end subroutine fmcosh_sinh

      subroutine fmcsadd_r1(ma, mb)

!  Internal addition routine.  ma = ma + mb

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb

      integer :: j, k, kp2, n1

      if ((ntrace /= 0 .and. lvltrc >= ncall+1) .or. abs(ma%mp(2)) >= mexpab .or.  &
          abs(mb%mp(2)) >= mexpab .or. ma%mp(2) < mb%mp(2) .or.                    &
          ma%mp(1) < 0 .or. mb%mp(1) < 0 .or. ma%mp(3) == 0 .or.                   &
          mb%mp(3) == 0) then
          call fmadd_r1(ma, mb)
          return
      endif
      kflag = 0
      n1 = ndig + 1
      k = ma%mp(2) - mb%mp(2)

!             Add ma and mb.

      kp2 = k + 2
      do j = kp2+1, n1+1
         ma%mp(j) = ma%mp(j) + mb%mp(j-k)
      enddo

!             Normalize.  Fix any digit not less than mbase.

      if (ma%mp(3) >= mbase) then
          ma%mp(2) = ma%mp(2) + 1
          if (ma%mp(n1+1) >= mbase) ma%mp(ndig+1) = ma%mp(ndig+1) + 1
          do j = ndig+1, 4, -1
             if (ma%mp(j) >= mbase) then
                 ma%mp(j+1) = ma%mp(j) - mbase
                 ma%mp(j-1) = ma%mp(j-1) + 1
             else
                 ma%mp(j+1) = ma%mp(j)
             endif
          enddo
          ma%mp(4) = ma%mp(3) - mbase
          ma%mp(3) = 1
      else
          do j = n1+1, 4, -1
             if (ma%mp(j) >= mbase) then
                 ma%mp(j) = ma%mp(j) - mbase
                 ma%mp(j-1) = ma%mp(j-1) + 1
             endif
          enddo
          if (ma%mp(3) >= mbase) then
              do j = n1+1, 5, -1
                 ma%mp(j) = ma%mp(j-1)
              enddo
              ma%mp(4) = ma%mp(3) - mbase
              ma%mp(3) = 1
              ma%mp(2) = ma%mp(2) + 1
          endif
      endif

      if (abs(ma%mp(2)-mb%mp(2)) >= ndig) kflag = 1

      return
      end subroutine fmcsadd_r1

      subroutine fmcsaddnn_r1(ma, mb)

!  Internal addition routine.  ma = ma + mb

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb

      integer :: j, k, kp2, n1

      if ((ntrace /= 0 .and. lvltrc >= ncall+1) .or. abs(ma%mp(2)) >= mexpab .or.  &
          abs(mb%mp(2)) >= mexpab .or. ma%mp(2) < mb%mp(2) .or.                    &
          ma%mp(3) == 0 .or. mb%mp(3) == 0) then
          call fmcsnorm(ma)
          call fmadd_r1(ma, mb)
          return
      endif
      kflag = 0
      n1 = ndig + 1
      k = ma%mp(2) - mb%mp(2)

!             Add ma and mb.

      kp2 = k + 2
      do j = kp2+1, n1+1
         ma%mp(j) = ma%mp(j) + mb%mp(j-k)
      enddo

!             See if the result is equal to one of the input arguments.

      if (abs(ma%mp(2)-mb%mp(2)) >= ndig) kflag = 1

      return
      end subroutine fmcsaddnn_r1

      subroutine fmcsdiv(ma, mb, mc)

!  Internal division routine.  mc = ma / mb

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      double precision :: xb, xbr, xbase, xmwa
      real (kind(1.0d0)) :: maxmwa, mbp1, mcarry, mkt, mlmax, mqd
      real :: c
      integer :: j, jb, jl, ka, kb, kl, klp, kptmwa, n1, ng, nl, nmbwds, nzdmb

      c = 3100
      if ((ntrace /= 0 .and. lvltrc >= ncall+1) .or. abs(ma%mp(2)) >= mexpab  .or.  &
          abs(mb%mp(2)) >= mexpab .or. ma%mp(3) == 0 .or.                           &
          mb%mp(3) == 0 .or. mbase < 1000 .or. ndig >= c) then
          call fmdiv(ma, mb, mc)
          return
      endif
      call fmalloc(mc, ndig+2)
      call fmalloc(mwa, 2*ndig+30)
      kflag = 0
      n1 = ndig + 1
      ng = ndig + ngrd21
      nl = ng + 4
      mwa%mp(2) = ma%mp(2) - mb%mp(2) + 1
      mwa%mp(3) = 0
      do j = 2, n1
         mwa%mp(j+2) = ma%mp(j+1)
      enddo
      nl = n1 + ngrd21 + 3
      do j = ndig+3, nl
         mwa%mp(j+1) = 0
      enddo

!             nmbwds is the number of words of mb used to compute the estimated quotient digit mqd.

      nmbwds = 4
      if (mbase < 100) nmbwds = 7

!             xb is an approximation of mb used in estimating the quotient digits.

      xbase = dble(mbase)
      xb = 0
      jl = nmbwds
      if (jl <= n1) then
          do j = 2, jl
             xb = xb*xbase + dble(mb%mp(j+1))
          enddo
      else
          do j = 2, jl
             if (j <= n1) then
                 xb = xb*xbase + dble(mb%mp(j+1))
             else
                 xb = xb*xbase
             endif
          enddo
      endif
      if (jl+1 <= n1) then
          xb = xb + dble(mb%mp(jl+2))/xbase
      endif
      xbr = 1.0d0/xb

!             mlmax determines when to normalize all of mwa.

      mbp1 = mbase + 1
      mlmax = maxint/mbp1
      mkt = intmax - mbase
      mlmax = min(mlmax, mkt)

!             Count the trailing zero digits of mb.

      nzdmb = n1 - 2
      do j = n1, 2, -1
         if (mb%mp(j+1) /= 0) then
             nzdmb = n1 - j
             exit
         endif
      enddo

!             maxmwa is an upper bound on the size of values in mwa divided by mbase-1.  It is used
!             to determine whether normalization can be postponed.

      maxmwa = 0

!             kptmwa points to the next digit in the quotient.

      kptmwa = 2

!             This is the start of the division loop.

!             xmwa is an approximation of the active part of mwa used in estimating quotient digits.

      klp = 1
      do while (klp > 0)
         kl = kptmwa + nmbwds - 1
         if (kl <= nl) then
             xmwa = ((dble(mwa%mp(kptmwa+1))*xbase + dble(mwa%mp(kptmwa+2)))*xbase  &
                    + dble(mwa%mp(kptmwa+3)))*xbase + dble(mwa%mp(kptmwa+4))
             do j = kptmwa+4, kl
                xmwa = xmwa*xbase + dble(mwa%mp(j+1))
             enddo
         else
             xmwa = dble(mwa%mp(kptmwa+1))
             do j = kptmwa+1, kl
                if (j <= nl) then
                    xmwa = xmwa*xbase + dble(mwa%mp(j+1))
                else
                    xmwa = xmwa*xbase
                endif
             enddo
         endif

!             mqd is the estimated quotient digit.

         mqd = aint(xmwa*xbr)
         if (mqd < 0) mqd = mqd - 1

         if (mqd > 0) then
             maxmwa = maxmwa + mqd
         else
             maxmwa = maxmwa - mqd
         endif

!             See if mwa must be normalized.

         ka = kptmwa + 1
         kb = min(ka+ndig-1-nzdmb, nl)
         if (maxmwa >= mlmax) then
             do j = kb, ka, -1
                if (mwa%mp(j+1) < 0) then
                    mcarry = int((-mwa%mp(j+1)-1)/mbase) + 1
                    mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
                    mwa%mp(j) = mwa%mp(j) - mcarry
                else if (mwa%mp(j+1) >= mbase) then
                    mcarry = -int(mwa%mp(j+1)/mbase)
                    mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
                    mwa%mp(j) = mwa%mp(j) - mcarry
                endif
             enddo
             xmwa = 0
             if (kl <= nl) then
                 do j = kptmwa, kl
                    xmwa = xmwa*xbase + dble(mwa%mp(j+1))
                 enddo
             else
                 do j = kptmwa, kl
                    if (j <= nl) then
                        xmwa = xmwa*xbase + dble(mwa%mp(j+1))
                    else
                        xmwa = xmwa*xbase
                    endif
                 enddo
             endif
             mqd = aint(xmwa*xbr)
             if (mqd < 0) mqd = mqd - 1
             if (mqd > 0) then
                 maxmwa = mqd
             else
                 maxmwa = -mqd
             endif
         endif

!             Subtract mqd*mb from mwa.

         jb = ka - 2
         if (mqd /= 0) then

!             Major (Inner Loop)

             do j = ka+1, kb+1
                mwa%mp(j) = mwa%mp(j) - mqd*mb%mp(j-jb)
             enddo
         endif

         mwa%mp(ka+1) = mwa%mp(ka+1) + mwa%mp(ka)*mbase
         mwa%mp(kptmwa+1) = mqd

         kptmwa = kptmwa + 1
         if (kptmwa <= ng) cycle
         if (mwa%mp(3) == 0 .and. kptmwa <= ng+1) cycle
         klp = 0
      enddo

      kl = kptmwa + nmbwds - 1
      if (kl <= nl) then
          xmwa = ((dble(mwa%mp(kptmwa+1))*xbase + dble(mwa%mp(kptmwa+2)))*xbase  &
                 + dble(mwa%mp(kptmwa+3)))*xbase + dble(mwa%mp(kptmwa+4))
          do j = kptmwa+4, kl
             xmwa = xmwa*xbase + dble(mwa%mp(j+1))
          enddo
      else
          xmwa = dble(mwa%mp(kptmwa+1))
          do j = kptmwa+1, kl
             if (j <= nl) then
                 xmwa = xmwa*xbase + dble(mwa%mp(j+1))
             else
                 xmwa = xmwa*xbase
             endif
          enddo
      endif
      mqd = aint(xmwa*xbr)
      if (mqd < 0) mqd = mqd - 1
      mwa%mp(kptmwa+1) = mqd
      mwa%mp(kptmwa+2) = 0
      mwa%mp(kptmwa+3) = 0

!             Final normalization.

      if (kptmwa > 2*ndig) then
          do j = 2*ndig+1, kptmwa
             if (mwa%mp(j+1) /= mbase-1) exit
             if (j == kptmwa) mwa%mp(j+1) = mbase
          enddo
      endif
      do j = kptmwa, 3, -1
         if (mwa%mp(j+1) < 0) then
             mcarry = int((-mwa%mp(j+1)-1)/mbase) + 1
             mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
             mwa%mp(j) = mwa%mp(j) - mcarry
         else if (mwa%mp(j+1) >= mbase) then
             mcarry = -int(mwa%mp(j+1)/mbase)
             mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
             mwa%mp(j) = mwa%mp(j) - mcarry
         endif
      enddo
      call fmmove(mwa, mc)
      mc%mp(1) = ma%mp(1) * mb%mp(1)

      return
      end subroutine fmcsdiv

      subroutine fmcsdivi(ma, ival, mb)

!  Internal divide by integer routine.  ma = ma / ival

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (inout) :: mb
      intent (in) :: ma, ival

      real (kind(1.0d0)) :: mkt, modint, mvalp
      integer :: j, ka, kb, kl, klp, kpt, kptwa, n1, nmval, nv2

      mvalp = abs(ival)
      nmval = int(mvalp)
      nv2 = nmval - 1
      if ((ntrace /= 0 .and. lvltrc >= ncall+1) .or. abs(ma%mp(2)) >= mexpab .or.  &
          ma%mp(3) == 0 .or. ival == 0 .or. abs(ival) > mxbase .or.                &
          nmval /= abs(ival) .or. nv2 /= abs(ival)-1) then
          call fmdivi(ma, ival, mb)
          return
      endif
      call fmalloc(mb, ndig+2)
      if (abs(ival) == 1) then
          call fmeq(ma, mb)
          mb%mp(1) = ma%mp(1)*ival
          return
      endif

!             Find the first significant digit of the quotient.

      kflag = 0
      n1 = ndig + 1
      mvalp = abs(ival)
      mkt = ma%mp(3)
      klp = 0
      kpt = 2
      if (mkt >= mvalp) then
          kpt = 2
      else
          do j = 3, n1
             mkt = mkt*mbase + ma%mp(j+1)
             if (mkt >= mvalp) then
                 kpt = j
                 klp = 1
                 exit
             endif
          enddo
          if (klp == 0) then
              kpt = n1
              do while (mkt < mvalp)
                 kpt = kpt + 1
                 mkt = mkt*mbase
              enddo
          endif
      endif

!             Do the rest of the division.

      ka = kpt + 1
      mb%mp(1) = ma%mp(1)*ival/abs(ival)
      mb%mp(2) = ma%mp(2) + 2 - kpt
      mb%mp(3) = int (mkt/mvalp)
      modint = mkt - mb%mp(3)*mvalp
      kptwa = 2
      if (ka <= n1) then
          kl = 3 - ka

!             (Inner Loop)

          do j = ka+1, n1+1
             mkt = modint*mbase + ma%mp(j)
             mb%mp(j+kl) = int (mkt/mvalp)
             modint = mkt - mb%mp(j+kl)*mvalp
          enddo
          kptwa = kl + n1
      endif

      ka = kptwa + 1
      kb = n1
      do j = ka, kb
         mkt = modint*mbase
         mb%mp(j+1) = int (mkt/mvalp)
         modint = mkt - mb%mp(j+1)*mvalp
      enddo

      return
      end subroutine fmcsdivi

      subroutine fmcsdivi_r1(ma, ival)

!  Internal divide by integer routine.  ma = ma / ival

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (inout) :: ma
      intent (in) :: ival

      real (kind(1.0d0)) :: mkt, modint, mvalp
      integer :: j, ka, kb, kl, klp, kpt, kptwa, n1, nmval, nv2

      mvalp = abs(ival)
      nmval = int(mvalp)
      nv2 = nmval - 1
      if ((ntrace /= 0 .and. lvltrc >= ncall+1) .or. abs(ma%mp(2)) >= mexpab .or.  &
          ma%mp(3) == 0 .or. ival == 0 .or. abs(ival) > mxbase .or.                &
          nmval /= abs(ival) .or. nv2 /= abs(ival)-1) then
          call fmdivi_r1(ma, ival)
          return
      endif
      if (abs(ival) == 1) then
          ma%mp(1) = ma%mp(1)*ival
          return
      endif

!             Find the first significant digit of the quotient.

      kflag = 0
      n1 = ndig + 1
      mvalp = abs(ival)
      mkt = ma%mp(3)
      klp = 0
      kpt = 2
      if (mkt >= mvalp) then
          kpt = 2
      else
          do j = 3, n1
             mkt = mkt*mbase + ma%mp(j+1)
             if (mkt >= mvalp) then
                 kpt = j
                 klp = 1
                 exit
             endif
          enddo
          if (klp == 0) then
              kpt = n1
              do while (mkt < mvalp)
                 kpt = kpt + 1
                 mkt = mkt*mbase
              enddo
          endif
      endif

!             Do the rest of the division.

      ka = kpt + 1
      ma%mp(2) = ma%mp(2) + 2 - kpt
      ma%mp(3) = int (mkt/mvalp)
      modint = mkt - ma%mp(3)*mvalp
      kptwa = 2
      if (ka <= n1) then
          kl = 3 - ka

!             (Inner Loop)

          do j = ka+1, n1+1
             mkt = modint*mbase + ma%mp(j)
             ma%mp(j+kl) = int (mkt/mvalp)
             modint = mkt - ma%mp(j+kl)*mvalp
          enddo
          kptwa = kl + n1
      endif

      ka = kptwa + 1
      kb = n1
      do j = ka, kb
         mkt = modint*mbase
         ma%mp(j+1) = int (mkt/mvalp)
         modint = mkt - ma%mp(j+1)*mvalp
      enddo
      if (ival < 0) call fmnegate(ma)

      return
      end subroutine fmcsdivi_r1

      subroutine fmcsmpy_r1(ma, mb)

!  Internal multiplication ma * mb.  The result is returned in ma.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      real (kind(1.0d0)) :: maxmwa, mbj, mbkj, mbnorm, mbp1, mk, mkt, mmax, mt
      real :: c
      integer :: j, jm1, k, kb, ki, kj, kl, knz, kwa, l, n1, nguard
      intent (inout) :: ma
      intent (in) :: mb

      c = 900
      if ((ntrace /= 0 .and. lvltrc >= ncall+1) .or. abs(ma%mp(2)) >= mexpab  .or.  &
          abs(mb%mp(2)) >= mexpab .or. ma%mp(3) == 0 .or.                           &
          mb%mp(3) == 0 .or. mbase < 1000 .or. ndig >= c) then
          call fmmpy_r1(ma, mb)
          return
      endif
      call fmalloc(mwa, 2*ndig+30)
      kflag = 0
      n1 = ndig + 1
      nguard = ngrd22
      mwa%mp(2) = ma%mp(2) + mb%mp(2)
      l = n1 + nguard
      mwa%mp(l+2) = 0

!             The multiplication loop begins here.

!             mbnorm is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             maxmwa is an upper bound on the size of values in mwa divided by (mbase-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      mbp1 = mbase + 1
      mbnorm = (maxint/(mbp1*mbp1))
      mmax = intmax - mbase
      mmax = min((maxint/mbp1 - mbp1), mmax)
      if (mbnorm >= 2) then
          mbj = mb%mp(3)

!             Count the trailing zeros in ma.

          knz = n1
          if (ma%mp(n1+1) /= 0) then
              knz = n1
          else
              do j = ndig, 2, -1
                 if (ma%mp(j+1) /= 0) then
                     knz = j
                     exit
                 endif
              enddo
          endif

          mwa%mp(3) = 0
          do k = ndig+2, l
             mwa%mp(k+1) = 0
          enddo

!             (Inner Loop)

          do k = 3, n1+1
             mwa%mp(k+1) = ma%mp(k)*mbj
          enddo
          maxmwa = mbj
          do j = 3, n1
             mbj = mb%mp(j+1)
             if (mbj /= 0) then
                 maxmwa = maxmwa + mbj
                 jm1 = j - 1
                 kl = min(knz, l-jm1)
                 do k = j+2, j+kl
                    mwa%mp(k) = mwa%mp(k) + ma%mp(k-jm1)*mbj
                 enddo
             endif

             if (maxmwa > mmax) then
                 maxmwa = 0
                 jm1 = j - 1
                 kl = min(knz, l-jm1)

!                       Here normalization is only required for the range of digits currently
!                       changing in mwa.

                 do kb = jm1+kl, jm1+2, -1
                    mkt = int (mwa%mp(kb+1)/mbase)
                    mwa%mp(kb) = mwa%mp(kb) + mkt
                    mwa%mp(kb+1) = mwa%mp(kb+1) - mkt*mbase
                 enddo
             endif
          enddo

!             Perform the final normalization.  (Inner Loop)

          do kb = l+1, 4, -1
             mkt = int (mwa%mp(kb)/mbase)
             mwa%mp(kb-1) = mwa%mp(kb-1) + mkt
             mwa%mp(kb) = mwa%mp(kb) - mkt*mbase
          enddo

      else

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          do j = 2, l
             mwa%mp(j+1) = 0
          enddo
          kj = ndig + 2
          do j = 2, n1
             kj = kj - 1
             mbkj = mb%mp(kj+1)
             if (mbkj == 0) cycle
             kl = l - kj + 1
             if (kl > n1) kl = n1
             ki = kl + 2
             kwa = kl+ kj + 1
             mk = 0
             do k = 2, kl
                mt = ma%mp(ki-k+1)*mbkj + mwa%mp(kwa-k+1) + mk
                mk = int (mt/mbase)
                mwa%mp(kwa-k+1) = mt - mbase*mk
             enddo
             mwa%mp(kwa-kl) = mk
          enddo
      endif

      if (ma%mp(1)*mb%mp(1) < 0) then
          ma%mp(1) = -1
      else
          ma%mp(1) = 1
      endif
      ma%mp(2) = mwa%mp(2)
      if (mwa%mp(3) == 0) then
          ma%mp(2) = ma%mp(2) - 1
          do j = 3, n1+1
             ma%mp(j) = mwa%mp(j+1)
          enddo
      else
          do j = 3, n1+1
             ma%mp(j) = mwa%mp(j)
          enddo
      endif

      return
      end subroutine fmcsmpy_r1

      subroutine fmcsmpyi(ma, ival, mb)

!  Internal multiply by integer routine.  mb = ma * ival

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb

      real (kind(1.0d0)) :: mcarry, mkt, mval
      integer :: j, kshift, nmval, nv2

      if ((ntrace /= 0 .and. lvltrc >= ncall+1) .or. abs(ma%mp(2)) >= mexpab .or.  &
          ma%mp(3) == 0 .or. abs(ival) <= 1 .or. abs(ival) > mxbase) then
          call fmmpyi(ma, ival, mb)
          return
      endif
      call fmalloc(mb, ndig+2)

!             Work with positive numbers.

      kflag = 0
      mval = abs(ival)
      nmval = int(mval)
      nv2 = nmval - 1

!             To leave room for the normalization, shift the product to the right kshift
!             places in mb.

      kshift = 0
      mkt = ma%mp(3) * mval
      do j = 1, 100
         if (mkt < mbase) exit
         kshift = kshift + 1
         mkt = int(mkt/mbase)
      enddo

      if (kshift > ndig .or. nmval /= abs(ival) .or. nv2 /= abs(ival)-1) then
          call fmmpyi(ma, ival, mb)
          return
      endif
      mb%mp(2) = ma%mp(2) + kshift

      mcarry = 0
      do j = ndig, ndig-kshift+1, -1
         mkt = ma%mp(j+2)*mval + mcarry
         mcarry = int(mkt/mbase)
      enddo
      do j = ndig-kshift, 1, -1
         mkt = ma%mp(j+2)*mval + mcarry
         mcarry = int(mkt/mbase)
         mb%mp(j+2+kshift) = mkt - mcarry*mbase
      enddo
      do j = kshift, 1, -1
         mkt = mcarry
         mcarry = int(mkt/mbase)
         mb%mp(j+2) = mkt - mcarry*mbase
      enddo
      if (mcarry > 0) then
          mb%mp(2) = mb%mp(2) + 1
          do j = ndig, 2, -1
             mb%mp(j+2) = mb%mp(j+1)
          enddo
          mb%mp(3) = mcarry
      endif

      if ((ma%mp(1) > 0 .and. ival > 0) .or. (ma%mp(1) < 0 .and. ival < 0)) then
          jrsign = 1
      else
          jrsign = -1
      endif
      mb%mp(1) = jrsign

      return
      end subroutine fmcsmpyi

      subroutine fmcsmpyi_r1(ma, ival)

!  Internal multiply by integer routine.  ma = ma * ival

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ival
      intent (inout) :: ma

      real (kind(1.0d0)) :: mcarry, mkt, mval
      integer :: j, kshift, nmval, nv2

      if ((ntrace /= 0 .and. lvltrc >= ncall+1) .or. abs(ma%mp(2)) >= mexpab .or.  &
          ma%mp(3) == 0 .or. abs(ival) <= 1 .or. abs(ival) > mxbase) then
          call fmmpyi_r1(ma, ival)
          return
      endif

!             Work with positive numbers.

      kflag = 0
      mval = abs(ival)
      nmval = int(mval)
      nv2 = nmval - 1

!             To leave room for the normalization, shift the product to the right kshift
!             places.

      kshift = 0
      mkt = ma%mp(3) * mval
      do j = 1, 100
         if (mkt < mbase) exit
         kshift = kshift + 1
         mkt = int(mkt/mbase)
      enddo

      if (kshift > ndig .or. nmval /= abs(ival) .or. nv2 /= abs(ival)-1) then
          call fmmpyi_r1(ma, ival)
          return
      endif
      ma%mp(2) = ma%mp(2) + kshift

      mcarry = 0
      do j = ndig, ndig-kshift+1, -1
         mkt = ma%mp(j+2)*mval + mcarry
         mcarry = int(mkt/mbase)
      enddo
      do j = ndig-kshift, 1, -1
         mkt = ma%mp(j+2)*mval + mcarry
         mcarry = int(mkt/mbase)
         ma%mp(j+2+kshift) = mkt - mcarry*mbase
      enddo
      do j = kshift, 1, -1
         mkt = mcarry
         mcarry = int(mkt/mbase)
         ma%mp(j+2) = mkt - mcarry*mbase
      enddo
      if (mcarry > 0) then
          ma%mp(2) = ma%mp(2) + 1
          do j = ndig, 2, -1
             ma%mp(j+2) = ma%mp(j+1)
          enddo
          ma%mp(3) = mcarry
      endif

      if ((ma%mp(1) > 0 .and. ival > 0) .or. (ma%mp(1) < 0 .and. ival < 0)) then
          jrsign = 1
      else
          jrsign = -1
      endif
      ma%mp(1) = jrsign

      return
      end subroutine fmcsmpyi_r1

      subroutine fmcsmpyin_r1(ma, jb, je)

!  Internal routine for  ma = ma * jb**je

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: jb, je
      intent (in) :: jb, je
      intent (inout) :: ma

      integer :: j, kj
      real (kind(1.0d0)) :: maxv

      kj = 1
      maxv = mxbase/jb
      if (je > 0) then
          do j = 1, je
             kj = jb*kj
             if (kj > maxv) then
                 call fmcsmpyi_r1(ma, kj)
                 kj = 1
             endif
          enddo
          if (kj > 1) call fmcsmpyi_r1(ma, kj)
      endif

      end subroutine fmcsmpyin_r1

      subroutine fmcsnorm(ma)

!  Internal routine to normalize the digits of ma.

      use fmvals
      implicit none

      type(multi) :: ma
      intent (inout) :: ma

      integer :: k, kshift
      real (kind(1.0d0)) :: mkt

      if (abs(ma%mp(2)) >= mexpov) return

      do k = ndig+2, 4, -1
         mkt = int (ma%mp(k)/mbase)
         ma%mp(k-1) = ma%mp(k-1) + mkt
         ma%mp(k) = ma%mp(k) - mkt*mbase
      enddo
      if (ma%mp(3) >= mbase) then
          mkt = ma%mp(3)
          kshift = 1
          do
             mkt = int (mkt/mbase)
             if (mkt < mbase) exit
             kshift = kshift + 1
          enddo
          do k = ndig+2, 3+kshift, -1
             ma%mp(k) = ma%mp(k-kshift)
          enddo
          do k = 3+kshift, 4, -1
             mkt = int (ma%mp(k)/mbase)
             ma%mp(k-1) = mkt
             ma%mp(k) = ma%mp(k) - mkt*mbase
          enddo
          ma%mp(2) = ma%mp(2) + kshift
      endif

      end subroutine fmcsnorm

      subroutine fmcsnsums(j2, mjsums)

!  Internal routine to normalize mjsums.

      use fmvals
      implicit none

      integer :: j2
      type(multi) :: mjsums(j2)
      intent (in) :: j2
      intent (inout) :: mjsums

      integer :: j

      do j = 1, j2
         call fmcsnorm(mjsums(j))
      enddo

      return
      end subroutine fmcsnsums

      subroutine fmcssn(ma, mb, mc)

!  mb = cos(ma),    mc = sin(ma)

!  If both the sine and cosine are needed, this routine is faster than calling both fmcos and fmsin.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      type(multi), save :: mxy(4), mresult1, mresult2
      logical :: retry

      call fmalloc(mb, ndig+2)
      call fmalloc(mc, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmcssn_sc(ma, mxy, ndsave, mresult1, mresult2, kresult)
      if (kresult > 0) then
          call fmexit2(mresult1, mresult2, mb, mc, kovun, mxsave, ndsave)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmcssn_m1(ma, mxy, mresult1, mresult2, ndsave)
         call fmcheck_accuracy(mresult1, ndsave, retry)
         if (retry) cycle
         call fmcheck_accuracy(mresult2, ndsave, retry)
      enddo

      call fmexit2(mresult1, mresult2, mb, mc, kovun, mxsave, ndsave)

      return
      end subroutine fmcssn

      subroutine fmcssn_m1(ma, mxy, mresult1, mresult2, ndsave)

!  Method 1 for computing fmcssn(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(4), mresult1, mresult2
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult1, mresult2

      integer :: jcos, jsin, jswap, krndsave, ndsv

      krndsave = kround
      kround = 1
      call fmequ(ma, mresult1, ndsave, ndig)
      mresult1%mp(1) = 1
      call fmeq(mresult1, mxy(4))

!             Reduce the argument, convert to radians if the input is in degrees, and evaluate
!             the functions.

      call fmrdc(mresult1, jsin, jcos, jswap)
      if (kround /= 1 .and. krad /= 1) then
          call fmi2m(30, mxy(1))
          call fmsub(mresult1, mxy(1), mxy(2))
          if (mxy(2)%mp(3) == 0) then
              call fmcos(mxy(4), mresult1)
              call fmsin(mxy(4), mresult2)
              if (ma%mp(1) < 0) call fmnegate(mresult2)
              return
          endif
      endif
      if (mresult1%mp(2) == munkno) then
          call fmcos(mxy(4), mresult1)
          call fmsin(mxy(4), mresult2)
          if (ma%mp(1) < 0) call fmnegate(mresult2)
          return
      endif
      if (krad == 0) then
          if (mbspi /= mbase .or. ndigpi < ndig) then
              ndsv = ndig
              ndig = ndig + 2
              call fmpi(mxy(2))
              ndig = ndsv
          endif
          call fmpi(mxy(1))
          call fmmpy_r1(mresult1, mxy(1))
          call fmdivi_r1(mresult1, 180)
      endif
      if (mresult1%mp(2) /= munkno) then
          if (jswap == 0) then
              if (mresult1%mp(2) < 0) then
                  call fmsin2(mresult1, mresult2)
                  mresult2%mp(1) = jsin*mresult2%mp(1)
                  call fmsqr(mresult2, mxy(2))
                  call fmi2m(1, mxy(1))
                  call fmsub_r2(mxy(1), mxy(2))
                  call fmsqrt(mxy(2), mresult1)
                  mresult1%mp(1) = jcos*mresult1%mp(1)
              else
                  call fmcos2(mresult1, mxy(3))
                  call fmeq(mxy(3), mresult1)
                  mresult1%mp(1) = jcos*mresult1%mp(1)
                  call fmsqr(mresult1, mxy(2))
                  call fmi2m(1, mxy(1))
                  call fmsub_r2(mxy(1), mxy(2))
                  call fmsqrt(mxy(2), mresult2)
                  mresult2%mp(1) = jsin*mresult2%mp(1)
              endif
          else
              if (mresult1%mp(2) < 0) then
                  call fmsin2(mresult1, mxy(3))
                  call fmeq(mxy(3), mresult1)
                  mresult1%mp(1) = jcos*mresult1%mp(1)
                  call fmsqr(mresult1, mxy(2))
                  call fmi2m(1, mxy(1))
                  call fmsub_r2(mxy(1), mxy(2))
                  call fmsqrt(mxy(2), mresult2)
                  mresult2%mp(1) = jsin*mresult2%mp(1)
              else
                  call fmcos2(mresult1, mresult2)
                  mresult2%mp(1) = jsin*mresult2%mp(1)
                  call fmsqr(mresult2, mxy(2))
                  call fmi2m(1, mxy(1))
                  call fmsub_r2(mxy(1), mxy(2))
                  call fmsqrt(mxy(2), mresult1)
                  mresult1%mp(1) = jcos*mresult1%mp(1)
              endif
          endif
      else
          call fmeq(mresult1, mresult2)
      endif
      kround = krndsave
      if (ma%mp(1) < 0) call fmnegate(mresult2)

      return
      end subroutine fmcssn_m1

      subroutine fmcssn_sc(ma, mxy, ndsave, mresult1, mresult2, kresult)

!  Check for special cases for fmcssn.

!  kresult = 1 is returned if a special case gives the values of the two results.

      use fmvals
      implicit none

      type(multi) :: ma, mxy(4), mresult1, mresult2
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult1, mresult2, kresult

      integer :: j

      kresult = 0

      namest(ncall) = 'FMCSSN   '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, mxy(1), ndsave, ndig)

      if (mxy(1)%mp(2) == munkno .and. mxy(1)%mp(5) >= 0) then
          call fmunknown(mresult1)
          call fmunknown(mresult2)
          kresult = 1
          return
      endif

      if (abs(mxy(1)%mp(2)) >= mexpov) then
          call fmcos(mxy(1), mresult1)
          call fmsin(mxy(1), mresult2)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (kround /= 1 .and. mxy(1)%mp(2) < -ndsave) then
          call fmcos(mxy(1), mresult1)
          call fmsin(mxy(1), mresult2)
          kresult = 1
          return
      endif
      if (abs(mxy(1)%mp(2)) > mexpab .or. mxy(1)%mp(3) == 0) then
          call fmcos(mxy(1), mresult1)
          call fmsin(mxy(1), mresult2)
          kresult = 1
          return
      endif
      if (ma%mp(2) > 3*10**5 .and. krad == 1) then
          call fmunknown(mresult1)
          call fmunknown(mresult2)
          kresult = 1
          return
      endif

      return
      end subroutine fmcssn_sc

      subroutine fmdbl(a, b, c)

!  c = a + b.  All are double precision.  This routine tries to force the compiler to round c to
!  double precision accuracy. Some compilers allow double precision loops like the one in fmdpm2 to
!  be done in extended precision, which defeats the routine's attempt to determine double precision
!  accuracy.  This can lead to doing too few Newton steps and failing to get sufficient accuracy in
!  several FM routines.

      use fmvals
      implicit none
      double precision :: a, b, c
      intent (in) :: a, b
      intent (inout) :: c
      c = a + b

      return
      end subroutine fmdbl

      subroutine fmdefine_error

      use fmvals
      implicit none

      write (kw,*) ' '
      write (kw,*) ' Error in FM.  Out of memory for multiple precision numbers'
      write (kw,*) '               or character strings to format FM output.'
      write (kw,*) '               Allocation of more memory failed.'
      write (kw,*) ' '

      stop
      end subroutine fmdefine_error

      subroutine fmdig(nstack, kst)

!  Compute the number of intermediate digits to be used in Newton iteration.  This assumes that a
!  starting approximation that is accurate to double precision is used, and the root is simple.

!  kst is the number of iterations needed for final accuracy ndig.
!  nstack(j) holds the value of ndig to be used for the jth iteration.

      use fmvals
      implicit none

      integer :: nstack(49), kst
      intent (inout) :: nstack, kst

      double precision :: y
      integer :: j, jt, kl, l, nd, ndt, ne

      if (mblogs /= mbase) call fmcons

!             ne is the maximum number of base mbase digits that can be used in the first
!                Newton iteration.

      ne = int(1.9d0*dlogeb)

!             Fill the intermediate digit stack (backwards).

      kst = 1
      nd = ndig
      nstack(1) = nd
      if (nd < ne .or. nd <= 2) return

      kl = 1
      do while (kl == 1)
         y = nd

!             The 1.9 accounts for the fact that the number of correct digits approximately doubles
!             at each iteration.

         ndt = int(y/1.9d0)
         if (2*ndt <= nd) ndt = ndt + 1
         nd = ndt
         kst = kst + 1
         nstack(kst) = nd
         if (nd > ne .and. nd > 2) cycle
         kl = 0
      enddo

!             Reverse the stack.

      l = kst/2
      do j = 1, l
         jt = nstack(j)
         nstack(j) = nstack(kst+1-j)
         nstack(kst+1-j) = jt
      enddo

      return
      end subroutine fmdig

      subroutine fmdim(ma, mb, mc)

!  mc = dim(ma, mb)

!  Positive difference.  mc = ma - mb  if ma >= mb,
!                           = 0        otherwise.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      logical, external :: fmcomp
      type(multi), save :: mxy(3)

      call fmalloc(mc, ndig+2)
      if (mblogs /= mbase) call fmcons
      call fmenter2(ma, mb, kovun, mxsave, ndsave)
      ndig = ndsave
      namest(ncall) = 'FMDIM    '
      call fmntr_inp2(ma, mb)

      call fmequ(ma, mxy(1), ndsave, ndig)
      call fmequ(mb, mxy(2), ndsave, ndig)

      if (fmcomp(mxy(1), '<', mxy(2))) then
          call fmi2m(0, mxy(3))
      else
          call fmsub(mxy(1), mxy(2), mxy(3))
      endif

      if (kflag == 1) kflag = 0
      call fmexit1(mxy(3), mc, kovun, mxsave, ndsave)

      return
      end subroutine fmdim

      subroutine fmdiv(ma, mb, mc)

!  mc = ma / mb

!  This routine performs the trace printing for division.  fmdiv2 is used to do the arithmetic.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: kovun

      ncall = ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == mexpov .or. abs(mb%mp(2)) == mexpov) kovun = 1
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) kovun = 2
      if (ntrace /= 0) then
          namest(ncall) = 'FMDIV'
          call fmntr_inp2(ma, mb)
      endif

      call fmdiv2(ma, mb, mc)

      if ((abs(mc%mp(2)) == mexpov .and. kovun == 0) .or.  &
          (abs(mc%mp(2)) == munkno .and. kovun < 2)) then
          namest(ncall) = 'FMDIV'
          call fmwarn
      endif
      if (ntrace /= 0) then
          call fmntr_out1(mc)
      endif
      ncall = ncall - 1

      return
      end subroutine fmdiv

      subroutine fmdiv2(ma, mb, mc)

!  Internal division routine.  mc = ma / mb

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      logical :: retry
      integer :: kresult, kr_retry

      call fmalloc(mc, ndig+2)
      call fmalloc(mwa, 2*ndig+30)
      call fmdiv_sc(ma, mb, mc, kresult)
      if (kresult > 0) then
          return
      endif

      if (mblogs /= mbase) call fmcons

      kr_retry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fmdiv_m1(ma, mb, mc, kr_retry, retry)
      enddo

      return
      end subroutine fmdiv2

      subroutine fmdiv2_r1(ma, mb)

!  Internal division routine.  ma = ma / mb

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb

      type(multi), save :: mxy

      call fmdiv2(ma, mb, mxy)
      call fmeq(mxy, ma)

      return
      end subroutine fmdiv2_r1

      subroutine fmdiv2_r2(ma, mb)

!  Internal division routine.  mb = ma / mb

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(multi), save :: mxy

      call fmdiv2(ma, mb, mxy)
      call fmeq(mxy, mb)

      return
      end subroutine fmdiv2_r2

      subroutine fmdiv3(mb, ng)

!  Internal division routine.  Divide ma/mb and return the quotient in mwa.
!  ma has already been copied into mwa.
!  ng is the number of guard digits used.

      use fmvals
      implicit none

      type(multi) :: mb
      integer :: ng
      intent (in) :: mb, ng

      double precision :: xb, xbr, xbase, xmwa
      real (kind(1.0d0)) :: maxmwa, mbp1, mcarry, mkt, mlmax, mqd
      integer :: j, jb, jl, ka, kb, kl, kptmwa, n1, nl, nmbwds, nmethd, nzdmb
      real :: c
      logical :: div_loop


      n1 = ndig + 1
      nl = ng + 4

!             Check for using an fft-based method if precision is very high.

      c = 3100
      if (ndig >= c) then
          nzdmb = 0
          do j = 2, ndig
             if (mb%mp(j+2) == 0) nzdmb = nzdmb + 1
          enddo
          if (ndig-nzdmb < 50 .or. real(nzdmb)/ndig > 0.8 ) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          nmethd = 1
      endif
      if (nmethd == 2) then
          call fmdivfft(mb)
          return
      endif

!             nmbwds is the number of words of mb used to compute the estimated quotient digit mqd.

      nmbwds = 4
      if (mbase < 100) nmbwds = 7

!             xb is an approximation of mb used in estimating the quotient digits.

      xbase = dble(mbase)
      xb = 0
      jl = nmbwds
      if (jl <= n1) then
          do j = 2, jl
             xb = xb*xbase + dble(mb%mp(j+1))
          enddo
      else
          do j = 2, jl
             if (j <= n1) then
                 xb = xb*xbase + dble(mb%mp(j+1))
             else
                 xb = xb*xbase
             endif
          enddo
      endif
      if (jl+1 <= n1) then
          xb = xb + dble(mb%mp(jl+2))/xbase
      endif
      xbr = 1.0d0/xb

!             mlmax determines when to normalize all of mwa.

      mbp1 = mbase + 1
      mlmax = maxint/mbp1
      mkt = intmax - mbase
      mlmax = min(mlmax, mkt)

!             Count the trailing zero digits of mb.

      nzdmb = n1 - 2
      do j = n1, 2, -1
         if (mb%mp(j+1) /= 0) then
             nzdmb = n1 - j
             exit
         endif
      enddo

!             maxmwa is an upper bound on the size of values in mwa divided by mbase-1.  It is used
!             to determine whether normalization can be postponed.

      maxmwa = 0

!             kptmwa points to the next digit in the quotient.

      kptmwa = 2

!             This is the start of the division loop.

!             xmwa is an approximation of the active part of mwa used in estimating quotient digits.

      div_loop = .true.
      do while (div_loop)
         kl = kptmwa + nmbwds - 1
         if (kl <= nl) then
             xmwa = ((dble(mwa%mp(kptmwa+1))*xbase + dble(mwa%mp(kptmwa+2)))*xbase  &
                    + dble(mwa%mp(kptmwa+3)))*xbase + dble(mwa%mp(kptmwa+4))
             do j = kptmwa+4, kl
                xmwa = xmwa*xbase + dble(mwa%mp(j+1))
             enddo
         else
             xmwa = dble(mwa%mp(kptmwa+1))
             do j = kptmwa+1, kl
                if (j <= nl) then
                    xmwa = xmwa*xbase + dble(mwa%mp(j+1))
                else
                    xmwa = xmwa*xbase
                endif
             enddo
         endif

!             mqd is the estimated quotient digit.

         mqd = aint(xmwa*xbr)
         if (mqd < 0) mqd = mqd - 1

         if (mqd > 0) then
             maxmwa = maxmwa + mqd
         else
             maxmwa = maxmwa - mqd
         endif

!             See if mwa must be normalized.

         ka = kptmwa + 1
         kb = min(ka+ndig-1-nzdmb, nl)
         if (maxmwa >= mlmax) then
             do j = kb, ka, -1
                if (mwa%mp(j+1) < 0) then
                    mcarry = int((-mwa%mp(j+1)-1)/mbase) + 1
                    mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
                    mwa%mp(j) = mwa%mp(j) - mcarry
                else if (mwa%mp(j+1) >= mbase) then
                    mcarry = -int(mwa%mp(j+1)/mbase)
                    mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
                    mwa%mp(j) = mwa%mp(j) - mcarry
                endif
             enddo
             xmwa = 0
             if (kl <= nl) then
                 do j = kptmwa, kl
                    xmwa = xmwa*xbase + dble(mwa%mp(j+1))
                 enddo
             else
                 do j = kptmwa, kl
                    if (j <= nl) then
                        xmwa = xmwa*xbase + dble(mwa%mp(j+1))
                    else
                        xmwa = xmwa*xbase
                    endif
                 enddo
             endif
             mqd = aint(xmwa*xbr)
             if (mqd < 0) mqd = mqd - 1
             if (mqd > 0) then
                 maxmwa = mqd
             else
                 maxmwa = -mqd
             endif
         endif

!             Subtract mqd*mb from mwa.

         jb = ka - 2
         if (mqd /= 0) then

!             Major (Inner Loop)

             do j = ka+1, kb+1
                mwa%mp(j) = mwa%mp(j) - mqd*mb%mp(j-jb)
             enddo
         endif

         mwa%mp(ka+1) = mwa%mp(ka+1) + mwa%mp(ka)*mbase
         mwa%mp(kptmwa+1) = mqd

         kptmwa = kptmwa + 1
         if (kptmwa <= ng) then
             div_loop = .true.
         else if (mwa%mp(3) == 0 .and. kptmwa <= ng+1) then
             div_loop = .true.
         else
             div_loop = .false.
         endif
      enddo

      kl = kptmwa + nmbwds - 1
      if (kl <= nl) then
          xmwa = ((dble(mwa%mp(kptmwa+1))*xbase + dble(mwa%mp(kptmwa+2)))*xbase  &
                 + dble(mwa%mp(kptmwa+3)))*xbase + dble(mwa%mp(kptmwa+4))
          do j = kptmwa+4, kl
             xmwa = xmwa*xbase + dble(mwa%mp(j+1))
          enddo
      else
          xmwa = dble(mwa%mp(kptmwa+1))
          do j = kptmwa+1, kl
             if (j <= nl) then
                 xmwa = xmwa*xbase + dble(mwa%mp(j+1))
             else
                 xmwa = xmwa*xbase
             endif
          enddo
      endif
      mqd = aint(xmwa*xbr)
      if (mqd < 0) mqd = mqd - 1
      mwa%mp(kptmwa+1) = mqd
      mwa%mp(kptmwa+2) = 0
      mwa%mp(kptmwa+3) = 0

!             Final normalization.

      if (kptmwa > 2*ndig) then
          do j = 2*ndig+1, kptmwa
             if (mwa%mp(j+1) /= mbase-1) exit
             if (j == kptmwa) mwa%mp(j+1) = mbase
          enddo
      endif
      do j = kptmwa, 3, -1
         if (mwa%mp(j+1) < 0) then
             mcarry = int((-mwa%mp(j+1)-1)/mbase) + 1
             mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
             mwa%mp(j) = mwa%mp(j) - mcarry
         else if (mwa%mp(j+1) >= mbase) then
             mcarry = -int(mwa%mp(j+1)/mbase)
             mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
             mwa%mp(j) = mwa%mp(j) - mcarry
         endif
      enddo

      return
      end subroutine fmdiv3

      subroutine fmdiv_m1(ma, mb, mc, kr_retry, retry)

!  Method 1 for computing mc = ma / mb.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      integer :: kr_retry
      logical :: retry
      intent (in) :: ma, mb
      intent (inout) :: mc, kr_retry, retry

      real (kind(1.0d0)) :: mlr, mr, ms, mt1, mt2
      double precision :: err
      integer :: j, jrssav, k, kl, kt, kt1, kt2, kt3, l, n1, ng, nguard, nl

      kflag = 0
      jrssav = jrsign

!             nguard is the number of guard digits used.

      if (ncall > 1) then
          nguard = ngrd21
          if (nguard > ndig) nguard = ndig
      else
          nguard = ngrd52 - 1
          if (kr_retry >= 1) then
              nguard = ndig + 10
          endif
      endif
      if (nguard > ndig+10) nguard = ndig + 10
      n1 = ndig + 1
      ng = ndig + nguard
      if ((ma%mp(1) > 0 .and. mb%mp(1) > 0) .or. (ma%mp(1) < 0 .and. mb%mp(1) < 0)) then
          jrsign = 1
      else
          jrsign = -1
      endif
      mwa%mp(2) = ma%mp(2) - mb%mp(2) + 1

      if (mbase*mbase <= mxbase/(4*mbase)) then

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2**24) while
!             doing the operation.

          if (ndigl /= ndig .or. mbasel /= mbase .or. nguarl /= nguard) then
              mbasel = mbase
              ndigl = ndig
              nguarl = nguard
              do j = 2, 1000
                 mr = mbase*mbasel
                 if (4*mr > mxbase) then
                     n21 = j - 1
                     ndig = (ndigl-1)/n21 + 1
                     if (ndig < 3) ndig = 3
                     ngrdn = (ndigl+nguard-1)/n21 + 2 - ndig
                     if (ngrdn < 1) ngrdn = 1
                     exit
                 endif
                 mbase = mr
              enddo
              mbasen = mbase
              ndign = ndig
          else
              mbase = mbasen
              ndig = ndign
          endif
          if (mblogs /= mbase) call fmcons
          j = ndig
          ndig = ndig + ngrdn + 5
          call fmalloc(mpma, ndig+2)
          call fmalloc(mpmb, ndig+2)
          ndig = j
          mpma%mp(1) = ma%mp(1)
          mpmb%mp(1) = mb%mp(1)
          mpma%mp(2) = 0
          mpmb%mp(2) = 0
          l = 2 - n21
          do j = 2, ndigl+2-n21, n21
             mt1 = ma%mp(j+1)
             mt2 = mb%mp(j+1)
             do k = j+1, j+n21-1
                mt1 = mt1*mbasel + ma%mp(k+1)
                mt2 = mt2*mbasel + mb%mp(k+1)
             enddo
             mpma%mp(3+j/n21) = mt1
             mpmb%mp(3+j/n21) = mt2
             l = j
          enddo
          do j = 3+l/n21, ndig+ngrdn+2
             mpma%mp(j+1) = 0
             mpmb%mp(j+1) = 0
          enddo
          if (l+n21 <= ndigl+1) then
              mt1 = 0
              mt2 = 0
              do j = l+n21, l+2*n21-1
                 if (j <= ndigl+1) then
                     mt1 = mt1*mbasel + ma%mp(j+1)
                     mt2 = mt2*mbasel + mb%mp(j+1)
                 else
                     mt1 = mt1*mbasel
                     mt2 = mt2*mbasel
                 endif
              enddo
              mpma%mp(3+(l+n21)/n21) = mt1
              mpmb%mp(3+(l+n21)/n21) = mt2
          endif
          ng = ndig + ngrdn + 1
          if (mpma%mp(3) >= mpmb%mp(3)) ng = ng + 1

!             Copy ma into the working array.

          do j = 2, ndig+1
             mwa%mp(j+2) = mpma%mp(j+1)
          enddo
          mwa%mp(3) = 0
          do j = ndig+3, ng+4
             mwa%mp(j+1) = 0
          enddo
          call fmdiv3(mpmb, ng)
          if (mwa%mp(3) >= mbasel) then
              do j = 2+ndig+ngrdn, 3, -1
                 mwa%mp(j+1) = mwa%mp(j)
              enddo
              mwa%mp(3) = 0
              mwa%mp(2) = mwa%mp(2) + 1
          endif
          kt3 = n21 - 1
          if (mbasel == 2 .and. mbase < intmax) then
              do j = 2+ndig+ngrdn, 3, -1
                 kt1 = mwa%mp(j+1)
                 kt = 2 + (j-2)*n21
                 kt2 = n21 + kt - 1
                 do k = kt, min(1+(j-1)*n21, ndigl+nguard+2+kt3)
                    mwa%mp(k-kt3+1) = ibits(kt1, kt2-k, 1)
                 enddo
              enddo
          else
              ms = mbasel**(n21-1)
              do j = 2+ndig+ngrdn, 3, -1
                 mr = ms
                 mt1 = mwa%mp(j+1)
                 do k = 2+(j-2)*n21, min(1+(j-1)*n21, ndigl+nguard+2+kt3)
                    mwa%mp(k-kt3+1) = aint (mt1/mr)
                    mt1 = mt1 - mwa%mp(k-kt3+1)*mr
                    mr = aint (mr/mbasel)
                 enddo
              enddo
          endif
          ndig = ndigl
          mbase = mbasel
          if (mblogs /= mbase) call fmcons
      else

!             This is the normal case, where the base is not small.

!             Copy ma into the working array.

          do j = 2, n1
             mwa%mp(j+2) = ma%mp(j+1)
          enddo
          mwa%mp(3) = 0
          nl = n1 + nguard + 3
          do j = ndig+3, nl
             mwa%mp(j+1) = 0
          enddo
          call fmdiv3(mb, ng)
      endif

!             Round, affix the sign, and return.

      if (mwa%mp(3) == 0) then

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

          if (ncall >= 1 .and. nguard < ndig+10) then
              kl = min(nguard, int(3*dlogtn/dlogmb + 1.5))
              err = 0
              do j = kl, 1, -1
                 err = (err + mwa%mp(j+ndig+3)) / mbase
              enddo
              if ( (kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
                   (kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) kr_retry = kr_retry + 1
          endif
          if (kr_retry == 1 .and. nguard < ndig+10) then
              kr_retry = 2
              retry = .true.
              return
          endif
          mlr = 2*mwa%mp(ndig+4) + 1
          if (kround == -1 .or. kround == 2) then
              call fmrnd(mwa, ndig, nguard, 1)
          else if (mlr >= mbase) then
              if (mlr-1 > mbase .and. mwa%mp(n1+2) < mbase-1) then
                  if (kround /= 0) then
                      mwa%mp(n1+2) = mwa%mp(n1+2) + 1
                      mwa%mp(n1+3) = 0
                  endif
              else
                  call fmrnd(mwa, ndig, nguard, 1)
              endif
          endif
      else
          if (ncall >= 1 .and. nguard < ndig+10) then
              kl = min(nguard, int(3*dlogtn/dlogmb + 1.5))
              err = 0
              do j = kl, 1, -1
                 err = (err + mwa%mp(j+ndig+2)) / mbase
              enddo
              if ( (kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
                   (kround /= 1 .and. (err > 0.998 .or. err < 0.002)) )    &
                  kr_retry = kr_retry + 1
          endif
          if (kr_retry == 1 .and. nguard < ndig+10) then
              kr_retry = 2
              retry = .true.
              return
          endif
          mlr = 2*mwa%mp(ndig+3) + 1
          if (kround == -1 .or. kround == 2) then
              call fmrnd(mwa, ndig, nguard, 0)
          else if (mlr >= mbase) then
              if (mlr-1 > mbase .and. mwa%mp(n1+1) < mbase-1) then
                  if (kround /= 0) then
                      mwa%mp(n1+1) = mwa%mp(n1+1) + 1
                      mwa%mp(n1+2) = 0
                  endif
              else
                  call fmrnd(mwa, ndig, nguard, 0)
              endif
          endif
      endif
      call fmmove(mwa, mc)

      mc%mp(1) = 1
      if (ma%mp(1)*mb%mp(1) < 0 .and. mc%mp(2) /= munkno .and.  &
          mc%mp(3) /= 0) mc%mp(1) = -1
      jrsign = jrssav

      return
      end subroutine fmdiv_m1

      subroutine fmdiv_r1(ma, mb)

!  ma = ma / mb

!  This routine performs the trace printing for division.  fmdiv2_r1 is used to do the arithmetic.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb

      integer :: kovun

      ncall = ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == mexpov .or. abs(mb%mp(2)) == mexpov) kovun = 1
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) kovun = 2
      if (ntrace /= 0) then
          namest(ncall) = 'FMDIV_R1'
          call fmntr_inp2(ma, mb)
      endif

      call fmdiv2_r1(ma, mb)

      if ((abs(ma%mp(2)) == mexpov .and. kovun == 0) .or.  &
          (abs(ma%mp(2)) == munkno .and. kovun < 2)) then
          namest(ncall) = 'FMDIV_R1'
          call fmwarn
      endif
      if (ntrace /= 0) then
          call fmntr_out1(ma)
      endif
      ncall = ncall - 1

      return
      end subroutine fmdiv_r1

      subroutine fmdiv_r2(ma, mb)

!  mb = ma / mb

!  This routine performs the trace printing for division.  fmdiv2_r2 is used to do the arithmetic.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      integer :: kovun

      ncall = ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == mexpov .or. abs(mb%mp(2)) == mexpov) kovun = 1
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) kovun = 2
      if (ntrace /= 0) then
          namest(ncall) = 'FMDIV_R2'
          call fmntr_inp2(ma, mb)
      endif

      call fmdiv2_r2(ma, mb)

      if ((abs(mb%mp(2)) == mexpov .and. kovun == 0) .or.  &
          (abs(mb%mp(2)) == munkno .and. kovun < 2)) then
          namest(ncall) = 'FMDIV_R2'
          call fmwarn
      endif
      if (ntrace /= 0) then
          call fmntr_out1(mb)
      endif
      ncall = ncall - 1

      return
      end subroutine fmdiv_r2

      subroutine fmdiv_sc(ma, mb, mc, kresult)

!  Check for special cases for mc = ma / mb.

!  kresult = 1 is returned if a special case gives the value of mc.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      integer :: kresult
      intent (in) :: ma, mb
      intent (inout) :: mc, kresult

      integer :: jrssav


      if (mblogs /= mbase) call fmcons
      kresult = 0
      jrssav = jrsign
      if ((ma%mp(2) == munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc)
          kflag = -4
          kresult = 1
          return
      endif
      if (abs(ma%mp(2)) >= mexpov .or. abs(mb%mp(2)) >= mexpov) then
          call fmovun_div(ma, mb, mc)
          kresult = 1
          return
      endif
      if (mb%mp(3) == 0) then
          call fmi2m2(0, mc)
          kflag = -4
          mc%mp(2) = munkno
          mc%mp(3) = 1
          jrsign = jrssav
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0) then
          call fmi2m2(0, mc)
          jrsign = jrssav
          kresult = 1
          return
      endif

      return
      end subroutine fmdiv_sc

      subroutine fmdivd(ma, mb, mc, md, me)

!  Double division routine.  md = ma / mc,   me = mb / mc

!  It is usually slightly faster to do two divisions that have the same denominator with one call.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md, me
      intent (in) :: ma, mb, mc
      intent (inout) :: md, me

      ncall = ncall + 1
      if (ntrace /= 0) then
          namest(ncall) = 'FMDIVD'
          call fmntr_inp3(ma, mb, mc)

          call fmdivd2(ma, mb, mc, md, me)

          call fmntr_out2(md, me)
      else
          call fmdivd2(ma, mb, mc, md, me)
      endif
      ncall = ncall - 1

      return
      end subroutine fmdivd

      subroutine fmdivd2(ma, mb, mc, md, me)

!  Double division routine.  md = ma / mc,   me = mb / mc

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md, me
      intent (in) :: ma, mb, mc
      intent (inout) :: md, me

      integer :: jrssav, kresult

      call fmalloc(md, ndig+2)
      call fmalloc(me, ndig+2)
      call fmalloc(mwa, 2*ndig+30)
      call fmalloc(mwd, 2*ndig+30)
      call fmdivd_sc(ma, mb, mc, md, me, kresult)
      if (kresult > 0) then
          return
      endif
      jrssav = jrsign

      if (mblogs /= mbase) call fmcons

      call fmdivd_m1(ma, mb, mc, md, me)
      jrsign = jrssav

      return
      end subroutine fmdivd2

      subroutine fmdivd3(k, ma, mb, mc, mw, mr)

!  Round from the work area mw to mr.

!  k = 1 for rounding mw = ma / mc
!  k = 2 for rounding mw = mb / mc

      use fmvals
      implicit none

      integer :: k
      type(multi) :: ma, mb, mc, mw, mr
      intent (in) :: k, ma, mb, mc
      intent (inout) :: mw, mr

      real (kind(1.0d0)) :: mlr
      double precision :: err
      integer :: j, kl, n1, nguard

      if (ncall > 1) then
          nguard = ngrd21
          if (nguard > ndig) nguard = ndig
      else
          nguard = ngrd52 - 1
      endif
      n1 = ndig + 1

      if (k == 1) then
          jrsign = ma%mp(1) * mc%mp(1)
      else
          jrsign = mb%mp(1) * mc%mp(1)
      endif
      if (mw%mp(3) == 0) then
          if (ncall >= 1) then
              kl = min(nguard, int(3*dlogtn/dlogmb + 1.5))
              err = 0
              do j = kl, 1, -1
                 err = (err + mw%mp(j+ndig+3)) / mbase
              enddo
              if ( (kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
                   (kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) then
                  if (k == 1) then
                      call fmdiv2(ma, mc, mr)
                  else
                      call fmdiv2(mb, mc, mr)
                  endif
                  return
              endif
          endif
          mlr = 2*mw%mp(ndig+4) + 1
          if (kround == -1 .or. kround == 2) then
              call fmrnd(mw, ndig, nguard, 1)
          else if (mlr >= mbase) then
              if (mlr-1 > mbase .and. mw%mp(n1+2) < mbase-1) then
                  if (kround /= 0) then
                      mw%mp(n1+2) = mw%mp(n1+2) + 1
                      mw%mp(n1+3) = 0
                  endif
              else
                  call fmrnd(mw, ndig, nguard, 1)
              endif
          endif
      else
          if (ncall >= 1) then
              kl = min(nguard, int(3*dlogtn/dlogmb + 1.5))
              err = 0
              do j = kl, 1, -1
                 err = (err + mw%mp(j+ndig+2)) / mbase
              enddo
              if ( (kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
                   (kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) then
                  if (k == 1) then
                      call fmdiv2(ma, mc, mr)
                  else
                      call fmdiv2(mb, mc, mr)
                  endif
                  return
              endif
          endif
          mlr = 2*mw%mp(ndig+3) + 1
          if (kround == -1 .or. kround == 2) then
              call fmrnd(mw, ndig, nguard, 0)
          else if (mlr >= mbase) then
              if (mlr-1 > mbase .and. mw%mp(n1+1) < mbase-1) then
                  if (kround /= 0) then
                      mw%mp(n1+1) = mw%mp(n1+1) + 1
                      mw%mp(n1+2) = 0
                  endif
              else
                  call fmrnd(mw, ndig, nguard, 0)
              endif
          endif
      endif
      call fmmove(mw, mr)

      return
      end subroutine fmdivd3

      subroutine fmdivd_m1(ma, mb, mc, md, me)

!  Method 1 for computing  md = ma / mc  and  me = mb / mc.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md, me
      intent (in) :: ma, mb, mc
      intent (inout) :: md, me

      real (kind(1.0d0)) :: ma2p, maxmwa, mb2p, mbp1, mc2p, mcarry, mkt, mlmax,  &
                            mqdmwa, mqdmwd, mtemp
      double precision :: xb, xbr, xbase, xmwa, xmwd
      integer :: j, jb, jl, ka, kb, kl, kptmw, n1, ng, nguard, nl, nmbwds, nzdmb

      kflag = 0

!             nguard is the number of guard digits used.

      if (ncall > 1) then
          nguard = ngrd21
          if (nguard > ndig) nguard = ndig
      else
          nguard = ngrd52 - 1
      endif
      if (nguard > ndig+10) nguard = ndig + 10
      ma2p = abs(ma%mp(3))
      mb2p = abs(mb%mp(3))
      mc2p = abs(mc%mp(3))
      if ((mc2p >= ma2p .or. mc2p >= mb2p) .and. nguard < 2) nguard = 2
      n1 = ndig + 1
      ng = ndig + nguard

!             Copy ma and mb into the working arrays.

      do j = 3, n1
         mwa%mp(j+2) = ma%mp(j+1)
         mwd%mp(j+2) = mb%mp(j+1)
      enddo
      mwa%mp(2) = ma%mp(2) - mc%mp(2) + 1
      mwd%mp(2) = mb%mp(2) - mc%mp(2) + 1
      mwa%mp(3) = 0
      mwd%mp(3) = 0
      nl = n1 + nguard + 3
      do j = ndig+3, nl
         mwa%mp(j+1) = 0
         mwd%mp(j+1) = 0
      enddo

      mwa%mp(4) = ma%mp(3)
      mwd%mp(4) = mb%mp(3)

!             nmbwds is the number of words used to compute the estimated quotient digits.

      nmbwds = 4
      if (mbase < 100) nmbwds = 7

!             xb is an approximation of mc used in selecting estimated quotients.

      xbase = dble(mbase)
      xb = 0
      jl = nmbwds
      if (jl <= n1) then
          do j = 2, jl
             xb = xb*xbase + dble(mc%mp(j+1))
          enddo
      else
          do j = 2, jl
             if (j <= n1) then
                 xb = xb*xbase + dble(mc%mp(j+1))
             else
                 xb = xb*xbase
             endif
          enddo
      endif
      if (jl+1 <= n1) xb = xb + dble(mc%mp(jl+2))/xbase
      xbr = 1.0d0/xb

!             mlmax determines when to normalize all of mwa.

      mbp1 = mbase + 1
      mlmax = maxint/mbp1
      mkt = intmax - mbase
      mlmax = min(mlmax, mkt)

!             Count the trailing zero digits of mc.

      nzdmb = n1 - 2
      do j = n1, 2, -1
         if (mc%mp(j+1) /= 0) then
             nzdmb = n1 - j
             exit
         endif
      enddo

!             maxmwa is an upper bound on the size of values in mwa divided by mbase-1.  It is used
!             to determine whether normalization can be postponed.

      maxmwa = 0

!             kptmw points to the next digit in the quotient.

      kptmw = 2

!             This is the start of the division loop.

!             xmwa is an approximation of the active part of mwa used in selecting estimated
!             quotients.

      do while (kptmw <= ng)
         kl = kptmw + nmbwds - 1
         if (kl <= nl) then
             xmwa = ((dble(mwa%mp(kptmw+1))*xbase + dble(mwa%mp(kptmw+2)))*xbase  &
                    + dble(mwa%mp(kptmw+3)))*xbase + dble(mwa%mp(kptmw+4))
             xmwd = ((dble(mwd%mp(kptmw+1))*xbase + dble(mwd%mp(kptmw+2)))*xbase  &
                    + dble(mwd%mp(kptmw+3)))*xbase + dble(mwd%mp(kptmw+4))
             do j = kptmw+4, kl
                xmwa = xmwa*xbase + dble(mwa%mp(j+1))
                xmwd = xmwd*xbase + dble(mwd%mp(j+1))
             enddo
         else
             xmwa = dble(mwa%mp(kptmw+1))
             xmwd = dble(mwd%mp(kptmw+1))
             do j = kptmw+1, kl
                if (j <= nl) then
                    xmwa = xmwa*xbase + dble(mwa%mp(j+1))
                    xmwd = xmwd*xbase + dble(mwd%mp(j+1))
                else
                    xmwa = xmwa*xbase
                    xmwd = xmwd*xbase
                endif
             enddo
         endif

!             mqdmwa and mqdmwd are the estimated quotient digits.

         mqdmwa = aint(xmwa*xbr)
         if (mqdmwa < 0) mqdmwa = mqdmwa - 1
         mqdmwd = aint(xmwd*xbr)
         if (mqdmwd < 0) mqdmwd = mqdmwd - 1

         maxmwa = maxmwa + max(abs(mqdmwa), abs(mqdmwd))

!             See if mwa and mwd must be normalized.

         ka = kptmw + 1
         kb = min(ka+ndig-1-nzdmb, nl)
         if (maxmwa >= mlmax) then
             do j = kb, ka, -1
                if (mwa%mp(j+1) < 0) then
                    mcarry = int((-mwa%mp(j+1)-1)/mbase) + 1
                    mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
                    mwa%mp(j) = mwa%mp(j) - mcarry
                else if (mwa%mp(j+1) >= mbase) then
                    mcarry = -int(mwa%mp(j+1)/mbase)
                    mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
                    mwa%mp(j) = mwa%mp(j) - mcarry
                endif
                if (mwd%mp(j+1) < 0) then
                    mcarry = int((-mwd%mp(j+1)-1)/mbase) + 1
                    mwd%mp(j+1) = mwd%mp(j+1) + mcarry*mbase
                    mwd%mp(j) = mwd%mp(j) - mcarry
                else if (mwd%mp(j+1) >= mbase) then
                    mcarry = -int(mwd%mp(j+1)/mbase)
                    mwd%mp(j+1) = mwd%mp(j+1) + mcarry*mbase
                    mwd%mp(j) = mwd%mp(j) - mcarry
                endif
             enddo
             xmwa = 0
             xmwd = 0
             if (kl <= nl) then
                 do j = kptmw, kl
                    xmwa = xmwa*xbase + dble(mwa%mp(j+1))
                    xmwd = xmwd*xbase + dble(mwd%mp(j+1))
                 enddo
             else
                 do j = kptmw, kl
                    if (j <= nl) then
                        xmwa = xmwa*xbase + dble(mwa%mp(j+1))
                        xmwd = xmwd*xbase + dble(mwd%mp(j+1))
                    else
                        xmwa = xmwa*xbase
                        xmwd = xmwd*xbase
                    endif
                 enddo
             endif
             mqdmwa = aint(xmwa*xbr)
             if (mqdmwa < 0) mqdmwa = mqdmwa - 1
             mqdmwd = aint(xmwd*xbr)
             if (mqdmwd < 0) mqdmwd = mqdmwd - 1
             maxmwa = max(abs(mqdmwa), abs(mqdmwd))
         endif

!             Subtract mqdmwa*mc from mwa and mqdmwd*mc from mwd.

         jb = ka - 2

!             Major (Inner Loop)

         do j = ka+1, kb+1
            mtemp = mc%mp(j-jb)
            mwa%mp(j) = mwa%mp(j) - mqdmwa*mtemp
            mwd%mp(j) = mwd%mp(j) - mqdmwd*mtemp
         enddo

         mwa%mp(ka+1) = mwa%mp(ka+1) + mwa%mp(ka)*mbase
         mwd%mp(ka+1) = mwd%mp(ka+1) + mwd%mp(ka)*mbase
         mwa%mp(kptmw+1) = mqdmwa
         mwd%mp(kptmw+1) = mqdmwd

         kptmw = kptmw + 1
      enddo

      kl = kptmw + nmbwds - 1
      if (kl <= nl) then
          xmwa = ((dble(mwa%mp(kptmw+1))*xbase + dble(mwa%mp(kptmw+2)))*xbase  &
                 + dble(mwa%mp(kptmw+3)))*xbase + dble(mwa%mp(kptmw+4))
          xmwd = ((dble(mwd%mp(kptmw+1))*xbase + dble(mwd%mp(kptmw+2)))*xbase  &
                 + dble(mwd%mp(kptmw+3)))*xbase + dble(mwd%mp(kptmw+4))
          do j = kptmw+4, kl
             xmwa = xmwa*xbase + dble(mwa%mp(j+1))
             xmwd = xmwd*xbase + dble(mwd%mp(j+1))
          enddo
      else
          xmwa = dble(mwa%mp(kptmw+1))
          xmwd = dble(mwd%mp(kptmw+1))
          do j = kptmw+1, kl
             if (j <= nl) then
                 xmwa = xmwa*xbase + dble(mwa%mp(j+1))
                 xmwd = xmwd*xbase + dble(mwd%mp(j+1))
             else
                 xmwa = xmwa*xbase
                 xmwd = xmwd*xbase
             endif
          enddo
      endif
      mqdmwa = aint(xmwa*xbr)
      if (mqdmwa < 0) mqdmwa = mqdmwa - 1
      mqdmwd = aint(xmwd*xbr)
      if (mqdmwd < 0) mqdmwd = mqdmwd - 1
      mwa%mp(kptmw+1) = mqdmwa
      mwa%mp(kptmw+2) = 0
      mwa%mp(kptmw+3) = 0
      mwd%mp(kptmw+1) = mqdmwd
      mwd%mp(kptmw+2) = 0
      mwd%mp(kptmw+3) = 0

!             Final normalization.

      do j = kptmw-1, 3, -1
         if (mwa%mp(j+1) < 0) then
             mcarry = int((-mwa%mp(j+1)-1)/mbase) + 1
             mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
             mwa%mp(j) = mwa%mp(j) - mcarry
         else if (mwa%mp(j+1) >= mbase) then
             mcarry = -int(mwa%mp(j+1)/mbase)
             mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
             mwa%mp(j) = mwa%mp(j) - mcarry
         endif
         if (mwd%mp(j+1) < 0) then
             mcarry = int((-mwd%mp(j+1)-1)/mbase) + 1
             mwd%mp(j+1) = mwd%mp(j+1) + mcarry*mbase
             mwd%mp(j) = mwd%mp(j) - mcarry
         else if (mwd%mp(j+1) >= mbase) then
             mcarry = -int(mwd%mp(j+1)/mbase)
             mwd%mp(j+1) = mwd%mp(j+1) + mcarry*mbase
             mwd%mp(j) = mwd%mp(j) - mcarry
         endif
      enddo

!             Round, affix the sign, and return.

      call fmdivd3(1, ma, mb, mc, mwa, md)
      call fmdivd3(2, ma, mb, mc, mwd, me)

      if (kflag < 0) then
          namest(ncall) = 'FMDIVD'
          call fmwarn
      endif

      md%mp(1) = ma%mp(1)*mc%mp(1)
      me%mp(1) = mb%mp(1)*mc%mp(1)

      return
      end subroutine fmdivd_m1

      subroutine fmdivd_sc(ma, mb, mc, md, me, kresult)

!  Check for special cases for  md = ma / mc  and  me = mb / mc.

!  kresult = 1 is returned if a special case gives the values of md, me.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md, me
      integer :: kresult
      intent (in) :: ma, mb, mc
      intent (inout) :: md, me, kresult

      integer :: kb, kc, kovun

      if (mblogs /= mbase) call fmcons
      kresult = 0
      kc = 3100
      if (ndig >= kc .or.                                          &
          abs(ma%mp(2)) > mexpab .or. abs(mb%mp(2)) > mexpab .or.  &
          abs(mc%mp(2)) > mexpab .or. mbase*mbase <= mxbase/(4*mbase)) then
          kovun = 0
          if (ma%mp(2) == mexpov .or. ma%mp(2) == mexpun .or.  &
              mb%mp(2) == mexpov .or. mb%mp(2) == mexpun .or.  &
              mc%mp(2) == mexpov .or. mc%mp(2) == mexpun) kovun = 1
          if (ma%mp(2) == munkno .or. mb%mp(2) == munkno .or.  &
              mc%mp(2) == munkno) kovun = 2
          ncall = ncall + 1
          call fmdiv2(ma, mc, md)
          kb = kflag
          call fmdiv2(mb, mc, me)
          ncall = ncall - 1
          if (((kflag < 0 .or. kb < 0) .and. kovun == 0) .or.  &
              ((kflag == -4 .or. kb == -4) .and. kovun == 1)) then
              if (kflag == -4 .or. kb == -4) then
                  kflag = -4
              else if (kflag == -5 .or. kb == -5) then
                  kflag = -5
              else
                  kflag = min(kflag, kb)
              endif
              namest(ncall) = 'FMDIVD'
              call fmwarn
          endif
          kresult = 1
          return
      endif
      if (mc%mp(3) == 0) then
          kflag = -4
          namest(ncall) = 'FMDIVD'
          call fmwarn
          call fmunknown(md)
          call fmunknown(me)
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0 .or. mb%mp(3) == 0) then
          call fmdiv2(ma, mc, md)
          call fmdiv2(mb, mc, me)
          kresult = 1
          return
      endif

      return
      end subroutine fmdivd_sc

      subroutine fmdivfft(mb)
      use fmvals
      implicit none

!  Internal division routine ma/mb for very high precision.
!  ma has already been moved to mwa before this routine is called.
!  Fast Fourier transforms are used, and the number of digits carried is usually
!  raised slightly, because the fft needs for n to have only small prime factors.

      type(multi) :: mb
      intent (in) :: mb

      double precision :: xb
      real (kind(1.0d0)) :: mwa1
      integer :: j, k, kst, nd2, ndsave, nstack(49)
      type(multi), save :: mxy(10)

      ndsave = ndig

!             Save low precision copies of the numerator and denominator.

      ndig = 20
      call fmi2m2(1, mxy(7))
      do j = 1, size(mxy(7)%mp)-3
         mxy(7)%mp(j+2) = mwa%mp(j+3)
      enddo
      mxy(7)%mp(2) = mwa%mp(2) + mb%mp(2) - 1
      call fmequ(mb, mxy(8), ndsave, 20)
      ndig = ndsave

!             Use Newton iteration and the routine fmmpyfft, with the formula
!                 x = x + x*(1 - b*x)
!             to converge to 1/b.

      k = max(ngrd52-1, 2)
      ndig = max(ndig+k, 3)

!             Generate the first approximation.

      call fmi2m2(1, mxy(1))
      do j = 1, ndsave
         mxy(1)%mp(j+2) = mwa%mp(j+3)
      enddo
      call fmequ(mb, mxy(2), ndsave, ndig)
      mxy(1)%mp(2) = 0
      mxy(2)%mp(1) = 1
      mxy(2)%mp(2) = 0
      kst = mwa%mp(2)

!             fmadd2 will negate mxy(2) and add.

      ksub = 1
      call fmadd2(mxy(1), mxy(2), mxy(3))
      ksub = 0
      if (mxy(3)%mp(1) >= 0) then
          mwa1 = kst
      else
          mwa1 = kst - 1
      endif
      call fmm2dp2(mxy(2), xb)
      xb = 1.0d0/xb
      call fmdpm2(xb, mxy(3))

!             Initialize.

      call fmi2m2(0, mxy(4))
      call fmi2m2(0, mxy(5))
      call fmi2m2(1, mxy(6))
      call fmdig(nstack, kst)

!             Newton iteration.

      do j = 1, kst-1
         ndig = nstack(j)
         call fmmpy2(mxy(2), mxy(3), mxy(4))
         ksub = 1
         call fmadd2_r2(mxy(6), mxy(4))
         ksub = 0
         ndig = nstack(max(1, j-1))
         call fmmpy2(mxy(3), mxy(4), mxy(5))
         ndig = nstack(j)
         call fmadd2_r1(mxy(3), mxy(5))
      enddo

!             Karp's trick:
!             The standard last step would give 1/b and then a final full precision
!             multiply by a would be done.  That does 2 full mpy's at the final precision,
!             and one at next-to-last (1/2 of final) precision.

!             Instead combine the a* step into the last iteration and get
!             y = a*x   at 1/2 precision, then
!             y = y + x*(a - b*y)
!             where the x* mpy is at 1/2 precision and only b*y is at final precision.

      ndig = nstack(max(1, kst-1))
      call fmmpy2(mxy(1), mxy(3), mxy(4))
      ndig = nstack(kst)
      call fmmpy2(mxy(2), mxy(4), mxy(5))
      ksub = 1
      call fmadd2(mxy(1), mxy(5), mxy(6))
      ksub = 0
      ndig = nstack(max(1, kst-1))
      call fmmpy2(mxy(3), mxy(6), mxy(5))
      ndig = nstack(kst)
      call fmadd2(mxy(4), mxy(5), mxy(6))

      mxy(6)%mp(2) = mwa1

!             Because of rounding errors in the Newton iteration, if the quotient is very close
!             to a power of mbase the exponent of the result might be off by one.
!             Check by doing low precision multiplications.

      nd2 = ndig
      mxy(7)%mp(1) = -1
      mxy(8)%mp(1) = 1
      call fmequ(mxy(6), mxy(4), ndsave, 20)
      mxy(4)%mp(1) = 1
      ndig = 20
      call fmmpy2(mxy(8), mxy(4), mxy(5))
      call fmadd2(mxy(5), mxy(7), mxy(9))
      mxy(9)%mp(1) = 1
      mxy(4)%mp(2) = mxy(4)%mp(2) + 1
      call fmmpy2(mxy(8), mxy(4), mxy(5))
      call fmadd2(mxy(5), mxy(7), mxy(10))
      if (mxy(10)%mp(3) /= 0) mxy(10)%mp(1) = -1
      call fmadd2(mxy(10), mxy(9), mxy(5))
      if (mxy(5)%mp(1) == 1) then
          call fmeq(mxy(10), mxy(9))
          mxy(6)%mp(2) = mxy(6)%mp(2) + 1
      endif
      mxy(4)%mp(2) = mxy(4)%mp(2) - 2
      call fmmpy2(mxy(8), mxy(4), mxy(5))
      call fmadd2(mxy(5), mxy(7), mxy(10))
      if (mxy(10)%mp(3) /= 0) mxy(10)%mp(1) = -1
      call fmadd2(mxy(10), mxy(9), mxy(5))
      if (mxy(5)%mp(1) == 1) then
          mxy(6)%mp(2) = mxy(6)%mp(2) - 1
      endif
      ndig = nd2

      do j = 1, ndig+2
         mwa%mp(j) = mxy(6)%mp(j)
      enddo
      if (kflag == 1) kflag = 0
      ndig = ndsave

      return
      end subroutine fmdivfft

      subroutine fmdivi(ma, ival, mb)

!  mb = ma / ival

!  Divide fm number ma by one word integer ival.

!  This routine is faster than fmdiv when the divisor is less than mxbase (the square root of the
!  largest integer).
!  When ival is not less than mxbase, fmdiv2 is used.  In this case, if ival is known to be a
!  product of two integers less than mxbase, it is usually faster to make two calls to fmdivi
!  with half-word factors than one call with their product.

      use fmvals
      implicit none
      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb

      ncall = ncall + 1
      if (ntrace /= 0) then
          namest(ncall) = 'FMDIVI'
          call fmntr_inp1i(ma, ival)

          call fmdivi2(ma, ival, mb)

          call fmntr_out1(mb)
      else
          call fmdivi2(ma, ival, mb)
      endif
      ncall = ncall - 1

      return
      end subroutine fmdivi

      subroutine fmdivi2(ma, ival, mb)

!  Internal divide by integer routine.  mb = ma / ival

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb

      integer :: kr_retry, kresult
      logical :: retry

      call fmalloc(mb, ndig+2)
      call fmalloc(mwa, 2*ndig+30)
      call fmdivi_sc(ma, ival, mb, kresult)
      if (kresult > 0) then
          return
      endif

      if (mblogs /= mbase) call fmcons

      kr_retry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fmdivi_m1(ma, ival, mb, kr_retry, retry)
      enddo

      return
      end subroutine fmdivi2

      subroutine fmdivi2_r1(ma, ival)

!  Internal divide by integer routine.  ma = ma / ival

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ival
      intent (inout) :: ma

      integer :: kr_retry, kresult
      logical :: retry

      call fmalloc(mwa, 2*ndig+30)
      call fmdivi_r1_sc(ma, ival, kresult)
      if (kresult > 0) then
          return
      endif

      if (mblogs /= mbase) call fmcons

      kr_retry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fmdivi_r1_m1(ma, ival, kr_retry, retry)
      enddo

      return
      end subroutine fmdivi2_r1

      subroutine fmdivi_m1(ma, ival, mb, kr_retry, retry)

!  Method 1 for computing mb = ma / ival.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: ival, kr_retry
      logical :: retry
      intent (in) :: ma, ival
      intent (inout) :: mb, kr_retry, retry

      real (kind(1.0d0)) :: mkt, mlr, modint, mvalp
      double precision :: err
      integer :: ka, kb, kl, klp, kpt, kptwa, n1, nguard, nmval, nv2

      integer :: j, jrssav
      type(multi), save :: mxy

!             nguard is the number of guard digits used.

      if (ncall > 1) then
          nguard = ngrd21
      else
          nguard = ngrd52
          if (kr_retry >= 1) then
              nguard = ndig + 10
          endif
      endif
      if (nguard > ndig+10) nguard = ndig + 10
      jrssav = jrsign
      n1 = ndig + 1

!             If abs(ival) >= mxbase use fmdiv.

      mvalp = abs(ival)
      nmval = int(mvalp)
      nv2 = nmval - 1
      if (abs(ival) > mxbase .or. nmval /= abs(ival) .or. nv2 /= abs(ival)-1) then
          call fmi2m2(ival, mxy)
          call fmdiv2(ma, mxy, mb)
          jrsign = jrssav
          return
      endif

!             Find the first significant digit of the quotient.

      mkt = ma%mp(3)
      klp = 0
      kpt = 2
      if (mkt >= mvalp) then
          kpt = 2
      else
          do j = 3, n1
             mkt = mkt*mbase + ma%mp(j+1)
             if (mkt >= mvalp) then
                 kpt = j
                 klp = 1
                 exit
             endif
          enddo
          if (klp == 0) then
              kpt = n1
              do while (mkt < mvalp)
                 kpt = kpt + 1
                 mkt = mkt*mbase
              enddo
          endif
      endif

!             Do the rest of the division.

      ka = kpt + 1
      mwa%mp(2) = ma%mp(2) + 2 - kpt
      mwa%mp(3) = int (mkt/mvalp)
      modint = mkt - mwa%mp(3)*mvalp
      kptwa = 2
      if (ka <= n1) then
          kl = 3 - ka

!             (Inner Loop)

          do j = ka+1, n1+1
             mkt = modint*mbase + ma%mp(j)
             mwa%mp(j+kl) = int (mkt/mvalp)
             modint = mkt - mwa%mp(j+kl)*mvalp
          enddo
          kptwa = kl + n1
      endif

      ka = kptwa + 1
      kb = n1 + nguard
      do j = ka, kb
         mkt = modint*mbase
         mwa%mp(j+1) = int (mkt/mvalp)
         modint = mkt - mwa%mp(j+1)*mvalp
      enddo

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      if (ncall >= 1) then
          kl = min(nguard, int(3*dlogtn/dlogmb + 1.5))
          err = 0
          do j = kl, 1, -1
             err = (err + mwa%mp(j+ndig+2)) / mbase
          enddo
          if ( (kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
               (kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) kr_retry = kr_retry + 1
      endif
      if (kr_retry == 1 .and. nguard < ndig+10) then
          kr_retry = 2
          retry = .true.
          return
      endif

!             Round the result, put the sign on mb and return.

      mlr = 2*mwa%mp(ndig+3) + 1
      if ((ma%mp(1) > 0 .and. ival > 0) .or. (ma%mp(1) < 0 .and. ival < 0)) then
          jrsign = 1
      else
          jrsign = -1
      endif
      if (kround == -1 .or. kround == 2) then
          call fmrnd(mwa, ndig, nguard, 0)
      else if (mlr >= mbase) then
          if (mlr-1 > mbase .and. mwa%mp(n1+1) < mbase-1) then
              if (kround /= 0) then
                  mwa%mp(n1+1) = mwa%mp(n1+1) + 1
                  mwa%mp(n1+2) = 0
              endif
          else
              call fmrnd(mwa, ndig, nguard, 0)
          endif
      endif
      call fmmove(mwa, mb)

      if (kflag < 0) then
          namest(ncall) = 'FMDIVI'
          call fmwarn
      endif
      mb%mp(1) = jrsign
      jrsign = jrssav

      return
      end subroutine fmdivi_m1

      subroutine fmdivi_r1(ma, ival)

!  ma = ma / ival

!  Divide fm number ma by one word integer ival.

!  This routine is faster than fmdiv when the divisor is less than mxbase (the square root of the
!  largest integer).
!  When ival is not less than mxbase, fmdiv2 is used.  In this case, if ival is known to be a
!  product of two integers less than mxbase, it is usually faster to make two calls to fmdivi_r1
!  with half-word factors than one call with their product.

      use fmvals
      implicit none
      type(multi) :: ma
      integer :: ival
      intent (in) :: ival
      intent (inout) :: ma

      ncall = ncall + 1
      if (ntrace /= 0) then
          namest(ncall) = 'FMDIVI_R1'
          call fmntr_inp1i(ma, ival)

          call fmdivi2_r1(ma, ival)

          call fmntr_out1(ma)
      else
          call fmdivi2_r1(ma, ival)
      endif
      ncall = ncall - 1

      return
      end subroutine fmdivi_r1

      subroutine fmdivi_r1_m1(ma, ival, kr_retry, retry)

!  Method 1 for computing ma = ma / ival.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: ival, kr_retry
      logical :: retry
      intent (in) :: ival
      intent (inout) :: ma, kr_retry, retry

      real (kind(1.0d0)) :: mkt, mlr, modint, mvalp
      double precision :: err
      integer :: ka, kb, kl, klp, kpt, kptwa, n1, nguard, nmval, nv2

      integer :: j, jrssav
      type(multi), save :: mxy(2)

!             nguard is the number of guard digits used.

      if (ncall > 1) then
          nguard = ngrd21
      else
          nguard = ngrd52
          if (kr_retry >= 1) then
              nguard = ndig + 10
          endif
      endif
      if (nguard > ndig+10) nguard = ndig + 10
      jrssav = jrsign
      n1 = ndig + 1

!             If abs(ival) >= mxbase use fmdiv.

      mvalp = abs(ival)
      nmval = int(mvalp)
      nv2 = nmval - 1
      if (abs(ival) > mxbase .or. nmval /= abs(ival) .or. nv2 /= abs(ival)-1) then
          call fmi2m2(ival, mxy(1))
          call fmdiv2(ma, mxy(1), mxy(2))
          call fmeq(mxy(2), ma)
          jrsign = jrssav
          return
      endif

!             Find the first significant digit of the quotient.

      mkt = ma%mp(3)
      klp = 0
      kpt = 2
      if (mkt >= mvalp) then
          kpt = 2
      else
          do j = 3, n1
             mkt = mkt*mbase + ma%mp(j+1)
             if (mkt >= mvalp) then
                 kpt = j
                 klp = 1
                 exit
             endif
          enddo
          if (klp == 0) then
              kpt = n1
              do while (mkt < mvalp)
                 kpt = kpt + 1
                 mkt = mkt*mbase
              enddo
          endif
      endif

!             Do the rest of the division.

      ka = kpt + 1
      mwa%mp(2) = ma%mp(2) + 2 - kpt
      mwa%mp(3) = int (mkt/mvalp)
      modint = mkt - mwa%mp(3)*mvalp
      kptwa = 2
      if (ka <= n1) then
          kl = 3 - ka

!             (Inner Loop)

          do j = ka+1, n1+1
             mkt = modint*mbase + ma%mp(j)
             mwa%mp(j+kl) = int (mkt/mvalp)
             modint = mkt - mwa%mp(j+kl)*mvalp
          enddo
          kptwa = kl + n1
      endif

      ka = kptwa + 1
      kb = n1 + nguard
      do j = ka, kb
         mkt = modint*mbase
         mwa%mp(j+1) = int (mkt/mvalp)
         modint = mkt - mwa%mp(j+1)*mvalp
      enddo

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      if (ncall >= 1) then
          kl = min(nguard, int(3*dlogtn/dlogmb + 1.5))
          err = 0
          do j = kl, 1, -1
             err = (err + mwa%mp(j+ndig+2)) / mbase
          enddo
          if ( (kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
               (kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) kr_retry = kr_retry + 1
      endif
      if (kr_retry == 1 .and. nguard < ndig+10) then
          kr_retry = 2
          retry = .true.
          return
      endif

!             Round the result, put the sign on ma and return.

      mlr = 2*mwa%mp(ndig+3) + 1
      if ((ma%mp(1) > 0 .and. ival > 0) .or. (ma%mp(1) < 0 .and. ival < 0)) then
          jrsign = 1
      else
          jrsign = -1
      endif
      if (kround == -1 .or. kround == 2) then
          call fmrnd(mwa, ndig, nguard, 0)
      else if (mlr >= mbase) then
          if (mlr-1 > mbase .and. mwa%mp(n1+1) < mbase-1) then
              if (kround /= 0) then
                  mwa%mp(n1+1) = mwa%mp(n1+1) + 1
                  mwa%mp(n1+2) = 0
              endif
          else
              call fmrnd(mwa, ndig, nguard, 0)
          endif
      endif
      call fmmove(mwa, ma)

      if (kflag < 0) then
          namest(ncall) = 'FMDIVI_R1'
          call fmwarn
      endif
      ma%mp(1) = jrsign
      jrsign = jrssav

      return
      end subroutine fmdivi_r1_m1

      subroutine fmdivi_r1_sc(ma, ival, kresult)

!  Check for special cases for ma = ma / ival.

!  kresult = 1 is returned if a special case gives the value of ma.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: ival, kresult
      intent (in) :: ival
      intent (inout) :: ma, kresult

      integer :: kovun
      type(multi), save :: mxy(2)

      kresult = 0
      if ((ma%mp(2) == munkno .and. ma%mp(5) >= 0) .or. ival == 0) then
          call fmunknown(ma)
          kflag = -4
          kresult = 1
          return
      endif

      if (abs(ma%mp(2)) >= mexpov) then
          kovun = 0
          if (ma%mp(2) == munkno) kovun = 2
          call fmi2m(ival, mxy(1))
          call fmovun_div(ma, mxy(1), mxy(2))
          call fmeq(mxy(2), ma)
          if (kovun /= 2 .and. ma%mp(2) == munkno) then
              namest(ncall) = 'FMDIVI_R1'
              call fmwarn
          endif
          kresult = 1
          return
      endif

      if (ma%mp(3) == 0) then
          kresult = 1
          return
      endif

      if (abs(ival) == 1) then
          ma%mp(1) = ma%mp(1)*ival
          if (ma%mp(2) == mexpov) kflag = -5
          if (ma%mp(2) == mexpun) kflag = -6
          kresult = 1
          return
      endif

      return
      end subroutine fmdivi_r1_sc

      subroutine fmdivi_sc(ma, ival, mb, kresult)

!  Check for special cases for mb = ma / ival.

!  kresult = 1 is returned if a special case gives the value of mb.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: ival, kresult
      intent (in) :: ma, ival
      intent (inout) :: mb, kresult

      integer :: j
      type(multi), save :: mxy

      kresult = 0
      if ((ma%mp(2) == munkno .and. ma%mp(5) >= 0) .or. ival == 0) then
          call fmunknown(mb)
          kflag = -4
          kresult = 1
          return
      endif

      if (abs(ma%mp(2)) >= mexpov) then
          call fmi2m(ival, mxy)
          call fmovun_div(ma, mxy, mb)
          if (ma%mp(2) /= munkno .and. mb%mp(2) == munkno) then
              namest(ncall) = 'FMDIVI'
              call fmwarn
          endif
          kresult = 1
          return
      endif

      if (ma%mp(3) == 0) then
          call fmeq(ma, mb)
          kresult = 1
          return
      endif

      if (abs(ival) == 1) then
          do j = 1, ndig+2
             mb%mp(j) = ma%mp(j)
          enddo
          mb%mp(1) = ma%mp(1)*ival
          if (ma%mp(2) == mexpov) kflag = -5
          if (ma%mp(2) == mexpun) kflag = -6
          kresult = 1
          return
      endif

      return
      end subroutine fmdivi_sc

      subroutine fmdp2m(x, ma)

!  ma = x

!  Convert a double precision floating point number to FM format.

!  This version tries to convert the double precision machine number to FM with accuracy of nearly
!  full FM precision. If conversion to FM with approximately double precision accuracy is good
!  enough, fmdpm is faster and uses less scratch space.

!  This routine assumes the machine's base for double precision is a power of two.

      use fmvals
      implicit none

      double precision :: x
      type(multi) :: ma
      intent (in) :: x
      intent (inout) :: ma

      ncall = ncall + 1
      namest(ncall) = 'FMDP2M'
      if (ntrace /= 0) call fmntr_inpd(x)

      call fmdp2m2(x, ma)

      if (ntrace /= 0) call fmntr_out1(ma)
      ncall = ncall - 1

      return
      end subroutine fmdp2m

      subroutine fmdp2m2(x, ma)

!  Internal routine for converting double precision to multiple precision.

      use fmvals
      implicit none

      double precision :: x
      type(multi) :: ma
      intent (in) :: x
      intent (inout) :: ma

      double precision :: y, z
      integer :: j, k, kd, km, nb, ne, ndsave
      type(multi), save :: mxy

      call fmalloc(ma, ndig+2)

!             Increase the working precision.

      ndsave = ndig
      if (ncall == 1) then
          k = max(ngrd21, 1)
          ndig = max(ndig+k, 3)
      endif

      if (mblogs /= mbase) call fmcons
      kflag = 0

!             Special case for x = 0.

      if (x == 0.0d0) then
          do j = 2, ndsave+2
             ma%mp(j) = 0
          enddo
          ma%mp(1) = 1
          ndig = ndsave
          return
      endif

!             Check for x = + or - Infinity, or Nan.  Return unknown if so.

      if (x > huge(x) .or. x < -huge(x) .or. (.not.(x == x))) then
          do j = 4, ndsave+2
             ma%mp(j) = 0
          enddo
          kflag = -4
          ma%mp(1) = 1
          ma%mp(2) = munkno
          ma%mp(3) = 1
          call fmwarn
          ndig = ndsave
          return
      endif

!             Special case for mbase = 2.

      if (mbase == 2 .and. radix(x) == 2) then
          ndig = max(ndig, digits(x))
          y = fraction(abs(x))
          call fmi2m(0, mxy)
          do j = 1, min(digits(x), ndig)
             y = y + y
             mxy%mp(j+2) = int(y)
             y = y - int(y)
          enddo
          mxy%mp(2) = exponent(x)
          call fmequ(mxy, ma, ndig, ndsave)
          ma%mp(1) = 1
          if (x < 0.0 .and. ma%mp(2) /= munkno .and. ma%mp(3) /= 0) then
              ma%mp(1) = -1
          endif
          ndig = ndsave
          return
      endif

!             General case.

      z = fraction(abs(x))
      nb = digits(x)
      y = z * 2.0d0**nb
      ne = nint( log(abs(x)/y) / log(2.0d0))
      kd = int( log(y) / log(mbase) ) + 1
      call fmi2m(0, mxy)
      mxy%mp(1) = 1
      mxy%mp(2) = kd

      do j = kd+2, 3, -1
         mxy%mp(j) = mod(y, mbase)
         y = aint(y/mbase)
      enddo

      km = 2
      do j = 1, abs(ne)
         if (ne > 0) then
             if (km >= (maxint/2)/mbase .or. km >= intmax/2) then
                 call fmmpyi_r1(mxy, km)
                 km = 2
             else
                 km = km * 2
             endif
         else if (ne < 0) then
             if (km >= mxbase/2) then
                 call fmdivi2_r1(mxy, km)
                 km = 2
             else
                 km = km * 2
             endif
         endif
      enddo

      km = km / 2
      if (km > 1) then
          if (ne > 0) then
              call fmmpyi_r1(mxy, km)
          else
              call fmdivi2_r1(mxy, km)
          endif
      endif

      if (x < 0) mxy%mp(1) = -1

      call fmequ(mxy, ma, ndig, ndsave)

      ma%mp(1) = 1
      if (x < 0.0 .and. ma%mp(2) /= munkno .and. ma%mp(3) /= 0) ma%mp(1) = -1
      ndig = ndsave

      return
      end subroutine fmdp2m2

      function fmdplg(a)

!  Internal routine for computing an approximation to log(gamma(a)) using Stirling's formula.

      use fmvals
      implicit none

      double precision :: fmdplg, a
      intent (in) :: a

      if (mblogs /= mbase) call fmcons
      if (a > 0.0d0) then
          fmdplg = -a + (a-0.5d0)*log(a) + dlogtp/2.0d0
      else if (a < 0.0d0) then
          if (abs(a) < 1.0d+8 .and. abs(a) > 1) then
              fmdplg = -(a-1.0d0) - (0.5d0-a)*log(1.0d0-a) - dlogtp/2.0d0 -  &
                       log(abs(sin(dppi*a))+1.0d-10) + dlogpi
          else
              fmdplg = -(a-1.0d0) - (0.5d0-a)*log(1.0d0-a) - dlogtp/2.0d0 + dlogpi
          endif
      else

!             a = 0 is really an approximation for some value in [-1,1].

          fmdplg = 0.0d0
      endif

      return
      end function fmdplg

      subroutine fmdpm(x, ma)

!  ma = x

!  Convert a double precision floating point number to FM format.

!  In general, the relative accuracy of the FM number returned is only the relative accuracy of a
!  machine precision number.  This may be true even if x can be represented exactly in the machine
!  floating point number system.

!  This version is faster than fmdp2m, but often less accurate.

      use fmvals
      implicit none

      double precision :: x
      type(multi) :: ma
      intent (in) :: x
      intent (inout) :: ma

      integer :: k
      double precision :: y, yt

      ncall = ncall + 1
      namest(ncall) = 'FMDPM'
      if (ntrace /= 0) call fmntr_inpd(x)

!             Check to see if x is exactly a small integer.  If so, converting as an integer is
!             better.  Also see if x is exactly a small integer divided by a small power of two.

      y = 1048576.0d0
      if (abs(x) < y) then
          k = int(x)
          y = k
          if (y == x) then
              call fmi2m2(k, ma)
              if (ntrace /= 0) call fmntr_out1(ma)
              ncall = ncall - 1
              return
          endif
      endif
      if (abs(x) < 1.0d0) then
          y = 4096.0d0*x
          k = int(y)
          yt = k
          if (y == yt) then
              call fmi2m2(k, ma)
              call fmdivi_r1(ma, 4096)
              if (ntrace /= 0) call fmntr_out1(ma)
              ncall = ncall - 1
              return
          endif
      endif

      call fmdpm2(x, ma)

      if (ntrace /= 0) call fmntr_out1(ma)
      ncall = ncall - 1

      return
      end subroutine fmdpm

      subroutine fmdpm2(x, ma)

!  Internal routine for converting double precision to multiple precision.

      use fmvals
      implicit none

      double precision :: x
      type(multi) :: ma
      intent (in) :: x
      intent (inout) :: ma

      double precision :: one, xbase, y, y2, yt
      real (kind(1.0d0)) :: mk, mn
      integer :: j, k, ks, n1, n2, ne

      call fmalloc(ma, ndig+2)

      if (mblogs /= mbase) call fmcons
      kflag = 0
      n1 = ndig + 1
      n2 = ndig + 2

!             Check for x = + or - Infinity, or Nan.  Return unknown if so.

      if (x > huge(x) .or. x < -huge(x) .or. (.not.(x == x))) then
          do j = 4, n2
             ma%mp(j) = 0
          enddo
          kflag = -4
          ma%mp(1) = 1
          ma%mp(2) = munkno
          ma%mp(3) = 1
          call fmwarn
          return
      endif

      one = 1.0d0
      xbase = mbase
      k = 0

!             ne-1 is the number of words at the current precision and base roughly equal to
!             machine precision.

      ne = int(dlogeb) + 3
      y = x
      if (x < 0.0) y = -x

      if (x == 0.0) then
          do j = 2, n2
             ma%mp(j) = 0
          enddo
          ma%mp(1) = 1
          if (x < 0.0 .and. ma%mp(2) /= munkno .and. ma%mp(3) /= 0) then
              ma%mp(1) = -1
          endif
          return
      endif

!             Get the exponent.

      if (y > one) then
          if (y/xbase < y) then
              do while (y > one)
                 k = k + 1
                 y = y/xbase
              enddo
              if (y < one) then
                  ma%mp(2) = k
              endif
          else
              kflag = -4
              call fmwarn
              do j = 4, n2
                 ma%mp(j) = 0
              enddo
              ma%mp(1) = 1
              ma%mp(2) = munkno
              ma%mp(3) = 1
              return
          endif
      else if (y < one) then
          if (y*xbase > y) then
              do while (y < one)
                 k = k - 1
                 y = y*xbase
              enddo
              if (y > one) then
                  k = k + 1
                  y = y/xbase
                  ma%mp(2) = k
              endif
          else
              kflag = -4
              call fmwarn
              do j = 4, n2
                 ma%mp(j) = 0
              enddo
              ma%mp(1) = 1
              ma%mp(2) = munkno
              ma%mp(3) = 1
              return
          endif
      endif

      if (y == 1) then
          do j = 4, n2
             ma%mp(j) = 0
          enddo
          ma%mp(1) = 1
          ma%mp(2) = k + 1
          ma%mp(3) = 1
          if (x < 0.0 .and. ma%mp(2) /= munkno .and. ma%mp(3) /= 0) then
              ma%mp(1) = -1
          endif
          return
      endif

!             Build the rest of the number.

      ks = 1
      do j = 2, ne
         y = y*xbase
         mk = aint(y)
         yt = -mk
         call fmdbl(y, yt, y2)
         y = y2
         ma%mp(j+1) = mk
         if (j >= n1) then
             ks = 0
             exit
         endif
      enddo
      if (ks == 1) then
          k = ne + 1
          do j = k+1, n2
             ma%mp(j) = 0
          enddo
      endif

!             Normalize.

      if (abs(ma%mp(3)) >= mbase) then
          do j = n1, 3, -1
             ma%mp(j+1) = ma%mp(j)
          enddo
          mn = aint (ma%mp(3)/mbase)
          ma%mp(4) = ma%mp(3) - mn*mbase
          ma%mp(3) = mn
          ma%mp(2) = ma%mp(2) + 1
      else if (ma%mp(3) == 0) then
          do j = 2, ndig
             ma%mp(j+1) = ma%mp(j+2)
          enddo
          ma%mp(2) = ma%mp(2) - 1
          ma%mp(n2) = 0
      endif

      ma%mp(1) = 1
      if (x < 0.0 .and. ma%mp(2) /= munkno .and. ma%mp(3) /= 0) ma%mp(1) = -1

      return
      end subroutine fmdpm2

      subroutine fmei(ma, mb)

!  mb = exponential integral(ma)

!  Integral from -infinity to ma of e**t / t  dt.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(17), mresult, mretry

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmei_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      n_acc = nint(ndig*alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmei_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmei

      subroutine fmei_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc)

!  Method selection for computing ln(gamma(ma)).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(17), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc

      double precision :: x, y
      integer :: iextra, kflagx, nmethd

      retry = .true.

      n_acc = nint(ndig*alogm2)
      call fmequ(ma, mxy(1), ndsave, ndig)

!             x is a double precision approximation to the input argument to this function.

      call fmm2dp(mxy(1), x)
      kflagx = kflag
      if (kflag /= 0 .and. mxy(1)%mp(2) < 0) then
          x = (10.0d0*dlogmb)/dpmax
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif

!             If ma is large in magnitude, use more guard digits.

      iextra = min(max(int(mxy(1)%mp(2)), 0), int(2.0+alogmx/alogmb))
      if (mxy(1)%mp(2) >= mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(1), ndig, ndig+iextra)
      endif
      ndig = ndig + iextra
      n_acc = nint(ndig*alogm2)

!             Check for special cases.

      if (mxy(1)%mp(3) == 0 .or. mxy(1)%mp(2) == mexpun) then
          call fmunknown(mresult)
          kflag = -4
          retry = .false.
          return
      else if (mxy(1)%mp(2) > ndig) then
          call fmexp(mxy(1), mxy(2))
          call fmdiv(mxy(2), mxy(1), mresult)
          retry = .false.
          return
      endif

!             Determine which method to use.

!             nmethd = 1 means use the convergent series,
!                    = 2 means use the asymptotic series,
!                    = 3 means use the continued fraction expansion.

      nmethd = 1
      if (kflagx /= 0) then
          if (mxy(1)%mp(2) <= 0) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          y = (ndig+3)*dlogmb
          if (abs(x) > y+(dlogtp+log(y))/2.0d0) nmethd = 2
          if (x < 0.0d0 .and. nmethd == 1) then
              if (x <= -14.3d0-0.275d0*y) nmethd = 3
          endif
      endif

      if (nmethd == 1) then
          call fmei_m1(mxy, mresult, numtry, kflagx, n_acc, x)
      else if (nmethd == 2) then
          call fmei_m2(mxy, mresult, ndsave, numtry, kflagx, n_acc, x)
      else if (nmethd == 3) then
          call fmei_m3(mxy, mresult, n_acc)
      endif

      return
      end subroutine fmei_m

      subroutine fmei_m1(mxy, mresult, numtry, kflagx, n_acc, x)

!  Method 1 for computing ln(gamma(ma)).

      use fmvals
      implicit none

      type(multi) :: mxy(17), mresult
      integer :: numtry, kflagx, n_acc
      double precision :: x
      intent (in) :: numtry, kflagx, x
      intent (inout) :: mxy, mresult, n_acc

      integer :: iextra, j, j2, k, kl, ndsav1, nterm
      double precision :: xe
      type(multi), save :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 1.  Use the x**n/(n*n!) series.

      iextra = min(max(int(mxy(1)%mp(2)), 0), int(2.0+alogmx/alogmb))
      if (kflagx == 0) then
          if (x < 0) then
              iextra = int(2.0d0*abs(x)/dlogmb)
          else if (numtry <= 0 .and. ncall <= 1) then
              ndig = ndig - iextra - 1
              iextra = 0
          else if (numtry <= 0 .and. ncall > 1) then
              ndig = ndig - iextra
              iextra = 0
          endif
      endif
      if (iextra > 0) then
          call fmequ_r1(mxy(1), ndig, ndig+iextra)
      endif
      ndig = ndig + iextra
      n_acc = nint(ndig*alogm2)

      if (kflagx == 0) then
          j2 = int(0.63*sqrt(fmnterms(abs(x), 1, 0, 0, 1)) - 1.4)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = ndig

!             Split into j2 concurrent sums.

      call fmi2m(1, mxy(6))
      call fmeq(mxy(6), mjsums(1))
      nterm = 1
      do j = 2, j2
         nterm = nterm + 1
         call fmcsdivi_r1(mxy(6), nterm)
         call fmcsdivi(mxy(6), nterm, mjsums(j))
      enddo

      call fmovun_xe(mxy(1), xe)
      if (xe < -ndig) then
          kl = 0
      else
          kl = 1
          call fmipwr(mxy(1), j2, mxy(5))
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(6), mxy(5))
         do j = 1, j2
            nterm = nterm + 1
            call fmcsdivi_r1(mxy(6), nterm)
            call fmcsdivi(mxy(6), nterm, mxy(4))
            ndig = ndsav1
            call fmcsaddnn_r1(mjsums(j), mxy(4))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            ndig = ndsav1 - int(mjsums(j)%mp(2)-mxy(4)%mp(2))
            ndig = min(ndsav1, ndig)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         enddo
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call fmcsnsums(j2, mjsums)
      call fmi2m(0, mxy(16))
      call fmi2m(0, mxy(17))
      call fmeq(mxy(1), mxy(12))
      do j = 1, j2
         call fmmpy(mxy(12), mjsums(j), mxy(3))
         if (mxy(3)%mp(1) > 0) then
             call fmadd_r1(mxy(16), mxy(3))
         else
             call fmadd_r1(mxy(17), mxy(3))
         endif
         call fmmpy_r1(mxy(12), mxy(1))
      enddo
      call fmeulr(mxy(3))
      call fmadd_r1(mxy(16), mxy(3))
      call fmabs(mxy(1), mxy(2))
      call fmln(mxy(2), mxy(11))
      if (mxy(11)%mp(1) > 0) then
          call fmadd_r1(mxy(16), mxy(11))
      else
          call fmadd_r1(mxy(17), mxy(11))
      endif
      call fmadd(mxy(16), mxy(17), mxy(10))
      call fmcancel(mxy(16), mxy(17), mjsums(1), k)
      n_acc = n_acc - k

      call fmeq(mxy(10), mresult)

      return
      end subroutine fmei_m1

      subroutine fmei_m2(mxy, mresult, ndsave, numtry, kflagx, n_acc, x)

!  Method 2 for computing ln(gamma(ma)).

      use fmvals
      implicit none

      type(multi) :: mxy(17), mresult
      integer :: ndsave, numtry, kflagx, n_acc
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult, n_acc

      integer :: j, j2, jterms, kl, ndsav1, nterm, nterms
      type(multi), save :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 2.  Use the n!/x**n series.

      nterms = int(intmax/10)
      if (kflagx == 0) then
          j2 = int(0.38*sqrt(fmnterms(abs(x), 1, 0, 0, 0)) + 0.6)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      if (kflagx == 0) then
          if (x > 0 .and. numtry <= 0 .and. ncall <= 1) then
              ndig = max(ndsave+ngrd52, ndig-2)
          endif
      endif
      n_acc = nint(ndig*alogm2)
      ndsav1 = ndig

!             Split into j2 concurrent sums.

      call fmi2m(1, mxy(6))
      call fmdiv(mxy(6), mxy(1), mxy(15))
      call fmeq(mxy(6), mjsums(1))
      nterm = 1
      do j = 2, j2
         if (nterm >= 2) call fmcsmpyi_r1(mxy(6), nterm)
         call fmeq(mxy(6), mjsums(j))
         nterm = nterm + 1
      enddo
      if (mxy(15)%mp(2)+mxy(6)%mp(2) >= -ndig-3) then
          call fmipwr(mxy(15), j2, mxy(5))
          kl = 1

          do jterms = 1, nterms
             call fmcsmpy_r1(mxy(6), mxy(5))
             do j = 1, j2
                call fmcsmpyi_r1(mxy(6), nterm)
                ndig = ndsav1
                call fmcsaddnn_r1(mjsums(j), mxy(6))
                if (kflag /= 0) then
                    kl = 0
                    exit
                endif
                ndig = ndsav1 - int(mjsums(j)%mp(2)-mxy(6)%mp(2))
                ndig = min(ndsav1, ndig)
                if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                nterm = nterm + 1
             enddo
             if (kl == 0) exit
             if (jterms == nterms) then
                 call fmunknown(mresult)
                 return
             endif
          enddo
      endif

!             Put the j2 separate sums back together.

      kflag = 0
      call fmcsnsums(j2, mjsums)
      call fmeq(mjsums(j2), mxy(5))
      do j = 2, j2
         call fmcsmpy_r1(mxy(5), mxy(15))
         call fmadd_r1(mxy(5), mjsums(j2-j+1))
      enddo
      call fmmpy(mxy(15), mxy(5), mxy(13))
      call fmexp(mxy(1), mxy(11))
      if (mxy(11)%mp(2) == mexpov .and. mxy(1)%mp(1) > 0) then
          call fmeq(mxy(11), mresult)
          return
      else
          call fmmpy(mxy(11), mxy(13), mxy(10))
      endif

      ndig = ndsav1

      call fmeq(mxy(10), mresult)

      return
      end subroutine fmei_m2

      subroutine fmei_m3(mxy, mresult, n_acc)

!  Method 3 for computing ln(gamma(ma)).

      use fmvals
      implicit none

      type(multi) :: mxy(17), mresult
      integer :: n_acc
      intent (inout) :: mxy, mresult, n_acc

      integer :: j, jextra, kflag1, ndsav1, ndsav2, nterms

!             Method 3.  Use the continued fraction expansion.

!             mxy(14) is the current approximation.
!             mxy(10) is the term in the sum, s(k).
!             mxy(8), mxy(9) are the latest denominators, q(k-1) and q(k).


      nterms = int(intmax/10)
      ndsav1 = ndig
      jextra = max(1, int(5.76/alogmb + 1.0))
      if (ndig+jextra > ndsav1) then
          call fmequ_r1(mxy(1), ndsav1, ndsav1+jextra)
      endif
      ndig = ndig + jextra
      n_acc = nint(ndig*alogm2)
      call fmeq(mxy(1), mxy(13))
      call fmnegate(mxy(13))
      call fmi2m(1, mxy(8))
      call fmequ(mxy(13), mxy(9), ndsav1, ndig)
      call fmi2m(1, mxy(2))
      call fmdiv(mxy(2), mxy(13), mxy(10))
      call fmeq(mxy(10), mxy(14))

!             Method 3 continued fraction loop.

      ndsav2 = ndig
      do j = 1, nterms
         call fmcsmpyi(mxy(8), j, mxy(6))
         call fmeq(mxy(9), mxy(7))
         call fmcsadd_r1(mxy(7), mxy(6))
         call fmcsmpy_r1(mxy(10), mxy(6))
         call fmcsdiv(mxy(10), mxy(7), mxy(11))
         call fmeq(mxy(11), mxy(10))
         call fmnegate(mxy(10))
         ndig = ndsav2
         call fmcsadd_r1(mxy(14), mxy(10))
         kflag1 = kflag
         call fmeq(mxy(9), mxy(8))
         call fmeq(mxy(7), mxy(9))
         ndig = min(ndsav2, max(ngrd22, ndsav2-int(mxy(14)%mp(2)-mxy(10)%mp(2))))
         if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         call fmcsmpyi(mxy(8), j, mxy(6))
         call fmeq(mxy(9), mxy(3))
         call fmcsmpy_r1(mxy(3), mxy(13))
         call fmeq(mxy(3), mxy(7))
         call fmcsadd_r1(mxy(7), mxy(6))
         call fmcsmpy_r1(mxy(10), mxy(6))
         call fmcsdiv(mxy(10), mxy(7), mxy(11))
         call fmeq(mxy(11), mxy(10))
         call fmnegate(mxy(10))
         ndig = ndsav2
         call fmcsadd_r1(mxy(14), mxy(10))

!             Check for convergence.

         if (kflag1 == 1 .and. kflag == 1) then
             exit
         endif
         call fmeq(mxy(9), mxy(8))
         call fmeq(mxy(7), mxy(9))
         ndig = min(ndsav2, max(ngrd22, ndsav2-int(mxy(14)%mp(2)-mxy(10)%mp(2))))
         if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         if (j == nterms) then
             call fmunknown(mresult)
             return
         endif
      enddo

      call fmequ_r1(mxy(14), ndig, ndsav1)
      ndig = ndsav1
      call fmexp(mxy(1), mxy(15))
      call fmmpy(mxy(14), mxy(15), mxy(10))
      call fmnegate(mxy(10))

      call fmeq(mxy(10), mresult)

      return
      end subroutine fmei_m3

      subroutine fmei_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = ln(gamma(ma)).

!  kresult = 1 is returned if a special case gives the value of ln(gamma(ma)).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(17), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j, k
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMEI     '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif
      if (abs(malocal%mp(2)) >= mexpov) then
          k = 0
          j = ntrace
          ntrace = 0
          if (malocal%mp(5) < 0) then
              if (malocal%mp(4) < 0) then
                  call fmabs(malocal, mxy(1))
                  call fmln(mxy(1), mxy(2))
                  call fmeulr(mxy(3))
                  call fmadd_r2(mxy(2), mxy(3))
                  call fmadd_r2(malocal, mxy(3))
                  call fmsqr(malocal, mxy(2))
                  call fmdivi_r1(mxy(2), 4)
                  call fmadd_r2(mxy(2), mxy(3))
                  if (kflag == 1) k = 1
              else
                  call fmi2m(1, mxy(1))
                  call fmdiv(mxy(1), malocal, mxy(2))
                  call fmsqr(mxy(2), mxy(3))
                  call fmadd_r2(mxy(2), mxy(3))
                  if (kflag == 1) k = 1
                  call fmexp(malocal, mxy(1))
                  if (malocal%mp(4) == mxy(1)%mp(4)) then
                      k = 1
                      call fmeq(malocal, mxy(3))
                  else
                      call fmmpy_r2(mxy(1), mxy(3))
                  endif
              endif
          endif
          ntrace = j
          if (k == 1) then
              call fmeq(mxy(3), mresult)
              kresult = 1
              return
          endif
      endif

      return
      end subroutine fmei_sc

      subroutine fmen(ival, ma, mb)

!  mb = exponential integral(ival,ma)

!  Integral from 1 to infinity of e**(-ma*t) / t**ival  dt.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ival, ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(14), mresult, mretry

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmen_sc(ival, ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      n_acc = nint(ndig*alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmen_m(ival, ma, mxy, mresult, ndsave, numtry, n_acc)
         call fmcheck_accuracy(mresult, ndsave, retry)
         if (.not. retry) then
             call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmen

      subroutine fmen_m(ival, ma, mxy, mresult, ndsave, numtry, n_acc)

!  Method selection for computing exponential integral(ival,ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(14), mresult
      integer :: ival, ndsave, numtry, n_acc
      intent (in) :: ival, ma, ndsave, numtry
      intent (inout) :: mxy, mresult, n_acc

      double precision :: d, x, xe
      integer :: k, kflagx, nmethd
      logical, external :: fmcomp

      n_acc = nint(ndig*alogm2)
      call fmequ(ma, mxy(1), ndsave, ndig)

!             Special cases.

      if (ival > 0 .and. (mxy(1)%mp(1) < 0 .or. mxy(1)%mp(3) == 0)) then
          if (ival > 1 .and. mxy(1)%mp(3) == 0) then
              call fmi2m(1, mxy(2))
              call fmdivi(mxy(2), ival-1, mresult)
          else
              call fmunknown(mresult)
          endif
          return
      endif
      if (ival <= 0 .and. mxy(1)%mp(3) == 0) then
          call fmunknown(mresult)
          return
      endif
      if (mxy(1)%mp(2) == mexpov) then
          if (huge(mbase)/mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          if (mxy(1)%mp(1) < 0) then
              call fmoverflow(-1, mxy(12))
              mxy(12)%mp(4) = huge(mbase)/d
              mxy(12)%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
              kflag = -5
          else
              call fmunderflow(1, mxy(12))
              mxy(12)%mp(4) = -huge(mbase)/d
              mxy(12)%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
              kflag = -6
          endif
          call fmeq(mxy(12), mresult)
          return
      endif
      call fmovun_xe(mxy(1), xe)
      if (ival == 0) then
          call fmi2m(-1000, mxy(3))
          if (fmcomp(mxy(1), '>=', mxy(3))) then
              call fmeq(mxy(1), mxy(3))
              call fmnegate(mxy(3))
              call fmexp(mxy(3), mxy(4))
              call fmdiv(mxy(4), mxy(1), mresult)
          else
              call fmeq(mxy(1), mxy(3))
              call fmnegate(mxy(3))
              call fmln(mxy(3), mxy(4))
              call fmsub(mxy(3), mxy(4), mxy(5))
              call fmexp(mxy(5), mresult)
              call fmnegate(mresult)
          endif
          return
      else if (ival == 1 .and. xe < -ndsave) then
          call fmeulr(mxy(11))
          call fmln(mxy(1), mxy(10))
          call fmadd(mxy(10), mxy(11), mxy(4))
          call fmsub(mxy(1), mxy(4), mresult)
          return
      else if (ival == 2 .and. (xe < -ndsave .or. mxy(1)%mp(3) == 0)) then
          if (xe < -ndsave*2 .or. mxy(1)%mp(3) == 0) then
              call fmi2m(1, mresult)
          else
              call fmeulr(mxy(11))
              call fmln(mxy(1), mxy(10))
              call fmadd(mxy(10), mxy(11), mxy(4))
              call fmi2m(1, mxy(3))
              call fmsub(mxy(4), mxy(3), mxy(2))
              call fmmpy(mxy(2), mxy(1), mxy(5))
              call fmadd(mxy(3), mxy(5), mresult)
          endif
          return
      else if (ival > 2 .and. (xe < -ndsave .or. mxy(1)%mp(3) == 0)) then
          call fmi2m(1, mxy(3))
          call fmdivi(mxy(3), ival-1, mxy(4))
          call fmdivi(mxy(1), ival-2, mxy(5))
          call fmsub(mxy(4), mxy(5), mresult)
          return
      endif

!             Determine which method to use.

!             nmethd = 1 use the convergent series,
!                    = 2 use the continued fraction expansion,
!                    = 3 for small positive ival use a recurrence involving exponentialei,
!                    = 4 for small negative ival use a recurrence involving exp,
!                    = 5 use incomplete gamma.

      call fmm2dp(mxy(1), x)
      kflagx = kflag
      call fmovun_xe(mxy(1), xe)
      if (kflag /= 0 .and. xe < 0) then
          x = (10.0d0*dlogmb)/dpmax
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif
      if (kflag /= 0 .and. xe > 0) then
          x = dpmax
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif
      nmethd = 5
      k = 0
      if (ival == 1 .and. abs(x) >= 1) k = 10
      if (ival > 0) then
          if (abs(x) < (ndig*alogmb)/(5.5 + 0.00095*ival) + k +                                  &
              (ndig*alogmb)**2 * 1.0e-4 * (4.22 + log(real(ival)))/(24 + log(real(ival))) .and.  &
              abs(xe) < mexpov .and. mxy(1)%mp(3) /= 0) then
              nmethd = 1
          else if (ival < max(2, int((ndig+3)*alogmb/32)) .and.  &
                   abs(x) > (ndig+5)*alogmb + log(6.2832*(ndig+5)*alogmb)/2) then
              nmethd = 3
          else
              nmethd = 2
          endif
      else if (ival < 0 .and. ival >= -10 .and. abs(x) > 1 .and.  &
               abs(xe) < mexpov .and. mxy(1)%mp(3) /= 0) then
          nmethd = 2
      else if (ival < 0 .and. ival >= -10 .and. abs(x) <= 1 .and.  &
               abs(xe) < mexpov .and. mxy(1)%mp(3) /= 0) then
          nmethd = 4
      else if (ival < 0 .and. ival > -500 .and.  &
               abs(xe) < mexpov .and. mxy(1)%mp(3) /= 0) then
          nmethd = 4
      endif
      if (ival == 1 .and. k == 10 .and. nmethd == 1) nmethd = 3
      if (mxy(1)%mp(2) == mexpov) nmethd = 3

      if (nmethd == 1) then
          call fmen_m1(mxy, ival, mresult, numtry, kflagx, x)
      else if (nmethd == 2) then
          call fmen_m2(mxy, ival, ndsave, mresult, numtry, kflagx, x)
      else if (nmethd == 3) then
          call fmen_m3(mxy, ival, mresult, n_acc, kflagx, x)
      else if (nmethd == 4) then
          call fmen_m4(mxy, ival, mresult)
      else if (nmethd == 5) then
          call fmen_m5(mxy, ival, mresult)
      endif

      return
      end subroutine fmen_m

      subroutine fmen_m1(mxy, ival, mresult, numtry, kflagx, x)

!  Method 1 for computing exponential integral(ival,ma).

      use fmvals
      implicit none

      type(multi) :: mxy(14), mresult
      integer :: ival, numtry, kflagx
      double precision :: x
      intent (in) :: ival, numtry, kflagx, x
      intent (inout) :: mxy, mresult

      double precision :: xe
      integer :: iextra, j, j2, jterm, k, kl, ndsav1, nterm
      type(multi), save :: mjsums(ljsums)
      type(multi), save :: m_euler_harmonic
      integer, save :: ival_e_h = 0, ndig_e_h = 0
      real (kind(1.0d0)), save :: mbs_e_h = 0
      double precision, external :: fmnterms

!             Method 1.  Use the (-x)**n/((n-ival+1)*n!) series.

      iextra = 0
      if (kflagx == 0) then
          if (x > 0) then
              iextra = int(2.0d0*abs(x)/dlogmb)
          else if (numtry <= 0) then
              ndig = ndig - iextra - 1
              iextra = 0
          endif
      endif
      if (iextra > 0) then
          call fmequ_r1(mxy(1), ndig, ndig+iextra)
      endif
      ndig = ndig + iextra

      if (kflagx == 0) then
          j2 = int(0.68*sqrt(fmnterms(abs(x), 1, 0, 0, 1)) + 0.7)
          j2 = max(1, min(ljsums, j2))
      else
          j2 = 1
      endif
      ndsav1 = ndig

!             Split into j2 concurrent sums.

      call fmi2m(1, mxy(6))
      jterm = 0
      nterm = ival - 1
      do j = 1, j2
         if (j > 2) call fmcsdivi_r1(mxy(6), jterm)
         if (nterm /= 0) then
             call fmcsdivi(mxy(6), nterm, mjsums(j))
         else
             if (ival == ival_e_h .and. ndig <= ndig_e_h .and. mbs_e_h == mbase) then
                 call fmeq(m_euler_harmonic, mxy(2))
                 call fmln(mxy(1), mxy(3))
                 call fmsub_r1(mxy(2), mxy(3))
                 call fmmpy(mxy(6), mxy(2), mjsums(j))
             else
                 call fmeuler(mxy(2))
                 call fmnegate(mxy(2))
                 call fmi2m(1, mxy(3))
                 do k = 1, ival-1
                    call fmcsdivi(mxy(3), k, mxy(4))
                    call fmadd_r1(mxy(2), mxy(4))
                 enddo
                 ival_e_h = ival
                 ndig_e_h = ndig
                 mbs_e_h = mbase
                 call fmeq(mxy(2), m_euler_harmonic)
                 call fmln(mxy(1), mxy(3))
                 call fmsub_r1(mxy(2), mxy(3))
                 call fmmpy(mxy(6), mxy(2), mjsums(j))
             endif
         endif
         jterm = jterm + 1
         nterm = nterm - 1
      enddo
      call fmovun_xe(mxy(1), xe)
      if (xe < -ndig) then
          kl = 0
      else
          kl = 1
          call fmeq(mxy(1), mxy(2))
          call fmnegate(mxy(2))
          call fmipwr(mxy(2), j2, mxy(5))
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(6), mxy(5))
         do j = 1, j2
            call fmcsdivi_r1(mxy(6), jterm)
            if (nterm /= 0) then
                call fmcsdivi(mxy(6), nterm, mxy(4))
            else
                if (ival == ival_e_h .and. ndig <= ndig_e_h .and. mbs_e_h == mbase) then
                    call fmeq(m_euler_harmonic, mxy(7))
                    call fmln(mxy(1), mxy(3))
                    call fmsub_r1(mxy(7), mxy(3))
                    call fmmpy(mxy(6), mxy(7), mxy(4))
                else
                    call fmeuler(mxy(7))
                    call fmnegate(mxy(7))
                    call fmi2m(1, mxy(3))
                    do k = 1, ival-1
                       call fmcsdivi(mxy(3), k, mxy(4))
                       call fmadd_r1(mxy(7), mxy(4))
                    enddo
                    ival_e_h = ival
                    ndig_e_h = ndig
                    mbs_e_h = mbase
                    call fmeq(mxy(7), m_euler_harmonic)
                    call fmln(mxy(1), mxy(3))
                    call fmsub_r1(mxy(7), mxy(3))
                    call fmmpy(mxy(6), mxy(7), mxy(4))
                endif
            endif
            ndig = ndsav1
            call fmadd_r1(mjsums(j), mxy(4))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            ndig = ndsav1 - int(mjsums(j)%mp(2) - mxy(4)%mp(2))
            ndig = min(ndsav1, ndig)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
            jterm = jterm + 1
            nterm = nterm - 1
         enddo
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call fmeq(mjsums(j2), mxy(5))
      do j = 2, j2
         call fmcsmpy_r1(mxy(5), mxy(2))
         call fmadd_r1(mxy(5), mjsums(j2-j+1))
      enddo
      call fmeq(mxy(5), mxy(12))

      call fmeq(mxy(12), mresult)

      return
      end subroutine fmen_m1

      subroutine fmen_m2(mxy, ival, ndsave, mresult, numtry, kflagx, x)

!  Method 2 for computing exponential integral(ival,ma).

      use fmvals
      implicit none

      type(multi) :: mxy(14), mresult
      integer :: ival, ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ival, ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult

      double precision :: xe
      integer :: iextra, j, ndsav1, ndsav2, nterms

!             Method 2.  use the continued fraction expansion.

!             mxy(14) is the current approximation.
!             mxy(10) is the term in the sum, s(k).
!             mxy(8), mxy(9) are the latest denominators, q(k-1) and q(k).

      if (kflagx == 0) then
          if (x > 0 .and. ival > 0 .and. numtry <= 0 .and. ncall <= 1) then
              ndig = max(ndsave+ngrd52, ndig-1)
          endif
      endif
      call fmi2m(-ival, mxy(2))
      call fmsub(mxy(2), mxy(1), mxy(3))
      call fmnint(mxy(3), mxy(2))
      call fmsub(mxy(3), mxy(2), mxy(4))
      if (mxy(4)%mp(3) == 0) then
          if (ival <= 0) then
              if (abs(ival) <= 100) then
                  call fmen_m4(mxy, ival, mresult)
                  return
              else
                  call fmen_m5(mxy, ival, mresult)
              endif
          endif
      endif
      iextra = 0
      if (mxy(2)%mp(1) >= 0) then
          if (mxy(4)%mp(2) < 0) iextra = -mxy(4)%mp(2)
          if (abs(mxy(4)%mp(2)) >= mexpov) iextra = 0
      endif
      if (ival < 0) then
          if (abs(x) > 1/sqrt(dpmax) .and. abs(x) < sqrt(dpmax)) then
              j = (log(6.2831853d0) + log(dble(-ival)) - ival*(log(dble(-ival))-1) -  &
                  (1-ival)*log(abs(x))) / dlogmb + ngrd21
          else
              call fmovun_xe(mxy(1), xe)
              j = (log(6.2831853d0) + log(dble(-ival)) - ival*(log(dble(-ival))-1)) / dlogmb  &
                  - dble(1-ival)*(xe-1)
          endif
          iextra = max(iextra, j)
      endif
      if (iextra > 0) then
          call fmequ_r1(mxy(1), ndig, ndig+iextra)
      endif
      ndig = ndig + iextra
      ndsav1 = ndig
      call fmi2m(0, mxy(8))
      call fmi2m(1, mxy(9))
      call fmi2m(0, mxy(10))
      call fmi2m(0, mxy(14))
      nterms = int(intmax/10)

!             Continued fraction loop.

      ndsav2 = ndig
      do j = 1, nterms
         if (mod(j, 2) == 1) then
             call fmeq(mxy(1), mxy(11))
             call fmcsmpy_r1(mxy(11), mxy(9))
             call fmcsmpyi(mxy(8), (j-1)/2, mxy(12))
         else
             call fmeq(mxy(9), mxy(11))
             call fmcsmpyi(mxy(8), ival+(j-2)/2, mxy(12))
         endif
         if (j == 1) then
             call fmeq(mxy(11), mxy(7))
             call fmexp(mxy(1), mxy(5))
             call fmovun_xe(mxy(5), xe)
             if (xe >= mexpov) then
                 call fmen_m5(mxy, ival, mresult)
                 return
             endif
             call fmmpy(mxy(1), mxy(5), mxy(6))
             call fmi2m(1, mxy(2))
             call fmdiv(mxy(2), mxy(6), mxy(10))
         else
             call fmadd(mxy(11), mxy(12), mxy(7))
             call fmcsmpy_r1(mxy(10), mxy(12))
             call fmcsdiv(mxy(10), mxy(7), mxy(3))
             call fmeq(mxy(3), mxy(10))
             call fmnegate(mxy(10))
         endif
         call fmeq(mxy(9), mxy(8))
         call fmeq(mxy(7), mxy(9))
         ndig = ndsav2
         call fmcsadd_r1(mxy(14), mxy(10))

!             Check for convergence.

         if (kflag == 1 .and. j > 1) then
             exit
         endif
         ndig = min(ndsav2, max(ngrd22, ndsav2-int(mxy(14)%mp(2)-mxy(10)%mp(2))))
         if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         if (j == nterms) then
             call fmunknown(mresult)
             return
         endif
      enddo

      call fmeq(mxy(14), mxy(12))
      ndig = ndsav1
      if (mxy(12)%mp(2) == munkno .and. mxy(12)%mp(5) >= 0) then
          call fmen_m5(mxy, ival, mresult)
          return
      endif

      call fmeq(mxy(12), mresult)

      return
      end subroutine fmen_m2

      subroutine fmen_m3(mxy, ival, mresult, n_acc, kflagx, x)

!  Method 3 for computing exponential integral(ival,ma).

      use fmvals
      implicit none

      type(multi) :: mxy(14), mresult
      integer :: ival, n_acc, kflagx
      double precision :: x
      intent (in) :: ival, kflagx, x
      intent (inout) :: mxy, mresult, n_acc

      integer :: iextra, j, k

!             Method 3.  For small positive ival use a recurrence involving ExponentialEi.

      if (mxy(1)%mp(1) < 0) then
          call fmunknown(mxy(12))
          kflag = -4
      else if (ival == 1) then
          call fmeq(mxy(1), mxy(3))
          call fmnegate(mxy(3))
          call fmei(mxy(3), mxy(12))
          call fmnegate(mxy((12)))
      else
          iextra = 0
          if (kflagx == 0) then
              iextra = int(ival/2.25d0*(log(abs(x))-1.1d0*(log(dble(ival))-1.4d0))*dlogtn/dlogmb)
              iextra = max(0, iextra)
          endif
          if (abs(mxy(1)%mp(2)) >= mexpov) iextra = 0
          if (iextra > 0) then
              call fmequ_r1(mxy(1), ndig, ndig+iextra)
          endif
          ndig = ndig + iextra
          n_acc = nint(ndig*alogm2)
          call fmeq(mxy(1), mxy(3))
          call fmnegate(mxy(3))
          call fmei(mxy(3), mxy(4))
          call fmeq(mxy(4), mxy(8))
          call fmipwr(mxy(3), ival-1, mxy(6))
          call fmmpy_r1(mxy(4), mxy(6))
          call fmnegate(mxy((4)))
          if (mxy(4)%mp(1) > 0) then
              call fmeq(mxy(4), mxy(13))
              call fmi2m(0, mxy(14))
          else
              call fmeq(mxy(4), mxy(14))
              call fmi2m(0, mxy(13))
          endif
          if (mxy(8)%mp(2) == mexpun) then
              call fmmpyi(mxy(8), -1, mxy(12))
          else
              call fmexp(mxy(3), mxy(5))
              call fmmpy_r1(mxy(6), mxy(5))
              do j = ival-2, 0, -1
                 call fmdiv_r1(mxy(6), mxy(3))
                 if (mxy(6)%mp(1) > 0) then
                     call fmadd_r1(mxy(13), mxy(6))
                 else
                     call fmadd_r1(mxy(14), mxy(6))
                 endif
                 call fmmpyi_r1(mxy(6), ival-1-j)
              enddo
              call fmadd(mxy(13), mxy(14), mxy(12))
              call fmcancel(mxy(13), mxy(14), mxy(12), k)
              n_acc = n_acc - k
              call fmfcti(ival-1, mxy(7))
              call fmdiv_r1(mxy(12), mxy(7))
          endif
      endif
      if (mxy(12)%mp(2) == munkno .and. mxy(12)%mp(5) >= 0) then
          call fmen_m5(mxy, ival, mresult)
          return
      endif

      call fmeq(mxy(12), mresult)

      return
      end subroutine fmen_m3

      subroutine fmen_m4(mxy, ival, mresult)

!  Method 4 for computing exponential integral(ival,ma).

      use fmvals
      implicit none

      type(multi) :: mxy(14), mresult
      integer :: ival
      intent (in) :: ival
      intent (inout) :: mxy, mresult

      integer :: j

!             Method 4.  For small negative ival use a recurrence involving exp.

      call fmeq(mxy(1), mxy(3))
      call fmnegate(mxy(3))
      call fmi2m(1, mxy(4))
      call fmi2m(1, mxy(5))
      do j = 1, -ival
         call fmmpy_r1(mxy(5), mxy(1))
         if (j > 1) call fmdivi_r1(mxy(5), j)
         call fmadd_r1(mxy(4), mxy(5))
      enddo
      call fmmpy_r1(mxy(5), mxy(1))
      call fmdiv(mxy(4), mxy(5), mxy(6))
      call fmabs(mxy(6), mxy(7))
      call fmln(mxy(7), mxy(8))
      call fmsub(mxy(8), mxy(1), mxy(5))
      call fmexp(mxy(5), mxy(12))
      if (mxy(6)%mp(1) < 0) call fmnegate(mxy(12))
      if (mxy(12)%mp(2) == munkno .and. mxy(12)%mp(5) >= 0) then
          call fmen_m5(mxy, ival, mresult)
          return
      endif

      call fmeq(mxy(12), mresult)

      return
      end subroutine fmen_m4

      subroutine fmen_m5(mxy, ival, mresult)

!  Method 5 for computing exponential integral(ival,ma).

      use fmvals
      implicit none

      type(multi) :: mxy(14), mresult
      integer :: ival
      intent (in) :: ival
      intent (inout) :: mxy, mresult

      integer :: n
      logical, external :: fmcomp

!             Method 5.  use incomplete gamma.

      if (mxy(1)%mp(1) < 0) then
          if (ival > 0) then
              call fmunknown(mxy(12))
              kflag = -4
          else
              call fmi2m(-1, mxy(12))
              if (ival == -1 .and. fmcomp(mxy(1), '==', mxy(12))) then
                  call fmi2m(0, mxy(12))
              else
                  n = 1 - ival
                  call fmi2m(n, mxy(12))
                  raise_ndig = 1
                  call fmigm2(mxy(12), mxy(1), mxy(13))
                  raise_ndig = 0
                  call fmeq(mxy(13), mxy(12))
                  n = ival - 1
                  call fmipwr(mxy(1), n, mxy(3))
                  call fmmpy_r2(mxy(3), mxy(12))
              endif
          endif
      else
          n = 1 - ival
          call fmi2m(n, mxy(13))
          raise_ndig = 1
          call fmigm2(mxy(13), mxy(1), mxy(12))
          call fmipwr(mxy(1), ival-1, mxy(13))
          call fmmpy_r2(mxy(13), mxy(12))
          raise_ndig = 0
      endif

      call fmeq(mxy(12), mresult)

      return
      end subroutine fmen_m5

      subroutine fmen_sc(ival, ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = exponential integral(ival,ma).

!  kresult = 1 is returned if a special case gives the value of exponential integral(ival,ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(14), mresult
      integer :: ival, kresult, ndsave
      intent (in) :: ival, ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j, k, kl, krsave, n, nds
      double precision :: xe, ye
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMEN     '
      j = ndig
      ndig = ndsave
      call fmntr_inpi1(ival, ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      k = 0
      n = ival

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (kround /= 1) then
          call fmovun_xe(malocal, xe)
          if (n > 1 .and. xe < -ndsave) k = 1
          if (n <= 0) then
              j = ntrace
              ntrace = 0
              kl = kwarn
              kwarn = 0
              krsave = kround
              kround = 1
              nds = ndig
              ndig = ndig + ngrd52
              call fmequ(malocal, mxy(1), nds, ndig)
              call fmi2m(-n, mxy(2))
              call fmfact(mxy(2), mxy(3))
              call fmipwr(mxy(1), -n+1, mxy(5))
              call fmdiv(mxy(3), mxy(5), mxy(4))
              call fmi2m(-1, mxy(6))
              call fmdivi(mxy(6), -n+1, mxy(5))
              call fmovun_xe(mxy(4), xe)
              call fmovun_xe(mxy(5), ye)
              if (xe - ye > ndsave) k = 1
              ntrace = j
              kwarn = kl
              ndig = nds
              kround = krsave
          endif
          if (malocal%mp(1) < 0 .and. n > 0) k = 0
      endif
      if (kround /= 1 .and. k == 1) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          krsave = kround
          kround = 1
          nds = ndig
          ndig = ndig + ngrd52
          call fmequ(malocal, mxy(1), nds, ndig)
          if (n == 2) then
              call fmi2m(1, mxy(4))
              call fmln(mxy(1), mxy(2))
              call fmeulr(mxy(3))
              call fmadd(mxy(2), mxy(3), mxy(5))
              call fmmpy(mxy(5), mxy(1), mxy(6))
              call fmsub(mxy(6), mxy(1), mxy(5))
          else if (n >= 3) then
              call fmi2m(1, mxy(2))
              call fmdivi(mxy(2), n-1, mxy(4))
              call fmdivi(mxy(1), -(n-2), mxy(5))
          endif
          call fmovun_xe(mxy(4), xe)
          call fmovun_xe(mxy(5), ye)
          if (xe - ye > ndsave+1) then
              call fmequ(mxy(4), mxy(10), ndig, nds)
              call fmequ(mxy(4), mxy(6), ndig, nds)
              call fmequ(mxy(6), mxy(8), nds, ndig)
              call fmsub(mxy(4), mxy(8), mxy(6))
              if (mxy(6)%mp(3) == 0) then
                  call fmequ(mxy(4), mxy(6), ndig, nds)
                  call fmequ(mxy(5), mxy(7), ndig, nds)
                  ndig = nds
                  kround = krsave
                  call fmadd(mxy(6), mxy(7), mresult)
              else
                  kround = krsave
                  call fmequ(mxy(4), mresult, ndig, nds)
              endif
              kflag = 0
              ntrace = j
              kwarn = k
              ndig = nds
              kround = krsave
              kresult = 1
              return
          endif
          kflag = 0
          ntrace = j
          kwarn = k
          ndig = nds
          kround = krsave
      endif

      return
      end subroutine fmen_sc

      subroutine fmenter0(kovun, mxsave, ndsave)

!  At the start of a function this routine raises precision, and extends the
!  overflow/underflow threshold.

      use fmvals
      implicit none

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (inout) :: kovun, mxsave, ndsave

      integer :: k

      if (mblogs /= mbase) call fmcons
      kovun = 0

!             Increase the working precision.

      ncall = ncall + 1
      ndsave = ndig
      if (ncall == 1) then
          k = max(ngrd52-1, 2)
          ndig = max(ndig+k, 3)
          kround1 = kround
      else if (kround1 /= 1) then
          ndig = ndig + ngrd22
      endif

!             Extend the overflow/underflow threshold.

      mxsave = mxexp
      mxexp = mxexp2

      return
      end subroutine fmenter0

      subroutine fmenter1(ma, kovun, mxsave, ndsave)

!  At the start of a function this routine raises precision, and extends the
!  overflow/underflow threshold.

      use fmvals
      implicit none

      type(multi) :: ma
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (in) :: ma
      intent (inout) :: kovun, mxsave, ndsave

      integer :: k

      if (mblogs /= mbase) call fmcons
      kovun = 0
      if (ma%mp(2) == mexpov .or. ma%mp(2) == mexpun) kovun = 1
      if (ma%mp(2) == munkno) kovun = 2

!             Increase the working precision.

      ncall = ncall + 1
      ndsave = ndig
      if (ncall == 1) then
          k = max(ngrd52-1, 2)
          ndig = max(ndig+k, 3)
          kround1 = kround
      else if (kround1 /= 1) then
          ndig = ndig + ngrd22
      endif

!             Extend the overflow/underflow threshold.

      mxsave = mxexp
      mxexp = mxexp2

      return
      end subroutine fmenter1

      subroutine fmenter2(ma, mb, kovun, mxsave, ndsave)

!  At the start of a function this routine raises precision, and extends the
!  overflow/underflow threshold.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (in) :: ma, mb
      intent (inout) :: kovun, mxsave, ndsave

      integer :: k

      if (mblogs /= mbase) call fmcons
      kovun = 0
      if (ma%mp(2) == mexpov .or. ma%mp(2) == mexpun) kovun = 1
      if (mb%mp(2) == mexpov .or. mb%mp(2) == mexpun) kovun = 1
      if (ma%mp(2) == munkno) kovun = 2
      if (mb%mp(2) == munkno) kovun = 2

!             Increase the working precision.

      ncall = ncall + 1
      ndsave = ndig
      if (ncall == 1) then
          k = max(ngrd52-1, 2)
          ndig = max(ndig+k, 3)
          kround1 = kround
      else if (kround1 /= 1) then
          ndig = ndig + ngrd22
      endif

!             Extend the overflow/underflow threshold.

      mxsave = mxexp
      mxexp = mxexp2

      return
      end subroutine fmenter2

      subroutine fmenter3(ma, mb, mc, kovun, mxsave, ndsave)

!  At the start of a function this routine raises precision, and extends the
!  overflow/underflow threshold.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (in) :: ma, mb, mc
      intent (inout) :: kovun, mxsave, ndsave

      integer :: k

      if (mblogs /= mbase) call fmcons
      kovun = 0
      if (ma%mp(2) == mexpov .or. ma%mp(2) == mexpun) kovun = 1
      if (mb%mp(2) == mexpov .or. mb%mp(2) == mexpun) kovun = 1
      if (mc%mp(2) == mexpov .or. mc%mp(2) == mexpun) kovun = 1
      if (ma%mp(2) == munkno) kovun = 2
      if (mb%mp(2) == munkno) kovun = 2
      if (mc%mp(2) == munkno) kovun = 2

!             Increase the working precision.

      ncall = ncall + 1
      ndsave = ndig
      if (ncall == 1) then
          k = max(ngrd52-1, 2)
          ndig = max(ndig+k, 3)
          kround1 = kround
      else if (kround1 /= 1) then
          ndig = ndig + ngrd22
      endif

!             Extend the overflow/underflow threshold.

      mxsave = mxexp
      mxexp = mxexp2

      return
      end subroutine fmenter3

      subroutine fmenter_sp(ndsave)

!  Called by the fm special functions, to raise precision more than for the elementary functions.

      use fmvals
      implicit none

      integer :: ndsave
      intent (in) :: ndsave

      integer :: k

!             Increase the working precision.

      if (ncall >= 1 .or. raise_ndig > 0) then
          k = int(ngrd52 + 1 + 0.002*ndsave + (real(ndsave)*alogmt)**0.35/alogmt)
          ndig = max(ndsave+k, ndig)
          ndig = max(ndig, 3)
      endif

      return
      end subroutine fmenter_sp

      subroutine fmenteri(kovun, mxsave, ndsave)

!  At the start of a function this routine raises precision, and extends the
!  overflow/underflow threshold.

      use fmvals
      implicit none

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (inout) :: kovun, mxsave, ndsave

      integer :: k

      if (mblogs /= mbase) call fmcons
      kovun = 0

!             Increase the working precision.

      ncall = ncall + 1
      ndsave = ndig
      if (ncall == 1) then
          k = max(ngrd52-1, 2)
          ndig = max(ndig+k, 3)
          kround1 = kround
      else if (kround1 /= 1) then
          ndig = ndig + ngrd22
      endif

!             Extend the overflow/underflow threshold.

      mxsave = mxexp
      mxexp = mxexp2

      return
      end subroutine fmenteri

      subroutine fmeq(ma, mb)

!  mb = ma

!  This is the standard form of equality, where ma and mb both have precision ndig.
!  Use fmequ for assignments that also change precision.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      integer :: j

      call fmalloc(mb, ndig+2)

!             If the user tries to change precision, one common mistake is to fail to increase the
!             size of all existing variables.  Check to make sure ma has a valid definition.

      if (.not. allocated(ma%mp)) call fminput_error
      if (size(ma%mp) < max(ndig+2, 5)) call fminput_error
      if (ma%mp(2) > munkno) then
          kflag = -3
          call fmwarn
      endif

!             Copy ma to mb.

      do j = 1, ndig+2
         mb%mp(j) = ma%mp(j)
      enddo

!             Check for overflow or underflow.

      if (abs(mb%mp(2)) > mxexp) then
          if (mb%mp(2) /= munkno .or. mb%mp(3) /= 1) then
              ncall = ncall + 1
              call fmtrap(mb)
              ncall = ncall - 1
          endif
          if (mb%mp(2) == munkno .and. kflag /= 1) kflag = -4
      endif

      return
      end subroutine fmeq

      subroutine fmequ(ma, mb, nda, ndb)

!  Set mb (having ndb digits) equal to ma (having nda digits).

!  If mb has less precision than ma the result is rounded to ndb digits.

!  If mb has more precision the result has zero digits padded on the right, and will have
!  its size increased if needed.

      use fmvals
      implicit none

      integer :: nda, ndb
      type(multi) :: ma, mb
      intent (in) :: ma, nda, ndb
      intent (inout) :: mb

      real (kind(1.0d0)) :: mbs, mkt
      integer :: j, k, kb, kresult

      if (.not. allocated(ma%mp)) then
          write (kw,*) ' '
          write (kw,*) ' Error in FMEQU.'
          write (kw,*) ' MA is not defined on input.'
          write (kw,*) ' Call stack: '
          write (kw, "(10(3X, A))") (namest(j), j=1, ncall)
          write (kw,*) ' '
          stop
      endif
      call fmalloc(mb, ndb+2)

      if (mblogs /= mbase) call fmcons

!             If the user tries to change precision, one common mistake is to fail to increase the
!             size of all existing variables.  Check to make sure ma has a valid definition.

      if (.not. allocated(ma%mp)) call fminput_error
      if (size(ma%mp) < nda+2) call fminput_error

!             Check for precision in range.

      if (nda < 3 .or. ndb < 3) then
          ncall = ncall + 1
          namest(ncall) = 'FMEQU'
          kflag = -1
          call fmwarn
          write (kw,                                                       &
                 "(/' The two precisions in FMEQU were NDA =', I19, "  //  &
                  "' NDB =', I19/)"                                        &
                ) nda, ndb
          do j = 2, ndb
             mb%mp(j+2) = 0
          enddo
          kflag = -1
          mb%mp(2) = munkno
          mb%mp(3) = 1
          mb%mp(1) = 1
          ncall = ncall - 1
          return
      endif
      mbs = ma%mp(1)
      mb%mp(1) = mbs

!             Check for special symbols.

      kflag = 0
      if (abs(ma%mp(2)) >= mexpov) then
          k = 2
          if (ma%mp(5) < 0) then
              k = 4
              mb%mp(4) = ma%mp(4)
              mb%mp(5) = ma%mp(5)
          endif
          do j = k, ndb
             mb%mp(j+2) = 0
          enddo
          mb%mp(2) = ma%mp(2)
          mb%mp(3) = ma%mp(3)
          call fmequ2(mb, ndb)
          return
      endif

      if (nda > ndb) then

!               Round ma from nda to ndb digits and return the result in mb.

          call fmequ_m1(ma, mb, nda, ndb, kresult)
          if (kresult > 0) then
              call fmequ2(mb, ndb)
              return
          endif
          mb%mp(ndb+2) = mb%mp(ndb+2) + 1

!             Check whether there was a carry in the rounded digit.

          kb = ndb + 1
          if (kb >= 3) then
              k = kb + 1
              do j = 3, kb
                 k = k - 1
                 if (mb%mp(k+1) < mbase) exit
                 mkt = aint (mb%mp(k+1)/mbase)
                 mb%mp(k) = mb%mp(k) + mkt
                 mb%mp(k+1) = mb%mp(k+1) - mkt*mbase
              enddo
          endif

!             If there is a carry in the first digit then the exponent must be adjusted and the
!             number shifted right.

          if (mb%mp(3) >= mbase) then
              if (kb >= 4) then
                  k = kb + 1
                  do j = 4, kb
                     k = k - 1
                     mb%mp(k+1) = mb%mp(k)
                  enddo
              endif

              mkt = aint (mb%mp(3)/mbase)
              if (kb >= 3) mb%mp(4) = mb%mp(3) - mkt*mbase
              mb%mp(3) = mkt
              mb%mp(2) = mb%mp(2) + 1
          endif

          if (mbs < 0 .and. mb%mp(2) /= munkno .and. mb%mp(3) /= 0) then
              mb%mp(1) = -1
          endif
          call fmequ2(mb, ndb)
          return
      else if (ndb == nda) then

!             ma and mb have the same precision.

          do j = 1, nda+1
             mb%mp(j+1) = ma%mp(j+1)
          enddo
          call fmequ2(mb, ndb)
          return

      else if (ndb > nda) then

!             Extend to ndb digits by padding with zeros.

          do j = 1, nda+1
             mb%mp(j+1) = ma%mp(j+1)
          enddo
          do j = nda+2, ndb+1
             mb%mp(j+1) = 0
          enddo
          call fmequ2(mb, ndb)
      endif

      return
      end subroutine fmequ

      subroutine fmequ2(mb, ndb)

!  Check for overflow or underflow.

      use fmvals
      implicit none

      type(multi) :: mb
      integer :: ndb
      intent (in) :: ndb
      intent (inout) :: mb

      integer :: j, kbovun, kbsign, kxf
      double precision :: d, xe, xf


      if (abs(mb%mp(2)) > mxexp) then
          if (mb%mp(2) /= munkno .or. mb%mp(3) /= 1) then
              if (mb%mp(2) > mxexp+1 .or. mb%mp(2) < -mxexp) then
                  kbovun = 1
                  if (mb%mp(2) < -mxexp) kbovun = -1
                  kbsign = mb%mp(1)
                  kxf = 0
                  xe = mb%mp(4)
                  xf = -mb%mp(5)/maxint
                  if (size(mb%mp) >= 5) then
                      if (mb%mp(5) < 0) then
                          xe = mb%mp(4)
                          xf = -mb%mp(5)/maxint
                          if (huge(mbase)/mexpov > 1.0d+20) then
                              d = 1.0d+10
                          else
                              d = 4
                          endif
                          if (xe > huge(mbase)/d) then
                              xe = huge(mbase)/d
                              xf = 1.0d0 - epsilon(1.0d0)
                          else if (xe < -huge(mbase)/d) then
                              xe = -huge(mbase)/d
                              xf = 1.0d0 - epsilon(1.0d0)
                          else if (xe == xe + 1.0d0) then
                              xf = 1.0d0 - epsilon(1.0d0)
                          endif
                          kxf = 1
                      endif
                  endif
                  if (kxf == 0) then
                      xe = mb%mp(2)
                      call fmovun_frac(mb, xf)
                  endif
                  do j = 4, ndb
                     mb%mp(j+2) = 0
                  enddo
                  mb%mp(1) = kbsign
                  mb%mp(2) = mexpov
                  kflag = -5
                  if (kbovun == -1) then
                      mb%mp(2) = mexpun
                      kflag = -6
                  endif
                  mb%mp(3) = 1
                  if (xf >= 1.0d0) then
                      xf = xf / dble(mbase)
                      xe = xe + 1
                      if (huge(mbase)/mexpov > 1.0d+20) then
                          d = 1.0d+10
                      else
                          d = 4
                      endif
                      if (xe > huge(mbase)/d) then
                          xe = huge(mbase)/d
                          xf = 1.0d0 - epsilon(1.0d0)
                      else if (xe < -huge(mbase)/d) then
                          xe = -huge(mbase)/d
                          xf = 1.0d0 - epsilon(1.0d0)
                      else if (xe == xe + 1.0d0) then
                          xf = 1.0d0 - epsilon(1.0d0)
                      endif
                  endif
                  mb%mp(4) = xe
                  mb%mp(5) = -xf*maxint
              endif
          endif
          if (mb%mp(2) == munkno .and. kflag /= 1) kflag = -4
      endif

      return
      end subroutine fmequ2

      subroutine fmequ_m1(ma, mb, nda, ndb, kresult)

!  Round ma from nda to ndb digits and return the result in mb.
!  nda > ndb.

      use fmvals
      implicit none

      integer :: nda, ndb, kresult
      type(multi) :: ma, mb
      intent (in) :: ma, nda, ndb
      intent (inout) :: mb, kresult

      real (kind(1.0d0)) :: m2
      integer :: j, l, n1

      kresult = 0
      n1 = ndb + 1
      do j = 1, n1
         mb%mp(j+1) = ma%mp(j+1)
      enddo
      if (kround == -1) then
          if (ma%mp(1) > 0) then
              kresult = 1
              return
          endif
          do j = ndb+2, nda+1
             if (ma%mp(j+1) > 0) return
          enddo
          kresult = 1
          return
      endif
      if (kround == 2) then
          if (ma%mp(1) < 0) then
              kresult = 1
              return
          endif
          do j = ndb+2, nda+1
             if (ma%mp(j+1) > 0) return
          enddo
          kresult = 1
          return
      endif
      if (kround == 0) then
          kresult = 1
          return
      endif

      if (int(mbase-aint (mbase/2)*2) /= 0) then
          m2 = aint (mbase/2)
          do j = ndb+2, nda+1
             if (ma%mp(j+1) /= m2) exit
             if (j == nda+1) return
          enddo
      endif
      l = ndb + 2
      if (2*(ma%mp(l+1)+1) < mbase) then
          kresult = 1
          return
      endif
      m2 = 2
      if (int(mbase-aint (mbase/m2)*m2) == 0) then
          if (2*ma%mp(l+1) < mbase) then
              kresult = 1
              return
          endif
          if (2*ma%mp(l+1) == mbase) then
              if (l <= nda) then
                  do j = l, nda
                     if (ma%mp(j+2) > 0) return
                  enddo
              endif

!                       Round to even.

              if (int(mb%mp(n1+1)-aint (mb%mp(n1+1)/m2)*m2) == 0) then
                  kresult = 1
                  return
              endif
          endif
      else
          if (2*ma%mp(l+1)+1 == mbase) then
              if (l <= nda) then
                  do j = l, nda
                     if (2*(ma%mp(j+2)+1) < mbase) then
                         kresult = 1
                         return
                     endif
                     if (2*ma%mp(j+2) > mbase) return
                  enddo
                  call fmequ2(mb, ndb)
                  return
              endif
          endif
      endif

      return
      end subroutine fmequ_m1

      subroutine fmequ_r1(ma, nda, ndb)

!  Change precision of ma from nda digits on input to ndb digits on output.

!  If ndb is less than nda the result is rounded to ndb digits.

!  If ndb is greater than nda the result has zero digits padded on the right, and will have
!  its size increased if needed.

      use fmvals
      implicit none

      type(multi) :: ma
      type(multi), save :: ma_copy
      integer :: nda, ndb

      integer :: j
      intent (inout) :: ma
      intent (in) :: nda, ndb

      if (.not. allocated(ma%mp)) then
          write (kw,*) ' '
          write (kw,*) ' Error in FMEQU_R1.'
          write (kw,*) ' MA is not defined on input.'
          write (kw,*) ' Call stack: '
          write (kw, "(10(3X, A))") (namest(j), j=1, ncall)
          write (kw,*) ' '
          stop
      endif

      call fmalloc(ma_copy, max(max(nda, ndb)+2, 5))

      do j = 1, nda+2
         ma_copy%mp(j) = ma%mp(j)
      enddo
      call fmequ(ma_copy, ma, nda, ndb)
      if (ndb < nda) then
          do j = ndb+1, nda
             ma%mp(j+2) = 0
          enddo
      endif

      return
      end subroutine fmequ_r1

      subroutine fmerf(ma, mb)

!  mb = erf(ma)    Error function.

!  2/sqrt(pi) * integral from 0 to ma of e**(-t**2) dt.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(13), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmerf_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call fmerf_m(ma, mxy, mresult, ndsave, retry)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry)
         endif
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmerf

      subroutine fmerf_m(ma, mxy, mresult, ndsave, retry)

!  Method selection for computing erf(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: ndsave
      logical :: retry
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, retry

      double precision :: c1, c2, x, xe
      integer :: kflagx, nmethd

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, ndig)

!             Check for special cases.

      if (mxy(1)%mp(3) == 0) then
          call fmeq(mxy(1), mxy(3))
          call fmerf_r(ma, mxy, mresult)
          return
      endif
      call fmovun_xe(mxy(1), xe)
      if (3*xe <= -ndig) then
          call fmi2m(2, mxy(2))
          call fmpi(mxy(3))
          call fmsqrt(mxy(3), mxy(4))
          call fmdiv(mxy(2), mxy(4), mxy(3))
          call fmmpy(mxy(3), mxy(1), mxy(4))
          call fmsqr(mxy(1), mxy(2))
          call fmmpy_r2(mxy(1), mxy(2))
          call fmdivi_r1(mxy(2), 3)
          call fmmpy_r2(mxy(3), mxy(2))
          call fmsub(mxy(4), mxy(2), mxy(3))
          mxy(3)%mp(1) = 1
          call fmerf_r(ma, mxy, mresult)
          return
      endif

!             x is a double precision approximation to the input argument to this function.

      mxy(1)%mp(1) = 1
      call fmm2dp(mxy(1), x)
      kflagx = kflag
      if (kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax**0.33d0
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif
      if (kflag /= 0 .and. xe > 0) then
          x = dpmax**0.33d0
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif

!             Determine which method to use.

!             nmethd = 1 use the convergent series,
!                    = 2 use a 2nd convergent series -- slower but no cancellation,
!                    = 3 use a continued fraction expansion.

      c1 = sqrt(dlogmb*(ndig+21))/5
      c2 = (dlogmb*(ndig+6))**0.6d0/4.1d0
      if (xe < 1) then
          nmethd = 1
      else if (abs(x) <= c1) then
          nmethd = 1
      else if (abs(x) <= c2) then
          nmethd = 2
      else
          nmethd = 3
      endif

      if (nmethd == 1) then
          call fmerf_m1(mxy, kflagx, x)
      else if (nmethd == 2) then
          call fmerf_m2(mxy, kflagx, x)
      else if (nmethd == 3) then
          call fmerf_m3(mxy)
      endif
      call fmerf_r(ma, mxy, mresult)

      return
      end subroutine fmerf_m

      subroutine fmerf_m1(mxy, kflagx, x)

!  Method 1 for computing erf(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(13)
      integer :: kflagx
      double precision :: x
      intent (in) :: kflagx, x
      intent (inout) :: mxy

      double precision :: xe
      integer :: iextra, j, j2, kl, ndsav1, nterm
      type(multi), save :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 1.  Use the (-1)**n x**(2n+1) / n! / (2n+1) series.

!             If ma is large in magnitude, use more guard digits.

      if (kflagx == 0) then
          if (abs(x) > 2 .and. abs(x) < sqrt(huge(x))) then
              iextra = max(int((x*x-1.83-log(2*x*x+1))/alogmb+1), 0)
              if (iextra > 0) then
                  call fmequ_r1(mxy(1), ndig, ndig+iextra)
              endif
              ndig = ndig + iextra
          endif
      endif
      if (kflagx == 0) then
          j2 = int(0.66*sqrt(fmnterms(x**2, 1, 0, 0, 1)) - 0.8)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call fmi2m(1, mxy(6))
      call fmi2m(1, mjsums(1))
      do j = 2, j2
         if (nterm > 1) call fmcsdivi_r1(mxy(6), nterm)
         call fmcsdivi(mxy(6), 2*nterm+1, mjsums(j))
         nterm = nterm + 1
      enddo
      call fmovun_xe(mxy(1), xe)
      if (xe < -ndig) then
          kl = 0
      else
          kl = 1
          call fmipwr(mxy(1), 2*j2, mxy(5))
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(6), mxy(5))
         do j = 1, j2
            call fmcsdivi_r1(mxy(6), nterm)
            call fmcsdivi(mxy(6), 2*nterm+1, mxy(4))
            ndig = ndsav1
            call fmcsaddnn_r1(mjsums(j), mxy(4))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            ndig = ndsav1 - int(mjsums(j)%mp(2) - mxy(4)%mp(2))
            ndig = min(ndsav1, ndig)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
            nterm = nterm + 1
         enddo
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call fmcsnsums(j2, mjsums)
      call fmsqr(mxy(1), mxy(4))
      call fmnegate(mxy(4))
      call fmeq(mjsums(j2), mxy(5))
      do j = 2, j2
         call fmcsmpy_r1(mxy(5), mxy(4))
         call fmadd_r1(mxy(5), mjsums(j2-j+1))
      enddo
      call fmcsmpy_r1(mxy(5), mxy(1))

      call fmpi(mxy(4))
      call fmsqrt(mxy(4), mxy(3))
      call fmcsmpyi(mxy(5), 2, mxy(4))
      call fmdiv_r2(mxy(4), mxy(3))

      return
      end subroutine fmerf_m1

      subroutine fmerf_m2(mxy, kflagx, x)

!  Method 2 for computing erf(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(13)
      integer :: kflagx
      double precision :: x
      intent (in) :: kflagx, x
      intent (inout) :: mxy

      double precision :: xe
      integer :: j, j2, kl, ndsav1, nterm
      type(multi), save :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 2.  Use the x**(2n+1) * 2**(n+1) / (1*3*5*...*(2n+1)) series.

      mxy(1)%mp(1) = 1
      if (kflagx == 0) then
          j2 = int(0.51*sqrt(fmnterms(2*x, 2, -1, 0, 1)))
      else
          j2 = 1
      endif
      j2 = max(1, min(ljsums, j2))
      ndsav1 = ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call fmcsmpyi(mxy(1), 2, mxy(6))
      call fmeq(mxy(6), mjsums(1))
      do j = 2, j2
         call fmcsmpyi_r1(mxy(6), 2)
         call fmcsdivi_r1(mxy(6), 2*nterm+1)
         call fmeq(mxy(6), mjsums(j))
         nterm = nterm + 1
      enddo
      call fmovun_xe(mxy(1), xe)
      if (xe < -ndig) then
          kl = 0
      else
          kl = 1
          call fmipwr(mxy(1), 2*j2, mxy(5))
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(6), mxy(5))
         do j = 1, j2
            call fmcsmpyi_r1(mxy(6), 2)
            call fmcsdivi_r1(mxy(6), 2*nterm+1)
            ndig = ndsav1
            call fmcsaddnn_r1(mjsums(j), mxy(6))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            ndig = ndsav1 - int(mjsums(j)%mp(2)-mxy(6)%mp(2))
            ndig = min(ndsav1, ndig)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
            nterm = nterm + 1
         enddo
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call fmcsnsums(j2, mjsums)
      call fmsqr(mxy(1), mxy(6))
      call fmeq(mjsums(j2), mxy(5))
      do j = 2, j2
         call fmcsmpy_r1(mxy(5), mxy(6))
         call fmadd_r1(mxy(5), mjsums(j2-j+1))
      enddo

      call fmpi(mxy(4))
      call fmsqrt(mxy(4), mxy(3))
      call fmdiv_r2(mxy(5), mxy(3))
      call fmexp(mxy(6), mxy(4))
      call fmdiv_r1(mxy(3), mxy(4))

      return
      end subroutine fmerf_m2

      subroutine fmerf_m3(mxy)

!  Method 2 for computing erf(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(13)
      intent (inout) :: mxy

      integer :: j, ndsav1, ndsav2, nterms

!             Method 3.  Use the continued fraction expansion.

!             mxy(2) is abs(x).
!             mxy(3) is abs(2x).
!             mxy(4) is -x*x.
!             mxy(13) is the current approximation.
!             mxy(10) is the term in the sum, s(k).
!             mxy(8), mxy(9) are the latest denominators, q(k-1) and q(k).

      ndsav1 = ndig
      call fmabs(mxy(1), mxy(2))
      call fmmpyi(mxy(2), 2, mxy(3))
      call fmsqr(mxy(2), mxy(4))
      call fmnegate(mxy(4))
      call fmi2m(0, mxy(8))
      call fmi2m(1, mxy(9))
      call fmi2m(1, mxy(10))
      call fmi2m(1, mxy(13))
      nterms = int(intmax/10)

!             Continued fraction loop.

      ndsav2 = ndig
      do j = 1, nterms
         if (mod(j, 2) == 1) then
             call fmeq(mxy(2), mxy(11))
             call fmcsmpy_r1(mxy(11), mxy(9))
         else
             call fmeq(mxy(3), mxy(11))
             call fmcsmpy_r1(mxy(11), mxy(9))
         endif
         if (j == 1) then
             call fmeq(mxy(11), mxy(7))
             call fmexp(mxy(4), mxy(5))
             call fmpi(mxy(12))
             call fmsqrt(mxy(12), mxy(6))
             call fmdiv(mxy(5), mxy(6), mxy(10))
             call fmdiv_r1(mxy(10), mxy(2))
             call fmnegate(mxy(10))
         else
             call fmcsmpyi(mxy(8), j-1, mxy(12))
             call fmadd(mxy(11), mxy(12), mxy(7))
             call fmcsmpy_r1(mxy(10), mxy(12))
             call fmeq(mxy(10), mxy(5))
             call fmcsdiv(mxy(5), mxy(7), mxy(10))
             call fmnegate(mxy(10))
         endif
         call fmeq(mxy(9), mxy(8))
         call fmeq(mxy(7), mxy(9))
         ndig = ndsav2
         call fmcsadd_r1(mxy(13), mxy(10))

!             Check for convergence.

         if (kflag == 1) then
             exit
         endif
         ndig = min(ndsav2, max(ngrd22, ndsav2-int(mxy(13)%mp(2)-mxy(10)%mp(2))))
         if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         if (j == nterms) then
             call fmunknown(mxy(3))
             return
         endif
      enddo

      call fmeq(mxy(13), mxy(3))
      ndig = ndsav1

      return
      end subroutine fmerf_m3

      subroutine fmerf_r(ma, mxy, mresult)

!  Check non-symmetric rounding for computing erf(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(13), mresult
      intent (in) :: ma
      intent (inout) :: mxy, mresult

      integer :: krsave
      if (kround /= 1) then
          if (mxy(3)%mp(2) == 1 .and. ma%mp(1) > 0 .and.  &
              (kround == -1 .or. kround == 0)) then
              call fmtiny(mxy(1))
              call fmsub_r1(mxy(3), mxy(1))
          endif
          if (mxy(3)%mp(2) == 1 .and. ma%mp(1) < 0 .and.  &
              (kround == 2 .or. kround == 0)) then
              krsave = kround
              kround = 0
              call fmtiny(mxy(1))
              call fmsub_r1(mxy(3), mxy(1))
              kround = krsave
          endif
          if (kflag == 1) kflag = 0
      endif

      if (ma%mp(1) < 0) then
          call fmnegate(mxy(3))
      endif

      call fmeq(mxy(3), mresult)

      return
      end subroutine fmerf_r

      subroutine fmerf_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = erf(ma).

!  kresult = 1 is returned if a special case gives the value of erf(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMERF    '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      return
      end subroutine fmerf_sc

      subroutine fmerfc(ma, mb)

!  mb = erfc(ma)    Complimentary Error function.

!  2/sqrt(pi) * integral from ma to infinity of e**(-t**2) dt.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(13), mresult, mretry

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmerfc_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      n_acc = nint(ndig*alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmerfc_m(ma, mxy, mresult, ndsave, numtry, retry)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmerfc

      subroutine fmerfc_m(ma, mxy, mresult, ndsave, numtry, retry)

!  Method selection for computing erfc(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: ndsave, numtry
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry

      integer :: nmethd
      double precision :: c1, x, xe

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, ndig)
      call fmi2m(1, mxy(3))
      call fmdivi_r1(mxy(3), 2)

!             Check for special cases.

      if (mxy(1)%mp(3) == 0 .or. mxy(1)%mp(2) == mexpun) then
          call fmi2m(1, mresult)
          retry = .false.
          return
      endif

!             x is a double precision approximation to the input argument to this function.

      call fmm2dp(mxy(1), x)
      call fmovun_xe(mxy(1), xe)
      if (kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax
          if (mxy(1)%mp(1) < 0) x = -x
      endif
      if (kflag /= 0 .and. xe > 0) then
          x = dpmax
          if (mxy(1)%mp(1) < 0) x = -x
      endif

!             Determine which method to use.

!             nmethd = 1 means use 1 - erf(x),
!                    = 2 means use the continued fraction expansion.

      c1 = (dlogmb*(ndig+6))**0.7d0/9
      if (xe < 1) then
          nmethd = 1
      else if (x <= c1) then
          nmethd = 1
      else
          nmethd = 2
      endif

      if (nmethd == 1) then
          call fmerfc_m1(mxy, mresult, ndsave, numtry, x)
      else if (nmethd == 2) then
          call fmerfc_m2(mxy, mresult)
      endif
      call fmerfc_r(mxy, mresult)

      return
      end subroutine fmerfc_m

      subroutine fmerfc_m1(mxy, mresult, ndsave, numtry, x)

!  Method 1 for computing erfc(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(13), mresult
      integer :: ndsave, numtry
      double precision :: x
      intent (in) :: numtry, ndsave, x
      intent (inout) :: mxy, mresult

      integer :: iextra

!             Method 1.  Use erf.

      if (numtry <= 0 .and. ncall <= 1 .and. ndig < 100) then
          ndig = max(ndsave+ngrd52, ndig-1)
      endif
      if (x < 2) then
          call fmerf(mxy(1), mxy(4))
          call fmi2m(1, mxy(2))
          call fmsub(mxy(2), mxy(4), mresult)
          return
      endif

!             Raise precision to compensate for cancellation if x is large.

      iextra = max(int((x*x+log(2*x))/alogmb+1), 0)
      if (iextra > 0) then
          call fmequ_r1(mxy(1), ndig, ndig+iextra)
      endif
      ndig = ndig + iextra
      raise_ndig = 1
      call fmerf(mxy(1), mxy(4))
      raise_ndig = 0
      call fmi2m(1, mxy(2))
      call fmsub(mxy(2), mxy(4), mxy(3))

      call fmeq(mxy(3), mresult)

      return
      end subroutine fmerfc_m1

      subroutine fmerfc_m2(mxy, mresult)

!  Method 2 for computing erfc(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(13), mresult
      intent (inout) :: mxy, mresult

      integer :: j, ndsav2, nterms

!             Method 2.  Use the continued fraction expansion.

!             mxy(2) is abs(x).
!             mxy(3) is abs(2x).
!             mxy(4) is -x*x.
!             mxy(13) is the current approximation.
!             mxy(10) is the term in the sum, s(k).
!             mxy(8), mxy(9) are the latest denominators, q(k-1) and q(k).

      call fmabs(mxy(1), mxy(2))
      call fmmpyi(mxy(2), 2, mxy(3))
      call fmsqr(mxy(2), mxy(4))
      call fmnegate(mxy(4))
      call fmi2m(0, mxy(8))
      call fmi2m(1, mxy(9))
      call fmi2m(1, mxy(10))
      call fmi2m(0, mxy(13))
      nterms = int(intmax/10)

!             Continued fraction loop.

      ndsav2 = ndig
      do j = 1, nterms
         if (mod(j, 2) == 1) then
             call fmeq(mxy(2), mxy(11))
             call fmcsmpy_r1(mxy(11), mxy(9))
         else
             call fmeq(mxy(3), mxy(11))
             call fmcsmpy_r1(mxy(11), mxy(9))
         endif
         if (j == 1) then
             call fmeq(mxy(11), mxy(7))
             call fmexp(mxy(4), mxy(5))
             call fmpi(mxy(12))
             call fmsqrt(mxy(12), mxy(6))
             call fmdiv(mxy(5), mxy(6), mxy(10))
             call fmdiv_r1(mxy(10), mxy(2))
             if (mxy(10)%mp(2) == mexpun) then
                 call fmeq(mxy(10), mresult)
                 return
             endif
         else
             call fmcsmpyi(mxy(8), j-1, mxy(12))
             call fmadd(mxy(11), mxy(12), mxy(7))
             call fmcsmpy_r1(mxy(10), mxy(12))
             call fmeq(mxy(10), mxy(5))
             call fmcsdiv(mxy(5), mxy(7), mxy(10))
             call fmnegate(mxy(10))
         endif
         call fmeq(mxy(9), mxy(8))
         call fmeq(mxy(7), mxy(9))
         ndig = ndsav2
         call fmcsadd_r1(mxy(13), mxy(10))

!             Check for convergence.

         if (j > 1 .and. kflag == 1) then
             exit
         endif
         ndig = min(ndsav2, max(ngrd22, ndsav2-int(mxy(13)%mp(2)-mxy(10)%mp(2))))
         if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         if (j == nterms) then
             call fmunknown(mresult)
             return
         endif
      enddo

      call fmeq(mxy(13), mresult)

      return
      end subroutine fmerfc_m2

      subroutine fmerfc_r(mxy, mresult)

!  Check non-symmetric rounding for computing erfc(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(13), mresult
      intent (inout) :: mxy, mresult

      logical, external :: fmcomp

      if (kround == -1 .or. kround == 0) then
          call fmi2m(2, mxy(1))
          if (fmcomp(mresult, '==', mxy(1))) then
              call fmdp2m(1.9999d0, mxy(2))
              call fmulp(mxy(2), mxy(4))
              call fmsub(mxy(1), mxy(4), mresult)
          endif
      endif

      return
      end subroutine fmerfc_r

      subroutine fmerfc_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = erfc(ma).

!  kresult = 1 is returned if a special case gives the value of erfc(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      double precision :: xe, ye
      integer :: j, k, krsave, nds
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMERFC   '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      call fmovun_xe(malocal, xe)
      if (kround /= 1 .and. xe < -ndsave) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          krsave = kround
          kround = 1
          nds = ndig
          ndig = ndig + ngrd52
          call fmequ(malocal, mxy(1), nds, ndig)
          call fmi2m(1, mxy(4))
          if (malocal%mp(2) == mexpun) then
              call fmi2m(0, mxy(2))
              call fmsub(mxy(2), mxy(1), mxy(5))
          else
              call fmpi(mxy(2))
              call fmsqrt(mxy(2), mxy(3))
              call fmdiv(mxy(4), mxy(3), mxy(5))
              call fmmpyi(mxy(5), -2, mxy(6))
              call fmmpy(mxy(1), mxy(6), mxy(5))
          endif
          call fmovun_xe(mxy(4), xe)
          call fmovun_xe(mxy(5), ye)
          if (xe - ye > ndsave) then
              call fmequ(mxy(4), mxy(6), ndig, nds)
              call fmequ(mxy(5), mxy(7), ndig, nds)
              ndig = nds
              kround = krsave
              call fmadd(mxy(6), mxy(7), mresult)
              kflag = 0
              ntrace = j
              kwarn = k
              kresult = 1
              return
          endif
          kflag = 0
          ntrace = j
          kwarn = k
          ndig = nds
          kround = krsave
      endif

      return
      end subroutine fmerfc_sc

      subroutine fmerfcs(ma, mb)

!  mb = erfc_scaled(ma)    Scaled Complimentary Error function.

!     = exp(x**2) * erfc(x)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(13), mresult, mretry

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmerfcs_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      n_acc = nint(ndig*alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmerfcs_m(ma, mxy, mresult, ndsave, numtry, retry)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmerfcs

      subroutine fmerfcs_m(ma, mxy, mresult, ndsave, numtry, retry)

!  Method selection for computing erfc_scaled(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: ndsave, numtry
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry

      double precision :: c1, x, xe
      integer :: nmethd

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, ndig)
      call fmi2m(1, mxy(3))
      call fmdivi_r1(mxy(3), 2)

!             Check for special cases.

      if (mxy(1)%mp(3) == 0 .or. mxy(1)%mp(2) == mexpun) then
          call fmi2m(1, mresult)
          retry = .false.
          return
      endif

!             x is a double precision approximation to the input argument to this function.

      call fmm2dp(mxy(1), x)
      call fmovun_xe(mxy(1), xe)
      if (kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax
          if (mxy(1)%mp(1) < 0) x = -x
      endif
      if (kflag /= 0 .and. xe > 0) then
          x = dpmax
          if (mxy(1)%mp(1) < 0) x = -x
      endif

!             Determine which method to use.

!             nmethd = 1 means use exp(x**2) * (1 - erf(x)),
!                    = 2 means use the continued fraction expansion.

      c1 = (dlogmb*(ndig+6))**0.7d0/9
      call fmovun_xe(mxy(1), xe)
      if (xe < 1) then
          nmethd = 1
      else if (x <= c1) then
          nmethd = 1
      else
          nmethd = 2
      endif

      if (nmethd == 1) then
          call fmerfcs_m1(mxy, mresult, ndsave, numtry, x)
      else if (nmethd == 2) then
          call fmerfcs_m2(mxy, mresult)
      endif

      return
      end subroutine fmerfcs_m

      subroutine fmerfcs_m1(mxy, mresult, ndsave, numtry, x)

!  Method 1 for computing erfc_scaled(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(13), mresult
      integer :: ndsave, numtry
      double precision :: x
      intent (in) :: numtry, ndsave, x
      intent (inout) :: mxy, mresult

      integer :: iextra

!             Method 1.  Use erf.

      if (numtry <= 0 .and. ncall <= 1 .and. ndig < 100) then
          ndig = max(ndsave+ngrd52, ndig-1)
      endif
      if (x < 2) then
          raise_ndig = 1
          call fmerf(mxy(1), mxy(4))
          raise_ndig = 0
          call fmi2m(1, mxy(2))
          call fmsub(mxy(2), mxy(4), mxy(3))
          call fmsqr(mxy(1), mxy(2))
          call fmexp(mxy(2), mxy(4))
          call fmmpy_r1(mxy(3), mxy(4))
          call fmeq(mxy(3), mresult)
          return
      endif

!             Raise precision to compensate for cancellation if x is large.

      iextra = max(int((x*x+log(2*x))/alogmb+1), 0)
      if (iextra > 0) then
          call fmequ_r1(mxy(1), ndig, ndig+iextra)
      endif
      ndig = ndig + iextra
      raise_ndig = 1
      call fmerf(mxy(1), mxy(4))
      raise_ndig = 0
      call fmi2m(1, mxy(2))
      call fmsub(mxy(2), mxy(4), mxy(3))
      call fmsqr(mxy(1), mxy(2))
      call fmexp(mxy(2), mxy(4))
      call fmmpy_r1(mxy(3), mxy(4))

      call fmeq(mxy(3), mresult)

      return
      end subroutine fmerfcs_m1

      subroutine fmerfcs_m2(mxy, mresult)

!  Method 2 for computing erfc_scaled(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(13), mresult
      intent (inout) :: mxy, mresult

      integer :: j, ndsav2, nterms

!             Method 2.  Use the continued fraction expansion.

!             mxy(2) is abs(x).
!             mxy(3) is abs(2x).
!             mxy(13) is the current approximation.
!             mxy(10) is the term in the sum, s(k).
!             mxy(8), mxy(9) are the latest denominators, q(k-1) and q(k).

      call fmabs(mxy(1), mxy(2))
      call fmmpyi(mxy(2), 2, mxy(3))
      call fmi2m(0, mxy(8))
      call fmi2m(1, mxy(9))
      call fmi2m(1, mxy(10))
      call fmi2m(0, mxy(13))
      nterms = int(intmax/10)

!             Continued fraction loop.

      ndsav2 = ndig
      do j = 1, nterms
         if (mod(j, 2) == 1) then
             call fmeq(mxy(2), mxy(11))
             call fmcsmpy_r1(mxy(11), mxy(9))
         else
             call fmeq(mxy(3), mxy(11))
             call fmcsmpy_r1(mxy(11), mxy(9))
         endif
         if (j == 1) then
             call fmeq(mxy(11), mxy(7))
             call fmi2m(1, mxy(5))
             call fmpi(mxy(12))
             call fmsqrt(mxy(12), mxy(6))
             call fmdiv(mxy(5), mxy(6), mxy(10))
             call fmdiv_r1(mxy(10), mxy(2))
             if (mxy(10)%mp(2) == mexpun) then
                 call fmeq(mxy(10), mresult)
                 return
             endif
         else
             call fmcsmpyi(mxy(8), j-1, mxy(12))
             call fmadd(mxy(11), mxy(12), mxy(7))
             call fmcsmpy_r1(mxy(10), mxy(12))
             call fmeq(mxy(10), mxy(5))
             call fmcsdiv(mxy(5), mxy(7), mxy(10))
             call fmnegate(mxy(10))
         endif
         call fmeq(mxy(9), mxy(8))
         call fmeq(mxy(7), mxy(9))
         ndig = ndsav2
         call fmcsadd_r1(mxy(13), mxy(10))

!             Check for convergence.

         if (j > 1 .and. kflag == 1) then
             exit
         endif
         ndig = min(ndsav2, max(ngrd22, ndsav2-int(mxy(13)%mp(2)-mxy(10)%mp(2))))
         if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         if (j == nterms) then
             call fmunknown(mresult)
             return
         endif
      enddo

      call fmeq(mxy(13), mresult)

      return
      end subroutine fmerfcs_m2

      subroutine fmerfcs_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = erfc_scaled(ma).

!  kresult = 1 is returned if a special case gives the value of erfc_scaled(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      double precision :: xe, ye
      integer :: j, k, krsave, nds
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMERFCS  '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      call fmovun_xe(malocal, xe)
      if (kround /= 1 .and. xe < -ndsave) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          krsave = kround
          kround = 1
          nds = ndig
          ndig = ndig + ngrd52
          call fmequ(malocal, mxy(1), nds, ndig)
          call fmi2m(1, mxy(4))
          if (malocal%mp(2) == mexpun) then
              call fmi2m(0, mxy(2))
              call fmsub(mxy(2), mxy(1), mxy(5))
          else
              call fmpi(mxy(2))
              call fmsqrt(mxy(2), mxy(3))
              call fmdiv(mxy(4), mxy(3), mxy(5))
              call fmmpyi(mxy(5), -2, mxy(6))
              call fmmpy(mxy(1), mxy(6), mxy(5))
          endif
          call fmovun_xe(mxy(4), xe)
          call fmovun_xe(mxy(5), ye)
          if (xe - ye > ndsave) then
              call fmequ(mxy(4), mxy(6), ndig, nds)
              call fmequ(mxy(5), mxy(7), ndig, nds)
              ndig = nds
              kround = krsave
              call fmadd(mxy(6), mxy(7), mresult)
              kflag = 0
              ntrace = j
              kwarn = k
              kresult = 1
              return
          endif
          kflag = 0
          ntrace = j
          kwarn = k
          ndig = nds
          kround = krsave
      endif

      return
      end subroutine fmerfcs_sc

      subroutine fmeuler(ma)

      use fmvals
      implicit none

      type(multi) :: ma
      intent (inout) :: ma

      call fmeulr(ma)

      return
      end subroutine fmeuler

      subroutine fmeulr(ma)

!  ma = Euler's constant ( 0.5772156649... )

      use fmvals
      implicit none

      type(multi) :: ma
      intent (inout) :: ma

      character(2315) :: string
      character :: st2(2315)
      integer :: j, k, ndmb, ndsave, ndsv
      type(multi), save :: mxy(1)

      call fmalloc(ma, ndig+2)

      if (mblogs /= mbase) call fmcons
      kflag = 0
      ncall = ncall + 1
      namest(ncall) = 'FMEULR'
      if (abs(ntrace) >= 2 .and. ncall <= lvltrc) then
          write (kw, "(' Input to FMEULR')")
      endif

!             Increase the working precision.

      ndsave = ndig
      if (ncall == 1) then
          k = int(5.0/alogmt + 2.0 + (real(ndig)*alogmt)**0.35/alogmt)
          ndig = max(ndig+k, 3)
      endif

!             Check to see if Euler's constant has previously been saved in base mbase with
!             sufficient precision.

      if (mbseul == mbase .and. ndgeul >= ndig) then
          call fmequ(m_euler, ma, ndgeul, ndsave)
      else

!             Euler's constant is slower to compute than the other saved constants, so more digits
!             are stored in string for quick conversion.

          ndmb = int(2300.0*2.302585/alogmb)
          if (ndmb >= ndig) then
              string = '0.57721566490153286060651209008240243104215933593992359880576723488486'//  &
              '7726777664670936947063291746749514631447249807082480960504014486542836224173997'//  &
              '6449235362535003337429373377376739427925952582470949160087352039481656708532331'//  &
              '5177661152862119950150798479374508570574002992135478614669402960432542151905877'//  &
              '5535267331399254012967420513754139549111685102807984234877587205038431093997361'//  &
              '3725530608893312676001724795378367592713515772261027349291394079843010341777177'//  &
              '8088154957066107501016191663340152278935867965497252036212879226555953669628176'//  &
              '3887927268013243101047650596370394739495763890657296792960100901512519595092224'//  &
              '3501409349871228247949747195646976318506676129063811051824197444867836380861749'//  &
              '4551698927923018773910729457815543160050021828440960537724342032854783670151773'//  &
              '9439870030237033951832869000155819398804270741154222781971652301107356583396734'//  &
              '8717650491941812300040654693142999297779569303100503086303418569803231083691640'//  &
              '0258929708909854868257773642882539549258736295961332985747393023734388470703702'//  &
              '8441292016641785024873337908056275499843459076164316710314671072237002181074504'//  &
              '4418664759134803669025532458625442225345181387912434573501361297782278288148945'//  &
              '9098638460062931694718871495875254923664935204732436410972682761608775950880951'//  &
              '2620840454447799229915724829251625127842765965708321461029821461795195795909592'//  &
              '2704208989627971255363217948873764210660607065982561990102880756125199137511678'//  &
              '2176436190570584407835735015800560774579342131449885007864151716151945657061704'//  &
              '3245075008168705230789093704614306684817916496842549150496724312183783875356489'//  &
              '4950868454102340601622508515583867234944187880440940770106883795111307872023426'//  &
              '3952269209716088569083825113787128368204911789259447848619911852939102930990592'//  &
              '5526691727446892044386971114717457157457320393520912231608508682755889010945168'//  &
              '1181016874975470969366671210206304827165895049327314860874940207006742590918248'//  &
              '7596213738423114426531350292303175172257221628324883811245895743862398703757662'//  &
              '8551303314392999540185313414158621278864807611003015211965780068117773763501681'//  &
              '8389733896639868957932991456388644310370608078174489957958324579418962026049841'//  &
              '0439225078604603625277260229196829958609883390137871714226917883819529844560791'//  &
              '6051972797360475910251099577913351579177225150254929324632502874767794842158405'//  &
              '07599290401855764599018627262'
              k = min(int(ndig * dlogmb / dlogtn + 3), len(string))
              do j = 1, k
                 st2(j) = string(j:j)
              enddo
              call fminp(st2, m_euler, 1, k)
              mbseul = mbase
              ndgeul = ndig
              if (abs(m_euler%mp(2)) > 10) ndgeul = 0
              call fmequ(m_euler, ma, ndig, ndsave)
          else
              ndsv = ndig
              ndig = ndig + 2
              call fmeulr_b(mxy(1))
              call fmeq(mxy(1), m_euler)
              mbseul = mbase
              ndgeul = ndig
              if (abs(m_euler%mp(2)) > 10) ndgeul = 0
              call fmequ(m_euler, ma, ndig, ndsave)
              ndig = ndsv
          endif
      endif

      ndig = ndsave
      if (ntrace /= 0) call fmntr_out1(ma)
      ncall = ncall - 1

      return
      end subroutine fmeulr

      subroutine fmeulr_b(mb)

!  mb = Euler's constant = .577215...

!  Binary splitting version.
!  called by fmeulr for large ndig.  Faster and saves memory by not using Bernoulli numbers.

!  Sum f(x) = 1 + x/(1!)**2 + x**2/(2!)**2 + ...
!  and g(x) = h(1)*x/(1!)**2 + h(2)*x**2/(2!)**2 + ...
!  where h(n) = 1 + 1/2 + ... + 1/n.

!  As x --> infinity, g(x)/f(x) - ln(x)/2 --> Euler's constant.

      use fmvals
      implicit none

      type(multi) :: mb
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: k, kt, n, ndsave, level_of_recursion
      type(multi), save :: mxy(7), x

      call fmalloc(mb, ndig+2)
      if (mblogs /= mbase) call fmcons
      ncall = ncall + 1
      ndsave = ndig
      if (ncall == 1) then
          k = max(ngrd52-1, 2)
          ndig = max(ndig+k, 3)
      endif
      mxsave = mxexp
      mxexp = mxexp2

!             Determine x, variable in the series.

      n = ndig*dlogmb/4
      do
         k = n
         do
            kt = k/2
            if (2*kt == k) then
                k = kt
            else
                exit
            endif
         enddo
         do
            kt = k/3
            if (3*kt == k) then
                k = kt
            else
                exit
            endif
         enddo
         do
            kt = k/5
            if (5*kt == k) then
                k = kt
            else
                exit
            endif
         enddo
         do
            kt = k/7
            if (7*kt == k) then
                k = kt
            else
                exit
            endif
         enddo
         if (k == 1) exit
         n = n + 1
      enddo

      call imi2m(n, mxy(1))
      call imsqr(mxy(1), x)

!             Determine k, the number of terms to sum in the series.

      k = 3.5912d0*n
      level_of_recursion = 0
      call fmeulr_ptdcv(0, k, mxy(1), mxy(2), mxy(3), mxy(4), mxy(5), x, level_of_recursion)
      if (mxy(3)%mp(2) >= ndig) then
          call fmeq(mxy(3), mxy(7))
      else
          call imi2fm(mxy(3), mxy(7))
      endif
      call fmsqr(mxy(7), mxy(4))
      if (mxy(2)%mp(2) >= ndig) then
          call fmeq(mxy(2), mxy(1))
      else
          call imi2fm(mxy(2), mxy(1))
      endif
      call fmdiv(mxy(1), mxy(4), mxy(6))
      call fmaddi(mxy(6), 1)

      call fmmpy(mxy(7), mxy(4), mxy(1))
      if (mxy(5)%mp(2) >= ndig) then
          call fmeq(mxy(5), mxy(4))
      else
          call imi2fm(mxy(5), mxy(4))
      endif
      call fmdiv(mxy(4), mxy(1), mxy(2))

      call fmdiv(mxy(2), mxy(6), mxy(5))
      call fmlni(n, mxy(1))
      call fmsub(mxy(5), mxy(1), mxy(3))

!             Round the result and return.

      mxexp = mxsave
      call fmequ(mxy(3), mb, ndig, ndsave)

      return
      end subroutine fmeulr_b

      recursive subroutine fmeulr_ptdcv(a, b, mp, mt, md, mc, mv, mx, level_of_recursion)

!  This routine does the binary splitting for computing Euler's constant.

      use fmvals
      implicit none

      type(multi) :: mp, mt, md, mc, mv, mx
      integer :: a, b, level_of_recursion
      intent (in) :: a, b
      intent (inout) :: mp, mt, md, mc, mv, mx, level_of_recursion

      type(multi) :: mxy(10)
      integer :: j, jp, jd, m, result_size
      real (kind(0.0d0)) :: da, db

      da = a
      db = b
      result_size = ( (db - da + 1)*mx%mp(2) ) + 5
      result_size = max(5, result_size)
      result_size = min(ndig+10, result_size)
      call fmalloc(mp, result_size)
      jp = result_size
      result_size = ( (db+1.5d0)*log(db+2) - db + 1/(12*(db+2)) -  &
                    ( (da+0.5d0)*log(da+1) - da + 1/(12*(da+1)) ) - 1 ) / dlogmb + 10
      result_size = min(ndig+10, result_size)
      call fmalloc(md, result_size)
      jd = result_size
      call fmalloc(mc, result_size)
      call imi2m(a, mxy(1))
      if (mxy(1)%mp(2) > mx%mp(2)) then
          result_size = mx%mp(2) + 4*jd
      else
          result_size = jp + 2*jd
      endif
      result_size = min(ndig+10, result_size)
      call fmalloc(mt, result_size)
      result_size = result_size + jd
      result_size = min(ndig+10, result_size)
      call fmalloc(mv, result_size)
      level_of_recursion = level_of_recursion + 1

      if (b-a < 12) then
          call fmalloc(mxy(1), result_size)
          call fmalloc(mxy(2), result_size)
          call fmalloc(mxy(3), result_size)
          call fmalloc(mxy(4), result_size)
          call fmalloc(mxy(5), result_size)

          call imi2m(b-a+1, mxy(2))
          call impwr(mx, mxy(2), mp)

          call imi2m(1, md)
          do j = a, b-1, 2
             call immpyi(md, j+1, mxy(1))
             call immpyi(mxy(1), j+2, md)
          enddo
          if (mod(b-a, 2) == 0) then
              call immpyi(md, b+1, mxy(1))
              call imeq(mxy(1), md)
          endif

          call imi2m(0, mc)
          do j = a, b
             call imdivi(md, j+1, mxy(2))
             call imadd(mc, mxy(2), mxy(3))
             call imeq(mxy(3), mc)
          enddo

!             mt is the t sum
!             mxy(1) is the next term
!             mv is the v sum
!             mxy(3) is the harmonic sum in the v terms

          call imi2m(0, mt)
          call imi2m(0, mv)
          call imsqr(md, mxy(1))
          call imi2m(0, mxy(3))
          do j = a, b
             call imdivi(mxy(1), j+1, mxy(2))
             call imdivi(mxy(2), j+1, mxy(1))
             call immpy(mxy(1), mx, mxy(2))
             call imeq(mxy(2), mxy(1))
             call imadd(mt, mxy(1), mxy(2))
             call imeq(mxy(2), mt)

             call imdivi(md, j+1, mxy(4))
             call imadd(mxy(3), mxy(4), mxy(5))
             call imeq(mxy(5), mxy(3))
             call immpy(mxy(1), mxy(3), mxy(5))
             call imadd(mv, mxy(5), mxy(2))
             call imeq(mxy(2), mv)
          enddo
      else

          m = a/2 + b/2 + mod(a, 2)*mod(b, 2)
          call fmeulr_ptdcv(a, m-1, mxy(1), mxy(2), mxy(3), mxy(4), mxy(5), mx, level_of_recursion)
          call fmeulr_ptdcv(m, b, mxy(6), mxy(7), mxy(8), mxy(9), mxy(10), mx, level_of_recursion)
          call im_or_fm_mpy(mxy(1), mxy(7), mt)
          call im_or_fm_sqr(mxy(8), mp)
          call im_or_fm_mpy(mxy(4), mxy(8), md)

!             mp and mc are not needed in fmeulr_b, so their calculations can be skipped at the
!             top level of the recursion.

          if (level_of_recursion > 1) then
              call im_or_fm_mpy(mxy(9), mxy(3), mxy(4))
              call im_or_fm_add(md, mxy(4), mc)
          else
              call imi2m(0, mc)
          endif

          call im_or_fm_mpy(md, mt, mxy(4))
          call im_or_fm_mpy(mp, mxy(8), mv)
          call im_or_fm_mpy(mv, mxy(5), mxy(9))
          call im_or_fm_add(mxy(9), mxy(4), mv)
          call im_or_fm_mpy(mxy(3), mxy(1), mxy(4))
          call im_or_fm_mpy(mxy(4), mxy(10), mxy(9))
          call im_or_fm_add(mv, mxy(9), mxy(4))
          call im_or_fm_eq(mxy(4), mv)

          call im_or_fm_mpy(mxy(3), mxy(8), md)

          call im_or_fm_mpy(mp, mxy(2), mxy(3))
          call im_or_fm_add(mxy(3), mt, mxy(8))
          call im_or_fm_eq(mxy(8), mt)

          if (level_of_recursion > 1) then
              call im_or_fm_mpy(mxy(1), mxy(6), mp)
          else
              call imi2m(0, mp)
          endif
      endif

      level_of_recursion = level_of_recursion - 1

      return
      end subroutine fmeulr_ptdcv

      subroutine fmexit0(mxsave, ndsave)

!  At the end of a function this routine resets precision and the overflow/underflow threshold
!  to the values from the start of that function.

      use fmvals
      implicit none

      real (kind(1.0d0)) :: mxsave
      integer :: ndsave
      intent (inout) :: mxsave, ndsave

      mxexp = mxsave
      ndig = ndsave
      if (kflag == 1) kflag = 0
      if (kflag < 0) call fmwarn
      ncall = ncall - 1

      return
      end subroutine fmexit0

      subroutine fmexit1(ma, mb, kovun, mxsave, ndsave)

!  At the end of a function this routine checks for tracing the output argument,
!  rounds ma from precision ndig to precision ndsave as the returned function value mb,
!  and resets precision, and the overflow/underflow threshold to the values from the
!  start of that function.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (in) :: ma
      intent (inout) :: mb, kovun, mxsave, ndsave

      integer :: kfsave, kwrnsv

      kwrnsv = kwarn
      kwarn = 0
      mxexp = mxsave
      kfsave = kflag
      call fmequ(ma, mb, ndig, ndsave)
      if (kflag /= -5 .and. kflag /= -6) kflag = kfsave
      ndig = ndsave
      kwarn = kwrnsv
      if (kflag == 1) kflag = 0
      if (kflag >= 0 .or. kflag == -4 .or. kflag == -5 .or. kflag == -6) then
          if (mb%mp(2) == munkno) kflag = -4
          if (mb%mp(2) == mexpov) kflag = -5
          if (mb%mp(2) == mexpun) kflag = -6
      endif
      if ((mb%mp(2) == munkno .and. kflag /= -9 .and. kovun /= 2) .or.  &
          (mb%mp(2) == mexpun .and. kovun == 0)                   .or.  &
          (mb%mp(2) == mexpov .and. kovun == 0)) then
         call fmwarn
      else if ((kflag < 0 .and. kflag > -4) .or. kflag < -6) then
         call fmwarn
      endif
      if (ntrace /= 0) call fmntr_out1(mb)
      ncall = ncall - 1

      return
      end subroutine fmexit1

      subroutine fmexit2(ma, mb, mc, md, kovun, mxsave, ndsave)

!  At the end of a function this routine checks for tracing the output argument,
!  rounds ma from precision ndig to precision ndsave as the returned function value mb,
!  and resets precision, and the overflow/underflow threshold to the values from the
!  start of that function.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (in) :: ma, mb
      intent (inout) :: mc, md, kovun, mxsave, ndsave

      integer :: kfsave, kwrnsv

      kwrnsv = kwarn
      kwarn = 0
      mxexp = mxsave
      kfsave = kflag
      call fmequ(ma, mc, ndig, ndsave)
      call fmequ(mb, md, ndig, ndsave)
      if (kflag /= -5 .and. kflag /= -6) kflag = kfsave
      ndig = ndsave
      kwarn = kwrnsv
      if (kflag == 1) kflag = 0
      if (kflag >= 0 .or. kflag == -4 .or. kflag == -5 .or. kflag == -6) then
          if (mc%mp(2) == mexpun .or. md%mp(2) == mexpun) kflag = -6
          if (mc%mp(2) == mexpov .or. md%mp(2) == mexpov) kflag = -5
          if (mc%mp(2) == munkno .or. md%mp(2) == munkno) kflag = -4
      endif
      if ((mc%mp(2) == munkno .and. kflag /= -9 .and. kovun /= 2) .or.  &
          (md%mp(2) == munkno .and. kflag /= -9 .and. kovun /= 2) .or.  &
          (abs(mc%mp(2)) == mexpov .and. kovun == 0)              .or.  &
          (abs(md%mp(2)) == mexpov .and. kovun == 0)) then
         call fmwarn
      else if ((kflag < 0 .and. kflag > -4) .or. kflag < -6) then
         call fmwarn
      endif
      if (ntrace /= 0) call fmntr_out2(mc, md)
      ncall = ncall - 1

      return
      end subroutine fmexit2

      subroutine fmexp(ma, mb)

!  mb = exp(ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(4), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmexp_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmexp_m1(ma, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmexp

      subroutine fmexp2(ma, mb)

!  mb = exp(ma)

!  Internal exponential routine (called with 0 < ma <= 1).

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: maxv
      real (kind(0.0d0)) :: x1, x2, x3, f1, f2, f3, pi
      integer :: j, j2, k, k2, kexp, kl, ktwo, l, l2, n2, nbig, nbot, ndsav1, ndsave, nterm, ntop
      real :: alog2, alogt, b, t, tj, xn
      type(multi), save :: mxy(4), mjsums(ljsums)

      call fmalloc(mb, ndig+2)

      if (mblogs /= mbase) call fmcons
      ndsave = ndig
      if (ma%mp(2) == 1) then

!             Special case exp(1).

          t = ndig
          xn = t*alogmb/log(t)
          k = int(log(xn)/alogmb)
          ndig = max(ndig+k, 3)
          ndsav1 = ndig

          if (ndsave < 100) then

!             If precision is not very high, use the direct series  e = 1/0! + 1/1! + 1/2! + ...
!             Do as much of the work as possible using small integers to minimize the number of
!             FM calls.  Reduce ndig while computing each term in the sum as the terms get smaller.

              call fmi2m(2, mxy(2))
              call fmi2m(1, mxy(1))
              j = 2
              nbig = int(mxbase)
              kl = 1
              do while (kl > 0)
                 ntop = 1
                 nbot = j
                 do while (nbot <= nbig/(j+1))
                    j = j + 1
                    ntop = j*ntop + 1
                    nbot = j*nbot
                 enddo

                 call fmcsdivi_r1(mxy(1), nbot)
                 if (ntop > 1) then
                     call fmcsmpyi(mxy(1), ntop, mxy(3))
                     ndig = ndsav1
                     call fmadd_r1(mxy(2), mxy(3))
                     ndig = ndsav1 - int(mxy(2)%mp(2)-mxy(3)%mp(2))
                     if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                 else
                     ndig = ndsav1
                     call fmadd_r1(mxy(2), mxy(1))
                     ndig = ndsav1 - int(mxy(2)%mp(2)-mxy(1)%mp(2))
                     if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                 endif
                 if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                 if (kflag /= 1) then
                     j = j + 1
                 else
                     kl = 0
                 endif
              enddo

              ndig = ndsave
              kflag = 0
              call fmequ(mxy(2), mb, ndsav1, ndsave)
          else

!             If precision is high, use the binary splitting method for summing the direct series.

!             Determine k, the number of terms to sum in the series for e.

              x1 = 1.184*ndig*dlogmb/log(ndig*dlogmb) + 1.95*real(ndig)**0.777 + 10
              pi = acos(-1.0d0)
              f1 = ndig*dlogmb - (x1 + 0.5)*log(x1) + x1 - log(2.0*pi)/2 - 1/(12.0*x1)
              if (f1 < 0) then
                  x2 = 0.9*x1
              else
                  x2 = 1.1*x1
              endif
              f2 = ndig*dlogmb - (x2 + 0.5)*log(x2) + x2 - log(2.0*pi)/2 - 1/(12.0*x2)
              x3 = x2
              do j = 1, 5
                 x3 = x2 - f2*(x2 - x1)/(f2 - f1)
                 f3 = ndig*dlogmb - (x3 + 0.5)*log(x3) + x3 - log(2.0*pi)/2 - 1/(12.0*x3)
                 if (abs(x3-x2) < 0.1) exit
                 x1 = x2
                 f1 = f2
                 x2 = x3
                 f2 = f3
              enddo

              k = x3 + 10
              call fmexp2_tq(0, k, mxy(1), mxy(2))
              if (mxy(1)%mp(2) >= ndig .and. mxy(2)%mp(2) >= ndig) then
                  call fmdiv_r2(mxy(1), mxy(2))
                  ndig = ndsave
                  kflag = 0
                  call fmequ(mxy(2), mb, ndsav1, ndsave)
              else
                  call imi2fm(mxy(1), mxy(3))
                  call imi2fm(mxy(2), mxy(4))
                  call fmdiv(mxy(3), mxy(4), mxy(2))
                  ndig = ndsave
                  kflag = 0
                  call fmequ(mxy(2), mb, ndsav1, ndsave)
              endif
          endif
          return
      endif

!             Here is the general case.  Compute exp(ma) where 0 < ma < 1.

!             Use the direct series
!                  exp(x) = 1 + x + x**2/2! + x**3/3! + ...

!             The argument will be halved k2 times before the series is summed.  The series will be
!             added as j2 concurrent series.

      b = real(mbase)
      k = ngrd52
      t = max(ndig-k, 2)
      alog2 = real(dlogtw)
      alogt = log(t)
      tj = 0.87*(ndig*alogmt)**0.3333 - 1.3
      j2 = int(tj)
      j2 = max(1, min(j2, ljsums))
      k2 = max(2, int(2.0*(ndig*alogmt)**0.3333 - 0.5))

      tj = -(real(ma%mp(2))*alogmb +  &
             log(real(ma%mp(3))/b + real(ma%mp(4))/(b*b)))/alog2 - 0.3
      if (tj >= k2) then
          l = k2
      else if (tj > 0) then
          l = int(tj)
      else
          l = 0
      endif
      k2 = k2 - l
      if (k2 <= 0) then
          k2 = 0
          j2 = int(.43*sqrt(t*alogmb/(alogt+real(l)*alog2)) + .33)
          j2 = max(1, min(j2, ljsums))
      endif

      n2 = int(t*alogmb/(alogt+real(l)*alog2))
      l2 = int(log(real(n2)+2.0d0**k2)/alogmb)
      ndig = ndig + l2
      ndsav1 = ndig

!             Halve the argument k2 times.

      call fmequ(ma, mxy(1), ndsave, ndig)
      ktwo = 1
      maxv = mxbase/2
      if (k2 > 0) then
          do j = 1, k2
             ktwo = 2*ktwo
             if (ktwo > maxv) then
                 call fmcsdivi_r1(mxy(1), ktwo)
                 ktwo = 1
             endif
          enddo
          if (ktwo > 1) call fmcsdivi_r1(mxy(1), ktwo)
      endif

!             Sum the series x + x**2/2! + x**3/3! + ....
!             Split into j2 concurrent sums and reduce ndig while computing each term in the sum as
!             the terms get smaller.

      call fmeq(mxy(1), mxy(2))
      nterm = 1
      do j = 1, j2
         call fmcsdivi_r1(mxy(2), nterm)
         nterm = nterm + 1
         call fmeq(mxy(2), mjsums(j))
      enddo

      if (mxy(1)%mp(2) >= -ndig) then
          call fmipwr(mxy(1), j2, mxy(3))
          kl = 1
          do while (kl > 0)
             call fmcsmpy_r1(mxy(2), mxy(3))
             do j = 1, j2
                call fmcsdivi_r1(mxy(2), nterm)
                ndig = ndsav1
                call fmcsaddnn_r1(mjsums(j), mxy(2))
                if (kflag /= 0) then
                    kl = 0
                    exit
                endif
                ndig = ndsav1 - int(mjsums(j)%mp(2)-mxy(2)%mp(2))
                if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                nterm = nterm + 1
             enddo
          enddo
      endif

!             Put the j2 separate sums back together.

      kflag = 0
      call fmcsnsums(j2, mjsums)
      call fmeq(mjsums(j2), mxy(3))
      do j = 2, j2
         call fmcsmpy_r1(mxy(3), mxy(1))
         call fmadd_r1(mxy(3), mjsums(j2-j+1))
      enddo

!             Reverse the effect of halving the argument to compute exp(ma).

      ndig = ndsav1
      if (k2 > 0) then
          if (ndsave <= 20) then
              call fmi2m(2, mxy(1))
              do j = 1, k2
                 kexp = mxy(3)%mp(2)
                 if (mbase == 2 .or. kexp > 0) then
                     call fmadd(mxy(3), mxy(1), mxy(2))
                 else
                     do k = 1, 3-kexp
                        mxy(2)%mp(k) = mxy(1)%mp(k)
                     enddo
                     do k = 4-kexp, ndig+2
                        mxy(2)%mp(k) = mxy(3)%mp(k-1+kexp)
                     enddo
                 endif
                 call fmcsmpy_r1(mxy(3), mxy(2))
              enddo
          else
              do j = 1, k2
                 call fmsqr(mxy(3), mxy(2))
                 call fmadd(mxy(3), mxy(3), mxy(1))
                 call fmadd(mxy(2), mxy(1), mxy(3))
              enddo
          endif
      endif
      call fmi2m(1, mxy(1))
      call fmadd(mxy(1), mxy(3), mxy(2))

      call fmequ(mxy(2), mb, ndsav1, ndsave)
      ndig = ndsave

      return
      end subroutine fmexp2

      recursive subroutine fmexp2_tq(a, b, mt, mq)

!  This routine does the binary splitting for computing the constant e.
!  When a is zero, e is approximated by mt/mq.

      use fmvals
      implicit none

      integer :: a, b
      type(multi) :: mt, mq
      intent (in) :: a, b
      intent (inout) :: mt, mq

      type(multi) :: mxy(4)
      integer :: j, km, result_size
      real (kind(0.0d0)) :: da, db

      da = a
      db = b

      if (b-a < 25) then
          result_size = ( (db+0.5d0)*log(db+1) - db + 1/(12*(db+1)) -  &
                        ( (da+0.5d0)*log(da+1) - da + 1/(12*(da+1)) ) + 10 ) / dlogmb + 8
          result_size = max(5, result_size)
          call fmalloc(mt, result_size)
          call fmalloc(mq, result_size)
          call fmalloc(mxy(1), result_size)
          call fmalloc(mxy(2), result_size)
          call fmalloc(mxy(3), result_size)
          call fmalloc(mxy(4), result_size)
          call imi2m(1, mt)
          call imi2m(1, mxy(1))
          do j = 0, b-a-2, 2
             call immpyi(mxy(1), b-j, mxy(2))
             call imadd(mt, mxy(2), mxy(3))
             call immpyi(mxy(2), b-j-1, mxy(1))
             call imadd(mxy(3), mxy(1), mt)
          enddo
          if (mod(b-a, 2) == 1) then
              call immpyi(mxy(1), a+1, mxy(2))
              call imadd(mt, mxy(2), mxy(3))
              call imeq(mxy(3), mt)
          endif

          if (a == 0) then
              call imi2m(1, mq)
          else
              call imi2m(a, mq)
          endif
          do j = a+1, b-1, 2
             call immpyi(mq, j, mxy(1))
             call immpyi(mxy(1), j+1, mq)
          enddo
          if (mod(b-a+1, 2) == 0) then
              call immpyi(mq, b, mxy(1))
              call imeq(mxy(1), mq)
          endif
          return
      endif

      km = a/2 + b/2 + mod(a, 2)*mod(b, 2)
      call fmexp2_tq(a, km-1, mxy(1), mxy(2))
      call fmexp2_tq(km, b, mxy(3), mxy(4))

      call im_or_fm_mpy(mxy(2), mxy(4), mq)

      call im_or_fm_mpy(mxy(1), mxy(4), mxy(2))
      call im_or_fm_add(mxy(3), mxy(2), mt)

      return
      end subroutine fmexp2_tq

      subroutine fmexp_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing exp(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      character(155) :: string
      character :: st2(155)
      integer :: iextra, j, k, kt, kwrnsv, ndmb, ndsv, nmethd
      logical :: kt_large

      call fmequ(ma, mxy(2), ndsave, ndig)

!             Split ma into integer and fraction parts.  Work with a positive argument.
!             mxy(1) = integer part of abs(ma)
!             mxy(2) = fraction part of abs(ma)

      mxy(2)%mp(1) = 1
      call fmint(mxy(2), mxy(1))
      call fmsub_r1(mxy(2), mxy(1))

!             If the integer part is not zero, compute e**(mxy(1)).

      kwrnsv = kwarn
      kwarn = 0
      call fmm2i(mxy(1), kt)
      kt_large = .false.
      if (kt < 0) then
          kt_large = .true.
          kt = huge(kt)
      endif
      kwarn = kwrnsv
      if (kt /= 0) then

!             Compute iextra, the number of extra digits required to get exp(kt) correct to the
!             current precision.

          iextra = int(log(real(kt))/alogmb + 0.5)
          if (iextra > 0) then
              call fmequ_r1(mxy(2), ndig, ndig+iextra)
          endif
          ndig = ndig + iextra

!             Check whether the current precision of e is large enough.

          if (mbse /= mbase .or. ndig > ndige) then
              ndmb = int(150.0*2.302585/alogmb)
              if (ndmb >= ndig) then
                  string = '2.718281828459045235360287471352662497757247'//  &
                  '09369995957496696762772407663035354759457138217852516'//  &
                  '6427427466391932003059921817413596629043572900334295261'
                  k = min(int((ndig-1) * dlogmb / dlogtn + 3), len(string))
                  do j = 1, k
                     st2(j) = string(j:j)
                  enddo
                  call fminp(st2, mesav, 1, k)
                  mbse = mbase
                  ndige = ndig
                  if (abs(mesav%mp(2)) > 10) ndige = 0
              else
                  ndsv = ndig
                  ndig = ndig + 2 + ndig/100
                  call fmi2m(1, mesav)
                  call fmexp2(mesav, mxy(4))
                  call fmeq(mxy(4), mesav)
                  mbse = mbase
                  ndige = ndig
                  if (abs(mesav%mp(2)) > 10) ndige = 0
                  ndig = ndsv
              endif
          endif
      endif

!             Now do the fraction part of ma and combine the results.

      kwrnsv = kwarn
      kwarn = 0
      nmethd = 1
      if (ndig > 50) nmethd = 2
      if (mxy(2)%mp(3) /= 0 .and. kt > 0 .and. nmethd == 1) then
          call fmexp2(mxy(2), mxy(4))
          if (kt_large) then
              call fmexp_m2(ma, mesav, mxy(3), ndsave)
          else
              call fmipwr(mesav, kt, mxy(3))
          endif
          call fmmpy(mxy(4), mxy(3), mxy(2))
      else if (mxy(2)%mp(3) /= 0 .and. kt == 0 .and. nmethd == 1) then
          call fmexp2(mxy(2), mxy(4))
          call fmeq(mxy(4), mxy(2))
      else if (mxy(2)%mp(3) /= 0 .and. kt > 0 .and. nmethd == 2) then
          ndsv = ndig
          ndig = ndig + ngrd21
          call fmequ_r1(mxy(2), ndsv, ndig)
          if (mxy(2)%mp(2) >= 0) then
              call fmcosh2(mxy(2), mxy(4))
              call fmsqr(mxy(4), mxy(3))
              call fmi2m(-1, mxy(1))
              call fmadd_r1(mxy(3), mxy(1))
              call fmsqrt_r1(mxy(3))
              call fmadd(mxy(4), mxy(3), mxy(2))
          else
              call fmsinh2(mxy(2), mxy(4))
              call fmsqr(mxy(4), mxy(3))
              call fmi2m(1, mxy(1))
              call fmadd_r1(mxy(3), mxy(1))
              call fmsqrt_r1(mxy(3))
              call fmadd(mxy(4), mxy(3), mxy(2))
          endif
          ndig = ndsv
          if (kt_large) then
              call fmexp_m2(ma, mesav, mxy(3), ndsave)
          else
              call fmipwr(mesav, kt, mxy(3))
          endif
          call fmmpy_r1(mxy(2), mxy(3))
      else if (mxy(2)%mp(3) /= 0 .and. kt == 0 .and. nmethd == 2) then
          ndsv = ndig
          ndig = ndig + ngrd21
          call fmequ_r1(mxy(2), ndsv, ndig)
          if (mxy(2)%mp(2) >= 0) then
              call fmcosh2(mxy(2), mxy(4))
              call fmsqr(mxy(4), mxy(3))
              call fmi2m(-1, mxy(1))
              call fmadd_r1(mxy(3), mxy(1))
              call fmsqrt_r1(mxy(3))
              call fmadd(mxy(4), mxy(3), mxy(2))
          else
              call fmsinh2(mxy(2), mxy(4))
              call fmsqr(mxy(4), mxy(3))
              call fmi2m(1, mxy(1))
              call fmadd_r1(mxy(3), mxy(1))
              call fmsqrt_r1(mxy(3))
              call fmadd(mxy(4), mxy(3), mxy(2))
          endif
          ndig = ndsv
      else if (mxy(2)%mp(3) == 0 .and. kt > 0) then
          if (kt_large) then
              call fmexp_m2(ma, mesav, mxy(2), ndsave)
          else
              call fmipwr(mesav, kt, mxy(2))
          endif
      else
          call fmi2m(1, mxy(2))
      endif

!             Invert if ma was negative.

      if (ma%mp(1) < 0) then
          call fmi2m(1, mxy(1))
          call fmdiv_r2(mxy(1), mxy(2))
      endif
      kwarn = kwrnsv
      call fmeq(mxy(2), mresult)

      return
      end subroutine fmexp_m1

      subroutine fmexp_m2(ma, mb, mc, ndsave)

!  Internal routine to compute mc = mb**int(abs(ma)).

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      integer :: ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mc

      type(multi), save :: mxy(5)

      call fmequ(ma, mxy(2), ndsave, ndig)
      mxy(2)%mp(1) = 1
      call fmint(mxy(2), mxy(1))

      call fmi2m(2, mxy(2))
      call fmmod(mxy(1), mxy(2), mxy(3))
      if (mxy(3)%mp(3) == 0) then
          call fmi2m2(1, mxy(3))
      else
          call fmeq(mb, mxy(3))
      endif
      call fmeq(mb, mxy(2))

!             This is the multiplication loop.

      do while (mxy(1)%mp(2) > 1 .or.  &
               (mxy(1)%mp(2) == 1 .and.  mxy(1)%mp(3) > 1))
         call fmdivi(mxy(1), 2, mxy(5))
         call fmint(mxy(5), mxy(1))
         call fmsqr2_r1(mxy(2))
         call fmi2m(2, mxy(5))
         call fmmod(mxy(1), mxy(5), mxy(4))
         if (mxy(4)%mp(3) == 1) call fmmpy2_r2(mxy(2), mxy(3))
      enddo
      call fmeq(mxy(3), mc)

      return
      end subroutine fmexp_m2

      subroutine fmexp_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = exp(ma).

!  kresult = 1 is returned if a special case gives the value of exp(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j, k, kl, nds
      double precision :: b, d, xe, xf, ye, yf, z1, z2, ze, zf

      kresult = 0

      namest(ncall) = 'FMEXP    '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, mxy(1), ndsave, ndig)

      if (mxy(1)%mp(2) == munkno .and. mxy(1)%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      if (mxy(1)%mp(2) == munkno) then
          call fmunknown(mxy(3))
          if (huge(mbase)/mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          call fmovun_xexf(mxy(1), xe, xf)
          xe = abs(xe)
          ze = log( (huge(mbase)/d) * dlogmb ) / dlogmb
          if (xe > ze) then
              if (mxy(1)%mp(4) > 0) then
                  if (mxy(1)%mp(1) > 0) then
                      call fmoverflow(1, mresult)
                      mresult%mp(4) = huge(mbase)/d
                      mresult%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
                  else
                      call fmunderflow(1, mresult)
                      mresult%mp(4) = -huge(mbase)/d
                      mresult%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
                  endif
              else
                  call fmi2m(1, mresult)
                  if (kround /= 1) then
                      call fmulp(mresult, mxy(3))
                      mxy(3)%mp(2) = mxy(3)%mp(2) - 2
                      if (mxy(1)%mp(1) > 0) then
                          call fmadd_r1(mresult, mxy(3))
                      else
                          call fmsub_r1(mresult, mxy(3))
                      endif
                  endif
                  kflag = 0
              endif
              kresult = 1
              return
          endif

          call fmovun_xexf(mxy(1), xe, xf)
          xe = abs(xe)
          b = mbase
          ye = aint(b**xe * xf / dlogmb) + 1
          yf = b**xe * xf - ye*dlogmb
          if (-2*dlogmb <= yf .and. yf < -dlogmb) then
              ye = ye - 1
              yf = yf + dlogmb
          else if (0 <= yf .and. yf < dlogmb) then
              ye = ye + 1
              yf = yf - dlogmb
          endif
          if (-dlogmb <= yf .and. yf < 0) then
              yf = exp(b**xe * xf - ye*dlogmb)
          else
              yf = 1.0d0 - epsilon(1.0d0)
          endif
          if (mxy(1)%mp(1) < 0) then
              ye = -ye + 1
              yf = 1/(b*yf)
              if (yf == 1) then
                  ye = ye + 1
                  yf = yf / b
              endif
          endif
          mxy(3)%mp(4) = ye
          mxy(3)%mp(5) = -yf*maxint
          if (ye > mxexp0) mxy(3)%mp(2) = mexpov
          if (ye < -mxexp0) mxy(3)%mp(2) = mexpun
          call fmeq(mxy(3), mresult)
          kresult = 1
          return
      endif
      if (mxy(1)%mp(2) == mexpov) then
          if (huge(mbase)/mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          if (mxy(1)%mp(1) > 0) then
              call fmoverflow(1, mresult)
              mresult%mp(4) = huge(mbase)/d
              mresult%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
          else
              call fmunderflow(1, mresult)
              mresult%mp(4) = -huge(mbase)/d
              mresult%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
          endif
          kresult = 1
          return
      else if (mxy(1)%mp(3) == 0) then
          call fmi2m(1, mresult)
          kresult = 1
          return
      else if (mxy(1)%mp(2) == mexpun) then
          call fmi2m(1, mresult)
          call fmadd_r1(mresult, mxy(1))
          kresult = 1
          return
      else
          kl = 0
          if (huge(mbase)/mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          call fmovun_xexf(mxy(1), xe, xf)
          b = mbase
          z1 = xe*log(b) + log(xf) - log(log(b))
          z2 = log(huge(mbase)/d)
          if (z1 > z2) then
              if (mxy(1)%mp(1) > 0) then
                  call fmoverflow(1, mxy(2))
                  ze = huge(mbase)/d
                  zf = 1.0d0 - epsilon(1.0d0)
              else
                  call fmunderflow(1, mxy(2))
                  ze = -huge(mbase)/d
                  zf = 1.0d0 - epsilon(1.0d0)
              endif
              mxy(2)%mp(4) = ze
              mxy(2)%mp(5) = -maxint * zf
              kl = 1
          else
              if (mxy(1)%mp(1) > 0) then
                  z2 = mxexp+1
                  z2 = log(z2)
                  if (z1 > z2) then
                      call fmoverflow(1, mxy(2))
                      ze = b**xe * xf / log(b)
                      if (ze == ze + 1) then
                          zf = 1.0d0 - epsilon(1.0d0)
                      else
                          z1 = aint(ze)
                          if (ze - z1 == 0) then
                              ze = z1 + 1
                              zf = 1/b
                          else
                              z1 = z1 + 1
                              zf = b**( ze - z1 )
                              ze = z1
                          endif
                      endif
                      if (zf == 0) then
                          ze = ze + 1
                          zf = 1/b
                      endif
                      mxy(2)%mp(4) = ze
                      mxy(2)%mp(5) = -maxint * zf
                      kl = 1
                  endif
              else
                  z2 = mxexp
                  z2 = log(z2)
                  if (z1 > z2) then
                      call fmunderflow(1, mxy(2))
                      ze = -(b**xe * xf / log(b))
                      if (ze == ze + 1) then
                          zf = 1.0d0 - epsilon(1.0d0)
                      else
                          z1 = aint(ze)
                          if (ze - z1 == 0) then
                              ze = z1 + 1
                              zf = 1/b
                          else
                              zf = b**( ze - z1 )
                              ze = z1
                          endif
                      endif
                      if (zf == 0) then
                          ze = ze + 1
                          zf = 1/b
                      endif
                      mxy(2)%mp(4) = ze
                      mxy(2)%mp(5) = -maxint * zf
                      kl = 1
                  endif
              endif
          endif
          if (kl == 1) then
              call fmeq(mxy(2), mresult)
              if (mresult%mp(2) == mexpun) kflag = -6
              kresult = 1
              return
          endif
      endif

      if (ndig > 1000) then
          nds = ndig
          ndig = ndig + 100 + ndig/100
          call fmalloc(mwa, 2*ndig+30)
          ndig = nds
      endif

      if (mblogs /= mbase) call fmcons

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (kround /= 1 .and. ma%mp(2) < -ndsave) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          call fmi2m(1, mxy(2))
          call fmadd(mxy(2), mxy(1), mresult)
          kflag = 0
          ntrace = j
          kwarn = k
          kresult = 1
          return
      endif

      return
      end subroutine fmexp_sc

      subroutine fmfact(ma, mb)

!  mc = ma!    ( = gamma(ma+1))

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(2), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmfact_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call fmfact_m1(ma, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmfact

      subroutine fmfact_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing ma!.

      use fmvals
      implicit none

      type(multi) :: ma, mxy(2), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      call fmequ(ma, mxy(1), ndsave, ndig)
      call fmaddi(mxy(1), 1)
      in_fact = 1
      call fmgam(mxy(1), mresult)
      in_fact = 0

      return
      end subroutine fmfact_m1

      subroutine fmfact_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = ma!.

!  kresult = 1 is returned if a special case gives the value of ma!.

      use fmvals
      implicit none

      type(multi) :: ma, mxy(2), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j, k
      double precision :: xe
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMFACT   '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      call fmovun_xe(malocal, xe)
      if (kround /= 1 .and. xe < -ndsave) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          call fmeulr(mxy(1))
          call fmmpy(mxy(1), malocal, mxy(2))
          call fmi2m(1, mxy(1))
          call fmsub(mxy(1), mxy(2), mresult)
          kflag = 0
          ntrace = j
          kwarn = k
          kresult = 1
          return
      endif

      return
      end subroutine fmfact_sc

      subroutine fmfcti(num, ma)

!  ma = num factorial, where num is an integer.

      use fmvals
      implicit none

      integer :: num
      type(multi) :: ma
      intent (in) :: num
      intent (inout) :: ma

      integer :: j, jk, k, large

      call fmi2m(1, ma)
      if (num <= 1) then
          return
      endif
      j = num
      k = 1
      large = int(intmax/j)
      do jk = 2, j
         k = k*jk
         if (k > large) then
             call fmcsmpyi_r1(ma, k)
             k = 1
         endif
      enddo
      if (k > 1) call fmmpyi_r1(ma, k)

      return
      end subroutine fmfcti

      subroutine fmfft(a, n, a2)

!  a is returned as the fast fourier transform of the complex input array a(1:n)

!  This is not a general fft subroutine.  It is designed to be called by fm's multiplication
!  routines.  n will be a small integer times a power of 2.

      use fmvals
      implicit none
      integer :: n
      complex (kind(0.0d0)) :: a(n), a2(n)
      intent (in) :: n
      intent (inout) :: a, a2

      complex (kind(0.0d0)) :: ft(15), r_u(0:225), zi
      double precision :: pi
      integer :: h, its, j, jlists, js, jstep, k, k1, k2, l, level, lg, nl
      integer, allocatable :: first(:)

      pi = acos(-1.0d0)
      zi = cmplx( 0.0d0 , 1.0d0 , kind(1.0d0) )
      level = 0
      k = n
      do while (mod(k, 2) == 0)
         level = level + 1
         k = k / 2
      enddo

      nl = 2**level
      lg = n/nl
      allocate( first(nl) )

!             The bottom level is to do the transforms of nl lists of length lg directly from
!             the definition of the Fourier transform.
!             Generate a list of starting points in the original list for these sublists.

      jlists = 1
      first(1) = 1
      h = 1
      do j = 1, level
         do k = jlists, 1, -1
            first(2*k-1) = first(k)
            first(2*k)   = first(k) + h
         enddo
         h = 2*h
         jlists = 2*jlists
      enddo

!             Do the initial transforms.

      do j = 1, nl
         do k = 0, lg-1
            a2(1+k+(j-1)*lg) = a(first(j)+k*h)
         enddo
      enddo

      if (lg > 1) then
          do k = 0, lg-1
             do k2 = 0, lg-1
                r_u(k*k2) = exp((2*pi*zi*k*k2)/lg)
             enddo
          enddo

          do j = 1, nl

!             Do the direct Fourier transform using the definition.
!             The jth sublist has length lg and starts at a2(1+(j-1)*lg).

             do k = 1, 15
                ft(k) = 0
             enddo
             k1 = 1 + (j-1)*lg
             do k = 1, lg
                do k2 = 0, lg-1
                   ft(k) = ft(k) + a2(k2+k1) * r_u((k-1)*k2)
                enddo
             enddo
             do k = 1, lg
                a2(k+(j-1)*lg) = ft(k)
             enddo
          enddo
      endif

!             Iterate, combining pairs of lists using the Cooley-Tukey recurrence until only
!             one list remains.

      its = nint( log( dble(nl) ) / log(2.0d0) )
      jstep = its + 1
      do l = 2, its, 2

         jstep = jstep - 1
         js = -1
         k1 = 2**(jstep-1)
         if (jstep > 1) js = (n / k1) * (k1 - 1) - 1
         do k = 2, nl, 2
            k1 = (k-2)*lg
            k2 = k1 + lg
            do j = 1, lg
               a(j+k1) = a2(j+k1) + roots_of_unity(j+js) * a2(j+k2)
               a(j+k2) = a2(j+k1) - roots_of_unity(j+js) * a2(j+k2)
            enddo
         enddo

         lg = 2 * lg
         nl = nl / 2
         jstep = jstep - 1
         js = -1
         k1 = 2**(jstep-1)
         if (jstep > 1) js = (n / k1) * (k1 - 1) - 1
         do k = 2, nl, 2
            k1 = (k-2)*lg
            k2 = k1 + lg
            do j = 1, lg
               a2(j+k1) = a(j+k1) + roots_of_unity(j+js) * a(j+k2)
               a2(j+k2) = a(j+k1) - roots_of_unity(j+js) * a(j+k2)
            enddo
         enddo

         lg = 2 * lg
         nl = nl / 2

      enddo

      if (mod(its, 2) == 0) then
          do j = 1, n
             a(j) = a2(j)
          enddo
      else
          jstep = jstep - 1
          js = -1
          k1 = 2**(jstep-1)
          if (jstep > 1) js = (n / k1) * (k1 - 1) - 1
          do k = 2, nl, 2
             k1 = (k-2)*lg
             k2 = k1 + lg
             do j = 1, lg
                a(j+k1) = a2(j+k1) + roots_of_unity(j+js) * a2(j+k2)
                a(j+k2) = a2(j+k1) - roots_of_unity(j+js) * a2(j+k2)
             enddo
          enddo
      endif

      deallocate( first )

      return
      end subroutine fmfft

      subroutine fmfft_init(n)

!  Initialize roots of unity.

      use fmvals
      implicit none
      integer :: n
      intent (in) :: n

      complex (kind(0.0d0)) :: s, st
      double precision :: pi, t
      integer :: its, j, js, jstep, k, l, level, nr, n_def

      if (n_roots_of_unity == n) return

      level = 0
      k = n
      do while (mod(k, 2) == 0)
         level = level + 1
         k = k / 2
      enddo

      n_def = n / 2**level
      if (n < n_def) n_def = n
      its = nint( log( dble(n) / n_def ) / log(2.0d0) )

!             Compute the roots of unity.

      pi = acos(-1.0d0)
      t = 2*pi/n
      st = cmplx(-2*sin(pi/n)**2, sin(2*pi/n), kind(0.0d0) )
      nr = n/2
      jstep = 32
      do k = 0, nr/jstep - 1
         js = k*jstep
         s = cmplx( cos(js*t) , sin(js*t) , kind(0.0d0) )
         do j = 0, jstep - 1
            roots_of_unity(j+js) = s
            s = s + st*s
         enddo
      enddo
      k = (nr/jstep)*jstep
      do j = k, nr-1
         roots_of_unity(j) = cmplx( cos(j*t) , sin(j*t) , kind(0.0d0) )
      enddo
      l = nr - 1
      do j = 2, its
         jstep = 2**(j-1)
         do k = 0, nr-1, jstep
            l = l + 1
            roots_of_unity(l) = roots_of_unity(k)
         enddo
      enddo

      end subroutine fmfft_init

      subroutine fmfgfi(ma, mb, mc)

!  Internal routine for the two auxiliary asymptotic series used in the sine and cosine
!  Fresnel integral functions.

!  For x = ma the two values returned are mb and mc, where

!  mb = f(x) = (1 - 1*3/(pi*x*x)**2 + 1*3*5*7/(pi*x*x)**4 - ...) / (pi*x)
!  mc = g(x) = (1 - 1*3*5/(pi*x*x)**2 + 1*3*5*7*9/(pi*x*x)**4 - ...) / (pi**2*x**3)

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc

      integer :: j, j2, jterms, kl, nbot, ndsav1, nterm, nterms
      double precision :: x, xe, ye
      double precision, external :: fmnterms
      type(multi), save :: mxy(6), mjsums(ljsums)

      call fmalloc(mb, ndig+2)
      call fmalloc(mc, ndig+2)

      nterms = int(intmax/10)
      call fmm2dp(ma, x)
      if (kflag == 0) then
          j2 = int(0.35*sqrt(fmnterms(3.14159d0*x*x/2, 2, 0, 0, 0)) - 0.2)
          j2 = max(2, min(j2+mod(j2, 2), ljsums/2))
      else
          j2 = 2
      endif
      ndsav1 = ndig

!             Split into j2 concurrent sums for f(x) and another j2 concurrent sums for g(x).
!             Because the two sums use the same powers of x, the calculations for f and g
!             are interleaved.

      call fmi2m(1, mxy(4))
      call fmdiv(mxy(4), ma, mxy(2))
      call fmsqr(mxy(2), mxy(6))
      call fmpi(mxy(1))
      call fmdiv(mxy(6), mxy(1), mxy(2))
      call fmsqr(mxy(2), mxy(6))
      nterm = 0
      do j = 1, j2
         nbot = 2*nterm - 1
         if (nterm >= 2) call fmcsmpyi_r1(mxy(4), nbot)
         call fmeq(mxy(4), mjsums(j))
         nterm = nterm + 1

         nbot = 2*nterm - 1
         if (nterm >= 2) call fmcsmpyi_r1(mxy(4), nbot)
         call fmeq(mxy(4), mjsums(j2+j))
         nterm = nterm + 1
      enddo
      call fmovun_xe(mxy(6), xe)
      call fmovun_xe(mxy(4), ye)
      if (xe + ye < -ndig-3) then
          kl = 0
      else
          call fmipwr(mxy(6), j2, mxy(3))
          kl = 1
      endif

      if (kl == 1) then
          do jterms = 1, nterms
             call fmcsmpy_r1(mxy(4), mxy(3))
             do j = 1, j2
                nbot = 2*nterm - 1
                call fmcsmpyi_r1(mxy(4), nbot)
                ndig = ndsav1
                call fmcsaddnn_r1(mjsums(j), mxy(4))
                if (kflag /= 0) then
                    kl = 0
                    exit
                endif
                ndig = max(ngrd22, ndsav1-int(mjsums(j)%mp(2) - mxy(4)%mp(2)))
                ndig = min(ndsav1, ndig)
                if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                nterm = nterm + 1

                nbot = 2*nterm - 1
                call fmcsmpyi_r1(mxy(4), nbot)
                ndig = ndsav1
                call fmcsaddnn_r1(mjsums(j2+j), mxy(4))
                if (kflag /= 0) then
                    kl = 0
                    exit
                endif
                ndig = max(ngrd22, ndsav1-int(mjsums(j2+j)%mp(2) - mxy(4)%mp(2)))
                ndig = min(ndsav1, ndig)
                if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                nterm = nterm + 1
             enddo
             if (kl == 0) exit
             if (jterms == nterms) then
                 call fmunknown(mb)
                 call fmunknown(mc)
                 return
             endif
          enddo
      endif

!             Put the j2 separate sums back together.

      kflag = 0
      call fmcsnsums(2*j2, mjsums)
      call fmeq(mjsums(j2), mxy(3))
      call fmeq(mjsums(j2+j2), mxy(5))
      call fmnegate(mxy(6))
      do j = 2, j2
         call fmcsmpy_r1(mxy(3), mxy(6))
         call fmadd_r1(mxy(3), mjsums(j2-j+1))

         call fmcsmpy_r1(mxy(5), mxy(6))
         call fmadd_r1(mxy(5), mjsums(j2+j2-j+1))
      enddo
      call fmmpy(ma, mxy(1), mxy(2))
      call fmdiv(mxy(3), mxy(2), mb)

      call fmsqr(mxy(2), mxy(3))
      call fmmpy(mxy(3), ma, mxy(2))
      call fmdiv(mxy(5), mxy(2), mc)

      ndig = ndsav1

      return
      end subroutine fmfgfi

      subroutine fmfhgh(ma, mb, mc)

!  Internal routine for the two auxiliary asymptotic series used in the hyperbolic sine and
!  cosine integral functions.

!  for x = ma the two values returned are mb and mc, where

!  mb = f(x) = (1 + 2!/x**2 + 4!/x**4 + ...) / x
!  mc = g(x) = (1 + 3!/x**2 + 5!/x**4 + ...) / x**2

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc

      integer :: j, j2, jterms, kl, nbot, ndsav1, nterm, nterms
      double precision :: x, xe, ye
      type(multi), save :: mxy(5), mjsums(ljsums)
      double precision, external :: fmnterms

      call fmalloc(mb, ndig+2)
      call fmalloc(mc, ndig+2)

      nterms = int(intmax/10)
      call fmm2dp(ma, x)
      if (kflag == 0) then
          j2 = int(0.30*sqrt(fmnterms(x, 2, 0, 0, 0)) + 0.8)
          j2 = max(1, min(ljsums/2, j2))
      else
          j2 = 1
      endif
      ndsav1 = ndig

!             Split into j2 concurrent sums for f(x) and another j2 concurrent sums for g(x).
!             Because the two sums use the same powers of x, the calculations for f and g
!             are interleaved.

      call fmi2m(1, mxy(3))
      call fmdiv(mxy(3), ma, mxy(1))
      call fmsqr(mxy(1), mxy(5))
      nterm = 0
      do j = 1, j2
         nbot = nterm
         if (nterm >= 2) call fmcsmpyi_r1(mxy(3), nbot)
         call fmeq(mxy(3), mjsums(j))
         nterm = nterm + 1

         if (nterm >= 2) call fmcsmpyi_r1(mxy(3), nterm)
         call fmeq(mxy(3), mjsums(j2+j))
         nterm = nterm + 1
      enddo
      call fmovun_xe(mxy(5), xe)
      call fmovun_xe(mxy(3), ye)
      if (xe + ye < -ndig-3) then
          kl = 0
      else
          call fmipwr(mxy(5), j2, mxy(2))
          kl = 1
      endif

      if (kl == 1) then
          do jterms = 1, nterms
             call fmcsmpy_r1(mxy(3), mxy(2))
             do j = 1, j2
                nbot = nterm
                call fmcsmpyi_r1(mxy(3), nbot)
                ndig = ndsav1
                call fmcsaddnn_r1(mjsums(j), mxy(3))
                if (kflag /= 0) then
                    kl = 0
                    exit
                endif
                ndig = max(ngrd22, ndsav1-int(mjsums(j)%mp(2) - mxy(3)%mp(2)))
                ndig = min(ndsav1, ndig)
                if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                nterm = nterm + 1

                call fmcsmpyi_r1(mxy(3), nterm)
                ndig = ndsav1
                call fmcsaddnn_r1(mjsums(j2+j), mxy(3))
                if (kflag /= 0) then
                    kl = 0
                    exit
                endif
                ndig = max(ngrd22, ndsav1-int(mjsums(j2+j)%mp(2) - mxy(3)%mp(2)))
                ndig = min(ndsav1, ndig)
                if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                nterm = nterm + 1
                if (jterms == nterms) then
                    call fmunknown(mb)
                    call fmunknown(mc)
                    return
                endif
             enddo
             if (kl == 0) exit
          enddo
      endif

!             Put the j2 separate sums back together.

      kflag = 0
      call fmcsnsums(2*j2, mjsums)
      call fmeq(mjsums(j2), mxy(2))
      call fmeq(mjsums(2*j2), mxy(4))
      do j = 2, j2
         call fmcsmpy_r1(mxy(2), mxy(5))
         call fmadd_r1(mxy(2), mjsums(j2-j+1))

         call fmcsmpy_r1(mxy(4), mxy(5))
         call fmadd_r1(mxy(4), mjsums(j2+j2-j+1))
      enddo
      call fmdiv(mxy(2), ma, mb)
      call fmmpy(mxy(4), mxy(5), mc)

      ndig = ndsav1

      return
      end subroutine fmfhgh

      function fmfi(n)

!  Format integers for trace output.

      implicit none

      character(40) :: fmfi
      integer :: n
      intent (in) :: n

      character(40) :: temp
      integer :: j

      fmfi = ' '
      write (temp,*) n
      do j = 1, 40
         if (temp(j:j) /= ' ') then
             fmfi(1:41-j) = temp(j:40)
             return
         endif
      enddo

      return
      end function fmfi

      subroutine fmflag(k)

!  Return the internal condition variable kflag to the user.

      use fmvals
      implicit none

      integer :: k
      intent (inout) :: k

      k = kflag

      return
      end subroutine fmflag

      subroutine fmform(form, ma, string)

!  convert an fm number (ma) to a character string base 10 (string) using character string
!  form format.

!  form can be one of these types:  iw,  fw.d,  ew.d,  esw.d,  1pew.d  for positive integers w,d.

!  if iw format is used and ma is not exactly an integer, then the nearest integer to ma is printed.

      use fmvals
      implicit none

      character(*) :: form, string
      type(multi) :: ma
      intent (in) :: form, ma
      intent (inout) :: string
      double precision :: val
      integer :: j, jf1sav, jf2sav, jpt, k1, k2, k3, kd, ksave, kwd, kwi, last, lb, lengfm,  &
                 lengst, lfirst, nd, nexp
      type(multi), save :: mxy(1)


      ncall = ncall + 1
      namest(ncall) = 'FMFORM'

      ksave = kflag
      jf1sav = jform1
      jf2sav = jform2
      string = ' '
      lengfm = len(form)
      lengst = len(string)
      kwi = 75
      kwd = 40

      if (index(form, 'I') > 0 .or. index(form, 'i') > 0) then
          k1 = max(index(form, 'I'), index(form, 'i')) + 1
          k2 = lengfm
          if (k2 >= k1) then
              call fmst2d(form(k1:k2), val)
              kwi = nint(val)
          else
              kwi = lengst
          endif
          kwi = max(1, min(kwi, lengst))
          jform1 = 2
          jform2 = 0
          kwd = kwi + 21
          if (kwd+50 > lmbuff) then
              if (lmbuff > 0) deallocate(cmbuff)
              allocate(cmbuff(kwd+50), stat=j)
              if (j /= 0) then
                  call fmdefine_error
              endif
              lmbuff = kwd + 50
          endif
          call fmnint(ma, mxy(1))
          if (mxy(1)%mp(3) /= 0) then
              call fmout(mxy(1), cmbuff, kwd)
          else
              do j = 1, kwd
                 cmbuff(j) = ' '
              enddo
              cmbuff(2) = '0'
          endif
          lfirst = 1
          last = 1
          do j = 1, kwd
             if (cmbuff(kwd+1-j) /= ' ') lfirst = kwd+1-j
             if (cmbuff(j) /= ' ') last = j
          enddo
          jpt = 1
          if (last-lfirst+1 > kwi) then
              call fmform_err(string, lengst, jf1sav, jf2sav)
              return
          endif
          if (last <= kwi) then
              do j = last, lfirst, -1
                 jpt = kwi - last + j
                 string(jpt:jpt) = cmbuff(j)
              enddo
              do j = 1, jpt-1
                 string(j:j) = ' '
              enddo
          else
              do j = lfirst, last
                 jpt = kwi - last + j
                 string(jpt:jpt) = cmbuff(j)
              enddo
          endif
      else if (index(form, 'F') > 0 .or. index(form, 'f') > 0) then
          k1 = max(index(form, 'F'), index(form, 'f')) + 1
          k2 = index(form, '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val)
              kd = nint(val)
          else
              kd = 0
          endif
          kwi = max(1, min(kwi, lengst))
          kd = max(0, min(kd, kwi-2))
          jform1 = 2
          jform2 = kd
          nd = int(real(ndig)*log10(real(mbase))) + 1
          if (nd < 2) nd = 2
          nexp = int(2.0*log10(real(mxbase))) + 16
          lb = max(jform2+nexp, nd+nexp)
          kwd = lb
          if (kwd+50 > lmbuff) then
              if (lmbuff > 0) deallocate(cmbuff)
              allocate(cmbuff(kwd+50), stat=j)
              if (j /= 0) then
                  call fmdefine_error
              endif
              lmbuff = kwd + 50
          endif
          call fmout(ma, cmbuff, kwd)
          lfirst = 1
          last = 1
          do j = 1, kwd
             if (cmbuff(kwd+1-j) /= ' ') lfirst = kwd+1-j
             if (cmbuff(j) /= ' ') last = j
          enddo
          if (last-lfirst+1 > kwi) then

!             Not enough room for this f format, or fmout converted it to e format to avoid showing
!             no significant digits.  See if a shortened form will fit in e format.

              nexp = int(log10((abs(real(ma%mp(2)))+1)*log10(real(mbase))+1)+1)
              nd = kwi - nexp - 5
              if (nd < 1) then
                  call fmform_err(string, lengst, jf1sav, jf2sav)
                  return
              else
                  jform1 = 0
                  jform2 = nd
                  if (kwi+50 > lmbuff) then
                      if (lmbuff > 0) deallocate(cmbuff)
                      allocate(cmbuff(kwi+50), stat=j)
                      if (j /= 0) then
                          call fmdefine_error
                      endif
                      lmbuff = kwi + 50
                  endif
                  call fmout(ma, cmbuff, kwi)
                  lfirst = 1
                  last = 1
                  do j = 1, kwi
                     if (cmbuff(kwi+1-j) /= ' ') lfirst = kwi+1-j
                     if (cmbuff(j) /= ' ') last = j
                  enddo
              endif
          endif
          jpt = 1
          if (last <= kwi) then
              do j = last, lfirst, -1
                 jpt = kwi - last + j
                 string(jpt:jpt) = cmbuff(j)
              enddo
              do j = 1, jpt-1
                 string(j:j) = ' '
              enddo
          else
              do j = lfirst, last
                 jpt = kwi - last + j
                 string(jpt:jpt) = cmbuff(j)
              enddo
          endif
      else if (index(form, '1PE') > 0 .or. index(form, '1pe') > 0 .or. index(form, 'ES') > 0 .or.  &
               index(form, 'es') > 0) then
          if (index(form, '1PE') > 0 .or. index(form, '1pe') > 0) then
              k1 = max(index(form, 'E'), index(form, 'e')) + 1
          else
              k1 = max(index(form, 'S'), index(form, 's')) + 1
          endif
          k2 = index(form, '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val)
              kd = nint(val)
          else
              kd = 0
          endif
          kwi = max(1, min(kwi, lengst))
          kd = max(0, min(kd, kwi-2))
          jform1 = 1
          jform2 = kd + 1
          if (kwi+50 > lmbuff) then
              if (lmbuff > 0) deallocate(cmbuff)
              allocate(cmbuff(kwi+50), stat=j)
              if (j /= 0) then
                  call fmdefine_error
              endif
              lmbuff = kwi + 50
          endif
          call fmout(ma, cmbuff, kwi)
          do j = kwi, 1, -1
             if (j > lengst) then
                 if (cmbuff(j) /= ' ') then
                     call fmform_err(string, lengst, jf1sav, jf2sav)
                     return
                 endif
             else
                 string(j:j) = cmbuff(j)
             endif
          enddo
      else if (index(form, 'E') > 0 .or. index(form, 'e') > 0) then
          k1 = max(index(form, 'E'), index(form, 'e')) + 1
          k2 = index(form, '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val)
              kd = nint(val)
          else
              kd = 0
          endif
          kwi = max(1, min(kwi, lengst))
          kd = max(0, min(kd, kwi-2))
          jform1 = 0
          jform2 = kd
          if (kwi+50 > lmbuff) then
              if (lmbuff > 0) deallocate(cmbuff)
              allocate(cmbuff(kwi+50), stat=j)
              if (j /= 0) then
                  call fmdefine_error
              endif
              lmbuff = kwi + 50
          endif
          call fmout(ma, cmbuff, kwi)
          do j = kwi, 1, -1
             if (j > lengst) then
                 if (cmbuff(j) /= ' ') then
                     call fmform_err(string, lengst, jf1sav, jf2sav)
                     return
                 endif
             else
                 string(j:j) = cmbuff(j)
             endif
          enddo
      else
          call fmform_err(string, lengst, jf1sav, jf2sav)
          return
      endif

      kflag = ksave
      jform1 = jf1sav
      jform2 = jf2sav
      ncall = ncall - 1

      return
      end subroutine fmform

      subroutine fmform_err(string, n, jf1sav, jf2sav)

!  If an error occurs during input conversion, return string = '***...***'

      use fmvals
      implicit none

      character(*) :: string
      integer :: n, jf1sav, jf2sav
      intent (in) :: n, jf1sav, jf2sav
      intent (inout) :: string

      integer :: j

      kflag = -8
      do j = 1, n
         string(j:j) = '*'
      enddo

      jform1 = jf1sav
      jform2 = jf2sav
      ncall = ncall - 1

      return
      end subroutine fmform_err

      subroutine fmfprint(form, ma)

      use fmvals
      implicit none

      character(*) :: form
      type(multi) :: ma
      intent (in) :: form, ma

      call fmfprt(form, ma)

      return
      end subroutine fmfprint

      subroutine fmfprt(form, ma)

!  print an fm number (ma) on unit kw using character string form format.

!  form can be one of these types:  iw,  fw.d,  ew.d,  esw.d,  1pew.d  for positive integers w,d.

!  if iw format is used and ma is not exactly an integer, then the nearest integer to ma is printed.

      use fmvals
      implicit none

      character(*) :: form
      type(multi) :: ma
      intent (in) :: form, ma

      character(20) :: form2
      double precision :: val
      integer :: j, jf1sav, jf2sav, jpt, k, k1, k2, k3, kd, ksave, kwd, kwi, last, lb,  &
                 lengfm, lfirst, nd, nexp
      type(multi), save :: mxy(1)


      ncall = ncall + 1
      namest(ncall) = 'FMFPRT'

      ksave = kflag
      jf1sav = jform1
      jf2sav = jform2
      lengfm = len(form)
      kwi = 75
      kwd = 40

      if (index(form, 'I') > 0 .or. index(form, 'i') > 0) then
          k1 = max(index(form, 'I'), index(form, 'i')) + 1
          k2 = lengfm
          if (k2 >= k1) then
              call fmst2d(form(k1:k2), val)
              kwi = nint(val)
          else
              kwi = 50
          endif
          jform1 = 2
          jform2 = 0
          kwd = kwi + 21
          if (kwd+50 > lmbuff) then
              if (lmbuff > 0) deallocate(cmbuff)
              allocate(cmbuff(kwd+50), stat=j)
              if (j /= 0) then
                  call fmdefine_error
              endif
              lmbuff = kwd + 50
          endif
          call fmnint(ma, mxy(1))
          if (mxy(1)%mp(3) /= 0) then
              call fmout(mxy(1), cmbuff, kwd)
          else
              do j = 1, kwd
                 cmbuff(j) = ' '
              enddo
              cmbuff(2) = '0'
          endif
          lfirst = 1
          last = 1
          do j = 1, kwd
             if (cmbuff(kwd+1-j) /= ' ') lfirst = kwd+1-j
             if (cmbuff(j) /= ' ') last = j
          enddo
          jpt = 1
          if (last-lfirst+1 > kwi) then
              call fmfprt_err(kwi, jf1sav, jf2sav)
              return
          endif
          if (last <= kwi) then
              do j = last, lfirst, -1
                 jpt = kwi - last + j
                 if (jpt /= j) cmbuff(jpt) = cmbuff(j)
              enddo
              do j = 1, jpt-1
                 cmbuff(j) = ' '
              enddo
          else
              do j = lfirst, last
                 jpt = kwi - last + j
                 if (jpt /= j) cmbuff(jpt) = cmbuff(j)
              enddo
          endif
      else if (index(form, 'F') > 0 .or. index(form, 'f') > 0) then
          k1 = max(index(form, 'F'), index(form, 'f')) + 1
          k2 = index(form(1:lengfm), '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val)
              kd = nint(val)
          else
              kd = 0
          endif
          kd = max(0, min(kd, kwi-2))
          jform1 = 2
          jform2 = kd
          nd = int(real(ndig)*log10(real(mbase))) + 1
          if (nd < 2) nd = 2
          nexp = int(2.0*log10(real(mxbase))) + 16
          lb = max(jform2+nexp, nd+nexp)
          kwd = lb
          if (kwd+50 > lmbuff) then
              if (lmbuff > 0) deallocate(cmbuff)
              allocate(cmbuff(kwd+50), stat=j)
              if (j /= 0) then
                  call fmdefine_error
              endif
              lmbuff = kwd + 50
          endif
          call fmout(ma, cmbuff, kwd)
          lfirst = 1
          last = 1
          do j = 1, kwd
             if (cmbuff(kwd+1-j) /= ' ') lfirst = kwd+1-j
             if (cmbuff(j) /= ' ') last = j
          enddo
          if (last-lfirst+1 > kwi) then

!             Not enough room for this f format, or fmout converted it to e format to avoid showing
!             no significant digits.  See if a shortened form will fit in e format.

              nexp = int(log10((abs(real(ma%mp(2)))+1)*log10(real(mbase))+1)+1)
              nd = kwi - nexp - 5
              if (nd < 1) then
                  call fmfprt_err(kwi, jf1sav, jf2sav)
                  return
              else
                  jform1 = 0
                  jform2 = nd
                  if (kwi+50 > lmbuff) then
                      if (lmbuff > 0) deallocate(cmbuff)
                      allocate(cmbuff(kwi+50), stat=j)
                      if (j /= 0) then
                          call fmdefine_error
                      endif
                      lmbuff = kwi + 50
                  endif
                  call fmout(ma, cmbuff, kwi)
                  lfirst = 1
                  last = 1
                  do j = 1, kwi
                     if (cmbuff(kwi+1-j) /= ' ') lfirst = kwi+1-j
                     if (cmbuff(j) /= ' ') last = j
                  enddo
              endif
          endif
          jpt = 1
          if (last <= kwi) then
              do j = last, lfirst, -1
                 jpt = kwi - last + j
                 if (jpt /= j) cmbuff(jpt) = cmbuff(j)
              enddo
              do j = 1, jpt-1
                 cmbuff(j) = ' '
              enddo
          else
              do j = lfirst, last
                 jpt = kwi - last + j
                 if (jpt /= j) cmbuff(jpt) = cmbuff(j)
              enddo
          endif
      else if (index(form, '1PE') > 0 .or. index(form, '1pe') > 0 .or. index(form, 'ES') > 0 .or.  &
               index(form, 'es') > 0) then
          if (index(form, '1PE') > 0 .or. index(form, '1pe') > 0) then
              k1 = max(index(form, 'E'), index(form, 'e')) + 1
          else
              k1 = max(index(form, 'S'), index(form, 's')) + 1
          endif
          k2 = index(form(1:lengfm), '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val)
              kd = nint(val)
          else
              kd = 0
          endif
          kd = max(0, min(kd, kwi-2))
          jform1 = 1
          jform2 = kd + 1
          if (kwi+50 > lmbuff) then
              if (lmbuff > 0) deallocate(cmbuff)
              allocate(cmbuff(kwi+50), stat=j)
              if (j /= 0) then
                  call fmdefine_error
              endif
              lmbuff = kwi + 50
          endif
          call fmout(ma, cmbuff, kwi)
      else if (index(form, 'E') > 0 .or. index(form, 'e') > 0) then
          k1 = max(index(form, 'E'), index(form, 'e')) + 1
          k2 = index(form(1:lengfm), '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val)
              kd = nint(val)
          else
              kd = 0
          endif
          kd = max(0, min(kd, kwi-2))
          jform1 = 0
          jform2 = kd
          if (kwi+50 > lmbuff) then
              if (lmbuff > 0) deallocate(cmbuff)
              allocate(cmbuff(kwi+50), stat=j)
              if (j /= 0) then
                  call fmdefine_error
              endif
              lmbuff = kwi + 50
          endif
          call fmout(ma, cmbuff, kwi)
      else
          call fmfprt_err(kwi, jf1sav, jf2sav)
          return
      endif

      write (form2, "(' (6X, ', I3, 'A1) ')") kswide-7
      if (kflag /= -8) kflag = ksave
      jform1 = jf1sav
      jform2 = jf2sav
      do j = kwi, 1, -1
         if (cmbuff(j) /= ' ' .or. j == 1) then
             write (kw, form2) (cmbuff(k), k=1, j)
             exit
         endif
      enddo
      ncall = ncall - 1

      return
      end subroutine fmfprt

      subroutine fmfprt_err(kwi, jf1sav, jf2sav)

!  If an error occurs during input conversion, return string = '***...***'

      use fmvals
      implicit none

      integer :: kwi, jf1sav, jf2sav
      intent (in) :: kwi, jf1sav, jf2sav

      integer :: j, k
      character(20) :: form2

      kflag = -8
      do j = 1, kwi
         cmbuff(j) = '*'
      enddo

      write (form2, "(' (6X, ', I3, 'A1) ')") kswide-7
      jform1 = jf1sav
      jform2 = jf2sav
      do j = kwi, 1, -1
         if (cmbuff(j) /= ' ' .or. j == 1) then
             write (kw, form2) (cmbuff(k), k=1, j)
             ncall = ncall - 1
             return
         endif
      enddo
      ncall = ncall - 1

      return
      end subroutine fmfprt_err

      subroutine fmfxgx(ma, mb, mc)

!  Internal routine for the two auxiliary asymptotic series used in the sine and
!  cosine integral functions.

!  for x = ma the two values returned are mb and mc, where

!  mb = f(x) = (1 - 2!/x**2 + 4!/x**4 - ...) / x
!  mc = g(x) = (1 - 3!/x**2 + 5!/x**4 - ...) / x**2

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc

      integer :: j, j2, jterms, kl, ndsav1, nterm, nterms
      double precision :: x, xe, ye
      type(multi), save :: mxy(5), mjsums(ljsums)
      double precision, external :: fmnterms

      call fmalloc(mb, ndig+2)
      call fmalloc(mc, ndig+2)

      nterms = int(intmax/10)
      call fmm2dp(ma, x)
      if (kflag == 0) then
          j2 = int(0.38*sqrt(fmnterms(x, 2, 0, 0, 0)) - 0.2)
          j2 = max(2, min(j2+mod(j2, 2), ljsums/2))
      else
          j2 = 2
      endif
      ndsav1 = ndig

!             Split into j2 concurrent sums for f(x) and another j2 concurrent sums for g(x).
!             Because the two sums use the same powers of x, the calculations for f and g
!             are interleaved.

      call fmi2m(1, mxy(3))
      call fmdiv(mxy(3), ma, mxy(1))
      call fmsqr(mxy(1), mxy(5))
      nterm = 0
      do j = 1, j2
         if (nterm >= 2) call fmcsmpyi_r1(mxy(3), nterm)
         call fmeq(mxy(3), mjsums(j))
         nterm = nterm + 1

         if (nterm >= 2) call fmcsmpyi_r1(mxy(3), nterm)
         call fmeq(mxy(3), mjsums(j2+j))
         nterm = nterm + 1
      enddo
      call fmovun_xe(mxy(5), xe)
      call fmovun_xe(mxy(3), ye)
      if (xe + ye < -ndig-3) then
          kl = 0
      else
          call fmipwr(mxy(5), j2, mxy(2))
          kl = 1
      endif

      if (kl == 1) then
          do jterms = 1, nterms
             call fmcsmpy_r1(mxy(3), mxy(2))
             do j = 1, j2
                call fmcsmpyi_r1(mxy(3), nterm)
                ndig = ndsav1
                call fmcsaddnn_r1(mjsums(j), mxy(3))
                if (kflag /= 0) then
                    kl = 0
                    exit
                endif
                ndig = max(ngrd22, ndsav1-int(mjsums(j)%mp(2) - mxy(3)%mp(2)))
                ndig = min(ndsav1, ndig)
                if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                nterm = nterm + 1

                call fmcsmpyi_r1(mxy(3), nterm)
                ndig = ndsav1
                call fmcsaddnn_r1(mjsums(j2+j), mxy(3))
                if (kflag /= 0) then
                    kl = 0
                    exit
                endif
                ndig = max(ngrd22, ndsav1-int(mjsums(j2+j)%mp(2) - mxy(3)%mp(2)))
                ndig = min(ndsav1, ndig)
                if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                nterm = nterm + 1
                if (jterms == nterms) then
                    call fmunknown(mb)
                    call fmunknown(mc)
                    return
                endif
             enddo
             if (kl == 0) exit
          enddo
      endif

!             Put the j2 separate sums back together.

      kflag = 0
      call fmcsnsums(2*j2, mjsums)
      call fmeq(mjsums(j2), mxy(2))
      call fmeq(mjsums(j2+j2), mxy(4))
      call fmnegate(mxy(5))
      do j = 2, j2
         call fmcsmpy_r1(mxy(2), mxy(5))
         call fmadd_r1(mxy(2), mjsums(j2-j+1))

         call fmcsmpy_r1(mxy(4), mxy(5))
         call fmadd_r1(mxy(4), mjsums(j2+j2-j+1))
      enddo
      call fmdiv(mxy(2), ma, mb)
      mxy(5)%mp(1) = 1
      call fmmpy(mxy(4), mxy(5), mc)

      ndig = ndsav1

      return
      end subroutine fmfxgx

      subroutine fmgam(ma, mb)

!  mc = gamma(ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(17), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      if (in_fact == 1) ndig = ndsave
      call fmgam_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fmgam_m(ma, mxy, mresult, ndsave, numtry)
         call fmcheck_accuracy(mresult, ndsave, retry)
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmgam

      subroutine fmgam_c(ndig_c, mbase_c, c)

!  Initialize the constants used in the gamma polynomial.

      use fmvals
      implicit none

      type(multi) :: c(0:196)
      integer :: ndig_c
      real (kind(1.0d0)) :: mbase_c
      intent (inout) :: c, ndig_c, mbase_c

      integer :: ndsave
      character(220) :: st

      ndsave = ndig
      ndig = max(ndig, nint(210*dlogtn/dlogmb))
      ndig_c = ndig
      mbase_c = mbase

      st = " 2 "
      call fmst2m(st, c(0))
      st = " 1.845568670196934278786975819835195137915681328120152802388465530" //  &
           "230264546444670658126105873416506500970737105500385835038078991971" //  &
           "02691432755165200471015292749299933251412532452465211441480948350581017M+0"
      call fmst2m(st, c(1))
      st = " 1.246464995951346528971255032754062122751889033636657384469089862" //  &
           "717670083765963530684050979376234434063149542816318341831199882570" //  &
           "54136293454241409125655601075903604372266188019198826399323980756659507M+0"
      call fmst2m(st, c(2))
      st = " 5.749941689206122275465545297069514629181683280995911506411578080" //  &
           "726118046263102563376406423582057300595042023225863076035376079997" //  &
           "58104823944616583929664137138189407083120305067949277678404599957423943M-1"
      call fmst2m(st, c(3))
      st = " 2.300749407541140630184757374755110638744965329574536384291172327" //  &
           "224547634301735916779398033223621567106468104559113876289562540922" //  &
           "49810183476230067472728208959273220898874770326648720581128183324434328M-1"
      call fmst2m(st, c(4))
      st = " 7.371504661602386878317788712652808511825657580343462427360683175" //  &
           "509260544574956944742301697314778437297368730369274995615677873789" //  &
           "35133238331475104267889872993214666032986278826546933416543800481312385M-2"
      call fmst2m(st, c(5))
      st = " 2.204110936751696733001055930504381988327566876073187686154801967" //  &
           "909973103233273981903764688650115297934327575508639951789708251337" //  &
           "92707722587521058280471694968009955629145006098566559417433720825728363M-2"
      call fmst2m(st, c(6))
      st = " 5.448754075820309416743506865467445124448139461938118242185774040" //  &
           "091229588005782816224467061542163141883870132680748064163312525326" //  &
           "79285947455982778971828128624591203392889667559929450792010659863151692M-3"
      call fmst2m(st, c(7))
      st = " 1.355220860239435200782800511692912879531376156061699075016521316" //  &
           "639789508602632933261809843993626303860552687494426922068347662436" //  &
           "50638664308894605216771132545723510121680479395222846647397509645416658M-3"
      call fmst2m(st, c(8))
      st = " 2.647856630454963762916703027588487719988377646494592862588577877" //  &
           "670108768701128952589855350528375734341831836105261848089596212014" //  &
           "43438318203511988335596380750860411655605437077878364306986421443576571M-4"
      call fmst2m(st, c(9))
      st = " 6.120306281920072864297933044336079606323020239995311203374612431" //  &
           "474530317806041317622369821667524651305326663533305730887143946711" //  &
           "61266460849960962516510977842732486514289292246744768624817147886489117M-5"
      call fmst2m(st, c(10))
      st = " 8.505579174881354789674853004022777303159200477826996950880457101" //  &
           "421412876328884015915508261943090083057713903043228932335601231203" //  &
           "40141960454601937991265277526358454689641320642200080030286310049533045M-6"
      call fmst2m(st, c(11))
      st = " 2.406177240131441866815352548925218907359016756341071832415175589" //  &
           "258269044824185640836078834625474374503849871861065571818953770220" //  &
           "34975008487473056363745663434694457043463856223590513289898353487696130M-6"
      call fmst2m(st, c(12))
      st = " 8.802390990648096801589149015845004893557805933708362167755975543" //  &
           "372057695537675243732864757390172399681575843089705450975708832670" //  &
           "47894590480007482518734894597525237926945509694423313414680575733951262M-8"
      call fmst2m(st, c(13))
      st = " 1.142227645342158377586670448383448546854299529797736913759691985" //  &
           "910949533336448816683159056251333466684021985223318722135340801690" //  &
           "72260625981817135095639775689249807942339836246106905787385604364337194M-7"
      call fmst2m(st, c(14))
      st = " 1.631475210082743727954198968671352602693131133480080900245408554" //  &
           "939316524124591839852475746114674778530360919625180046232777005122" //  &
           "27236317509067632839828070252526276470500723929148927321567689434907911M-8"
      call fmst2m(st, c(15))
      st = " 8.623497389978272698928826543954910754554854080065660353539135917" //  &
           "773916063595516849273098040739690585246037837539507713246122281847" //  &
           "07020525306666205624027189054003604432165771697650991757066138256773314M-9"
      call fmst2m(st, c(16))
      st = " 2.441104025235454263800352688428668916552720940475516379601031040" //  &
           "328703631852876301331001731922670655825329213688582617123340479731" //  &
           "30453030855966898642614830460583649086634599347191276139711017402687474M-9"
      call fmst2m(st, c(17))
      st = " 8.729150638722326041474546798911555513733749137711634358293958504" //  &
           "106518519494766446793260191698472463238634461285021617971659072089" //  &
           "64830740638437222612735276515039966197638188663669442608898762584643632M-10"
      call fmst2m(st, c(18))
      st = " 2.839029513083401421929170732563229229668325235436226039051054572" //  &
           "783508115759922623716045941336385750870556656615699867502848974601" //  &
           "25690803078266597331301210600902409196080711025610915592408863593987027M-10"
      call fmst2m(st, c(19))
      st = " 9.560889804988413908509285509380646041154360005479482459192247765" //  &
           "357528992664976535701311631674646910607500850899901331610584447013" //  &
           "61092693917685042900085585432034263673380064316273851782544357969469641M-11"
      call fmst2m(st, c(20))
      st = " 3.178270013361840262252491679259206811383776452439447460847595023" //  &
           "655033077497304599287176316699672432816255052883697868521388307529" //  &
           "40383229860610241927494715179896090660025570060233690995092455619052433M-11"
      call fmst2m(st, c(21))
      st = " 1.061093469576602661180070676287816314794459534888083832039943125" //  &
           "106258601567850805437194313637331057164170163808855202657895983163" //  &
           "75070581362231098256864140947088822349901059528755152892715695385840670M-11"
      call fmst2m(st, c(22))
      st = " 3.536842812699221803341361602631772393030775267007960695600138342" //  &
           "475056171314799106864974683735705965078815702431194850519988946394" //  &
           "60297349449303074734807619318567432754104422976962193319806157373676528M-12"
      call fmst2m(st, c(23))
      st = " 1.179381890210746859019626609111101179189547278121204798102640669" //  &
           "089589106613555171765287658695791241618592970217136500883583515937" //  &
           "07042245469783966737397377617384891192343427489490590732643362286614565M-12"
      call fmst2m(st, c(24))
      st = " 3.931867733137363527554885326768660997026944151573526847589071835" //  &
           "861161866217034417877097706264724092166846479646830599648529767479" //  &
           "29972500613317852095515147938660038231478063008302625870299351511379064M-13"
      call fmst2m(st, c(25))
      st = " 1.310821437225892696503587059884518604419875759028225403332569486" //  &
           "263124550715228960875605764084965585015810053174223154386683364225" //  &
           "82940623880095674287091265178854323811489670635974124477257044106228515M-13"
      call fmst2m(st, c(26))
      st = " 4.369852680143739417301538884456930730266716017178643408797678607" //  &
           "489727662002478005547544394166113056281405054193512564204527806783" //  &
           "21820023428536694798337606178682340961609542697763176968052664696930530M-14"
      call fmst2m(st, c(27))
      st = " 1.456734329592486133181460315029414930377211960023817769883504280" //  &
           "093804008390039009055883271224157190963826905955811848380812603165" //  &
           "54224971663883071707665069028985176275185941888330865659033519170133935M-14"
      call fmst2m(st, c(28))
      st = " 4.856068671580721652825423134564758955030518962120078212851284455" //  &
           "507593020938761405142314134920533228978526051606006790133466381223" //  &
           "50359680218686853748359459683818517509731959413893343189086282950465935M-15"
      call fmst2m(st, c(29))
      st = " 1.618761872087034547065539210485881034248882944054015543045073210" //  &
           "910330056730122088065602760823181836215863575050044591541254549198" //  &
           "06533155170588574561959173365139660326081560892373137180542173284519690M-15"
      call fmst2m(st, c(30))
      st = " 5.396053371990928374785154960328771472570021055817837913960904096" //  &
           "760099091618418168792262897777467993922856366402610309885017994638" //  &
           "31375328961628239846054792847689945091796341112338488175505578851091459M-16"
      call fmst2m(st, c(31))
      st = " 1.798729611660976774380774106560359446517486065245326232319884896" //  &
           "239912275072122853296640979664466879259429595297450987702461004648" //  &
           "40931772056892963070221773391675849856440134420289464625930506084236358M-16"
      call fmst2m(st, c(32))
      st = " 5.995878246226820269265104853882744953833262677515218945976170565" //  &
           "702779924974464149394857574835844004490020924890860726739848899923" //  &
           "95696324825550829660096649087698612645940055809410964879423696294173532M-17"
      call fmst2m(st, c(33))
      st = " 1.998654305589399275726998250553254783542933078465976133420153128" //  &
           "272381058668053909214099708471764295907486937756314951544992358421" //  &
           "97144228984621236873733301083447645823872653994272286143235273563570481M-17"
      call fmst2m(st, c(34))
      st = " 6.662251581403731529306004514600953655139824062623862163440755266" //  &
           "354957947460012639499946309112697689542491881916960750384664086547" //  &
           "74220845245988438400136805239697524619278380861197973816032911820925462M-18"
      call fmst2m(st, c(35))
      st = " 2.220768169107932862809420803989156159852745026278540490315171027" //  &
           "166630658162840832652660890951304947572979341837638582334903909155" //  &
           "05010378303851983844455677013599258308919578609796169265316664802443791M-18"
      call fmst2m(st, c(36))
      st = " 7.402604670809900203376581979566914810234491834807160670117173102" //  &
           "679048535794208132168246922357691220447769517665621319685807754668" //  &
           "30524972355162004213858351086934604282899918908012797069231868984875389M-19"
      call fmst2m(st, c(37))
      st = " 2.467545917514843068413870814987535001534095121397550756283431485" //  &
           "174239672848806618511211094654861620856356668212851618482113031080" //  &
           "96983868763519240779629920703298714890476973363239861006308885857104223M-19"
      call fmst2m(st, c(38))
      st = " 8.225180627404782368968305939492307217250324537166525666738082095" //  &
           "443986514199471391717760463558674271532612180804614900051667267307" //  &
           "84828422378491452316833093910246472565776447483034439499635086721544230M-20"
      call fmst2m(st, c(39))
      st = " 2.741733768240659509936720350920901622511204615005846102750077012" //  &
           "225034115334522335690591847723821637675971676287391586929140867246" //  &
           "24157389063680220659693708857804287064240054553450007399411745938008177M-20"
      call fmst2m(st, c(40))
      st = " 9.139129792265891288417212538920834449088699985871081943229349237" //  &
           "308947859965368326191615768810794304428951588196306949098368574539" //  &
           "28605395142908365050404570472066333401820331325326810443520131888072775M-21"
      call fmst2m(st, c(41))
      st = " 3.046380905361179933871534873717109530976853470108494529882869084" //  &
           "727927972747326006151030730201866380503024676995328258901563345953" //  &
           "00658838459344187262962809267579300899208726174226364547735769503160384M-21"
      call fmst2m(st, c(42))
      st = " 1.015461378786517931007333337553073166997854684093926238094172044" //  &
           "744795968432075139196598233114739312125317801492097820991352317417" //  &
           "40293799704807080092075189476011412233026066523677916838565466920346563M-21"
      call fmst2m(st, c(43))
      st = " 3.384873955149684581869145002322761445395722444488361773402583112" //  &
           "448446196579967067830143563552847474861011075678427137967175986491" //  &
           "77423399240122512958345857834877457342567505386357823149491980041361130M-22"
      call fmst2m(st, c(44))
      st = " 1.128291991521080392925404045314099582618612165311869719114516335" //  &
           "417518456246100356538652790526704797786336190873078001030469915965" //  &
           "30342451983442856226503526150387619863083398681667798679726159209459487M-22"
      call fmst2m(st, c(45))
      st = " 3.760974987926624413050052192380026663425879102031305346359345746" //  &
           "935876097802220422384767553022229983969369775506060549782771493660" //  &
           "85309029600033693383948806798756523782518697759939484580588143464857350M-23"
      call fmst2m(st, c(46))
      st = " 1.253658750025309164633924716897191398251340412647146221607418983" //  &
           "652266605895765756004913716691084072256991264216324248980009909612" //  &
           "59662905496332238803040488263666172235045176892125202448596644986008747M-23"
      call fmst2m(st, c(47))
      st = " 4.178863551880140415652989937671280452129584936360929800867252116" //  &
           "863675482287565904618697224054245640513684845309376666513701521263" //  &
           "52903495786573790786121590010548700491620543046740323819627331118835276M-24"
      call fmst2m(st, c(48))
      st = " 1.392954780243262418680115701340497736540387201421965383888625288" //  &
           "310091918535511115914306440504769869531128337443764472227581178596" //  &
           "20874940378776837220110757980964940848165877287239082243508787832464445M-24"
      call fmst2m(st, c(49))
      st = " 4.643183258187456757363871480237105948494753871341586050997508099" //  &
           "595411224954239240596072142323602079719155358372134330760070497787" //  &
           "55364393549841452404607067507295993200758608506748675165475527877530949M-25"
      call fmst2m(st, c(50))
      st = " 1.547727917073673030893407669122051522765823276651858723363536117" //  &
           "860559780947473082931957648716608923599799859242924550204192502327" //  &
           "93202961853805884072569165830891801693280119768515402102389811485890830M-25"
      call fmst2m(st, c(51))
      st = " 5.159093467774295934623929324290510691555682927619718795937537456" //  &
           "443748751641411020603883876314313578961537671360400477911224749990" //  &
           "32619951820624633170971754679797702479266215176809962392844181877752600M-26"
      call fmst2m(st, c(52))
      st = " 1.719697925307095214819334128534788375205527844306001827485335608" //  &
           "178891188953930792336558066117385344867670787386310361133421997787" //  &
           "32437687430376200145015883834569265381524778650808598371769510961689717M-26"
      call fmst2m(st, c(53))
      st = " 5.732326674479775700977445632081415478242873164984623088760026987" //  &
           "046479843038489986034336241981077004936330751439598114357862316445" //  &
           "25391747885525449466566054526270451667824579066863518701758860381778789M-27"
      call fmst2m(st, c(54))
      st = " 1.910775622357349859006177503807224410484768271435458299879734511" //  &
           "091872750666800933837592866045341090057920381872911981841539613531" //  &
           "34532853835424993139130432850991078908443110651776717566117546886621263M-27"
      call fmst2m(st, c(55))
      st = " 6.369252235018181185695546747418083648737457861666758649658733495" //  &
           "450326624296352111648047112820334535082139732219092514871542197623" //  &
           "45438407830542732130710826023492126216948058010058111121438710893185370M-28"
      call fmst2m(st, c(56))
      st = " 2.123084118462838161068146373210838937742442106504888126619598244" //  &
           "689122838503449807948835352511168142442994048637204680573237012416" //  &
           "88214862798756633312023510560919642366853351380446601871574640377801289M-28"
      call fmst2m(st, c(57))
      st = " 7.076947161851452988857602069175395219260001742350326617810798286" //  &
           "412997417428572002897367283988898197215995346896337658412178803828" //  &
           "71600585988840954970771671278144596708302210216220397647874970105717455M-29"
      call fmst2m(st, c(58))
      st = " 2.358982412360992050118851554506979955647201613693684896233810502" //  &
           "944787306402820374939041591698662853950957584483745174219063623695" //  &
           "13294756585697364356697316138631583855315160276428811116906407698998717M-29"
      call fmst2m(st, c(59))
      st = " 7.863274770562928683386208182169555716408523732927181605570254642" //  &
           "783489336698077228912261535122643231786047779260925663715692218511" //  &
           "54079525591282153925777222923833127312465613000068227777044732926174616M-30"
      call fmst2m(st, c(60))
      st = " 2.621091605860885533233898952848549221472883408639509048156174492" //  &
           "952501040386862212314276518084902725209461671925415533723193076219" //  &
           "02166363594957080995260573241730794841247260537467180156250342238881167M-30"
      call fmst2m(st, c(61))
      st = " 8.736972058719399393773664808053499235464951884789194640368079086" //  &
           "177143026321168823182202095050518931856284116458482040667912530023" //  &
           "17830489701338487555343938051214348611787932621065770035562250631323146M-31"
      call fmst2m(st, c(62))
      st = " 2.912324029368913239221905377728027928932487827862157086587586846" //  &
           "896450700145411015082377114761533704468584083695734375828642409882" //  &
           "69259984928264053284030731675607849783920249775114691953904644907709015M-31"
      call fmst2m(st, c(63))
      st = " 9.707746789052497475085146052433896715360382198339051019251763880" //  &
           "518185755627159066562273677244070805548234512751403592056913207327" //  &
           "80251017233714875898746055682870640485635412611964103637495935078818638M-32"
      call fmst2m(st, c(64))
      st = " 3.235915602473196442669228672981134089711213167383910530833953829" //  &
           "792990006951794162312454635926395818450571401725370707981435503583" //  &
           "55570191731695332982121199537121246583519326445577596987891273510182193M-32"
      call fmst2m(st, c(65))
      st = " 1.078638535688323258277639294637321095007154872462571028231301143" //  &
           "605467142930516231430752807470673434147256477737840344704980947455" //  &
           "43053554636974298772295627289032328328373036848556849010802235448385016M-32"
      call fmst2m(st, c(66))
      st = " 3.595461789454222217017444496718864771407199081151484546256978274" //  &
           "929484367469843471052909175769814275173782972424785067903628062172" //  &
           "38267851839020384161912309600523898207350166920811200389438694198073310M-33"
      call fmst2m(st, c(67))
      st = " 1.198487264108026960553291549779110538131003576080453431007006512" //  &
           "268160233237697351800460921121832519391521815357041008416084888598" //  &
           "27557131190172270346227678454195010189227547853345612460399635783630149M-33"
      call fmst2m(st, c(68))
      st = " 3.994957549418305520762016700744032876853769637744488924267188269" //  &
           "584393732051483805590060972426573672962844815489806656051668047426" //  &
           "97928538442568628891602616126915832496578665989847126282893366534237083M-34"
      call fmst2m(st, c(69))
      st = " 1.331652517070655772993246798258154050119486912201311455268437349" //  &
           "114193156345900532664095994600506577877633489606677937802093759650" //  &
           "12137846480275713137733722530126859812615084188357652189387132980702776M-34"
      call fmst2m(st, c(70))
      st = " 4.438841725063570781178568100283946176488573680079007649477905193" //  &
           "017992386971455066988895758316824569677887493778455225021106826855" //  &
           "29026392300941094435783945574507271437954562521405284456074260144096753M-35"
      call fmst2m(st, c(71))
      st = " 1.479613908728203152730390143133201780942639054825565044507758917" //  &
           "773304661939287594029105088656760879117520103897129013490206639754" //  &
           "87435121659508261905208347102886094942106298340234319457765604513963509M-35"
      call fmst2m(st, c(72))
      st = " 4.932046363361542755686335602696750869830288252199443432734105813" //  &
           "943462260083819436478927601708900720110450661448493818380083105762" //  &
           "71590161306544076696091310423964644508740590548145866774529617253109923M-36"
      call fmst2m(st, c(73))
      st = " 1.644015454687397316689944677831911620211552013511192085616959005" //  &
           "082583370344704494312506871603969621047795163740944612049682148927" //  &
           "59356353337859121253234322350982876222750860528515262326476034089950266M-36"
      call fmst2m(st, c(74))
      st = " 5.480051516208532057249213551633236335403175178397767120722791995" //  &
           "833335758082301610732726590856354303605009314671070073367443285322" //  &
           "81719944336949977298072286244404059176341969451639495219169668432874625M-37"
      call fmst2m(st, c(75))
      st = " 1.826683838882145937413050728363254416465068672788666223790911345" //  &
           "427048802205722820790024964162626522627539834294555447603439041292" //  &
           "92403842411688509922659248102884925797066250995812515878053578599537543M-37"
      call fmst2m(st, c(76))
      st = " 6.088946129972074589720378401074071029218658010685074635511831120" //  &
           "277695386768911269891962771874827650899040106965903278757448364187" //  &
           "28574155937467016044284632565747254397900833533383192879263530571086410M-38"
      call fmst2m(st, c(77))
      st = " 2.029648710081921896663063938682967174463636477103609117669608797" //  &
           "346033378612490707724833983253281429017993058131396854118481222339" //  &
           "85407951679907254491401107628467015394676060959591476686232563916557226M-38"
      call fmst2m(st, c(78))
      st = " 6.765495700501148906774995358078228324235325066490434291070320211" //  &
           "666634035845840680799492809322166392640915607858746928019847633868" //  &
           "45020162815858209793574963810268541266706689851018528823213713218014553M-39"
      call fmst2m(st, c(79))
      st = " 2.255165233557401948601014902186205602789864371948507888958512686" //  &
           "894666882870433310683786297682141353940837232625056953901094633832" //  &
           "03813175465801305121046951268786662654220745685289766957573976902789674M-39"
      call fmst2m(st, c(80))
      st = " 7.517217445333887278263065941349084170211801907036126548415826613" //  &
           "097540864542220787119574822998915671722740530800746773131556370537" //  &
           "17036257265431709600760536998990725283074006064618438905604324155029841M-40"
      call fmst2m(st, c(81))
      st = " 2.505739148480265955233204413682186719497131266833487675446538783" //  &
           "092174430438507742800231748635072748340810415087125614579378635688" //  &
           "66151322710496155055815000392267489014427962480151154107924769960320348M-40"
      call fmst2m(st, c(82))
      st = " 8.352463828356645340468994201986157494921881256993571664141509541" //  &
           "823273109890101870519752598083111861872055684078254288142631302953" //  &
           "90656071678927672118181416754149675034388261080192075026592829943869784M-41"
      call fmst2m(st, c(83))
      st = " 2.784154609474488152611480955615773344997254762720123569187499710" //  &
           "482501105031142742130099147104245620254144813103304543108707461283" //  &
           "03676294384838274788281739537719423506089439601147338491518140111085245M-41"
      call fmst2m(st, c(84))
      st = " 9.280515364970643106573953106487348079696240473524263398418948085" //  &
           "686805363427549650077259362814392417398055197835215069289928148824" //  &
           "67963286545183505632254520821084189068903494611293308100453524544737026M-42"
      call fmst2m(st, c(85))
      st = " 3.093505121670801685004800389514423527223386419080428824653989649" //  &
           "679279518505124420083928960371367692487927529341787666280479065858" //  &
           "20227384416309509890526585569312748427209499872674012860539332555258032M-42"
      call fmst2m(st, c(86))
      st = " 1.031168373893747390707549843146989045155823157470502623225595250" //  &
           "851710797449759760498072278428597174778192322827019231254514348869" //  &
           "35739852926303601231003771300391351671865972802045601948838060198753437M-42"
      call fmst2m(st, c(87))
      st = " 3.437227912987858374961865176796344063877564237772445606496240106" //  &
           "757864483254589585823971686699471956766584959383102055399682270269" //  &
           "52352941784639649980429822410674941181991395320188803002740041936488314M-43"
      call fmst2m(st, c(88))
      st = " 1.145742637664794559805828100464320725242403637362145522388352767" //  &
           "861006812839084798058391247493282342027006725688139044431839514660" //  &
           "53654774876669055000807030176806220727453288403581728457403167939166997M-43"
      call fmst2m(st, c(89))
      st = " 3.819142125554752953067839505315181594779066795846739238810201522" //  &
           "091877503536260790984284322275300395166507566249167177334314175598" //  &
           "37162971702086753249324866744493897786886912065021929714836592305111972M-44"
      call fmst2m(st, c(90))
      st = " 1.273047375186277089451795607705259637601635385366665197585993775" //  &
           "074526908019448436164455682411887757929212685231623835262681489558" //  &
           "82648858340071059461127000212205125717165045854603000054982553620290401M-44"
      call fmst2m(st, c(91))
      st = " 4.243491250624322227579766750508513228093573956231840709615359110" //  &
           "716873987770463557146491514771994072759888669351546219633295358033" //  &
           "66517307409098637643711145428866491214789294814344532842968257523643745M-45"
      call fmst2m(st, c(92))
      st = " 1.414497083542290391545199323374869916206725399320438141384531327" //  &
           "265477522477777915006882588147304129058542612492747596977199928651" //  &
           "94869243918440516701383178149493577193540062534758351817970713054178365M-45"
      call fmst2m(st, c(93))
      st = " 4.714990278476425427697520544930204334035129865733446210245204030" //  &
           "355616997118279522525088487975375771703855109208249987771017533193" //  &
           "90291285366875213381956263086437252260808891626942562877561594888642475M-46"
      call fmst2m(st, c(94))
      st = " 1.571663426159339506535953571864003053494761363991342538284158655" //  &
           "584260596318169435197761794741189000363244392470381778816827538385" //  &
           "70503152182049565811831241089687440405169499752285888183719228270040702M-46"
      call fmst2m(st, c(95))
      st = " 5.238878087199125931711927428699616143954533668740342266002176483" //  &
           "066317524800888207882487253378527961702366607212427983576029574311" //  &
           "70477008468882187587684440329802260450306316947736342927462019072062451M-47"
      call fmst2m(st, c(96))
      st = " 1.746292695733373871385356099575152433557917368382321044143123707" //  &
           "125733276511427813036854586467480879063125488695590156424518309858" //  &
           "40776387319594992052236593986791986838450118314507991811649011797951517M-47"
      call fmst2m(st, c(97))
      st = " 5.820975652445409306654690542379619928753899950100022072575451976" //  &
           "896049502425251330032699117677706811131644722750272961660598812323" //  &
           "95528274546713027672214860795936676307396171912021238503162387066702843M-48"
      call fmst2m(st, c(98))
      st = " 1.940325217482010536060783297163692278507114464120206717431891734" //  &
           "053010284461713330551549047577932453595163579118201359494986630173" //  &
           "01494093463680448771677875123107012368194613913742739952428603002168229M-48"
      call fmst2m(st, c(99))
      st = " 6.467750724940553704809014908981646231351194700919134365131054499" //  &
           "044206347270309742459318050095528539735477919872551695967650699099" //  &
           "88953248180134764653841795790617888566272316181621003159336089850848991M-49"
      call fmst2m(st, c(100))
      st = " 2.155916908313647547754610174771515398662821458991609891428955252" //  &
           "290583442620154212776250181824196267358169201447214242363354724316" //  &
           "89903280067672089810407626181445703141886320049309134936640041251647199M-49"
      call fmst2m(st, c(101))
      st = " 7.186389694379149274561055379686410434878982979762824712204962808" //  &
           "871607736477144813893452054031932010405337926726732941950536667006" //  &
           "84810252591610140816882396575440916998193275137670082479286587744869582M-50"
      call fmst2m(st, c(102))
      st = " 2.395463231459797453698442182708267050312141998051092331530640409" //  &
           "893924848764443035384500574394756654315653015364123642221973250880" //  &
           "68362683781580014370472600811020274312157465907532281112816349722673774M-50"
      call fmst2m(st, c(103))
      st = " 7.984877438199527417773369963127799969498648440970510669498583482" //  &
           "161029591317677710672043612633451504552983943030656888570069226104" //  &
           "04295259910858734307563648182821156659161484763549481645932818220413101M-51"
      call fmst2m(st, c(104))
      st = " 2.661625812733226448952431335647978161413961687446878335164533806" //  &
           "702910875419295287094135193138742564146281522194125689011703047524" //  &
           "45739306220536816835347815852152246454806822705745730784267021864361647M-51"
      call fmst2m(st, c(105))
      st = " 8.872086042444214770744709174167341653906439941556420653788154173" //  &
           "929048445735834186760727780453829909511846845819831435241835442504" //  &
           "04079891107632829549289090071219101574622546793854950277712602194795534M-52"
      call fmst2m(st, c(106))
      st = " 2.957362014148103242140721175656428119533141966179427551155676500" //  &
           "671725653671481845278656623962048055150306031384279834386038577295" //  &
           "72584556615286334177021422182622284915641930082182710316087748100105028M-52"
      call fmst2m(st, c(107))
      st = " 9.857873380493756603533616420387300817360969314828251071875082336" //  &
           "698703611411040709238371719721287012785465953801003782742219530827" //  &
           "73983924014324680294547858829752678323087789357138505841177563631130388M-53"
      call fmst2m(st, c(108))
      st = " 3.285957793497938650277342040351753052374376933619786220663421040" //  &
           "427587332321480401454840426545683394351958951963755749546928108005" //  &
           "75979757809361423163013264428850345811205867029087095522459004260861910M-53"
      call fmst2m(st, c(109))
      st = " 1.095319264499317829033981510140817754508285369349556399833223737" //  &
           "174998151312514038433336840462205568158214000003108865975414472963" //  &
           "70581756862795260586373374661842883378795511151785344346238350698780645M-53"
      call fmst2m(st, c(110))
      st = " 3.651064214997738460800440485464116453512465873766107387248343452" //  &
           "458997203837952291715916094766655886246438013372552836368973829605" //  &
           "29202550932685485563387565304843167421189066345923958359568125707813957M-54"
      call fmst2m(st, c(111))
      st = " 1.217021404999249244605272366723881223583838603878543320302210671" //  &
           "409056933719216026722268770996716099812270381542447122348883231949" //  &
           "38922656964910194439295935941196896773701049861546343314133034224282491M-54"
      call fmst2m(st, c(112))
      st = " 4.056738016664171876197055085310199605151026698635243534713457892" //  &
           "107296169062875134691895441571499550130093746425411512549327123228" //  &
           "16601740468340561446321921103466463550189353682758076018331072415996381M-55"
      call fmst2m(st, c(113))
      st = " 1.352246005554725890610555164289246652995273648088741088360045973" //  &
           "623667364361191345555088170702142598112873445326035312084757222791" //  &
           "25547996491724650392650447881135472685838861374568021340343847835638534M-55"
      call fmst2m(st, c(114))
      st = " 4.507486685182424465064025894185168278371602793396197455600512532" //  &
           "406474418197117862785333707359281266142995363043310398030388775224" //  &
           "96855355439438225180328883970301863313369556592379689501165566142115306M-56"
      call fmst2m(st, c(115))
      st = " 1.502495561727476029111885802751588446409759610042467877987373043" //  &
           "860038180719787874668067312469292183193912200682893897594757683194" //  &
           "08099696091579813882633694420046951596146901116935629924246701724845131M-56"
      call fmst2m(st, c(116))
      st = " 5.008318539091589782265978940332517362043223441916201948536518072" //  &
           "099322344676502315123489826715051040283829780783100995910094849108" //  &
           "65034584595413084839701258466960248343166395950551930374997082566708225M-57"
      call fmst2m(st, c(117))
      st = " 1.669439513030530682061916213454823087218137831151025299167070973" //  &
           "190879095582514009353872307284741332656640434042133116166845579709" //  &
           "81635243531150493888288323800171093455101171326873303863260272601517849M-57"
      call fmst2m(st, c(118))
      st = " 5.564798376768437493472862129317060203208340292866327711857634512" //  &
           "795204118217070748492626708664751935590615442683377362519336018325" //  &
           "51004856969881087903485123401331518636537459253893877449123506707146950M-58"
      call fmst2m(st, c(119))
      st = " 1.854932792256146302807572731110803878429090610101994543365419672" //  &
           "049548214027388780306433203424820289079873088082231836000918687537" //  &
           "23334792833523598579662177790912527794946886117189075782702240392408839M-58"
      call fmst2m(st, c(120))
      st = " 6.183109307520488855150122490825215119994140805333496249840425315" //  &
           "260483680241891966697616887289397465885493861812930613441993149861" //  &
           "75026053269580573584851572426023443652902431378207237270671672948970109M-59"
      call fmst2m(st, c(121))
      st = " 2.061036435840163246497927510477654121008516108356441555748893883" //  &
           "538337771585715140176109550136417103188492842915425790968199189673" //  &
           "75115850238127872748852300922000306375635048830126739836684145179941549M-59"
      call fmst2m(st, c(122))
      st = " 6.870121452800544891946141735609200171965629448722202434217816987" //  &
           "853447483793178217562366316730782300693739885096060635165076652920" //  &
           "41995525029854871068500757566629399110685057219153231404821304733713204M-60"
      call fmst2m(st, c(123))
      st = " 2.290040484266848481553643087076101079355964961713023345779978400" //  &
           "982834140969803837340319397848019038722638870138573135003750122280" //  &
           "67644649360313184772818630784452829131845685063424590204739986167925734M-60"
      call fmst2m(st, c(124))
      st = " 7.633468280889495399107799895007148312706155591452982323077149986" //  &
           "120899748236386385448066771935353332443050965065257767414246512604" //  &
           "54742904592796348751455213798689879834161009662040701046444537526427115M-61"
      call fmst2m(st, c(125))
      st = " 2.544489426963165248184847366204930714902412817306190051775615959" //  &
           "530879632335665207219382767168166468926593335092194936311475724489" //  &
           "22045567698482778031098111145226005087891270132458202092192296860039337M-61"
      call fmst2m(st, c(126))
      st = " 8.481631423210551115155109723717829106916950881296846054083649985" //  &
           "810525218550324029659230629073310007635840875342630862789117074541" //  &
           "87098166442436318923705470772023710069850200723928832617470068484538900M-62"
      call fmst2m(st, c(127))
      st = " 2.827210474403517110353107867003629422731212331386162488716730521" //  &
           "351064005716979204840102164742676308078783782599324060431157817109" //  &
           "88654841674710921627884749621343607380343694451939622450448527669612216M-62"
      call fmst2m(st, c(128))
      st = " 9.424034914678390547763871121100990122397792341363117728757038903" //  &
           "649538172737671552516290289880795766718250080584367536271759196670" //  &
           "39697325553891033518536553021634662617083010606852575129875069462163167M-63"
      call fmst2m(st, c(129))
      st = " 3.141344971559463560901334931474821601568811602982335715041502627" //  &
           "827982932089655486622557870156127718095126494732372850918038888332" //  &
           "54551941638266722522763646352278545149136303285285604558173356388928708M-63"
      call fmst2m(st, c(130))
      st = " 1.047114990519821198212122783269017133872736396216455065194396848" //  &
           "772182771964575553018906528347835085989108829213513953424609300128" //  &
           "95630377523418163375718344777771305545237149991145713842104433495405185M-63"
      call fmst2m(st, c(131))
      st = " 3.490383301732737355486270459507822699258345311341941846849921659" //  &
           "545613492122376436148560471436321288125576975707576514288727189135" //  &
           "81234008256049155059395856211182401981576994675285833396791180771117772M-64"
      call fmst2m(st, c(132))
      st = " 1.163461100577579125523555448655563780187894154820747936001916075" //  &
           "833373823024344903789897831688942109838607391549196509166544386710" //  &
           "32984677138183863587254008956883033409075083480154979676313298835611005M-64"
      call fmst2m(st, c(133))
      st = " 3.878203668591930435982181400901299436435180157598905860060992780" //  &
           "769432703831655807641542938250104063615345695580486254706194715454" //  &
           "60229972174586144050891402920273633768999530012198276610097006412695734M-65"
      call fmst2m(st, c(134))
      st = " 1.292734556197310149719976276646194118747432707279683488755745696" //  &
           "740947679118453560585318506784845508484302703353713015155212188239" //  &
           "59563349122999271475430680808380714359508027924891221587469189007133570M-65"
      call fmst2m(st, c(135))
      st = " 4.309115187324367176714710446351861339597497796718143278961320946" //  &
           "586948534200778409616190905114541820432168004724255101140047339531" //  &
           "16503452628730864113604659140394417734969121530536316322243286765720986M-66"
      call fmst2m(st, c(136))
      st = " 1.436371729108122394983600863166786192397968628737741530628906208" //  &
           "660940944816769480739740878584831113565249313940195309419096432913" //  &
           "23986224865537803560999682866769231274805486620569029108114354610082602M-66"
      call fmst2m(st, c(137))
      st = " 4.787905763693741323475412996513093551712741258381159384549759206" //  &
           "662442822072738588515832300420257228803664662013090680472314997210" //  &
           "47994366822587964409268875557318665191628748298284520227769123490709406M-67"
      call fmst2m(st, c(138))
      st = " 1.595968587897913776207656861993669785407285064500745185434113800" //  &
           "096356494376241989760638754749237977344465547010132327612679509965" //  &
           "90606634208693254568607053260913032981301281185089491854456988622988789M-67"
      call fmst2m(st, c(139))
      st = " 5.319895292993045924981820864535497749048234307774210374132739226" //  &
           "662962493896584326632876715466366610480847242863534749368020824442" //  &
           "26347859777033625778816141835475590087036758263889428530371159240382397M-68"
      call fmst2m(st, c(140))
      st = " 1.773298430997681976066348119317279371541102493785396123709304532" //  &
           "963732653591086234204258910992398206481527117154837605280677866587" //  &
           "40860519847234648346851518177302296315561478928449266143246491562286927M-68"
      call fmst2m(st, c(141))
      st = " 5.910994769992273256235513308905467236327084289024213039675731610" //  &
           "148156011515848201203908937219678972731231236325011698208574736079" //  &
           "80168427550976937837979750480068076198135077050989661245596743172379630M-69"
      call fmst2m(st, c(142))
      st = " 1.970331589997424419415425997445581585340102744812802313473388703" //  &
           "562069927312660229009236127416616182518232875620838559077842053926" //  &
           "92349876121987505300275410560304423025355686582773348179088042892097570M-69"
      call fmst2m(st, c(143))
      st = " 6.567771966658081399727057227641186570727529727910776691977632634" //  &
           "165946988657121076389626270986170591723497353782252176685973776995" //  &
           "43528417602815951738160201869055681397572348387528732209187423794662534M-70"
      call fmst2m(st, c(144))
      st = " 2.189257322219360466994595051007995333389857163416210506204122933" //  &
           "434092909606199446262463730440462471061414357649669288454519822486" //  &
           "33439286916366526139243135196086518512441365472582736479048872262858017M-70"
      call fmst2m(st, c(145))
      st = " 7.297524407397868224362590109254773419614298510807208602130225559" //  &
           "169843334057978765051658253298688634379979983044623872624689424224" //  &
           "07554019829693239747911909633693703476580188084738005493123701521791467M-71"
      call fmst2m(st, c(146))
      st = " 2.432508135799289408382681708766459710814072648334087437525650247" //  &
           "402627470576079904894860765869748078205431190272078201162332612662" //  &
           "86925426506431278564366927546261623009686964819372619868333948357411039M-71"
      call fmst2m(st, c(147))
      st = " 8.108360452664298028596818159143547381983866077866697620113475392" //  &
           "867557609420149388391146208299955439299097511073088600020008797364" //  &
           "90254145831112916894519121436284980569670233198361465597386807462396245M-72"
      call fmst2m(st, c(148))
      st = " 2.702786817554766009695908457319192274936196517820205990720071929" //  &
           "267436760629307786446087225623272749165348119673554381961913455458" //  &
           "93050660537495047726291186100258874974179781198259808664194749915523789M-72"
      call fmst2m(st, c(149))
      st = " 9.009289391849220032728785940466253732893526544523495429162278552" //  &
           "296342689979948102270331957628702643264702399700740206586719143369" //  &
           "63516748801336419497668271497140970017083857566651892279908542196784275M-73"
      call fmst2m(st, c(150))
      st = " 3.003096463949740011011890954041623476083928522268342083771940551" //  &
           "403977301983996687445005688089790997335068650775774411500709972696" //  &
           "00052352997217396436659500075907900727290635046242137258265027272046707M-73"
      call fmst2m(st, c(151))
      st = " 1.001032154649913337029531966564025740882006821416233309378396854" //  &
           "352648141475996724306705629001209846327383244434702908491488661840" //  &
           "33666122248311247777472186264526745924646761167750923503037999124457410M-73"
      call fmst2m(st, c(152))
      st = " 3.336773848833044456828335032653876240316804704924144044073849579" //  &
           "816206165795104200289660358785996996484528456071385377435139123676" //  &
           "57709192610536558746890780425020107260403503414920896791666418548557679M-74"
      call fmst2m(st, c(153))
      st = " 1.112257949611014818958755021576306436637772541032306466006509854" //  &
           "188967690019629658157071337514432146127855476046945605695950179554" //  &
           "39845790791214616926248699635001115509938807913024195016995950944619712M-74"
      call fmst2m(st, c(154))
      st = " 3.707526498703382729922171432032250515805881149465794264372984724" //  &
           "327809012896984209000978195800679443631566152731613311969108735093" //  &
           "51590966384556456803036744807880814153226574822433894031208374029742738M-75"
      call fmst2m(st, c(155))
      st = " 1.235842166234460909984137514518387752942293928074591712157524109" //  &
           "560139067764692539980008571135341128797657051727809999365157975182" //  &
           "53322235173852278845187716078871110242776570216352174337398795667971328M-75"
      call fmst2m(st, c(156))
      st = " 4.119473887448203032778434343895875695597840528814474282367848794" //  &
           "205301550322451475974554397356862932040320235498247930630480575568" //  &
           "25417807718570483485133432555365627049395094885528093686245256557591509M-76"
      call fmst2m(st, c(157))
      st = " 1.373157962482734344263376419251248172548827589625457941472696797" //  &
           "100175825647692982915548765225643706779206935633946071637767635709" //  &
           "79966315426397983742300900492572704510866186342432593363321634147388215M-76"
      call fmst2m(st, c(158))
      st = " 4.577193208275781160777550837017921925055088338901698850930906043" //  &
           "311063967012540679380363564085256672110282867832397021602920753059" //  &
           "62941763379439217899247719980351463557310935320189195654346581389521961M-77"
      call fmst2m(st, c(159))
      st = " 1.525731069425260386985167951519330997746387629867941705993359606" //  &
           "803096607303855736985249240116888915751939824222470295586537784557" //  &
           "14766559903817261522752203057544899378743721133360484530771023423930290M-77"
      call fmst2m(st, c(160))
      st = " 5.085770231417534312974277748264028715371006669759625749888114997" //  &
           "040535088461914628203462029057668451395058320957895155954018999649" //  &
           "89570133824275977321769674422087255596053232511973102592783007464375573M-78"
      call fmst2m(st, c(161))
      st = " 1.695256743805844769769991874189352969259021005362418248962236686" //  &
           "450929128768148436336404059930819742510685161671532907373324896396" //  &
           "92385277655969091090205296324356998243606127274626181023449273081779115M-78"
      call fmst2m(st, c(162))
      st = " 5.650855812686156039218806037909235903455451213739689260418037318" //  &
           "509446943950605499341032642835238412850215403194710979806557582704" //  &
           "37936259002958165848823746298586989930806700558037154118861273544045145M-79"
      call fmst2m(st, c(163))
      st = " 1.883618604228718704933778437940690307805004962163899221957470918" //  &
           "058716333776074607305943978262640017375578856797709581746515819407" //  &
           "51489901662136678406269201616881521607807260952614167843862068838710312M-79"
      call fmst2m(st, c(164))
      st = " 6.278728680762256512126149402150794782943415735579294630724544224" //  &
           "964157228232060226941740181573870879258048900467741995915140892478" //  &
           "63661908097641164941373210234799596031030310767570648902522277881849187M-80"
      call fmst2m(st, c(165))
      st = " 2.092909560254085021914720610883566852288010979452630217312140514" //  &
           "778472364540695790415885690351086108014265966713921440025212436361" //  &
           "73967300532411889825601604598920039776377478055710366101143130338433473M-80"
      call fmst2m(st, c(166))
      st = " 6.976365200849595928554228570881565721048784920515468405614250170" //  &
           "741926248557408642176573843779290903009186026063040672689273898432" //  &
           "88910357288258162475303198325632084369407383550262099668489007926100917M-81"
      call fmst2m(st, c(167))
      st = " 2.325455066949873863603395561978748601800147911008192886172463050" //  &
           "451820515051068562317761231512963759254765453729061173550997868120" //  &
           "58407734788242875774377719715615329774495325545245938734484625573096582M-81"
      call fmst2m(st, c(168))
      st = " 7.751516889786273230324814807015203014115787760363240263773567207" //  &
           "238770582250611249333986919911192763902738500220512285746471179825" //  &
           "77571260191751902463570497659486034004412403189688932637270843323495731M-82"
      call fmst2m(st, c(169))
      st = " 2.583838963261950823749231801853943339353886424780054671299212593" //  &
           "953839989881747235093144189509781483529556454394968872792726683435" //  &
           "27643326289916001403186650841236534106807785205861848342075189337865239M-82"
      call fmst2m(st, c(170))
      st = " 8.612796544966339593458567326158368856673430376795891557224772538" //  &
           "947415233055213978085860502193079097945197318656791149694366866539" //  &
           "72822366330690625287806683992931214418731468102411025539925415006202370M-83"
      call fmst2m(st, c(171))
      st = " 2.870932181657563853681094248589222833815589612305003013771994066" //  &
           "486301003023979828481138638939770854259457931497871219438623202895" //  &
           "38689833732465547124246759187251713896087958971527124804970116015889039M-83"
      call fmst2m(st, c(172))
      st = " 9.569773927459502329186355848231519845153615256953762486987693008" //  &
           "642824433756506369875737104132534466116626389178752624525042798289" //  &
           "22548975065811830797487032916317956125950813783158098289413462007841293M-84"
      call fmst2m(st, c(173))
      st = " 3.189924642457193947274111017893685291988923107347172733780095937" //  &
           "504990242848262256269173114579259710506482337540368636019319969386" //  &
           "73520058153132922629586433368902183759949488890960340616457392616954301M-84"
      call fmst2m(st, c(174))
      st = " 1.063308229833233763649615961280021009800959973857039083389096247" //  &
           "411276485934365597139214502542489173998160641619626621325276246417" //  &
           "76894303109902050056828926820785431328629167285741168999780547981801651M-84"
      call fmst2m(st, c(175))
      st = " 3.544360766480896268661403387806726005830929777366570657261489401" //  &
           "694611013460386506117284436161560434270675994478125024682804092939" //  &
           "15998067887747220478181658639560020083789407982402045792182967207779297M-85"
      call fmst2m(st, c(176))
      st = " 1.181453391991692193233769222790948883554160416544364056162345177" //  &
           "930450135664579747942304147194452606107088227217835015752643760372" //  &
           "89824167494419232372153209806697818554092135462778008255059604732701717M-85"
      call fmst2m(st, c(177))
      st = " 3.938177969065104259816236800771282813142970611653130614923372425" //  &
           "876301727778466158006947186295720851119739977650492841350794668106" //  &
           "75909743699184418774259697017658821999190863053142757985704314111950238M-86"
      call fmst2m(st, c(178))
      st = " 1.312728231460229835781690690024789271337659581458734016769897717" //  &
           "615695172767934655904718896955205839028238358310418293184633392500" //  &
           "09974095126152086147719595157884930629859403536081952476482731834669587M-86"
      call fmst2m(st, c(179))
      st = " 4.375760815315077535413569523720083421030822320092520690986988142" //  &
           "097203566380515277459454385250926657264251938784637571214707790842" //  &
           "13901922704849922902680056772549256776092849835805341467509317300857668M-87"
      call fmst2m(st, c(180))
      st = " 1.458563929048378339389303099779179984031579246114615330084586060" //  &
           "391340363385450968349489278357541331271188532814617890065655968100" //  &
           "90864106047591784785100253214527821779035249121314752150297703091924694M-87"
      call fmst2m(st, c(181))
      st = " 4.861879359454319859107717556333622023158902013437521581162884873" //  &
           "340193641755594234893503470462192100416392001882798233766279202968" //  &
           "02742623676171486751287082335949083937364296608060437072511301740262916M-88"
      call fmst2m(st, c(182))
      st = " 1.620837575639336717669552632235434719742418568812043976527454822" //  &
           "311557369332525067245294696277568831932145434818066929071312277435" //  &
           "59667900060244610446776086220578843202917562200852939911588169882033048M-88"
      call fmst2m(st, c(183))
      st = " 5.402795219201229254205787739591614371703058387299744106863813045" //  &
           "890074410469634798352875615158044666258805327295738061277040804255" //  &
           "11706167845408641690753715592108911157218063444936673090628364776228851M-89"
      call fmst2m(st, c(184))
      st = " 1.799216964519093606731199173063133848252752532638951929530332271" //  &
           "088757960440794118609774620691669941349561692799601479867289303361" //  &
           "36573900179559749556590933182210908857440047681409893684369308365396546M-89"
      call fmst2m(st, c(185))
      st = " 5.997366309057088767075246255186377444897385269608659113392135251" //  &
           "083240010154867782825603589060665479283491811344357943450419502328" //  &
           "30863890415054273770878371228558497389363862954168787497855394907612488M-90"
      call fmst2m(st, c(186))
      st = " 2.011301294926252140726377746074781953178862150579839442308024059" //  &
           "805516340858995612053131399074329904610352755793706433609739823274" //  &
           "35441280105568641478715458116693621474886783585502490686457813740208553M-90"
      call fmst2m(st, c(187))
      st = " 6.704482593621562564692904617177008442804824808114929721560806403" //  &
           "083889880113942537426720271890350736903006981375786722754398310176" //  &
           "64290862799510364108316770714557534855989672010291914054754244834573505M-91"
      call fmst2m(st, c(188))
      st = " 2.160351395289544486253218378105888708749936652071087348664876866" //  &
           "590595135247617954742090212769559780976713437175453455128216319294" //  &
           "79621451615761249300873617293850399062283747501629953564198534458556254M-91"
      call fmst2m(st, c(189))
      st = " 7.200419569439204992397564583120569704507791779761471734959614293" //  &
           "903195879211244064072895412909288124860635443865351473928153163314" //  &
           "35648140579845782685750371868061482151886800120453245481648754938151403M-92"
      call fmst2m(st, c(190))
      st = " 2.784319712626698759566042489347515628094423349698152057970857358" //  &
           "347754564870738442303737360847085557292665631767832280403826508366" //  &
           "53961878379952572306276562137966777737866334027041960083257419418474932M-92"
      call fmst2m(st, c(191))
      st = " 9.284263699802481030477799658347338855061343963325012856142524485" //  &
           "337551481107985173202144915554476793675287039218856327451603285101" //  &
           "60910890143062738353240079101453208140103839949856135593728282192403791M-93"
      call fmst2m(st, c(192))
      st = " 1.469128321729119845643778628274835930841237239875100463308434786" //  &
           "723561392709397386626554407894406027910890887423959020221165249040" //  &
           "77624688503604251276023392875008399104638564047518405899300367036809361M-93"
      call fmst2m(st, c(193))
      st = " 4.886379978539319342120516219783307378314461447995883185804991015" //  &
           "296960664895043875586362313203658735183472813064062209400386162722" //  &
           "42806131645480493919198786449897808824436924850601891974937230254873784M-94"
      call fmst2m(st, c(194))
      st = " 7.046670647920504479063472745872909513874517692559573509267252909" //  &
           "755965774748698930668458487567120021155413053722800379339662049820" //  &
           "26470884186471084008635684699341681154401901074420825646205892400124466M-94"
      call fmst2m(st, c(195))
      st = " 2.351541158501990523752731183260855698650611680331234753194545827" //  &
           "615066582884384059556932538832948082760844393963381962615300495238" //  &
           "72892129343291577201989578726783775602985638203462774865396580295272103M-94"
      call fmst2m(st, c(196))

      ndig = ndsave

      return
      end subroutine fmgam_c

      subroutine fmgam_m(ma, mxy, mresult, ndsave, numtry)

!  Method 1 for computing gamma(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(17), mresult
      integer :: ndsave, numtry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult

      double precision :: x, z
      integer :: j, kdiff, kfl, krflct, kwrnsv, nmethd
      logical, external :: fmcomp

      call fmequ(ma, mxy(1), ndsave, ndig)

!             See if there is a small integer separating this argument from the last one.

      if (mbase == mbsgam .and. ndig <= ndggam) then
          if (ma%mp(1) == -1) then
              call fmint(mxy(1), mxy(10))
              if (fmcomp(mxy(1), '==', mxy(10))) then
                  call fmunknown(mresult)
                  kflag = -4
                  return
              endif
          endif
          call fmsub(mxy(1), m_gamma_ma, mxy(7))
          if (mxy(7)%mp(3) == 0) then
              call fmeq(m_gamma_mb, mresult)
              return
          endif
          kwrnsv = kwarn
          kwarn = 0
          call fmm2i(mxy(7), kdiff)
          kwarn = kwrnsv
          if (kflag == 0 .and. abs(kdiff) <= 50) then
              if (kdiff > 0) then
                  call fmeq(m_gamma_ma, mxy(10))
              else
                  call fmeq(mxy(1), mxy(10))
              endif
              call fmeq(mxy(10), mxy(9))
              do j = 1, abs(kdiff)-1
                 call fmi2m(1, mxy(5))
                 call fmadd_r1(mxy(10), mxy(5))
                 call fmmpy_r1(mxy(9), mxy(10))
              enddo
              if (kdiff > 0) then
                  call fmmpy(m_gamma_mb, mxy(9), mxy(11))
              else
                  call fmdiv(m_gamma_mb, mxy(9), mxy(11))
              endif
              call fmgam_sg(mxy)
              call fmeq(mxy(11), mresult)
              return
          endif
      endif
      call fmeq(mxy(1), mxy(15))

!             Near zero Gamma(x) is about 1/x.

      if (mxy(15)%mp(2) < (-ndig-3)) then
          call fmi2m(1, mxy(5))
          call fmdiv(mxy(5), mxy(15), mxy(11))
          call fmgam_sg(mxy)
          call fmeq(mxy(11), mresult)
          return
      endif

!             Check for special cases.

      krflct = 0
      call fmdpm(dble(-0.5), mxy(7))
      if (fmcomp(mxy(15), '<=', mxy(7))) then
          krflct = 1
          kfl = 0
          if (mxy(1)%mp(2) <= ndsave) then
              call fmint(mxy(15), mxy(10))
              if (fmcomp(mxy(15), '==', mxy(10))) kfl = -4
          else
              kfl = -4
          endif
          if (kfl /= 0) then
              call fmunknown(mresult)
              kflag = -4
              return
          else
              call fmi2m(1, mxy(5))
              call fmsub_r2(mxy(5), mxy(15))
          endif
      endif

!             Determine which method to use.

!             nmethd = 1 means use the polynomial approximation,
!                    = 2 means use the asymptotic series.

      nmethd = 1
      call fmnint(mxy(15), mxy(2))
      call fmsub(mxy(15), mxy(2), mxy(6))
      call fmm2dp(mxy(6), z)
      z = max(abs(z), 1.0d-50)
      if (kflag /= 0 .or. abs(z) >= 1) then
          nmethd = 2
      else
          if (190*log(z) - 77*dlogtn >= -(ndig+1)*dlogmb .or. -190*dlogtn >= -ndig*dlogmb) then
              nmethd = 2
          endif
      endif
      call fmm2dp(mxy(15), x)
      if (kflag /= 0) then
          nmethd = 2
      else if (nmethd == 1) then
          if (x > 145 - (8+ndig*dlogmb/(25*dlogtn))*log(z) .or. x > 250) nmethd = 2
      endif
      if (nmethd == 1) then
          call fmgam_m1(ma, mxy, mresult, ndsave, numtry, z, krflct)
      else
          call fmgam_m2(mxy, mresult)
      endif
      call fmgam_rfl(mxy, mresult, krflct)

      return
      end subroutine fmgam_m

      subroutine fmgam_m1(ma, mxy, mresult, ndsave, numtry, z, krflct)

!  Method 1 for computing gamma(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(17), mresult
      integer :: ndsave, numtry, krflct
      double precision :: z
      intent (in) :: ma, ndsave, numtry, z
      intent (inout) :: mxy, mresult, krflct

      integer :: j, j2, k, k0, k1, k2, kdiff, kfl, kl, kls, kwrnsv, lshift, ndsav1, nterm
      type(multi), save :: mjsums(ljsums), c(0:196)
      integer, save :: ndig_c = 0
      real (kind(1.0d0)), save :: mbase_c = 0
      logical, external :: fmcomp

!             Method 1.  Use the polynomial c(0) + c(1)*(x-3) + ... + c(196)*(x-3)**196

      call fmequ(ma, mxy(1), ndsave, ndig)
      if (ma%mp(1) > 0 .and. ndsave+ngrd52 < ndig .and. numtry == 0) ndig = ndsave + ngrd52

!             Since precision may have changed, check again to see if the saved value from a
!             previous call can be used as a shortcut.

      if (mbase == mbsgam .and. ndig <= ndggam) then
          if (ma%mp(1) == -1) then
              call fmint(mxy(1), mxy(10))
              if (fmcomp(mxy(1), '==', mxy(10))) then
                  call fmunknown(mresult)
                  kflag = -4
                  krflct = 0
                  return
              endif
          endif
          call fmsub(mxy(1), m_gamma_ma, mxy(7))
          if (mxy(7)%mp(3) == 0) then
              call fmeq(m_gamma_mb, mresult)
              krflct = 0
              return
          endif
          kwrnsv = kwarn
          kwarn = 0
          call fmm2i(mxy(7), kdiff)
          kwarn = kwrnsv
          if (kflag == 0 .and. abs(kdiff) <= 50) then
              if (kdiff > 0) then
                  call fmeq(m_gamma_ma, mxy(10))
              else
                  call fmeq(mxy(1), mxy(10))
              endif
              call fmeq(mxy(10), mxy(9))
              do j = 1, abs(kdiff)-1
                 call fmi2m(1, mxy(5))
                 call fmadd_r1(mxy(10), mxy(5))
                 call fmmpy_r1(mxy(9), mxy(10))
              enddo
              if (kdiff > 0) then
                  call fmmpy(m_gamma_mb, mxy(9), mxy(11))
              else
                  call fmdiv(m_gamma_mb, mxy(9), mxy(11))
              endif
              call fmgam_sg(mxy)
              call fmeq(mxy(11), mresult)
              krflct = 0
              return
          endif
      endif
      call fmm2i(mxy(2), lshift)
      lshift = lshift - 3
      if (ndig_c < ndig .or. mbase_c /= mbase) then
          call fmgam_c(ndig_c, mbase_c, c)
      endif
      j2 = (0.38*log(z) + 4.1)*(ndig*dlogmb/(84*dlogtn))
      j2 = max(2, min(j2+mod(j2, 2), ljsums))
      ndsav1 = ndig
      do j = 1, 2
         call fmeq(c(j-1), mjsums(j))
      enddo
      call fmsqr(mxy(6), mxy(5))
      call fmeq(mxy(5), mxy(17))
      nterm = 1
      kl = 1
      do while (kl == 1)
         if (nterm > 1) then
             k = ndig
             ndig = ndsav1
             call fmcsmpy_r1(mxy(17), mxy(5))
             ndig = k
         endif
         do j = 1, 2
            nterm = nterm + 1
            call fmeq(mxy(17), mxy(4))
            call fmcsmpy_r1(mxy(4), c(nterm))
            ndig = ndsav1
            call fmcsaddnn_r1(mjsums(j), mxy(4))
            if (kflag /= 0 .or. nterm == 13) then
                kl = 0
                exit
            endif
            ndig = ndsav1 - int(mjsums(j)%mp(2)-mxy(4)%mp(2))
            ndig = min(ndsav1, ndig)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         enddo
      enddo
      kfl = kflag
      kflag = 0
      call fmcsnsums(2, mjsums)
      ndig = ndsav1
      call fmeq(mjsums(2), mxy(16))
      call fmeq(mxy(6), mxy(3))
      call fmcsmpy_r1(mxy(16), mxy(3))
      call fmcsadd_r1(mxy(16), mjsums(1))
      kls = 1
      if (kfl == 0) then
          call fmcsmpy_r1(mxy(17), mxy(5))
      else
          call fmi2m(0, mxy(8))
          kls = 0
      endif

      if (kls == 1) then
          call fmi2m(1, mxy(4))
          do j = 14, j2+13
             call fmadd(c(j), mxy(4), mjsums(j-13))
          enddo
          call fmipwr(mxy(6), j2, mxy(5))
          call fmeq(mxy(5), mxy(7))
          nterm = j2 + 13
          kl = 1
          do while (kl == 1)
             if (nterm > j2+13) call fmcsmpy_r1(mxy(7), mxy(5))
             do j = 1, j2
                nterm = nterm + 1
                call fmeq(mxy(7), mxy(4))
                call fmcsmpy_r1(mxy(4), c(nterm))
                ndig = ndsav1
                call fmcsaddnn_r1(mjsums(j), mxy(4))
                if (kflag /= 0 .or. nterm == 196) then
                    kl = 0
                    exit
                endif
                ndig = ndsav1 - int(mjsums(j)%mp(2)-mxy(4)%mp(2))
                ndig = min(ndsav1, ndig)
                if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
             enddo
          enddo
          kflag = 0
          call fmcsnsums(j2, mjsums)
          ndig = ndsav1
          if (nterm == 196) then
              call fmgam_m2(mxy, mresult)
              return
          endif
          call fmi2m(1, mxy(4))
          call fmsub(mjsums(j2), mxy(4), mxy(8))
          call fmeq(mxy(6), mxy(3))
          call fmnegate(mxy(3))
          do j = 2, j2
             call fmcsmpy_r1(mxy(8), mxy(3))
             call fmsub_r1(mjsums(j2-j+1), mxy(4))
             call fmcsadd_r1(mxy(8), mjsums(j2-j+1))
          enddo
      endif

!             Recover from using a shifted argument.

      call fmcsmpy_r1(mxy(8), mxy(17))
      call fmadd(mxy(8), mxy(16), mxy(10))
      if (lshift < 0) then
          call fmeq(mxy(15), mxy(3))
          call fmeq(mxy(15), mxy(14))
          do j = 2, -lshift
             call fmaddi(mxy(14), 1)
             call fmcsmpy_r1(mxy(3), mxy(14))
          enddo
          call fmdiv_r1(mxy(10), mxy(3))
      endif
      if (lshift > 0) then
          if (mod(lshift, 4) == 0) then
              call fmi2m(1, mxy(3))
              call fmeq(mxy(6), mxy(14))
              call fmaddi(mxy(14), 3)
          else
              call fmeq(mxy(6), mxy(3))
              call fmaddi(mxy(3), 3)
              call fmeq(mxy(3), mxy(14))
              do j = 1, mod(lshift, 4)-1
                 call fmaddi(mxy(14), 1)
                 call fmcsmpy_r1(mxy(3), mxy(14))
              enddo
              call fmaddi(mxy(14), 1)
          endif
          lshift = lshift - mod(lshift, 4)

!             The product z*(z+1)*...*(z+lshift-1) is computed four terms at a time to reduce
!             the number of fmmpy calls.

!             mxy(14) is z
!             mxy(6) is z**2
!             mxy(7) is z**3
!             mxy(8) is (z+k)*...*(z+k+3)
!             mxy(11) is the current product

          call fmi2m(1, mxy(11))
          if (lshift > 0) then
              call fmsqr(mxy(14), mxy(6))
              call fmmpy(mxy(14), mxy(6), mxy(7))
              call fmsqr(mxy(6), mxy(8))
              call fmcsmpyi(mxy(7), 6, mxy(12))
              call fmcsadd_r1(mxy(8), mxy(12))
              call fmcsmpyi(mxy(6), 11, mxy(12))
              call fmcsadd_r1(mxy(8), mxy(12))
              call fmcsmpyi(mxy(14), 6, mxy(12))
              call fmcsadd_r1(mxy(8), mxy(12))
              call fmeq(mxy(8), mxy(11))
              call fmcsmpyi_r1(mxy(7), 16)
              do k = 0, lshift-8, 4
                 call fmcsadd_r1(mxy(8), mxy(7))
                 k2 = 24*(2*k + 7)
                 call fmcsmpyi(mxy(6), k2, mxy(12))
                 call fmcsadd_r1(mxy(8), mxy(12))
                 if (k <= sqrt(real(intmax)/49.0)) then
                     k1 = 8*(6*k*k + 42*k + 79)
                     call fmcsmpyi(mxy(14), k1, mxy(12))
                     call fmcsadd_r1(mxy(8), mxy(12))
                 else
                     k1 = 48*k
                     call fmcsmpyi(mxy(14), k1, mxy(12))
                     call fmcsmpyi_r1(mxy(12), k)
                     call fmcsadd_r1(mxy(8), mxy(12))
                     k1 = 336*k + 632
                     call fmcsmpyi(mxy(14), k1, mxy(12))
                     call fmcsadd_r1(mxy(8), mxy(12))
                 endif
                 if (k <= (real(intmax)/17.0)**0.3333) then
                     k0 = 8*(2*k + 7)*(k*k + 7*k + 15)
                     call fmaddi(mxy(8), k0)
                 else if (k <= sqrt(real(intmax)*0.9)) then
                     k0 = 8*(2*k + 7)
                     call fmi2m(k0, mxy(12))
                     k0 = k*k + 7*k + 15
                     call fmcsmpyi_r1(mxy(12), k0)
                     call fmcsadd_r1(mxy(8), mxy(12))
                 else
                     k0 = 8*(2*k + 7)
                     call fmi2m(k0, mxy(12))
                     call fmcsmpyi(mxy(12), k, mxy(9))
                     call fmcsmpyi_r1(mxy(9), k)
                     call fmcsadd_r1(mxy(8), mxy(9))
                     k0 = 7*k + 15
                     call fmcsmpyi_r1(mxy(12), k0)
                     call fmcsadd_r1(mxy(8), mxy(12))
                 endif
                 call fmcsmpy_r1(mxy(11), mxy(8))
              enddo
          endif
          call fmcsmpy_r1(mxy(11), mxy(3))
          call fmcsmpy_r1(mxy(10), mxy(11))
      endif
      call fmeq(mxy(10), mxy(11))

      call fmeq(mxy(11), mresult)

      return
      end subroutine fmgam_m1

      subroutine fmgam_m2(mxy, mresult)

!  Method 2 for computing gamma(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(17), mresult
      intent (inout) :: mxy, mresult

      integer :: iextra, inta, k, k0, k1, k2, kwsave, large, lshift, ndsav2

!             Method 2.  Use the Ln(Gamma(z)) asymptotic series, then use exp.
!                        To speed the asymptotic series calculation,
!                        increase the argument by lshift.

      kwsave = kwarn
      kwarn = 0
      call fmm2i(mxy(15), inta)
      kwarn = kwsave

      if (kflag == -4) then
          lshift = 0
      else
          lshift = max(0, int(real(ndig)*alogmb/4.46-real(inta)))
      endif
      if (lshift > 0) lshift = 4*(lshift/4 + 1)
      if (kflag == 0) then
          if (inta <= max(200, int(dlogmb*ndig))) then
              if (inta <= 2) then
                  call fmi2m(1, mxy(11))
                  call fmgam_sg(mxy)
                  call fmeq(mxy(11), mresult)
                  return
              endif
              inta = inta - 1
              call fmfcti(inta, mxy(11))
              call fmgam_sg(mxy)
              call fmeq(mxy(11), mresult)
              return
          endif
      endif

      if (lshift /= 0) then
          call fmi2m(lshift, mxy(5))
          call fmadd(mxy(15), mxy(5), mxy(14))
      else
          call fmeq(mxy(15), mxy(14))
      endif

!             Get Gamma for the shifted argument.

!             Compute iextra, the number of extra digits required to compensate for cancellation
!             error when the argument is large.

      iextra = min(max(int(mxy(14)%mp(2))-1, 0), int(1.0+alogmx/alogmb))
      if (mxy(14)%mp(2) >= mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(14), ndig, ndig+iextra)
          call fmequ_r1(mxy(15), ndig, ndig+iextra)
      endif
      ndsav2 = ndig
      ndig = ndig + iextra
      call fmlngm(mxy(14), mxy(4))
      call fmexp(mxy(4), mxy(11))

      ndig = ndsav2

!             Reverse the shifting.
!             The product ma*(ma+1)*...*(ma+lshift-1) is computed four terms at a time to reduce
!             the number of fmmpy calls.

!             mxy(6)  is z
!             mxy(7)  is z**2
!             mxy(8)  is z**3
!             mxy(9)  is (z+k)*...*(z+k+3)
!             mxy(12) is the current product

      call fmeq(mxy(15), mxy(6))
      if (lshift > 0) then
          call fmsqr(mxy(6), mxy(7))
          call fmmpy(mxy(6), mxy(7), mxy(8))
          call fmsqr(mxy(7), mxy(9))
          call fmcsmpyi(mxy(8), 6, mxy(13))
          call fmcsadd_r1(mxy(9), mxy(13))
          call fmcsmpyi(mxy(7), 11, mxy(13))
          call fmcsadd_r1(mxy(9), mxy(13))
          call fmcsmpyi(mxy(6), 6, mxy(13))
          call fmcsadd_r1(mxy(9), mxy(13))
          call fmeq(mxy(9), mxy(12))
          call fmcsmpyi_r1(mxy(8), 16)
          large = intmax
          do k = 0, lshift-8, 4
             call fmcsadd_r1(mxy(9), mxy(8))
             k2 = 24*(2*k + 7)
             call fmcsmpyi(mxy(7), k2, mxy(13))
             call fmcsadd_r1(mxy(9), mxy(13))
             if (k <= sqrt(real(large)/49.0)) then
                 k1 = 8*(6*k*k + 42*k + 79)
                 call fmcsmpyi(mxy(6), k1, mxy(13))
                 call fmcsadd_r1(mxy(9), mxy(13))
             else
                 k1 = 48*k
                 call fmcsmpyi(mxy(6), k1, mxy(13))
                 call fmcsmpyi_r1(mxy(13), k)
                 call fmcsadd_r1(mxy(9), mxy(13))
                 k1 = 336*k + 632
                 call fmcsmpyi(mxy(6), k1, mxy(13))
                 call fmcsadd_r1(mxy(9), mxy(13))
             endif
             if (k <= (real(large)/17.0)**0.3333) then
                 k0 = 8*(2*k + 7)*(k*k + 7*k + 15)
                 call fmaddi(mxy(9), k0)
             else if (k <= sqrt(real(large)*0.9)) then
                 k0 = 8*(2*k + 7)
                 call fmi2m(k0, mxy(13))
                 k0 = k*k + 7*k + 15
                 call fmcsmpyi_r1(mxy(13), k0)
                 call fmcsadd_r1(mxy(9), mxy(13))
             else
                 k0 = 8*(2*k + 7)
                 call fmi2m(k0, mxy(13))
                 call fmcsmpyi(mxy(13), k, mxy(10))
                 call fmcsmpyi_r1(mxy(10), k)
                 call fmcsadd_r1(mxy(9), mxy(10))
                 k0 = 7*k + 15
                 call fmcsmpyi_r1(mxy(13), k0)
                 call fmcsadd_r1(mxy(9), mxy(13))
             endif
             call fmcsmpy_r1(mxy(12), mxy(9))
          enddo
          call fmdiv_r1(mxy(11), mxy(12))
      endif

      call fmgam_sg(mxy)
      call fmeq(mxy(11), mresult)

      return
      end subroutine fmgam_m2

      subroutine fmgam_rfl(mxy, mresult, krflct)

!  Use the reflection formula if ma was less than -1/2.

      use fmvals
      implicit none

      type(multi) :: mxy(17), mresult
      integer :: krflct
      intent (in) :: krflct
      intent (inout) :: mxy, mresult

      integer :: krsave, ksign
      logical, external :: fmcomp

      if (krflct == 1) then

!             Reduce the argument before multiplying by Pi.

          call fmnint(mxy(15), mxy(7))
          call fmdivi(mxy(7), 2, mxy(8))
          call fmint(mxy(8), mxy(2))
          call fmmpyi(mxy(2), 2, mxy(9))
          ksign = -1
          if (fmcomp(mxy(7), '==', mxy(9))) ksign = 1
          call fmsub(mxy(15), mxy(7), mxy(10))
          call fmpi(mxy(12))
          call fmmpy_r1(mxy(12), mxy(10))
          krsave = krad
          krad = 1
          call fmsin(mxy(12), mxy(3))
          mxy(3)%mp(1) = ksign*mxy(3)%mp(1)
          krad = krsave
          call fmpi(mxy(12))
          call fmdiv_r2(mxy(12), mxy(3))
          call fmdiv_r2(mxy(3), mxy(11))
          call fmgam_sg(mxy)
          call fmeq(mxy(11), mresult)
      endif

      return
      end subroutine fmgam_rfl

      subroutine fmgam_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = gamma(ma).

!  kresult = 1 is returned if a special case gives the value of gamma(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(17), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j, k
      double precision :: d
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMGAM    '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      if (ma%mp(2) == mexpov .and. ma%mp(1) > 0) then
          call fmoverflow(1, mresult)
          if (huge(mbase)/mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          mresult%mp(4) = huge(mbase)/d
          mresult%mp(5) = -(1.0d0 - epsilon(1.0d0)) * maxint
          kresult = 1
          return
      endif

      if (kround /= 1 .and. ma%mp(2) < -ndsave) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          call fmi2m(1, mxy(1))
          call fmdiv(mxy(1), malocal, mxy(2))
          call fmeulr(mxy(1))
          call fmsub(mxy(2), mxy(1), mresult)
          if (kflag > 0) kflag = 0
          ntrace = j
          kwarn = k
          kresult = 1
          return
      endif

      return
      end subroutine fmgam_sc

      subroutine fmgam_sg(mxy)

!  Save the current values of ma and gamma(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(17)
      intent (in) :: mxy

      if (abs(mxy(1)%mp(2)) < mexpov .and. abs(mxy(11)%mp(2)) < mexpov) then
          call fmeq(mxy(1), m_gamma_ma)
          call fmeq(mxy(11), m_gamma_mb)
          ndggam = ndig
          mbsgam = mbase
      endif

      return
      end subroutine fmgam_sg

      subroutine fmgcdi(n1, n2)

!  Find the greatest common divisor of n1 and n2, and return both having been divided by their gcd.
!  Both must be positive.

      use fmvals
      implicit none
      integer :: n1, n2
      intent (inout) :: n1, n2

      integer :: k1, k2, k3

      k1 = max(n1, n2)
      k2 = min(n1, n2)
      k3 = mod(k1, k2)
      do while (k3 > 0)
         k1 = k2
         k2 = k3
         k3 = mod(k1, k2)
      enddo

      n1 = n1/k2
      n2 = n2/k2

      return
      end subroutine fmgcdi

      subroutine fmhtbl

!  Initialize two hash tables that are used for character look-up during input conversion.

      use fmvals
      implicit none

      integer :: j, kpt
      character :: lchars(21) = (/                                             &
                  '+', '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',  &
                  '.', 'E', 'D', 'Q', 'M', 'e', 'd', 'q', 'm' /)
      integer :: ltypes(21) = (/ 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4 /)
      integer :: lvals(21) = (/  1,-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0 /)

      do j = lhash1, lhash2
         khasht(j) = 5
         khashv(j) = 0
      enddo
      do j = 1, 21
         kpt = ichar(lchars(j))
         if (kpt < lhash1 .or. kpt > lhash2) then
             write (kw,                                                          &
                "(/' Error in input conversion.'/"                           //  &
                "' ICHAR function was out of range for the current', "       //  &
                "' dimensions.'/' ICHAR(''', A, ''') gave the value ', "     //  &
                "I12, ', which is outside the currently'/' dimensioned', "   //  &
                "' bounds of (', I5, ':', I5, ') for variables KHASHT ', "   //  &
                "'and KHASHV.'/' Re-define the two parameters ', "           //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain', "    //  &
                "' all possible output values from ICHAR.'//)"                   &
                   ) lchars(j), kpt, lhash1, lhash2
         else
             khasht(kpt) = ltypes(j)
             khashv(kpt) = lvals(j)
         endif
      enddo
      lhash = 1

      return
      end subroutine fmhtbl

      subroutine fmhypot(ma, mb, mc)

!  mc = sqrt( ma**2 + mb**2 )

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(2), mresult

      call fmalloc(mc, ndig+2)
      call fmenter2(ma, mb, kovun, mxsave, ndsave)
      call fmhypot_sc(ma, mb, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mc, kovun, mxsave, ndsave)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmhypot_m1(ma, mb, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mc, kovun, mxsave, ndsave)

      return
      end subroutine fmhypot

      subroutine fmhypot_m1(ma, mb, mxy, mresult, ndsave)

!  Method 1 for computing sqrt( ma**2 + mb**2 )

      use fmvals
      implicit none

      type(multi) :: ma, mb, mxy(2), mresult
      integer :: ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult

      call fmequ(ma, mxy(1), ndsave, ndig)
      call fmequ(mb, mxy(2), ndsave, ndig)

      call fmsqr_r1(mxy(1))
      call fmsqr_r1(mxy(2))
      call fmadd_r1(mxy(1), mxy(2))
      call fmsqrt(mxy(1), mresult)

      return
      end subroutine fmhypot_m1

      subroutine fmhypot_sc(ma, mb, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = sqrt( ma**2 + mb**2 ).

!  kresult = 1 is returned if a special case gives the value of sqrt( ma**2 + mb**2 )

      use fmvals
      implicit none

      type(multi) :: ma, mb, mxy(2), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j
      double precision :: xe, ye
      logical, external :: fmcomp

      kresult = 0

      namest(ncall) = 'FMHYPOT  '
      j = ndig
      ndig = ndsave
      call fmntr_inp2(ma, mb)
      ndig = j

      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) then
          if (ma%mp(5) >= 0 .or. mb%mp(5) >= 0) then
              call fmunknown(mresult)
              kresult = 1
              return
          endif
      endif

      if (kround /= 1) then
          call fmequ(ma, mxy(1), ndsave, ndig)
          call fmequ(mb, mxy(2), ndsave, ndig)
          mxy(1)%mp(1) = 1
          mxy(2)%mp(1) = 1
          if (fmcomp(mxy(1), '>=', mxy(2))) then
              call fmsqr_r1(mxy(2))
              call fmdivi_r1(mxy(2), 2)
              call fmdiv_r1(mxy(2), mxy(1))
              call fmovun_xe(mxy(1), xe)
              call fmovun_xe(mxy(2), ye)
              if (xe > ye+ndsave) then
                  call fmadd(mxy(1), mxy(2), mresult)
                  kresult = 1
                  return
              endif
          else
              call fmsqr_r1(mxy(1))
              call fmdivi_r1(mxy(1), 2)
              call fmdiv_r1(mxy(1), mxy(2))
              call fmovun_xe(mxy(1), xe)
              call fmovun_xe(mxy(2), ye)
              if (ye > xe+ndsave) then
                  call fmadd(mxy(2), mxy(1), mresult)
                  kresult = 1
                  return
              endif
          endif
      endif

      return
      end subroutine fmhypot_sc

      subroutine fmi2m(ival, ma)

!  ma = ival

!  Convert an integer to fm format.

!  The conversion is exact if ival is less than mbase**ndig, otherwise the result is
!  an approximation.

!  This routine performs the trace printing for the conversion.  fmi2m2 is used to do
!  the arithmetic

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ival
      intent (inout) :: ma

      ncall = ncall + 1
      if (ntrace /= 0) then
          namest(ncall) = 'FMI2M'
          call fmntr_inpi(ival)

          call fmi2m2(ival, ma)

          call fmntr_out1(ma)
      else
          call fmi2m2(ival, ma)
      endif
      ncall = ncall - 1

      return
      end subroutine fmi2m

      subroutine fmi2m2(ival, ma)

!  ma = ival.  Internal integer conversion routine.

!  The conversion is exact if ival is less than mbase**ndig, otherwise fmdpm2 is used to get
!  an approximation.

      use fmvals
      implicit none

      integer :: ival
      type(multi) :: ma
      intent (in) :: ival
      intent (inout) :: ma

      double precision :: x
      real (kind(1.0d0)) :: mk, ml, mval
      integer :: j, k, nmval, nv2

      call fmalloc(ma, ndig+2)

      if (mblogs /= mbase) call fmcons
      kflag = 0

      mval = abs(ival)
      nmval = int(mval)
      nv2 = nmval - 1
      if (mval > mxbase .or. nmval /= abs(ival) .or. nv2 /= abs(ival)-1) then
          call fmi2m2s(ival, ma)
          return
      endif

!             Check for small ival.

      if (mval < mbase) then
          do j = 4, ndig+2
             ma%mp(j) = 0
          enddo
          if (ival >= 0) then
              ma%mp(3) = ival
              ma%mp(1) = 1
          else
              ma%mp(3) = -ival
              ma%mp(1) = -1
          endif
          if (ival == 0) then
              ma%mp(2) = 0
          else
              ma%mp(2) = 1
          endif
          return
      endif

!             Compute and store the digits, right to left.

      ma%mp(2) = 0
      j = ndig + 2
      do while (j >= 3)
         mk = aint (mval/mbase)
         ml = mval - mk*mbase
         ma%mp(2) = ma%mp(2) + 1
         ma%mp(j) = ml
         if (mk > 0) then
             mval = mk
             j = j - 1
             if (j >= 3) cycle

!                  Here ival cannot be expressed exactly.

             x = ival
             call fmdpm2(x, ma)
             return
         else
             exit
         endif
      enddo

!             Normalize ma.

      if (j > 3) then
          do k = j, ndig+2
             ma%mp(k-j+3) = ma%mp(k)
          enddo
          do k = ndig-j+6, ndig+2
             ma%mp(k) = 0
          enddo
      endif

      ma%mp(1) = 1
      if (ival < 0 .and. ma%mp(2) /= munkno .and. ma%mp(3) /= 0) ma%mp(1) = -1

      return
      end subroutine fmi2m2

      subroutine fmi2m2s(ival, ma)

!  ma = ival.  Internal integer conversion routine.

!  This routine is called when m-variable precision is less than integer precision.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ival
      intent (inout) :: ma

      double precision :: x
      real (kind(1.0d0)) :: ml
      integer :: j, k, kbase, kmk, kval

      call fmalloc(ma, ndig+2)

      if (mblogs /= mbase) call fmcons
      kflag = 0

!             Check for small ival.

      kval = abs(ival)
      kbase = int(mbase)
      if (kval < kbase) then
          do j = 4, ndig+2
             ma%mp(j) = 0
          enddo
          if (ival >= 0) then
              ma%mp(3) = ival
              ma%mp(1) = 1
          else
              ma%mp(3) = -ival
              ma%mp(1) = -1
          endif
          if (ival == 0) then
              ma%mp(2) = 0
          else
              ma%mp(2) = 1
          endif
          return
      endif

!             Compute and store the digits, right to left.

      ma%mp(2) = 0
      j = ndig + 2
      do while (j >= 3)
         kmk = kval / kbase
         ml = kval - kmk*kbase
         ma%mp(2) = ma%mp(2) + 1
         ma%mp(j) = ml
         if (kmk > 0) then
             kval = kmk
             j = j - 1
             if (j >= 3) cycle

!                  Here ival cannot be expressed exactly.

             x = ival
             call fmdpm2(x, ma)
             return
         else
             exit
         endif
      enddo

!             Normalize ma.

      if (j > 3) then
          do k = j, ndig+2
             ma%mp(k-j+3) = ma%mp(k)
          enddo
          do k = ndig-j+6, ndig+2
             ma%mp(k) = 0
          enddo
      endif

      ma%mp(1) = 1
      if (ival < 0 .and. ma%mp(2) /= munkno .and. ma%mp(3) /= 0) ma%mp(1) = -1

      return
      end subroutine fmi2m2s

      subroutine fmibta(mx, ma, mb, mc)

!  mc = incomplete beta(mx,ma,mb)

!  Integral from 0 to mx of  t**(ma-1) * (1-t)**(mb-1)  dt.

!  0 <= mx <= 1,    0 < ma,    0 <= mb.

!  Some comments below refer to this function and its arguments as b(x,a,b).

      use fmvals
      implicit none

      type(multi) :: mx, ma, mb, mc
      intent (in) :: mx, ma, mb
      intent (inout) :: mc

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, n_acc
      type(multi), save :: mxy(40), mresult

      call fmalloc(mc, ndig+2)
      call fmenter3(mx, ma, mb, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmibta_sc(mx, ma, mb, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mc, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      call fmibta_m(mx, ma, mb, mxy, mresult, ndsave, mxsave, n_acc)

      call fmexit1(mresult, mc, kovun, mxsave, ndsave)

      return
      end subroutine fmibta

      subroutine fmibta2(k_return_code, mxy, mxsave, nterms, numtry, nmethd)

!  Check for various special cases in incomplete beta.

      use fmvals
      implicit none

      integer :: k_return_code, nterms, numtry, nmethd
      type(multi) :: mxy(40)
      real (kind(1.0d0)) :: mxsave
      intent (in) :: mxsave
      intent (inout) :: k_return_code, mxy, nterms, numtry, nmethd

      integer :: iextra, j, j4, jr, jswitch, k, krsave, n, nd, nd1, ndsav1, nup
      integer, parameter :: kprime(8) = (/ 2, 3, 5, 7, 11, 13, 17, 19 /)
      type(multi), save :: mjsums(ljsums)
      logical, external :: fmcomp

      k_return_code = 0
      call fmi2m(0, mxy(32))
      ndsav1 = ndig

!             If b is small, use more guard digits.

      call fmdpm(1.0d-10, mxy(12))
      if (fmcomp(mxy(3), '<=', mxy(12))) then
          iextra = ngrd52
          call fmequ_r1(mxy(1), ndig, ndig+iextra)
          call fmequ_r1(mxy(2), ndig, ndig+iextra)
          call fmequ_r1(mxy(3), ndig, ndig+iextra)
          ndig = ndig + iextra
      endif

      nterms = int(intmax/10)
      nmethd = 0

!             Check for special cases.

      if (mxy(1)%mp(3) == 0) then
          call fmi2m(0, mxy(21))
          k_return_code = 1
          return
      endif
      call fmi2m(1, mxy(28))
      if (fmcomp(mxy(28), '==', mxy(1))) then
          iextra = ngrd52
          call fmequ_r1(mxy(1), ndig, ndig+iextra)
          call fmequ_r1(mxy(2), ndig, ndig+iextra)
          call fmequ_r1(mxy(3), ndig, ndig+iextra)
          ndig = ndig + iextra
          call fmbeta(mxy(2), mxy(3), mxy(31))
          call fmeq(mxy(31), mxy(21))
          k_return_code = 1
          return
      else if (mxy(1)%mp(1) < 0 .or. fmcomp(mxy(1), '>', mxy(28))) then
          call fmunknown(mxy(21))
          kflag = -4
          k_return_code = 2
          return
      endif
      if (mxy(2)%mp(1) < 0 .or. mxy(2)%mp(3) == 0) then
          call fmunknown(mxy(21))
          kflag = -4
          k_return_code = 2
          return
      endif
      if (mxy(3)%mp(1) < 0) then
          call fmunknown(mxy(21))
          kflag = -4
          k_return_code = 2
          return
      endif
      jr = numtry
      if (mxy(2)%mp(2) < -ndig .and. mxy(3)%mp(2) < -ndig) then
          call fmsub(mxy(28), mxy(1), mxy(12))
          call fmln(mxy(12), mxy(21))
          call fmdiv(mxy(28), mxy(2), mxy(12))
          call fmsub(mxy(12), mxy(21), mxy(13))
          call fmpwr(mxy(1), mxy(2), mxy(12))
          call fmmpy(mxy(13), mxy(12), mxy(21))
          k_return_code = 1
          return
      endif
      call fmi2m(1, mxy(12))
      call fmsub(mxy(12), mxy(3), mxy(7))
      call fmmpy(mxy(1), mxy(7), mxy(12))
      jr = kround
      kround = 1
      call fmadd(mxy(12), mxy(28), mxy(7))
      kround = jr
      if (fmcomp(mxy(7), '==', mxy(28))) then
          call fmln(mxy(1), mxy(12))
          call fmmpy(mxy(2), mxy(12), mxy(21))
          call fmln(mxy(2), mxy(12))
          call fmsub_r2(mxy(21), mxy(12))
          call fmexp(mxy(12), mxy(21))
          k_return_code = 2
          return
      endif

!             When a or b is large, check for an underflowed result.

      call fmdpm(1.0d+7, mxy(12))
      if (fmcomp(mxy(2), '>', mxy(12)) .or. fmcomp(mxy(3), '>', mxy(12))) then

!             If b is much larger than a, approximate beta(a, b) and use that as an upper bound.

          if (mxy(3)%mp(2) >= mxy(2)%mp(2)+ndig) then
              call fmadd(mxy(3), mxy(2), mxy(12))
              call fmln(mxy(12), mxy(23))
              call fmmpy_r2(mxy(2), mxy(23))
              call fmeq(mxy(2), mxy(27))
              call fmlngm(mxy(27), mxy(24))
              call fmsub(mxy(24), mxy(23), mxy(12))
              call fmexp(mxy(12), mxy(21))
              if (mxy(21)%mp(2) <= -mxsave-1) then
                  k_return_code = 2
                  return
              endif
          endif

!             If a > 2 > b, use the bound
!                c = min( x , (a-2)/(a+b-2) )
!                beta(x, a, b) < (a-1)*x/b * c**(a-2) * (1-c)**b
!
!             An alternate bound is also tried:
!                c = min( x , (a-1)/(a+b-2) )
!                beta(x, a, b) < c**a * (1-c)**(1-b)

          call fmi2m(2, mxy(12))
          if (fmcomp(mxy(2), '>', mxy(12)) .and. fmcomp(mxy(3), '<', mxy(12))) then
              call fmi2m(2, mxy(6))
              call fmsub(mxy(2), mxy(6), mxy(12))
              call fmadd(mxy(2), mxy(3), mxy(7))
              call fmsub_r1(mxy(7), mxy(6))
              call fmdiv_r1(mxy(12), mxy(7))
              call fmmin(mxy(1), mxy(12), mxy(23))
              call fmi2m(1, mxy(12))
              call fmsub_r2(mxy(2), mxy(12))
              call fmln(mxy(12), mxy(27))
              call fmln(mxy(1), mxy(12))
              call fmadd_r1(mxy(27), mxy(12))
              call fmln(mxy(3), mxy(12))
              call fmsub_r1(mxy(27), mxy(12))
              call fmi2m(2, mxy(7))
              call fmsub(mxy(2), mxy(7), mxy(21))
              call fmln(mxy(23), mxy(12))
              call fmmpy_r2(mxy(21), mxy(12))
              call fmadd_r1(mxy(27), mxy(12))
              call fmi2m(1, mxy(7))
              call fmsub(mxy(7), mxy(23), mxy(12))
              call fmln(mxy(12), mxy(21))
              call fmmpy(mxy(3), mxy(21), mxy(12))
              call fmadd_r1(mxy(27), mxy(12))
              call fmexp(mxy(27), mxy(21))
              if (mxy(21)%mp(2) <= -mxsave-1) then
                  k_return_code = 2
                  return
              endif
              call fmi2m(1, mxy(7))
              call fmsub(mxy(2), mxy(7), mxy(12))
              call fmadd(mxy(2), mxy(3), mxy(7))
              call fmi2m(2, mxy(6))
              call fmsub_r1(mxy(7), mxy(6))
              call fmdiv_r1(mxy(12), mxy(7))
              call fmmin(mxy(1), mxy(12), mxy(23))
              call fmi2m(1, mxy(7))
              call fmsub(mxy(7), mxy(23), mxy(12))
              call fmln(mxy(12), mxy(27))
              call fmsub(mxy(3), mxy(7), mxy(6))
              call fmmpy_r2(mxy(6), mxy(27))
              call fmln(mxy(1), mxy(12))
              call fmmpy_r2(mxy(2), mxy(12))
              call fmadd_r2(mxy(12), mxy(27))
              call fmexp(mxy(27), mxy(21))
              if (mxy(21)%mp(2) <= -mxsave-1) then
                  k_return_code = 2
                  return
              endif
          endif

!             If a > 2 and b > 2, use the bound
!                c = min( x , (a-1)/(a+b-2) )
!                beta(x, a, b) < x * c**(a-1) * (1-c)**(b-1)

          call fmi2m(2, mxy(12))
          if (fmcomp(mxy(2), '>', mxy(12)) .and. fmcomp(mxy(3), '>', mxy(12))) then
              call fmi2m(1, mxy(7))
              call fmsub(mxy(2), mxy(7), mxy(12))
              call fmadd(mxy(2), mxy(3), mxy(7))
              call fmi2m(2, mxy(6))
              call fmsub_r1(mxy(7), mxy(6))
              call fmdiv_r1(mxy(12), mxy(7))
              call fmmin(mxy(1), mxy(12), mxy(23))
              call fmi2m(1, mxy(7))
              call fmsub(mxy(7), mxy(23), mxy(12))
              call fmln(mxy(12), mxy(27))
              call fmsub(mxy(3), mxy(7), mxy(6))
              call fmmpy_r2(mxy(6), mxy(27))
              call fmln(mxy(23), mxy(12))
              call fmsub(mxy(2), mxy(7), mxy(6))
              call fmmpy_r2(mxy(6), mxy(12))
              call fmadd_r2(mxy(12), mxy(27))
              call fmln(mxy(1), mxy(12))
              call fmadd_r2(mxy(12), mxy(27))
              call fmexp(mxy(27), mxy(21))
              if (mxy(21)%mp(2) <= -mxsave-1) then
                  k_return_code = 2
                  return
              endif
          endif
      endif

!             Check for cases where x is large enough so that at this precision, b(x,a,b) = b(a,b).
!             These are often unstable, so it is better to use Beta.

      call fmi2m(1, mxy(12))
      call fmi2m(2, mxy(6))
      call fmadd(mxy(2), mxy(3), mxy(7))
      if (fmcomp(mxy(2), '>', mxy(12)) .and. fmcomp(mxy(7), '>', mxy(6))) then
              call fmi2m(1, mxy(7))
              call fmsub(mxy(2), mxy(7), mxy(12))
              call fmadd(mxy(2), mxy(3), mxy(7))
              call fmi2m(2, mxy(6))
              call fmsub_r1(mxy(7), mxy(6))
              call fmdiv(mxy(12), mxy(7), mxy(31))
          call fmi2m(1, mxy(12))
          call fmadd(mxy(2), mxy(3), mxy(7))
          call fmaddi(mxy(7), -3)
          if (fmcomp(mxy(31), '<', mxy(12)) .and. fmcomp(mxy(1), '>', mxy(31)) .and.  &
              mxy(7)%mp(3) /= 0) then
              call fmi2m(1, mxy(7))
              call fmsub(mxy(2), mxy(7), mxy(6))
              call fmsub(mxy(3), mxy(7), mxy(12))
              call fmmpy_r2(mxy(6), mxy(12))
              call fmadd(mxy(2), mxy(3), mxy(6))
              call fmi2m(3, mxy(7))
              call fmsub_r2(mxy(6), mxy(7))
              call fmdiv(mxy(12), mxy(7), mxy(30))
              if (mxy(30)%mp(1) >= 0) then
                  call fmi2m(1, mxy(7))
                  call fmsub_r2(mxy(2), mxy(7))
                  call fmsqrt(mxy(30), mxy(12))
                  call fmadd(mxy(7), mxy(12), mxy(30))
                  call fmadd(mxy(2), mxy(3), mxy(7))
                  call fmi2m(2, mxy(6))
                  call fmsub_r1(mxy(7), mxy(6))
                  call fmdiv_r1(mxy(30), mxy(7))
              else
                  call fmdpm(dble(1.1), mxy(30))
              endif
              call fmi2m(1, mxy(12))
              if (fmcomp(mxy(30), '>', mxy(31)) .and. fmcomp(mxy(30), '<', mxy(12)) .and.  &
                  fmcomp(mxy(1), '>=', mxy(30))) then

!                 Approximate b(a, b).

                  jr = kround
                  kround = 1
                  call fmadd(mxy(2), mxy(3), mxy(12))
                  kround = jr
                  if (fmcomp(mxy(12), '==', mxy(2))) then
                      call fmln(mxy(3), mxy(12))
                      call fmdpm(0.5d0, mxy(7))
                      call fmsub_r2(mxy(3), mxy(7))
                      call fmmpy(mxy(7), mxy(12), mxy(29))
                      call fmsub_r1(mxy(29), mxy(3))
                      call fmdpm(dlogtp/2.0d0, mxy(12))
                      call fmsub_r1(mxy(29), mxy(12))
                      call fmln(mxy(2), mxy(12))
                      call fmmpy_r2(mxy(3), mxy(12))
                      call fmsub_r1(mxy(29), mxy(12))
                  else if (fmcomp(mxy(12), '==', mxy(3))) then
                      call fmln(mxy(2), mxy(12))
                      call fmdp2m(0.5d0, mxy(7))
                      call fmsub_r2(mxy(2), mxy(7))
                      call fmmpy(mxy(7), mxy(12), mxy(29))
                      call fmsub_r1(mxy(29), mxy(2))
                      call fmdpm(dlogtp/2.0d0, mxy(12))
                      call fmsub_r1(mxy(29), mxy(12))
                      call fmln(mxy(3), mxy(12))
                      call fmmpy_r2(mxy(2), mxy(12))
                      call fmsub_r1(mxy(29), mxy(12))
                  else
                      call fmln(mxy(2), mxy(12))
                      call fmdp2m(0.5d0, mxy(7))
                      call fmsub_r2(mxy(2), mxy(7))
                      call fmmpy(mxy(7), mxy(12), mxy(29))
                      call fmln(mxy(3), mxy(12))
                      call fmdp2m(0.5d0, mxy(7))
                      call fmsub_r2(mxy(3), mxy(7))
                      call fmmpy_r2(mxy(7), mxy(12))
                      call fmadd_r1(mxy(29), mxy(12))
                      call fmadd(mxy(2), mxy(3), mxy(12))
                      call fmln(mxy(12), mxy(7))
                      call fmdp2m(0.5d0, mxy(6))
                      call fmsub_r2(mxy(12), mxy(6))
                      call fmmpy(mxy(6), mxy(7), mxy(12))
                      call fmsub_r1(mxy(29), mxy(12))
                      call fmdpm(dlogtp/2.0d0, mxy(12))
                      call fmsub_r1(mxy(29), mxy(12))
                  endif
                  call fmexp(mxy(29), mxy(9))
                  call fmeq(mxy(9), mxy(29))

!                 Bound the area from x to 1.

                  call fmi2m(1, mxy(12))
                  jr = kround
                  kround = 1
                  call fmsub(mxy(12), mxy(1), mxy(7))
                  kround = jr
                  if (fmcomp(mxy(7), '==', mxy(12))) then
                      call fmln(mxy(1), mxy(12))
                      call fmi2m(1, mxy(6))
                      call fmsub(mxy(2), mxy(6), mxy(7))
                      call fmmpy(mxy(7), mxy(12), mxy(28))
                      call fmsub(mxy(3), mxy(6), mxy(7))
                      call fmmpy(mxy(1), mxy(7), mxy(12))
                      call fmsub_r1(mxy(28), mxy(12))
                      call fmsub(mxy(6), mxy(1), mxy(12))
                      call fmdivi_r1(mxy(12), 2)
                      call fmln(mxy(12), mxy(13))
                      call fmsub_r1(mxy(28), mxy(13))
                  else
                      call fmln(mxy(1), mxy(12))
                      call fmi2m(1, mxy(6))
                      call fmsub(mxy(2), mxy(6), mxy(7))
                      call fmmpy(mxy(7), mxy(12), mxy(28))
                      call fmsub(mxy(3), mxy(6), mxy(7))
                      call fmsub(mxy(6), mxy(1), mxy(12))
                      call fmln(mxy(12), mxy(13))
                      call fmmpy_r2(mxy(7), mxy(13))
                      call fmadd_r1(mxy(28), mxy(13))
                      call fmdivi_r1(mxy(12), 2)
                      call fmln(mxy(12), mxy(13))
                      call fmadd_r1(mxy(28), mxy(13))
                  endif
                  call fmexp(mxy(28), mxy(9))
                  call fmeq(mxy(9), mxy(28))
                  jr = kround
                  kround = 1
                  call fmsub(mxy(29), mxy(28), mxy(12))
                  kround = jr
                  if (fmcomp(mxy(12), '==', mxy(29))) then
                      call fmeq(mxy(28), mxy(33))
                      call fmbeta(mxy(2), mxy(3), mxy(31))
                      jr = kround
                      kround = 1
                      call fmsub(mxy(31), mxy(33), mxy(12))
                      kround = jr
                      if (fmcomp(mxy(12), '==', mxy(31))) then
                          call fmeq(mxy(31), mxy(21))
                          k_return_code = 1
                          return
                      endif
                  endif
              endif
          endif
      else if (mxy(2)%mp(2) < 1 .and. fmcomp(mxy(3), '>', mxy(12))) then

!                 Approximate b(a, b).

          jr = kround
          kround = 1
          call fmadd(mxy(2), mxy(3), mxy(12))
          kround = jr
          if (fmcomp(mxy(12), '==', mxy(2))) then
              call fmln(mxy(3), mxy(12))
              call fmdp2m(0.5d0, mxy(7))
              call fmsub_r2(mxy(3), mxy(7))
              call fmmpy(mxy(7), mxy(12), mxy(29))
              call fmsub_r1(mxy(29), mxy(3))
              call fmdpm(dlogtp/2.0d0, mxy(12))
              call fmsub_r1(mxy(29), mxy(12))
              call fmln(mxy(2), mxy(12))
              call fmmpy_r2(mxy(3), mxy(12))
              call fmsub_r1(mxy(29), mxy(12))
          else if (fmcomp(mxy(12), '==', mxy(3))) then
              call fmln(mxy(2), mxy(12))
              call fmdp2m(0.5d0, mxy(7))
              call fmsub_r2(mxy(2), mxy(7))
              call fmmpy(mxy(7), mxy(12), mxy(29))
              call fmsub_r1(mxy(29), mxy(2))
              call fmdpm(dlogtp/2.0d0, mxy(12))
              call fmsub_r1(mxy(29), mxy(12))
              call fmln(mxy(3), mxy(12))
              call fmmpy_r2(mxy(2), mxy(12))
              call fmsub_r1(mxy(29), mxy(12))
          else
              call fmln(mxy(2), mxy(12))
              call fmdp2m(0.5d0, mxy(7))
              call fmsub_r2(mxy(2), mxy(7))
              call fmmpy(mxy(7), mxy(12), mxy(29))
              call fmln(mxy(3), mxy(12))
              call fmdp2m(0.5d0, mxy(7))
              call fmsub_r2(mxy(3), mxy(7))
              call fmmpy_r2(mxy(7), mxy(12))
              call fmadd_r1(mxy(29), mxy(12))
              call fmadd(mxy(2), mxy(3), mxy(12))
              call fmln(mxy(12), mxy(7))
              call fmdp2m(0.5d0, mxy(6))
              call fmsub_r2(mxy(12), mxy(6))
              call fmmpy(mxy(6), mxy(7), mxy(12))
              call fmsub_r1(mxy(29), mxy(12))
              call fmdpm(dlogtp/2.0d0, mxy(12))
              call fmsub_r1(mxy(29), mxy(12))
          endif
          call fmexp(mxy(29), mxy(9))
          call fmeq(mxy(9), mxy(29))

!                 Bound the area from x to 1.

          call fmi2m(1, mxy(12))
          jr = kround
          kround = 1
          call fmsub(mxy(12), mxy(1), mxy(7))
          kround = jr
          if (fmcomp(mxy(7), '==', mxy(12))) then
              call fmln(mxy(1), mxy(12))
              call fmi2m(1, mxy(6))
              call fmsub(mxy(2), mxy(6), mxy(7))
              call fmmpy(mxy(7), mxy(12), mxy(28))
              call fmsub(mxy(3), mxy(6), mxy(7))
              call fmmpy(mxy(1), mxy(7), mxy(12))
              call fmsub_r1(mxy(28), mxy(12))
              call fmsub(mxy(6), mxy(1), mxy(12))
              call fmdivi_r1(mxy(12), 2)
              call fmln(mxy(12), mxy(13))
              call fmsub_r1(mxy(28), mxy(13))
              call fmexp(mxy(28), mxy(9))
              call fmeq(mxy(9), mxy(28))
          else
              call fmln(mxy(1), mxy(12))
              call fmi2m(1, mxy(6))
              call fmsub(mxy(2), mxy(6), mxy(7))
              call fmmpy(mxy(7), mxy(12), mxy(28))
              call fmsub(mxy(3), mxy(6), mxy(7))
              call fmsub(mxy(6), mxy(1), mxy(12))
              call fmln(mxy(12), mxy(13))
              call fmmpy_r2(mxy(7), mxy(13))
              call fmadd_r1(mxy(28), mxy(13))
              call fmdivi_r1(mxy(12), 2)
              call fmln(mxy(12), mxy(13))
              call fmadd_r1(mxy(28), mxy(13))
              call fmexp(mxy(28), mxy(9))
              call fmeq(mxy(9), mxy(28))
          endif
          jr = kround
          kround = 1
          call fmsub(mxy(29), mxy(28), mxy(12))
          kround = jr
          if (fmcomp(mxy(12), '==', mxy(29))) then
              call fmbeta(mxy(2), mxy(3), mxy(31))
              call fmeq(mxy(31), mxy(21))
              k_return_code = 1
              return
          endif
      endif

!             If b is small enough, use one of two series or an asymptotic series,
!             depending on the size of x and a.

      call fmi2m(1, mxy(6))
      jr = kround
      kround = 1
      call fmadd(mxy(6), mxy(3), mxy(7))
      call fmadd(mxy(2), mxy(3), mxy(12))
      kround = jr
      if ((fmcomp(mxy(7), '==', mxy(6)) .and. fmcomp(mxy(12), '==', mxy(2))) ) then
          call fmdp2m(0.5d0, mxy(12))
          if (fmcomp(mxy(1), '<=', mxy(12))) then
              call fmi2m(0, mxy(22))
              call fmeq(mxy(1), mxy(23))
              call fmi2m(1, mxy(7))
              call fmadd(mxy(2), mxy(7), mxy(12))
              call fmdiv(mxy(23), mxy(12), mxy(24))
              call fmeq(mxy(2), mxy(14))
              call fmaddi(mxy(14), 1)
              ndsav1 = ndig
              do j = 2, nterms
                 call fmadd_r1(mxy(22), mxy(24))
                 if (kflag /= 0 .and. j >= 3) exit
                 nd1 = max(ngrd22, ndsav1-int(mxy(22)%mp(2)-mxy(24)%mp(2))+1)
                 nd = min(ndsav1, nd1)
                 ndig = nd
                 if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                 call fmmpy_r1(mxy(23), mxy(1))
                 call fmaddi(mxy(14), 1)
                 call fmdiv(mxy(23), mxy(14), mxy(24))
                 ndig = ndsav1
                 if (j == nterms) then
                     call fmunknown(mxy(21))
                     k_return_code = 2
                     return
                 endif
              enddo
              call fmpwr(mxy(1), mxy(2), mxy(12))
              call fmi2m(1, mxy(6))
              call fmdiv(mxy(6), mxy(2), mxy(7))
              call fmadd(mxy(7), mxy(22), mxy(6))
              call fmmpy(mxy(12), mxy(6), mxy(22))
              call fmeq(mxy(22), mxy(21))
              k_return_code = 1
              return
          endif
          call fmdp2m(0.5d0, mxy(12))
          call fmi2m(20, mxy(7))
          if ((fmcomp(mxy(1), '>', mxy(12)) .and. fmcomp(mxy(2), '<', mxy(7)))) then
              call fmi2m(0, mxy(22))
              call fmi2m(1, mxy(12))
              call fmsub(mxy(12), mxy(1), mxy(25))
              call fmi2m(1, mxy(7))
              call fmadd(mxy(3), mxy(7), mxy(12))
              call fmpwr(mxy(25), mxy(12), mxy(23))
              call fmi2m(1, mxy(12))
              call fmsub(mxy(12), mxy(2), mxy(7))
              call fmmpy_r2(mxy(7), mxy(23))

              call fmeq(mxy(23), mxy(24))
              ndsav1 = ndig
              do j = 2, nterms
                 call fmadd_r1(mxy(22), mxy(24))
                 if (kflag /= 0 .and. j >= 3) exit
                 nd1 = max(ngrd22, ndsav1-int(mxy(22)%mp(2)-mxy(24)%mp(2))+1)
                 nd = min(ndsav1, nd1)
                 ndig = nd
                 if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                 call fmi2m(j, mxy(7))
                 call fmsub(mxy(7), mxy(2), mxy(12))
                 call fmmpy(mxy(23), mxy(12), mxy(7))
                 call fmmpy(mxy(7), mxy(25), mxy(12))
                 call fmdivi(mxy(12), j, mxy(23))
                 call fmdivi(mxy(23), j, mxy(24))
                 ndig = ndsav1
                 if (j == nterms) then
                     call fmunknown(mxy(21))
                     k_return_code = 2
                     return
                 endif
              enddo
              call fmln(mxy(25), mxy(12))
              call fmi2m(1, mxy(7))
              call fmdiv(mxy(7), mxy(2), mxy(6))
              call fmsub(mxy(6), mxy(12), mxy(7))
              call fmsub(mxy(7), mxy(22), mxy(23))
              call fmeulr(mxy(24))
              call fmi2m(1, mxy(12))
              call fmadd(mxy(2), mxy(12), mxy(25))
              call fmpsi(mxy(25), mxy(11))
              call fmeq(mxy(11), mxy(25))
              call fmsub(mxy(23), mxy(24), mxy(12))
              call fmsub(mxy(12), mxy(25), mxy(21))
              k_return_code = 1
              return
          endif

          call fmdp2m(0.5d0, mxy(12))
          call fmi2m(20, mxy(7))
          if ((fmcomp(mxy(1), '>', mxy(12)) .and. fmcomp(mxy(2), '>=', mxy(7)))) then
              call fmdp2m(0.7*dble(ndig)*alogmt, mxy(28))
              if (fmcomp(mxy(2), '>=', mxy(28))) then
                  nup = 0
                  call fmeq(mxy(2), mxy(32))
                  call fmi2m(0, mxy(33))
              else
                  call fmsub(mxy(28), mxy(2), mxy(12))
                  call fmaddi(mxy(12), 1)
                  call fmm2i(mxy(12), nup)
                  call fmi2m(nup, mxy(12))
                  call fmadd(mxy(2), mxy(12), mxy(32))
                  call fmi2m(1, mxy(33))
                  call fmeq(mxy(2), mxy(23))
                  ndsav1 = ndig
                  do j = 1, nup-1
                     call fmmpy_r1(mxy(23), mxy(1))
                     call fmi2m(j, mxy(12))
                     call fmadd(mxy(2), mxy(12), mxy(7))
                     call fmdiv(mxy(23), mxy(7), mxy(24))
                     ndig = ndsav1
                     call fmadd_r1(mxy(33), mxy(24))
                     nd1 = max(ngrd22, ndsav1-int(mxy(33)%mp(2)-mxy(24)%mp(2))+1)
                     nd = min(ndsav1, nd1)
                     ndig = nd
                  enddo
                  ndig = ndsav1
                  call fmpwr(mxy(1), mxy(2), mxy(12))
                  call fmmpy(mxy(33), mxy(12), mxy(13))
                  call fmi2m(1, mxy(7))
                  call fmsub(mxy(7), mxy(1), mxy(12))
                  call fmpwr(mxy(12), mxy(3), mxy(33))
                  call fmmpy_r2(mxy(13), mxy(33))
                  call fmdiv_r1(mxy(33), mxy(2))
              endif

              call fmi2m(1, mxy(7))
              call fmdivi(mxy(7), 2, mxy(12))
              call fmsub(mxy(32), mxy(12), mxy(29))
              call fmln(mxy(1), mxy(12))
              call fmmpy(mxy(29), mxy(12), mxy(30))
              call fmnegate(mxy(30))
              call fmigm2(mxy(3), mxy(30), mxy(31))
              call fmpwr(mxy(30), mxy(3), mxy(12))
              call fmeq(mxy(30), mxy(13))
              call fmnegate(mxy(13))
              call fmexp(mxy(13), mxy(7))
              call fmmpy(mxy(7), mxy(12), mxy(13))
              call fmdiv_r1(mxy(31), mxy(13))
              call fmeq(mxy(31), mxy(22))
              call fmsqr(mxy(29), mxy(12))
              call fmmpyi(mxy(12), 4, mxy(23))
              call fmi2m(1, mxy(24))
              call fmi2m(1, mxy(25))
              call fmi2m(1, mxy(26))
              call fmln(mxy(1), mxy(12))
              call fmdivi(mxy(12), 2, mxy(7))
              call fmsqr(mxy(7), mxy(28))
              ndsav1 = ndig
              j4 = 0
              krsave = kround
              kround = 1
              do j = 1, nterms
                 jswitch = max(2, int(ndig*dlogmb/(2.0d0*log(23.0)) + 2))
                 if (j < jswitch) then
                     j4 = 0
                     call fmmpyi_r1(mxy(25), 4)
                     call fmmpyi(mxy(26), 2*j-1, mxy(12))
                     call fmmpyi(mxy(12), 2*j, mxy(26))
                     call fmi2m(2, mxy(7))
                     call fmsub(mxy(7), mxy(25), mxy(12))
                     call fmdiv(mxy(12), mxy(26), mxy(27))
                     call fmbern(2*j, mxy(27), mxy(8))
                     call fmeq(mxy(8), mxy(27))
                 else
                     if (j4 == 0) then
                         j4 = 1
                         n = 2*j
                         do k = 1, 8
                            call fmi2m(kprime(k), mjsums(k))
                            call fmipwr(mjsums(k), n, mxy(12))
                            call fmeq(mxy(12), mjsums(k))
                         enddo
                     else
                         do k = 1, 8
                            call fmmpyi_r1(mjsums(k), kprime(k)**2)
                         enddo
                     endif
                     call fmpi(mxy(18))
                     call fmi2m(1, mxy(14))
                     call fmi2m(1, mxy(15))
                     do k = 1, 8
                        call fmeq(mjsums(k), mxy(17))
                        call fmi2m(kprime(k)**2-1, mxy(12))
                        jr = kround
                        kround = 1
                        call fmsub(mxy(17), mxy(14), mxy(7))
                        call fmdiv_r2(mxy(12), mxy(7))
                        call fmsub(mxy(14), mxy(7), mxy(16))
                        kround = jr
                        call fmi2m(1, mxy(12))
                        if (fmcomp(mxy(16), '==', mxy(12))) exit
                        call fmmpy_r1(mxy(15), mxy(16))
                     enddo
                     call fmeq(mjsums(1), mxy(17))
                     call fmi2m(-1, mxy(7))
                     call fmsqr(mxy(18), mxy(13))
                     call fmdiv(mxy(7), mxy(13), mxy(12))
                     call fmi2m(2, mxy(7))
                     call fmsub(mxy(7), mxy(17), mxy(6))
                     call fmi2m(8, mxy(7))
                     call fmsub_r1(mxy(7), mxy(17))
                     call fmdiv(mxy(6), mxy(7), mxy(13))
                     call fmmpy(mxy(12), mxy(13), mxy(7))
                     call fmmpy(mxy(7), mxy(15), mxy(16))
                     call fmmpy_r2(mxy(16), mxy(27))
                 endif
                 call fmi2m(2*j-2, mxy(7))
                 call fmadd(mxy(3), mxy(7), mxy(12))
                 call fmmpy(mxy(12), mxy(31), mxy(7))
                 call fmmpyi(mxy(7), 2*j-1, mxy(31))
                 call fmi2m(2*j-1, mxy(7))
                 call fmadd(mxy(30), mxy(7), mxy(12))
                 call fmmpy(mxy(24), mxy(12), mxy(7))
                 call fmadd_r1(mxy(31), mxy(7))
                 call fmdiv_r1(mxy(31), mxy(23))
                 call fmmpy_r1(mxy(24), mxy(28))
                 call fmmpy(mxy(27), mxy(31), mxy(19))
                 ndig = ndsav1
                 call fmadd_r1(mxy(22), mxy(19))
                 if (kflag /= 0 .and. j >= 3) exit
                 nd1 = max(ngrd22, ndsav1-int(mxy(22)%mp(2)-mxy(19)%mp(2))+1)
                 nd = min(ndsav1, nd1)
                 ndig = nd
                 if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                 if (j == nterms) then
                     call fmunknown(mxy(21))
                     k_return_code = 2
                     return
                 endif
              enddo
              kround = krsave
              ndig = ndsav1
              call fmpwr(mxy(1), mxy(29), mxy(12))
              call fmln(mxy(1), mxy(13))
              call fmnegate(mxy(13))
              call fmpwr(mxy(13), mxy(3), mxy(21))
              call fmmpy(mxy(22), mxy(12), mxy(7))
              call fmmpy_r2(mxy(7), mxy(21))
              call fmadd_r2(mxy(33), mxy(21))
              k_return_code = 1
              return
          endif
      endif

!             If a or b is large in magnitude, use more guard digits.

      nd1 = max(int(mxy(2)%mp(2)), int(mxy(3)%mp(2)))
      nd1 = max(nd1, 0)
      iextra = min(nd1 , int(1.0+alogmx/alogmb))
      if (abs(mxy(2)%mp(2)) >= mexpov .or. abs(mxy(3)%mp(2)) >= mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(1), ndig, ndig+iextra)
          call fmequ_r1(mxy(2), ndig, ndig+iextra)
          call fmequ_r1(mxy(3), ndig, ndig+iextra)
      endif
      ndig = ndig + iextra

      return
      end subroutine fmibta2

      subroutine fmibta3(mx, ma, mb, mc, mxy, k_return_code)

!  Rounding for special cases in non-standard rounding modes.

      use fmvals
      implicit none

      type(multi) :: mx, ma, mb, mc, mxy(40)
      integer :: k_return_code
      intent (in) :: mx, ma, mb
      intent (inout) :: mc, mxy, k_return_code

      integer :: j, j1, j2, k, k1, k2, krsave, ndsave

      j = ntrace
      ntrace = 0
      k = kwarn
      kwarn = 0
      ndsave = ndig
      krsave = kround
      kround = 1
      call fmi2m(1, mxy(1))
      call fmsub(mxy(1), mx, mxy(2))
      if (mx%mp(1) < 0 .or. mxy(2)%mp(1) < 0 .or. ma%mp(1) < 0 .or. mb%mp(1) < 0) then
          kflag = 0
          ntrace = j
          kwarn = k
          ndig = ndsave
          kround = krsave
          return
      endif
      if (krsave /= 1 .and. (mxy(2)%mp(3) == 0 .or. mx%mp(2) < -ndig .or.  &
                             ma%mp(2) < -ndig .or. mb%mp(2) < -ndig)) then
          if (mxy(2)%mp(3) == 0) then
              kround = krsave
              call fmbeta(ma, mb, mc)
              k_return_code = 1
          else if (mx%mp(3) == 0) then
              kround = krsave
              call fmi2m(0, mc)
              k_return_code = 1
          else
              ndig = ndig + ngrd52
              call fmequ(mx, mxy(1), ndsave, ndig)
              call fmequ(ma, mxy(2), ndsave, ndig)
              call fmequ(mb, mxy(3), ndsave, ndig)
              call fmi2m(1, mxy(4))
              call fmsub(mxy(4), mxy(3), mxy(5))
              call fmmpy(mxy(1), mxy(5), mxy(6))
              call fmadd(mxy(2), mxy(4), mxy(7))
              call fmdiv(mxy(6), mxy(7), mxy(8))
              call fmdiv(mxy(4), mxy(2), mxy(9))
              if (mxy(9)%mp(2) - mxy(8)%mp(2) > ndig) then
                  call fmpwr(mxy(1), mxy(2), mxy(10))
                  if (mxy(10)%mp(2) > mexpun .and. mxy(10)%mp(2) < mexpov) then
                      call fmdiv(mxy(10), mxy(2), mxy(11))
                      call fmmpy(mxy(10), mxy(8), mxy(12))
                      if (ma%mp(2) < -ndsave) then
                          call fmln(mxy(1), mxy(13))
                          call fmadd_r1(mxy(12), mxy(13))
                          call fmequ(mxy(9), mxy(5), ndig, ndsave)
                          call fmequ(mxy(13), mxy(6), ndig, ndsave)
                          ndig = ndsave
                          kround = krsave
                          call fmadd(mxy(5), mxy(6), mc)
                          k_return_code = 1
                      else if (mxy(11)%mp(2) < mexpov) then
                          call fmequ(mxy(11), mxy(5), ndig, ndsave)
                          call fmequ(mxy(5), mxy(13), ndsave, ndig)
                          call fmsub(mxy(11), mxy(13), mxy(8))
                          if (mxy(8)%mp(3) == 0) then
                              call fmequ(mxy(12), mxy(6), ndig, ndsave)
                              ndig = ndsave
                              kround = krsave
                              call fmadd(mxy(5), mxy(6), mc)
                              if (mc%mp(2) == munkno) then
                                  j1 = mxy(5)%mp(2)
                                  k1 = mxy(6)%mp(2)
                                  j2 = j1
                                  if (j1 /= mexpun .and. j1 < 0) j2 = j1 + 2*ndig
                                  if (j1 /= mexpov .and. j1 > 0) j2 = j1 - 2*ndig
                                  k2 = k1
                                  if (k1 /= mexpun .and. k1 < 0) k2 = k1 + 2*ndig
                                  if (k1 /= mexpov .and. k1 > 0) k2 = k1 - 2*ndig
                                  mxy(5)%mp(2) = j2
                                  mxy(6)%mp(2) = k2
                                  call fmadd(mxy(5), mxy(6), mc)
                                  k2 = mc%mp(2) - (j2 - j1) - (k2 - k1)
                                  if (mc%mp(2) /= munkno) mc%mp(2) = k2
                              endif
                          else
                              kround = krsave
                              call fmequ(mxy(11), mc, ndig, ndsave)
                          endif
                          k_return_code = 1
                      endif
                  endif
              endif
              if (k_return_code /= 1) then
                  call fmi2m(1, mxy(4))
                  call fmsub(mxy(4), mxy(1), mxy(5))
                  call fmpwr(mxy(5), mxy(3), mxy(6))
                  call fmdiv(mxy(4), mxy(3), mxy(7))
                  call fmsub(mxy(4), mxy(2), mxy(8))
                  call fmmpy(mxy(1), mxy(8), mxy(9))
                  call fmadd(mxy(3), mxy(4), mxy(10))
                  call fmdiv(mxy(9), mxy(10), mxy(11))
                  if (mxy(6)%mp(2) <= mexpun) then
                      ndig = ndsave
                      kround = krsave
                      call fmbeta(ma, mb, mc)
                      k_return_code = 1
                  else
                      call fmadd(mxy(7), mxy(11), mxy(12))
                      call fmmpy(mxy(6), mxy(12), mxy(8))
                      ndig = ndsave
                      kround = krsave
                      call fmbeta(ma, mb, mc)
                      if (mc%mp(2) - mxy(8)%mp(2) > ndig) k_return_code = 1
                  endif
              endif
          endif
      endif

      kflag = 0
      ntrace = j
      kwarn = k
      ndig = ndsave
      kround = krsave

      return
      end subroutine fmibta3

      subroutine fmibta_m(mx, ma, mb, mxy, mresult, ndsave, mxsave, n_acc)

!  Main logic for computing ibta(mx,ma,mb).

      use fmvals
      implicit none

      type(multi) :: mx, ma, mb, mxy(40), mresult
      real (kind(1.0d0)) :: mxsave
      integer :: ndsave, n_acc
      intent (in) :: mx, ma, mb, ndsave, mxsave
      intent (inout) :: mxy, mresult, n_acc

      type(multi), save :: mretry, mxlocal
      double precision :: err
      integer :: j, kashift, kbigab, kbshift, kfsave, kl, klr, kr_retry, krt,  &
                 k_return_code, nmethd, nterms, numtry, nwds1

      kr_retry = 0
      krt = 0
      klr = 1
      k_return_code = 0
      kbigab = 0
      do while (klr == 1)
         klr = 0

         kbigab = 0
         if (krt == 0) then
             call fmequ(mx, mxy(1), ndsave, ndig)
             call fmequ(ma, mxy(2), ndsave, ndig)
             call fmequ(mb, mxy(3), ndsave, ndig)
             call fmibta_ma(mx, ma, mb, mxy, k_return_code, numtry, nwds1, kashift, kbshift, kbigab)
             if (k_return_code == 2) exit
         endif

!             Check some special cases.

         n_acc = nint(ndig*alogm2)
         call fmibta2(k_return_code, mxy, mxsave, nterms, numtry, nmethd)
         if (k_return_code == 2) exit

         if (k_return_code /= 1) then
             call fmibta_mb(mxy, nmethd)

             call fmequ(mx, mxlocal, ndsave, ndig)
             if (nmethd == 1) call fmibta_m1(mxy, k_return_code, n_acc)
             if (nmethd == 2) call fmibta_m2(mxy, k_return_code, n_acc)
             if (nmethd == 5) call fmibta_m5(mxy, mxlocal, nmethd, ndsave, k_return_code, n_acc)

             if (nmethd == 3 .or. nmethd == 4 .or. nmethd == 6) then
                 call fmibta_mc(mxlocal, mxy, numtry, nmethd, ndsave, k_return_code, n_acc,  &
                                nwds1, kashift, kbshift)
             endif
             if (k_return_code == 2) exit
         endif

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

         if (ncall >= 1) then
             kl = min(ndig-ndsave, int(3*dlogtn/dlogmb + 1.5))
             err = 0
             do j = kl, 1, -1
                err = (err + mxy(21)%mp(j+ndsave+2)) / mbase
             enddo
             if ( (kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
                  (kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) kr_retry = kr_retry + 1
         endif
         if (kr_retry == 1 .and. ndig < 2*ndsave+10) then
             kr_retry = 2
             klr = 1
             cycle
         endif

         call fmibta_md(mx, ma, mb, mxy, nterms, ndsave, k_return_code, n_acc,  &
                        kashift, kbshift, kfsave)
         if (k_return_code == 2) exit
         call fmibta_me(mx, ma, mb, mxy, nterms, ndsave, k_return_code, n_acc, kbshift)
         if (k_return_code == 2) exit
         call fmibta_mf(mx, ma, mb, mxy, krt, k_return_code, numtry, nmethd, ndsave, n_acc,  &
                        kashift, kbshift, kfsave, mretry)
         if (k_return_code == 2) exit
         if (krt == 1) klr = 1
      enddo

      call fmequ(mxy(21), mxy(20), ndig, ndsave)
      if (kbigab /= 0) then
          if ((mxy(20)%mp(2) >= -mxsave  .and. kbigab == -1) .or.  &
              (mxy(20)%mp(2) <= mxsave+1 .and. kbigab ==  1) .or. (kbigab == -9)) then
              call fmunknown(mxy(21))
              kflag = -4
          endif
      endif

      call fmeq(mxy(21), mresult)

      return
      end subroutine fmibta_m

      subroutine fmibta_m1(mxy, k_return_code, n_acc)
      use fmvals
      implicit none

      type(multi) :: mxy(40)
      integer :: k_return_code, n_acc
      intent (inout) :: mxy, k_return_code, n_acc

      integer :: int_temp1, int_temp2, int_temp3, int_temp4, j, jcheck, jextra,  &
                 k, kl, krsave, ndig2, ndsav1, nterms

!             Method 1.  Use the pochhammer(1-b,n)*x**n/((a+n)*n!) series.

!             mxy(21) is the sum.
!             mxy(17) is the current term.
!             mxy(18) is j-b.
!             mxy(19) is 1.
!             mxy(20) is a+j.

      n_acc = nint(ndig*alogm2)
      nterms = int(intmax/10)
      jextra = int(0.06*ndig)
      if (ndig+jextra > ndig) then
          call fmequ_r1(mxy(1), ndig, ndig+jextra)
          call fmequ_r1(mxy(2), ndig, ndig+jextra)
          call fmequ_r1(mxy(3), ndig, ndig+jextra)
      endif
      ndig = ndig + jextra
      call fmi2m(1, mxy(17))
      call fmdiv(mxy(17), mxy(2), mxy(38))
      call fmi2m(0, mxy(39))
      call fmeq(mxy(3), mxy(18))
      call fmnegate(mxy(18))
      call fmeq(mxy(2), mxy(20))
      call fmi2m(1, mxy(19))
      call fmi2m(0, mxy(16))
      call fmi2m(0, mxy(22))
      jcheck = 5
      ndsav1 = ndig

!             Method 1 summation loop.

      krsave = kround
      kround = 1
      do j = 1, nterms
         ndig = ndsav1
         call fmcsadd_r1(mxy(18), mxy(19))
         int_temp3 = ndsav1 - int(mxy(38)%mp(2) - mxy(17)%mp(2))
         int_temp4 = ndsav1 - int(mxy(39)%mp(2) - mxy(17)%mp(2))
         int_temp1 = max(int_temp3, int_temp4)
         int_temp2 = max(ngrd22, int_temp1)
         ndig2 = min(ndsav1, int_temp2)
         ndig = ndig2
         call fmcsmpy_r1(mxy(17), mxy(18))
         call fmcsmpy_r1(mxy(17), mxy(1))
         if (j > 1) call fmdivi_r1(mxy(17), j)
         ndig = ndsav1
         call fmcsadd_r1(mxy(20), mxy(19))
         ndig = ndig2
         call fmcsdiv(mxy(17), mxy(20), mxy(16))

         ndig = ndsav1
         if (int(mxy(16)%mp(1)) < 0) then
             call fmadd_r2(mxy(16), mxy(39))
         else
             call fmadd_r2(mxy(16), mxy(38))
         endif

         if (kflag < 0) exit
         if (mod(j, jcheck) == 0) then
             call fmadd(mxy(38), mxy(39), mxy(16))
             kl = 1
             do k = ndig+1, 1, -1
                if (mxy(16)%mp(k+1) /= mxy(22)%mp(k+1)) then
                    call fmeq(mxy(16), mxy(22))
                    kl = 0
                    exit
                endif
             enddo
             if (kl == 1) exit
         endif
         if (j == nterms) then
             call fmunknown(mxy(21))
             k_return_code = 2
             return
         endif
      enddo
      kround = krsave

      call fmpwr(mxy(1), mxy(2), mxy(12))
      call fmadd(mxy(38), mxy(39), mxy(7))
      call fmcancel(mxy(38), mxy(39), mxy(7), j)
      n_acc = n_acc - j
      call fmmpy(mxy(7), mxy(12), mxy(21))
      call fmmpy_r1(mxy(38), mxy(12))
      call fmmpy_r1(mxy(39), mxy(12))

      return
      end subroutine fmibta_m1

      subroutine fmibta_m2(mxy, k_return_code, n_acc)
      use fmvals
      implicit none

      type(multi) :: mxy(40)
      integer :: k_return_code, n_acc
      intent (inout) :: mxy, k_return_code, n_acc

      integer :: int_temp1, int_temp2, j, jextra, k, kflag1, krsave, ndsav1, nterms

!             Method 2.  Continued fraction expansion for b(x,a,b).

!             mxy(22) is the current approximation.
!             mxy(21) is the term in the sum, s(k).
!             mxy(19), mxy(20) are the latest denominators, q(k-1) and q(k).

      n_acc = nint(ndig*alogm2)
      nterms = int(intmax/10)
      jextra = max(1, int(5.76/alogmb + 1.0)) + ngrd52 + int(0.152*ndig)
      if (ndig+jextra > ndig) then
          call fmequ_r1(mxy(1), ndig, ndig+jextra)
          call fmequ_r1(mxy(2), ndig, ndig+jextra)
          call fmequ_r1(mxy(3), ndig, ndig+jextra)
      endif
      ndig = ndig + jextra
      ndsav1 = ndig
      call fmi2m(1, mxy(19))
      call fmi2m(1, mxy(20))
      call fmi2m(1, mxy(21))
      call fmeq(mxy(21), mxy(38))
      call fmi2m(0, mxy(39))
      call fmeq(mxy(2), mxy(24))
      call fmadd(mxy(2), mxy(3), mxy(25))
      call fmeq(mxy(2), mxy(26))
      call fmi2m(1, mxy(12))
      call fmadd(mxy(2), mxy(12), mxy(27))
      call fmeq(mxy(3), mxy(28))
      call fmsqr(mxy(2), mxy(29))
      call fmadd(mxy(29), mxy(26), mxy(30))
      call fmsub(mxy(29), mxy(26), mxy(31))
      call fmmpy(mxy(24), mxy(25), mxy(12))
      call fmmpy(mxy(12), mxy(1), mxy(7))
      call fmdiv(mxy(7), mxy(30), mxy(33))
      call fmnegate(mxy(33))
      call fmmpy(mxy(33), mxy(19), mxy(18))
      call fmadd(mxy(20), mxy(18), mxy(17))
      call fmmpy(mxy(18), mxy(21), mxy(12))
      call fmdiv(mxy(12), mxy(17), mxy(21))
      call fmnegate(mxy(21))
      if (mxy(21)%mp(1) > 0) then
          call fmadd(mxy(38), mxy(21), mxy(19))
          call fmeq(mxy(19), mxy(38))
      else
          call fmadd(mxy(39), mxy(21), mxy(19))
          call fmeq(mxy(19), mxy(39))
      endif
      call fmeq(mxy(20), mxy(19))
      call fmeq(mxy(17), mxy(20))

!             Method 2 continued fraction loop.

      krsave = kround
      kround = 1
      do j = 1, nterms
         call fmaddi(mxy(24), 1)
         call fmaddi(mxy(25), 1)
         call fmaddi(mxy(26), 2)
         call fmaddi(mxy(27), 2)
         call fmaddi(mxy(28), -1)
         call fmmpyi(mxy(26), 4, mxy(15))
         call fmaddi(mxy(15), -4)
         call fmcsadd_r1(mxy(29), mxy(15))
         call fmadd(mxy(29), mxy(26), mxy(30))
         call fmsub(mxy(29), mxy(26), mxy(31))

         call fmeq(mxy(28), mxy(15))
         call fmcsmpy_r1(mxy(15), mxy(1))
         call fmmpyi_r1(mxy(15), j)
         call fmcsdiv(mxy(15), mxy(31), mxy(33))

         call fmeq(mxy(33), mxy(18))
         call fmcsmpy_r1(mxy(18), mxy(19))
         call fmadd(mxy(20), mxy(18), mxy(17))
         call fmeq(mxy(18), mxy(15))
         call fmcsmpy_r1(mxy(15), mxy(21))
         call fmcsdiv(mxy(15), mxy(17), mxy(21))
         call fmnegate(mxy(21))

         ndig = ndsav1
         if (mxy(21)%mp(1) > 0) then
             call fmadd(mxy(38), mxy(21), mxy(19))
             int_temp1 = kflag
             call fmeq(mxy(19), mxy(38))
         else
             call fmadd(mxy(39), mxy(21), mxy(19))
             int_temp1 = kflag
             call fmeq(mxy(19), mxy(39))
         endif
         kflag1 = int_temp1

         call fmeq(mxy(20), mxy(19))
         call fmeq(mxy(17), mxy(20))
         call fmadd(mxy(38), mxy(39), mxy(15))
         int_temp1 = ndsav1 - int(mxy(15)%mp(2) - mxy(21)%mp(2))
         int_temp2 = max(ngrd22, int_temp1)
         ndig = min(ndsav1, int_temp2)
         call fmeq(mxy(24), mxy(15))
         call fmcsmpy_r1(mxy(15), mxy(25))
         call fmcsmpy_r1(mxy(15), mxy(1))
         call fmcsdiv(mxy(15), mxy(30), mxy(33))
         call fmnegate(mxy(33))

         call fmeq(mxy(33), mxy(18))
         call fmcsmpy_r1(mxy(18), mxy(19))
         call fmadd(mxy(20), mxy(18), mxy(17))
         call fmeq(mxy(18), mxy(15))
         call fmcsmpy_r1(mxy(15), mxy(21))
         call fmcsdiv(mxy(15), mxy(17), mxy(21))
         call fmnegate(mxy(21))

         ndig = ndsav1
         if (mxy(21)%mp(1) > 0) then
             call fmadd(mxy(38), mxy(21), mxy(19))
             int_temp1 = kflag
             call fmeq(mxy(19), mxy(38))
         else
             call fmadd(mxy(39), mxy(21), mxy(19))
             int_temp1 = kflag
             call fmeq(mxy(19), mxy(39))
         endif
         kflag = int_temp1

!             Check for convergence.

         if (kflag1 == 1 .and. kflag == 1) then
             exit
         endif
         call fmeq(mxy(20), mxy(19))
         call fmeq(mxy(17), mxy(20))
         call fmadd(mxy(38), mxy(39), mxy(15))
         int_temp1 = ndsav1 - int(mxy(15)%mp(2) - mxy(21)%mp(2))
         int_temp2 = max(ngrd22, int_temp1)
         ndig = min(ndsav1, int_temp2)
         if (j == nterms) then
             call fmunknown(mxy(21))
             k_return_code = 2
             return
         endif
      enddo
      call fmadd(mxy(38), mxy(39), mxy(15))
      call fmcancel(mxy(38), mxy(39), mxy(15), k)
      n_acc = n_acc - k
      call fmeq(mxy(15), mxy(22))
      kround = krsave

!             Multiply the sums by x**a * (1-x)**b / a

      call fmeq(mxy(38), mxy(40))
      call fmibta_m2b(mxy, k_return_code)
      if (k_return_code == 2) return
      call fmeq(mxy(40), mxy(38))
      call fmeq(mxy(39), mxy(40))
      call fmibta_m2b(mxy, k_return_code)
      if (k_return_code == 2) return
      call fmeq(mxy(40), mxy(39))
      call fmeq(mxy(22), mxy(40))
      call fmibta_m2b(mxy, k_return_code)
      if (k_return_code == 2) return
      call fmeq(mxy(40), mxy(21))

      return
      end subroutine fmibta_m2

      subroutine fmibta_m2b(mxy, k_return_code)
      use fmvals
      implicit none

!  Multiply the sum in mxy(40) by  x^a * (1-x)^b / a  and return the result in mxy(40).

      type(multi) :: mxy(40)
      integer :: k_return_code
      intent (inout) :: mxy, k_return_code

      integer :: k, nterms

      nterms = int(intmax/10)

      call fmln(mxy(1), mxy(19))
      call fmmpy_r1(mxy(19), mxy(2))
      if (mxy(1)%mp(2)*(-10) >= ndig) then
          call fmeq(mxy(1), mxy(15))
          call fmeq(mxy(1), mxy(20))
          do k = 2, nterms
             call fmmpy_r1(mxy(15), mxy(1))
             call fmdivi(mxy(15), k, mxy(12))
             call fmadd_r1(mxy(20), mxy(12))
             if (kflag /= 0) exit
             if (k == nterms) then
                 call fmunknown(mxy(21))
                 k_return_code = 2
                 return
             endif
          enddo
          call fmmpy_r1(mxy(20), mxy(3))
          call fmnegate(mxy(20))
      else
          call fmi2m(1, mxy(12))
          call fmsub_r1(mxy(12), mxy(1))
          call fmln(mxy(12), mxy(20))
          call fmmpy_r1(mxy(20), mxy(3))
      endif
      call fmadd(mxy(19), mxy(20), mxy(12))
      call fmexp(mxy(12), mxy(21))
      call fmmpy_r1(mxy(40), mxy(21))
      if (mxy(21)%mp(2) == munkno) then
          if (mxy(40)%mp(1)*mxy(40)%mp(3) > 0) then
              call fmln(mxy(40), mxy(12))
              call fmadd(mxy(12), mxy(19), mxy(7))
              call fmadd(mxy(7), mxy(20), mxy(12))
              call fmexp(mxy(12), mxy(21))
          else
              call fmeq(mxy(40), mxy(13))
              call fmnegate(mxy(13))
              call fmln(mxy(13), mxy(12))
              call fmadd(mxy(12), mxy(19), mxy(7))
              call fmadd(mxy(7), mxy(20), mxy(12))
              call fmexp(mxy(12), mxy(21))
              call fmnegate(mxy(21))
          endif
      endif
      if (abs(mxy(40)%mp(2)) < mexpov) call fmdiv_r1(mxy(40), mxy(2))

      return
      end subroutine fmibta_m2b

      subroutine fmibta_m5(mxy, mx, nmethd, ndsave, k_return_code, n_acc)

      use fmvals
      implicit none

      type(multi) :: mxy(40), mx
      integer :: nmethd, ndsave, k_return_code, n_acc
      intent (in) :: mx, nmethd, ndsave
      intent (inout) :: mxy, k_return_code, n_acc

      integer :: int_temp1, int_temp2, j, jextra, k, krsave, ndsav1, nterms

!             Method 5.  Continued fraction expansion 2 for b(x,a,b).

!             mxy(22) is the current sum.
!             mxy(21) is the term in the sum, s(k).
!             mxy(19), mxy(20) are the latest denominators, q(k-1) and q(k).

      n_acc = nint(ndig*alogm2)
      nterms = int(intmax/10)
      jextra = max(1, int(5.76/alogmb + 1.0)) + int(0.07*ndig)
      if (ndig+jextra > ndig) then
          call fmequ_r1(mxy(1), ndig, ndig+jextra)
          call fmequ_r1(mxy(2), ndig, ndig+jextra)
          call fmequ_r1(mxy(3), ndig, ndig+jextra)
      endif
      ndig = ndig + jextra
      ndsav1 = ndig
      call fmsqr(mxy(1), mxy(23))
      call fmi2m(1, mxy(12))
      call fmsub(mxy(2), mxy(12), mxy(24))
      call fmadd(mxy(2), mxy(3), mxy(25))
      call fmaddi(mxy(25), -1)
      call fmeq(mxy(24), mxy(26))
      call fmi2m(1, mxy(12))
      call fmadd(mxy(2), mxy(12), mxy(27))
      call fmeq(mxy(3), mxy(28))
      call fmi2m(1, mxy(7))
      call fmsub(mxy(2), mxy(7), mxy(12))
      call fmsqr(mxy(12), mxy(29))
      call fmi2m(2, mxy(12))
      call fmsub(mxy(12), mxy(1), mxy(30))
      if (nmethd == 6) then
          call fmequ(mx, mxy(19), ndsave, ndig)
          call fmmpy(mxy(2), mxy(19), mxy(7))
          call fmmpy(mxy(3), mxy(1), mxy(12))
          call fmsub(mxy(7), mxy(12), mxy(31))
          call fmaddi(mxy(31), 1)
      else
          call fmadd(mxy(2), mxy(3), mxy(7))
          call fmmpy(mxy(7), mxy(1), mxy(12))
          call fmsub(mxy(2), mxy(12), mxy(31))
          call fmaddi(mxy(31), 1)
      endif
      call fmeq(mxy(2), mxy(35))
      call fmi2m(2, mxy(7))
      call fmsub(mxy(2), mxy(7), mxy(12))
      call fmmpyi(mxy(12), 4, mxy(36))

      call fmi2m(1, mxy(33))
      call fmmpy(mxy(35), mxy(31), mxy(12))
      call fmdiv(mxy(12), mxy(27), mxy(34))

      call fmi2m(1, mxy(19))
      call fmeq(mxy(34), mxy(20))
      call fmdiv(mxy(33), mxy(34), mxy(21))
      if (mxy(21)%mp(1) > 0) then
          call fmeq(mxy(21), mxy(38))
          call fmi2m(0, mxy(39))
      else
          call fmeq(mxy(21), mxy(39))
          call fmi2m(0, mxy(38))
      endif

!             Method 5 continued fraction loop.

      krsave = kround
      kround = 1
      do j = 1, nterms
         call fmaddi(mxy(24), 1)
         call fmaddi(mxy(25), 1)
         call fmaddi(mxy(26), 2)
         call fmaddi(mxy(27), 2)
         call fmaddi(mxy(28), -1)
         call fmaddi(mxy(36), 8)
         call fmcsadd_r1(mxy(29), mxy(36))
         call fmcsadd_r1(mxy(31), mxy(30))
         call fmaddi(mxy(35), 1)

         call fmeq(mxy(24), mxy(15))
         call fmcsmpy_r1(mxy(15), mxy(25))
         call fmcsmpyi_r1(mxy(15), j)
         call fmcsmpy_r1(mxy(15), mxy(28))
         call fmcsmpy_r1(mxy(15), mxy(23))
         call fmcsdiv(mxy(15), mxy(29), mxy(33))

         call fmeq(mxy(35), mxy(15))
         call fmcsmpy_r1(mxy(15), mxy(31))
         call fmcsdiv(mxy(15), mxy(27), mxy(34))
         call fmeq(mxy(28), mxy(15))
         call fmcsmpy_r1(mxy(15), mxy(1))
         call fmcsmpyi_r1(mxy(15), j)
         call fmdiv_r1(mxy(15), mxy(26))
         call fmcsadd_r1(mxy(34), mxy(15))
         call fmaddi(mxy(34), j)

         call fmeq(mxy(33), mxy(18))
         call fmcsmpy_r1(mxy(18), mxy(19))
         call fmeq(mxy(34), mxy(15))
         call fmcsmpy_r1(mxy(15), mxy(20))
         call fmadd(mxy(15), mxy(18), mxy(17))
         call fmeq(mxy(18), mxy(15))
         call fmcsmpy_r1(mxy(15), mxy(21))
         call fmcsdiv(mxy(15), mxy(17), mxy(21))
         call fmnegate(mxy(21))

         ndig = ndsav1
         if (mxy(21)%mp(1) > 0) then
             call fmadd(mxy(38), mxy(21), mxy(19))
             int_temp1 = kflag
             call fmeq(mxy(19), mxy(38))
         else
             call fmadd(mxy(39), mxy(21), mxy(19))
             int_temp1 = kflag
             call fmeq(mxy(19), mxy(39))
         endif
         kflag = int_temp1

!             Check for convergence.

         if (kflag == 1 .and. j > 4) then
             exit
         endif

         call fmeq(mxy(20), mxy(19))
         call fmeq(mxy(17), mxy(20))
         call fmadd(mxy(38), mxy(39), mxy(15))
         int_temp1 = ndsav1 - int(mxy(15)%mp(2) - mxy(21)%mp(2))
         int_temp2 = max(ngrd22, int_temp1)
         ndig = min(ndsav1, int_temp2)
         if (j == nterms) then
             call fmunknown(mxy(21))
             k_return_code = 2
             return
         endif
      enddo
      call fmadd(mxy(38), mxy(39), mxy(15))
      call fmcancel(mxy(38), mxy(39), mxy(15), k)
      n_acc = n_acc - k
      call fmeq(mxy(15), mxy(22))

      kround = krsave
      ndig = ndsav1

!             Multiply the sums by x**a * (1-x)**b

      call fmeq(mxy(38), mxy(40))
      call fmibta_m5b(mx, mxy, ndsave, k_return_code, nmethd)
      if (k_return_code == 2) return
      call fmeq(mxy(40), mxy(38))
      call fmeq(mxy(39), mxy(40))
      call fmibta_m5b(mx, mxy, ndsave, k_return_code, nmethd)
      if (k_return_code == 2) return
      call fmeq(mxy(40), mxy(39))
      call fmeq(mxy(22), mxy(40))
      call fmibta_m5b(mx, mxy, ndsave, k_return_code, nmethd)
      if (k_return_code == 2) return
      call fmeq(mxy(40), mxy(21))

      return
      end subroutine fmibta_m5

      subroutine fmibta_m5b(mx, mxy, ndsave, k_return_code, nmethd)
      use fmvals
      implicit none

!  Return mxy(40) = x^a * (1-x)^b

      type(multi) :: mx, mxy(40)
      integer :: ndsave, k_return_code, nmethd
      intent (in) :: mx, ndsave, nmethd
      intent (inout) :: mxy, k_return_code

      integer :: k, nterms
      logical, external :: fmcomp

      nterms = int(intmax/10)
      call fmi2m(1, mxy(12))
      if (fmcomp(mxy(1), '==', mxy(12)) .and.  &
          nmethd == 6) then
          call fmequ(mx, mxy(19), ndsave, ndig)
          call fmmpy_r1(mxy(19), mxy(2))
          call fmnegate(mxy(19))
      else if (mx%mp(2) <= -1 .and. nmethd == 6) then
          call fmequ(mx, mxy(19), ndsave, ndig)
          call fmeq(mxy(19), mxy(15))
          call fmeq(mxy(19), mxy(20))
          do k = 2, nterms
             call fmmpy_r1(mxy(15), mxy(19))
             call fmdivi(mxy(15), k, mxy(12))
             call fmadd_r1(mxy(20), mxy(12))
             if (kflag /= 0) exit
             if (k == nterms) then
                 call fmunknown(mxy(21))
                 k_return_code = 2
                 return
             endif
          enddo
          call fmmpy(mxy(20), mxy(2), mxy(19))
          call fmnegate(mxy(19))
      else
          call fmln(mxy(1), mxy(19))
          call fmmpy_r1(mxy(19), mxy(2))
      endif
      if (nmethd == 6) then
          call fmequ(mx, mxy(20), ndsave, ndig)
          call fmln(mxy(20), mxy(10))
          call fmmpy(mxy(10), mxy(3), mxy(20))
      else if (mxy(1)%mp(2) <= -1) then
          call fmeq(mxy(1), mxy(15))
          call fmeq(mxy(1), mxy(20))
          do k = 2, nterms
             call fmmpy_r1(mxy(15), mxy(1))
             call fmdivi(mxy(15), k, mxy(12))
             call fmadd_r1(mxy(20), mxy(12))
             if (kflag /= 0) exit
             if (k == nterms) then
                 call fmunknown(mxy(21))
                 k_return_code = 2
                 return
             endif
          enddo
          call fmmpy_r1(mxy(20), mxy(3))
          call fmnegate(mxy(20))
      else
          call fmi2m(1, mxy(12))
          call fmsub_r1(mxy(12), mxy(1))
          call fmln(mxy(12), mxy(20))
          call fmmpy_r1(mxy(20), mxy(3))
      endif
      call fmadd(mxy(19), mxy(20), mxy(12))
      call fmexp(mxy(12), mxy(21))
      call fmmpy_r2(mxy(40), mxy(21))
      if (mxy(21)%mp(2) == munkno) then
          if (mxy(40)%mp(1)*mxy(40)%mp(3) > 0) then
              call fmln(mxy(40), mxy(12))
              call fmadd(mxy(12), mxy(19), mxy(7))
              call fmadd(mxy(7), mxy(20), mxy(12))
              call fmexp(mxy(12), mxy(21))
          else
              call fmeq(mxy(40), mxy(13))
              call fmnegate(mxy(13))
              call fmln(mxy(13), mxy(12))
              call fmadd(mxy(12), mxy(19), mxy(7))
              call fmadd(mxy(7), mxy(20), mxy(12))
              call fmexp(mxy(12), mxy(21))
              call fmnegate(mxy(21))
          endif
      endif
      call fmeq(mxy(21), mxy(40))

      return
      end subroutine fmibta_m5b

      subroutine fmibta_ma(mx, ma, mb, mxy, k_return_code, numtry, nwds1, kashift, kbshift, kbigab)

      use fmvals
      implicit none

      type(multi) :: mx, ma, mb, mxy(40)
      integer :: k_return_code, numtry, nwds1, kashift, kbshift, kbigab
      intent (in) :: mx, ma, mb
      intent (inout) :: mxy, k_return_code, numtry, nwds1, kashift, kbshift, kbigab

      logical, external :: fmcomp


!             Handle cases where at least one of x, a, b is underflow or overflow.
!             Increasing any underflowed values to 1/huge makes the calculations more stable.
!             If a is underflow and the final result is overflow, it is safe to return overflow.
!             If x is underflow and the final result is underflow, it is safe to return underflow.
!             If b is underflow, it is replaced by zero.
!             Similarly, decreasing any overflowed a or b values to huge and then getting a final
!             result of underflow means it is safe to return underflow.
!             Any cases where the inequalities conflict, such as a = underflow, b = overflow,
!             will return unknown.

      kbigab = 0
      if (ma%mp(2) == mexpov) then
          call fmbig(mxy(2))
          kbigab = -1
      endif
      if (mb%mp(2) == mexpov) then
          call fmbig(mxy(3))
          kbigab = -1
      endif
      if (mx%mp(2) == mexpun) then
          call fmbig(mxy(1))
          call fmi2m(1, mxy(12))
          call fmdiv_r2(mxy(12), mxy(1))
          kbigab = -1
      endif
      if (ma%mp(2) == mexpun) then
          call fmbig(mxy(2))
          call fmi2m(1, mxy(12))
          call fmdiv_r2(mxy(12), mxy(2))
          if (kbigab < 0) then
              kbigab = -9
              call fmi2m(0, mxy(21))
              k_return_code = 2
              return
          else
              kbigab = 1
          endif
      endif
      if (mb%mp(2) == mexpun) then
          call fmi2m(1, mxy(12))
          if (fmcomp(mxy(1), '/=', mxy(12))) then
              call fmi2m(0, mxy(3))
          endif
      endif
      numtry = 0
      nwds1 = 0
      kashift = 0
      kbshift = 0

      return
      end subroutine fmibta_ma

      subroutine fmibta_mb(mxy, nmethd)

      use fmvals
      implicit none

      type(multi) :: mxy(40)
      integer :: nmethd
      intent (inout) :: mxy, nmethd

      logical, external :: fmcomp

!             Determine which method to use.

!             nmethd = 1 means use the convergent series for b(x,a,b),
!                    = 2 means use continued fraction expansion 1 for b(x,a,b),
!                    = 3 means use the convergent series for b(1-x,b,a).
!                    = 4 means use continued fraction expansion 1 for b(1-x,b,a).
!                    = 5 means use continued fraction expansion 2 for b(x,a,b).
!                    = 6 means use continued fraction expansion 2 for b(1-x,b,a).

      call fmsqr(mxy(2), mxy(12))
      call fmdpm(dble(0.00173), mxy(7))
      call fmmpy(mxy(7), mxy(12), mxy(6))
      call fmsqr(mxy(3), mxy(12))
      call fmdpm(dble(0.01253), mxy(7))
      call fmmpy(mxy(7), mxy(12), mxy(5))
      call fmadd_r1(mxy(6), mxy(5))
      call fmdpm(dble(0.21583), mxy(7))
      call fmmpy(mxy(7), mxy(2), mxy(5))
      call fmadd_r1(mxy(6), mxy(5))
      call fmdpm(dble(0.03891), mxy(7))
      call fmmpy(mxy(7), mxy(3), mxy(5))
      call fmadd_r1(mxy(6), mxy(5))
      call fmdpm(dble(9.14350), mxy(5))
      call fmadd_r1(mxy(6), mxy(5))

      call fmdpm(dble(0.11709), mxy(7))
      call fmmpy(mxy(7), mxy(2), mxy(5))
      call fmdpm(dble(0.62633), mxy(7))
      call fmmpy(mxy(7), mxy(3), mxy(4))
      call fmadd_r1(mxy(5), mxy(4))
      call fmaddi(mxy(5), 1)

      call fmdiv(mxy(5), mxy(6), mxy(33))

      call fmdpm(dble(0.29217), mxy(7))
      call fmmpy(mxy(7), mxy(2), mxy(6))
      call fmdpm(dble(2.09304), mxy(7))
      call fmmpy(mxy(7), mxy(3), mxy(5))
      call fmadd_r1(mxy(6), mxy(5))
      call fmdpm(dble(1.53724), mxy(5))
      call fmadd_r1(mxy(6), mxy(5))

      call fmdpm(dble(0.29217), mxy(7))
      call fmmpy(mxy(7), mxy(2), mxy(5))
      call fmdpm(dble(2.09304), mxy(7))
      call fmmpy(mxy(7), mxy(3), mxy(4))
      call fmadd_r1(mxy(5), mxy(4))
      call fmaddi(mxy(5), 1)

      call fmdiv(mxy(5), mxy(6), mxy(34))

      call fmsqr(mxy(2), mxy(12))
      call fmdpm(dble(0.04038), mxy(7))
      call fmmpy(mxy(7), mxy(12), mxy(6))
      call fmsqr(mxy(3), mxy(12))
      call fmdpm(dble(0.05754), mxy(7))
      call fmmpy(mxy(7), mxy(12), mxy(5))
      call fmadd_r1(mxy(6), mxy(5))
      call fmdpm(dble(0.02670), mxy(7))
      call fmmpy(mxy(7), mxy(2), mxy(5))
      call fmadd_r1(mxy(6), mxy(5))
      call fmdpm(dble(0.56206), mxy(7))
      call fmmpy(mxy(7), mxy(3), mxy(5))
      call fmadd_r1(mxy(6), mxy(5))
      call fmdpm(dble(0.13746), mxy(5))
      call fmadd_r1(mxy(6), mxy(5))

      call fmdpm(dble(0.87312), mxy(7))
      call fmmpy(mxy(7), mxy(2), mxy(5))
      call fmdpm(dble(0.20334), mxy(7))
      call fmmpy(mxy(7), mxy(3), mxy(4))
      call fmadd_r1(mxy(5), mxy(4))
      call fmaddi(mxy(5), 1)

      call fmdiv(mxy(5), mxy(6), mxy(35))

      call fmdpm(dble(0.64584), mxy(7))
      call fmmpy(mxy(7), mxy(2), mxy(6))
      call fmdpm(dble(0.64584), mxy(7))
      call fmmpy(mxy(7), mxy(3), mxy(5))
      call fmadd_r1(mxy(6), mxy(5))
      call fmdpm(dble(6.31958), mxy(5))
      call fmadd_r1(mxy(6), mxy(5))

      call fmdpm(dble(0.64584), mxy(7))
      call fmmpy(mxy(7), mxy(2), mxy(5))
      call fmaddi(mxy(5), 1)

      call fmdiv(mxy(5), mxy(6), mxy(36))

      call fmsqr(mxy(2), mxy(12))
      call fmdpm(dble(0.11637), mxy(7))
      call fmmpy(mxy(7), mxy(12), mxy(6))
      call fmsqr(mxy(3), mxy(12))
      call fmdpm(dble(0.10718), mxy(7))
      call fmmpy(mxy(7), mxy(12), mxy(5))
      call fmadd_r1(mxy(6), mxy(5))
      call fmdpm(dble(0.92626), mxy(7))
      call fmmpy(mxy(7), mxy(2), mxy(5))
      call fmadd_r1(mxy(6), mxy(5))
      call fmdpm(dble(0.05518), mxy(7))
      call fmmpy(mxy(7), mxy(3), mxy(5))
      call fmadd_r1(mxy(6), mxy(5))
      call fmdpm(dble(0.28962), mxy(5))
      call fmadd_r1(mxy(6), mxy(5))

      call fmdpm(dble(0.99773), mxy(7))
      call fmmpy(mxy(7), mxy(2), mxy(5))
      call fmdpm(dble(0.56855), mxy(7))
      call fmmpy(mxy(7), mxy(3), mxy(4))
      call fmadd_r1(mxy(5), mxy(4))
      call fmaddi(mxy(5), 1)

      call fmdiv(mxy(5), mxy(6), mxy(37))
      if (fmcomp(mxy(1), '<=', mxy(33))) then
          nmethd = 1
      else if (fmcomp(mxy(1), '>=', mxy(34))) then
          nmethd = 3
      else if (fmcomp(mxy(1), '<', mxy(37))) then
          if (fmcomp(mxy(1), '<', mxy(35))) then
              nmethd = 2
          else
              nmethd = 4
          endif
      else
          if (fmcomp(mxy(1), '<', mxy(36))) then
              nmethd = 5
          else
              nmethd = 6
          endif
      endif
      if (mxy(3)%mp(2) <= 0 .and. mxy(2)%mp(2)+ndig < 0) then
          nmethd = 1
      endif

      return
      end subroutine fmibta_mb

      subroutine fmibta_mc(mx, mxy, numtry, nmethd, ndsave, k_return_code, n_acc,  &
                           nwds1, kashift, kbshift)

      use fmvals
      implicit none

      type(multi) :: mx, mxy(40)
      integer :: numtry, nmethd, ndsave, k_return_code, n_acc, nwds1, kashift, kbshift
      intent (in) :: mx, ndsave
      intent (inout) :: mxy, numtry, nmethd, k_return_code, n_acc, nwds1, kashift, kbshift

      real (kind(1.0d0)) :: mla
      integer :: j, k


!             Method 3, 4, or 6.  b(x,a,b) = b(a,b) - b(1-x,b,a).

      call fmi2m(1, mxy(12))
      call fmsub_r2(mxy(12), mxy(1))
      do j = 1, ndig+2
         mla = mxy(2)%mp(j)
         mxy(2)%mp(j) = mxy(3)%mp(j)
         mxy(3)%mp(j) = mla
      enddo
      if (nmethd == 3) then
          call fmibta_m1(mxy, k_return_code, n_acc)
      else if (nmethd == 4) then
          call fmibta_m2(mxy, k_return_code, n_acc)
      else
          call fmibta_m5(mxy, mx, nmethd, ndsave, k_return_code, n_acc)
      endif
      if (k_return_code == 2) return

      k = nwds1
      call fmeq(mxy(21), mxy(30))
      call fmbeta(mxy(2), mxy(3), mxy(32))
      n_acc = nint(ndig*alogm2)
      if (mxy(32)%mp(1) > 0) then
          call fmsub(mxy(32), mxy(39), mxy(37))
          call fmmpyi(mxy(38), -1, mxy(39))
          call fmeq(mxy(37), mxy(38))
      else
          call fmsub(mxy(32), mxy(38), mxy(37))
          call fmmpyi(mxy(39), -1, mxy(38))
          call fmeq(mxy(37), mxy(39))
      endif
      call fmadd(mxy(38), mxy(39), mxy(21))
      nwds1 = int(max(mxy(32)%mp(2), mxy(30)%mp(2)))
      call fmcancel(mxy(38), mxy(39), mxy(21), j)
      n_acc = n_acc - j
      nwds1 = max(0, nwds1-int(mxy(21)%mp(2)))
      if (k /= nwds1 .and. numtry >= 1) then
          if (kashift == 0 .and. kbshift == 0) n_acc = -1
      endif

      return
      end subroutine fmibta_mc

      subroutine fmibta_md(mx, ma, mb, mxy, nterms, ndsave, k_return_code, n_acc,  &
                           kashift, kbshift, kfsave)

      use fmvals
      implicit none

      type(multi) :: mx, ma, mb, mxy(40)
      integer :: nterms, ndsave, k_return_code, n_acc, kashift, kbshift, kfsave
      intent (in) :: mx, ma, mb, ndsave
      intent (inout) :: mxy, nterms, k_return_code, n_acc, kashift, kbshift, kfsave

      integer :: j, k

!             Check for too much cancellation.

      kfsave = kflag

!             Reverse the translation if kashift is positive.
!             This is used when a is small and a retry was required because of cancellation.

      if (kashift > 0 .and. n_acc > 0) then
          call fmequ(mx, mxy(22), ndsave, ndig)
          call fmequ(ma, mxy(23), ndsave, ndig)
          call fmequ(mb, mxy(24), ndsave, ndig)
          if (kbshift > 0) call fmaddi(mxy(24), kbshift)
          call fmi2m(1, mxy(19))
          call fmadd(mxy(23), mxy(24), mxy(16))
          call fmi2m(1, mxy(12))
          call fmadd(mxy(23), mxy(12), mxy(7))
          call fmdiv(mxy(16), mxy(7), mxy(20))
          call fmi2m(1, mxy(12))
          call fmsub(mxy(12), mxy(22), mxy(17))
          call fmeq(mxy(22), mxy(18))
          call fmmpy(mxy(20), mxy(22), mxy(12))
          call fmadd_r1(mxy(19), mxy(12))
          call fmeq(mxy(16), mxy(14))
          call fmeq(mxy(23), mxy(15))
          call fmaddi(mxy(15), 1)
          do j = 2, kashift-1
             call fmaddi(mxy(14), 1)
             call fmaddi(mxy(15), 1)
             call fmmpy_r1(mxy(20), mxy(14))
             call fmdiv_r1(mxy(20), mxy(15))
             call fmmpy_r1(mxy(18), mxy(22))
             call fmmpy(mxy(20), mxy(18), mxy(13))
             call fmadd_r1(mxy(19), mxy(13))
          enddo
          if (mxy(22)%mp(2)*(-10) >= ndig) then
              call fmeq(mxy(22), mxy(15))
              call fmeq(mxy(22), mxy(17))
              do k = 2, nterms
                 call fmmpy_r1(mxy(15), mxy(22))
                 call fmdivi(mxy(15), k, mxy(12))
                 call fmadd_r1(mxy(17), mxy(12))
                 if (kflag /= 0) exit
                 if (k == nterms) then
                     call fmunknown(mxy(21))
                     k_return_code = 2
                     return
                 endif
              enddo
              call fmmpy(mxy(17), mxy(24), mxy(12))
              call fmnegate(mxy(12))
              call fmexp(mxy(12), mxy(18))
              call fmeq(mxy(19), mxy(15))
              call fmpwr(mxy(22), mxy(23), mxy(12))
              call fmmpy(mxy(19), mxy(12), mxy(7))
              call fmmpy(mxy(7), mxy(18), mxy(12))
              call fmdiv(mxy(12), mxy(23), mxy(19))
              if (mxy(19)%mp(2) == munkno) then
                  call fmln(mxy(22), mxy(12))
                  call fmmpy(mxy(23), mxy(12), mxy(19))
                  call fmln(mxy(15), mxy(12))
                  call fmadd_r2(mxy(12), mxy(19))
                  call fmmpy(mxy(17), mxy(24), mxy(12))
                  call fmsub_r1(mxy(19), mxy(12))
                  call fmln(mxy(23), mxy(12))
                  call fmsub_r2(mxy(19), mxy(12))
                  call fmexp(mxy(12), mxy(19))
              endif
          else
              call fmpwr(mxy(22), mxy(23), mxy(12))
              call fmmpy_r1(mxy(19), mxy(12))
              call fmpwr(mxy(17), mxy(24), mxy(12))
              call fmmpy_r1(mxy(19), mxy(12))
              call fmdiv_r1(mxy(19), mxy(23))
          endif
          call fmmpy(mxy(21), mxy(20), mxy(12))
          call fmi2m(kashift-1, mxy(7))
          call fmadd_r2(mxy(16), mxy(7))
          call fmmpy_r1(mxy(12), mxy(7))
          call fmdiv(mxy(12), mxy(23), mxy(20))
          call fmadd(mxy(20), mxy(19), mxy(21))
          call fmcancel(mxy(20), mxy(19), mxy(21), j)
          n_acc = n_acc - j
      endif

      return
      end subroutine fmibta_md

      subroutine fmibta_me(mx, ma, mb, mxy, nterms, ndsave, k_return_code, n_acc, kbshift)

      use fmvals
      implicit none

      type(multi) :: mx, ma, mb, mxy(40)
      integer :: nterms, ndsave, k_return_code, n_acc, kbshift
      intent (in) :: mx, ma, mb, ndsave
      intent (inout) :: mxy, nterms, k_return_code, n_acc, kbshift

      integer :: j, k

!             Reverse the translation if kbshift is positive.
!             This is used when x is close to 1, b is small, and a retry was required because
!             of cancellation.

      if (kbshift > 0 .and. n_acc > 0) then
          call fmequ(mx, mxy(22), ndsave, ndig)
          call fmequ(ma, mxy(23), ndsave, ndig)
          call fmequ(mb, mxy(24), ndsave, ndig)
          call fmi2m(1, mxy(19))
          call fmi2m(1, mxy(12))
          call fmadd(mxy(24), mxy(12), mxy(7))
          call fmadd(mxy(23), mxy(24), mxy(12))
          call fmdiv(mxy(12), mxy(7), mxy(20))
          call fmadd(mxy(23), mxy(24), mxy(16))
          call fmi2m(1, mxy(12))
          call fmsub(mxy(12), mxy(22), mxy(17))
          call fmeq(mxy(17), mxy(18))
          call fmmpy(mxy(20), mxy(18), mxy(12))
          call fmadd_r1(mxy(19), mxy(12))
          call fmeq(mxy(16), mxy(14))
          call fmeq(mxy(24), mxy(15))
          call fmaddi(mxy(15), 1)
          do j = 2, kbshift-1
             call fmaddi(mxy(14), 1)
             call fmaddi(mxy(15), 1)
             call fmmpy_r1(mxy(20), mxy(14))
             call fmdiv_r1(mxy(20), mxy(15))
             call fmmpy_r1(mxy(18), mxy(17))
             call fmmpy(mxy(20), mxy(18), mxy(13))
             call fmadd_r1(mxy(19), mxy(13))
          enddo
          if (mxy(22)%mp(2)*(-10) >= ndig) then
              call fmeq(mxy(22), mxy(15))
              call fmeq(mxy(22), mxy(17))
              do k = 2, nterms
                 call fmmpy_r1(mxy(15), mxy(22))
                 call fmdivi(mxy(15), k, mxy(12))
                 call fmadd_r1(mxy(17), mxy(12))
                 if (kflag /= 0) exit
                 if (k == nterms) then
                     call fmunknown(mxy(21))
                     k_return_code = 2
                     return
                 endif
              enddo
              call fmmpy(mxy(17), mxy(24), mxy(12))
              call fmnegate(mxy(12))
              call fmexp(mxy(12), mxy(17))
              call fmpwr(mxy(22), mxy(23), mxy(12))
              call fmmpy(mxy(19), mxy(12), mxy(7))
              call fmmpy(mxy(7), mxy(17), mxy(12))
              call fmdiv(mxy(12), mxy(24), mxy(19))
          else
              call fmpwr(mxy(22), mxy(23), mxy(12))
              call fmmpy_r1(mxy(19), mxy(12))
              call fmpwr(mxy(17), mxy(24), mxy(12))
              call fmmpy_r1(mxy(19), mxy(12))
              call fmdiv_r1(mxy(19), mxy(24))
          endif
          call fmmpy(mxy(21), mxy(20), mxy(12))
          call fmi2m(kbshift-1, mxy(7))
          call fmadd_r2(mxy(16), mxy(7))
          call fmmpy_r1(mxy(12), mxy(7))
          call fmdiv(mxy(12), mxy(24), mxy(20))
          call fmsub(mxy(20), mxy(19), mxy(21))
          call fmcancel(mxy(20), mxy(19), mxy(21), j)
          n_acc = n_acc - j
      endif

      return
      end subroutine fmibta_me

      subroutine fmibta_mf(mx, ma, mb, mxy, krt, k_return_code, numtry, nmethd, ndsave, n_acc,  &
                           kashift, kbshift, kfsave, mretry)

      use fmvals
      implicit none

      type(multi) :: mx, ma, mb, mxy(40), mretry
      integer :: krt, k_return_code, numtry, nmethd, ndsave, n_acc, kashift, kbshift, kfsave
      intent (in) :: mx, ma, mb, ndsave, kfsave
      intent (inout) :: mxy, mretry, krt, k_return_code, numtry, nmethd, n_acc, kashift, kbshift

      real (kind(1.0d0)) :: mla
      integer :: iextra, j, ksk, ndgoal, ndold, ngoal
      logical, external :: fmcomp

      krt = 0
      if (ncall >= 1) then
          ngoal = 1.06*(int(dble(ndsave)*alogm2) + 29)
      else
          ngoal = int(-mxexp2)
      endif
      ndgoal = int(dble(ngoal)/alogm2 + 1.0)
      if (n_acc <= ngoal) then
          if (numtry > 0) then
              ksk = 0
              if (mxy(21)%mp(3) == 0 .or. kfsave < 0) then
                  ksk = 1
              else
                  do j = 1, ndgoal+1
                     if (mretry%mp(j+1) /= mxy(21)%mp(j+1)) then
                         ksk = 1
                         exit
                     endif
                  enddo
              endif
              if (ksk == 0) then
                  call fmi2m(1, mxy(15))
                  n_acc = nint(ndig*alogm2)
                  k_return_code = 2
                  return
              endif
          endif

          iextra = int(dble(ngoal-n_acc)/alogm2 + 23.03/alogmb) + 1
          ndold = ndig
          ndig = ndig + iextra
          if (n_acc < 0) ndig = ndold + 10*2**numtry
          if (abs(mx%mp(2)) >= mexpov .or. abs(ma%mp(2)) >= mexpov .or.  &
              abs(mb%mp(2)) >= mexpov) then
              call fmunknown(mxy(21))
              kflag = -4
              k_return_code = 2
              return
          endif
          call fmequ_r1(mxy(1), ndsave, ndig)
          call fmequ_r1(mxy(2), ndsave, ndig)
          call fmequ_r1(mxy(3), ndsave, ndig)
          if (nmethd == 3 .or. nmethd == 4 .or. nmethd == 6) then
              call fmequ(mx, mxy(1), ndsave, ndig)
              do j = 1, ndig+2
                 mla = mxy(2)%mp(j)
                 mxy(2)%mp(j) = mxy(3)%mp(j)
                 mxy(3)%mp(j) = mla
              enddo
          endif

          if (kashift > 0) then
              call fmequ(ma, mxy(2), ndsave, ndig)
              if (kashift <= 2000) then
                  kashift = 9*kashift
              else
                  kashift = ndig
              endif
              call fmaddi(mxy(2), kashift)
          endif
          if (kbshift > 0) then
              call fmequ(mb, mxy(3), ndsave, ndig)
              if (kbshift <= 2000) then
                  kbshift = 9*kbshift
              else
                  kbshift = ndig
              endif
              call fmaddi(mxy(3), kbshift)
          endif

!             Check to see if a retry is about to be done for small a and large b.
!             If so, raise a by 2*ndig to reduce the potential cancellation error.

          call fmi2m(200, mxy(12))
          if (numtry == 0 .and.                    &
              fmcomp(mxy(2), '<=', mxy(12)) .and.  &
              fmcomp(mxy(3), '>=', mxy(2))) then
              kashift = 2*ndig
              call fmaddi(mxy(2), 2*ndig)
          endif

!             Check to see if a retry is about to be done for a > 100 and b < 2.
!             If so, raise b by 2*ndig to reduce the potential cancellation error.

          call fmi2m(100, mxy(12))
          call fmi2m(2, mxy(7))
          if (numtry == 0 .and.                    &
              fmcomp(mxy(2), '>=', mxy(12)) .and.  &
              fmcomp(mxy(3), '<=', mxy(7))) then
              kbshift = 2*ndig
              call fmaddi(mxy(3), 2*ndig)
          endif

          call fmi2m(40*numtry, mxy(12))
          call fmi2m(100, mxy(7))
          if (numtry > 0 .and. kashift == 0 .and.  &
              fmcomp(mxy(2), '<=', mxy(12)) .and.  &
              fmcomp(mxy(3), '>=', mxy(7))) then
              kashift = 2*ndig
              call fmaddi(mxy(2), 2*ndig)
          endif

          call fmi2m(40*numtry, mxy(12))
          call fmi2m(100, mxy(7))
          if (numtry > 0 .and. kbshift == 0 .and.  &
              fmcomp(mxy(2), '>=', mxy(12)) .and.  &
              fmcomp(mxy(3), '<=', mxy(7))) then
              kbshift = 2*ndig
              call fmaddi(mxy(3), 2*ndig)
          endif

          numtry = numtry + 1
          call fmequ(mxy(21), mretry, ndold, ndig)
          if (kashift == 2*ndig .or. kbshift == 2*ndig) then
              ndig = max(ndig, ndold+2)
          endif
          krt = 1
          return
      endif

      return
      end subroutine fmibta_mf

      subroutine fmibta_sc(mx, ma, mb, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = ibta(mx,ma,mb).

!  kresult = 1 is returned if a special case gives the value of ibta(mx,ma,mb).

      use fmvals
      implicit none

      type(multi) :: mx, ma, mb, mxy(40), mresult
      integer :: kresult, ndsave
      intent (in) :: mx, ma, mb, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j, krs
      double precision :: b_xe, x_xe
      type(multi), save :: mxlocal, malocal, mblocal
      logical, external :: fmcomp
      logical :: lun

      kresult = 0

      namest(ncall) = 'FMIBTA   '
      j = ndig
      ndig = ndsave
      call fmntr_inp3(mx, ma, mb)
      ndig = j

      call fmequ(mx, mxlocal, ndsave, ndig)
      call fmequ(ma, malocal, ndsave, ndig)
      call fmequ(mb, mblocal, ndsave, ndig)

      if ((mxlocal%mp(2) == munkno .and. mxlocal%mp(5) >= 0) .or.  &
          (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) .or.  &
          (mblocal%mp(2) == munkno .and. mblocal%mp(5) >= 0)) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      call fmi2m(1, mxy(1))
      lun = mx%mp(1) < 0 .or. ma%mp(1) < 0 .or. mb%mp(1) < 0
      lun = lun .or. ma%mp(3) == 0  .or. fmcomp(mxlocal, '>', mxy(1))
      if (lun) then
          call fmunknown(mresult)
          kflag = -4
          kresult = 1
          return
      endif
      if (abs(mx%mp(2)) == mexpov .or. abs(ma%mp(2)) == mexpov .or.  &
          abs(mb%mp(2)) == mexpov .or. mx%mp(3) == 0) then
          krs = 0
          call fmi2m(1, mxy(1))
          if (mx%mp(3) == 0) then
              call fmi2m(0, mxy(8))
              krs = 1
          else if (mx%mp(2) == mexpun) then
              call fmovun_xe(mxlocal, x_xe)
              call fmovun_xe(mblocal, b_xe)
              if (b_xe+x_xe < -ndsave) then
                  call fmpwr(mxlocal, malocal, mxy(2))
                  call fmdiv(mxy(2), malocal, mxy(8))
                  if (mxy(8)%mp(2) /= munkno) then
                      krs = 1
                  endif
              endif
          else if (ma%mp(2) == mexpun .and. mb%mp(2) < mexpov) then
              call fmdiv(mxy(1), malocal, mxy(8))
              krs = 1
          else if (fmcomp(malocal, '==', mxy(1))) then
              call fmsub(mxy(1), mxlocal, mxy(2))
              call fmpwr(mxy(2), mblocal, mxy(3))
              call fmsub(mxy(1), mxy(3), mxy(2))
              call fmdiv(mxy(2), mblocal, mxy(8))
              if (mxy(8)%mp(2) /= munkno) then
                  krs = 1
              endif
          endif
          if (krs == 1) then
              call fmeq(mxy(8), mresult)
              if (mresult%mp(2) == munkno) then
                  kflag = -4
              endif
              kresult = 1
              return
          endif
      endif

      call fmibta3(mxlocal, malocal, mblocal, mresult, mxy, kresult)

      return
      end subroutine fmibta_sc

      subroutine fmigm1(ma, mb, mc)

!  mc = incomplete gamma(ma, mb)

!  Integral from 0 to mb of e**(-t) * t**(ma-1)  dt.

!  This is (lower case) gamma(a, x).   Domain:  ma: all reals except integers <= 0,  mb >= 0.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(18), mresult, mretry

      call fmalloc(mc, ndig+2)
      call fmenter2(ma, mb, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmigm1_sc(ma, mb, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mc, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      n_acc = nint(ndig*alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmigm1_m(ma, mb, mxy, mresult, ndsave, retry, n_acc, mxsave)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mc, kovun, mxsave, ndsave)

      return
      end subroutine fmigm1

      subroutine fmigm1_m(ma, mb, mxy, mresult, ndsave, retry, n_acc, mxsave)

!  Method selection for computing igm1(ma, mb).

      use fmvals
      implicit none

      type(multi) :: ma, mb, mxy(18), mresult
      integer :: ndsave, n_acc
      double precision :: mxsave
      logical :: retry
      intent (in) :: ma, mb, ndsave, mxsave
      intent (inout) :: mxy, mresult, retry, n_acc

      double precision :: a, b, big, c, c1, c2, d, dt1, small, t, t1, tlnb, tol, x, y
      real (kind(1.0d0)) :: moda2
      integer :: iextra, inta, intg, j, jr, k, kflaga, kflagi, kflagx, kwrnsv, kxneg,  &
                 nd1, nmethd, nterms
      logical, external :: fmcomp
      double precision, external :: fmdplg

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, ndig)
      call fmequ(mb, mxy(2), ndsave, ndig)
      n_acc = nint(ndig*alogm2)
      nterms = int(intmax/10)


!             Check for special cases.

!             See if a is small enough so that the result is x**a/a.

      call fmi2m(1, mxy(5))
      jr = kround
      kround = 1
      call fmadd(mxy(1), mxy(5), mxy(4))
      kround = jr
      if (fmcomp(mxy(4), '==', mxy(5))) then
          call fmpwr(mxy(2), mxy(1), mxy(5))
          call fmdiv(mxy(5), mxy(1), mxy(13))
          if (mxy(13)%mp(2) /= munkno) then
              call fmeq(mxy(13), mresult)
              retry = .false.
              return
          endif
      endif

!             Check to see if x is large enough so that the result is gamma(a).

      call fmi2m(1, mxy(5))
      call fmdiv(mxy(1), mxy(2), mxy(4))
      mxy(4)%mp(1) = 1
      call fmdpm(dble(0.001), mxy(3))
      if (fmcomp(mxy(2), '>', mxy(5)) .and. fmcomp(mxy(4), '<=', mxy(3))) then
          call fmi2m(1, mxy(4))
          call fmsub(mxy(1), mxy(4), mxy(5))
          call fmln(mxy(2), mxy(6))
          call fmmpy(mxy(5), mxy(6), mxy(4))
          call fmsub(mxy(4), mxy(2), mxy(6))
          call fmexp(mxy(6), mxy(15))
          if (mxy(15)%mp(2) /= munkno) then
              call fmgam(mxy(1), mxy(14))
              call fmsub_r1(mxy(14), mxy(15))
              if (mxy(14)%mp(2) > mxy(15)%mp(2)+ndig .and.  &
                  mxy(14)%mp(2) /= munkno) then
                  call fmeq(mxy(14), mresult)
                  retry = .false.
                  return
              endif
          endif
      endif

!             a, x are double precision approximations to the two arguments to this function.
!             inta = a if a is a small integer.  It is used to limit the number of terms used in
!                    the asymptotic series and in the continued fraction expansion.

      inta = nterms
      kwrnsv = kwarn
      kwarn = 0
      call fmm2i(mxy(1), intg)
      kflagi = kflag
      if (kflag == 0) inta = intg
      call fmm2dp(mxy(1), a)
      kflaga = kflag
      if (kflag /= 0 .and. mxy(1)%mp(2) < 0) then
          a = 1.0d0/dpmax
          if (mxy(1)%mp(1) < 0) a = -a
          kflaga = 0
      endif
      call fmm2dp(mxy(2), x)
      kflagx = kflag
      if (kflag /= 0 .and. mxy(2)%mp(2) < 0) then
          x = 1.0d0/dpmax
          if (mxy(2)%mp(1) < 0) x = -x
          kflagx = 0
      endif
      kwarn = kwrnsv

!             If a or x is large in magnitude, use more guard digits.

      j = mxy(1)%mp(2)
      if (mxy(1)%mp(3) >= sqrt(dble(mbase))) j = j + 1
      k = mxy(2)%mp(2)
      if (mxy(2)%mp(3) >= sqrt(dble(mbase))) k = k + 1
      nd1 = max(j, k)
      iextra = min(max(nd1, 0) , int(1.0+alogmx/alogmb))
      if (iextra > 0) then
          call fmequ_r1(mxy(1), ndig, ndig+iextra)
          call fmequ_r1(mxy(2), ndig, ndig+iextra)
      endif
      ndig = ndig + iextra
      n_acc = nint(ndig*alogm2)

!             kxneg = 1 if x is negative and a is a positive integer.

      kxneg = 0

!             moda2 = mod(a, 2) when kxneg is 1.

      moda2 = 0

      if (mxy(1)%mp(2) == mexpov .or. mxy(2)%mp(2) == mexpov) then
          if (mxy(1)%mp(2) == mexpov .and. mxy(1)%mp(1) > 0) then
              if (mxy(2)%mp(3) == 0) then
                  call fmi2m(0, mresult)
                  return
              endif
              if (mxy(2)%mp(2) == mexpov .and. mxy(2)%mp(1) > 0) then
                  call fmgam(mxy(1), mresult)
                  return
              else if (mxy(2)%mp(1) > 0) then
                  call fmi2m(1, mxy(13))
                  if (fmcomp(mxy(2), '<=', mxy(13))) then
                      call fmpwr(mxy(2), mxy(1), mxy(11))
                      call fmexp(mxy(2), mxy(12))
                      call fmmpy_r2(mxy(1), mxy(12))
                      call fmdiv(mxy(11), mxy(12), mresult)
                      kflag = -6
                      return
                  else
                      call fmoverflow(1, mxy(13))
                      if (huge(mbase)/mexpov > 1.0d+20) then
                          d = 1.0d+10
                      else
                          d = 4
                      endif
                      mxy(13)%mp(4) = huge(mbase)/d
                      mxy(13)%mp(5) = -(1.0d0 - epsilon(1.0d0)) * maxint
                      kflag = -5
                      call fmeq(mxy(13), mresult)
                      return
                  endif
              endif
          endif
          if (mxy(2)%mp(2) == mexpov .and. mxy(2)%mp(1) > 0) then
              call fmgam(mxy(1), mxy(15))
              call fmeq(mxy(15), mresult)
              return
          endif
          if (mxy(2)%mp(2) == mexpov .and. mxy(2)%mp(1) < 0 .and.  &
              mxy(1)%mp(1) > 0.and. mxy(1)%mp(3) > 0) then
              if (mxy(1)%mp(2) /= mexpov) then
                  call fmint(mxy(1), mxy(12))
                  if (fmcomp(mxy(1), '==', mxy(12))) then
                      call fmi2m(2, mxy(9))
                      call fmmod(mxy(12), mxy(9), mxy(5))
                      call fmeq(mxy(5), mxy(9))
                      if (mxy(9)%mp(3) /= 0) then
                          call fmoverflow(-1, mxy(13))
                          if (huge(mbase)/mexpov > 1.0d+20) then
                              d = 1.0d+10
                          else
                              d = 4
                          endif
                          mxy(13)%mp(4) = huge(mbase)/d
                          mxy(13)%mp(5) = -(1.0d0 - epsilon(1.0d0)) * maxint
                          kflag = -5
                          call fmeq(mxy(13), mresult)
                          return
                      else
                          call fmoverflow(1, mxy(13))
                          if (huge(mbase)/mexpov > 1.0d+20) then
                              d = 1.0d+10
                          else
                              d = 4
                          endif
                          mxy(13)%mp(4) = huge(mbase)/d
                          mxy(13)%mp(5) = -(1.0d0 - epsilon(1.0d0)) * maxint
                          kflag = -5
                          call fmeq(mxy(13), mresult)
                          return
                      endif
                  endif
              endif
          endif
          call fmunknown(mresult)
          kflag = -4
          retry = .false.
          return
      endif

      if (mxy(1)%mp(2) == mexpun .or. mxy(2)%mp(2) == mexpun) then
          call fmabs(mxy(1), mxy(4))
          call fmi2m(1, mxy(5))
          if (fmcomp(mxy(4), '<', mxy(5)) .and. mxy(2)%mp(2) == mexpun) then
              call fmunknown(mresult)
              kflag = -4
              retry = .false.
              return
          endif
          call fmabs(mxy(1), mxy(4))
          call fmi2m(1, mxy(5))
          if (fmcomp(mxy(4), '>=', mxy(5)) .and. mxy(2)%mp(2) == mexpun .and.  &
              mxy(1)%mp(1) > 0 .and. mxy(2)%mp(1) > 0) then
              call fmunderflow(1, mresult)
              kflag = -6
              retry = .false.
              return
          endif
      endif

      if (mxy(1)%mp(1) < 0 .or. mxy(1)%mp(3) == 0) then
          call fmint(mxy(1), mxy(12))
          if (fmcomp(mxy(1), '==', mxy(12))) then
              call fmunknown(mresult)
              kflag = -4
              retry = .false.
              return
          endif
      endif
      if (mxy(2)%mp(3) == 0) then
          if (mxy(1)%mp(1) <= 0) then
              call fmunknown(mresult)
              kflag = -4
              retry = .false.
              return
          else
              call fmi2m(0, mresult)
              retry = .false.
              return
          endif
      endif
      if (mxy(2)%mp(1) < 0) then
          call fmint(mxy(1), mxy(12))
          if (fmcomp(mxy(1), '==', mxy(12))) then
              kxneg = 1
              call fmi2m(2, mxy(9))
              call fmmod(mxy(12), mxy(9), mxy(5))
              call fmeq(mxy(5), mxy(9))
              if (mxy(9)%mp(3) /= 0) moda2 = 1
          else
              call fmunknown(mresult)
              kflag = -4
              retry = .false.
              return
          endif
      endif
      call fmmax(mxy(1), mxy(2), mxy(5))
      call fmmin(mxy(1), mxy(2), mxy(6))
      call fmdpm(1.0d6, mxy(3))
      call fmdpm(1.0d2, mxy(4))
      if (fmcomp(mxy(5), '>=', mxy(3)) .and. fmcomp(mxy(6), '>=', mxy(4))) then
          call fmi2m(1, mxy(5))
          call fmsub(mxy(1), mxy(5), mxy(7))
          call fmmin(mxy(7), mxy(2), mxy(8))
          call fmaddi(mxy(8), -1)
          call fmln(mxy(8), mxy(5))
          call fmmpy(mxy(7), mxy(5), mxy(4))
          call fmsub(mxy(4), mxy(8), mxy(5))
          call fmexp(mxy(5), mxy(10))
          if ((mxy(10)%mp(2) == mexpov .and. mxy(10)%mp(1) > 0) .or.  &
              mxy(10)%mp(2) > mxsave+1) then
              call fmabs(mxy(10), mresult)
              kflag = -5
              return
          endif
      endif
      call fmi2m(1, mxy(5))
      if (fmcomp(mxy(1), '==', mxy(5)) .and. mxy(2)%mp(2) >= 0) then
          if (abs(mxy(2)%mp(2)) < mexpov) then
              call fmeq(mxy(2), mxy(6))
              call fmnegate(mxy(6))
              call fmexp(mxy(6), mxy(7))
              call fmsub(mxy(5), mxy(7), mxy(13))
              if (mxy(13)%mp(2) /= munkno) then
                  call fmeq(mxy(13), mresult)
                  retry = .false.
                  return
              endif
          endif
      endif

!             Determine which method to use.

!             nmethd = 1 means use the convergent series,
!                    = 2 means use the asymptotic series,
!                    = 3 means use the continued fraction expansion.

      nmethd = 1
      call fmi2m(-10000, mxy(8))
      call fmi2m(10000, mxy(9))
      call fmabs(mxy(1), mxy(11))
      call fmabs(mxy(2), mxy(12))
      call fmsub(mxy(12), mxy(11), mxy(10))

!             Check whether the smallest term in the asymptotic series is small enough to give
!             the required accuracy.

      if (kflaga /= 0 .or. kflagx /= 0) then
          call fmdiv(mxy(12), mxy(11), mxy(10))
          call fmi2m(1, mxy(8))
          call fmsub(mxy(8), mxy(10), mxy(9))
          if (mxy(9)%mp(1) < 0) then
              nmethd = 2
          else
              nmethd = 1
          endif
      else
          t1 = fmdplg(a)
          small = t1 - fmdplg(-abs(x)) - (a+abs(x))*log(abs(x))
          tol = -dble(ndig+2)*dlogmb - 12.0d0
          b = 1.0d0
          if (a > abs(x)) b = a - abs(x)
          big = t1 - fmdplg(a-b) - b*log(abs(x))

          if (fmcomp(mxy(10), '<=', mxy(8))) then
              nmethd = 1
          else if (fmcomp(mxy(10), '>=', mxy(9)) .and. mxy(1)%mp(1) > 0 .and.  &
                   mxy(2)%mp(1) > 0) then
              nmethd = 3
              if (small < tol+big) nmethd = 2
          else if (fmcomp(mxy(10), '>=', mxy(9))) then
              nmethd = 3
          else if (mxy(1)%mp(1) > 0 .and. mxy(2)%mp(1) > 0) then
              call fmdp2m(sqrt(dpmax), mxy(8))
              if (fmcomp(mxy(2), '>=', mxy(8))) then
                  kflag = -5
                  call fmoverflow(1, mresult)
                  return
              endif

              c2 = dble(ndsave)*dlogmb
              c1 = c2/10.0d0 + a + 10.0d0
              dt1 = max( 10.0d0 , c2/6.0d0 )
              c2 = max( dt1 , a - 3.5d0*a/(sqrt(a)+1.0d0))
              if (x < c1) then
                  nmethd = 1
              else
                  nmethd = 3
              endif
              if (x > c2) then
                  nmethd = 3
                  if (small < tol+big) nmethd = 2
              endif
          else if (mxy(1)%mp(1) < 0 .and. mxy(2)%mp(1) > 0) then
              tlnb = ndig*dlogmb
              c = 0.75/tlnb**0.35
              d = 0.80*tlnb**0.70
              if (kflaga == 0 .and. kflagx == 0) then
                  t = -a - d/c
                  y = d + c*t/2.0 + (c/2.0)*sqrt(t**2 + t + (2.0/c)**2)
                  if (x > y) then
                      nmethd = 3
                  else
                      nmethd = 1
                  endif
              else
                  call fmdpm(dble(c), mxy(5))
                  call fmmpy(mxy(5), mxy(1), mxy(8))
                  mxy(8)%mp(1) = 1
                  if (fmcomp(mxy(2), '>', mxy(8))) then
                      nmethd = 3
                  else
                      nmethd = 1
                  endif
              endif
          else if (mxy(1)%mp(1) > 0 .and. mxy(2)%mp(1) < 0) then
              call fmdpm(dble(-0.8), mxy(5))
              call fmmpy(mxy(5), mxy(1), mxy(8))
              if (fmcomp(mxy(8), '<', mxy(2))) then
                  nmethd = 1
              else
                  nmethd = 3
              endif
          endif
      endif
      if (ma%mp(1) > 0 .and. mb%mp(1) < 0 .and.  &
          ma%mp(2) > ndig .and. mb%mp(2) > ndig) nmethd = 3

      if (nmethd == 1) then
          call fmigm1_m1(mxy, mresult, n_acc, kxneg, kflagx, kflaga, kflagi, inta, moda2, x, a)
      else if (nmethd == 2) then
          call fmigm1_m2(mxy, mresult, n_acc, kxneg, kflagx, kflaga, kflagi, inta, x, a)
      else if (nmethd == 3) then
          call fmigm1_m3(mxy, mresult, n_acc, kflagx, kflaga, kflagi, inta, moda2, x, a)
      endif

      return
      end subroutine fmigm1_m

      subroutine fmigm1_m1(mxy, mresult, n_acc, kxneg, kflagx, kflaga, kflagi, inta, moda2, x, a)

!  Method 1 for computing igm1(ma, mb).  Use the x**n/Pochhammer(a+1, n) series.

      use fmvals
      implicit none

      type(multi) :: mxy(18), mresult
      integer :: n_acc, kxneg, kflagx, kflaga, kflagi, inta
      double precision :: x, a
      real (kind(1.0d0)) :: moda2
      intent (in) :: kxneg, kflagx, kflaga, kflagi, inta, moda2, x, a
      intent (inout) :: mxy, mresult, n_acc

      double precision :: t1
      real (kind(1.0d0)) :: maxe
      integer :: iextra, int_temp1, j, jextra, k, kflgok, kl, ndig2,  &
                 ndsav1, nmnndg, nmxdif, nterms
      logical, external :: fmcomp
      double precision, external :: fmdplg

!             mxy(13) = mxy(17) + mxy(18) is the current sum.
!             mxy(9) is the current term.
!             mxy(8) is (a+n)/x.
!             mxy(14) is 1/x

      nterms = int(intmax/10)

!             Raise the precision if a is negative and near an integer, to compensate
!             for cancellation when (a+n)/x is near zero.

      if (mxy(1)%mp(1) < 0) then
          call fmnint(mxy(1), mxy(17))
          call fmsub(mxy(1), mxy(17), mxy(14))
          iextra = max(-int(mxy(14)%mp(2)), 0)
          if (abs(mxy(14)%mp(2)) >= mexpov) iextra = 0
          if (iextra > 0) then
              call fmequ_r1(mxy(1), ndig, ndig+iextra)
              call fmequ_r1(mxy(2), ndig, ndig+iextra)
          endif
          ndig = ndig + iextra
          n_acc = nint(ndig*alogm2)
      endif

      jextra = 0

      kl = 1
      do while (kl == 1)
         kl = 0
         call fmi2m(1, mxy(17))
         call fmi2m(0, mxy(18))
         call fmi2m(1, mxy(7))
         call fmadd(mxy(1), mxy(7), mxy(8))
         call fmdiv(mxy(2), mxy(8), mxy(9))
         call fmdiv_r1(mxy(8), mxy(2))
         call fmdiv(mxy(7), mxy(2), mxy(14))
         ndsav1 = ndig
         maxe = 1

!             If a is negative and abs(a) > abs(x), the terms in the series first decrease,
!             then increase, then decrease.  Try to predict the number of extra digits required
!             to keep the precision from prematurely becoming too small.

         kflgok = 1
         if (mxy(1)%mp(1) < 0) then
             if (kflaga == 0) then
                 if (abs(a) > 1.0d3) then
                     call fmigm1_m3(mxy, mresult, n_acc, kflagx, kflaga, kflagi, inta, moda2, x, a)
                     return
                 endif
             else
                 call fmigm1_m3(mxy, mresult, n_acc, kflagx, kflaga, kflagi, inta, moda2, x, a)
                 return
             endif
             kflgok = 0
             call fmabs(mxy(1), mxy(3))
             call fmabs(mxy(2), mxy(4))
             if (fmcomp(mxy(3), '>', mxy(4))) then
                 if (jextra == 0) then
                     if (kflaga == 0 .and. kflagx == 0) then
                         t1 = fmdplg(a+aint(-abs(x)-a)) - fmdplg(a+1.0d0+aint(abs(x)-a))
                         t1 = (t1 + 2.0d0*abs(x)*log(abs(x)+1.0d-10))/dlogmb
                         t1 = max(0.0d0, t1+1.0d0)
                         jextra = t1
                     endif
                 endif

!             If a is negative and abs(a) is much bigger than abs(x), the later increase in
!             the size of the terms can be ignored.

                 if (kflaga == 0 .and. kflagx == 0) then
                     t1 = (aint(x-a)*log(abs(x)+1.0d-10) + fmdplg(a+1.0d0)  &
                          - fmdplg(a+1.0d0+aint(x-a))) / dlogmb
                     if (t1 < -dble(ndig)) kflgok = 1
                 else
                     kflgok = 1
                 endif
             endif
         endif

         nmnndg = ndsav1
         nmxdif = 0

!             Method 1 summation loop.

         n_acc = nint(ndig*alogm2)
         do j = 1, nterms
            ndig = ndsav1
            maxe = max(maxe, mxy(9)%mp(2))
            if (mxy(9)%mp(1) > 0) then
                call fmadd(mxy(17), mxy(9), mxy(16))
                int_temp1 = kflag
                call fmeq(mxy(16), mxy(17))
            else
                call fmadd(mxy(18), mxy(9), mxy(16))
                int_temp1 = kflag
                call fmeq(mxy(16), mxy(18))
            endif
            call fmadd(mxy(17), mxy(18), mxy(13))
            kflag = int_temp1
            if (kflag /= 0 .and. (j > 2 .or. abs(mxy(17)%mp(2)) > mxexp .or.  &
                abs(mxy(18)%mp(2)) > mxexp)) then
                if (kflgok == 0 .and. kflaga == 0 .and. kflagx == 0) then
                    if (dble(j) > x-a) exit
                else
                    exit
                endif
            endif

            call fmcsadd_r1(mxy(8), mxy(14))

            ndig2 = max(ngrd22, ndsav1-int(mxy(13)%mp(2)-mxy(9)%mp(2)))
            ndig = min(ndsav1, ndig2+jextra)
            nmnndg = min(nmnndg, ndig)
            nmxdif = max(nmxdif, ndig-nmnndg)
            call fmcsdiv(mxy(9), mxy(8), mxy(5))
            call fmeq(mxy(5), mxy(9))
            if (j == nterms) then
                call fmunknown(mresult)
                return
            endif
         enddo
         call fmadd(mxy(17), mxy(18), mxy(16))
         call fmcancel(mxy(17), mxy(18), mxy(16), k)
         n_acc = n_acc - k
         call fmeq(mxy(16), mxy(13))

         ndig = ndsav1
         if (nmxdif > jextra+1) then
             jextra = nmxdif
             kl = 1
         endif
      enddo

      call fmabs(mxy(2), mxy(5))
      call fmln(mxy(5), mxy(6))
      call fmmpy(mxy(1), mxy(6), mxy(4))
      call fmsub(mxy(4), mxy(2), mxy(14))
      call fmexp(mxy(14), mxy(15))
      if (mxy(15)%mp(2) == munkno) then
          call fmpwr(mxy(5), mxy(1), mxy(4))
          call fmexp(mxy(2), mxy(6))
          call fmdiv(mxy(4), mxy(6), mxy(15))
      endif
      call fmdiv(mxy(13), mxy(1), mxy(12))
      call fmmpy(mxy(15), mxy(12), mxy(11))
      if (mxy(11)%mp(2) == munkno) then
          call fmln(mxy(13), mxy(5))
          call fmln(mxy(1), mxy(6))
          call fmadd(mxy(14), mxy(5), mxy(4))
          call fmsub(mxy(4), mxy(6), mxy(14))
          call fmexp(mxy(14), mxy(13))
      else
          call fmeq(mxy(11), mxy(13))
      endif
      if (kxneg == 1 .and. moda2 == 1) call fmnegate(mxy(13))

      call fmeq(mxy(13), mresult)

      return
      end subroutine fmigm1_m1

      subroutine fmigm1_m2(mxy, mresult, n_acc, kxneg, kflagx, kflaga, kflagi, inta, x, a)

!  Method 2 for computing igm1(ma, mb).  Use the Pochhammer(a-n, n)/x**n series.

      use fmvals
      implicit none

      type(multi) :: mxy(18), mresult
      integer :: n_acc, kxneg, kflagx, kflaga, kflagi, inta
      double precision :: x, a
      intent (in) :: kxneg, kflagx, kflaga, kflagi, inta, x, a
      intent (inout) :: mxy, mresult, n_acc

      double precision :: bigj, t1
      integer :: iextra, j, jterms, k, less, ndig2, ndsav1, nt, nterms

!             mxy(13) = mxy(17) + mxy(18) is the current sum.
!             mxy(9) is the current term.
!             mxy(8) is (a-n)/x.
!             mxy(14) is -1/x

      nterms = int(intmax/10)

!             Raise the precision if a is positive and near an integer, to compensate for
!             cancellation when (a-n)/x is near zero.

      if (mxy(1)%mp(1) > 0) then
          call fmnint(mxy(1), mxy(13))
          call fmsub(mxy(1), mxy(13), mxy(14))
          iextra = max(-int(mxy(14)%mp(2)), 0)
          if (abs(mxy(14)%mp(2)) >= mexpov) iextra = 0
          if (iextra > 0) then
              call fmequ_r1(mxy(1), ndig, ndig+iextra)
              call fmequ_r1(mxy(2), ndig, ndig+iextra)
          endif
          ndig = ndig + iextra
      endif
      n_acc = nint(ndig*alogm2)

      call fmgam(mxy(1), mxy(15))
      if (kflaga == 0 .and. kflagx == 0) then
          nt = int(((a-1)*log(abs(x)+1.0d-10) - x)/dlogmb)
          less = max(0, int(mxy(15)%mp(2)) - nt - 1)
          if (less > ndig .and. abs(a) < abs(x)) then
              call fmeq(mxy(15), mresult)
              return
          endif
      endif
      if (kflag /= 0) then
          call fmeq(mxy(15), mresult)
          return
      endif
      if (kxneg == 0) then
          call fmln(mxy(2), mxy(14))
          call fmmpy(mxy(1), mxy(14), mxy(5))
          call fmsub(mxy(5), mxy(2), mxy(13))
          call fmsub_r2(mxy(13), mxy(14))
          call fmexp(mxy(14), mxy(9))
      else
          call fmi2m(1, mxy(5))
          call fmsub(mxy(1), mxy(5), mxy(13))
          call fmpwr(mxy(2), mxy(13), mxy(14))
          call fmexp(mxy(2), mxy(12))
          call fmdiv(mxy(14), mxy(12), mxy(9))
      endif

!             Here mxy(9) is x**(a-1)/exp(x).

      call fmnegate(mxy(9))
      call fmeq(mxy(15), mxy(13))
      if (mxy(15)%mp(1) > 0) then
          call fmeq(mxy(15), mxy(17))
          call fmi2m(0, mxy(18))
      else
          call fmeq(mxy(15), mxy(18))
          call fmi2m(0, mxy(17))
      endif
      call fmdiv(mxy(1), mxy(2), mxy(8))
      call fmi2m(1, mxy(5))
      call fmdiv(mxy(5), mxy(2), mxy(14))
      call fmnegate(mxy(14))
      ndsav1 = ndig

!             Disable ndig reduction until the terms in the sum begin to decrease in size.

      bigj = 0
      if (kflaga == 0 .and. kflagx == 0) bigj = abs(a) - abs(x)
      jterms = nterms
      if (kflagi == 0 .and. inta > 0) then
          jterms = inta
      else if (kflaga == 0 .and. kflagx == 0) then
          t1 = a + abs(x)
          if (t1 > 0 .and. t1 < dble(nterms)) jterms = int(t1) + 2
      endif

!             Method 2 summation loop.

      n_acc = nint(ndig*alogm2)
      do j = 1, jterms
         ndig = ndsav1
         call fmcsadd_r1(mxy(13), mxy(9))
         if (mxy(9)%mp(1) > 0) then
             call fmadd_r2(mxy(9), mxy(17))
         else
             call fmadd_r2(mxy(9), mxy(18))
         endif
         k = max(mxy(17)%mp(2), mxy(18)%mp(2)) - ndig
         if (mxy(9)%mp(2) < k) kflag = 1
         if (kflag /= 0 .and. j > 1) then
             exit
         endif
         call fmcsadd_r1(mxy(8), mxy(14))
         if (dble(j) >= bigj) then
             call fmadd(mxy(17), mxy(18), mxy(13))
             ndig2 = max(ngrd22, ndsav1-int(mxy(13)%mp(2)-mxy(9)%mp(2)))
             ndig = min(ndsav1, ndig2)
         endif
         call fmcsmpy_r1(mxy(9), mxy(8))
         if (j == nterms) then
             call fmunknown(mresult)
             return
         endif
      enddo

      ndig = ndsav1
      call fmadd(mxy(17), mxy(18), mxy(13))
      call fmcancel(mxy(17), mxy(18), mxy(13), k)
      n_acc = n_acc - k
      call fmeq(mxy(13), mresult)

      return
      end subroutine fmigm1_m2

      subroutine fmigm1_m3(mxy, mresult, n_acc, kflagx, kflaga, kflagi, inta, moda2, x, a)

!  Method 3 for computing igm1(ma, mb).Use the continued fraction expansion.

      use fmvals
      implicit none

      type(multi) :: mxy(18), mresult
      integer :: n_acc, kflagx, kflaga, kflagi, inta
      double precision :: x, a
      real (kind(1.0d0)) :: moda2
      intent (in) :: kflagx, kflaga, kflagi, inta, moda2, x, a
      intent (inout) :: mxy, mresult, n_acc

      double precision :: yt
      integer :: j, jextra, k, kflag1, less, ndsav1, ndsav2, nt, nterms


!             mxy(14) = mxy(17) + mxy(18) is the current approximation.
!             mxy(13) is the term in the sum, s(k).
!             mxy(11), mxy(12) are the latest denominators, q(k-1) and q(k).

      call fmgam(mxy(1), mxy(15))
      n_acc = nint(ndig*alogm2)
      ndsav1 = ndig
      if (kflaga == 0 .and. kflagx == 0) then
          yt = min(dble(huge(1))/11, aint(((a-1)*log(abs(x)+1.0d-10) - x)/dlogmb))
          nt = huge(1)/10
          nt = min(dble(nt), yt)
          less = max(0, int(mxy(15)%mp(2)) - nt - 1)
          if (less > ndig) then
              call fmeq(mxy(15), mresult)
              return
          endif
          ndig = min(ndsav1, max(ngrd22, ndig-less))
      endif
      jextra = max(1, int(5.76/alogmb + 1.0))
      if (ndig+jextra > ndsav1) then
          call fmequ_r1(mxy(1), ndsav1, ndsav1+jextra)
          call fmequ_r1(mxy(2), ndsav1, ndsav1+jextra)
      endif
      ndig = ndig + jextra
      call fmequ(mxy(1), mxy(8), ndsav1, ndig)
      call fmnegate(mxy(8))
      call fmi2m(1, mxy(11))
      call fmequ(mxy(2), mxy(12), ndsav1, ndig)
      call fmi2m(1, mxy(5))
      call fmdiv(mxy(5), mxy(12), mxy(13))
      if (mxy(13)%mp(1) > 0) then
          call fmeq(mxy(13), mxy(17))
          call fmi2m(0, mxy(18))
      else
          call fmeq(mxy(13), mxy(18))
          call fmi2m(0, mxy(17))
      endif

      nterms = int(intmax/10)
      n_acc = nint(ndig*alogm2)

!             Method 3 continued fraction loop.

      ndsav2 = ndig
      n_acc = nint(ndig*alogm2)
      do j = 1, min(nterms, inta-1)
         call fmaddi(mxy(8), 1)
         call fmeq(mxy(8), mxy(10))
         call fmcsmpy_r1(mxy(10), mxy(11))
         call fmadd(mxy(12), mxy(10), mxy(9))
         call fmeq(mxy(10), mxy(6))
         call fmcsmpy_r1(mxy(6), mxy(13))
         call fmcsdiv(mxy(6), mxy(9), mxy(13))
         call fmnegate(mxy(13))
         ndig = ndsav2
         if (mxy(13)%mp(1) > 0) then
             call fmadd_r1(mxy(17), mxy(13))
         else
             call fmadd_r1(mxy(18), mxy(13))
         endif
         kflag1 = kflag
         call fmadd(mxy(17), mxy(18), mxy(14))
         call fmeq(mxy(12), mxy(11))
         call fmeq(mxy(9), mxy(12))
         ndig = min(ndsav2, max(ngrd22, ndsav2-int(mxy(14)%mp(2)-mxy(13)%mp(2))))
         if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         call fmcsmpyi(mxy(11), j, mxy(10))
         call fmeq(mxy(2), mxy(6))
         call fmcsmpy_r1(mxy(6), mxy(12))
         call fmadd(mxy(6), mxy(10), mxy(9))
         call fmeq(mxy(10), mxy(6))
         call fmcsmpy_r1(mxy(6), mxy(13))
         call fmcsdiv(mxy(6), mxy(9), mxy(13))
         call fmnegate(mxy(13))
         ndig = ndsav2
         if (mxy(13)%mp(1) > 0) then
             call fmadd_r1(mxy(17), mxy(13))
         else
             call fmadd_r1(mxy(18), mxy(13))
         endif

!             Check for convergence.

         if (kflag1 == 1 .and. kflag == 1 .and. j > 2) then
             exit
         endif
         call fmadd(mxy(17), mxy(18), mxy(14))
         call fmeq(mxy(12), mxy(11))
         call fmeq(mxy(9), mxy(12))
         ndig = min(ndsav2, max(ngrd22, ndsav2-int(mxy(14)%mp(2)-mxy(13)%mp(2))))
         if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         if (j == nterms) then
             call fmunknown(mresult)
             return
         endif
      enddo

      ndig = ndsav2
      call fmequ_r1(mxy(14), ndig, ndsav1)
      call fmequ_r1(mxy(17), ndig, ndsav1)
      call fmequ_r1(mxy(18), ndig, ndsav1)
      ndig = ndsav1
      if (mxy(2)%mp(1) > 0) then
          call fmln(mxy(2), mxy(5))
          call fmmpy(mxy(1), mxy(5), mxy(4))
          call fmsub(mxy(4), mxy(2), mxy(5))
          call fmexp(mxy(5), mxy(12))
      else if (kflagi == 0) then
          call fmexp(mxy(2), mxy(13))
          call fmipwr(mxy(2), inta, mxy(5))
          call fmdiv(mxy(5), mxy(13), mxy(12))
      else
          call fmabs(mxy(2), mxy(5))
          call fmln(mxy(5), mxy(6))
          call fmmpy(mxy(1), mxy(6), mxy(4))
          call fmsub(mxy(4), mxy(2), mxy(5))
          call fmexp(mxy(5), mxy(12))
          if (moda2 == 1) call fmnegate(mxy(12))
      endif

      if (mxy(12)%mp(2) /= mexpov) then
          call fmmpy_r2(mxy(12), mxy(17))
          call fmmpy_r2(mxy(12), mxy(18))
      else if (mxy(12)%mp(2)+mxy(14)%mp(2) >= mxexp2/2) then
          call fmeq(mxy(12), mxy(13))
          if (mxy(14)%mp(1) < 0) call fmnegate(mxy(13))
      else
          call fmmpy_r2(mxy(12), mxy(17))
          call fmmpy_r2(mxy(12), mxy(18))
      endif
      n_acc = nint(ndig*alogm2)
      if (mxy(15)%mp(1) > 0) then
          call fmsub(mxy(15), mxy(18), mxy(16))
          call fmmpyi(mxy(17), -1, mxy(18))
          call fmeq(mxy(16), mxy(17))
      else
          call fmsub(mxy(15), mxy(17), mxy(16))
          call fmmpyi(mxy(18), -1, mxy(17))
          call fmeq(mxy(16), mxy(18))
      endif
      call fmadd(mxy(17), mxy(18), mxy(13))
      call fmcancel(mxy(17), mxy(18), mxy(13), k)
      n_acc = n_acc - k
      call fmeq(mxy(13), mresult)

      return
      end subroutine fmigm1_m3

      subroutine fmigm1_sc(ma, mb, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = igm1(ma, mb).

!  kresult = 1 is returned if a special case gives the value of igm1(ma, mb).

      use fmvals
      implicit none

      type(multi) :: ma, mb, mxy(18), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j, k, krsave, nds
      double precision :: xe, ye
      type(multi), save :: malocal, mblocal
      logical, external :: fmcomp

      kresult = 0

      namest(ncall) = 'FMIGM1   '
      j = ndig
      ndig = ndsave
      call fmntr_inp2(ma, mb)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)
      call fmequ(mb, mblocal, ndsave, ndig)

      call fmint(malocal, mxy(1))
      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          kresult = 1
      else if (mblocal%mp(2) == munkno .and. mblocal%mp(5) >= 0) then
          kresult = 1
      else if (mblocal%mp(1) < 0 .and. fmcomp(malocal, '/=', mxy(1))) then
          kresult = 1
      else if (malocal%mp(3) == 0) then
          kresult = 1
      else if (malocal%mp(1) < 0 .and. fmcomp(malocal, '==', mxy(1))) then
          kresult = 1
      endif
      if (kresult == 1) then
          call fmunknown(mresult)
          return
      endif

      if (mblocal%mp(2) == mexpun) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          krsave = kround
          kround = 1
          nds = ndig
          ndig = ndsave
          call fmpwr(mblocal, malocal, mxy(3))
          call fmdiv(mxy(3), malocal, mxy(4))
          call fmi2m(1, mxy(1))
          kround = krsave
          if (fmcomp(mxy(3), '==', mxy(1)) .and. kround /= 1) then
              call fmtiny(mxy(2))
              call fmsub(mxy(4), mxy(2), mxy(3))
          else
              call fmeq(mxy(4), mxy(3))
          endif
          ntrace = j
          kwarn = k
          if (mxy(3)%mp(2) /= munkno) then
              call fmeq(mxy(3), mresult)
              kresult = 1
              return
          endif
          ndig = nds
      endif

      if (mb%mp(3) == 0 .and. ma%mp(3) /= 0 .and. ma%mp(1) > 0) then
          call fmi2m(0, mresult)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      call fmovun_xe(malocal, xe)
      call fmovun_xe(mblocal, ye)
      if (kround /= 1 .and. (xe < -ndsave .or. ye < -ndsave)) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          nds = ndig
          krsave = kround
          kround = 1
          ndig = ndig + ngrd52
          call fmequ(malocal, mxy(1), nds, ndig)
          call fmequ(mblocal, mxy(2), nds, ndig)
          call fmi2m(1, mxy(3))
          call fmadd(mxy(1), mxy(3), mxy(4))
          if (mxy(1)%mp(3) /= 0 .and. mxy(4)%mp(3) /= 0) then
              call fmdiv(mxy(2), mxy(4), mxy(6))
              call fmmpy(mxy(6), mxy(1), mxy(5))
              call fmovun_xe(mxy(3), xe)
              call fmovun_xe(mxy(5), ye)
              if (xe - ye > ndsave) then
                  call fmpwr(mxy(2), mxy(1), mxy(6))
                  call fmdiv(mxy(6), mxy(1), mxy(7))
                  call fmequ(mxy(7), mxy(6), ndig, nds)
                  call fmequ(mxy(6), mxy(8), nds, ndig)
                  call fmsub(mxy(7), mxy(8), mxy(6))
                  if (abs(mxy(7)%mp(2)) >= mexpov) then
                      call fmeq(mxy(7), mresult)
                  else if (mxy(6)%mp(3) == 0) then
                      call fmmpy(mxy(5), mxy(7), mxy(8))
                      call fmequ(mxy(7), mxy(9), ndig, nds)
                      call fmequ(mxy(8), mxy(6), ndig, nds)
                      ndig = nds
                      kround = krsave
                      call fmsub(mxy(9), mxy(6), mresult)
                      if (mresult%mp(2) == munkno) then
                          call fmi2m(2, mxy(9))
                          call fmmod(malocal, mxy(9), mxy(8))
                          if (mblocal%mp(1) < 0 .and. mxy(8)%mp(3) /= 0) then
                              if (krsave ==  2) kround = -1
                              if (krsave == -1) kround =  2
                          endif
                          call fmi2m(1, mxy(8))
                          call fmsub(mxy(8), mxy(5), mxy(6))
                          call fmmpy(mxy(7), mxy(6), mresult)
                      endif
                  else
                      kround = krsave
                      call fmmpy(mxy(3), mxy(7), mxy(6))
                      call fmmpy(mxy(5), mxy(7), mxy(8))
                      call fmsub_r2(mxy(6), mxy(8))
                      call fmeq(mxy(8), mresult)
                  endif
                  ntrace = j
                  kwarn = k
                  call fmequ_r1(mresult, ndig, nds)
                  ndig = nds
                  kround = krsave
                  kresult = 1
                  return
              endif
              call fmovun_xe(malocal, xe)
              if (xe < -ndsave) then
                  call fmdiv(mxy(3), mxy(1), mxy(4))
                  call fmequ(mxy(4), mxy(6), ndig, nds)
                  call fmequ(mxy(6), mxy(5), nds, ndig)
                  call fmsub(mxy(4), mxy(5), mxy(6))
                  if (mxy(6)%mp(3) == 0) then
                      call fmi2m(0, mxy(5))
                      call fmsub(mxy(5), mxy(2), mxy(6))
                      call fmei(mxy(6), mxy(7))
                      call fmln(mxy(2), mxy(8))
                      call fmsub(mxy(7), mxy(8), mxy(9))
                      call fmeulr(mxy(10))
                      call fmsub(mxy(9), mxy(10), mxy(11))
                      call fmpwr(mxy(2), mxy(1), mxy(5))
                      call fmmpy(mxy(5), mxy(11), mxy(12))
                      call fmadd(mxy(8), mxy(12), mxy(13))
                      call fmequ(mxy(4), mxy(6), ndig, nds)
                      call fmequ(mxy(13), mxy(7), ndig, nds)
                      ndig = nds
                      kround = krsave
                      call fmadd(mxy(6), mxy(7), mresult)
                      ntrace = j
                      kwarn = k
                      kresult = 1
                      return
                  endif
              endif
          endif
          kflag = 0
          ntrace = j
          kwarn = k
          ndig = nds
          kround = krsave
      endif

      return
      end subroutine fmigm1_sc

      subroutine fmigm2(ma, mb, mc)

!  mc = incomplete gamma(ma, mb)

!  Integral from mb to infinity of e**(-t) * t**(ma-1)  dt.

!  This is (upper case) Gamma(a, x).   Domain:  ma: all reals,  mb >= 0.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      real (kind(1.0d0)) :: mxsave
      integer :: inta, kmeth4, kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(20), mresult, mretry

      call fmalloc(mc, ndig+2)
      call fmenter2(ma, mb, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmigm2_sc(ma, mb, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mc, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      kmeth4 = 0
      n_acc = nint(ndig*alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmigm2_m(ma, mb, mxy, mresult, ndsave, retry, n_acc, mxsave, inta, kmeth4)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)
                 if (kmeth4 == 1) then
                     call fmi2m(inta, mxy(1))
                 endif
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mc, kovun, mxsave, ndsave)

      return
      end subroutine fmigm2

      subroutine fmigm2_m(ma, mb, mxy, mresult, ndsave, retry, n_acc, mxsave, inta, kmeth4)

!  Method selection for computing igm2(ma, mb).

      use fmvals
      implicit none

      type(multi) :: ma, mb, mxy(20), mresult
      integer :: ndsave, n_acc, inta, kmeth4
      real (kind(1.0d0)) :: mxsave
      logical :: retry
      intent (in) :: ma, mb, ndsave, mxsave
      intent (inout) :: mxy, mresult, retry, n_acc, inta, kmeth4

      double precision :: a, b, big, c1, c2, small, tol, t1, x, xe, ye, yf
      real (kind(1.0d0)) :: moda2
      integer :: iextra, intg, kabigr, kflaga, kflagi, kflagx, kwrnsv, kxneg, nd1, nmethd, nterms
      logical, external :: fmcomp
      double precision, external :: fmdplg

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, ndig)
      call fmequ(mb, mxy(2), ndsave, ndig)
      n_acc = nint(ndig*alogm2)
      nterms = int(intmax/10)

!             a, x are double precision approximations to the two arguments to this function.
!             inta = a if a is a small integer.  It is used to limit the number of terms used
!                    in the asymptotic series and in the continued fraction expansion.

      inta = nterms
      kwrnsv = kwarn
      kwarn = 0
      call fmm2i(mxy(1), intg)
      kflagi = kflag
      if (kflag == 0) inta = intg
      call fmm2dp(mxy(1), a)
      kflaga = kflag
      call fmovun_xe(mxy(1), xe)
      if (kflag /= 0 .and. xe < 0) then
          a = 1.0d0/dpmax
          if (mxy(1)%mp(1) < 0) a = -a
          kflaga = 0
      endif
      call fmm2dp(mxy(2), x)
      kflagx = kflag
      call fmovun_xe(mxy(2), xe)
      if (kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax
          if (mxy(2)%mp(1) < 0) x = -x
          kflagx = 0
      endif
      kwarn = kwrnsv

!             If a or x is large in magnitude use more guard digits.

      nd1 = max(int(mxy(1)%mp(2)), int(mxy(2)%mp(2)))
      nd1 = max(nd1, 0)
      iextra = min(nd1 , int(1.0+alogmx/alogmb))
      if (mxy(1)%mp(2) >= mexpov .or. mxy(2)%mp(2) >= mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(1), ndig, ndig+iextra)
          call fmequ_r1(mxy(2), ndig, ndig+iextra)
      endif
      ndig = ndig + iextra
      n_acc = nint(ndig*alogm2)

!             kxneg = 1 if x is negative and a is a positive integer.

      kxneg = 0

!             moda2 = mod(a, 2) when kxneg is 1.

      moda2 = 0

!             Check for special cases.

      if (mxy(2)%mp(3) == 0) then
          if (mxy(1)%mp(1) < 0 .or. mxy(1)%mp(3) == 0) then
              call fmunknown(mresult)
              kflag = -4
              retry = .false.
              return
          else
              call fmgam(mxy(1), mxy(18))
              call fmeq(mxy(18), mresult)
              return
          endif
      endif
      if (mxy(1)%mp(2) == mexpov .or. mxy(2)%mp(2) == mexpov) then
          call fmabs(mxy(1), mxy(3))
          call fmabs(mxy(2), mxy(4))
          if (mxy(1)%mp(2) == mexpov .and. mxy(1)%mp(1) < 0 .and.  &
              mxy(2)%mp(1) > 0 .and. mxy(2)%mp(2) < 1) then
              call fmgam(mxy(3), mxy(16))
          else if (fmcomp(mxy(3), '>', mxy(4))) then
              call fmgam(mxy(3), mxy(16))
              if (ma%mp(1) < 0) then
                  call fmi2m(1, mxy(5))
                  call fmdiv_r2(mxy(5), mxy(16))
              endif
          else if (fmcomp(mxy(3), '<', mxy(4))) then
              call fmi2m(1, mxy(5))
              call fmsub(mxy(1), mxy(5), mxy(6))
              call fmovun_xexf(mxy(2), ye, yf)
              ye = ye*dlogmb + log(yf)
              call fmdp2m(ye, mxy(7))
              call fmmpy(mxy(6), mxy(7), mxy(8))
              call fmsub(mxy(8), mxy(2), mxy(9))
              call fmexp(mxy(9), mxy(16))
          else
              call fmgam(mxy(3), mxy(16))
              call fmdivi_r1(mxy(16), 2)
              if (ma%mp(1) < 0) then
                  call fmi2m(1, mxy(5))
                  call fmdiv_r2(mxy(5), mxy(16))
              endif
          endif
          call fmeq(mxy(16), mresult)
          if (abs(mxy(16)%mp(2)) >= mexpov) then
              return
          endif
          retry = .false.
          return
      endif

      if (mxy(1)%mp(2) == mexpun .or. mxy(2)%mp(2) == mexpun) then
          if (mxy(1)%mp(2) == mexpun .and. mxy(2)%mp(2) == mexpun) then
              call fmunknown(mresult)
              kflag = -4
              retry = .false.
              return
          endif
          if (mxy(2)%mp(2) == mexpun .and. mxy(2)%mp(1) > 0 .and.  &
              mxy(2)%mp(3) /= 0                                  ) then
              if (mxy(1)%mp(2) >= 1 .and. mxy(1)%mp(1) > 0) then
                  call fmgam(mxy(1), mxy(18))
                  call fmeq(mxy(18), mresult)
                  return
              else if (mxy(1)%mp(2) >= 1 .and. mxy(1)%mp(1) < 0) then
                  call fmoverflow(1, mresult)
                  kflag = -5
                  retry = .false.
                  return
              else
                  call fmunknown(mresult)
                  kflag = -4
                  retry = .false.
                  return
              endif
          endif
      endif
      if (mxy(2)%mp(1) < 0) then
          call fmint(mxy(1), mxy(15))
          if (fmcomp(mxy(1), '==', mxy(15)) .and. mxy(1)%mp(1)*mxy(1)%mp(3) > 0) then
              kxneg = 1
              call fmi2m(2, mxy(12))
              call fmmod(mxy(15), mxy(12), mxy(7))
              call fmeq(mxy(7), mxy(12))
              if (mxy(12)%mp(3) /= 0) moda2 = 1
          else
              call fmunknown(mresult)
              kflag = -4
              retry = .false.
              return
          endif
      endif
      if (mxy(2)%mp(2) == mexpun) then
          if (mxy(1)%mp(1) < 0 .and. mxy(1)%mp(2) >= 1) then
              call fmoverflow(1, mxy(16))
              kflag = -5
          else
              call fmgam(mxy(1), mxy(18))
              call fmeq(mxy(18), mresult)
          endif
          return
      endif
      if (mxy(1)%mp(2) == mexpun) then
          call fmi2m(0, mxy(1))
      endif
      call fmmax(mxy(1), mxy(2), mxy(7))
      call fmmin(mxy(1), mxy(2), mxy(8))
      call fmdpm(1.0d6, mxy(3))
      call fmdpm(1.0d2, mxy(4))
      if (fmcomp(mxy(7), '>=', mxy(3)) .and. fmcomp(mxy(8), '>=', mxy(4))) then
          call fmi2m(1, mxy(7))
          call fmsub(mxy(1), mxy(7), mxy(9))
          call fmmax(mxy(9), mxy(2), mxy(11))
          call fmaddi(mxy(11), 1)
          call fmln(mxy(11), mxy(7))
          call fmmpy(mxy(9), mxy(7), mxy(4))
          call fmsub(mxy(4), mxy(11), mxy(7))
          call fmexp(mxy(7), mxy(13))
          if ((mxy(13)%mp(2) == mexpov .and. mxy(13)%mp(1) > 0 .and.  &
              mxy(13)%mp(3) /= 0) .or. mxy(13)%mp(2) > mxsave+1) then
              call fmeq(mxy(13), mresult)
              kflag = -5
              return
          endif
      endif

!             If a is 1 the result is exp(-x).

      call fmi2m(1, mxy(7))
      if (fmcomp(mxy(1), '==', mxy(7))) then
          if (abs(mxy(2)%mp(2)) < mexpov) then
              call fmeq(mxy(2), mxy(8))
              call fmnegate(mxy(8))
              call fmexp(mxy(8), mxy(16))
              if (mxy(16)%mp(2) /= munkno) then
                  call fmeq(mxy(16), mresult)
                  retry = .false.
                  return
              endif
          endif
      endif

!             If a is negative and x is small, the result is -x**a / a.

      if (mxy(1)%mp(1) == -1 .and. mxy(2)%mp(2) < -ndsave) then
          call fmpwr(mxy(2), mxy(1), mxy(8))
          call fmdiv(mxy(8), mxy(1), mxy(16))
          if (mxy(16)%mp(2) == munkno) then
              call fmln(mxy(2), mxy(8))
              call fmmpy(mxy(8), mxy(1), mxy(9))
              call fmabs(mxy(1), mxy(10))
              call fmln(mxy(10), mxy(11))
              call fmsub(mxy(9), mxy(11), mxy(10))
              call fmexp(mxy(10), mxy(16))
              call fmnegate(mxy(16))
          endif
          call fmnegate(mxy(16))
          if (mxy(16)%mp(2) /= munkno) then
              call fmeq(mxy(16), mresult)
              retry = .false.
              return
          endif
      endif
      if (mxy(1)%mp(1) == -1 .and. mxy(2)%mp(1) == 1 .and.  &
          mxy(1)%mp(2) > ndig .and.                         &
          mxy(1)%mp(2) - mxy(2)%mp(2) > ndig) then
          call fmi2m(1, mxy(3))
          call fmsub(mxy(3), mxy(1), mxy(4))
          call fmadd(mxy(4), mxy(2), mxy(6))
          call fmdiv(mxy(3), mxy(6), mxy(5))
          call fmsqr(mxy(1), mxy(4))
          call fmmpyi(mxy(2), 2, mxy(6))
          call fmaddi(mxy(6), 3)
          call fmmpy(mxy(1), mxy(6), mxy(7))
          call fmsub(mxy(4), mxy(7), mxy(8))
          call fmdiv(mxy(5), mxy(8), mxy(9))
          call fmsub(mxy(1), mxy(3), mxy(10))
          call fmmpy(mxy(10), mxy(9), mxy(11))
          if (mxy(11)%mp(2) /= munkno) then
              call fmadd(mxy(5), mxy(11), mxy(12))
          else
              call fmeq(mxy(5), mxy(12))
          endif
          call fmpwr(mxy(2), mxy(1), mxy(13))
          if (mxy(1)%mp(2) == mexpov .or. mxy(1)%mp(2) == mexpun) then
              call fmeq(mxy(13), mxy(16))
          else
              call fmexp(mxy(2), mxy(14))
              call fmmpy(mxy(12), mxy(13), mxy(15))
              call fmdiv(mxy(15), mxy(14), mxy(16))
          endif
          if (mxy(16)%mp(2) /= munkno) then
              call fmeq(mxy(16), mresult)
              retry = .false.
              return
          endif
      endif

!             Determine which method to use.

!             nmethd = 1 means use the convergent series,
!                    = 2 means use the asymptotic series,
!                    = 3 means use the continued fraction expansion,
!                    = 4 means use an o(a**2) formula.

      call fmi2m(-10000, mxy(11))
      call fmi2m(10000, mxy(12))
      call fmabs(mxy(1), mxy(14))
      call fmabs(mxy(2), mxy(15))
      call fmsub(mxy(15), mxy(14), mxy(13))
      kabigr = 1
      if (mxy(13)%mp(3) >= 0 .and. mxy(13)%mp(1) > 0) kabigr = 0

!             Check whether the smallest term in the asymptotic series is small enough to give
!             the required accuracy.

      if (kflaga /= 0 .or. kflagx /= 0) then
          call fmdiv(mxy(14), mxy(15), mxy(10))
          call fmi2m(1, mxy(8))
          call fmsub(mxy(8), mxy(10), mxy(9))
          if (mxy(9)%mp(1) < 0) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          t1 = fmdplg(a)
          small = t1 - fmdplg(-abs(x)) - (a+abs(x))*log(abs(x))
          tol = -dble(ndig+2)*dlogmb - 12.0d0
          b = 1.0d0
          if (a > abs(x)) b = a - abs(x)
          big = t1 - fmdplg(a-b) - b*log(abs(x))

          nmethd = 0
          if (fmcomp(mxy(13), '<=', mxy(11))) then
              if (mxy(1)%mp(1) > 0 .and. mxy(1)%mp(3) /= 0) then
                  nmethd = 1
              else
                  nmethd = 3
              endif
          else if (fmcomp(mxy(13), '>=', mxy(12)) .and. mxy(1)%mp(1) > 0 .and.  &
                   mxy(1)%mp(3) > 0 .and. mxy(2)%mp(1) > 0 .and.                &
                   mxy(2)%mp(3) > 0) then
              nmethd = 3
              if (small < tol+big) nmethd = 2
          else if (fmcomp(mxy(13), '>=', mxy(12))) then
              nmethd = 3
          else if (mxy(1)%mp(1) > 0 .and. mxy(2)%mp(1) > 0 .and.  &
                   mxy(2)%mp(3) > 0) then
              call fmdp2m(sqrt(dpmax), mxy(11))
              if (fmcomp(mxy(2), '>=', mxy(11))) then
                  kflag = -5
                  call fmoverflow(1, mresult)
                  return
              endif

              if (mxy(1)%mp(1) > 0 .and. mxy(1)%mp(3) /= 0) then
                  c2 = dble(ndsave)*dlogmb/6.0d0
                  c1 = max( 10.0d0 , c2 )
                  c1 = max( c1 , a )
                  c2 = max( 10.0d0 , c2 )
                  c2 = max( c2 , a - 6.5d0*a/(sqrt(a)+1.0d0) )
              else
                  c1 = max( 15.0d0 , dble(ndsave)*dlogmb/5.0d0 )
                  c2 = c1
              endif
              if (x < min(c1, c2)) then
                  if (-2*mxy(1)%mp(2) > ndig .or. mxy(1)%mp(3) == 0) then
                      nmethd = 4
                  else
                      nmethd = 1
                  endif
              else if (x > c2) then
                  if (small < tol+big) nmethd = 2
              endif
              if (nmethd == 0 .and. x > c1) nmethd = 3
              if (nmethd == 0) nmethd = 1
          else if (mxy(1)%mp(1) < 0 .and. mxy(2)%mp(1) > 0 .and.  &
              mxy(2)%mp(3) > 0) then
              call fmdp2m(sqrt(dpmax), mxy(11))
              if (fmcomp(mxy(2), '>=', mxy(11))) then
                  kflag = -6
                  call fmunderflow(1, mresult)
                  return
              endif

              c1 = max( 10.0d0 , dble(ndsave)*dlogmb/7.0d0 )
              c2 = -2.0d0*a
              if (x < c1) then
                  if (-2*mxy(1)%mp(2) > ndig) then
                      nmethd = 4
                  else
                      nmethd = 1
                  endif
              else if (x > c2) then
                  t1 = fmdplg(a)
                  small = t1 - fmdplg(-abs(x)) - (a+abs(x))*log(abs(x))
                  tol = -dble(ndig+2)*dlogmb - 12.0d0
                  b = 1.0d0
                  if (a > abs(x)) b = a - abs(x)
                  big = t1 - fmdplg(a-b) - b*log(abs(x))
                  if (small < tol+big) nmethd = 2
              endif
              if (nmethd == 0 .and. x > c1) nmethd = 3
              if (nmethd == 0) nmethd = 1
          else if (mxy(1)%mp(1) > 0 .and. mxy(1)%mp(3) > 0 .and.  &
              mxy(2)%mp(1) < 0) then
              call fmeq(mxy(2), mxy(11))
              call fmnegate(mxy(11))
              call fmmpyi(mxy(1), 2, mxy(12))
              if (fmcomp(mxy(11), '<', mxy(1))) then
                  nmethd = 1
              else if (fmcomp(mxy(11), '<', mxy(12))) then
                  nmethd = 3
              else
                  nmethd = 3
                  if (small < tol+big) nmethd = 2
              endif
          endif
      endif

      if (nmethd == 1) then
          call fmigm2_m1(mxy, mresult, ndsave, n_acc, kxneg, kflagx, kflaga, kflagi,  &
                         kmeth4, inta, moda2, kabigr, x, a)
      else if (nmethd == 2) then
          call fmigm2_m2(mxy, mresult, n_acc, kxneg, kflagx, kflaga, kflagi, inta, moda2, x, a)
      else if (nmethd == 3) then
          call fmigm2_m3(mxy, mresult, n_acc, kxneg, kflagx, kflaga, inta, moda2, x, a)
      else if (nmethd == 4) then
          call fmigm2_m4(mxy, mresult, n_acc, kflagx, kflaga, kflagi, kmeth4, inta, x, a)
      endif

      return
      end subroutine fmigm2_m

      subroutine fmigm2_m1(mxy, mresult, ndsave, n_acc, kxneg, kflagx, kflaga, kflagi,  &
                           kmeth4, inta, moda2, kabigr, x, a)

!  Method 1 for computing igm2(ma, mb).  Use the x**n/Pochhammer(a+1, n) series.

      use fmvals
      implicit none

      type(multi) :: mxy(20), mresult
      integer :: ndsave, n_acc, kxneg, kflagx, kflaga, kflagi, kmeth4, inta, kabigr
      double precision :: x, a
      real (kind(1.0d0)) :: moda2
      intent (in) :: ndsave, kxneg, kflagx, kflaga, kflagi, inta, moda2, kabigr, x
      intent (inout) :: mxy, mresult, n_acc, kmeth4, a

      double precision :: c1, t1
      real (kind(1.0d0)) :: maxm09
      integer :: iextra, j, jextra, k, kflgok, ndig2, ndsav1, nmnndg, nterms
      logical, external :: fmcomp
      double precision, external :: fmdplg

!             Method 1.  Use the x**n/Pochhammer(a+1, n) series.

!             mxy(16) = mxy(19) + mxy(20) is the current sum.
!             mxy(12) is the current term.
!             mxy(11) is (a+n)/x.
!             mxy(17) is 1/x

!             Raise the precision if a is negative and near an integer, to compensate for
!             cancellation when (a+n)/x is near zero.
!             Raise the precision if a is positive and near zero, since there will be cancellation
!             in subtracting the sum from Gamma(a).
!             If a is a negative integer use method 3 or 4.

      iextra = 0
      if (mxy(1)%mp(1) < 0) then
          if (kflaga == 0) then
              if (abs(a) > 1.0d3) then
                  call fmigm2_m3(mxy, mresult, n_acc, kxneg, kflagx, kflaga, inta, moda2, x, a)
                  return
              endif
          else
              call fmigm2_m3(mxy, mresult, n_acc, kxneg, kflagx, kflaga, inta, moda2, x, a)
              return
          endif
          call fmnint(mxy(1), mxy(16))
          if (fmcomp(mxy(16), '==', mxy(1))) then
              if (kflagi == 0) then
                  if (kflagx /= 0) then
                      call fmigm2_m3(mxy, mresult, n_acc, kxneg, kflagx, kflaga, inta, moda2, x, a)
                      return
                  else
                      if (abs(x) <= 20.0d0) then
                          c1 = 0.7d0*(dble(ndsave)*dlogmb*(20.0d0-x))**0.75d0
                          if (abs(a) > c1) then
                              call fmigm2_m3(mxy, mresult, n_acc, kxneg, kflagx, kflaga,  &
                                             inta, moda2, x, a)
                              return
                          else
                              call fmigm2_m4(mxy, mresult, n_acc, kflagx, kflaga, kflagi, kmeth4,  &
                                             inta, x, a)
                              return
                          endif
                      else
                          call fmigm2_m3(mxy, mresult, n_acc, kxneg, kflagx, kflaga,  &
                                         inta, moda2, x, a)
                          return
                      endif
                  endif
              else
                  call fmigm2_m3(mxy, mresult, n_acc, kxneg, kflagx, kflaga, inta, moda2, x, a)
                  return
              endif
          endif
          call fmsub(mxy(1), mxy(16), mxy(17))
          iextra = max(-2*int(mxy(17)%mp(2)), -int(mxy(1)%mp(2))+1)
          iextra = max(iextra, 0)
          if (abs(mxy(17)%mp(2)) >= mexpov .or. abs(mxy(1)%mp(2)) >= mexpov)  &
              iextra = 0
      else
          iextra = max(-int(mxy(1)%mp(2))+1, 0)
          if (abs(mxy(1)%mp(2)) >= mexpov) iextra = 0
      endif

!             Raise the precision further as x increases in magnitude.

      if (kflagx == 0 .and. kflaga == 0) then
          t1 = (0.92d0 + (x-a) + (a-0.5d0)*log(abs(a)+1.0d-10) -  &
               (a-1.0d0)*log(abs(x)+1.0d-10))/dlogmb
          if (t1 > 0 .and. abs(x) > 1.0d0) then
              if (a < 0.0d0 .or. x >= a) then
                  iextra = iextra + max(0, int(t1)+1)
              endif
          endif
      endif

      if (iextra > 0) then
          call fmequ_r1(mxy(1), ndig, ndig+iextra)
          call fmequ_r1(mxy(2), ndig, ndig+iextra)
      endif
      ndig = ndig + iextra
      n_acc = nint(ndig*alogm2)

      jextra = 0

      if (kabigr == 1) then
          call fmgam(mxy(1), mxy(18))
          if (kflag /= 0) then
              call fmeq(mxy(18), mresult)
              return
          endif
          call fmeq(mxy(18), mxy(16))
          if (mxy(18)%mp(1) > 0) then
              call fmeq(mxy(18), mxy(19))
              call fmi2m(0, mxy(20))
          else
              call fmeq(mxy(18), mxy(20))
              call fmi2m(0, mxy(19))
          endif
      else
          call fmi2m(0, mxy(16))
          call fmi2m(0, mxy(19))
          call fmi2m(0, mxy(20))
      endif

      maxm09 = mxy(16)%mp(2)

      call fmabs(mxy(2), mxy(17))
      call fmln(mxy(17), mxy(6))
      call fmmpy_r2(mxy(1), mxy(6))
      call fmsub_r1(mxy(6), mxy(2))
      call fmexp(mxy(6), mxy(18))
      call fmdiv(mxy(18), mxy(1), mxy(12))
      if (mxy(12)%mp(2) == munkno) then
          call fmln(mxy(1), mxy(15))
          call fmsub_r1(mxy(6), mxy(15))
          call fmexp(mxy(6), mxy(12))
      endif
      if (kxneg == 1 .and. moda2 == 1) call fmnegate(mxy(12))

      call fmnegate(mxy(12))
      call fmadd_r1(mxy(16), mxy(12))
      if (mxy(12)%mp(1) > 0) then
          call fmadd_r1(mxy(19), mxy(12))
      else
          call fmadd_r1(mxy(20), mxy(12))
      endif
      maxm09 = max(maxm09, mxy(16)%mp(2))

      call fmi2m(1, mxy(9))
      call fmadd(mxy(1), mxy(9), mxy(11))
      call fmdiv_r1(mxy(12), mxy(11))
      call fmmpy_r1(mxy(12), mxy(2))
      call fmdiv_r1(mxy(11), mxy(2))
      call fmdiv(mxy(9), mxy(2), mxy(17))
      ndsav1 = ndig

!             If a is negative and abs(a) > abs(x), the terms in the series first decrease,
!             then increase, then decrease. Try to predict the number of extra digits required to
!             keep the precision from prematurely becoming too small.

      kflgok = 1
      if (mxy(1)%mp(1) < 0) then
          kflgok = 0
          call fmabs(mxy(1), mxy(3))
          call fmabs(mxy(2), mxy(4))
          if (fmcomp(mxy(3), '>', mxy(4))) then
              if (jextra == 0) then
                  if (kflaga == 0 .and. kflagx == 0) then
                      t1 = fmdplg(a+aint(-abs(x)-a)) - fmdplg(a+1.0d0+aint(abs(x)-a))
                      t1 = (t1 + 2.0d0*abs(x)*log(abs(x)+1.0d-10))/dlogmb
                      t1 = max(0.0d0, t1+1.0d0)
                      jextra = t1
                  endif
              endif

!             If a is negative and abs(a) is much bigger than abs(x), then the later increase
!             in the size of the terms can be ignored.

              if (kflaga == 0 .and. kflagx == 0) then
                  t1 = (aint(x-a)*log(abs(x)+1.0d-10) + fmdplg(a+1.0d0)  &
                       - fmdplg(a+1.0d0+aint(x-a))) / dlogmb
                  if (t1 < -dble(ndig)) kflgok = 1
              else
                  kflgok = 1
              endif
          endif
      endif

      nmnndg = ndsav1

!             Method 1 summation loop.

      nterms = int(intmax/10)
      do j = 1, nterms
         ndig = ndsav1
         if (mxy(12)%mp(1) > 0) then
             call fmadd_r1(mxy(19), mxy(12))
         else
             call fmadd_r1(mxy(20), mxy(12))
         endif
         call fmcsadd_r1(mxy(16), mxy(12))
         maxm09 = max(maxm09, mxy(16)%mp(2))
         if (kflag /= 0) then
             if (kflgok == 0 .and. kflaga == 0 .and. kflagx == 0) then
                 if (dble(j) > x-a) exit
             else
                 exit
             endif
         endif

         call fmcsadd_r1(mxy(11), mxy(17))

         ndig2 = max(ngrd22, ndsav1-int(mxy(16)%mp(2)-mxy(12)%mp(2)))
         ndig = min(ndsav1, ndig2+jextra)
         nmnndg = min(nmnndg, ndig)
         call fmcsdiv(mxy(12), mxy(11), mxy(5))
         call fmeq(mxy(5), mxy(12))
         if (j == nterms) then
             call fmunknown(mresult)
             return
         endif
      enddo

      ndig = ndsav1
      if (kabigr == 0) then
          call fmeq(mxy(16), mxy(17))
          call fmgam(mxy(1), mxy(18))
          if (kflag /= 0) then
              call fmeq(mxy(18), mresult)
              return
          endif
          call fmadd(mxy(18), mxy(17), mxy(16))
          if (mxy(9)%mp(1) > 0) then
              call fmadd_r1(mxy(19), mxy(18))
          else
              call fmadd_r1(mxy(20), mxy(18))
          endif

      endif

!             If too much cancellation occurred, raise the precision and do the calculation again.

      call fmadd(mxy(19), mxy(20), mxy(16))
      call fmcancel(mxy(19), mxy(20), mxy(16), k)
      n_acc = n_acc - k


      call fmeq(mxy(16), mresult)

      return
      end subroutine fmigm2_m1

      subroutine fmigm2_m2(mxy, mresult, n_acc, kxneg, kflagx, kflaga, kflagi, inta, moda2, x, a)

!  Method 2 for computing igm2(ma, mb).  Use the Pochhammer(a-n, n)/x**n series.

      use fmvals
      implicit none

      type(multi) :: mxy(20), mresult
      integer :: n_acc, kxneg, kflagx, kflaga, kflagi, inta
      real (kind(1.0d0)) :: moda2
      double precision :: x, a
      intent (in) :: kxneg, kflagx, kflaga, kflagi, inta, moda2, x, a
      intent (inout) :: mxy, mresult, n_acc

      double precision :: bigj, t1
      integer :: j, jterms, k, ndig2, ndsav1, nterms

!             Method 2.  Use the Pochhammer(a-n, n)/x**n series.

!             mxy(16) is the current sum.
!             mxy(12) is the current term.
!             mxy(11) is (a-n)/x.
!             mxy(17) is -1/x

      nterms = int(intmax/10)
      call fmabs(mxy(2), mxy(17))
      call fmln(mxy(17), mxy(6))
      call fmmpy(mxy(1), mxy(6), mxy(16))
      call fmsub_r2(mxy(16), mxy(6))
      call fmsub_r1(mxy(6), mxy(2))
      call fmexp(mxy(6), mxy(12))
      if (kxneg == 1 .and. moda2 == 0) call fmnegate(mxy(12))
      if (abs(mxy(12)%mp(2)) >= mxexp2) then
          call fmeq(mxy(12), mresult)
          return
      endif

!             Here mxy(12) is x**(a-1)/exp(x).

      call fmi2m(0, mxy(16))
      call fmi2m(0, mxy(19))
      call fmi2m(0, mxy(20))
      call fmeq(mxy(1), mxy(11))
      call fmdiv_r1(mxy(11), mxy(2))
      call fmi2m(1, mxy(9))
      call fmdiv(mxy(9), mxy(2), mxy(17))
      call fmnegate(mxy(17))
      ndsav1 = ndig

!             Disable ndig reduction until the terms in the sum begin to decrease in size.

      bigj = 0
      if (kflaga == 0 .and. kflagx == 0) bigj = abs(a) - abs(x)
      jterms = nterms
      if (kflagi == 0 .and. inta > 0) then
          jterms = inta
      else if (kflagx == 0) then
          if (kflaga == 0) then
              t1 = a + abs(x)
              if (t1 > 0 .and. t1 < dble(nterms)) jterms = int(t1) + 2
          else if (mxy(1)%mp(2) < 0) then
              t1 = abs(x)
              if (t1 > 0 .and. t1 < dble(nterms)) jterms = int(t1) + 2
          endif
      endif

!             Method 2 summation loop.

      do j = 1, jterms
         ndig = ndsav1
         if (mxy(12)%mp(1) > 0) then
             call fmadd_r1(mxy(19), mxy(12))
         else
             call fmadd_r1(mxy(20), mxy(12))
         endif
         call fmcsadd_r1(mxy(16), mxy(12))
         if (kflag /= 0 .and. j > 1) then
             exit
         endif
         call fmcsadd_r1(mxy(11), mxy(17))
         if (real(j) >= bigj) then
             ndig2 = max(ngrd22, ndsav1-int(mxy(16)%mp(2)-mxy(12)%mp(2)))
             ndig = min(ndsav1, ndig2)
         endif
         call fmcsmpy_r1(mxy(12), mxy(11))
         if (j == nterms) then
             call fmunknown(mresult)
             return
         endif
      enddo

      ndig = ndsav1
      call fmadd(mxy(19), mxy(20), mxy(16))
      call fmcancel(mxy(19), mxy(20), mxy(16), k)
      n_acc = n_acc - k

      call fmeq(mxy(16), mresult)

      return
      end subroutine fmigm2_m2

      subroutine fmigm2_m3(mxy, mresult, n_acc, kxneg, kflagx, kflaga, inta, moda2, x, a)

!  Method 3 for computing igm2(ma, mb).Use the continued fraction expansion.

      use fmvals
      implicit none

      type(multi) :: mxy(20), mresult
      integer :: n_acc, kxneg, kflagx, kflaga, inta
      double precision :: x, a
      real (kind(1.0d0)) :: moda2
      intent (in) :: kxneg, kflagx, kflaga, inta, moda2, x, a
      intent (inout) :: mxy, mresult, n_acc

      double precision :: t1
      integer :: j, jextra, jterms, k, kflag1, ndsav1, ndsav2, nterms

!             Method 3.  Use the continued fraction expansion.

!             mxy(17) = mxy(19) + mxy(20) is the current approximation.
!             mxy(16) is the term in the sum, s(k).
!             mxy(14), mxy(15) are the latest denominators, q(k-1) and q(k).

!             Raise the precision so that convergence of the continued fraction expansion
!             is easier to detect.

      jextra = max(1, int(5.76/alogmb + 1.0))

!             Raise the precision further for small x if a is positive.

      if (kflagx == 0 .and. kflaga == 0) then
          t1 = (0.92d0 + (abs(x)-a) + (a-0.5d0)*log(abs(a)+1.0d-10) -  &
               (a-1.0d0)*log(abs(x)+1.0d-10))/dlogmb
          if (t1 > 0.0d0 .and. a > 0.0d0) then
              if (abs(x) < a) then
                  jextra = jextra + max(0, int(1.5d0*t1)+1)
              endif
          endif
      endif
      ndsav1 = ndig
      if (ndig+jextra > ndsav1) then
          call fmequ_r1(mxy(1), ndsav1, ndsav1+jextra)
          call fmequ_r1(mxy(2), ndsav1, ndsav1+jextra)
      endif
      ndig = ndig + jextra
      n_acc = nint(ndig*alogm2)
      call fmequ(mxy(1), mxy(11), ndsav1, ndig)
      call fmnegate(mxy(11))
      call fmi2m(1, mxy(14))
      call fmequ(mxy(2), mxy(15), ndsav1, ndig)
      call fmi2m(1, mxy(7))
      call fmdiv(mxy(7), mxy(15), mxy(16))
      call fmeq(mxy(16), mxy(17))
      if (mxy(17)%mp(1) > 0) then
          call fmeq(mxy(17), mxy(19))
          call fmi2m(0, mxy(20))
      else
          call fmeq(mxy(17), mxy(20))
          call fmi2m(0, mxy(19))
      endif

      nterms = int(intmax/10)
      jterms = nterms
      if (inta > 0) jterms = inta - 1

!             Method 3 continued fraction loop.

      ndsav2 = ndig
      do j = 1, jterms
         call fmaddi(mxy(11), 1)
         call fmeq(mxy(11), mxy(13))
         call fmcsmpy_r1(mxy(13), mxy(14))
         call fmadd(mxy(15), mxy(13), mxy(12))
         call fmeq(mxy(13), mxy(8))
         call fmcsmpy_r1(mxy(8), mxy(16))
         call fmcsdiv(mxy(8), mxy(12), mxy(16))
         call fmnegate(mxy(16))
         ndig = ndsav2
         if (mxy(16)%mp(1) > 0) then
             call fmadd_r1(mxy(19), mxy(16))
         else
             call fmadd_r1(mxy(20), mxy(16))
         endif
         call fmcsadd_r1(mxy(17), mxy(16))
         kflag1 = kflag
         call fmeq(mxy(15), mxy(14))
         call fmeq(mxy(12), mxy(15))
         ndig = min(ndsav2, max(ngrd22, ndsav2-int(mxy(17)%mp(2)-mxy(16)%mp(2))))
         if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         call fmcsmpyi(mxy(14), j, mxy(13))
         call fmeq(mxy(2), mxy(8))
         call fmcsmpy_r1(mxy(8), mxy(15))
         call fmadd(mxy(8), mxy(13), mxy(12))
         call fmeq(mxy(13), mxy(8))
         call fmcsmpy_r1(mxy(8), mxy(16))
         call fmcsdiv(mxy(8), mxy(12), mxy(16))
         call fmnegate(mxy(16))
         ndig = ndsav2
         if (mxy(16)%mp(1) > 0) then
             call fmadd_r1(mxy(19), mxy(16))
         else
             call fmadd_r1(mxy(20), mxy(16))
         endif
         call fmcsadd_r1(mxy(17), mxy(16))

!             Check for convergence.

         if (kflag1 == 1 .and. kflag == 1) then
             exit
         endif
         call fmeq(mxy(15), mxy(14))
         call fmeq(mxy(12), mxy(15))
         ndig = min(ndsav2, max(ngrd22, ndsav2-int(mxy(17)%mp(2)-mxy(16)%mp(2))))
         if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         if (j == nterms) then
             call fmunknown(mresult)
             return
         endif
      enddo

      ndig = ndsav2
      call fmadd(mxy(19), mxy(20), mxy(17))
      call fmcancel(mxy(19), mxy(20), mxy(17), k)
      n_acc = n_acc - k
      call fmequ_r1(mxy(17), ndig, ndsav1)
      ndig = ndsav1
      call fmabs(mxy(2), mxy(15))
      call fmln(mxy(15), mxy(6))
      call fmmpy_r2(mxy(1), mxy(6))
      call fmsub_r1(mxy(6), mxy(2))
      call fmexp(mxy(6), mxy(5))
      if (kxneg == 1 .and. moda2 == 1) call fmnegate(mxy(5))
      if (abs(mxy(5)%mp(2)) >= mxexp2) then
          call fmeq(mxy(5), mresult)
          if (mxy(17)%mp(1) < 0) call fmnegate(mresult)
          return
      endif

      call fmmpy(mxy(5), mxy(17), mxy(16))
       call fmeq(mxy(16), mresult)

      return
      end subroutine fmigm2_m3

      subroutine fmigm2_m4(mxy, mresult, n_acc, kflagx, kflaga, kflagi, kmeth4, inta, x, a)

!  Method 4 for computing igm2(ma, mb).Use the continued fraction expansion.

      use fmvals
      implicit none

      type(multi) :: mxy(20), mresult
      integer :: n_acc, kflagx, kflaga, kflagi, kmeth4, inta
      double precision :: x, a
      intent (in) :: kflagx, kflaga, kflagi, inta, x
      intent (inout) :: mxy, mresult, n_acc, kmeth4, a

      double precision :: t1, t2
      integer :: iextra, j, jr, n, ndig2, ndsav1, nterms
      logical, external :: fmcomp

!             Method 4.  Use the o(a**2) formula when a is small.

!             mxy(16) is the current term.
!             mxy(17) is the current sum.

!             Raise the precision if x is larger than a in magnitude.
!             The terms initially increase in size, and the final sum is small.

      iextra = 0
      nterms = int(intmax/10)

!             If a is a negative integer, replace it by zero and later use a recurrence to recover
!             the original function value.

      if (kflagi == 0 .and. inta < 0) then
          call fmi2m(0, mxy(1))
          a = 0.0d0
          kmeth4 = 1
      endif

      if (kflagx == 0) then
          if (kflaga == 0) then
              t1 = abs(x) - abs(a)
          else
              t1 = abs(x)
          endif
          if (t1 > 0) then
              t2 = (t1 + log(t1))/dlogmb
              if (t2 > dble(mxexp2/10)) t2 = dble(mxexp2/10)
              iextra = int(max(0.0d0, t2))
          endif
          t1 = abs(x)+1.0d-10
          t2 = (t1 - 0.5d0*log(6.2831853d0*t1))/dlogmb
          if (t2 > dble(mxexp2/10)) t2 = dble(mxexp2/10)
          iextra = iextra + int(max(0.0d0, t2))
      endif

      if (iextra > 0) then
          call fmequ_r1(mxy(1), ndig, ndig+iextra)
          call fmequ_r1(mxy(2), ndig, ndig+iextra)
      endif
      ndig = ndig + iextra
      n_acc = nint(ndig*alogm2)

      call fmeulr(mxy(17))
      call fmeq(mxy(17), mxy(18))
      mxy(17)%mp(1) = -1
      call fmabs(mxy(2), mxy(16))
      call fmln(mxy(16), mxy(15))
      call fmsub_r1(mxy(17), mxy(15))
      if (mxy(1)%mp(3) /= 0 .and. mxy(1)%mp(2) >= -ndig-1) then
          call fmsqr(mxy(15), mxy(7))
          call fmmpy(mxy(7), mxy(1), mxy(4))
          call fmdivi(mxy(4), 2, mxy(16))
          call fmsub_r1(mxy(17), mxy(16))

          call fmsqr(mxy(18), mxy(14))
          call fmpi(mxy(13))
          call fmsqr(mxy(13), mxy(7))
          call fmdivi(mxy(7), 6, mxy(13))
          call fmadd(mxy(13), mxy(14), mxy(7))
          call fmmpy(mxy(7), mxy(1), mxy(4))
          call fmdivi(mxy(4), 2, mxy(14))
          call fmadd_r1(mxy(17), mxy(14))
      endif

      ndsav1 = ndig
      call fmi2m(1, mxy(14))
      jr = kround
      kround = 1
      call fmadd(mxy(1), mxy(14), mxy(13))
      kround = jr
      if (fmcomp(mxy(14), '==', mxy(13))) then
          call fmi2m(-1, mxy(16))
          do j = 1, nterms
             ndig2 = max(ngrd22, ndsav1-int(mxy(17)%mp(2)-mxy(16)%mp(2)))
             ndig = min(ndsav1, ndig2)
             call fmmpy_r1(mxy(16), mxy(2))
             call fmnegate(mxy(16))
             call fmdivi_r1(mxy(16), j)
             call fmdivi(mxy(16), j, mxy(15))
             ndig = ndsav1
             call fmadd_r1(mxy(17), mxy(15))
             if (kflag /= 0) exit
             if (j == nterms) then
                 call fmunknown(mresult)
                 return
             endif
          enddo
      else
          call fmpwr(mxy(2), mxy(1), mxy(16))
          call fmnegate(mxy(16))
          call fmeq(mxy(1), mxy(18))
          do j = 1, nterms
             ndig2 = max(ngrd22, ndsav1-int(mxy(17)%mp(2)-mxy(16)%mp(2)))
             ndig = min(ndsav1, ndig2)
             call fmmpy_r1(mxy(16), mxy(2))
             call fmnegate(mxy(16))
             call fmdivi_r1(mxy(16), j)
             ndig = ndsav1
             call fmadd_r1(mxy(18), mxy(14))
             ndig = min(ndsav1, ndig2)
             call fmdiv(mxy(16), mxy(18), mxy(15))
             ndig = ndsav1
             call fmadd_r1(mxy(17), mxy(15))
             if (kflag /= 0) exit
             if (j == nterms) then
                 call fmunknown(mresult)
                 return
             endif
          enddo
      endif
      call fmeq(mxy(17), mxy(16))

!             Use the recurrence relation if a was a negative integer.

      if (kflagi == 0 .and. inta < 0) then
          n = -inta
          call fmi2m(1, mxy(17))
          call fmdiv_r1(mxy(17), mxy(2))
          call fmeq(mxy(17), mxy(15))
          call fmeq(mxy(17), mxy(14))
          do j = 1, n-1
             call fmmpyi_r1(mxy(15), j)
             call fmmpy_r1(mxy(15), mxy(14))
             call fmnegate(mxy(15))
             call fmadd_r1(mxy(17), mxy(15))
          enddo
          call fmexp(mxy(2), mxy(14))
          call fmdiv_r1(mxy(17), mxy(14))
          call fmsub_r1(mxy(16), mxy(17))
          call fmfcti(n, mxy(14))
          call fmdiv_r1(mxy(16), mxy(14))
          if (mod(n, 2) == 1) call fmnegate(mxy(16))
      endif

      call fmeq(mxy(16), mresult)

      return
      end subroutine fmigm2_m4

      subroutine fmigm2_sc(ma, mb, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = igm2(ma, mb).

!  kresult = 1 is returned if a special case gives the value of igm2(ma, mb).

      use fmvals
      implicit none

      type(multi) :: ma, mb, mxy(20), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j, k, kl, krsave
      double precision :: xe, ye
      type(multi), save :: malocal, mblocal
      logical, external :: fmcomp

      kresult = 0

      namest(ncall) = 'FMIGM2   '
      j = ndig
      ndig = ndsave
      call fmntr_inp2(ma, mb)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)
      call fmequ(mb, mblocal, ndsave, ndig)

      j = ntrace
      ntrace = 0
      k = kwarn
      kwarn = 0
      call fmint(malocal, mxy(1))
      ntrace = j
      kwarn = k
      if ((malocal%mp(2) == munkno .and. malocal%mp(5) >= 0)   .or.      &
          (mblocal%mp(2) == munkno .and. mblocal%mp(5) >= 0)   .or.      &
          (mblocal%mp(1) < 0 .and. fmcomp(malocal, '/=', mxy(1)))  .or.  &
          (mblocal%mp(1) < 0 .and. malocal%mp(3) == 0)   .or.            &
          (malocal%mp(1) < 0 .and. mblocal%mp(1) < 0)) then
          ntrace = j
          kwarn = k
          call fmunknown(mresult)
          kflag = -4
          kresult = 1
          return
      endif
      if (abs(malocal%mp(2)) >= mexpov .or. abs(mblocal%mp(2)) >= mexpov) then
          ntrace = j
          kwarn = k
          if (mblocal%mp(3) == 0 .and. malocal%mp(1) > 0) then
              call fmgam(malocal, mresult)
          else if ((malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) .or.  &
                   (mblocal%mp(2) == munkno .and. mblocal%mp(5) >= 0)) then
              call fmunknown(mresult)
          else
              call fmovun_xe(malocal, xe)
              call fmovun_xe(mblocal, ye)
              if ((ye-xe >= ndig .and. ye > ndsave) .or.  &
                  (mblocal%mp(2) == mexpov .and. fmcomp(mblocal, '>', malocal))) then
                  call fmabs(mblocal, mxy(1))
                  call fmln(mxy(1), mxy(3))
                  call fmi2m(1, mxy(2))
                  call fmadd_r2(malocal, mxy(2))
                  call fmmpy_r2(mxy(2), mxy(3))
                  call fmsub_r1(mxy(3), mblocal)
                  call fmexp(mxy(3), mresult)
              else if ((xe > ndig .and. xe-ye >= ndig) .or.  &
                       (malocal%mp(2) == mexpov .and. fmcomp(malocal, '>', mblocal))) then
                  if (malocal%mp(1) > 0) then
                      call fmabs(malocal, mxy(1))
                      call fmln(mxy(1), mxy(3))
                      call fmaddi(mxy(3), -1)
                      call fmmpy_r2(malocal, mxy(3))
                      call fmexp(mxy(3), mxy(2))
                      call fmpi(mxy(1))
                      call fmmpyi_r1(mxy(1), 2)
                      call fmdiv_r1(mxy(1), malocal)
                      if (mxy(1)%mp(1) < 0) call fmnegate(mxy(1))
                      call fmsqrt_r1(mxy(1))
                      call fmmpy(mxy(1), mxy(2), mresult)
                  else
                      call fmpwr(mblocal, malocal, mxy(1))
                      call fmdiv(mxy(1), malocal, mresult)
                      call fmnegate(mresult)
                  endif
              else if (xe < -ndsave .and. ye < -ndsave) then
                  ndig = ndig + ngrd22
                  call fmequ(mblocal, mxy(2), ndig-ngrd22, ndig)
                  call fmabs(mxy(2), mxy(1))
                  call fmln(mxy(1), mxy(2))
                  call fmnegate(mxy(2))
                  call fmeulr(mxy(3))
                  call fmsub_r2(mxy(2), mxy(3))
                  call fmeq(mxy(3), mresult)
              else if (xe < -ndsave .and. ye >= 0) then

                  ndig = ndig + ngrd22
                  call fmequ(mblocal, mxy(1), ndig-ngrd22, ndig)
                  call fmnegate(mxy(1))
                  call fmei(mxy(1), mxy(2))
                  call fmnegate(mxy(2))
                  call fmabs(mxy(1), mxy(3))
                  call fmln(mxy(3), mxy(1))
                  call fmequ(malocal, mxy(3), ndig-ngrd22, ndig)
                  call fmmpy_r2(mxy(1), mxy(3))
                  call fmmpy_r2(mxy(2), mxy(3))
                  call fmadd_r2(mxy(2), mxy(3))
                  if (mxy(3)%mp(5) >= 0) then
                      call fmequ(malocal, mxy(3), ndig-ngrd22, ndig)
                      call fmmpy_r2(mxy(1), mxy(3))
                      call fmaddi(mxy(3), 1)
                      call fmmpy_r2(mxy(2), mxy(3))
                  endif
                  call fmeq(mxy(3), mresult)
              else if (xe >= 0 .and. ye < -ndsave .and. malocal%mp(3) /= 0) then
                  ndig = ndig + ngrd22
                  call fmequ(malocal, mxy(3), ndig-ngrd22, ndig)
                  call fmequ(mblocal, mxy(4), ndig-ngrd22, ndig)
                  call fmpwr(mxy(4), mxy(3), mxy(1))
                  call fmdiv_r1(mxy(1), mxy(3))
                  call fmgam(mxy(3), mxy(2))
                  call fmsub(mxy(2), mxy(1), mxy(3))
                  call fmeq(mxy(3), mresult)
              else
                  call fmunknown(mresult)
              endif
          endif
          kresult = 1
          return
      endif


!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      call fmovun_xe(mblocal, ye)

      if (kround /= 1 .and. mblocal%mp(1) > 0 .and. malocal%mp(3) /= 0 .and.   &
          ye < -ndsave - ngrd52) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          krsave = kround
          kround = 1
          ndig = ndig + ngrd52
          call fmequ(malocal, mxy(1), ndsave, ndig)
          call fmequ(mblocal, mxy(2), ndsave, ndig)
          call fmgam(mxy(1), mxy(3))
          if (mxy(3)%mp(2) /= munkno) then
              call fmigm1(mxy(1), mxy(2), mxy(4))
              kround = krsave
              call fmsub(mxy(3), mxy(4), mxy(5))
              call fmovun_xe(mxy(3), xe)
              call fmovun_xe(mxy(5), ye)
              if (mxy(5)%mp(3) == 0 .or. ye < xe-ngrd52) then
                  kflag = 0
                  ntrace = j
                  kwarn = k
                  ndig = ndig - ngrd52
                  return
              endif
          else
              call fmm2i(mxy(1), kl)
              call fmipwr(mxy(2), kl, mxy(4))
              if (mxy(4)%mp(2) /= mexpov) then
                  call fmdivi_r1(mxy(4), -kl)
              endif
              call fmtiny(mxy(5))
              kround = krsave
              call fmsub_r2(mxy(4), mxy(5))
          endif
          kflag = 0
          ntrace = j
          kwarn = k
          call fmeq(mxy(5), mresult)
          kresult = 1
          return
      endif

      return
      end subroutine fmigm2_sc

      subroutine fminp(line, ma, la, lb)

!  Convert an array of characters to floating point multiple precision format.

!  line is an a1 character array of length lb to be converted to fm format and returned in ma.
!  Convert the section line(la:lb).

!  The input number may be in integer or any real format.

!  keswch = 1  causes input to fminp with no digits before the exponent letter to be treated as if
!              there were a leading '1'.  This is sometimes better for interactive input:
!              'e7' converts to 10.0**7.
!         = 0  causes a leading zero to be assumed.  This gives compatibility with Fortran:
!              'e7' converts to 0.0.

!  In exponential format the 'e' may also be 'd', 'q', or 'm'.

!  So that fminp will convert any output from fmout, line is tested to see if the input is one of
!  the special symbols +overflow, -overflow, +underflow, -underflow, or unknown.
!  For user input the abbreviations ovfl, unfl, unkn may be used.

      use fmvals
      implicit none

      integer :: la, lb
      character :: line(lb)
      type(multi) :: ma
      intent (in) :: line, la, lb
      intent (inout) :: ma

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kpower, kresult, krnd, kwrnsave, ndsave, ntrsave
      type(multi), save :: mxy(5), mresult
      logical :: retry

      call fmalloc(ma, ndig+2)
      call fmenter0(kovun, mxsave, ndsave)
      ntrsave = ntrace
      ntrace = 0
      kflag = 0
      kwrnsave = kwarn
      kwarn = 0
      call fminp_sc(line, la, lb, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, ma, kovun, mxsave, ndsave)
          kflag = 0
          ntrace = ntrsave
          kwarn = kwrnsave
          return
      endif

      krnd = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fminp_m1(line, la, lb, mxy, mresult, ma, krnd, kpower, ndsave)
         if (mbase == 10**kpower) exit
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      if (krnd == 0) then
          call fmexit1(mresult, ma, kovun, mxsave, ndsave)
      else
          call fmexit1(mresult, mxy(1), kovun, mxsave, ndsave)
      endif
      ntrace = ntrsave
      kwarn = kwrnsave

      return
      end subroutine fminp

      subroutine fminp2(mxy, line, kstart, kstop, kpower, mbsave)

!  Internal routine for input conversion for a power of ten mbase.

      use fmvals
      implicit none

      type(multi) :: mxy(5)
      integer :: kstart, kstop, kpower
      real (kind(1.0d0)) :: mbsave
      character :: line(kstop)
      intent (in) :: line, kstart, kstop, kpower, mbsave
      intent (inout) :: mxy

      integer :: j, jstate, k, kdflag, kexp, kf1, kf1dig, kf2, kf2dig, kf2pt, knzdig, kpt,  &
                  kshift, ksign, ksignx, ktype, kval, lnzd, nf1, nf2
      double precision :: d, dlog_10, dlog_mbsave, f1, f2, fexp, fp

!  Simulate a finite-state automaton to scan the input line and build the number.
!  States of the machine:

!  1.  Initial entry to the subroutine
!  2.  Sign of the number
!  3.  Scanning digits before a decimal point
!  4.  Decimal point
!  5.  Scanning digits after a decimal point
!  6.  e, d, q, or m -- precision indicator before the exponent
!  7.  Sign of the exponent
!  8.  Scanning exponent
!  9.  Syntax error

!  Character types recognized by the machine:

!  1.  Sign (+,-)
!  2.  Numeral (0,1,...,9)
!  3.  Decimal point (.)
!  4.  Precision indicator (e,d,q,m)
!  5.  Illegal character for number

!  All blanks are ignored.  The analysis of the number proceeds as follows:  If the simulated
!  machine is in state jstate and a character of type jtype is encountered the new state of the
!  machine is given by jtrans(jstate,jtype).

!  In this initialization, the array is loaded by columns.

!          State   1  2  3  4  5  6  7  8

      integer :: jtrans(8, 4) = reshape(  (/    &
                   2, 9, 7, 7, 7, 7, 9, 9,      &
                   3, 3, 3, 5, 5, 8, 8, 8,      &
                   4, 4, 4, 9, 9, 9, 9, 9,      &
                   6, 6, 6, 6, 6, 9, 9, 9   /)  &
        , (/ 8, 4 /) )

      jstate = 1
      kdflag = 0
      ksign = 1
      ksignx = 1
      kf1 = 0
      knzdig = 0
      lnzd = 0
      kf1dig = 0
      kf2 = 0
      kf2dig = 0
      kf2pt = 2
      kexp = 0
      nf1 = 0
      nf2 = 0
      f1 = 0
      f2 = 0
      fexp = 0
      fp = 1
      dlog_10 = log(10.0d0)
      dlog_mbsave = log(dble(mbsave))

!             Scan the number.

      do j = kstart, kstop
         if (line(j) == ' ') cycle
         kpt = ichar(line(j))
         if (kpt < lhash1 .or. kpt > lhash2) then
             write (kw,                                                         &
                "(/' Error in input conversion.'/"                          //  &
                "' ICHAR function was out of range for the current', "      //  &
                "' dimensions.'/' ICHAR(''', A, ''') gave the value ', "    //  &
                "I12, ', which is outside the currently'/' dimensioned', "  //  &
                "' bounds of (', I5, ':', I5, ') for variables KHASHT ', "  //  &
                "'and KHASHV.'/' Re-define the two parameters ', "          //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain', "   //  &
                "' all possible output values from ICHAR.'//)"                  &
                   ) line(j), kpt, lhash1, lhash2
             ktype = 5
             kval  = 0
         else
             ktype = khasht(kpt)
             kval  = khashv(kpt)
         endif

         if (ktype >= 5) then

!                  Error in converting the number.

             call fmi2m2(0, mxy(5))
             mxy(5)%mp(2) = munkno
             mxy(5)%mp(3) = 1
             mxy(5)%mp(1) = 1
             kflag = -7
             return
         endif

         jstate = jtrans(jstate, ktype)

         select case (jstate)

!             State 2.  Sign of the number.

         case (2)
             ksign = kval

!             State 3.  Digits before a decimal point.

         case (3)
             kdflag = 1
             kf1 = 10*kf1 + kval
             if (f1 <= huge(f1)/11) then
                 f1 = 10 * f1 + kval
             else
                 nf1 = nf1 + 1
             endif
             if (kval > 0) lnzd = 1
             if (kval > 0 .or. knzdig /= 0) then
                 knzdig = 1
                 kf1dig = kf1dig + 1
             endif
             if (kf1dig == kpower) then
                 mxy(2)%mp(2) = mxy(2)%mp(2) + 1
                 k = mxy(2)%mp(2)
                 if (k < ndig) then
                     mxy(2)%mp(k+2) = kf1
                 endif
                 kf1 = 0
                 kf1dig = 0
             endif

!             State 4.  Decimal point

         case (4)
             cycle

!             State 5.  Digits after a decimal point.

         case (5)
             kdflag = 1
             if (kval == 0 .and. fp == 1.0d0) then
                 nf2 = nf2 + 1
             else
                 if (fp > tiny(fp)*11) then
                     fp = fp / 10.0d0
                     f2 = f2 + fp * kval
                 endif
             endif
             if (kval > 0) lnzd = 1
             if (kf2pt > ndig+1) cycle
             kf2 = 10*kf2 + kval
             kf2dig = kf2dig + 1
             if (kf2dig == kpower) then
                 mxy(3)%mp(kf2pt+1) = kf2
                 if (kf2 == 0 .and. kf2pt == 2) then
                     mxy(3)%mp(2) = mxy(3)%mp(2) - 1
                 else
                     kf2pt = kf2pt + 1
                 endif
                 kf2 = 0
                 kf2dig = 0
             endif

!             State 6.  Precision indicator.

         case (6)
             if (kdflag == 0 .and. keswch == 1) then
                 lnzd = 1
                 call fmi2m2(1, mxy(2))
                 kf1 = 1
                 f1 = 1
             endif

!             State 7.  Sign of the exponent.

         case (7)
             ksignx = kval

!             State 8.  Digits of the exponent.

         case (8)
             if (lnzd == 0) then
                 call fmi2m2(0, mxy(5))
                 return
             endif

!                  Check for overflow or underflow.

             if (fexp >= huge(fexp)/11) then
                 if (huge(mbase)/mexpov > 1.0d+20) then
                     d = 1.0d+10
                 else
                     d = 4
                 endif
                 call fmi2m2(1, mxy(5))
                 if (ksignx > 0) then
                     mxy(5)%mp(1) = ksign
                     mxy(5)%mp(2) = mexpov
                     mxy(5)%mp(4) = huge(mbase)/d
                     mxy(5)%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
                 else
                     mxy(5)%mp(1) = ksign
                     mxy(5)%mp(2) = mexpun
                     mxy(5)%mp(4) = -huge(mbase)/d
                     mxy(5)%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
                 endif
                 return
             endif
             fexp = 10*fexp + kval
             k = 0
             if (ksignx > 0) then
                 if (nf1 > 0) then
                     if (log(f1) + nf1*dlog_10 + fexp*dlog_10 >= (mxexp0+4.0d0) * dlog_mbsave) then
                         k = 1
                     endif
                 else
                     if (f1 == 0) then
                         if (log(f2) - nf2*dlog_10 + fexp*dlog_10 >=  &
                             (mxexp0+4.0d0) * dlog_mbsave) then
                             k = 1
                         endif
                     else if (nf2 > 50) then
                         if (log(f1) + fexp*dlog_10 >= (mxexp0+4.0d0) * dlog_mbsave) then
                             k = 1
                         endif
                     else
                         if (log(f1+f2/10.0d0**nf2) + fexp*dlog_10 >=  &
                             (mxexp0+4.0d0) * dlog_mbsave) then
                             k = 1
                         endif
                     endif
                 endif
             else
                 if (nf1 > 0) then
                     if (log(f1) + nf1*dlog_10 - fexp*dlog_10 < (-mxexp0-3.0d0) * dlog_mbsave) then
                         k = 1
                     endif
                 else
                     if (f1 == 0) then
                         if (log(f2) - nf2*dlog_10 - fexp*dlog_10 <  &
                             (-mxexp0-3.0d0) * dlog_mbsave) then
                             k = 1
                         endif
                     else if (nf2 > 50) then
                         if (log(f1) - fexp*dlog_10 < (-mxexp0-3.0d0) * dlog_mbsave) then
                             k = 1
                         endif
                     else
                         if (log(f1+f2/10.0d0**nf2) - fexp*dlog_10 <  &
                             (-mxexp0-3.0d0) * dlog_mbsave) then
                             k = 1
                         endif
                     endif
                 endif
             endif
             if (k == 1) then
                 call fminp2b(kf1, kf2, kf1dig, kf2dig, kf2pt, kpower, mxy)
                 call fminp3(line, kstart, kstop, mxy, mbsave)
                 return
             endif
             kexp = 10*kexp + kval

         case default

!                  Error in converting the number.

             call fmi2m2(0, mxy(5))
             mxy(5)%mp(2) = munkno
             mxy(5)%mp(3) = 1
             mxy(5)%mp(1) = 1
             kflag = -7
             return

         end select

      enddo

!             Form the number and return.  mxy(5) = ksign*(mxy(2) + mxy(3))*10.0**(ksignx*kexp)

      call fminp2b(kf1, kf2, kf1dig, kf2dig, kf2pt, kpower, mxy)

      if (kexp /= 0) then
          if (ksignx == 1) then
              mxy(4)%mp(2) = int(kexp/kpower) + 1
              mxy(4)%mp(3) = 10**(mod(kexp, kpower))
          else
              mxy(4)%mp(2) = -int((kexp-1)/kpower)
              kshift = 10**(mod(kexp, kpower))
              if (kshift > 1) then
                  mxy(4)%mp(3) = mbase/kshift
              else
                  mxy(4)%mp(3) = 1
              endif
          endif
      endif

      call fmadd2(mxy(2), mxy(3), mxy(5))

      if (kexp > 0) call fmmpy2_r1(mxy(5), mxy(4))
      mxy(5)%mp(1) = ksign

      return
      end subroutine fminp2

      subroutine fminp2b(kf1, kf2, kf1dig, kf2dig, kf2pt, kpower, mxy)

!  Internal routine to complete the evaluation of
!  mxy(2) = number represented by any digits before a decimal point
!  mxy(3) = number represented by any digits after a decimal point

      use fmvals
      implicit none

      type(multi) :: mxy(5)
      integer :: kf1, kf2, kf1dig, kf2dig, kf2pt, kpower
      intent (in) :: kf1, kf2, kf1dig, kf2dig, kf2pt, kpower
      intent (inout) :: mxy

      integer :: k, kshift

      if (kf1dig /= 0) then
          mxy(2)%mp(2) = mxy(2)%mp(2) + 1
          kshift = 10**(kpower-kf1dig)
          k = mxy(2)%mp(2)
          if (k < ndig) mxy(2)%mp(2+int(k)) = kf1*kshift
          if (kshift > 1) then
              call fmdivi2_r1(mxy(2), kshift)
          endif
      endif
      if (mxy(2)%mp(3) == 0) then
          mxy(2)%mp(1) = 1
          mxy(2)%mp(2) = 0
      else
          mxy(2)%mp(1) = 1
      endif

      if (kf2dig /= 0) then
          kshift = 10**(kpower-kf2dig)
          mxy(3)%mp(kf2pt+1) = kf2*kshift
      endif
      if (mxy(3)%mp(3) == 0) then
          mxy(3)%mp(1) = 1
          mxy(3)%mp(2) = 0
      else
          mxy(3)%mp(1) = 1
      endif

      return
      end subroutine fminp2b

      subroutine fminp3(line, kstart, kstop, mxy, mbsave)

!  Internal routine to see if the input character string in line would overflow or underflow
!  with the current base and precision.

!  mxy(5) is returned as + or - over/underflow or unknown.

      use fmvals
      implicit none

      type(multi) :: mxy(5)
      integer :: kstart, kstop
      character :: line(kstop)
      real (kind(1.0d0)) :: mbsave
      intent (in) :: line, kstart, kstop, mbsave
      intent (inout) :: mxy

      integer :: j, jstate, kdigfl, kpt, ksign, ksignx, ktype, kval
      double precision :: dlog_mbsave, f1, fexp, flarge, ze, zf
      integer :: jtrans(8, 4) = reshape(  (/    &
                   2, 9, 7, 7, 7, 7, 9, 9,      &
                   3, 3, 3, 5, 5, 8, 8, 8,      &
                   4, 4, 4, 9, 9, 9, 9, 9,      &
                   6, 6, 6, 6, 6, 9, 9, 9   /)  &
        , (/ 8, 4 /) )
      character :: kblank = ' '

      jstate = 1
      ksign = 1
      dlog_mbsave = log(dble(mbsave))
      f1 = 0
      ksignx = 1
      fexp = 0
      flarge = huge(f1)/31

!             kdigfl will be 1 if any digits are found before 'e'.

      kdigfl = 0

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      if (lhash == 0) call fmhtbl

!             Scan the number.

      do j = kstart, kstop
         if (line(j) == kblank) cycle
         kpt = ichar(line(j))
         if (kpt < lhash1 .or. kpt > lhash2) then
             write (kw,                                                         &
                "(/' Error in input conversion.'/"                          //  &
                "' ICHAR function was out of range for the current', "      //  &
                "' dimensions.'/' ICHAR(''', A, ''') gave the value ', "    //  &
                "I12, ', which is outside the currently'/' dimensioned', "  //  &
                "' bounds of (', I5, ':', I5, ') for variables KHASHT ', "  //  &
                "'and KHASHV.'/' Re-define the two parameters ', "          //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain', "   //  &
                "' all possible output values from ICHAR.'//)"                  &
                   ) line(j), kpt, lhash1, lhash2
             ktype = 5
             kval  = 0
         else
             ktype = khasht(kpt)
             kval  = khashv(kpt)
         endif
         if (ktype >= 5) then

!                  Error in converting the number.

             call fmi2m2(0, mxy(5))
             mxy(5)%mp(2) = munkno
             mxy(5)%mp(3) = 1
             mxy(5)%mp(1) = 1
             kflag = -7
             return
         endif

         jstate = jtrans(jstate, ktype)

         select case (jstate)

!             State 2.  Sign of the number.

         case (2)
             ksign = kval

!             State 3.  Digits before a decimal point.

         case (3)
             cycle

!             State 4.  Decimal point

         case (4)
             cycle

!             State 5.  Digits after a decimal point.

         case (5)
             cycle

!             State 6.  Precision indicator.

         case (6)
             if (kdigfl == 0) f1 = 1.0d0

!             State 7.  Sign of the exponent.

         case (7)
             ksignx = kval

!             State 8.  Digits of the exponent.

         case (8)
             if (fexp < flarge) then
                 fexp = 10*fexp + kval
             endif

         case default

!                  Error in converting the number.

             call fmi2m2(0, mxy(5))
             mxy(5)%mp(2) = munkno
             mxy(5)%mp(3) = 1
             mxy(5)%mp(1) = 1
             kflag = -7
             return

         end select

      enddo

!             mxy(5) = ksign*(mxy(2) + mxy(3))*10.0**(ksignx*fexp)

      call fmi2m2(1, mxy(1))
      if (ksignx > 0) then
          ze = aint(ksignx*fexp*log(10.0d0)/dlog_mbsave)
      else
          ze = aint(ksignx*fexp*log(10.0d0)/dlog_mbsave) - 1.0d0
      endif
      zf = ksignx*fexp*log(10.0d0) - ze*dlog_mbsave
      if (zf < -dlog_mbsave) then
          zf = 1.0d0/mbsave
      else if (zf > 0.0d0) then
          zf = 1.0d0 - epsilon(1.0d0)
      else
          zf = exp(zf)
      endif
      mxy(1)%mp(1) = ksign
      if (ze > mxexp0+1) then
          mxy(1)%mp(2) = mexpov
      else if (ze < -mxexp0) then
          mxy(1)%mp(2) = mexpun
      else
          mxy(1)%mp(2) = munkno
      endif
      mxy(1)%mp(4) = ze
      mxy(1)%mp(5) = -maxint * zf
      call fmadd2(mxy(2), mxy(3), mxy(4))
      call fmmpy2(mxy(1), mxy(4), mxy(5))

      return
      end subroutine fminp3

      subroutine fminp_m1(line, la, lb, mxy, mresult, ma, krnd, kpower, ndsave)

!  Method 1 for computing fminp.

      use fmvals
      implicit none

      integer :: la, lb, krnd, kpower, ndsave
      character :: line(lb)
      type(multi) :: mxy(5), mresult, ma
      intent (in) :: line, la, lb, ndsave
      intent (inout) :: mxy, mresult, ma, krnd, kpower

      real (kind(1.0d0)) :: mbsave, mxsav1, mxsav2
      character(9) :: namest_save(0:50)
      integer :: j, k, krndsave, kstart, kstop, l, m, nd, ndsav1,  &
                 new_mbase, new_ndig, ntrsav

      krnd = 0
      krndsave = kround
      kround = 1
      mbsave = mbase
      mxsav1 = mxexp
      mxsav2 = mxexp2
      ndsav1 = ndig
      kstart = la
      kstop = lb

!             If mbase is a power of ten then call fminp2 for faster input conversion.

      kpower = int(log10(dble(mbase)) + 0.5d0)
      if (mbase == 10**kpower) then
          k = 0
          do j = la, lb
             if (line(j) /= ' ') then
                 do l = lb, la, -1
                    if (line(l) /= ' ') then
                        k = (l-j+1)*log(10.0d0)/log(dble(mbase))
                        exit
                    endif
                 enddo
                 exit
             endif
          enddo
          if (ndig <= k+2) then
              ndig = k + 3
              ndsav1 = ndig
          endif
          call fmi2m2(0, mxy(1))
          call fmi2m2(0, mxy(2))
          call fmi2m2(0, mxy(3))
          call fmi2m2(0, mxy(4))
          call fmi2m2(0, mxy(5))
          call fminp2(mxy, line, kstart, kstop, kpower, mbsave)
          call fmeq(mxy(5), mresult)
          if (mxy(5)%mp(2) == munkno) kflag = -7
          mxexp = mxsav1
          mxexp2 = mxsav2
          kround = krndsave
          if (kflag == 1) kflag = 0
          if (mresult%mp(3) == 0) mresult%mp(1) = 1
          return
      endif

!             If mbase is not a power of ten then call fminp2 first using a power of ten base,
!             then change to base mbase.

      mbsave = mbase
      kpower = int(log10(dble(mxbase)/4) + 0.5d0)
      mbase = 10**kpower
      ndig = int(ndsav1*log(dble(mbsave))/log(dble(mbase)) + 3)
      k = 0
      do j = la, lb
         if (line(j) /= ' ') then
             do l = lb, la, -1
                if (line(l) /= ' ') then
                    k = (l-j+1)*log(10.0d0)/log(dble(mbase))
                    exit
                endif
             enddo
             exit
         endif
      enddo
      if (ndig <= k+9) then
          ndig = k + 10
      endif
      call fmcons
      call fmi2m2(0, mxy(1))
      call fmi2m2(0, mxy(2))
      call fmi2m2(0, mxy(3))
      call fmi2m2(0, mxy(4))
      call fmi2m2(0, mxy(5))
      j = mxexp2
      k = j*log(dble(mbsave))/log(dble(mbase)) + 0.5
      mxexp2 = k
      call fminp2(mxy, line, kstart, kstop, kpower, mbsave)
      mxexp2 = j
      new_mbase = mbsave
      new_ndig = max(ndsav1, ndig*nint(log(dble(mbase))/log(dble(mbsave))))
      nd = 2
      do j = ndig, 3, -1
         if (mxy(5)%mp(j+2) /= 0) then
             nd = j
             exit
         endif
      enddo
      ndig = nd
      ntrsav = ntrace
      ntrace = 0
      j = ncall
      do m = 0, ncall
         namest_save(m) = namest(m)
      enddo
      ncall = 0
      if (abs(mxy(5)%mp(2)) < mexpov) then
          call fmchangebase(mxy(5), mxy(4), new_mbase, new_ndig)
      else
          call fmequ(mxy(5), mxy(4), ndig, new_ndig)
      endif
      ncall = j
      do m = 0, ncall
         namest(m) = namest_save(m)
      enddo
      ntrace = ntrsav
      mbase = mbsave
      ndig = new_ndig
      call fmcons
      call fmeq(mxy(4), mresult)
      if (mresult%mp(2) == munkno) then
          kflag = -7
          mxexp = mxsav1
          mxexp2 = mxsav2
          kround = krndsave
          if (kflag == 1) kflag = 0
          if (mresult%mp(3) == 0) mresult%mp(1) = 1
          return
      endif

      mxexp = mxsav1
      mxexp2 = mxsav2
      kround = krndsave
      if (int(mbase-aint (mbase/2)*2) == 0) then
          call fmequ(mresult, ma, ndig, ndsave)
      else
          call fmequ(mresult, ma, ndig-1, ndsave)
      endif
      krnd = 1

      return
      end subroutine fminp_m1

      subroutine fminp_sc(line, la, lb, mresult, kresult)

!  Check for special cases for fminp.

!  kresult = 1 is returned if a special case gives the values of the two results.

      use fmvals
      implicit none

      integer :: la, lb, kresult
      character :: line(lb)
      type(multi) :: mresult
      intent (in) :: line, la, lb
      intent (inout) :: mresult, kresult

      integer :: j, kmn, kof, kpt, ktype, kuf, kuk

      character :: kovfl(4) = (/ 'O', 'V', 'F', 'L' /)
      character :: kunfl(4) = (/ 'U', 'N', 'F', 'L' /)
      character :: kunkn(4) = (/ 'U', 'N', 'K', 'N' /)
      character :: lovfl(4) = (/ 'o', 'v', 'f', 'l' /)
      character :: lunfl(4) = (/ 'u', 'n', 'f', 'l' /)
      character :: lunkn(4) = (/ 'u', 'n', 'k', 'n' /)

      kresult = 0
      namest(ncall) = 'FMINP    '

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      if (lhash == 0) call fmhtbl

!             Check for special symbols.

      kmn = 1
      kof = 1
      kuf = 1
      kuk = 1
      do j = la, lb
         kpt = ichar(line(j))
         if (kpt >= lhash1 .and. kpt <= lhash2) then
             ktype = khasht(kpt)
             if (ktype == 2) return
         endif
         if (line(j) == '-') kmn = -1
         if (line(j) == kovfl(kof) .or. line(j) == lovfl(kof)) then
             kof = kof + 1
             if (kof == 5) then
                 call fmi2m2(0, mresult)
                 mresult%mp(1) = kmn
                 mresult%mp(2) = mexpov
                 mresult%mp(3) = 1
                 mresult%mp(4) = mxexp0 + 2
                 mresult%mp(5) = -(1.01d0*maxint)/mbase
                 kresult = 1
                 return
             endif
         endif
         if (line(j) == kunfl(kuf) .or. line(j) == lunfl(kuf)) then
             kuf = kuf + 1
             if (kuf == 5) then
                 call fmi2m2(0, mresult)
                 mresult%mp(1) = kmn
                 mresult%mp(2) = mexpun
                 mresult%mp(3) = 1
                 mresult%mp(4) = -mxexp0 - 1
                 mresult%mp(5) = -(0.495d0*maxint)
                 kresult = 1
                 return
             endif
         endif
         if (line(j) == kunkn(kuk) .or. line(j) == lunkn(kuk)) then
             kuk = kuk + 1
             if (kuk == 5) then
                 call fmi2m2(0, mresult)
                 mresult%mp(2) = munkno
                 mresult%mp(3) = 1
                 kresult = 1
                 return
             endif
         endif
      enddo

      return
      end subroutine fminp_sc

      subroutine fminput_error
      use fmvals
      implicit none
      integer :: e(2)
      e = 0
      write (*,*) ' '
      write (*,*) ' '
      write (*,*) ' ***  Error in a program using the FM package  ***'
      write (*,*) ' '
      write (*,*) ' A multiple precision number is undefined in an expression or as an input'
      write (*,*) ' argument to a subprogram.'
      write (*,*) ' '
      write (*,*) ' '
      write (*,*) ' The most common causes of this error are:'
      write (*,*) "     1. A multiple-precision variable (type(fm), (im), (zm), etc.) appears in an"
      write (*,*) "        expression in the user's program before it has been given a value."
      write (*,*) "     2. The user's program raises precision (ndig) and later tries to use a"
      write (*,*) "        variable previously defined at a lower precision."
      write (*,*) "        Call fm_equ or fm_equ_r1 to increase the size of type(fm) variables"
      write (*,*) "        after increasing precision, zm_equ for type(zm) variables, etc."
      write (*,*) ' '
      write (*,*) ' To help isolate the code that caused this error, this error message is followed'
      write (*,*) ' by an illegal out-of-range array reference.  Some compilers have an option for'
      write (*,*) ' checking array bounds and will give a traceback with the line number in the'
      write (*,*) ' calling program where the error originated.'
      write (*,*) ' '
      write (*,*) ' The program has been stopped.'
      write (*,*) ' '
      if (e(-ndig) > -314159) write (*,*) ' Negative array subscript.'
      stop
      end subroutine fminput_error

      subroutine fmint(ma, mb)

!  mb = int(ma)

!  The integer part of ma is computed and returned in mb as a multiple precision floating
!  point number.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      integer :: j, ka, kresult

      call fmalloc(mb, ndig+2)

      if (mblogs /= mbase) call fmcons
      kflag = 0
      ncall = ncall + 1
      namest(ncall) = 'FMINT'
      if (ntrace /= 0) call fmntr_inp1(ma)

      call fmint_sc(ma, mb, kresult)
      if (kresult > 0) then
          mb%mp(1) = ma%mp(1)
          if (mb%mp(3) == 0) mb%mp(1) = 1
          if (ntrace /= 0) call fmntr_out1(mb)
          ncall = ncall - 1
          return
      endif

!             Here ma has both integer and fraction parts.  Replace the digits right of the
!             radix point by zeros.

      ka = int(ma%mp(2)) + 2
      do j = 1, ka
         mb%mp(j) = ma%mp(j)
      enddo
      do j = ka+1, ndig+2
         mb%mp(j) = 0
      enddo

      mb%mp(1) = ma%mp(1)
      if (mb%mp(3) == 0) mb%mp(1) = 1
      if (ntrace /= 0) call fmntr_out1(mb)
      ncall = ncall - 1

      return
      end subroutine fmint

      subroutine fmint_sc(ma, mb, kresult)

!  Special cases for  mb = int(ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: kresult
      intent (in) :: ma
      intent (inout) :: mb, kresult

      double precision :: x, xe, xf, ye, yf
      integer :: j
      type(multi), save :: mxy

      kresult = 0

      if (ma%mp(2) == munkno .and. ma%mp(5) < 0) then
          kflag = -4
          if (ma%mp(4) > ndig) then
              call fmeq(ma, mb)
          else if (ma%mp(4) < -ndig) then
              call fmi2m(0, mb)
              kflag = 0
          else
              call fmovun_xexf(ma, xe, xf)
              call fmst2m('1.0E+12', mb)
              call fmovun_xexf(mb, ye, yf)
              if (xe > ye .or. (xe == ye .and. xf > yf)) then
                  call fmeq(ma, mb)
              else
                  call fmunknown(mb)
                  x = dble(mbase)**xe * xf
                  if (aint(x) == 0) then
                      mb%mp(4) = 0
                      mb%mp(5) = -maxint * (1/dble(mbase))
                  else
                      x = aint(x)
                      call fmdpm2(x, mxy)
                      call fmovun_xexf(mxy, ye, yf)
                      kflag = -4
                      mb%mp(4) = ye
                      mb%mp(5) = -maxint * yf
                  endif
                  mb%mp(1) = ma%mp(1)
              endif
          endif
          kresult = 1
          return
      endif

!             If ma is less than one in magnitude, return zero.

      if (ma%mp(2) <= 0) then
          do j = 1, ndig+2
             mb%mp(j) = 0
          enddo
          kresult = 1
          return
      endif

!             If the radix point is off the right end of ma then ma is already an integer.
!             Return ma.

      if (ma%mp(2) >= ndig) then
          do j = 1, ndig+2
             mb%mp(j) = ma%mp(j)
          enddo
          if (ma%mp(2) == munkno) kflag = -4
          if (ma%mp(2) == mexpov) kflag = -5
          kresult = 1
          return
      endif

      return
      end subroutine fmint_sc

      subroutine fmipower(ma, ival, mb)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb

      call fmipwr(ma, ival, mb)

      return
      end subroutine fmipower

      subroutine fmipwr(ma, ival, mb)

!  mb = ma**ival

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(2), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmipwr_sc(ma, ival, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call fmipwr_m1(ma, ival, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmipwr

      subroutine fmipwr2(ma, ival, mb)

!  Internal version of fmipwr without any tracing.  mb = ma**ival.
!  Only called by other fm routines.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb

      double precision :: xval
      integer :: k, kwrnsv, ndsave
      type(multi), save :: mxy(2)

      call fmalloc(mb, ndig+2)
      xval = abs(ival)
      ndsave = ndig
      if (xval > 10.0 .or. real(mbase) <= 999.0) then
          k = int(log(xval)/alogmb + 1.0)
          ndig = ndig + k
      endif

!             Initialize.

      k = abs(ival)
      kwrnsv = kwarn
      kwarn = 0
      call fmequ(ma, mxy(1), ndsave, ndig)

!             Handle small exponents by hand.

      if (k == 0) then
          call fmi2m2(1, mxy(2))
      else if (k == 1) then
          call fmeq(mxy(1), mxy(2))
      else if (k == 2) then
          call fmsqr2(mxy(1), mxy(2))
      else if (k == 3) then
          call fmsqr2(mxy(1), mxy(2))
          call fmmpy2_r1(mxy(2), mxy(1))
      else if (k == 4) then
          call fmsqr2(mxy(1), mxy(2))
          call fmsqr2_r1(mxy(2))
      else if (k == 5) then
          call fmsqr2(mxy(1), mxy(2))
          call fmsqr2_r1(mxy(2))
          call fmmpy2_r1(mxy(2), mxy(1))
      endif
      if (k <= 5) then
          if (ival < 0) then
              call fmi2m2(1, mxy(1))
              call fmdiv2_r2(mxy(1), mxy(2))
          endif
          call fmequ(mxy(2), mb, ndig, ndsave)
          ndig = ndsave
          kwarn = kwrnsv
          return
      endif

      if (mod(k, 2) == 0) then
          call fmi2m2(1, mxy(2))
      else
          call fmeq(mxy(1), mxy(2))
      endif

!             This is the multiplication loop.

      do while (k > 1)
         k = k/2
         call fmsqr2_r1(mxy(1))
         if (mod(k, 2) == 1) call fmmpy2_r2(mxy(1), mxy(2))
      enddo

!             Invert if the exponent is negative.

      if (ival < 0) then
          call fmi2m2(1, mxy(1))
          call fmdiv2_r2(mxy(1), mxy(2))
      endif

      call fmequ(mxy(2), mb, ndig, ndsave)
      ndig = ndsave
      kwarn = kwrnsv

      return
      end subroutine fmipwr2

      subroutine fmipwr_m1(ma, ival, mxy, mresult, ndsave)

!  Method 1 for computing ma**ival

      use fmvals
      implicit none

      type(multi) :: ma, mxy(2), mresult
      integer :: ival, ndsave
      intent (in) :: ma, ival, ndsave
      intent (inout) :: mxy, mresult

      double precision :: xval
      integer :: k, kwrnsv

      if (ncall == 1) then
          xval = abs(ival)
          k = int((5.0*real(dlogtn) + log(xval))/alogmb + ngrd52 - 1)
          ndig = max(ndig+k, 3)
      else
          xval = abs(ival)
          if (xval > 10.0 .or. real(mbase) <= 999.0) then
              k = int(log(xval)/alogmb + 1.0)
              ndig = ndig + k
          endif
      endif

!             Initialize.

      k = abs(ival)
      kwrnsv = kwarn
      kwarn = 0
      call fmequ(ma, mxy(1), ndsave, ndig)

!             Handle small exponents by hand.

      if (k == 2) then
          call fmsqr2(mxy(1), mresult)
      else if (k == 3) then
          call fmsqr2(mxy(1), mresult)
          call fmmpy2_r1(mresult, mxy(1))
      else if (k == 4) then
          call fmsqr2(mxy(1), mresult)
          call fmsqr2_r1(mresult)
      else if (k == 5) then
          call fmsqr2(mxy(1), mresult)
          call fmsqr2_r1(mresult)
          call fmmpy2_r1(mresult, mxy(1))
      endif
      if (k <= 5) then
          if (ival < 0) then
              call fmi2m2(1, mxy(1))
              call fmdiv2_r2(mxy(1), mresult)
          endif
          kwarn = kwrnsv
          return
      endif

      if (mod(k, 2) == 0) then
          call fmi2m2(1, mresult)
      else
          call fmeq(mxy(1), mresult)
      endif

!             This is the multiplication loop.

      do while (k > 1)
         k = k/2
         call fmsqr2_r1(mxy(1))
         if (mod(k, 2) == 1) call fmmpy2_r2(mxy(1), mresult)
      enddo

!             Invert if the exponent is negative.

      if (ival < 0) then
          call fmi2m2(1, mxy(1))
          call fmdiv2_r2(mxy(1), mresult)
      endif
      kwarn = kwrnsv

      return
      end subroutine fmipwr_m1

      subroutine fmipwr_sc(ma, ival, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = ma**ival.

!  kresult = 1 is returned if a special case gives the value of ma**ival.

      use fmvals
      implicit none

      type(multi) :: ma, mxy(2), mresult
      integer :: ival, kresult, ndsave
      intent (in) :: ma, ival, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j, kwrnsv

      kresult = 0

      namest(ncall) = 'FMIPWR   '
      j = ndig
      ndig = ndsave
      call fmntr_inp1i(ma, ival)
      ndig = j

      call fmequ(ma, mxy(1), ndsave, ndig)

      if (mxy(1)%mp(2) == munkno .and. mxy(1)%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      if (mxy(1)%mp(2) == munkno .and. mxy(1)%mp(5) < 0) then
          call fmi2m2(ival, mxy(2))
          call fmovun_pwr(mxy(1), mxy(2), mresult)
          kresult = 1
          return
      endif

      if (ival <= 0 .and. mxy(1)%mp(3) == 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      if (ival == 0) then
          call fmi2m2(1, mresult)
          kresult = 1
          return
      endif

      if (abs(ival) == 1) then
          kwrnsv = kwarn
          kwarn = 0
          if (ival == 1) then
              call fmeq(mxy(1), mresult)
          else
              call fmi2m2(1, mxy(2))
              call fmdiv2(mxy(2), mxy(1), mresult)
          endif
          kwarn = kwrnsv
          kresult = 1
          return
      endif

      if (mxy(1)%mp(3) == 0) then
          call fmeq(mxy(1), mresult)
          kresult = 1
          return
      endif

      if (abs(mxy(1)%mp(2)) == mexpov) then
          call fmi2m2(ival, mxy(2))
          call fmovun_pwr(mxy(1), mxy(2), mresult)
          kresult = 1
          return
      endif

      return
      end subroutine fmipwr_sc

      subroutine fmlerc(ma, mb)

!  mb = ln(erfc(ma))

!  ma must be positive, and is assumed to be large enough that erfc(ma) might underflow.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(16), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmlerc_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fmlerc_m(ma, mxy, mresult, ndsave, numtry, retry)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry)
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmlerc

      subroutine fmlerc_m(ma, mxy, mresult, ndsave, numtry, retry)

!  Method selection for computing ln(gamma(ma)).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(16), mresult
      integer :: ndsave, numtry
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry

      double precision :: xe
      integer :: j, nmethd, nterms
      logical, external :: fmcomp

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, ndig)

      nterms = int(intmax/10)

!             Check for special cases.

      if (mxy(1)%mp(3) == 0) then
          call fmi2m(0, mresult)
          retry = .false.
          return
      endif
      if (mxy(1)%mp(2) == mexpun) then
          call fmi2m(-2, mxy(2))
          call fmpi(mxy(3))
          call fmsqrt(mxy(3), mxy(4))
          call fmdiv(mxy(2), mxy(4), mxy(3))
          call fmmpy(mxy(1), mxy(3), mresult)
          return
      endif
      if (mxy(1)%mp(2) == mexpov .and. mxy(1)%mp(1) > 0) then
          call fmsqr(mxy(1), mresult)
          mresult%mp(1) = -1
          kflag = -5
          return
      endif

!             Close to zero use the series for Ln(1-erf(x)).

      call fmovun_xe(mxy(1), xe)
      if (log(mxy(1)%mp(3)+1.0d0)+(xe-1)*dlogmb < -10.0d0*dlogtn) then
          call fmerf(mxy(1), mxy(10))
          call fmeq(mxy(10), mxy(11))
          call fmeq(mxy(10), mxy(6))
          call fmnegate(mxy(11))
          do j = 2, nterms
             call fmmpy_r1(mxy(6), mxy(10))
             call fmdivi(mxy(6), j, mxy(3))
             call fmsub_r1(mxy(11), mxy(3))
             if (kflag == 1) exit
             if (j == nterms) then
                 call fmunknown(mresult)
                 return
             endif
          enddo
          call fmeq(mxy(11), mresult)
          return
      endif

!             Determine which method to use.

!             nmethd = 1 means use fmerfc,
!                    = 2 means use the asymptotic value,
!                    = 3 means use the continued fraction expansion.

      nmethd = 1
      call fmi2m(1000, mxy(3))
      call fmovun_xe(mxy(1), xe)
      if (xe >= ndig) then
          nmethd = 2
      else if (fmcomp(mxy(1), '>', mxy(3))) then
          nmethd = 3
      endif

      if (nmethd == 1) then
          call fmlerc_m1(mxy, mresult, ndsave, numtry)
      else if (nmethd == 2) then
          call fmlerc_m2(mxy, mresult, ndsave, numtry)
      else if (nmethd == 3) then
          call fmlerc_m3(mxy, mresult, ndsave, numtry)
      endif

      return
      end subroutine fmlerc_m

      subroutine fmlerc_m1(mxy, mresult, ndsave, numtry)

!  Method 1 for computing ln(gamma(ma)).

      use fmvals
      implicit none

      type(multi) :: mxy(16), mresult
      integer :: ndsave, numtry
      intent (in) :: numtry, ndsave
      intent (inout) :: mxy, mresult

!             Method 1.  Use fmerfc.

      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig-1)
      endif
      call fmerfc(mxy(1), mxy(15))
      call fmln(mxy(15), mxy(11))

      namest(ncall) = 'FMLERC'

      call fmeq(mxy(11), mresult)

      return
      end subroutine fmlerc_m1

      subroutine fmlerc_m2(mxy, mresult, ndsave, numtry)

!  Method 2 for computing ln(gamma(ma)).

      use fmvals
      implicit none

      type(multi) :: mxy(16), mresult
      integer :: ndsave, numtry
      intent (in) :: ndsave, numtry
      intent (inout) :: mxy, mresult

!             Method 2.  Use the asymptotic value.

      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig-1)
      endif
      if (mxy(1)%mp(1) == 1) then
          call fmpi(mxy(16))
          call fmsqrt(mxy(16), mxy(3))
          call fmmpy_r1(mxy(3), mxy(1))
          call fmi2m(1, mxy(2))
          call fmdiv(mxy(2), mxy(3), mxy(11))
          call fmln(mxy(11), mxy(4))
          call fmsqr(mxy(1), mxy(5))
          call fmsub(mxy(4), mxy(5), mxy(11))
      else
          call fmi2m(2, mxy(3))
          call fmln(mxy(3), mxy(11))
      endif

      call fmeq(mxy(11), mresult)

      return
      end subroutine fmlerc_m2

      subroutine fmlerc_m3(mxy, mresult, ndsave, numtry)

!  Method 3 for computing ln(gamma(ma)).

      use fmvals
      implicit none

      type(multi) :: mxy(16), mresult
      integer :: ndsave, numtry
      intent (in) :: ndsave, numtry
      intent (inout) :: mxy, mresult

      double precision :: xe
      integer :: j, jextra, ndsav1, ndsav2, nterms

!             Method 3.  Use the continued fraction expansion.

!             mxy(14) is the current approximation.
!             mxy(11) is the term in the sum, s(k).
!             mxy(9), mxy(10) are the latest denominators, q(k-1) and q(k).

      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig-1)
      endif
      ndsav1 = ndig
      jextra = max(1, int(5.76/alogmb + 1.0))
      if (ndig+jextra > ndsav1) then
          call fmequ_r1(mxy(1), ndsav1, ndsav1+jextra)
      endif
      ndig = ndig + jextra
      call fmi2m(1, mxy(9))
      call fmeq(mxy(1), mxy(10))
      call fmi2m(1, mxy(11))
      call fmi2m(1, mxy(14))
      nterms = int(intmax/10)

!             Method 3 continued fraction loop.

      ndsav2 = ndig
      do j = 1, nterms
         if (mod(j, 2) == 0) then
             call fmcsmpyi(mxy(9), j/2, mxy(7))
             call fmeq(mxy(1), mxy(3))
             call fmcsmpy_r1(mxy(3), mxy(10))
             call fmadd(mxy(3), mxy(7), mxy(8))
         else
             call fmcsmpyi(mxy(9), j, mxy(3))
             call fmcsdivi(mxy(3), 2, mxy(7))
             call fmeq(mxy(1), mxy(3))
             call fmcsmpy_r1(mxy(3), mxy(10))
             call fmadd(mxy(3), mxy(7), mxy(8))
         endif
         call fmeq(mxy(7), mxy(3))
         call fmcsmpy_r1(mxy(3), mxy(11))
         call fmdiv(mxy(3), mxy(8), mxy(11))
         call fmnegate(mxy(11))
         ndig = ndsav2
         call fmcsadd_r1(mxy(14), mxy(11))

!             Check for convergence.

         if (kflag == 1) then
             exit
         endif
         call fmeq(mxy(10), mxy(9))
         call fmeq(mxy(8), mxy(10))
         ndig = min(ndsav2, max(ngrd22, ndsav2-int(mxy(14)%mp(2)-mxy(11)%mp(2))))
         if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         if (j == nterms) then
             call fmunknown(mresult)
             return
         endif
      enddo

      call fmequ_r1(mxy(14), ndig, ndsav1)
      ndig = ndsav1
      call fmpi(mxy(16))
      call fmsqrt(mxy(16), mxy(3))
      call fmdiv(mxy(14), mxy(3), mxy(11))
      call fmdiv(mxy(11), mxy(1), mxy(12))
      call fmln(mxy(12), mxy(13))
      call fmsqr(mxy(1), mxy(12))
      call fmovun_xe(mxy(12), xe)
      if (xe < mexpov) then
          call fmsub(mxy(13), mxy(12), mxy(11))
      else
          call fmeq(mxy(12), mxy(11))
          call fmnegate(mxy(11))
      endif

      call fmeq(mxy(11), mresult)

      return
      end subroutine fmlerc_m3

      subroutine fmlerc_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = ln(gamma(ma)).

!  kresult = 1 is returned if a special case gives the value of ln(gamma(ma)).

      use fmvals
      implicit none

      type(multi) :: ma, mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMLERC   '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      return
      end subroutine fmlerc_sc

      subroutine fmlg10(ma, mb)

!  mb = log10(ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(6), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmlg10_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call fmlg10_m1(ma, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmlg10

      subroutine fmlg10_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing log10(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(6), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      type(multi), save :: mt
      double precision :: x

      call fmequ(ma, mxy(1), ndsave, ndig)

      if (ma%mp(2) == 0 .or. ma%mp(2) == 1) then
          x = mbase
          x = x**(int(ma%mp(2))-1)*(dble(ma%mp(3))+dble(ma%mp(4))/x)
      else
          x = 2.0
      endif
      if (x > 0.9 .and. x < 1.1) then
          ndig = ndig + 1
          call fmequ(ma, mxy(1), ndsave, ndig)
      endif

      call fmln(mxy(1), mt)
      if (mbase /= mbsli .or. ndig > ndigli) then
          call fmlni_m1(10, mxy, mresult)
          call fmeq(mresult, mxy(2))
      else
          call fmadd(mln2, mln5, mxy(2))
      endif
      call fmdiv(mt, mxy(2), mresult)

      return
      end subroutine fmlg10_m1

      subroutine fmlg10_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = log10(ma).

!  kresult = 1 is returned if a special case gives the value of fmlg10(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(6), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j

      kresult = 0

      namest(ncall) = 'FMLG10   '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, mxy(1), ndsave, ndig)

      if (mxy(1)%mp(2) == munkno .and. mxy(1)%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      return
      end subroutine fmlg10_sc

      subroutine fmli(ma, mb)

!  mb = logarithmic integral(ma)

!  Integral from 0 to ma of 1 / ln(t)  dt.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(3), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmli_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call fmli_m1(ma, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmli

      subroutine fmli_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing li(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(3), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      double precision :: b, xe, xf, ye, ze, zf

      call fmequ(ma, mxy(1), ndsave, ndig)

      if (mxy(1)%mp(3) == 0) then
          call fmi2m(0, mxy(2))
      else if (mxy(1)%mp(2) == mexpun .and. mxy(1)%mp(1) == 1) then
          call fmovun_xexf(mxy(1), xe, xf)
          b = mbase
          ze = xe + log(xf)/log(b)
          zf = log(-ze)/log(b) + log(log(b))/log(b)
          if (ze-zf == ze) then
              ze = xe
              zf = xf
          else
              ye = aint(ze-zf)
              zf = b**(ze-zf - aint(ze-zf))
              ze = ye
          endif
          call fmunderflow(-1, mxy(2))
          mxy(2)%mp(4) = ze
          mxy(2)%mp(5) = -maxint * zf
          kflag = -6
      else if (mxy(1)%mp(2) == mexpov .and. mxy(1)%mp(1) == 1) then
          call fmovun_xexf(mxy(1), xe, xf)
          b = mbase
          ze = xe + log(xf)/log(b)
          zf = log(ze)/log(b) + log(log(b))/log(b)
          if (ze-zf == ze) then
              ze = xe
              zf = xf
          else
              ye = aint(ze-zf) + 1
              zf = b**(ze-zf - aint(ze-zf) - 1)
              ze = ye
          endif
          if (ze <= mxexp0+1) then
              call fmunknown(mxy(2))
              kflag = -4
          else
              call fmoverflow(1, mxy(2))
              mxy(2)%mp(4) = ze
              mxy(2)%mp(5) = -maxint * zf
              kflag = -5
          endif
      else
          call fmln(mxy(1), mxy(3))
          call fmei(mxy(3), mxy(2))
      endif

      call fmeq(mxy(2), mresult)

      return
      end subroutine fmli_m1

      subroutine fmli_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = li(ma).

!  kresult = 1 is returned if a special case gives the value of li(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMLI     '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      return
      end subroutine fmli_sc

      subroutine fmln(ma, mb)

!  mb = ln(ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(6), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmln_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call fmln_m(ma, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmln

      subroutine fmln_m(ma, mxy, mresult, ndsave)

!  Method selection for computing ln(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(6), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      type(multi), save :: mt
      real (kind(1.0d0)) :: ma1
      integer :: ival, j, k2exp, km1, kscale, kwrnsv, last, n1, n3, ndsv, nmethd

      call fmequ(ma, mxy(1), ndsave, ndig)
      ma1 = ma%mp(2)

!             Check to see if the argument is a small integer.  If so use fmlni.

      km1 = 0
      kwrnsv = kwarn
      kwarn = 0
      call fmm2i(mxy(1), ival)
      kwarn = kwrnsv
      if (kflag == 0 .and. ival < mxbase) then
          call fmlni_m1(ival, mxy, mresult)
          return
      endif

!             See if the argument can be scaled to a small integer.

      n3 = ndig + 3
      n1 = ndig + 1
      last = n3 - n1 - 1
      do j = 2, n1
         if (mxy(1)%mp(n3-j+1) /= 0) then
             last = n3 - j - 1
             exit
         endif
      enddo
      kscale = int(ma1) - last
      mxy(1)%mp(2) = last
      kwrnsv = kwarn
      kwarn = 0
      call fmm2i(mxy(1), ival)
      kwarn = kwrnsv
      if (kflag == 0 .and. ival < mxbase) then
          call fmlni_m1(ival, mxy, mt)
          if (ival == 1) km1 = 1
          k2exp = 0

!             Compute ln(mbase**kscale).

          if ((mbslb /= mbase .or. ndiglb < ndig) .and. kscale /= 0) then
              ndsv = ndig
              ndig = ndig + 2 + ndig/100
              call fmlni_m1(int(mbase), mxy, mlbsav)
              mbslb = mbase
              ndiglb = ndig
              if (abs(mlbsav%mp(2)) > 10) ndiglb = 0
              ndig = ndsv
          endif

          if (kscale /= 0 .and. km1 == 0) then
              call fmmpyi(mlbsav, kscale, mxy(6))
              call fmadd_r2(mt, mxy(6))
          else if (kscale /= 0 .and. km1 == 1) then
              call fmmpyi(mlbsav, kscale, mxy(6))
          else if (kscale == 0 .and. km1 == 0) then
              call fmeq(mt, mxy(6))
          else if (kscale == 0 .and. km1 == 1) then
              call fmi2m(0, mxy(6))
          endif
          call fmeq(mxy(6), mt)

          if (k2exp /= 0) then
              if (mbase /= mbsli .or. ndig > ndigli) then
                  call fmlni_m1(2, mxy, mresult)
                  call fmeq(mresult, mxy(4))
              endif
              call fmmpyi(mln2, k2exp, mxy(4))
              call fmadd_r1(mt, mxy(4))
          endif
          call fmeq(mt, mresult)
          return
      endif

      nmethd = 1
      if (ndig*dlogmb/dlogtn > 110000) nmethd = 2
      if (nmethd == 1) then
          call fmln_m1(ma, mxy, mresult, ndsave)
      else
          call fmln_m2(ma, mxy, mresult, ndsave)
      endif

      return
      end subroutine fmln_m

      subroutine fmln_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing ln(ma).

!  Convert ma to a value x close to 1, then use the Taylor series:
!  Ln(x) = 2*( t + t**3/3 + t**5/5 + ...), where t = (x-1)/(x+1).

!  The argument will be moved closer to 1 by removing the base mbase exponent, and then
!  multiplying by powers of 2, 3, 5, 7 before the series is summed.  The series will be
!  added as j2 concurrent series.

      use fmvals
      implicit none

      type(multi) :: ma, mxy(6), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      integer :: jexp(8, 4), kexp(4)
      double precision :: y, xv(8)
      integer :: j, j2, k, k2, ke1, kl, ndsav1, nterm
      real :: tj
      type(multi), save :: mjsums(ljsums), mt

      call fmequ(ma, mxy(1), ndsave, ndig)
      call fmequ(ma, mxy(2), ndsave, ndig)
      mxy(2)%mp(2) = 0
      call fmm2dp(mxy(2), y)
      ke1 = 0
      if (y*mbase < 1 + 1.0d-7) then
          y = y * mbase
          mxy(2)%mp(2) = 1
          ke1 = 1
      endif
      jexp(1, 1:4) = (/    1,   1,  -1,   0 /)
      jexp(2, 1:4) = (/    2,   2,  -1,  -1 /)
      jexp(3, 1:4) = (/    6,   0,  -5,   2 /)
      jexp(4, 1:4) = (/   -5,  -1,  -2,   4 /)
      jexp(5, 1:4) = (/    3, -13,  10,  -2 /)
      jexp(6, 1:4) = (/   51, -13,  -1, -10 /)
      jexp(7, 1:4) = (/    9, -28,  37, -18 /)
      jexp(8, 1:4) = (/ -193,  -6,   5,  68 /)
      kexp(1:4) = 0
      xv(1:8) = (/ 1.2000000000000000d0, 1.0285714285714286d0, 1.0035200000000000d0,  &
                   1.0004166666666667d0, 1.0000406160495965d0, 1.0000070529094230d0,  &
                   1.0000006193987026d0, 1.0000001178537107d0  /)
      do
         if (7*y <= 1 + 1.0d-7) then
             y = 7*y
             kexp(4) = kexp(4) + 1
         else
             exit
         endif
      enddo
      if (5*y <= 1 + 1.0d-7) then
          y = 5*y
          kexp(3) = kexp(3) + 1
      endif
      if (3*y <= 1 + 1.0d-7) then
          y = 3*y
          kexp(2) = kexp(2) + 1
      endif
      if (2*y <= 1 + 1.0d-7) then
          y = 2*y
          kexp(1) = kexp(1) + 1
      endif
      k2 = 5 + sqrt(ndsave*dlogmb/dlogtn)/15
      if (k2 < 5) k2 = 5
      if (k2 > 8) k2 = 8
      do j = 1, k2
         k = -log(y)/log(xv(j))
         y = y * 2.0d0**(k*jexp(j, 1))
         kexp(1) = kexp(1) + k*jexp(j, 1)
         y = y * 3.0d0**(k*jexp(j, 2))
         kexp(2) = kexp(2) + k*jexp(j, 2)
         y = y * 5.0d0**(k*jexp(j, 3))
         kexp(3) = kexp(3) + k*jexp(j, 3)
         y = y * 7.0d0**(k*jexp(j, 4))
         kexp(4) = kexp(4) + k*jexp(j, 4)
      enddo
      call fmi2m(1, mxy(3))
      if (kexp(1) > 0) then
          call fmcsmpyin_r1(mxy(2), 2, kexp(1))
      else if (kexp(1) < 0) then
          call fmcsmpyin_r1(mxy(3), 2, -kexp(1))
      endif
      if (kexp(2) > 0) then
          call fmcsmpyin_r1(mxy(2), 3, kexp(2))
      else if (kexp(2) < 0) then
          call fmcsmpyin_r1(mxy(3), 3, -kexp(2))
      endif
      if (kexp(3) > 0) then
          call fmcsmpyin_r1(mxy(2), 5, kexp(3))
      else if (kexp(3) < 0) then
          call fmcsmpyin_r1(mxy(3), 5, -kexp(3))
      endif
      if (kexp(4) > 0) then
          call fmcsmpyin_r1(mxy(2), 7, kexp(4))
      else if (kexp(4) < 0) then
          call fmcsmpyin_r1(mxy(3), 7, -kexp(4))
      endif
      if (kexp(1) < 0 .or. kexp(2) < 0 .or. kexp(3) < 0 .or. kexp(4) < 0) then
          call fmdiv_r1(mxy(2), mxy(3))
      endif
      call fmi2m(1, mxy(3))
      call fmsub(mxy(2), mxy(3), mxy(4))
      call fmadd(mxy(2), mxy(3), mxy(5))
      call fmdiv(mxy(4), mxy(5), mxy(1))

      tj = 1.25d0 + (ndsave*dlogmb/dlogtn)**0.6d0/18
      j2 = int(tj)
      j2 = max(1, min(j2, ljsums))
      ndsav1 = ndig

!             Split into j2 concurrent sums and reduce ndig while computing each term in the sum as
!             the terms get smaller.

      call fmi2m(1, mxy(2))
      nterm = 1
      do j = 1, j2
         call fmcsdivi(mxy(2), nterm, mjsums(j))
         nterm = nterm + 2
      enddo
      call fmipwr(mxy(1), 2*j2, mxy(3))

      kl = 1
      do while (kl == 1)
         if (nterm > 2*j2+1) then
             call fmcsmpy_r1(mxy(2), mxy(3))
         else
             call fmeq(mxy(3), mxy(2))
         endif
         do j = 1, j2
            call fmcsdivi(mxy(2), nterm, mxy(4))
            ndig = ndsav1
            call fmcsaddnn_r1(mjsums(j), mxy(4))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            ndig = ndsav1 - int(mjsums(j)%mp(2)-mxy(4)%mp(2))
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
            nterm = nterm + 2
         enddo
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call fmcsnsums(j2, mjsums)
      call fmsqr(mxy(1), mxy(4))
      call fmeq(mjsums(j2), mxy(3))
      do j = 2, j2
         call fmcsmpy_r1(mxy(3), mxy(4))
         call fmadd_r1(mxy(3), mjsums(j2-j+1))
      enddo
      call fmmpy(mxy(3), mxy(1), mxy(6))
      call fmmpyi_r1(mxy(6), 2)
      k = ma%mp(2) - ke1
      ndsav1 = ndig
      ndig = ndig + ngrd21
      call fmequ(mxy(6), mt, ndsav1, ndig)
      if (k /= 0) then
          if (ndiglb >= ndig .and. mbase == mbslb) then
              call fmmpyi(mlbsav, k, mxy(5))
          else
              call fmlni_m1(int(mbase), mxy, mlbsav)
              mbslb = mbase
              ndiglb = ndig
              call fmmpyi(mlbsav, k, mxy(5))
          endif
          call fmadd_r1(mt, mxy(5))
      endif
      if (ndigli < ndig .or. mbase /= mbsli) then
          call fmlni_m1(210, mxy, mresult)
          call fmeq(mresult, mxy(2))
      endif
      if (kexp(1) /= 0) then
          call fmcsmpyi(mln2, kexp(1), mxy(3))
          call fmsub_r1(mt, mxy(3))
      endif
      if (kexp(2) /= 0) then
          call fmcsmpyi(mln3, kexp(2), mxy(3))
          call fmsub_r1(mt, mxy(3))
      endif
      if (kexp(3) /= 0) then
          call fmcsmpyi(mln5, kexp(3), mxy(3))
          call fmsub_r1(mt, mxy(3))
      endif
      if (kexp(4) /= 0) then
          call fmcsmpyi(mln7, kexp(4), mxy(3))
          call fmsub_r1(mt, mxy(3))
      endif
      call fmequ(mt, mresult, ndig, ndsav1)
      ndig = ndsav1

      return
      end subroutine fmln_m1

      subroutine fmln_m2(ma, mxy, mresult, ndsave)

!  Method 2 for computing ln(ma).

!  At high precision, use arithmetic-geometric mean iteration.

      use fmvals
      implicit none

      type(multi) :: ma, mxy(6), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      type(multi), save :: mt
      double precision :: y
      integer :: k, m

      call fmequ(ma, mxy(1), ndsave, ndig)
      mxy(1)%mp(2) = 0
      call fmm2dp(mxy(1), y)
      m = max(1, int((ndig*dlogmb/36 - log(y))/dlogtw + 1))
      call fmcsmpyin_r1(mxy(1), 2, m)
      call fmi2m(1, mxy(2))
      call fmdiv(mxy(2), mxy(1), mxy(4))
      call fmeq(mxy(4), mxy(2))
      call fmsqr(mxy(2), mxy(5))
      call fmsqr(mxy(5), mxy(3))
      call fmsqr(mxy(3), mxy(5))
      call fmmpy(mxy(4), mxy(5), mxy(6))
      call fmadd_r1(mxy(2), mxy(6))
      call fmsqr_r1(mxy(5))
      call fmadd_r1(mxy(3), mxy(5))
      call fmmpy_r1(mxy(5), mxy(6))
      call fmadd_r1(mxy(2), mxy(5))
      call fmmpyi_r1(mxy(2), 2)
      call fmmpyi_r1(mxy(3), 2)
      call fmi2m(1, mxy(5))
      call fmadd_r1(mxy(3), mxy(5))
      call fmmpy(mxy(2), mxy(3), mxy(5))
      call fmsqr_r1(mxy(2))
      call fmsqr_r1(mxy(3))
      call fmadd(mxy(2), mxy(3), mxy(4))
      call fmdivi(mxy(4), 2, mxy(2))
      call fmeq(mxy(5), mxy(3))
      do
         call fmsub(mxy(3), mxy(2), mxy(4))
         if (mxy(4)%mp(3) == 0 .or.  &
             mxy(4)%mp(2) - max(mxy(2)%mp(2), mxy(3)%mp(2)) <= -ndig+1) exit
         call fmdivi_r1(mxy(4), 2)
         call fmmpy(mxy(2), mxy(3), mxy(5))
         call fmsqrt(mxy(5), mxy(3))
         call fmadd_r1(mxy(2), mxy(4))
      enddo

      call fmpi(mxy(1))
      call fmmpyi_r1(mxy(2), 4)
      call fmdiv(mxy(1), mxy(2), mt)
      if (ndigli >= ndig .and. mbase == mbsli) then
          call fmmpyi(mln2, m, mxy(3))
      else
          call fmlni_m1(2, mxy, mresult)
          call fmeq(mresult, mxy(2))
          call fmmpyi(mxy(2), m, mxy(3))
      endif
      call fmsub_r1(mt, mxy(3))
      k = ma%mp(2)
      if (k /= 0) then
          if (ndiglb >= ndig .and. mbase == mbslb) then
              call fmmpyi(mlbsav, k, mxy(5))
          else
              call fmlni_m1(int(mbase), mxy, mlbsav)
              mbslb = mbase
              ndiglb = ndig
              call fmmpyi(mlbsav, k, mxy(5))
          endif
          call fmadd_r1(mt, mxy(5))
      endif
      call fmeq(mt, mresult)

      return
      end subroutine fmln_m2

      subroutine fmln_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = ln(ma).

!  kresult = 1 is returned if a special case gives the value of ln(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(6), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      double precision :: xe, xf, ye, yf, ze
      integer :: j

      kresult = 0

      namest(ncall) = 'FMLN     '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, mxy(1), ndsave, ndig)

      if ((mxy(1)%mp(2) == munkno .and. mxy(1)%mp(5) >= 0) .or.  &
          mxy(1)%mp(1) < 0 .or. mxy(1)%mp(3) == 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      if (abs(mxy(1)%mp(2)) >= mexpov) then
          call fmunknown(mresult)
          xe = abs(mxy(1)%mp(4))
          xf = -mxy(1)%mp(5)/maxint
          if (mxy(1)%mp(4) <= 0) xf = 1/xf

          if (xe > huge(1.0d0)/dlogmb) then
              ze = huge(1.0d0)
          else
              ze = xe*dlogmb + log(xf)
          endif

          ye = floor(log(ze)/dlogmb) + 1
          yf = ze / mbase**ye

          mresult%mp(4) = ye
          mresult%mp(5) = -yf*maxint
          if (mxy(1)%mp(4) <= 0) mresult%mp(1) = -1
          kresult = 1
          return
      endif

      return
      end subroutine fmln_sc

      subroutine fmlngm(ma, mb)

!  mb = ln(gamma(ma))

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(15), mresult, mretry

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmlngm_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      n_acc = nint(ndig*alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmlngm_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmlngm

      subroutine fmlngm_c(ndig_c, mbase_c, c)

!  Initialize the constants used in the log gamma polynomial.

      use fmvals
      implicit none

      type(multi) :: c(0:196)
      integer :: ndig_c
      real (kind(1.0d0)) :: mbase_c
      intent (inout) :: c, ndig_c, mbase_c
      integer :: ndsave
      character(220) :: st

      ndsave = ndig
      ndig = max(ndig, nint(210*dlogtn/dlogmb))
      ndig_c = ndig
      mbase_c = mbase

      st = " 6.931471805599453094172321214581765680755001343602552541206800094" //  &
           "933936219696947156058633269964186875420014810205706857336855202357" //  &
           "58130557032670751635075961930727570828371435190307038623891673471123350M-1"
      call fmst2m(st, c(0))
      st = " 9.227843350984671393934879099175975689578406640600764011942327651" //  &
           "151322732223353290630529367082532504853685527501929175190394959855" //  &
           "13457163775826002355076463746499666257062662262326057207404741752905084M-1"
      call fmst2m(st, c(1))
      st = " 1.974670334241132182362075833230125946094749506033992188677791146" //  &
           "850037352016004369168144503098793526520021594811685953398143623435" //  &
           "02503893967551473165433138415866654683881302547625503436070027398405779M-1"
      call fmst2m(st, c(2))
      st = " 2.568563438653142846657938717048333025499543078016629393075718511" //  &
           "394606859543769672881862453644508604873305259842023980616399866622" //  &
           "44277379254656124026333871513139276497866889063971918407474980813205213M-2"
      call fmst2m(st, c(3))
      st = " 4.955808427784547879000924135291975693687737979681726920744053861" //  &
           "030154046742211639227408985424979308247703477010685603646017893642" //  &
           "51133732050087867905480177194587022770925733154718370654381840105887655M-3"
      call fmst2m(st, c(4))
      st = " 1.135551028673985266273097291406833611416183900382562394838535580" //  &
           "760717957256296912008621311426667275924068293311321808560192355831" //  &
           "19416836702214436017528973257267436070719672792473025777796267055355048M-3"
      call fmst2m(st, c(5))
      st = " 2.863436640748566190863216318200879836362483388089269737347773340" //  &
           "553638169929829804623296564225284217131985270424264778996969080555" //  &
           "16975632152723012109455292088401608926031282713256898710394755277209657M-4"
      call fmst2m(st, c(6))
      st = " 7.668248313183240568536426425667994283765150931981520246901951022" //  &
           "878261676510504944242413055018913842306480735586784104096820283433" //  &
           "36343308283287191406517315813519407491295119077092395710810995273468308M-5"
      call fmst2m(st, c(7))
      st = " 2.138827474304242233565481358155815737009883123125254113877533157" //  &
           "286907184360179941090379654649639056545605878533625329428744350917" //  &
           "29963707838227249505773740942777859121824166285189382035452217278554155M-5"
      call fmst2m(st, c(8))
      st = " 6.140869564690490872529914712451165067316821654306283177401767753" //  &
           "894821139822105599229903018842906378733862871895584602819330080270" //  &
           "01700768138875158345454772076408505044108823934202891440461609291305270M-6"
      call fmst2m(st, c(9))
      st = " 1.801262781808533714595890031901700601953156447751725778899463629" //  &
           "146515191295439704196861038565275400689206320530767736809020353629" //  &
           "38073190695949842873953621603334722352596732052178932328832066543779584M-6"
      call fmst2m(st, c(10))
      st = " 5.370321926785962456620478609033153278577962007833744674032818230" //  &
           "963452927104275083493657782390759550975407401180548454361763677022" //  &
           "25719502127813332819843513403345897099400330508911246024488125358988974M-7"
      call fmst2m(st, c(11))
      st = " 1.621606923373582198331706449725800346740381669503777534126777710" //  &
           "016401617427540869007126583916228785817454388595224584374431558565" //  &
           "62424003947302186656188945000933064454593249101343833268069567881424866M-7"
      call fmst2m(st, c(12))
      st = " 4.946423680685744244896356595351648270045350075731820789781699205" //  &
           "590998801613945328568871293350300180372347783056466467421940336962" //  &
           "37993051766799459115354359781619794227922798691721786471256812355243228M-8"
      call fmst2m(st, c(13))
      st = " 1.521277205034494703893608109526767726401208246782019680016091878" //  &
           "150165553006261855592657131910806289218694348060771816544039319519" //  &
           "70268151503584997891542218258262605500864512242956007183617857332741602M-8"
      call fmst2m(st, c(14))
      st = " 4.710545468032903448567376337505841863247123878500437995526222151" //  &
           "143756151971538155623134503232957797896283285550201985050591879362" //  &
           "14529603180002288823222154049517099193894892610640999441314930078235979M-9"
      call fmst2m(st, c(15))
      st = " 1.466896634491983285717977295126452336811904470697069075224299192" //  &
           "939247071986642850302895153896641951172329934777380990036068940704" //  &
           "92049327640255496401589822485890032872392277699930611719523121420745147M-9"
      call fmst2m(st, c(16))
      st = " 4.590062735154278588407978252478287205347213340644341084689962143" //  &
           "111930858436518669786421571299766271527706531603537599776303515851" //  &
           "07346286911988982005532291493494947163957826550954358278107733999478261M-10"
      call fmst2m(st, c(17))
      st = " 1.442221874911031367580345522072474831788307406190652461104238910" //  &
           "857027803132223315927216471971838450273509423200923289440756059767" //  &
           "68857423403274844425475990232160708382227977333807182882605816718263351M-10"
      call fmst2m(st, c(18))
      st = " 4.547809165468029773462079480806624058657045422294384456641178682" //  &
           "659691101645601195358296330035349908208769392426188702234370516180" //  &
           "56888377164494448967006811680025457321926050295945478985302205704218490M-11"
      call fmst2m(st, c(19))
      st = " 1.438587332730565760193417246729718970937052978750282449255687568" //  &
           "655719501289180489881937394774257940434077254947095313349728878573" //  &
           "86843008158160916187514601728862636178280076324418505631445853717950171M-11"
      call fmst2m(st, c(20))
      st = " 4.563265937212529367600208240284116509275473219057499398885563766" //  &
           "090388563517935169737964577745895815190180995118452252225828163120" //  &
           "99722426850021624306978846433211406278468453662456948824141382999031282M-12"
      call fmst2m(st, c(21))
      st = " 1.451073916840454711281216045224320082808166284993163778021566315" //  &
           "255587037332552553079272066121649499425851990060321384124955433677" //  &
           "67207993278060823840271886615031403999360286605743411932260491743002791M-12"
      call fmst2m(st, c(22))
      st = " 4.624528056444812082051687967994458694688921677653576433580975534" //  &
           "968450053554049283580808625060631085218986361103614972923204710045" //  &
           "87054803107018718005909662543849301887854984204280816281128477629296891M-13"
      call fmst2m(st, c(23))
      st = " 1.476781612022755183419973250511459966182209498276769571800718539" //  &
           "731445227020086180343751505787486916705816774093130509272233480605" //  &
           "44047487934404934553435264532664986314948239961478420907068538648968405M-13"
      call fmst2m(st, c(24))
      st = " 4.724507827870744254820277464047378923678173249594725356053537843" //  &
           "069856328276686251584801735153843799291487544822727471278651677292" //  &
           "03640042606725210618105758740751314683086483423378587429797730710810703M-14"
      call fmst2m(st, c(25))
      st = " 1.513978913019171763487041148572556877568791963643984495346043449" //  &
           "018701962532639151560210080671482947559816365848586253646530778070" //  &
           "18537123717716793256274213468254921216965019092087180696648092689644960M-14"
      call fmst2m(st, c(26))
      st = " 4.858996725976554852006318671090915519699354289999749614013042503" //  &
           "935984106218549522233834213516072290014623125419558504921174284920" //  &
           "78107160688407534237846157628451620609106027079137343790816294845243811M-15"
      call fmst2m(st, c(27))
      st = " 1.561654519392582828714942943686889037831993268563190525220343034" //  &
           "296584463347814354645233174014087011036651133377861482059644157593" //  &
           "18350440790655464091846868252936233878726656395056209922850191735361446M-15"
      call fmst2m(st, c(28))
      st = " 5.025614514474191003429454120021263907058345057163756484675204032" //  &
           "160626854269473972760278335161149373855516115547324556053250680761" //  &
           "35960353957624688528998376864715123324194768194244608331227956016708835M-16"
      call fmst2m(st, c(29))
      st = " 1.619268063222415588245007073271189318378938728336204453480653557" //  &
           "646832121167874868009309695437374462682430335955717169955384406157" //  &
           "35461655626485084754177259606520323581270018242949002547200222070367875M-16"
      call fmst2m(st, c(30))
      st = " 5.223211739191891688145554861633126404312733249590231268939276354" //  &
           "483256718224458681957003067572062210319658187678206505904762786890" //  &
           "39036962584739426283467796928036615339321696596679043636072535930177735M-17"
      call fmst2m(st, c(31))
      st = " 1.686605565375918423742481404695259319639157222117507057462225591" //  &
           "850533083720983505743619854637504171953994487105802289063236646168" //  &
           "31565771482245546699030298377683203899275714959867483319947682463166471M-17"
      call fmst2m(st, c(32))
      st = " 5.451517284342611284349867604595522641598896765349022422637246200" //  &
           "744471171937423465939660935482207447703449379192989322923063888266" //  &
           "31229372543901089934035916918836653287495719335136501890625959613216773M-18"
      call fmst2m(st, c(33))
      st = " 1.763692929460761010585031266299209488371094586913873180122443276" //  &
           "358212007822366334544290589814884405499150265809186554929224793099" //  &
           "67159580614375385516830687382686358909934655641565142758100304193688125M-18"
      call fmst2m(st, c(34))
      st = " 5.710924940930289429222525846887709139266580644631501378754425400" //  &
           "402344096734033498368417722870024289649356569956325790061028789490" //  &
           "90201209337135311180824855625236387835485476090642686407138148182122938M-19"
      call fmst2m(st, c(35))
      st = " 1.850743092341469168679255116939946915034455019205428394047707184" //  &
           "730616709166372869327273711967997594444383081358747754694208065117" //  &
           "59243078812287887751986055564202797220696526499221359781019466183552083M-19"
      call fmst2m(st, c(36))
      st = " 6.002362311111352855438751511526624123122881372177829574698482082" //  &
           "268472189497794035844163044963208202280717860883655584808569201908" //  &
           "84840540664364095292197489013673097320200190188150543497148096517991518M-20"
      call fmst2m(st, c(37))
      st = " 1.948123521680466000278613877664857969433940710389346300112405920" //  &
           "570813255255307791273062459813736293577657819726099571791897412896" //  &
           "04499052083706223596278073126974722712855926508631000226750654451336437M-20"
      call fmst2m(st, c(38))
      st = " 6.327210499275762922454617564886905374837540270134647521961777337" //  &
           "241208973850468966202699863294902233722101674486074157046009900783" //  &
           "94943168708628546063295850691161365924829349560770067069849204243333875M-21"
      call fmst2m(st, c(39))
      st = " 2.056336517258456819404872718846500024771970712636992752800634217" //  &
           "390177588265180513218328462256818578504975537617618012477658735253" //  &
           "91357901005319898451317799466679533736509835947206121997945730419581125M-21"
      call fmst2m(st, c(40))
      st = " 6.687256410663997968707038300952324368643567824691228269512829884" //  &
           "600241200120276396209386234811912763595929600746527477568692380093" //  &
           "65846941054535500737409129245379236794232295378392955072876104303576437M-22"
      call fmst2m(st, c(41))
      st = " 2.176007902867600569564968838424519571170445852508011400529276121" //  &
           "985778848606677081067574991228552820893084306450020295730062213612" //  &
           "47319852047491615671942139635029927212587004293525094112235574131058548M-22"
      call fmst2m(st, c(42))
      st = " 7.084666872547745583697885218008349498259999765144828626416539742" //  &
           "112817790036483006355449086393842354631309401157315763399808881211" //  &
           "63034428362049804231045013084677403365104232875460124915055150115352532M-23"
      call fmst2m(st, c(43))
      st = " 2.307881457325186109702251558024026338622462538196464637417250145" //  &
           "271014677258724350821337105472668901649544195158107332539530013289" //  &
           "58690754615380156771062458199324618311119940721724411263802909784747175M-23"
      call fmst2m(st, c(44))
      st = " 7.521978024882350363251147127637517006885196169534728483482110729" //  &
           "767330760893859561440994301232670866451144204592673539313561020703" //  &
           "16229680624073031879503528876975581601231458676853213367966509358616500M-24"
      call fmst2m(st, c(45))
      st = " 2.452817457661126560656022558232578383346781683732614004543641047" //  &
           "950608697083659342320485224577786541964544409466877827518882696166" //  &
           "77785583812635059733861275531662340097681814492066607106278651398864552M-24"
      call fmst2m(st, c(46))
      st = " 8.002095926418321660462882983562136934827167736984869734245484961" //  &
           "990362339894468819446499270621544724743989273983343985659243797090" //  &
           "02617723679997529884675116233201816776147675793642923747702696525736417M-25"
      call fmst2m(st, c(47))
      st = " 2.611794321654760040868482915030344896471378127607902926579083608" //  &
           "600355795254414772701179436107007717915331779124504018381582369712" //  &
           "35303338971473297210813756554582658474866145972030534849911654352767572M-25"
      call fmst2m(st, c(48))
      st = " 8.528305842439874174397891979909201174136636691345390271985961340" //  &
           "951635472717713994160270983358301811012414732109357429143927205677" //  &
           "24451493207732247380061110874133984404716199859823728402868897884262789M-26"
      call fmst2m(st, c(49))
      st = " 2.785912715941407608332964765121774292928933289953979801676819715" //  &
           "042211815722358756877838540023159292634878096952517082899902453482" //  &
           "75453420374439979087786662261117071847545271472089893478013180932399900M-26"
      call fmst2m(st, c(50))
      st = " 9.104288632359302486087921738156084451459177031330022615977426375" //  &
           "389281113948847333526780396722062239770555955153203912544147152689" //  &
           "10635505098052873178484650793531962248685195239569728214014565219560910M-27"
      call fmst2m(st, c(51))
      st = " 2.976401736830878380813487190839719864305643062243346972314080928" //  &
           "571659774700309771395429511816849731798335554291299072632159561785" //  &
           "13853498257646786277128193242849488156599291079190249617494763928122532M-27"
      call fmst2m(st, c(52))
      st = " 9.734143269753073619444573395909866046087281775327043563820191216" //  &
           "592074666762884461637185638436344417629043795119832288445119716594" //  &
           "54681757554722607199255640890946515559342596226071714786376672991314824M-28"
      call fmst2m(st, c(53))
      st = " 3.184626928899218981583942072541398262319779552845939844429551688" //  &
           "572650417481499150961066174605543822869303332888433674715027707880" //  &
           "04490731942311456494319892555319423931924782646792891555889559629511546M-28"
      call fmst2m(st, c(54))
      st = " 1.042241493677369606594579977699800680670958579629702706075164525" //  &
           "911994152904008645633144958538688068689955477642378460321912420061" //  &
           "44713093711611925694102923080704525452321573189336778639403115171327402M-28"
      call fmst2m(st, c(55))
      st = " 3.412100013470891170294585716908258368140834550044525411190398041" //  &
           "104754921079862028936399162559763428726672165337980689582820113040" //  &
           "13416198464826440959995204574451765227502181269455928284526174312187664M-29"
      call fmst2m(st, c(56))
      st = " 1.117412841751556843302074248615568735696721287113186281328504084" //  &
           "312562222725968138902580374246217663276066641488490501477225640253" //  &
           "42579986440180416098324496187285052304475776686406646945052809161071102M-29"
      call fmst2m(st, c(57))
      st = " 3.660490274490043678026226644620183224238038689661082986523077162" //  &
           "981414308819425679643969633533180026092880760915904811622562886923" //  &
           "84487396264603185012812742600008480127678888705848700357490206046685979M-30"
      call fmst2m(st, c(58))
      st = " 1.199482671814381161791341850793296252666044625258418739613110049" //  &
           "104551626086380287997089537812232630867438710978470875637869385419" //  &
           "01607003246251775392139826953129400440619709892748008039595593739769704M-30"
      call fmst2m(st, c(59))
      st = " 3.931637604707211006390296608348190956772148951812063256727344243" //  &
           "900822542438555764328768554173091304365555553142603137727525766441" //  &
           "84525659723982712681986023184076666876842449810082867584381453291908627M-31"
      call fmst2m(st, c(60))
      st = " 1.289061499462497744696303533633690434193534414239284689686070597" //  &
           "676814880055275326028949838642762828605994974529472129232550363697" //  &
           "60950396038294052993668381573708577221742561680239596349647149571718672M-31"
      call fmst2m(st, c(61))
      st = " 4.227567257903962351790508597715893632841769835136110706800940837" //  &
           "829652461572432184043919015812076564236545988931174492991859433101" //  &
           "25778000859246543191517786955778130308647637177926547762610318839215217M-32"
      call fmst2m(st, c(62))
      st = " 1.386820999018780266062944049316369528834057757206382128765313047" //  &
           "270244006158501294298057326510552601141951742736581362353221200763" //  &
           "47128739854666116108186922912060771673278920840786086509429347218298547M-32"
      call fmst2m(st, c(63))
      st = " 4.550506387724437506082055927268146785006102873281969302732936243" //  &
           "298895572505202160358438794407807710437237187496655791039130216893" //  &
           "87511924875421792179416180376854086009363053011270507639350841775560466M-33"
      call fmst2m(st, c(64))
      st = " 1.493499528613739965372638972965391238482547633295265869054828367" //  &
           "829416466398480374395870941759362578697731625235707888992530344564" //  &
           "64118616870137110287959590352137938213456367349222761768780656871967062M-33"
      call fmst2m(st, c(65))
      st = " 4.902902483647573629190444872668433339026722693539103782664050983" //  &
           "225694025564768841074155141457059295428474046880275907189034299237" //  &
           "32944103681204447082846734232378539796234753927604216121433267289535418M-34"
      call fmst2m(st, c(66))
      st = " 1.609908275928169570082165607481456370083831087969406562557256167" //  &
           "364188362846846549047875066952892162692919458759129310778349489953" //  &
           "22770448873819282967830858947780630728913545194644474976588962028982890M-34"
      call fmst2m(st, c(67))
      st = " 5.287443841783967253336743861164853484418810262590989794938834387" //  &
           "073299404536655202675616502143848847208164288382903044431016858516" //  &
           "20009538336266282148044005430788026679223320414557498337146361309107021M-35"
      call fmst2m(st, c(68))
      st = " 1.736938072243109805185530725881959995611305822994512775248040487" //  &
           "238177289693647144646295113799732566680032754548503116064306224752" //  &
           "78198414114124592660116717229603109916607439068859873993478598764324167M-35"
      call fmst2m(st, c(69))
      st = " 5.707082233953717693925573957068774870416069447922801957662691273" //  &
           "270987710445603289113054181853887859043710418144298938936434365836" //  &
           "22910905014974542359781276508954019188261527426571788239315967868621528M-36"
      call fmst2m(st, c(70))
      st = " 1.875566930504197126372674019737550486762741857855257836323427280" //  &
           "225964790637523226088657691476666774290875901414134481518247331060" //  &
           "71906874659900660807946217987043810912477339050139457949133330400430348M-36"
      call fmst2m(st, c(71))
      st = " 6.165057963933168318023358517808802281756068067015463002715232153" //  &
           "371564234012532194529099415076087246371078651694171463516031915534" //  &
           "01898954460353148685542639895937235904606585101085654511370630295486436M-37"
      call fmst2m(st, c(72))
      st = " 2.026868371192165401197185010283739193718905421948964225522412850" //  &
           "262737204848695188406921800082238582127540011428039129914658458542" //  &
           "37634642867581786423872725394317163245280102057930986208119247853710652M-37"
      call fmst2m(st, c(73))
      st = " 6.664927525630725280315186707639828112376671188813408419458083523" //  &
           "173661970136566062651079390703015968881216092673504456192083877599" //  &
           "15804352132821230683566017780795660498858012885579266098347848714173428M-38"
      call fmst2m(st, c(74))
      st = " 2.192020608118261066539037933528189571558724587838583580744609163" //  &
           "952034074131032109073883254528947795371825396404707207594960566130" //  &
           "08388120561413633077336889145268058079508281341166298919160705693687869M-38"
      call fmst2m(st, c(75))
      st = " 7.210594104883918757684569353059178987815466143353338512729476387" //  &
           "590176795023385801954403484227849398454243048187188857331730164109" //  &
           "61130821394037069074892323683471141755158288684895958165035966426280590M-39"
      call fmst2m(st, c(76))
      st = " 2.372316675010334396327093341566291045560598544381746314200798914" //  &
           "361335388290174563770200693760939384221618459565684611293948349762" //  &
           "99760715272696457406804603245507893941691344795060823654575302742922341M-39"
      call fmst2m(st, c(77))
      st = " 7.806341195078978788896796569353844545546683670636287097360101000" //  &
           "674819867286255396945996712341079701193140494784764939652507657527" //  &
           "10776509577749635871445825212032538401033636476215858432876024174293608M-40"
      call fmst2m(st, c(78))
      st = " 2.569175583075068496597802624641121843008905917144485747977702000" //  &
           "084716234785945953181138133105853830584529894491272387561559175918" //  &
           "06056635101515773378678277304459406269213364274389438074596955963853941M-40"
      call fmst2m(st, c(79))
      st = " 8.456869627337005555483543945000411129981141780087868584229158532" //  &
           "975156474362982393176600086105992624536940685475408780825634971862" //  &
           "82928746682884903136048829786952212289839035702247341347744500864695940M-41"
      call fmst2m(st, c(80))
      st = " 2.784154609752488682347830682317399839437808496760216533359957844" //  &
           "108419936184123983123382869988781032193042150722634481595940148079" //  &
           "47471887024692990616525022991390619756225607915282611367773077871045722M-41"
      call fmst2m(st, c(81))
      st = " 9.167338349011185351110270732877594395344097568799016206592150045" //  &
           "211148681681966966935859814202597754161577071431235188923674247559" //  &
           "93097788462831296346214350780525347998671878506396254329112437194116937M-42"
      call fmst2m(st, c(82))
      st = " 3.018962829751912207860422524685002365325324396585948666388970238" //  &
           "468900826307200635678324473325455973126327818463443937367696783407" //  &
           "31216822788529908321030119923263022821575928202721712476375757572174960M-42"
      call fmst2m(st, c(83))
      st = " 9.943409320108569385064969631771335447816687861933253786118347289" //  &
           "942417796521205611575152291429262471820315825809582098019324351274" //  &
           "19736007449168383766428225696036997597572676990996005739875078089934258M-43"
      call fmst2m(st, c(84))
      st = " 3.275476011303678103893551709440913333007415558028940493123054436" //  &
           "102576111138063293549771997379461070822607505834700351586923416924" //  &
           "36130515829060972565436000080016114747837549174742969323583514548979337M-43"
      call fmst2m(st, c(85))
      st = " 1.079129693640085894851434181915227380977317782277815512357487683" //  &
           "235378082315776477576402633427103515916665364561427248912637998286" //  &
           "84497336603622824659763899982809691142662878118295489894583048485526949M-43"
      call fmst2m(st, c(86))
      st = " 3.555753013510719060083393999120543994047683529242126292544972222" //  &
           "356576357296720319402739291176562890757829588273748247638519856640" //  &
           "67480610895714757344602846046498898788815371622608783151322531494411842M-44"
      call fmst2m(st, c(87))
      st = " 1.171782243084804960250703836375832017652851729860152530408648875" //  &
           "579920584019031061094655011368498851035103058003948560022564877979" //  &
           "17046691205570131651535433024120306105982182247803947139577240760760240M-44"
      call fmst2m(st, c(88))
      st = " 3.862053834876472821052586382551496075098455346933359196501245526" //  &
           "180729685642432233621061970152222441386142907366726076208958805328" //  &
           "70627198276478969445218445704378235779473329084661077747371015095013204M-45"
      call fmst2m(st, c(89))
      st = " 1.273047375197605743053349834215496117644063043473174035166207181" //  &
           "768692059655110422250456339545311971995535730478050915338536261677" //  &
           "65444071293612365602178273688293636174364964871538328370023554265881805M-45"
      call fmst2m(st, c(90))
      st = " 4.196859478667449972989243439715623246016537566511261080114559563" //  &
           "758135987775813449384022624930316510736358259866183402630340459291" //  &
           "72668526906989173105067164347823743598675043393233726870416684054894389M-46"
      call fmst2m(st, c(91))
      st = " 1.383747146950471434825293091024083280747013661478053604841911598" //  &
           "022310276318757265593640560735257184999994184693906229160627176389" //  &
           "15615636692838842344470182112269725385554047172321124664394879685510285M-46"
      call fmst2m(st, c(92))
      st = " 4.562893817897541724781950430442496378260377512288497109803666040" //  &
           "621854629198431249084998659248405128970881921614143709856471314566" //  &
           "71187340235712918767373708561614114398918238461996856137728111624669887M-47"
      call fmst2m(st, c(93))
      st = " 1.504784131433391793257248428485220036318516611757628814861273953" //  &
           "241786001999746507693533747202375916340889614020197821617964401281" //  &
           "09223232430673952549932990159444752780504141754928914375319317506618075M-47"
      call fmst2m(st, c(94))
      st = " 4.963147661567547539987958807734897162902530398116312148944960055" //  &
           "796268377992054321453624007551095855206124470724586679336263613115" //  &
           "89091300344790164050318056261092913116282166570730942288235067198317928M-48"
      call fmst2m(st, c(95))
      st = " 1.637149402252630927456890226306016168030553715912510338166421018" //  &
           "082250171874970269061229738963393420354696075864382273796383465054" //  &
           "54500820509537840793087307985392209620656037379007014938893681782187286M-48"
      call fmst2m(st, c(96))
      st = " 5.400905244543393186874620589431418037639831941879628434368248998" //  &
           "722906347036053715166862260092049668825631280975790017953688626636" //  &
           "15617148734065300820447033765217546328421226646834925099741473350545005M-49"
      call fmst2m(st, c(97))
      st = " 1.781931322178944118647377674747852837095476406297808108639777839" //  &
           "710695191748931947375083891115191186633327477558489708276330078077" //  &
           "84355945700557484952518727190790584478520941307748997078811897348262566M-49"
      call fmst2m(st, c(98))
      st = " 5.879773386313522948360905422632431077145168395771420120384935880" //  &
           "807587039058575601777312600437920559716301465154041152414856698220" //  &
           "03215044402130085493835602372831521053966369492752843371900098859590805M-50"
      call fmst2m(st, c(99))
      st = " 1.940325217483255139116418908036918257576300407306275798031334364" //  &
           "409600080862034828483316076995017274377332356098893076821893973234" //  &
           "40382503373462356947628021148992374363794778068565614630007284818985556M-50"
      call fmst2m(st, c(100))
      st = " 6.403713589053133873710962618711106281414140108122214547412024301" //  &
           "692917083153216025874647060197659674432573844849077628829246217574" //  &
           "60249742706649007645817489620506941120553080709097100788465375868770515M-51"
      call fmst2m(st, c(101))
      st = " 2.113644027759240612416047225977851974737748960538792675174058961" //  &
           "161021976645079782965719680309463063367873086114357869089879642560" //  &
           "91741774488093918815994311848793042306225840389086585033999559719325383M-51"
      call fmst2m(st, c(102))
      st = " 6.977077373185528123141201643198765846940778946562652437177053180" //  &
           "068202610894634761485494475059094517798144344611412525007119040744" //  &
           "47619138364742657951321893292966244857904586187576743960389378098756527M-52"
      call fmst2m(st, c(103))
      st = " 2.303330030250272718045226178470266630636882414669936525013604526" //  &
           "663877295122333165527547705932002051525319167095677157791507288736" //  &
           "64026571366295683502084852088545059435402597033343652161501470364354290M-52"
      call fmst2m(st, c(104))
      st = " 7.604645179238802714709378571216485567328230281028063584140295724" //  &
           "376585957946481904384646230934323963536666254241381678030728396763" //  &
           "58178737195689600607109967321748886837389095954530241223910865091320330M-53"
      call fmst2m(st, c(105))
      st = " 2.510967747861821044453112929896090858886255004999542279673792434" //  &
           "537208309423086735805390141224743694821441092754412288490320556507" //  &
           "90129078122051056660926795028903236517945321893911606739679056323908271M-53"
      call fmst2m(st, c(106))
      st = " 8.291669198546705061835867356103780154660596199979498029660459478" //  &
           "188005146704679300246430992623307755626947749069085299081605791921" //  &
           "74019998848391467377542111031322996337770209654839668772234104877607677M-54"
      call fmst2m(st, c(107))
      st = " 2.738298161248419586570035179837181952253572874107137240705415238" //  &
           "006265247194645939919863261646299211192029639655806078478918931977" //  &
           "00593190887265237361465699889511989159926295238433577049420127008639310M-54"
      call fmst2m(st, c(108))
      st = " 9.043920532563515029285236381202044755606494352793597664587001938" //  &
           "974036674170391738386361814188362066318933595609565234700634164118" //  &
           "70487847122956051574723330382189769818956900012640799709823774379723508M-55"
      call fmst2m(st, c(109))
      st = " 2.987234357725506677158331533521097034607039220763832901730464971" //  &
           "787758443274701147417241273125203557371693807601776736455273977366" //  &
           "05803089099448475489215616434095538698506543339535511526713482057801648M-55"
      call fmst2m(st, c(110))
      st = " 9.867741121615743267416100354228158234050959334204884456346592478" //  &
           "319239204688512319808683885900238794688432245788378036339502910311" //  &
           "95256267366461853050971201508370739481479021507935296576188223198846781M-56"
      call fmst2m(st, c(111))
      st = " 3.259878763390904147253084369202388245824453621447959285540458582" //  &
           "736012876275248713545534462435398177897630905297446122213135317168" //  &
           "82679622090783961983706156224847005117892642811444666243882001638133683M-56"
      call fmst2m(st, c(112))
      st = " 1.077010092919706009412412261729007614456466446787757717767031010" //  &
           "139026034411384632610387807051427675075586800080476142293720773922" //  &
           "20272670887152593395631417854201652294534598158204732976231392133784649M-56"
      call fmst2m(st, c(113))
      st = " 3.558542119880893194099946299932858465278352616190909402621150713" //  &
           "569585013772896155460681917876143100438779403865861290242704606012" //  &
           "88545096496889803741553260243082158570103416935736970008787448980973697M-57"
      call fmst2m(st, c(114))
      st = " 1.175866091786728245112848768043708292858352425382756439383320272" //  &
           "578862130652141603853077265569964741389836105657992359851950676535" //  &
           "04338748169984545024264075261487170842373741152762109550508117751868574M-57"
      call fmst2m(st, c(115))
      st = " 3.885764383777977106238860501037171757872128590510931610888692650" //  &
           "910285334868201439319749230933970529786352570062128138073985716014" //  &
           "24775116761936632328170508559558303761107738144547614997375397249406443M-58"
      call fmst2m(st, c(116))
      st = " 1.284184240792720746713802455067655929838349505783919451560002320" //  &
           "126603715783906155689196669126320213369826150934215436793861556561" //  &
           "85972584789613262065820990433273679374866590546774541475968702317884481M-58"
      call fmst2m(st, c(117))
      st = " 4.244337744992888045444183568112374868793650501308024498979691533" //  &
           "890762987246535790550234061933625766554201413681894303054318079987" //  &
           "15016824304537959514257416420938167100044999559848904364273216745412168M-59"
      call fmst2m(st, c(118))
      st = " 1.402890347084483369665088764818551961487912000082962187928218261" //  &
           "785089551297393342668713450909249794752403435631477836303274921114" //  &
           "55362046946784217832779503423966063510800253866244156993968505509787734M-59"
      call fmst2m(st, c(119))
      st = " 4.637331980640374010893092224461382977846892054658359797965131441" //  &
           "456865261185257586124099243621668370219467668437596174204742705530" //  &
           "83668639386769597559944266590300361763651777592096905886759195912398458M-60"
      call fmst2m(st, c(120))
      st = " 1.533002307649710027030813938667476629444482989777771349009392774" //  &
           "898001472950267391452028201567335345539750749325735733749863033002" //  &
           "69548753895579308292780126786018722213349444264135999363029954583214006M-60"
      call fmst2m(st, c(121))
      st = " 5.068122383213521254015903956436646089688648450514341540538884175" //  &
           "869469050644753957457320055403310802554634158264858859825705672789" //  &
           "91662731199394270951038339532656379827609414997054764442302975300731162M-61"
      call fmst2m(st, c(122))
      st = " 1.675639378731841475760363897846833007051598415558153712467179977" //  &
           "432925958506220080221518370999946501032024092613108461163906099341" //  &
           "82913060234132996850622927932164528031237880466865308048851412708423659M-61"
      call fmst2m(st, c(123))
      st = " 5.540420526452055898116485439538895779663375849440317942175183295" //  &
           "232404269513749797742436944684450241469393462030971608777003451754" //  &
           "24373370189591105970695273793446260615786377827169998532420885870021362M-62"
      call fmst2m(st, c(124))
      st = " 1.832032387413479669586574511502151686557921294324566012744100766" //  &
           "650543443902590363016386993218294974037346220641170740186656299364" //  &
           "35042400328594920807120027126914313294894904628053322733053994091135028M-62"
      call fmst2m(st, c(125))
      st = " 6.058308159436109652922013909249826504043342021872382519752917607" //  &
           "688622870375413804432273155114051562335231336139713200850863559312" //  &
           "92844948695425942146384859065918295663347978412467638683301971137894309M-63"
      call fmst2m(st, c(126))
      st = " 2.003534981860760581951442341610686092565547269730489837317963845" //  &
           "620455952950683642101005961045434369116586359058385158147557980542" //  &
           "11638367930496346396938524050401454422736023568038546321742832881166705M-63"
      call fmst2m(st, c(127))
      st = " 6.626274549383244408116266205294449505997555094384610044245319246" //  &
           "030550314415978028317676220529142615194623162680155029534077714720" //  &
           "63797428182476797631017411639144206566456794143210250637764789933866701M-64"
      call fmst2m(st, c(128))
      st = " 2.191636026669393443536074125395262735461777636080096892966692835" //  &
           "413006758477349117295402033106637857465621733449271837481434101507" //  &
           "59193133722553066298412025354918228064474978225340425161474540247412694M-64"
      call fmst2m(st, c(129))
      st = " 7.249257626675685867142261929211249822372411007081385395432760399" //  &
           "456066369908496028419563900512609131853389393280859633882497500591" //  &
           "28369747912197909028518904445517467819162688494876358555633787825066496M-65"
      call fmst2m(st, c(130))
      st = " 2.397973260732415138001223113122005679063725787264243397335901198" //  &
           "698321759116583811702053382300628630291425464911847398771216167493" //  &
           "18664813035306053986440746004247939745287869514463237143921611339050020M-65"
      call fmst2m(st, c(131))
      st = " 7.932689322119858073349921363235515368474949336836316506068072766" //  &
           "546624999168511473276482943408448126386413211956579156398290157039" //  &
           "88529011287347733351088257288781160869062308105566110665892110886142277M-66"
      call fmst2m(st, c(132))
      st = " 2.624348347167471822677772594888450230485642320545658876475286310" //  &
           "055771115343647866370773378641890749683248791810064619124781313040" //  &
           "39655556535083837498441324798836325222767712349195699260834872702802847M-66"
      call fmst2m(st, c(133))
      st = " 8.682545526698351997704083743124967023750577000605836108664866495" //  &
           "160128302689923574758622135053769717872441667362682928425542104432" //  &
           "66558278030150559101531475636719213636150787481043024038745922498650758M-67"
      call fmst2m(st, c(134))
      st = " 2.872743458216244845484563580154599626121124250656149184804291244" //  &
           "427536302457588668570923419780410649470498203175250876036620935134" //  &
           "64093415505201626499567870169234200516491544807537627932184985980888123M-67"
      call fmst2m(st, c(135))
      st = " 9.505401148509633647613758343551012792444980481501235466486933914" //  &
           "265907192633387738944843898328544931131135589195243791819300008378" //  &
           "30106163188879275241944204168059306729141838253133216063222884137562944M-68"
      call fmst2m(st, c(136))
      st = " 3.145339552791508936206896052221534466211147212254477273131941831" //  &
           "512277630670890754387204205624927221141107680833883854535942453092" //  &
           "60656013674364311521617359444957869733091866905428746679446531471773156M-68"
      call fmst2m(st, c(137))
      st = " 1.040849079063856819895496485119313778206922325391046796592400903" //  &
           "438704272609812766874547219070728506140021601572906667448239089200" //  &
           "17410157182972609752570220147431398012450147044399178635448118006623721M-68"
      call fmst2m(st, c(138))
      st = " 3.444536520642979399033002670688986667656937918697573314979061458" //  &
           "919964194677753822933252127653285396401597050249715424969440622451" //  &
           "73896561346967424455299327210221686160915541794905027119226479284135693M-69"
      call fmst2m(st, c(139))
      st = " 1.139977562784224133216265743521281955028156700765266508712800967" //  &
           "848831883748374530246175200161064830753252846881090666971108606926" //  &
           "84608508079113604819022125345471848395222113457719457394701080327610407M-69"
      call fmst2m(st, c(140))
      st = " 3.772975385101451028879155185726947819831206176127486435982734889" //  &
           "252802708561571080135558366656253315506022065599884895931599609988" //  &
           "98731864477490133149597217959601291802546927566215903357984266276909864M-70"
      call fmst2m(st, c(141))
      st = " 1.248801711970198579225912046586232268562301776030667048611621632" //  &
           "465628194502888533349817467748088996697006070450714611279370044918" //  &
           "58919189486279287758063253685579639080251285807174486835285307209688606M-70"
      call fmst2m(st, c(142))
      st = " 4.133562776218372917707434109108607724393370061767622907143777544" //  &
           "878888798728408345872714164317266154909605719593487267350335578853" //  &
           "93934162223974482538311480054078977999291506457599828857537063130739588M-71"
      call fmst2m(st, c(143))
      st = " 1.368285826387100294053441225148146980381219160778152569563356532" //  &
           "725964967014895839699806485363534911338607141236453063094587484467" //  &
           "66893839721308893253877636532577439328086482952402541207429714733339152M-71"
      call fmst2m(st, c(144))
      st = " 4.529497908040056144676469409188309794321421988959637669575342522" //  &
           "116514782664298860106021153887341542873949848678983271520138033675" //  &
           "79495262187662834453100157981375055331539396277574179995789688030466410M-72"
      call fmst2m(st, c(145))
      st = " 1.499491316588603061306884181776653655545748070661401693040695069" //  &
           "053696590521220167504120163356893714569898088385033607285458815124" //  &
           "35872442007725124320485376254435248066997500475451183595538404386947583M-72"
      call fmst2m(st, c(146))
      st = " 4.964302317957733490235530469745361589786652164074076392491530822" //  &
           "224428024784809035798407669056637309772933378074926314581475254129" //  &
           "86616192319821312175154821971972127073013580628971532023157018109185362M-73"
      call fmst2m(st, c(147))
      st = " 1.643586578242763114833507846160154608374622266203265530676336751" //  &
           "694818277497961440503117616606491252858317008970780154993421364483" //  &
           "78099010504715300393033107665724003113140293042459780949957368683890959M-73"
      call fmst2m(st, c(148))
      st = " 5.441852652794830894311470706477538221849565053218214215349180811" //  &
           "064294636030553844028448630827867613349267037250477900533924480506" //  &
           "82460851565237813605665759673888889710736177209599734575799006709861746M-74"
      call fmst2m(st, c(149))
      st = " 1.801857878369844007118484883880761798414766692597217574900046197" //  &
           "360262152730609587228705384643316107409543482294232641569660175011" //  &
           "79519154781224338457932814908298988696375455365226741142441036489254992M-74"
      call fmst2m(st, c(150))
      st = " 5.966416815794185453763830530254737531064047428340471319398688069" //  &
           "007552470288020366752010161084016011730287854271568912859552337203" //  &
           "41453128747443716412531087761908717466819377449540627696187031359721010M-75"
      call fmst2m(st, c(151))
      st = " 1.975721357861671060279948825620105307975444162740595055137362881" //  &
           "848246417197234999961571849669754470375412457219647332906833168922" //  &
           "68071772240997929407621098946132582262214118221958928604276333611006417M-75"
      call fmst2m(st, c(152))
      st = " 6.542693821241263641717538449532346497940622472878710087928587547" //  &
           "135890790293782933631752384033436259896798958027902059478261401316" //  &
           "51898760968041471004067759299223993845873964885693255185054469449588983M-76"
      call fmst2m(st, c(153))
      st = " 2.166736265476002894293516585134968365492470343594290484160425853" //  &
           "634757103189631345447367869704134537187600769397997799583921963715" //  &
           "66991272921221434244459511112119776440312273606272563588060032932425347M-76"
      call fmst2m(st, c(154))
      st = " 7.175857739425902058446366213267163717870002184056285139492810907" //  &
           "165151388326241994224874557956711286862577806517065215553936524682" //  &
           "13250466673505382651861797375923534026910443196181011966541606084919661M-77"
      call fmst2m(st, c(155))
      st = " 2.376619550450886365485623751880291284047099214872959375092451724" //  &
           "342950586001550942436415678973426556922327249108654045209317268184" //  &
           "82082947451080863768578126711240615665895962605984771627264126442044223M-77"
      call fmst2m(st, c(156))
      st = " 7.871606154359623630068573317612764902762392638995019862408631291" //  &
           "008061939353640535233024537980362873819209185759931590349366135182" //  &
           "14586054502659862300174333186280592070419277216786077915707312111770211M-78"
      call fmst2m(st, c(157))
      st = " 2.607261954081141160150797999367222244498208263011867403220673096" //  &
           "800582313576057737826578818707489920864730296871775420774049041364" //  &
           "79431809641123667403151516016216413258555378265536018764789936965838617M-78"
      call fmst2m(st, c(158))
      st = " 8.636213600520341807753750476732474442820999819309686673192125811" //  &
           "444182648267187160168499080611902341484327275294303024770270222135" //  &
           "59223769662625003083305590998863860730206646251762971580585644914132026M-79"
      call fmst2m(st, c(159))
      st = " 2.860745755172363223898311967180521130986380848162555027528393662" //  &
           "915983444061966784564310775020004680613450195420353857249494047775" //  &
           "73818249551580545509645629320363387364925214204842915131007525800466880M-79"
      call fmst2m(st, c(160))
      st = " 9.476590493324598214557576012349336522703693594124571054279111616" //  &
           "798531592192686914431167230715058815630334239433475110837262090138" //  &
           "33301645943249512127076707890530532222551337127599066189782985037412169M-80"
      call fmst2m(st, c(161))
      st = " 3.139364340381194056746408425980351704553046571903970795447364975" //  &
           "882887158738580119004810652625014397096678884159435971472598704137" //  &
           "54339572525201214956186891250608510839418632104354221549889413573604846M-80"
      call fmst2m(st, c(162))
      st = " 1.040034812150826026710373679719002963399053176200107466780745572" //  &
           "000065388516270021753222010998681619656807884101412895225381983273" //  &
           "03585371769586543699202508103518904235084186177627200599704020839402387M-80"
      call fmst2m(st, c(163))
      st = " 3.445643788223265129236923220146442325334098948153988879546081638" //  &
           "282932221486522368247949883425191269877715114051526159278376683546" //  &
           "54478379087683377717562788666572331232941361970188301510421846831598762M-81"
      call fmst2m(st, c(164))
      st = " 1.141587032865869378324299022323731794401778416670178670987733185" //  &
           "814446261010130113286467916958273916598065282809528144498877625408" //  &
           "51786835211126241486118129987351739916755135907809166050772678111097018M-81"
      call fmst2m(st, c(165))
      st = " 3.782366675158000172438186031560392817938018879105893232376963665" //  &
           "758045582935962507746785156805849115039876109316259116490068195664" //  &
           "22154600940352929680886350387924367311407243398433694317491879496500728M-82"
      call fmst2m(st, c(166))
      st = " 1.253239257637571101011205444147249909041208363526150999161557930" //  &
           "530122175707904339132697555874221097743565894565280785124100424739" //  &
           "12341727673603475533755872933253879415498534305672767854397632835354647M-82"
      call fmst2m(st, c(167))
      st = " 4.152598333838791095457780574441131208990623618377645706663873970" //  &
           "409219842573498216786365580094065012089293058629821760308697172924" //  &
           "25649947447826939431820718042482922400940273337175959594512550863844028M-83"
      call fmst2m(st, c(168))
      st = " 1.376008915348001441142775089390756952291415569331728264389528531" //  &
           "840532583703944779638084800244642630871018954424019239838171107774" //  &
           "08455142709222529998017403722473530832343485779953472597270935996990435M-83"
      call fmst2m(st, c(169))
      st = " 4.559715817525503407894512559569944355041250549999373143331298588" //  &
           "042902011136449984273691723063087171534265607563490346238292992622" //  &
           "43694334064073133108518335548127416155718965768703096927698154664008186M-84"
      call fmst2m(st, c(170))
      st = " 1.511016937693380717359102098553590521576253151812935620881255183" //  &
           "676747573506694189735416802045982192198119977018955499638830448943" //  &
           "99139906962195905603908709462882471176378436053656496936740374119626233M-84"
      call fmst2m(st, c(171))
      st = " 5.007439851661721308524939431791288925473304269198627995505717966" //  &
           "042698143618956580402359781596868665105789229557574207071195578504" //  &
           "34784490998580851675508563655209200033656690762499193037679456058834741M-85"
      call fmst2m(st, c(172))
      st = " 1.659498369200591197022274845367449670587666822869779371596678693" //  &
           "434849663818573237359515507605355977016921178742109368988856546946" //  &
           "53987167820516459592809407463255771494757163532540963217681912265486931M-85"
      call fmst2m(st, c(173))
      st = " 5.499870074123138278587253453863123198782240874965235399880295435" //  &
           "189868323747896824633224719144787009990778913499316775325760318709" //  &
           "84151200565534853443611640092085568829894647596561585415506088061475496M-86"
      call fmst2m(st, c(174))
      st = " 1.822814104787822173171970582684126136729373783986451680232463776" //  &
           "995284747235440436579147791215434063408671873139502336867256882493" //  &
           "52907684446136684618467464533340860151713404827732293178363163584088691M-86"
      call fmst2m(st, c(175))
      st = " 6.041524022149206216514749478207951898414628220569359023936273098" //  &
           "431129999705544414314317322005670901754042242107672777454004410860" //  &
           "23728922114946882252911249911639377024536952401619252235639914064675297M-87"
      call fmst2m(st, c(176))
      st = " 2.002463416328745336974658582823885810920380274053175588795927666" //  &
           "714050828711674000372182654975669270167646317724425684411171485274" //  &
           "63888736139146918349514677140009027878433312540016907441088200168772901M-87"
      call fmst2m(st, c(177))
      st = " 6.637378732657623720229439419358377518409139927005258254140285180" //  &
           "914849963099373381335080302807182958739736822642496046941955995156" //  &
           "47580543357281795983541588632113533651700800850371216214989020246965499M-88"
      call fmst2m(st, c(178))
      st = " 2.200102767530555026604991024957956952823900377482112800591761008" //  &
           "660084843014248387788035100004987819764909462237889078992186315330" //  &
           "60158332375064476625052936559137839280476740402400480416136592265795082M-88"
      call fmst2m(st, c(179))
      st = " 7.292933318740382159132169272746181235841016457994964554263454208" //  &
           "492201073732473833848574569619679758849986320998185690723690770932" //  &
           "41462402016226262443880472321890006685113024701301315267987027615012503M-89"
      call fmst2m(st, c(180))
      st = " 2.417513092202831923304643749980362419472891672259150932920867637" //  &
           "832384236931175709234025174145241123797309720555077484497334156484" //  &
           "70273284353674851435852469743857826682908838509841004308849506350039697M-89"
      call fmst2m(st, c(181))
      st = " 8.014099523920820532691698949493969623669374514095447937521752186" //  &
           "098803953643697356090844942590659454999844318173870304557001940555" //  &
           "42525475893078866822127874440270390910047929036227162217460866884004221M-90"
      call fmst2m(st, c(182))
      st = " 2.657079598189421611225399332494614836172370837056707080573411081" //  &
           "077314111961101307612637519570469581636094934124837596398237792257" //  &
           "42836805118176886050043438632186029854385799944806006391590874149011746M-90"
      call fmst2m(st, c(183))
      st = " 8.808801832338891822547417575762619398673718065912507825752674890" //  &
           "111044965171749095170501464417801064468367983054179217820785485005" //  &
           "97684256880162841894825031174637280632623961080123218247631394854404406M-91"
      call fmst2m(st, c(184))
      st = " 2.917871827472767744801985504187470385461224411949197505438209784" //  &
           "552995184888997609387528889784137922680585612807183342956402094608" //  &
           "01943529407670923901992925226137852941513101357366936300944346484030974M-91"
      call fmst2m(st, c(185))
      st = " 9.673909686763801191886681572020182885252222531903039060187477306" //  &
           "277095817639315200476096440352681128855627885542339760940019503157" //  &
           "11902076792371625818162067652299279665268178569377108196296372219380510M-92"
      call fmst2m(st, c(186))
      st = " 3.225317339965144219466139388048879231367171359221844461940917969" //  &
           "250112356759739827102732375554724422636709224874307206769709880215" //  &
           "16808317218174915989091357841379986431733603301918969106178493014736385M-92"
      call fmst2m(st, c(187))
      st = " 1.069410576590312480755235192735211157086107353088423400669923656" //  &
           "677428694478915259443669100953558846603833879903904822845298497420" //  &
           "71143211982703738257538091316334035362562254796294606412951506359364815M-92"
      call fmst2m(st, c(188))
      st = " 3.436230247075590625300285568770398628374034305782922085529568066" //  &
           "268230300872273810320168642643487560176713818087616304872506761508" //  &
           "46310739710431810178913824922315129263580429076241251322833952169352928M-93"
      call fmst2m(st, c(189))
      st = " 1.139260014627810596016761865641404521146852141822567620126418127" //  &
           "549772266075482248466335323616377804969776249070578213315603095439" //  &
           "66803478295001515092190429139446518480363880483757347561526976211621457M-93"
      call fmst2m(st, c(190))
      st = " 4.343070458433874603042514728830057473477940614398096372223763568" //  &
           "372476710887610850250214061613248238834003723272762897566055896217" //  &
           "49542103193171278645483518744915143059042740324768324837960269146747307M-94"
      call fmst2m(st, c(191))
      st = " 1.440667367566540553672654836910082201055609375400592746447756244" //  &
           "176284526124155943246633922603816785133029633668454281491778597874" //  &
           "45028943290797079216498815025085467176654584077190605132981537168513742M-94"
      call fmst2m(st, c(192))
      st = " 2.384816222561370113514027430584139466337689187141928475880205055" //  &
           "969980605519512189876139389796445441195296187421190296481218115986" //  &
           "36517542721807591974162349259651427967273755554095270040863620533051177M-95"
      call fmst2m(st, c(193))
      st = " 7.891080859500628750618564157769100520532680589132484946442038829" //  &
           "299825933371426348457257350822254140519284945880389565858120333678" //  &
           "80845449586455112014663973071181240064800376338635797974159751681049875M-96"
      call fmst2m(st, c(194))
      st = " 1.059066626703749406081450817511793688125712964427249229411570236" //  &
           "550112600348902027013047427990927965524515088187243012802502472093" //  &
           "22261048153901594967680556527547070843534915035469463356163636215773539M-95"
      call fmst2m(st, c(195))
      st = " 3.516498583838005375775193339944623281315914658931041130875008620" //  &
           "636983702886095342086986357214180450129972642316547945003279723791" //  &
           "81126461652035134771983947459420613651499692168433361308886876030693800M-96"
      call fmst2m(st, c(196))

      ndig = ndsave

      end subroutine fmlngm_c

      subroutine fmlngm_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc)

!  Method selection for computing ln(gamma(ma)).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(15), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc

      double precision :: x, z
      integer :: kfl, nmethd
      logical, external :: fmcomp

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, ndig)
      call fmeq(mxy(1), mxy(13))
      n_acc = nint(ndig*alogm2)

!             Near zero Gamma(x) is about 1/x.

      if (mxy(13)%mp(2) < (-ndig-3)) then
          call fmln(mxy(13), mresult)
          call fmnegate(mresult)
          return
      endif

!             Check for special cases.

      if (mxy(1)%mp(1) < 0) then
          kfl = 0
          if (mxy(1)%mp(2) <= ndsave) then
              call fmint(mxy(13), mxy(9))
              if (fmcomp(mxy(13), '==', mxy(9))) kfl = -4
              call fmi2m(2, mxy(10))
              mxy(9)%mp(1) = 1
              call fmmod(mxy(9), mxy(10), mxy(5))
              call fmeq(mxy(5), mxy(10))
              if (mxy(10)%mp(3) == 0) kfl = -4
          else
              kfl = -4
          endif
          if (kfl /= 0) then
              call fmunknown(mresult)
              kflag = -4
              retry = .false.
              return
          else
              call fmi2m(1, mxy(5))
              call fmsub_r2(mxy(5), mxy(13))
          endif
      endif

!             Determine which method to use.

!             nmethd = 1 means use the polynomial approximation,
!                    = 2 means use the asymptotic series.

      nmethd = 1
      call fmnint(mxy(13), mxy(2))
      call fmsub(mxy(13), mxy(2), mxy(6))
      call fmm2dp(mxy(6), z)
      z = max(abs(z), 1.0d-50)
      if (kflag /= 0 .or. abs(z) >= 1) then
          nmethd = 2
      else
          if (190*log(z) - 90*dlogtn >= -ndig*dlogmb .or. -190*dlogtn >= -ndig*dlogmb) then
              nmethd = 2
          endif
      endif
      call fmm2dp(mxy(13), x)
      if (kflag /= 0) then
          nmethd = 2
      else if (nmethd == 1) then
          if (x > 35 - 8*log(z) + ndig*dlogmb/(2.5*dlogtn) .or. x > 250) nmethd = 2
      endif

      if (nmethd == 1) then
          call fmlngm_m1(mxy, mresult, ndsave, numtry, retry, n_acc, z)
      else if (nmethd == 2) then
          call fmlngm_m2(mxy, mresult, retry, n_acc)
      endif

      return
      end subroutine fmlngm_m

      subroutine fmlngm_m1(mxy, mresult, ndsave, numtry, retry, n_acc, z)

!  Method 1 for computing ln(gamma(ma)).

      use fmvals
      implicit none

      type(multi) :: mxy(15), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      double precision :: z
      intent (in) :: numtry, ndsave, z
      intent (inout) :: mxy, mresult, retry, n_acc

      integer :: j, j2, k, k0, k1, k2, kl, krsave, ksign, lshift, ndsav1, nterm
      type(multi), save :: mjsums(ljsums), c(0:196)
      integer, save :: ndig_c = 0
      real (kind(1.0d0)), save :: mbase_c = 0
      logical, external :: fmcomp


!             Method 1.  Use the polynomial c(0) + c(1)*(x-3) + ... + c(196)*(x-3)**196

      if (mxy(1)%mp(1) > 0 .and. ndsave+ngrd52 < ndig .and. numtry == 0)  &
          ndig = ndsave + ngrd52
      n_acc = nint(ndig*alogm2)
      call fmm2i(mxy(2), lshift)
      lshift = lshift - 3
      if (ndig_c < ndig .or. mbase_c /= mbase) then
          call fmlngm_c(ndig_c, mbase_c, c)
      endif
      j2 = 0.42*log(z) + 7.9
      j2 = max(2, min(j2+mod(j2, 2), ljsums))
      ndsav1 = ndig
      do j = 1, j2
         call fmeq(c(j+1), mjsums(j))
      enddo
      call fmipwr(mxy(6), j2, mxy(5))
      call fmeq(mxy(5), mxy(7))
      nterm = j2 + 1
      kl = 1
      do while (kl == 1)
         if (nterm > j2+1) call fmcsmpy_r1(mxy(7), mxy(5))
         do j = 1, j2
            nterm = nterm + 1
            call fmeq(mxy(7), mxy(4))
            call fmcsmpy_r1(mxy(4), c(nterm))
            ndig = ndsav1
            call fmcsaddnn_r1(mjsums(j), mxy(4))
            if (kflag /= 0 .or. nterm == 196) then
                kl = 0
                exit
            endif
            ndig = ndsav1 - int(mjsums(j)%mp(2)-mxy(4)%mp(2))
            ndig = min(ndsav1, ndig)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         enddo
      enddo
      kflag = 0
      call fmcsnsums(j2, mjsums)
      ndig = ndsav1
      if (nterm == 196) then
          call fmlngm_m2(mxy, mresult, retry, n_acc)
          return
      endif
      call fmeq(mjsums(j2), mxy(8))
      call fmeq(mxy(6), mxy(3))
      call fmnegate(mxy(3))
      do j = 2, j2
         call fmcsmpy_r1(mxy(8), mxy(3))
         call fmcsadd_r1(mxy(8), mjsums(j2-j+1))
      enddo
      call fmsqr(mxy(6), mxy(3))
      call fmcsmpy_r1(mxy(8), mxy(3))
      call fmadd(mxy(8), c(0), mxy(10))
      call fmmpy(mxy(6), c(1), mxy(3))
      call fmadd_r1(mxy(10), mxy(3))

!             Recover from using a shifted argument.

      if (lshift < 0) then
          call fmeq(mxy(13), mxy(3))
          call fmeq(mxy(13), mxy(14))
          do j = 2, -lshift
             call fmaddi(mxy(14), 1)
             call fmmpy_r1(mxy(3), mxy(14))
          enddo
          call fmln(mxy(3), mxy(4))
          call fmsub(mxy(10), mxy(4), mxy(3))
          call fmcancel(mxy(10), mxy(4), mxy(3), k)
          n_acc = n_acc - k
          call fmeq(mxy(3), mxy(10))
      endif
      if (lshift > 0) then
          if (mod(lshift, 4) == 0) then
              call fmi2m(1, mxy(3))
              call fmeq(mxy(6), mxy(14))
              call fmaddi(mxy(14), 3)
          else
              call fmeq(mxy(6), mxy(3))
              call fmaddi(mxy(3), 3)
              call fmeq(mxy(3), mxy(14))
              do j = 1, mod(lshift, 4)-1
                 call fmaddi(mxy(14), 1)
                 call fmmpy_r1(mxy(3), mxy(14))
              enddo
              call fmaddi(mxy(14), 1)
          endif
          lshift = lshift - mod(lshift, 4)

!             The product z*(z+1)*...*(z+lshift-1) is computed four terms at a time to reduce
!             the number of fmmpy calls.

!             mxy(14) is z
!             mxy(6) is z**2
!             mxy(7) is z**3
!             mxy(8) is (z+k)*...*(z+k+3)
!             mxy(11) is the current product

          call fmi2m(1, mxy(11))
          if (lshift > 0) then
              call fmsqr(mxy(14), mxy(6))
              call fmmpy(mxy(14), mxy(6), mxy(7))
              call fmsqr(mxy(6), mxy(8))
              call fmcsmpyi(mxy(7), 6, mxy(12))
              call fmcsadd_r1(mxy(8), mxy(12))
              call fmcsmpyi(mxy(6), 11, mxy(12))
              call fmcsadd_r1(mxy(8), mxy(12))
              call fmcsmpyi(mxy(14), 6, mxy(12))
              call fmcsadd_r1(mxy(8), mxy(12))
              call fmeq(mxy(8), mxy(11))
              call fmcsmpyi_r1(mxy(7), 16)
              do k = 0, lshift-8, 4
                 call fmcsadd_r1(mxy(8), mxy(7))
                 k2 = 24*(2*k + 7)
                 call fmcsmpyi(mxy(6), k2, mxy(12))
                 call fmcsadd_r1(mxy(8), mxy(12))
                 if (k <= sqrt(real(intmax)/49.0)) then
                     k1 = 8*(6*k*k + 42*k + 79)
                     call fmcsmpyi(mxy(14), k1, mxy(12))
                     call fmcsadd_r1(mxy(8), mxy(12))
                 else
                     k1 = 48*k
                     call fmcsmpyi(mxy(14), k1, mxy(12))
                     call fmcsmpyi_r1(mxy(12), k)
                     call fmcsadd_r1(mxy(8), mxy(12))
                     k1 = 336*k + 632
                     call fmcsmpyi(mxy(14), k1, mxy(12))
                     call fmcsadd_r1(mxy(8), mxy(12))
                 endif
                 if (k <= (real(intmax)/17.0)**0.3333) then
                     k0 = 8*(2*k + 7)*(k*k + 7*k + 15)
                     call fmaddi(mxy(8), k0)
                 else if (k <= sqrt(real(intmax)*0.9)) then
                     k0 = 8*(2*k + 7)
                     call fmi2m(k0, mxy(12))
                     k0 = k*k + 7*k + 15
                     call fmcsmpyi_r1(mxy(12), k0)
                     call fmcsadd_r1(mxy(8), mxy(12))
                 else
                     k0 = 8*(2*k + 7)
                     call fmi2m(k0, mxy(12))
                     call fmcsmpyi(mxy(12), k, mxy(9))
                     call fmcsmpyi_r1(mxy(9), k)
                     call fmcsadd_r1(mxy(8), mxy(9))
                     k0 = 7*k + 15
                     call fmcsmpyi_r1(mxy(12), k0)
                     call fmcsadd_r1(mxy(8), mxy(12))
                 endif
                 call fmcsmpy_r1(mxy(11), mxy(8))
              enddo
          endif
          call fmmpy_r1(mxy(11), mxy(3))
          call fmln(mxy(11), mxy(4))
          call fmadd(mxy(10), mxy(4), mxy(3))
          call fmcancel(mxy(10), mxy(4), mxy(3), k)
          n_acc = n_acc - k
          call fmeq(mxy(3), mxy(10))
      endif

!             Use the reflection formula if ma was negative.

      if (mxy(1)%mp(1) < 0) then

!             Reduce the argument before multiplying by pi.

          call fmnint(mxy(13), mxy(6))
          call fmdivi(mxy(6), 2, mxy(7))
          call fmint(mxy(7), mxy(2))
          call fmmpyi(mxy(2), 2, mxy(8))
          ksign = -1
          if (fmcomp(mxy(6), '==', mxy(8))) ksign = 1
          call fmsub(mxy(13), mxy(6), mxy(9))
          call fmcancel(mxy(13), mxy(6), mxy(9), k)
          n_acc = n_acc - k
          call fmpi(mxy(11))
          call fmmpy_r1(mxy(11), mxy(9))
          krsave = krad
          krad = 1
          call fmsin(mxy(11), mxy(3))
          mxy(3)%mp(1) = ksign*mxy(3)%mp(1)
          krad = krsave
          call fmpi(mxy(11))
          call fmdiv_r2(mxy(11), mxy(3))
          call fmln(mxy(3), mxy(4))
          call fmsub(mxy(4), mxy(10), mxy(3))
          call fmcancel(mxy(4), mxy(10), mxy(3), k)
          n_acc = n_acc - k
          call fmeq(mxy(3), mxy(10))
      endif

      call fmeq(mxy(10), mresult)

      return
      end subroutine fmlngm_m1

      subroutine fmlngm_m2(mxy, mresult, retry, n_acc)

!  Method 2 for computing ln(gamma(ma)).

      use fmvals
      implicit none

      type(multi) :: mxy(15), mresult
      logical :: retry
      integer :: n_acc
      intent (inout) :: mxy, mresult, retry, n_acc

      integer :: inta, j, j2, k, k0, k1, k2, kl, krsave, ksign, kwrnsv, lshift,  &
                 ndenom, ndig2, ndmb, ndsav1, ndsv, nmxdif, nterm
      character(155) :: string
      character :: st2(155)
      type(multi), save :: mjsums(ljsums)
      logical, external :: fmcomp

!             Method 2.  Use the b(2n)/(2n*(2n-1)*x**(2n-1) asymptotic series.
!                        To speed the asymptotic series calculation,
!                        increase the argument by lshift.

      n_acc = nint(ndig*alogm2)
      kwrnsv = kwarn
      kwarn = 0
      call fmm2i(mxy(13), inta)
      kwarn = kwrnsv

      if (kflag == -4) then
          lshift = 0
      else
          lshift = max(0, int(real(ndig)*alogmb/4.46-real(inta)))
      endif
      if (lshift > 0) lshift = 4*(lshift/4 + 1)
      if (kflag == 0) then
          if (lshift > 0 .or. inta <= 10) then
              if (inta <= 2) then
                  call fmi2m(0, mresult)
                  return
              endif
              inta = inta - 1
              call fmfcti(inta, mxy(13))
              call fmln(mxy(13), mresult)
              return
          endif
      endif

      if (lshift /= 0) then
          call fmi2m(lshift, mxy(5))
          call fmadd(mxy(13), mxy(5), mxy(12))
      else
          call fmeq(mxy(13), mxy(12))
      endif

!             Sum the asymptotic series.

!       mxy(13) is z
!       mxy(12) is z + lshift
!       mxy(9)  is x**j2 = (1/(z+lshift)**2)**j2
!       mxy(10) is the current power of x
!       mxy(11) is the current term in the sum
!       mjsums  is the partial sum

      j2 = int(0.3*alogmb + 0.2*sqrt(real(ndig)))
      j2 = max(1, min(ljsums, j2))
      ndsav1 = ndig
      call fmi2m(1, mxy(10))
      j = -2*j2
      call fmipwr(mxy(12), j, mxy(9))
      if (abs(mxy(9)%mp(2)) >= mexpab) then
          j2 = 1
          call fmipwr(mxy(12), -2, mxy(9))
      endif
      nterm = 0
      do j = 1, j2
         nterm = 2*j
         call fmbern(nterm, mxy(10), mxy(11))
         if (kflag == -11) then
             call fmunknown(mresult)
             kflag = -4
             retry = .false.
             return
         endif
         ndenom = nterm*(nterm-1)
         call fmcsdivi(mxy(11), ndenom, mjsums(j))
      enddo

      ndig2 = ndig
      kl = 1
      do while (kl == 1)
         call fmcsmpy_r1(mxy(10), mxy(9))

         nmxdif = min(ndsav1, ngrd22)
         do j = 1, j2
            nterm = nterm + 2
            call fmbern(nterm, mxy(10), mxy(11))
            if (kflag == -11) then
                call fmunknown(mresult)
                kflag = -4
                retry = .false.
                return
            endif
            ndenom = nterm*(nterm-1)
            if (nterm <= mxbase/(nterm-1)) then
                call fmcsdivi_r1(mxy(11), ndenom)
            else
                call fmcsdivi_r1(mxy(11), nterm)
                ndenom = nterm - 1
                call fmcsdivi_r1(mxy(11), ndenom)
            endif
            ndig = ndsav1
            call fmcsadd_r1(mjsums(j), mxy(11))
            nmxdif = max(nmxdif, ndsav1-int(mjsums(j)%mp(2)-mxy(11)%mp(2)))
            ndig = ndig2
            if (kflag /= 0) then
                kl = 0
                exit
            endif
         enddo
         if (kl == 1) then
             ndig2 = nmxdif
             ndig = ndig2
         else
             exit
         endif
      enddo

!             Put the j2 concurrent sums back together.

      ndig = ndsav1
      if (j2 > 1) then
          call fmsqr(mxy(12), mxy(11))
          call fmi2m(1, mxy(5))
          call fmdiv_r2(mxy(5), mxy(11))
          call fmeq(mjsums(j2), mxy(9))
          do j = j2-1, 1, -1
             call fmcsmpy_r1(mxy(9), mxy(11))
             call fmcsadd_r1(mxy(9), mjsums(j))
          enddo
          call fmeq(mxy(9), mjsums(1))
      endif

!             Add the log terms to the asymptotic series.

!       mxy(10) is the current sum as the log terms are added
!       mxy(11) is now ln(z+lshift)

      call fmdiv(mjsums(1), mxy(12), mxy(10))
      call fmln(mxy(12), mxy(11))
      if (mbase /= mbs2pi .or. ndig > ndg2pi) then
          ndmb = int(150.0*2.302585/alogmb)
          if (ndmb >= ndig) then
              ndsv = ndig
              ndig = ndmb
              string = '1.837877066409345483560659472811235279722794'//  &
              '94727556682563430308096553139185452079538948659727190'//  &
              '8395244011293249268674892733725763681587144311751830445'
              k = min(int((ndig-1) * dlogmb / dlogtn + 2), len(string))
              do j = 1, k
                 st2(j) = string(j:j)
              enddo
              call fminp(st2, m_ln_2pi, 1, k)
              mbs2pi = mbase
              ndg2pi = ndig
              if (abs(m_ln_2pi%mp(2)) > 10) ndg2pi = 0
              ndig = ndsv
          else
              ndsv = ndig
              ndig = ndig + 2
              call fmpi(mxy(9))
              call fmmpyi(mxy(9), 2, mxy(5))
              call fmln(mxy(5), m_ln_2pi)
              mbs2pi = mbase
              ndg2pi = ndig
              if (abs(m_ln_2pi%mp(2)) > 10) ndg2pi = 0
              ndig = ndsv
          endif
      endif
      call fmsub(m_ln_2pi, mxy(11), mxy(5))
      call fmcancel(m_ln_2pi, mxy(11), mxy(5), k)
      n_acc = n_acc - k
      call fmcsdivi(mxy(5), 2, mxy(9))
      call fmadd(mxy(10), mxy(9), mxy(3))
      call fmcancel(mxy(10), mxy(9), mxy(3), k)
      n_acc = n_acc - k
      call fmeq(mxy(3), mxy(10))
      call fmsub(mxy(10), mxy(12), mxy(3))
      call fmcancel(mxy(10), mxy(12), mxy(3), k)
      n_acc = n_acc - k
      call fmeq(mxy(3), mxy(10))
      call fmmpy(mxy(11), mxy(12), mxy(9))
      call fmadd(mxy(10), mxy(9), mxy(3))
      call fmcancel(mxy(10), mxy(9), mxy(3), k)
      n_acc = n_acc - k
      call fmeq(mxy(3), mxy(10))

!             Now the log of gamma of the shifted argument has been computed.  Reverse the shifting.
!             The product ma*(ma+1)*...*(ma+lshift-1) is computed four terms at a time to reduce
!             the number of fmmpy calls.

!             mxy(13) is z
!             mxy(6) is z**2
!             mxy(7) is z**3
!             mxy(8) is (z+k)*...*(z+k+3)
!             mxy(11) is the current product

      if (lshift > 0) then
          call fmsqr(mxy(13), mxy(6))
          call fmmpy(mxy(13), mxy(6), mxy(7))
          call fmsqr(mxy(6), mxy(8))
          call fmcsmpyi(mxy(7), 6, mxy(12))
          call fmcsadd_r1(mxy(8), mxy(12))
          call fmcsmpyi(mxy(6), 11, mxy(12))
          call fmcsadd_r1(mxy(8), mxy(12))
          call fmcsmpyi(mxy(13), 6, mxy(12))
          call fmcsadd_r1(mxy(8), mxy(12))
          call fmeq(mxy(8), mxy(11))
          call fmcsmpyi_r1(mxy(7), 16)
          do k = 0, lshift-8, 4
             call fmcsadd_r1(mxy(8), mxy(7))
             k2 = 24*(2*k + 7)
             call fmcsmpyi(mxy(6), k2, mxy(12))
             call fmcsadd_r1(mxy(8), mxy(12))
             if (k <= sqrt(real(intmax)/49.0)) then
                 k1 = 8*(6*k*k + 42*k + 79)
                 call fmcsmpyi(mxy(13), k1, mxy(12))
                 call fmcsadd_r1(mxy(8), mxy(12))
             else
                 k1 = 48*k
                 call fmcsmpyi(mxy(13), k1, mxy(12))
                 call fmcsmpyi_r1(mxy(12), k)
                 call fmcsadd_r1(mxy(8), mxy(12))
                 k1 = 336*k + 632
                 call fmcsmpyi(mxy(13), k1, mxy(12))
                 call fmcsadd_r1(mxy(8), mxy(12))
             endif
             if (k <= (real(intmax)/17.0)**0.3333) then
                 k0 = 8*(2*k + 7)*(k*k + 7*k + 15)
                 call fmaddi(mxy(8), k0)
             else if (k <= sqrt(real(intmax)*0.9)) then
                 k0 = 8*(2*k + 7)
                 call fmi2m(k0, mxy(12))
                 k0 = k*k + 7*k + 15
                 call fmcsmpyi_r1(mxy(12), k0)
                 call fmcsadd_r1(mxy(8), mxy(12))
             else
                 k0 = 8*(2*k + 7)
                 call fmi2m(k0, mxy(12))
                 call fmcsmpyi(mxy(12), k, mxy(9))
                 call fmcsmpyi_r1(mxy(9), k)
                 call fmcsadd_r1(mxy(8), mxy(9))
                 k0 = 7*k + 15
                 call fmcsmpyi_r1(mxy(12), k0)
                 call fmcsadd_r1(mxy(8), mxy(12))
             endif
             call fmcsmpy_r1(mxy(11), mxy(8))
          enddo
          call fmln(mxy(11), mxy(4))
          call fmsub(mxy(10), mxy(4), mxy(3))
          call fmcancel(mxy(10), mxy(4), mxy(3), k)
          n_acc = n_acc - k
          call fmeq(mxy(3), mxy(10))
      endif

!             Use the reflection formula if ma was negative.

      if (mxy(1)%mp(1) < 0) then

!             Reduce the argument before multiplying by pi.

          call fmnint(mxy(13), mxy(6))
          call fmdivi(mxy(6), 2, mxy(7))
          call fmint(mxy(7), mxy(2))
          call fmmpyi(mxy(2), 2, mxy(8))
          ksign = -1
          if (fmcomp(mxy(6), '==', mxy(8))) ksign = 1
          call fmsub(mxy(13), mxy(6), mxy(9))
          call fmcancel(mxy(13), mxy(6), mxy(9), k)
          n_acc = n_acc - k
          call fmpi(mxy(11))
          call fmmpy_r1(mxy(11), mxy(9))
          krsave = krad
          krad = 1
          call fmsin(mxy(11), mxy(3))
          mxy(3)%mp(1) = ksign*mxy(3)%mp(1)
          krad = krsave
          call fmpi(mxy(11))
          call fmdiv_r2(mxy(11), mxy(3))
          call fmln(mxy(3), mxy(4))
          call fmsub(mxy(4), mxy(10), mxy(3))
          call fmcancel(mxy(4), mxy(10), mxy(3), k)
          n_acc = n_acc - k
          call fmeq(mxy(3), mxy(10))
      endif

      call fmeq(mxy(10), mresult)

      return
      end subroutine fmlngm_m2

      subroutine fmlngm_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = ln(gamma(ma)).

!  kresult = 1 is returned if a special case gives the value of ln(gamma(ma)).

      use fmvals
      implicit none

      type(multi) :: ma, mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      double precision :: b, xe, xf, ye, yf, ze, zf
      integer :: j
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMLNGM   '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      if ((malocal%mp(2) == mexpun .or. (malocal%mp(2) == munkno .and.  &
          malocal%mp(5) < 0 .and. malocal%mp(4) < -ndsave)) .and. malocal%mp(1) > 0) then
          call fmln(malocal, mresult)
          call fmnegate(mresult)
          kresult = 1
          return
      endif
      if ((malocal%mp(2) == mexpov .or. (malocal%mp(2) == munkno .and.  &
          malocal%mp(5) < 0 .and. malocal%mp(4) > ndsave)) .and. malocal%mp(1) > 0) then
          call fmovun_xexf(malocal, xe, xf)
          b = mbase
          ye = ceiling( log( xe*log(b) + log(xf) - 1 ) / log(b) )
          yf = ( xe*log(b) + log(xf) - 1 ) / b**ye
          ze = xe + ye
          zf = xf * yf
          if (zf < 1/b) then
              ze = ze - 1
              zf = zf * b
          endif
          if (ze == ze + 1.0d0) zf = 1.0d0 - epsilon(zf)
          if (ze > mxexp0) then
              call fmoverflow(1, mresult)
          else
              call fmunknown(mresult)
          endif
          mresult%mp(4) = ze
          mresult%mp(5) = -zf*maxint
          kresult = 1
          return
      endif

      return
      end subroutine fmlngm_sc

      subroutine fmlni(ival, ma)

!  ma = ln(ival)

!  Compute the natural logarithm of an integer ival.

!  If ival has only powers of 2, 3, 5, and 7 in its factorization then fmlni is faster than fmln.
!  Otherwise, if ival >= mxbase (i.e., ival does not fit in 1/2 word) then fmln is usually faster.

!  Use fmln instead of fmlni if 10*ival would cause integer overflow.

      use fmvals
      implicit none

      integer :: ival
      type(multi) :: ma
      intent (in) :: ival
      intent (inout) :: ma

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(6), mresult

      call fmalloc(ma, ndig+2)
      call fmenteri(kovun, mxsave, ndsave)
      call fmlni_sc(ival, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, ma, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call fmlni_m1(ival, mxy, mresult)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, ma, kovun, mxsave, ndsave)

      return
      end subroutine fmlni

      subroutine fmlni2(int1, int2, ma)

!  ma = ln(1 - int1/int2)

!  Taylor series for computing the logarithm of a rational number near 1.

      use fmvals
      implicit none

      integer :: int1, int2
      type(multi) :: ma
      intent (in) :: int1, int2
      intent (inout) :: ma

      integer :: j, ndsave
      type(multi), save :: mxy(2)

      call fmalloc(ma, ndig+2)

      call fmi2m(int1, mxy(2))
      call fmdivi_r1(mxy(2), int2)
      call fmeq(mxy(2), ma)
      ndsave = ndig
      j = 1

      kflag = 0
      do while (kflag /= 1)
         j = j + 1
         if (int1 /= 1) call fmmpyi_r1(mxy(2), int1)
         call fmdivi_r1(mxy(2), int2)
         call fmdivi(mxy(2), j, mxy(1))
         ndig = ndsave
         call fmadd_r1(ma, mxy(1))
         ndig = ndsave - int(ma%mp(2)-mxy(1)%mp(2))
         if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
      enddo

      ndig = ndsave
      call fmnegate(ma)

      return
      end subroutine fmlni2

      subroutine fmlni3

!  Binary splitting version.  faster for large ndig.

!  Compute the four saved constants ln(2), ln(3), ln(5), ln(7).

      use fmvals
      implicit none

      real (kind(1.0d0)) :: mxsave
      integer :: k, ndsave, n
      type(multi) :: mxy(6)

      if (mblogs /= mbase) call fmcons
      ndsave = ndig
      if (ncall == 1) then
          k = max(ngrd52-1, 2)
          ndig = max(ndig+k, 3)
      endif
      mxsave = mxexp
      mxexp = mxexp2

!             Determine k, the number of terms to sum in the series for
!             Ln( (n+1) / (n-1) ) = (2/n)*( 1 + 1/(3*d) + 1/(5*d**2) + ...), with d = n**2.
!             Four calls are made:  n = 251, 449, 4801, 8549.

      n = 251
      k = ndig*dlogmb/log(dble(n)**2) + 10
      call fmlni3_qbt(0, k, n, mxy(1), mxy(2), mxy(3))
      call imi2fm(mxy(1), mxy(4))
      call imi2fm(mxy(2), mxy(5))
      call imi2fm(mxy(3), mxy(6))
      call fmdiv(mxy(6), mxy(5), mxy(2))
      call fmdiv(mxy(2), mxy(4), mxy(1))
      call fmmpyi(mxy(1), 2, mxy(2))
      call fmdivi(mxy(2), n, mln2)

      n = 449
      k = ndig*dlogmb/log(dble(n)**2) + 10
      call fmlni3_qbt(0, k, n, mxy(1), mxy(2), mxy(3))
      call imi2fm(mxy(1), mxy(4))
      call imi2fm(mxy(2), mxy(5))
      call imi2fm(mxy(3), mxy(6))
      call fmdiv(mxy(6), mxy(5), mxy(2))
      call fmdiv(mxy(2), mxy(4), mxy(1))
      call fmmpyi(mxy(1), 2, mxy(2))
      call fmdivi(mxy(2), n, mln3)

      n = 4801
      k = ndig*dlogmb/log(dble(n)**2) + 10
      call fmlni3_qbt(0, k, n, mxy(1), mxy(2), mxy(3))
      call imi2fm(mxy(1), mxy(4))
      call imi2fm(mxy(2), mxy(5))
      call imi2fm(mxy(3), mxy(6))
      call fmdiv(mxy(6), mxy(5), mxy(2))
      call fmdiv(mxy(2), mxy(4), mxy(1))
      call fmmpyi(mxy(1), 2, mxy(2))
      call fmdivi(mxy(2), n, mln5)

      n = 8749
      k = ndig*dlogmb/log(dble(n)**2) + 10
      call fmlni3_qbt(0, k, n, mxy(1), mxy(2), mxy(3))
      call imi2fm(mxy(1), mxy(4))
      call imi2fm(mxy(2), mxy(5))
      call imi2fm(mxy(3), mxy(6))
      call fmdiv(mxy(6), mxy(5), mxy(2))
      call fmdiv(mxy(2), mxy(4), mxy(1))
      call fmmpyi(mxy(1), 2, mxy(2))
      call fmdivi(mxy(2), n, mln7)

!             Get Ln(2).

      call fmmpyi_r1(mln2, 72)
      call fmmpyi(mln3, 27, mxy(3))
      call fmadd_r1(mln2, mxy(3))
      call fmmpyi(mln5, -19, mxy(3))
      call fmadd_r1(mln2, mxy(3))
      call fmmpyi(mln7, 31, mxy(3))
      call fmadd_r1(mln2, mxy(3))

!             Get Ln(3).

      call fmmpyi_r1(mln3, 3)
      call fmmpyi(mln2, 19, mxy(3))
      call fmadd_r1(mln3, mxy(3))
      call fmadd_r1(mln3, mln5)
      call fmsub_r1(mln3, mln7)
      call fmdivi_r1(mln3, 12)

!             Get Ln(5).

      call fmadd_r1(mln5, mln2)
      call fmmpyi(mln3, 27, mxy(3))
      call fmsub_r2(mxy(3), mln5)
      call fmmpyi(mln7, 4, mxy(3))
      call fmadd_r1(mln5, mxy(3))
      call fmdivi_r1(mln5, 18)

!             Get Ln(7).

      call fmadd_r2(mln2, mln7)
      call fmmpyi(mln3, 7, mxy(3))
      call fmadd_r1(mln7, mxy(3))
      call fmmpyi(mln5, -4, mxy(3))
      call fmadd_r1(mln7, mxy(3))

      mxexp = mxsave
      ndig = ndsave

      return
      end subroutine fmlni3

      recursive subroutine fmlni3_qbt(a, b, n, mq, mb, mt)

!  This routine does the binary splitting for computing the constant Ln( (n+1) / (n-1) ).

      use fmvals
      implicit none

      type(multi) :: mq, mb, mt
      integer :: a, b, n
      intent (in) :: a, b, n
      intent (inout) :: mq, mb, mt

      type(multi) :: mxy(6)
      integer :: j, km, result_size
      real (kind(0.0d0)) :: da, db

      da = a
      db = b
      result_size = ( (db - da + 1)*log(dble(n)**2) ) / dlogmb + 7
      result_size = max(5, result_size)
      call fmalloc(mq, result_size)
      j = result_size
      result_size = ( (db+1.5d0)*log(db+2) - db + 1/(12*(db+2)) -          &
                      ( (da+0.5d0)*log(da+1) - da + 1/(12*(da+1)) ) - 1 +  &
                      (db-da+1)*log(2.0d0) ) / dlogmb + 7
      call fmalloc(mb, result_size)
      result_size = result_size + j
      call fmalloc(mt, result_size)

      if (b-a < 6) then
          call fmalloc(mxy(1), result_size)
          call fmalloc(mxy(2), result_size)
          call fmalloc(mxy(3), result_size)
          call fmalloc(mxy(4), result_size)
          call fmalloc(mxy(5), result_size)
          call imi2m(n, mxy(2))
          call imsqr(mxy(2), mxy(1))
          call imi2m(b-a+1, mxy(2))
          call impwr(mxy(1), mxy(2), mq)

          call imi2m(1, mb)
          do j = a+1, b, 2
             call immpyi(mb, 2*j-1, mxy(1))
             call immpyi(mxy(1), 2*j+1, mb)
          enddo
          if (mod(b-a, 2) == 0) then
              call immpyi(mb, 2*b+1, mxy(1))
              call imeq(mxy(1), mb)
          endif

!             mt is the sum
!             mxy(2) is (n*n)**(j+1)

          call imdivi(mb, 2*b+1, mxy(1))
          call immpyi(mxy(1), n, mxy(2))
          call immpyi(mxy(2), n, mt)
          call imi2m(n, mxy(1))
          call imsqr(mxy(1), mxy(2))
          do j = 1, b-a
             call imdivi(mb, 2*b+1-2*j, mxy(3))
             call immpyi(mxy(2), n, mxy(4))
             call immpyi(mxy(4), n, mxy(2))
             call immpy(mxy(2), mxy(3), mxy(4))
             call imadd(mt, mxy(4), mxy(5))
             call imeq(mxy(5), mt)
          enddo
          return
      endif

      km = a/2 + b/2 + mod(a, 2)*mod(b, 2)
      call fmlni3_qbt(a, km-1, n, mxy(1), mxy(2), mxy(3))
      call fmlni3_qbt(km, b, n, mxy(4), mxy(5), mxy(6))
      call immpy(mxy(1), mxy(4), mq)
      call immpy(mxy(2), mxy(5), mb)
      call immpy(mxy(5), mxy(4), mt)
      call immpy(mxy(3), mt, mxy(1))
      call immpy(mxy(2), mxy(6), mxy(3))
      call imadd(mxy(1), mxy(3), mt)

      return
      end subroutine fmlni3_qbt

      subroutine fmlni4(ival, nt, ma)

!  Binary splitting version.  Faster for large ndig.

!  ma = ln(ival/nt).

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: ival, nt
      intent (in) :: ival, nt
      intent (inout) :: ma

      real (kind(1.0d0)) :: mxsave
      integer :: a, b, k, ndsave, level_of_recursion
      type(multi), save :: mxy(7)

      call fmalloc(ma, ndig+2)
      if (mblogs /= mbase) call fmcons
      ndsave = ndig
      if (ncall == 1) then
          k = max(ngrd52-1, 2)
          ndig = max(ndig+k, 3)
      endif
      mxsave = mxexp
      mxexp = mxexp2

!             Determine k, the number of terms to sum in the series for
!             Ln( (b+a) / (b-a) ) = (2*a/b)*( 1 + 1/(3*d) + 1/(5*d**2) + ...), with d = (b/a)**2.

      a = abs(ival - nt)
      b = ival + nt
      call fmgcdi(a, b)
      if (ival-nt < 0) a = -a
      k = ndig*dlogmb/log(dble(b)**2/dble(a)**2) + 10
      level_of_recursion = 0
      call fmlni4_pqbt(0, k, a, b, mxy(1), mxy(2), mxy(3), mxy(4), level_of_recursion)
      call imi2fm(mxy(2), mxy(5))
      call imi2fm(mxy(3), mxy(6))
      call imi2fm(mxy(4), mxy(7))
      call fmdiv(mxy(7), mxy(6), mxy(2))
      call fmdiv(mxy(2), mxy(5), mxy(1))
      call fmmpyi(mxy(1), 2*a, mxy(2))
      call fmdivi(mxy(2), b, mxy(3))

      call fmequ(mxy(3), ma, ndig, ndsave)
      mxexp = mxsave
      ndig = ndsave

      return
      end subroutine fmlni4

      recursive subroutine fmlni4_pqbt(a, b, c, d, mp, mq, mb, mt, level_of_recursion)

!  This routine does the binary splitting for computing the constant Ln( (b+a) / (b-a) ).

      use fmvals
      implicit none

      type(multi) :: mp, mq, mb, mt
      integer :: a, b, c, d, level_of_recursion
      intent (in) :: a, b, c, d
      intent (inout) :: mp, mq, mb, mt, level_of_recursion

      type(multi) :: mxy(8)
      integer :: j, km, result_size
      real (kind(0.0d0)) :: da, db

      da = a
      db = b
      result_size = ( (db - da + 1)*log(dble(c)**2) ) / dlogmb + 7
      result_size = max(5, result_size)
      call fmalloc(mp, result_size)
      result_size = ( (db - da + 1)*log(dble(d)**2) ) / dlogmb + 7
      result_size = max(5, result_size)
      call fmalloc(mq, result_size)
      j = result_size
      result_size = ( (db+1.5d0)*log(db+2) - db + 1/(12*(db+2)) -          &
                      ( (da+0.5d0)*log(da+1) - da + 1/(12*(da+1)) ) - 1 +  &
                      (db-da+1)*log(2.0d0) ) / dlogmb + 7
      call fmalloc(mb, result_size)
      result_size = result_size + j
      call fmalloc(mt, result_size)
      level_of_recursion = level_of_recursion + 1

      if (b-a < 6) then
          call fmalloc(mxy(1), result_size)
          call fmalloc(mxy(2), result_size)
          call fmalloc(mxy(3), result_size)
          call fmalloc(mxy(4), result_size)
          call fmalloc(mxy(5), result_size)
          call imi2m(c, mxy(2))
          call imsqr(mxy(2), mxy(1))
          call imi2m(b-a+1, mxy(2))
          call impwr(mxy(1), mxy(2), mp)

          call imi2m(d, mxy(2))
          call imsqr(mxy(2), mxy(1))
          call imi2m(b-a+1, mxy(2))
          call impwr(mxy(1), mxy(2), mq)

          call imi2m(1, mb)
          do j = a+1, b, 2
             call immpyi(mb, 2*j-1, mxy(1))
             call immpyi(mxy(1), 2*j+1, mb)
          enddo
          if (mod(b-a, 2) == 0) then
              call immpyi(mb, 2*b+1, mxy(1))
              call imeq(mxy(1), mb)
          endif

          call imi2m(d, mxy(1))
          call imsqr(mxy(1), mxy(2))
          call imi2m(b-a+1, mxy(1))
          call impwr(mxy(2), mxy(1), mxy(3))

          call imi2m(1, mxy(4))
          call imi2m(0, mt)

          do j = a, b
             call imdivi(mb, 2*j+1, mxy(1))
             call immpy(mxy(1), mxy(3), mxy(2))
             call immpy(mxy(2), mxy(4), mxy(1))
             call imadd(mt, mxy(1), mxy(5))
             call imeq(mxy(5), mt)
             call imdivi(mxy(3), d, mxy(5))
             call imdivi(mxy(5), d, mxy(3))
             call immpyi(mxy(4), c, mxy(5))
             call immpyi(mxy(5), c, mxy(4))
          enddo
      else

          km = a/2 + b/2 + mod(a, 2)*mod(b, 2)
          call fmlni4_pqbt(a, km-1, c, d, mxy(1), mxy(2), mxy(3), mxy(4), level_of_recursion)
          call fmlni4_pqbt(km, b, c, d, mxy(5), mxy(6), mxy(7), mxy(8), level_of_recursion)

!             mp is not needed in fmlni4, so this multiplication can be skipped at the top level
!             of the recursion.

          if (level_of_recursion > 1) then
              call immpy(mxy(1), mxy(5), mp)
          else
              call imi2m(0, mp)
          endif
          call immpy(mxy(2), mxy(6), mq)
          call immpy(mxy(3), mxy(7), mb)
          call immpy(mxy(6), mxy(7), mt)
          call immpy(mxy(4), mt, mxy(5))
          call immpy(mxy(1), mxy(3), mt)
          call immpy(mxy(8), mt, mxy(2))
          call imadd(mxy(5), mxy(2), mt)
      endif

      level_of_recursion = level_of_recursion - 1

      return
      end subroutine fmlni4_pqbt

      subroutine fmlni_m1(ival, mxy, mresult)

!  Method 1 for computing ln(ival).

      use fmvals
      implicit none

      type(multi) :: mxy(6), mresult
      integer :: ival
      intent (in) :: ival
      intent (inout) :: mxy, mresult

      character(155) :: string
      character :: st2(155)
      integer :: int2, j, k, k2, k3, k5, k7, n, nd, ndsave, ndmb, ndsv, nt

!             Increase the working precision.

      ndsave = ndig
      if (ncall == 1) then
          k = ngrd52
          ndig = max(ndig+k, 3)
      endif

!             Find integers k2, k3, k5, and k7 such that
!                nt = 2**k2 * 3**k3 * 5**k5 * 7**k7
!             is a good approximation of ival.

      int2 = ival
      if (ival > intmax/100) int2 = ival/100
      nt = 0
      k2 = 0
      k3 = 0
      k5 = 0
      k7 = 0
      call fmlni_m1b(k2, k3, k5, k7, int2, nt)

!             If ival was too close to the integer overflow limit, restore nt to an
!             approximation of ival.

      if (int2 /= ival) then
          if (nt <= int2) then
              nt = nt*100
              k2 = k2 + 2
              k5 = k5 + 2
          else if (nt <= ival/98) then
              nt = nt*98
              k2 = k2 + 1
              k7 = k7 + 2
          else
              nt = nt*70
              k2 = k2 + 1
              k5 = k5 + 1
              k7 = k7 + 1
          endif
      endif

!             Compute ln(nt) as a linear combination of ln(2), ln(3), ln(5), and ln(7).

      if (mbase /= mbsli .or. ndig > ndigli) then
          ndmb = int(150.0*2.302585/alogmb)
          if (ndmb >= ndig) then
              ndsv = ndig
              ndig = ndmb
              string = '0.693147180559945309417232121458176568075500'//  &
              '13436025525412068000949339362196969471560586332699641'//  &
              '8687542001481020570685733685520235758130557032670751635'
              k = min(int(ndig * dlogmb / dlogtn + 2), len(string))
              do j = 1, k
                 st2(j) = string(j:j)
              enddo
              call fminp(st2, mln2, 1, k)
              string = '1.098612288668109691395245236922525704647490'//  &
              '55782274945173469433363749429321860896687361575481373'//  &
              '2088787970029065957865742368004225930519821052801870767'
              k = min(int((ndig-1) * dlogmb / dlogtn + 2), len(string))
              do j = 1, k
                 st2(j) = string(j:j)
              enddo
              call fminp(st2, mln3, 1, k)
              string = '1.609437912434100374600759333226187639525601'//  &
              '35426851772191264789147417898770765776463013387809317'//  &
              '9610799966303021715562899724005229324676199633616617464'
              k = min(int((ndig-1) * dlogmb / dlogtn + 2), len(string))
              do j = 1, k
                 st2(j) = string(j:j)
              enddo
              call fminp(st2, mln5, 1, k)
              string = '1.945910149055313305105352743443179729637084'//  &
              '72958186118845939014993757986275206926778765849858787'//  &
              '1526993061694205851140911723752257677786843148958095164'
              k = min(int((ndig-1) * dlogmb / dlogtn + 2), len(string))
              do j = 1, k
                 st2(j) = string(j:j)
              enddo
              call fminp(st2, mln7, 1, k)
              mbsli = mbase
              ndigli = ndig
              if (abs(mln2%mp(2)) > 10 .or. abs(mln3%mp(2)) > 10 .or.  &
                  abs(mln5%mp(2)) > 10 .or. abs(mln7%mp(2)) > 10) ndigli = 0
          else
              ndsv = ndig
              ndig = ndig + 2 + ndig/100
              mbsli = mbase
              ndigli = ndig

!                 If precision is high, use the binary splitting method.

              if (ndig < 40) then

                  call fmlni2(1, 126, mln2)
                  call fmlni2(1, 225, mln3)
                  call fmlni2(1, 2401, mln5)
                  call fmlni2(1, 4375, mln7)

!                    Get Ln(2).

                  call fmmpyi_r1(mln2, -72)
                  call fmmpyi(mln3, -27, mxy(3))
                  call fmadd_r1(mln2, mxy(3))
                  call fmmpyi(mln5, 19, mxy(3))
                  call fmadd_r1(mln2, mxy(3))
                  call fmmpyi(mln7, -31, mxy(3))
                  call fmadd_r1(mln2, mxy(3))

!                    Get Ln(3).

                  call fmmpyi_r1(mln3, -3)
                  call fmmpyi(mln2, 19, mxy(3))
                  call fmadd_r1(mln3, mxy(3))
                  call fmsub_r1(mln3, mln5)
                  call fmadd_r1(mln3, mln7)
                  call fmdivi_r1(mln3, 12)

!                    Get Ln(5).

                  call fmsub_r1(mln5, mln2)
                  call fmmpyi(mln3, 27, mxy(3))
                  call fmadd_r1(mln5, mxy(3))
                  call fmmpyi(mln7, -4, mxy(3))
                  call fmadd_r1(mln5, mxy(3))
                  call fmdivi_r1(mln5, 18)

!                    Get Ln(7).

                  call fmsub_r2(mln2, mln7)
                  call fmmpyi(mln3, 7, mxy(3))
                  call fmadd_r1(mln7, mxy(3))
                  call fmmpyi(mln5, -4, mxy(3))
                  call fmadd_r1(mln7, mxy(3))
              else
                  call fmlni3
              endif
          endif
          if (abs(mln2%mp(2)) > 10 .or. abs(mln3%mp(2)) > 10 .or.  &
              abs(mln5%mp(2)) > 10 .or. abs(mln7%mp(2)) > 10) ndigli = 0
          ndig = ndsv
      endif

!             If nt /= ival then the final step is to compute ln(ival/nt) and then use
!             ln(ival) = ln(ival/nt) + ln(nt).

      if (nt /= ival) then
          nd = nt - ival
          if (ndig < 40) then
              call fmlni2(nd, nt, mxy(3))
          else
              if (ival == nt-1) then
                  n = 2*ival + 1
                  k = ndig*dlogmb/log(dble(n)**2) + 10
                  call fmlni3_qbt(0, k, n, mxy(1), mxy(2), mxy(3))
                  call imi2fm(mxy(1), mxy(4))
                  call imi2fm(mxy(2), mxy(5))
                  call imi2fm(mxy(3), mxy(6))
                  call fmdiv(mxy(6), mxy(5), mxy(2))
                  call fmdiv(mxy(2), mxy(4), mxy(1))
                  call fmmpyi(mxy(1), -2, mxy(2))
                  call fmdivi(mxy(2), n, mxy(3))
              else if (ival == nt+1) then
                  n = 2*ival - 1
                  k = ndig*dlogmb/log(dble(n)**2) + 10
                  call fmlni3_qbt(0, k, n, mxy(1), mxy(2), mxy(3))
                  call imi2fm(mxy(1), mxy(4))
                  call imi2fm(mxy(2), mxy(5))
                  call imi2fm(mxy(3), mxy(6))
                  call fmdiv(mxy(6), mxy(5), mxy(2))
                  call fmdiv(mxy(2), mxy(4), mxy(1))
                  call fmmpyi(mxy(1), 2, mxy(2))
                  call fmdivi(mxy(2), n, mxy(3))
              else if (ival == nt-2) then
                  n = ival + 1
                  k = ndig*dlogmb/log(dble(n)**2) + 10
                  call fmlni3_qbt(0, k, n, mxy(1), mxy(2), mxy(3))
                  call imi2fm(mxy(1), mxy(4))
                  call imi2fm(mxy(2), mxy(5))
                  call imi2fm(mxy(3), mxy(6))
                  call fmdiv(mxy(6), mxy(5), mxy(2))
                  call fmdiv(mxy(2), mxy(4), mxy(1))
                  call fmmpyi(mxy(1), -2, mxy(2))
                  call fmdivi(mxy(2), n, mxy(3))
              else if (ival == nt+2) then
                  n = ival - 1
                  k = ndig*dlogmb/log(dble(n)**2) + 10
                  call fmlni3_qbt(0, k, n, mxy(1), mxy(2), mxy(3))
                  call imi2fm(mxy(1), mxy(4))
                  call imi2fm(mxy(2), mxy(5))
                  call imi2fm(mxy(3), mxy(6))
                  call fmdiv(mxy(6), mxy(5), mxy(2))
                  call fmdiv(mxy(2), mxy(4), mxy(1))
                  call fmmpyi(mxy(1), 2, mxy(2))
                  call fmdivi(mxy(2), n, mxy(3))
              else
                  call fmlni4(ival, nt, mxy(3))
              endif
          endif
      endif

      call fmmpyi(mln2, k2, mxy(2))
      call fmmpyi(mln3, k3, mxy(1))
      call fmadd_r1(mxy(2), mxy(1))
      call fmmpyi(mln5, k5, mxy(1))
      call fmadd_r1(mxy(2), mxy(1))
      call fmmpyi(mln7, k7, mxy(1))
      if (nt /= ival) call fmadd_r1(mxy(2), mxy(3))
      call fmadd(mxy(2), mxy(1), mxy(3))
      call fmequ(mxy(3), mresult, ndig, ndsave)
      ndig = ndsave

      return
      end subroutine fmlni_m1

      subroutine fmlni_m1b(k2, k3, k5, k7, int2, nt)

!  Find values k2, k3, k5, k7, such that  nt = 2**k2 * 3**k3 * 5**k5 * 7**k7
!  is a good approximation of ival.
!  kdelta = abs(ival - nt).

      use fmvals
      implicit none

      integer :: k2, k3, k5, k7, int2, nt
      intent (in) :: int2
      intent (inout) :: k2, k3, k5, k7, nt

      integer :: j2, j3, j5, j7, jtemp2, jtemp3, jtemp5, jtemp7, kdelta, last
      double precision :: xval

      xval = int2
      last = int(log(dble(xval))/dlogtw + 2.0d0)
      kdelta = int2

      jtemp7 = 1
      do j7 = 1, last
         if (jtemp7 > int2 .and. abs(jtemp7-int2) > kdelta) exit

         jtemp5 = jtemp7
         do j5 = 1, last
            if (jtemp5 > int2 .and. abs(jtemp5-int2) > kdelta) exit

            jtemp3 = jtemp5
            do j3 = 1, last
               if (jtemp3 > int2 .and. abs(jtemp3-int2) > kdelta) exit

               jtemp2 = jtemp3
               do j2 = 1, last
                  if (abs(jtemp2-int2) <= kdelta) then
                      if (abs(jtemp2-int2) == kdelta .and. jtemp2 < int2) exit
                      kdelta = abs(jtemp2-int2)
                      nt = jtemp2
                      k2 = j2 - 1
                      k3 = j3 - 1
                      k5 = j5 - 1
                      k7 = j7 - 1
                      if (kdelta == 0) return
                  endif
                  if (jtemp2 > int2) exit

                  jtemp2 = 2*jtemp2
               enddo

               jtemp3 = 3*jtemp3
            enddo

            jtemp5 = 5*jtemp5
         enddo

         jtemp7 = 7*jtemp7
      enddo

      return
      end subroutine fmlni_m1b

      subroutine fmlni_sc(ival, ndsave, mresult, kresult)

!  Check for special cases for mresult = ln(ival).

!  kresult = 1 is returned if a special case gives the value of ln(ival).

      use fmvals
      implicit none

      type(multi) :: mresult
      integer :: ival, kresult, ndsave
      intent (in) :: ival, ndsave
      intent (inout) :: mresult, kresult

      integer :: j

      kresult = 0

      namest(ncall) = 'FMLNI    '
      j = ndig
      ndig = ndsave
      call fmntr_inpi(ival)
      ndig = j

      if (ival <= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      if (ival == 1) then
          call fmi2m(0, mresult)
          kresult = 1
          return
      endif

      return
      end subroutine fmlni_sc

      subroutine fmlog10(ma, mb)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      call fmlg10(ma, mb)

      return
      end subroutine fmlog10

      subroutine fmm2dp(ma, x)

!  x = ma

!  Convert an fm number to double precision.

!  If kflag = -4 is returned for a value of ma that is in the range of the machine's double
!  precision number system, change the definition of dpmax in routine fmset to reflect the
!  current machine's range.

      use fmvals
      implicit none

      type(multi) :: ma
      double precision :: x
      intent (in) :: ma
      intent (inout) :: x

      ncall = ncall + 1
      namest(ncall) = 'FMM2DP'
      if (ntrace /= 0) call fmntr_inp1(ma)

      if (ma%mp(2) == mexpov .or. (ma%mp(2) == munkno .and. ma%mp(5) >= 0)) then

!             Here no valid result can be returned.
!             Set x to some value that the user is likely to recognize as wrong.

          x = dble(runkno)
          kflag = -4
          if (ma%mp(2) /= munkno) call fmwarn
          if (ntrace /= 0) call fmntr_outd(x)
          ncall = ncall - 1
          return
      endif

      call fmm2dp2(ma, x)

      if (ntrace /= 0) call fmntr_outd(x)
      ncall = ncall - 1

      return
      end subroutine fmm2dp

      subroutine fmm2dp2(ma, x)

!  x = ma

!  Internal routine for conversion to double precision.

      use fmvals
      implicit none

      type(multi) :: ma
      double precision :: x
      intent (in) :: ma
      intent (inout) :: x

      double precision :: aq(2), xq(2), yq(2), y1(2), y2(2), xbase, pmax, dlogdp,  &
                          a1, a2, c, c1, c2, c21, c22, q1, q2, t, xe, xf, xmax, ye, yf, z1, z2
      real (kind(1.0d0)) :: ma1
      integer :: j, k, ke, kl, kwrnsv, ncase

!             Check to see if ma is in range for single or double precision.

      if (ma%mp(2) == munkno) then
          if (ma%mp(5) < 0) then
              call fmovun_xexf(ma, xe, xf)
              if (xe > 0) then
                  ye = aint( log(huge(x)) / log(mbase) + 1 )
                  yf = exp( log(huge(x)) - ye*log(mbase) )
                  if (xe > ye .or. (xe == ye .and. xf > yf)) then
                      kflag = -4
                      x = dble(runkno)
                  else
                      kflag = 0
                      x = dble(mbase)**xe * xf
                      if (ma%mp(1) < 0) x = -x
                  endif
              else if (xe <= 0) then
                  ye = aint( log(tiny(x)) / log(mbase) )
                  yf = exp( log(tiny(x)) - ye*log(mbase) )
                  if (xe < ye .or. (xe == ye .and. xf <= yf)) then
                      kflag = -4
                      x = dble(runkno)
                  else
                      kflag = 0
                      x = dble(mbase)**xe * xf
                      if (ma%mp(1) < 0) x = -x
                  endif
              endif
          else
              kflag = -4
              x = dble(runkno)
          endif
          return
      endif
      if (mblogs /= mbase) call fmcons
      pmax = dpmax
      if (ncall > 0) then
          if (namest(ncall) == 'FMM2SP') pmax = dble(spmax)
      endif
      dlogdp = log(pmax)
      ma1 = ma%mp(2)
      ncase = 0
      x = dble(runkno)
      if (ma%mp(2)-1 > log(huge(x))/dlogmb) then
          kflag = -4
          x = dble(runkno)
          call fmwarn
          return
      else if (ma%mp(2) < log(tiny(x))/dlogmb) then
          kflag = -10
          x = 0.0d0
          call fmwarn
          return
      endif
      if (ma%mp(2) > log(huge(x))/dlogmb) then
          a1 = 0.0d0
          t = 1.0d0
          c = epsilon(t)/mbase
          do j = 3, ndig+2
             t = t/mbase
             a2 = ma%mp(j)*t
             a1 = a1 + a2
             if (a2 < c) exit
          enddo
          if (ma%mp(2) + log(a1)/dlogmb >= (log(huge(x))/dlogmb)*(1.0d0-5*epsilon(t))) then
              kflag = -4
              x = dble(runkno)
              call fmwarn
              return
          else
              x = dble(mbase)**ma%mp(2) * a1
              return
          endif
      else if (ma%mp(2)-1 < log(tiny(x))/dlogmb) then
          a1 = 0.0d0
          t = 1.0d0
          c = epsilon(t)/mbase
          do j = 3, ndig+2
             t = t/mbase
             a2 = ma%mp(j)*t
             a1 = a1 + a2
             if (a2 < c) exit
          enddo
          if (ma%mp(2) + log(a1)/dlogmb <= (log(tiny(x))/dlogmb)*(1.0d0+5*epsilon(t))) then
              kflag = -10
              x = 0.0d0
              call fmwarn
              return
          else
              x = dble(mbase)**ma%mp(2) * a1
              return
          endif
      endif
      if (dble(ma%mp(2)-1)*dlogmb > dlogdp) then
          kflag = -4
          x = dble(runkno)
          call fmwarn
          return
      else if (dble(ma%mp(2)+1)*dlogmb > dlogdp) then
          ma1 = ma1 - 2
          ncase = 1
      else if (dble(ma%mp(2)+1)*dlogmb < -dlogdp) then
          kflag = -10
          x = 0.0d0
          call fmwarn
          return
      else if (dble(ma%mp(2)-1)*dlogmb < -dlogdp) then
          ma1 = ma1 + 2
          ncase = 2
      endif

!             Try fmm2i2 first so that small integers will be converted quickly.

      kwrnsv = kwarn
      kwarn = 0
      call fmm2i2(ma, j)
      kwarn = kwrnsv
      if (kflag == 0) then
          x = j
          return
      endif
      kflag = 0
      k = -2*log(epsilon(1.0d0))/dlogmb + 1
      ke = ma%mp(2)
      kl = 0
      if (ke <= 0) then
          kl = 1
      else
          if (ke < k) then
              do j = ke+1, k
                 if (j > ndig) exit
                 if (ma%mp(j+2) /= 0) then
                     kl = 1
                     exit
                 endif
              enddo
          endif
      endif
      if (kl == 0) then
          xmax = dble(radix(1.0d0))**digits(1.0d0)
          x = 0
          do j = 1, ke
             x = mbase*x + ma%mp(j+2)
             if (x > xmax) then
                 kl = 1
                 exit
             endif
          enddo
          if (kl == 0) then
              if (ma%mp(1) < 0) x = -x
              return
          endif
      endif
      if (ma%mp(2) == 0) then
          k = 1
          do j = 4, ndig+2
             if (ma%mp(j) /= 0) then
                 k = 0
                 exit
             endif
          enddo
          if (k == 1) then
              z1 = ma%mp(3)
              z2 = mbase
              x = ma%mp(1) * (z1 / z2)
              return
          endif
      else if (ma%mp(2) == 1) then
          k = 1
          do j = 5, ndig+2
             if (ma%mp(j) /= 0) then
                 k = 0
                 exit
             endif
          enddo
          if (k == 1) then
              q1 = ma%mp(3)
              z1 = ma%mp(4)
              z2 = mbase
              q2 = z1 / z2
              x = ma%mp(1) * (q1 + q2)
              return
          endif
      endif

!             General case.
!             In order to get the correctly rounded x, the arithmetic for computing x is done
!             with simulated quadruple-precision using the arrays of length 2.

      xbase = mbase
      xq = (/ 0.0d0 , 0.0d0 /)
      yq = (/ 1.0d0 , 0.0d0 /)
      c = radix(x)**(digits(x) - digits(x)/2) + 1
      k = (log(dble(radix(x)))/dlogmb)*digits(x) + ngrd52
      do j = 2, min(k+1, ndig+1)
         z1 = yq(1) / xbase
         t = xbase*c
         a1 = (xbase - t) + t
         a2 = xbase - a1
         t = z1*c
         c1 = (z1 - t) + t
         c2 = z1 - c1
         t = c2*c
         c21 = (c2 - t) + t
         c22 = c2 - c21
         q1 = xbase*z1
         q2 = ((((a1*c1 - q1) + a1*c2) + c1*a2) + c21*a2) + c22*a2
         z2 = ((((yq(1)-q1) - q2) + yq(2))) / xbase
         yq(1) = z1 + z2
         yq(2) = (z1-yq(1)) + z2
         t = yq(1)*c
         a1 = (yq(1) - t) + t
         a2 = yq(1) - a1
         t = dble(ma%mp(j+1))*c
         c1 = (dble(ma%mp(j+1)) - t) + t
         c2 = dble(ma%mp(j+1)) - c1
         t = c2*c
         c21 = (c2 - t) + t
         c22 = c2 - c21
         q1 = yq(1)*dble(ma%mp(j+1))
         q2 = ((((a1*c1 - q1) + a1*c2) + c1*a2) + c21*a2) + c22*a2
         z2 = yq(2)*dble(ma%mp(j+1)) + q2
         aq(1) = q1 + z2
         aq(2) = (q1-aq(1)) + z2
         z1 = xq(1) + aq(1)
         q1 = xq(1) - z1
         z2 = (((q1+aq(1)) + (xq(1)-(q1+z1))) + xq(2)) + aq(2)
         xq(1) = z1 + z2
         xq(2) = (z1-xq(1)) + z2
      enddo

      y1 = (/ xbase , 0.0d0 /)
      k = abs(ma1)
      if (mod(k, 2) == 0) then
          y2 = (/ 1.0d0 , 0.0d0 /)
      else
          y2 = (/ xbase , 0.0d0 /)
      endif

      do
         k = k/2
         t = y1(1)*c
         a1 = (y1(1) - t) + t
         a2 = y1(1) - a1
         t = y1(1)*c
         c1 = (y1(1) - t) + t
         c2 = y1(1) - c1
         t = c2*c
         c21 = (c2 - t) + t
         c22 = c2 - c21
         q1 = y1(1)*y1(1)
         q2 = ((((a1*c1 - q1) + a1*c2) + c1*a2) + c21*a2) + c22*a2
         z2 = ((y1(1) + y1(2))*y1(2) + y1(2)*y1(1)) + q2
         y1(1) = q1 + z2
         y1(2) = (q1-y1(1)) + z2
         if (mod(k, 2) == 1) then
             t = y1(1)*c
             a1 = (y1(1) - t) + t
             a2 = y1(1) - a1
             t = y2(1)*c
             c1 = (y2(1) - t) + t
             c2 = y2(1) - c1
             t = c2*c
             c21 = (c2 - t) + t
             c22 = c2 - c21
             q1 = y1(1)*y2(1)
             q2 = ((((a1*c1 - q1) + a1*c2) + c1*a2) + c21*a2) + c22*a2
             z2 = ((y1(1) + y1(2))*y2(2) + y1(2)*y2(1)) + q2
             y2(1) = q1 + z2
             y2(2) = (q1-y2(1)) + z2
         endif
         if (k <= 1) exit
      enddo

      if (ma1 < 0) then
          z1 = xq(1) / y2(1)
          t = y2(1)*c
          a1 = (y2(1) - t) + t
          a2 = y2(1) - a1
          t = z1*c
          c1 = (z1 - t) + t
          c2 = z1 - c1
          t = c2*c
          c21 = (c2 - t) + t
          c22 = c2 - c21
          q1 = y2(1)*z1
          q2 = ((((a1*c1 - q1) + a1*c2) + c1*a2) + c21*a2) + c22*a2
          z2 = ((((xq(1)-q1) - q2) + xq(2)) - z1*y2(2)) / (y2(1) + y2(2))
          aq(1) = z1 + z2
          aq(2) = (z1-aq(1)) + z2
      else
          t = xq(1)*c
          a1 = (xq(1) - t) + t
          a2 = xq(1) - a1
          t = y2(1)*c
          c1 = (y2(1) - t) + t
          c2 = y2(1) - c1
          t = c2*c
          c21 = (c2 - t) + t
          c22 = c2 - c21
          q1 = xq(1)*y2(1)
          q2 = ((((a1*c1 - q1) + a1*c2) + c1*a2) + c21*a2) + c22*a2
          z2 = ((xq(1) + xq(2))*y2(2) + xq(2)*y2(1)) + q2
          aq(1) = q1 + z2
          aq(2) = (q1-aq(1)) + z2
      endif

      x = aq(1) + aq(2)

      if (ma%mp(1) < 0) x = -x

!             Check the result if it is near overflow or underflow.

      if (ncase == 1) then
          if (x <= pmax/(xbase*xbase)) then
              x = x*xbase*xbase
          else
              kflag = -4
              x = dble(runkno)
              call fmwarn
          endif
      else if (ncase == 2) then
          if (x >= (1.0d0/pmax)*xbase*xbase) then
              x = x/(xbase*xbase)
          else
              kflag = -10
              x = 0.0d0
              call fmwarn
          endif
      endif

      return
      end subroutine fmm2dp2

      subroutine fmm2i(ma, ival)

!  ival = ma

!  Convert an fm number to integer.

!  kflag =  0 is returned if the conversion is exact.
!        = -4 is returned if ma is larger than intmax in magnitude.  ival = iunkno is returned
!             as an indication that ival could not be computed without integer overflow.
!        =  2 is returned if ma is smaller than intmax in magnitude but ma is not an integer.
!             The next integer toward zero is returned in ival.
!  It is sometimes convenient to call fmm2i to see if an fm number can be represented as a one-word
!  integer, by checking kflag upon return.  To avoid an unwanted error message being printed in the
!  kflag=-4 case, set kwarn=0 before the call to fmm2i and reset it after the call.

!  This routine performs the trace printing for the conversion.
!  fmm2i2 is used to do the arithmetic.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ma
      intent (inout) :: ival

      ncall = ncall + 1
      namest(ncall) = 'FMM2I'
      if (ntrace /= 0) call fmntr_inp1(ma)

      call fmm2i2(ma, ival)

      if (ntrace /= 0) call fmntr_outi(ival)
      ncall = ncall - 1

      return
      end subroutine fmm2i

      subroutine fmm2i2(ma, ival)

!  ival = ma.  Internal fm to integer conversion routine.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ma
      intent (inout) :: ival

      integer :: j, ka, kb, large, n1

      kflag = 0
      n1 = ndig + 1
      large = int(intmax/mbase)
      ival = 0
      if (ma%mp(2) <= 0) then
          if (ma%mp(3) /= 0) kflag = 2
          return
      endif
      if (ma%mp(2) == munkno .and. ma%mp(5) < 0 .and. ma%mp(4) < 0) then
          kflag = 2
          return
      endif
      if (ma%mp(2) == munkno .and. ma%mp(5) < 0 .and. ma%mp(4) >= 0) then
          kflag = -4
          ival = iunkno
          return
      endif

      kb = int(ma%mp(2)) + 1
      ival = int(abs(ma%mp(3)))
      if (kb >= 3) then
          do j = 3, kb
             if (ival > large) then
                 kflag = -4
                 if (ma%mp(2) /= munkno) call fmwarn
                 ival = iunkno
                 return
             endif
             if (j <= n1) then
                 ival = ival*int(mbase)
                 if (ival > intmax-ma%mp(j+1)) then
                     kflag = -4
                     if (ma%mp(2) /= munkno) call fmwarn
                     ival = iunkno
                     return
                 else
                     ival = ival + int(ma%mp(j+1))
                 endif
             else
                 ival = ival*int(mbase)
             endif
          enddo
      endif

      if (ma%mp(1) < 0) ival = -ival

!             Check to see if ma is an integer.

      ka = kb + 1
      if (ka <= n1) then
          do j = ka, n1
             if (ma%mp(j+1) /= 0) then
                 kflag = 2
                 return
             endif
          enddo
      endif

      return
      end subroutine fmm2i2

      subroutine fmm2sp(ma, x)

!  x = ma

!  Convert an fm number to single precision.

!  ma is converted and the result is returned in x.

!  If kflag = -4 is returned for a value of ma that is in the range of the machine's single
!  precision number system, change the definition of spmax in routine fmset to reflect the
!  current machine's range.

      use fmvals
      implicit none

      type(multi) :: ma
      real :: x
      intent (in) :: ma
      intent (inout) :: x

      double precision :: y

      ncall = ncall + 1
      namest(ncall) = 'FMM2SP'
      if (ntrace /= 0) call fmntr_inp1(ma)

      if (ma%mp(2) == mexpov .or. (ma%mp(2) == munkno .and. ma%mp(5) >= 0)) then

!             Here no valid result can be returned.
!             Set x to some value that the user is likely to recognize as wrong.

          x = runkno
          kflag = -4
          if (ma%mp(2) /= munkno) call fmwarn
          y = dble(x)
          if (ntrace /= 0) call fmntr_outd(y)
          ncall = ncall - 1
          return
      endif

      call fmm2dp2(ma, y)
      if (abs(y) <= dble(huge(x))) then
          x = y
      else
          x = runkno
          kflag = -4
          call fmwarn
      endif

      if (ntrace /= 0) call fmntr_outr(x)
      ncall = ncall - 1

      return
      end subroutine fmm2sp

      subroutine fmmax(ma, mb, mc)

!  mc = max(ma,mb)

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: kwrnsv
      logical, external :: fmcomp

      call fmalloc(mc, ndig+2)

      kflag = 0
      ncall = ncall + 1
      namest(ncall) = 'FMMAX'
      if (ntrace /= 0) call fmntr_inp2(ma, mb)

      kwrnsv = kwarn
      kwarn = 0
      if ((ma%mp(2) == munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc)
          kflag = -4
      else if (fmcomp(ma, '<', mb)) then
          call fmeq(mb, mc)
      else
          call fmeq(ma, mc)
      endif

      kwarn = kwrnsv
      if (ntrace /= 0) call fmntr_out1(mc)
      ncall = ncall - 1

      return
      end subroutine fmmax

      subroutine fmmin(ma, mb, mc)

!  mc = min(ma,mb)

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: kwrnsv
      logical, external :: fmcomp

      call fmalloc(mc, ndig+2)

      kflag = 0
      ncall = ncall + 1
      namest(ncall) = 'FMMIN'
      if (ntrace /= 0) call fmntr_inp2(ma, mb)

      kwrnsv = kwarn
      kwarn = 0
      if ((ma%mp(2) == munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc)
          kflag = -4
      else if (fmcomp(ma, '>', mb)) then
          call fmeq(mb, mc)
      else
          call fmeq(ma, mc)
      endif

      kwarn = kwrnsv
      if (ntrace /= 0) call fmntr_out1(mc)
      ncall = ncall - 1

      return
      end subroutine fmmin

      subroutine fmmod(ma, mb, mc)

!  mc = ma(mod mb).

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      type(multi), save :: mresult
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave

      call fmalloc(mc, ndig+2)
      ncall = ncall + 1
      namest(ncall) = 'FMMOD'
      if (ntrace /= 0) call fmntr_inp2(ma, mb)
      ncall = ncall - 1

      call fmenter2(ma, mb, kovun, mxsave, ndsave)
      call fmmod2(ma, mb, mresult, ndsave)

      call fmexit1(mresult, mc, kovun, mxsave, ndsave)

      return
      end subroutine fmmod

      subroutine fmmod2(ma, mb, mc, ndsave)

!  mc = ma(mod mb).

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      integer :: ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mc

      real (kind(1.0d0)) :: mvb, mvc, mvy, mvz
      integer :: j, kb, ke, kl, kn, kwrnsv, ntrsav
      type(multi), save :: mxy(4)
      logical, external :: fmcomp

      call fmalloc(mc, ndig+2)
      if (mblogs /= mbase) call fmcons
      call fmequ(ma, mxy(1), ndsave, ndig)
      call fmequ(mb, mxy(2), ndsave, ndig)

      if ((mxy(1)%mp(2) == munkno .and. mxy(1)%mp(5) >= 0)  .or.  &
          (mxy(2)%mp(2) == munkno .and. mxy(2)%mp(5) >= 0)) then
          call fmunknown(mc)
          return
      endif
      kwrnsv = kwarn
      kwarn = 0

      mxy(1)%mp(1) = 1
      mxy(2)%mp(1) = 1
      if (fmcomp(mxy(2), '>', mxy(1))) then
          call fmequ(ma, mxy(1), ndsave, ndig)
      else

!             Special cases when mb is a small integer.

          call fmequ(ma, mxy(2), ndsave, ndig)
          call fmequ(mb, mxy(3), ndsave, ndig)
          mxy(2)%mp(1) = 1
          mxy(3)%mp(1) = 1

          call fmm2i(mxy(3), kb)
          kl = 0
          do while (kl == 0)
             if (kflag == 0 .and. kb < mxbase) then
                 if (kb == 1 .or. kb == -1) then
                     if (mxy(2)%mp(2) >= ndig) then
                         call fmi2m(0, mc)
                         if (kflag == 1) kflag = 0
                         kwarn = kwrnsv
                         return
                     else
                         call fmint(mxy(2), mxy(3))
                         call fmsub(mxy(2), mxy(3), mc)
                         if (ma%mp(1) < 0) call fmnegate(mc)
                         if (kflag == 1) kflag = 0
                         kwarn = kwrnsv
                         return
                     endif
                 else if (mxy(2)%mp(2) == mexpov .or. kb == 0) then
                     call fmunknown(mc)
                     if (kflag == 1) kflag = 0
                     kwarn = kwrnsv
                     return
                 else if (mxy(2)%mp(2) > ndig.and.mod(int(mbase), kb) == 0) then
                     call fmi2m(0, mc)
                     if (kflag == 1) kflag = 0
                     kwarn = kwrnsv
                     return
                 endif
                 if (mxy(2)%mp(2) < ndig) then
                     do j = int(mxy(2)%mp(2))+1, ndig+1
                        if (mxy(2)%mp(j+1) /= 0) then
                            kl = 1
                            exit
                        endif
                     enddo
                     if (kl == 1) exit
                 endif
                 ke = min(int(mxy(2)%mp(2)), ndig)
                 mvb = kb
                 mvc = mod(mxy(2)%mp(3), mvb)
                 do j = 3, ke+1
                    mvc = mod(mvc*mbase+mxy(2)%mp(j+1), mvb)
                 enddo
                 if (mvc == 0) then
                     call fmi2m(0, mc)
                     if (kflag == 1) kflag = 0
                     kwarn = kwrnsv
                     return
                 endif
                 kn = int(mxy(2)%mp(2)) - ke
                 mvy = mod(mbase, mvb)
                 mvz = 1
                 if (mod(kn, 2) == 1) mvz = mvy

                 if (mvy /= 1) then
                     do
                        kn = kn/2
                        mvy = mod(mvy*mvy, mvb)
                        if (mod(kn, 2) == 1) mvz = mod(mvz*mvy, mvb)
                        if (kn <= 1) exit
                     enddo
                 endif
                 mvz = mod(mvz*mvc, mvb)
                 ke = int(mvz)
                 call fmi2m(ke, mc)
                 if (ma%mp(1) < 0) call fmnegate(mc)
                 if (kflag == 1) kflag = 0
                 kwarn = kwrnsv
                 return
             endif
             if (ma%mp(2)-mb%mp(2) > 3*10**5) then
                 call fmunknown(mc)
                 if (kflag == 1) kflag = 0
                 kwarn = kwrnsv
                 return
             else
                 kl = 1
             endif
          enddo

!             General case.

          if (ma%mp(3) /= 0) then
              ndig = ndig + int(ma%mp(2)-mb%mp(2))
              if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
          endif
          if (mb%mp(3) == 0) then
              call fmunknown(mc)
              return
          endif

          call fmequ(ma, mxy(2), ndsave, ndig)
          call fmequ(mb, mxy(3), ndsave, ndig)

          mxy(2)%mp(1) = 1
          mxy(3)%mp(1) = 1
          call fmdiv(mxy(2), mxy(3), mxy(1))
          call fmint(mxy(1), mxy(4))
          call fmmpy_r1(mxy(4), mxy(3))
          call fmsub(mxy(2), mxy(4), mxy(1))

!             Due to rounding, mxy(1) may not be between 0 and mb here.

          ntrsav = ntrace
          ntrace = 0
          if (fmcomp(mxy(1), '>=', mxy(3))) then
              ntrace = ntrsav
              call fmsub_r1(mxy(1), mxy(3))
          endif
          ntrace = ntrsav
          if (mxy(1)%mp(1) < 0) call fmadd_r1(mxy(1), mxy(3))
          if (ma%mp(1) < 0) call fmnegate(mxy(1))
      endif

      call fmeq(mxy(1), mc)
      if (kflag == 1) kflag = 0
      kwarn = kwrnsv

      return
      end subroutine fmmod2

      subroutine fmmove(mw, ma)

!  Move a result from a work area (mw) to ma.

!  If the first digit of mw is 0, then mw is shifted and the exponent adjusted when it is
!  moved to ma.

      use fmvals
      implicit none

      type(multi) :: ma, mw

      integer :: j, n1, n2
      intent (in) :: mw
      intent (inout) :: ma

      if (mw%mp(3) /= 0) then
          n1 = ndig + 1

!             Major (Inner Loop)

          do j = 2, n1+1
             ma%mp(j) = mw%mp(j)
          enddo
      else
          n2 = ndig + 2
          do j = 3, n2
             ma%mp(j) = mw%mp(j+1)
          enddo
          if (ma%mp(3) /= 0) then
              ma%mp(2) = mw%mp(2) - 1
          else
              ma%mp(2) = 0
          endif
      endif

      ma%mp(1) = 1
      if (abs(ma%mp(2)) > mxexp) call fmtrap(ma)

      return
      end subroutine fmmove

      subroutine fmmpy(ma, mb, mc)

!  mc = ma * mb

!  When one of the numbers ma, mb is known to have more zero digits (base mbase) than the other,
!  it is faster if mb is the one with more zero digits.

!  This routine performs the trace printing for multiplication.
!  fmmpy2 is used to do the arithmetic.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: kovun

      ncall = ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == mexpov .or. abs(mb%mp(2)) == mexpov) kovun = 1
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) kovun = 2
      if (ntrace /= 0) then
          namest(ncall) = 'FMMPY'
          call fmntr_inp2(ma, mb)
      endif

      call fmmpy2(ma, mb, mc)

      if ((abs(mc%mp(2)) == mexpov .and. kovun == 0) .or.  &
          (abs(mc%mp(2)) == munkno .and. kovun < 2)) then
          namest(ncall) = 'FMMPY'
          call fmwarn
      endif
      if (ntrace /= 0) then
          call fmntr_out1(mc)
      endif
      ncall = ncall - 1

      return
      end subroutine fmmpy

      subroutine fmmpy2(ma, mb, mc)

!  Internal multiplication routine.  mc = ma * mb

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      logical :: retry
      integer :: kresult, kr_retry

      call fmalloc(mc, ndig+2)
      call fmalloc(mwa, 2*ndig+30)
      call fmmpy_sc(ma, mb, mc, kresult)
      if (kresult > 0) then
          return
      endif

      if (mblogs /= mbase) call fmcons

      kr_retry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fmmpy_m1(ma, mb, mc, kr_retry, retry)
      enddo

      return
      end subroutine fmmpy2

      subroutine fmmpy2_r1(ma, mb)

!  Internal multiplication routine.  ma = ma * mb

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: mb
      intent (inout) :: ma

      logical :: retry
      integer :: kresult, kr_retry

      call fmalloc(mwa, 2*ndig+30)
      call fmmpy_r1_sc(ma, mb, kresult)
      if (kresult > 0) then
          return
      endif

      if (mblogs /= mbase) call fmcons

      kr_retry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fmmpy_r1_m1(ma, mb, kr_retry, retry)
      enddo

      return
      end subroutine fmmpy2_r1

      subroutine fmmpy2_r2(ma, mb)

!  Internal multiplication routine.  mb = ma * mb

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      logical :: retry
      integer :: kresult, kr_retry

      call fmalloc(mwa, 2*ndig+30)
      call fmmpy_r2_sc(ma, mb, kresult)
      if (kresult > 0) then
          return
      endif

      if (mblogs /= mbase) call fmcons

      kr_retry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fmmpy_r2_m1(ma, mb, kr_retry, retry)
      enddo

      return
      end subroutine fmmpy2_r2

      subroutine fmmpy3(ma, mb, nguard, kshift)

!  Internal multiplication of ma*mb.  the result is returned in mwa.  Both ma and mb are positive.

!  nguard is the number of guard digits that will be used.
!  kshift = 1 is returned if a left shift is pending (i.e., first digit of mwa = 0).
!             The shift will be done in fmmove.  kshift = 0 is returned if no shift is pending.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: nguard, kshift
      intent (in) :: ma, mb, nguard
      intent (inout) :: kshift

      real (kind(1.0d0)) :: maxmwa, mbj, mbkj, mbnorm, mbp1, mk, mkt, mmax, mt
      integer :: j, jm1, k, kb, ki, kj, kl, knz, kwa, l, n1, nmethd, nzda, nzdb
      real :: c

      n1 = ndig + 1
      mwa%mp(2) = ma%mp(2) + mb%mp(2)

!             Check for using an fft-based method if precision is very high.

      c = 900
      if (ndig >= c) then
          nzda = 2
          nzdb = ndig
          do j = ndig, 2, -1
             if (ma%mp(j+2) /= 0) then
                 nzda = j
                 exit
             endif
          enddo
          do j = 2, ndig
             if (mb%mp(j+2) == 0) nzdb = nzdb - 1
          enddo
          c = 0.9 * c / log(c)
          if (real(nzda)*nzdb < c*ndig*log(real(ndig))) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          nmethd = 1
      endif
      if (nmethd == 2) then
          call fmmpyfft(ma, mb)
          if (mwa%mp(3) == 0) then
              kshift = 1
          else
              kshift = 0
          endif
          return
      endif

      l = n1 + nguard
      mwa%mp(l+2) = 0

!             The multiplication loop begins here.

!             mbnorm is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             maxmwa is an upper bound on the size of values in mwa divided by (mbase-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      mbp1 = mbase + 1
      mbnorm = (maxint/(mbp1*mbp1))
      mmax = intmax - mbase
      mmax = min((maxint/mbp1 - mbp1), mmax)
      if (mbnorm >= 2) then
          mbj = mb%mp(3)

!             Count the trailing zeros in ma.

          knz = n1
          if (ma%mp(n1+1) /= 0) then
              knz = n1
          else
              do j = ndig, 2, -1
                 if (ma%mp(j+1) /= 0) then
                     knz = j
                     exit
                 endif
              enddo
          endif

          mwa%mp(3) = 0
          do k = ndig+2, l
             mwa%mp(k+1) = 0
          enddo

!             (Inner Loop)

          do k = 3, n1+1
             mwa%mp(k+1) = ma%mp(k)*mbj
          enddo
          maxmwa = mbj
          do j = 3, n1
             mbj = mb%mp(j+1)
             if (mbj /= 0) then
                 maxmwa = maxmwa + mbj
                 jm1 = j - 1
                 kl = min(knz, l-jm1)

!                       Major (Inner Loop)

                 do k = j+2, j+kl
                    mwa%mp(k) = mwa%mp(k) + ma%mp(k-jm1)*mbj
                 enddo
             endif

             if (maxmwa > mmax) then
                 maxmwa = 0
                 jm1 = j - 1
                 kl = min(knz, l-jm1)

!                       Here normalization is only required for the range of digits currently
!                       changing in mwa.

                 do kb = jm1+kl, jm1+2, -1
                    mkt = int (mwa%mp(kb+1)/mbase)
                    mwa%mp(kb) = mwa%mp(kb) + mkt
                    mwa%mp(kb+1) = mwa%mp(kb+1) - mkt*mbase
                 enddo
             endif
          enddo

!             Perform the final normalization.  (Inner Loop)

          do kb = l+1, 4, -1
             mkt = int (mwa%mp(kb)/mbase)
             mwa%mp(kb-1) = mwa%mp(kb-1) + mkt
             mwa%mp(kb) = mwa%mp(kb) - mkt*mbase
          enddo

      else

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          do j = 2, l
             mwa%mp(j+1) = 0
          enddo
          kj = ndig + 2
          do j = 2, n1
             kj = kj - 1
             mbkj = mb%mp(kj+1)
             if (mbkj == 0) cycle
             kl = l - kj + 1
             if (kl > n1) kl = n1
             ki = kl + 2
             kwa = kl+ kj + 1
             mk = 0
             do k = 2, kl
                mt = ma%mp(ki-k+1)*mbkj + mwa%mp(kwa-k+1) + mk
                mk = int (mt/mbase)
                mwa%mp(kwa-k+1) = mt - mbase*mk
             enddo
             mwa%mp(kwa-kl) = mk
          enddo

      endif

!             Set kshift = 1 if a shift left is necessary.

      if (mwa%mp(3) == 0) then
          kshift = 1
      else
          kshift = 0
      endif

      return
      end subroutine fmmpy3

      subroutine fmmpy_m1(ma, mb, mc, kr_retry, retry)

!  Method 1 for computing mc = ma * mb.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      integer :: kr_retry
      logical :: retry
      intent (in) :: ma, mb
      intent (inout) :: mc, kr_retry, retry

      real (kind(1.0d0)) :: mr, ms, mt1, mt2
      double precision :: err
      integer :: j, jrssav, k, kl, kshift, kt, kt1, kt2, l, n1, nguard

      kflag = 0
      jrssav = jrsign

!             nguard is the number of guard digits used.

      if (ncall > 1) then
          nguard = ngrd22
          if (nguard > ndig) nguard = ndig
      else
          nguard = ngrd52
          if (nguard > ndig) nguard = ndig
          if (kr_retry >= 1) then
              nguard = ndig + 2
          else if (mbase < 10**6) then
              nguard = min(nguard+1, ndig+2)
          endif
      endif
      if (ma%mp(3)*mb%mp(3) < mbase .and. nguard < 3) nguard = 3

      n1 = ndig + 1

      if (mbase*mbase <= mxbase/(4*mbase)) then

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2**24) while
!             doing the operation.

          if (ndigl /= ndig .or. mbasel /= mbase .or. nguarl /= nguard) then
              mbasel = mbase
              ndigl = ndig
              nguarl = nguard
              do j = 2, 1000
                 mr = mbase*mbasel
                 if (4*mr > mxbase) then
                     n21 = j - 1
                     ndig = (ndigl-1)/n21 + 1
                     if (ndig < 3) ndig = 3
                     ngrdn = (ndigl+nguard-1)/n21 + 2 - ndig
                     if (ngrdn < 1) ngrdn = 1
                     exit
                 endif
                 mbase = mr
              enddo
              mbasen = mbase
              ndign = ndig
          else
              mbase = mbasen
              ndig = ndign
          endif
          if (mblogs /= mbase) call fmcons
          j = ndig
          ndig = ndig + ngrdn + 5
          call fmalloc(mpma, ndig+2)
          call fmalloc(mpmb, ndig+2)
          ndig = j
          mpma%mp(1) = ma%mp(1)
          mpmb%mp(1) = mb%mp(1)
          mpma%mp(2) = 0
          mpmb%mp(2) = 0
          l = 2 - n21
          do j = 2, ndigl+2-n21, n21
             mt1 = ma%mp(j+1)
             mt2 = mb%mp(j+1)
             do k = j+1, j+n21-1
                mt1 = mt1*mbasel + ma%mp(k+1)
                mt2 = mt2*mbasel + mb%mp(k+1)
             enddo
             mpma%mp(3+j/n21) = mt1
             mpmb%mp(3+j/n21) = mt2
             l = j
          enddo
          do j = 3+l/n21, ndig+ngrdn+1
             mpma%mp(j+1) = 0
             mpmb%mp(j+1) = 0
          enddo
          if (l+n21 <= ndigl+1) then
              mt1 = 0
              mt2 = 0
              do j = l+n21, l+2*n21-1
                 if (j <= ndigl+1) then
                     mt1 = mt1*mbasel + ma%mp(j+1)
                     mt2 = mt2*mbasel + mb%mp(j+1)
                 else
                     mt1 = mt1*mbasel
                     mt2 = mt2*mbasel
                 endif
              enddo
              mpma%mp(3+(l+n21)/n21) = mt1
              mpmb%mp(3+(l+n21)/n21) = mt2
          endif
          call fmmpy3(mpma, mpmb, ngrdn, kshift)
          if (mwa%mp(3) == 0) then
              do j = 3, 1+ndig+ngrdn
                 mwa%mp(j) = mwa%mp(j+1)
              enddo
              mwa%mp(ndig+ngrdn+2) = 0
              kshift = 0
          endif
          if (mbasel == 2 .and. mbase < intmax) then
              do j = 1+ndig+ngrdn, 2, -1
                 kt1 = mwa%mp(j+1)
                 kt = 2 + (j-2)*n21
                 kt2 = n21 + kt - 1
                 do k = kt, min(1+(j-1)*n21, ndigl+nguard+2)
                    mwa%mp(k+1) = ibits(kt1, kt2-k, 1)
                 enddo
              enddo
          else
              ms = mbasel**(n21-1)
              do j = 1+ndig+ngrdn, 2, -1
                 mr = ms
                 mt1 = mwa%mp(j+1)
                 do k = 2+(j-2)*n21, min(1+(j-1)*n21, ndigl+nguard+2)
                    mwa%mp(k+1) = aint (mt1/mr)
                    mt1 = mt1 - mwa%mp(k+1)*mr
                    mr = aint (mr/mbasel)
                 enddo
              enddo
          endif
          kshift = 0
          if (mwa%mp(3) == 0) kshift = 1
          mwa%mp(2) = ma%mp(2) + mb%mp(2)
          ndig = ndigl
          mbase = mbasel
          if (mblogs /= mbase) call fmcons
      else

!             This is the normal case, where the base is not small.

          call fmmpy3(ma, mb, nguard, kshift)
      endif

!             The multiplication is complete.
!             Round the result, move it to mc, and append the correct sign.

      if ((ma%mp(1) > 0 .and. mb%mp(1) > 0) .or. (ma%mp(1) < 0 .and. mb%mp(1) < 0)) then
          jrsign = 1
      else
          jrsign = -1
      endif

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      if (ncall >= 1) then
          kl = min(nguard, int(3*dlogtn/dlogmb + 1.5))
          err = 0
          do j = kl, 1, -1
             err = (err + mwa%mp(j+kshift+ndig+2)) / mbase
          enddo
          if ( (kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
               (kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) kr_retry = kr_retry + 1
      endif
      if (kr_retry == 1 .and. nguard < ndig+2) then
          kr_retry = 2
          retry = .true.
          return
      endif
      mr = 2*mwa%mp(kshift+ndig+3) + 1
      if (kround == -1 .or. kround == 2) then
          call fmrnd(mwa, ndig, nguard, kshift)
      else if (mr >= mbase) then
          if (mr-1 > mbase .and. mwa%mp(kshift+n1+1) < mbase-1) then
              if (kround /= 0) then
                  mwa%mp(kshift+n1+1) = mwa%mp(kshift+n1+1) + 1
                  mwa%mp(kshift+n1+2) = 0
              endif
          else
              call fmrnd(mwa, ndig, nguard, kshift)
          endif
      endif
      call fmmove(mwa, mc)

      mc%mp(1) = 1
      if (ma%mp(1)*mb%mp(1) < 0 .and. mc%mp(2) /= munkno .and.  &
          mc%mp(3) /= 0) mc%mp(1) = -1
      jrsign = jrssav

      return
      end subroutine fmmpy_m1

      subroutine fmmpy_r1(ma, mb)

!  ma = ma * mb

!  When one of the numbers ma, mb is known to have more zero digits (base mbase) than the other,
!  it is faster if mb is the one with more zero digits.

!  This routine performs the trace printing for multiplication.
!  fmmpy2_r1 is used to do the arithmetic.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: mb
      intent (inout) :: ma

      integer :: kovun

      ncall = ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == mexpov .or. abs(mb%mp(2)) == mexpov) kovun = 1
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) kovun = 2
      if (ntrace /= 0) then
          namest(ncall) = 'FMMPY_R1'
          call fmntr_inp2(ma, mb)
      endif

      call fmmpy2_r1(ma, mb)

      if ((abs(ma%mp(2)) == mexpov .and. kovun == 0) .or.  &
          (abs(ma%mp(2)) == munkno .and. kovun < 2)) then
          namest(ncall) = 'FMMPY_R1'
          call fmwarn
      endif
      if (ntrace /= 0) then
          call fmntr_out1(ma)
      endif
      ncall = ncall - 1

      return
      end subroutine fmmpy_r1

      subroutine fmmpy_r1_m1(ma, mb, kr_retry, retry)

!  Method 1 for computing ma = ma * mb.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: kr_retry
      logical :: retry
      intent (in) :: mb
      intent (inout) :: ma, kr_retry, retry

      real (kind(1.0d0)) :: mr, ms, mt1, mt2
      double precision :: err
      integer :: j, jrssav, k, kl, kshift, kt, kt1, kt2, l, n1, nguard

      kflag = 0
      jrssav = jrsign

!             nguard is the number of guard digits used.

      if (ncall > 1) then
          nguard = ngrd22
          if (nguard > ndig) nguard = ndig
      else
          nguard = ngrd52
          if (nguard > ndig) nguard = ndig
          if (kr_retry >= 1) then
              nguard = ndig + 2
          else if (mbase < 10**6) then
              nguard = min(nguard+1, ndig+2)
          endif
      endif
      if (ma%mp(3)*mb%mp(3) < mbase .and. nguard < 3) nguard = 3

      n1 = ndig + 1

      if (mbase*mbase <= mxbase/(4*mbase)) then

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2**24) while
!             doing the operation.

          if (ndigl /= ndig .or. mbasel /= mbase .or. nguarl /= nguard) then
              mbasel = mbase
              ndigl = ndig
              nguarl = nguard
              do j = 2, 1000
                 mr = mbase*mbasel
                 if (4*mr > mxbase) then
                     n21 = j - 1
                     ndig = (ndigl-1)/n21 + 1
                     if (ndig < 3) ndig = 3
                     ngrdn = (ndigl+nguard-1)/n21 + 2 - ndig
                     if (ngrdn < 1) ngrdn = 1
                     exit
                 endif
                 mbase = mr
              enddo
              mbasen = mbase
              ndign = ndig
          else
              mbase = mbasen
              ndig = ndign
          endif
          if (mblogs /= mbase) call fmcons
          j = ndig
          ndig = ndig + ngrdn + 5
          call fmalloc(mpma, ndig+2)
          call fmalloc(mpmb, ndig+2)
          ndig = j
          mpma%mp(1) = ma%mp(1)
          mpmb%mp(1) = mb%mp(1)
          mpma%mp(2) = 0
          mpmb%mp(2) = 0
          l = 2 - n21
          do j = 2, ndigl+2-n21, n21
             mt1 = ma%mp(j+1)
             mt2 = mb%mp(j+1)
             do k = j+1, j+n21-1
                mt1 = mt1*mbasel + ma%mp(k+1)
                mt2 = mt2*mbasel + mb%mp(k+1)
             enddo
             mpma%mp(3+j/n21) = mt1
             mpmb%mp(3+j/n21) = mt2
             l = j
          enddo
          do j = 3+l/n21, ndig+ngrdn+1
             mpma%mp(j+1) = 0
             mpmb%mp(j+1) = 0
          enddo
          if (l+n21 <= ndigl+1) then
              mt1 = 0
              mt2 = 0
              do j = l+n21, l+2*n21-1
                 if (j <= ndigl+1) then
                     mt1 = mt1*mbasel + ma%mp(j+1)
                     mt2 = mt2*mbasel + mb%mp(j+1)
                 else
                     mt1 = mt1*mbasel
                     mt2 = mt2*mbasel
                 endif
              enddo
              mpma%mp(3+(l+n21)/n21) = mt1
              mpmb%mp(3+(l+n21)/n21) = mt2
          endif
          call fmmpy3(mpma, mpmb, ngrdn, kshift)
          if (mwa%mp(3) == 0) then
              do j = 3, 1+ndig+ngrdn
                 mwa%mp(j) = mwa%mp(j+1)
              enddo
              mwa%mp(ndig+ngrdn+2) = 0
              kshift = 0
          endif
          if (mbasel == 2 .and. mbase < intmax) then
              do j = 1+ndig+ngrdn, 2, -1
                 kt1 = mwa%mp(j+1)
                 kt = 2 + (j-2)*n21
                 kt2 = n21 + kt - 1
                 do k = kt, min(1+(j-1)*n21, ndigl+nguard+2)
                    mwa%mp(k+1) = ibits(kt1, kt2-k, 1)
                 enddo
              enddo
          else
              ms = mbasel**(n21-1)
              do j = 1+ndig+ngrdn, 2, -1
                 mr = ms
                 mt1 = mwa%mp(j+1)
                 do k = 2+(j-2)*n21, min(1+(j-1)*n21, ndigl+nguard+2)
                    mwa%mp(k+1) = aint (mt1/mr)
                    mt1 = mt1 - mwa%mp(k+1)*mr
                    mr = aint (mr/mbasel)
                 enddo
              enddo
          endif
          kshift = 0
          if (mwa%mp(3) == 0) kshift = 1
          mwa%mp(2) = ma%mp(2) + mb%mp(2)
          ndig = ndigl
          mbase = mbasel
          if (mblogs /= mbase) call fmcons
      else

!             This is the normal case, where the base is not small.

          call fmmpy3(ma, mb, nguard, kshift)
      endif

!             The multiplication is complete.
!             Round the result, move it to mc, and append the correct sign.

      if ((ma%mp(1) > 0 .and. mb%mp(1) > 0) .or. (ma%mp(1) < 0 .and. mb%mp(1) < 0)) then
          jrsign = 1
      else
          jrsign = -1
      endif

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      if (ncall >= 1) then
          kl = min(nguard, int(3*dlogtn/dlogmb + 1.5))
          err = 0
          do j = kl, 1, -1
             err = (err + mwa%mp(j+kshift+ndig+2)) / mbase
          enddo
          if ( (kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
               (kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) kr_retry = kr_retry + 1
      endif
      if (kr_retry == 1 .and. nguard < ndig+2) then
          kr_retry = 2
          retry = .true.
          return
      endif
      mr = 2*mwa%mp(kshift+ndig+3) + 1
      if (kround == -1 .or. kround == 2) then
          call fmrnd(mwa, ndig, nguard, kshift)
      else if (mr >= mbase) then
          if (mr-1 > mbase .and. mwa%mp(kshift+n1+1) < mbase-1) then
              if (kround /= 0) then
                  mwa%mp(kshift+n1+1) = mwa%mp(kshift+n1+1) + 1
                  mwa%mp(kshift+n1+2) = 0
              endif
          else
              call fmrnd(mwa, ndig, nguard, kshift)
          endif
      endif
      k = ma%mp(1) * mb%mp(1)
      call fmmove(mwa, ma)

      if (k < 0 .and. ma%mp(2) /= munkno .and. ma%mp(3) /= 0) then
          ma%mp(1) = -1
      else
          ma%mp(1) = 1
      endif
      jrsign = jrssav

      return
      end subroutine fmmpy_r1_m1

      subroutine fmmpy_r1_sc(ma, mb, kresult)

!  Check for special cases for ma = ma * mb.

!  kresult = 1 is returned if a special case gives the value of ma.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: kresult
      intent (in) :: mb
      intent (inout) :: ma, kresult

      integer :: jrssav
      type(multi), save :: mxy

      if (mblogs /= mbase) call fmcons
      jrssav = jrsign
      kresult = 0
      kflag = 0
      if ( (ma%mp(2) == munkno .and. ma%mp(5) >= 0) .or.  &
           (mb%mp(2) == munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(ma)
          kflag = -4
          kresult = 1
          return
      endif
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) then
          call fmovun_mpy(ma, mb, mxy)
          call fmeq(mxy, ma)
          kresult = 1
          return
      endif
      if (abs(ma%mp(2)) == mexpov .or. abs(mb%mp(2)) == mexpov) then
          call fmovun_mpy(ma, mb, mxy)
          call fmeq(mxy, ma)
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0 .or. mb%mp(3) == 0) then
          call fmi2m2(0, ma)
          jrsign = jrssav
          kresult = 1
          return
      endif

      return
      end subroutine fmmpy_r1_sc

      subroutine fmmpy_r2(ma, mb)

!  mb = ma * mb

!  When one of the numbers ma, mb is known to have more zero digits (base mbase) than the other,
!  it is faster if mb is the one with more zero digits.

!  This routine performs the trace printing for multiplication.
!  fmmpy2_r2 is used to do the arithmetic.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      integer :: kovun

      ncall = ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == mexpov .or. abs(mb%mp(2)) == mexpov) kovun = 1
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) kovun = 2
      if (ntrace /= 0) then
          namest(ncall) = 'FMMPY_R2'
          call fmntr_inp2(ma, mb)
      endif

      call fmmpy2_r2(ma, mb)

      if ((abs(mb%mp(2)) == mexpov .and. kovun == 0) .or.  &
          (abs(mb%mp(2)) == munkno .and. kovun < 2)) then
          namest(ncall) = 'FMSUB'
          call fmwarn
      endif
      if (ntrace /= 0) then
          call fmntr_out1(mb)
      endif
      ncall = ncall - 1

      return
      end subroutine fmmpy_r2

      subroutine fmmpy_r2_m1(ma, mb, kr_retry, retry)

!  Method 1 for computing mb = ma * mb.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: kr_retry
      logical :: retry
      intent (in) :: ma
      intent (inout) :: mb, kr_retry, retry

      real (kind(1.0d0)) :: mr, ms, mt1, mt2
      double precision :: err
      integer :: j, jrssav, k, kl, kshift, kt, kt1, kt2, l, n1, nguard

      kflag = 0
      jrssav = jrsign

!             nguard is the number of guard digits used.

      if (ncall > 1) then
          nguard = ngrd22
          if (nguard > ndig) nguard = ndig
      else
          nguard = ngrd52
          if (nguard > ndig) nguard = ndig
          if (kr_retry >= 1) then
              nguard = ndig + 2
          else if (mbase < 10**6) then
              nguard = min(nguard+1, ndig+2)
          endif
      endif
      if (ma%mp(3)*mb%mp(3) < mbase .and. nguard < 3) nguard = 3

      n1 = ndig + 1

      if (mbase*mbase <= mxbase/(4*mbase)) then

!             If a small base is being used (for example, using base 2 to check some machine
!             precision results), it is faster to switch to a larger base (like 2**24) while
!             doing the operation.

          if (ndigl /= ndig .or. mbasel /= mbase .or. nguarl /= nguard) then
              mbasel = mbase
              ndigl = ndig
              nguarl = nguard
              do j = 2, 1000
                 mr = mbase*mbasel
                 if (4*mr > mxbase) then
                     n21 = j - 1
                     ndig = (ndigl-1)/n21 + 1
                     if (ndig < 3) ndig = 3
                     ngrdn = (ndigl+nguard-1)/n21 + 2 - ndig
                     if (ngrdn < 1) ngrdn = 1
                     exit
                 endif
                 mbase = mr
              enddo
              mbasen = mbase
              ndign = ndig
          else
              mbase = mbasen
              ndig = ndign
          endif
          if (mblogs /= mbase) call fmcons
          j = ndig
          ndig = ndig + ngrdn + 5
          call fmalloc(mpma, ndig+2)
          call fmalloc(mpmb, ndig+2)
          ndig = j
          mpma%mp(1) = ma%mp(1)
          mpmb%mp(1) = mb%mp(1)
          mpma%mp(2) = 0
          mpmb%mp(2) = 0
          l = 2 - n21
          do j = 2, ndigl+2-n21, n21
             mt1 = ma%mp(j+1)
             mt2 = mb%mp(j+1)
             do k = j+1, j+n21-1
                mt1 = mt1*mbasel + ma%mp(k+1)
                mt2 = mt2*mbasel + mb%mp(k+1)
             enddo
             mpma%mp(3+j/n21) = mt1
             mpmb%mp(3+j/n21) = mt2
             l = j
          enddo
          do j = 3+l/n21, ndig+ngrdn+1
             mpma%mp(j+1) = 0
             mpmb%mp(j+1) = 0
          enddo
          if (l+n21 <= ndigl+1) then
              mt1 = 0
              mt2 = 0
              do j = l+n21, l+2*n21-1
                 if (j <= ndigl+1) then
                     mt1 = mt1*mbasel + ma%mp(j+1)
                     mt2 = mt2*mbasel + mb%mp(j+1)
                 else
                     mt1 = mt1*mbasel
                     mt2 = mt2*mbasel
                 endif
              enddo
              mpma%mp(3+(l+n21)/n21) = mt1
              mpmb%mp(3+(l+n21)/n21) = mt2
          endif
          call fmmpy3(mpma, mpmb, ngrdn, kshift)
          if (mwa%mp(3) == 0) then
              do j = 3, 1+ndig+ngrdn
                 mwa%mp(j) = mwa%mp(j+1)
              enddo
              mwa%mp(ndig+ngrdn+2) = 0
              kshift = 0
          endif
          if (mbasel == 2 .and. mbase < intmax) then
              do j = 1+ndig+ngrdn, 2, -1
                 kt1 = mwa%mp(j+1)
                 kt = 2 + (j-2)*n21
                 kt2 = n21 + kt - 1
                 do k = kt, min(1+(j-1)*n21, ndigl+nguard+2)
                    mwa%mp(k+1) = ibits(kt1, kt2-k, 1)
                 enddo
              enddo
          else
              ms = mbasel**(n21-1)
              do j = 1+ndig+ngrdn, 2, -1
                 mr = ms
                 mt1 = mwa%mp(j+1)
                 do k = 2+(j-2)*n21, min(1+(j-1)*n21, ndigl+nguard+2)
                    mwa%mp(k+1) = aint (mt1/mr)
                    mt1 = mt1 - mwa%mp(k+1)*mr
                    mr = aint (mr/mbasel)
                 enddo
              enddo
          endif
          kshift = 0
          if (mwa%mp(3) == 0) kshift = 1
          mwa%mp(2) = ma%mp(2) + mb%mp(2)
          ndig = ndigl
          mbase = mbasel
          if (mblogs /= mbase) call fmcons
      else

!             This is the normal case, where the base is not small.

          call fmmpy3(ma, mb, nguard, kshift)
      endif

!             The multiplication is complete.
!             Round the result, move it to mc, and append the correct sign.

      if ((ma%mp(1) > 0 .and. mb%mp(1) > 0) .or. (ma%mp(1) < 0 .and. mb%mp(1) < 0)) then
          jrsign = 1
      else
          jrsign = -1
      endif

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      if (ncall >= 1) then
          kl = min(nguard, int(3*dlogtn/dlogmb + 1.5))
          err = 0
          do j = kl, 1, -1
             err = (err + mwa%mp(j+kshift+ndig+2)) / mbase
          enddo
          if ( (kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
               (kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) kr_retry = kr_retry + 1
      endif
      if (kr_retry == 1 .and. nguard < ndig+2) then
          kr_retry = 2
          retry = .true.
          return
      endif
      mr = 2*mwa%mp(kshift+ndig+3) + 1
      if (kround == -1 .or. kround == 2) then
          call fmrnd(mwa, ndig, nguard, kshift)
      else if (mr >= mbase) then
          if (mr-1 > mbase .and. mwa%mp(kshift+n1+1) < mbase-1) then
              if (kround /= 0) then
                  mwa%mp(kshift+n1+1) = mwa%mp(kshift+n1+1) + 1
                  mwa%mp(kshift+n1+2) = 0
              endif
          else
              call fmrnd(mwa, ndig, nguard, kshift)
          endif
      endif
      k = ma%mp(1) * mb%mp(1)
      call fmmove(mwa, mb)

      if (k < 0 .and. mb%mp(2) /= munkno .and. mb%mp(3) /= 0) then
          mb%mp(1) = -1
      else
          mb%mp(1) = 1
      endif
      jrsign = jrssav

      return
      end subroutine fmmpy_r2_m1

      subroutine fmmpy_r2_sc(ma, mb, kresult)

!  Check for special cases for mb = ma * mb.

!  kresult = 1 is returned if a special case gives the value of mb.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: kresult
      intent (in) :: ma
      intent (inout) :: mb, kresult

      integer :: jrssav
      type(multi), save :: mxy

      if (mblogs /= mbase) call fmcons
      jrssav = jrsign
      kresult = 0
      kflag = 0
      if ( (ma%mp(2) == munkno .and. ma%mp(5) >= 0) .or.  &
           (mb%mp(2) == munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mb)
          kflag = -4
          kresult = 1
          return
      endif
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) then
          call fmovun_mpy(ma, mb, mxy)
          call fmeq(mxy, mb)
          kresult = 1
          return
      endif
      if (abs(ma%mp(2)) == mexpov .or. abs(mb%mp(2)) == mexpov) then
          call fmovun_mpy(ma, mb, mxy)
          call fmeq(mxy, mb)
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0 .or. mb%mp(3) == 0) then
          call fmi2m2(0, mb)
          jrsign = jrssav
          kresult = 1
          return
      endif

      return
      end subroutine fmmpy_r2_sc

      subroutine fmmpy_sc(ma, mb, mc, kresult)

!  Check for special cases for mc = ma * mb.

!  kresult = 1 is returned if a special case gives the value of mc.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      integer :: kresult
      intent (in) :: ma, mb
      intent (inout) :: mc, kresult

      integer :: jrssav

      if (mblogs /= mbase) call fmcons
      jrssav = jrsign
      kresult = 0
      kflag = 0
      if ( (ma%mp(2) == munkno .and. ma%mp(5) >= 0) .or.  &
           (mb%mp(2) == munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc)
          kflag = -4
          kresult = 1
          return
      endif
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) then
          call fmovun_mpy(ma, mb, mc)
          kresult = 1
          return
      endif
      if (abs(ma%mp(2)) == mexpov .or. abs(mb%mp(2)) == mexpov) then
          call fmovun_mpy(ma, mb, mc)
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0 .or. mb%mp(3) == 0) then
          call fmi2m2(0, mc)
          jrsign = jrssav
          kresult = 1
          return
      endif

      return
      end subroutine fmmpy_sc

      subroutine fmmpyd(ma, mb, mc, md, me)

!  Double multiplication routine.  md = ma * mb,   me = ma * mc

!  It is usually slightly faster to do two multiplications by the same factor with one call.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md, me
      intent (in) :: ma, mb, mc
      intent (inout) :: md, me

      integer :: kovun

      ncall = ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == mexpov .or. abs(mb%mp(2)) == mexpov .or.  &
          abs(mc%mp(2)) == mexpov) kovun = 1
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno .or.  &
          mc%mp(2) == munkno) kovun = 2
      if (ntrace /= 0) then
          namest(ncall) = 'FMMPYD'
          call fmntr_inp3(ma, mb, mc)
      endif

      call fmmpyd2(ma, mb, mc, md, me)

      if ((abs(md%mp(2)) == mexpov .and. kovun == 0) .or.  &
          (abs(me%mp(2)) == mexpov .and. kovun == 0) .or.  &
          (abs(md%mp(2)) == munkno .and. kovun < 2)  .or.  &
          (abs(me%mp(2)) == munkno .and. kovun < 2)) then
          namest(ncall) = 'FMMPYD'
          call fmwarn
      endif
      if (ntrace /= 0) then
          call fmntr_out2(md, me)
      endif
      ncall = ncall - 1

      return
      end subroutine fmmpyd

      subroutine fmmpyd2(ma, mb, mc, md, me)

!  Double multiplication routine.  md = ma * mb,   me = ma * mc

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md, me
      intent (in) :: ma, mb, mc
      intent (inout) :: md, me

      integer :: jrssav, kresult

      call fmalloc(md, ndig+2)
      call fmalloc(me, ndig+2)
      call fmalloc(mwa, 2*ndig+30)
      call fmalloc(mwd, 2*ndig+30)
      call fmmpyd_sc(ma, mb, mc, md, me, kresult)
      if (kresult > 0) then
          return
      endif
      jrssav = jrsign

      if (mblogs /= mbase) call fmcons

      call fmmpyd_m1(ma, mb, mc, md, me)
      jrsign = jrssav

      return
      end subroutine fmmpyd2

      subroutine fmmpyd3(k, ma, mb, mc, mw, mr)

!  Round from the work area mw to mr.

!  k = 1 for rounding mw = ma * mb
!  k = 2 for rounding mw = ma * mc

      use fmvals
      implicit none

      integer :: k
      type(multi) :: ma, mb, mc, mw, mr
      intent (in) :: k, ma, mb, mc
      intent (inout) :: mw, mr

      real (kind(1.0d0)) :: mlr
      double precision :: err
      integer :: j, kl, n1, nguard

      if (ncall > 1) then
          nguard = ngrd21
          if (nguard > ndig) nguard = ndig
      else
          nguard = ngrd52 - 1
      endif
      n1 = ndig + 1

      if (k == 1) then
          jrsign = ma%mp(1) * mb%mp(1)
      else
          jrsign = ma%mp(1) * mc%mp(1)
      endif
      if (mw%mp(3) == 0) then
          if (ncall >= 1) then
              kl = min(nguard, int(3*dlogtn/dlogmb + 1.5))
              err = 0
              do j = kl, 1, -1
                 err = (err + mw%mp(j+ndig+3)) / mbase
              enddo
              if ( (kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
                   (kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) then
                  if (k == 1) then
                      call fmmpy2(ma, mb, mr)
                  else
                      call fmmpy2(ma, mc, mr)
                  endif
                  return
              endif
          endif
          mlr = 2*mw%mp(ndig+4) + 1
          if (kround == -1 .or. kround == 2) then
              call fmrnd(mw, ndig, nguard, 1)
          else if (mlr >= mbase) then
              if (mlr-1 > mbase .and. mw%mp(n1+2) < mbase-1) then
                  if (kround /= 0) then
                      mw%mp(n1+2) = mw%mp(n1+2) + 1
                      mw%mp(n1+3) = 0
                  endif
              else
                  call fmrnd(mw, ndig, nguard, 1)
              endif
          endif
      else
          if (ncall >= 1) then
              kl = min(nguard, int(3*dlogtn/dlogmb + 1.5))
              err = 0
              do j = kl, 1, -1
                 err = (err + mw%mp(j+ndig+2)) / mbase
              enddo
              if ( (kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
                   (kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) then
                  if (k == 1) then
                      call fmmpy2(ma, mb, mr)
                  else
                      call fmmpy2(ma, mc, mr)
                  endif
                  return
              endif
          endif
          mlr = 2*mw%mp(ndig+3) + 1
          if (kround == -1 .or. kround == 2) then
              call fmrnd(mw, ndig, nguard, 0)
          else if (mlr >= mbase) then
              if (mlr-1 > mbase .and. mw%mp(n1+1) < mbase-1) then
                  if (kround /= 0) then
                      mw%mp(n1+1) = mw%mp(n1+1) + 1
                      mw%mp(n1+2) = 0
                  endif
              else
                  call fmrnd(mw, ndig, nguard, 0)
              endif
          endif
      endif
      call fmmove(mw, mr)

      return
      end subroutine fmmpyd3

      subroutine fmmpyd_m1(ma, mb, mc, md, me)

!  Method 1 for computing  md = ma * mb,   me = ma * mc

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md, me
      intent (in) :: ma, mb, mc
      intent (inout) :: md, me

      real (kind(1.0d0)) :: maxmwa, mbj, mbkj, mbnorm, mbp1, mcj, mckj, mkb, mkc, mkt,  &
                            mmax, mt, mtemp
      integer :: j, jm1, k, kb, ki, kj, kl, knz, kwa, l, n1, nguard

      kflag = 0

!             nguard is the number of guard digits used.

      if (ncall > 1) then
          nguard = ngrd22
          if (nguard > ndig) nguard = ndig
      else
          nguard = ngrd52
          if (nguard > ndig) nguard = ndig
          if (mbase < 10**6) nguard = min(nguard+1, ndig+2)
      endif
      if ((ma%mp(3)*mb%mp(3) < mbase .or.  &
           ma%mp(3)*mc%mp(3) < mbase) .and. nguard < 3) nguard = 3

      n1 = ndig + 1
      mwa%mp(2) = ma%mp(2) + mb%mp(2)
      mwd%mp(2) = ma%mp(2) + mc%mp(2)
      l = ndig + 1 + nguard
      mwa%mp(l+2) = 0
      mwd%mp(l+2) = 0

!             The multiplication loop begins here.

!             mbnorm is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             maxmwa is an upper bound on the size of values in mwa divided by (mbase-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      mbp1 = mbase + 1
      mbnorm = (maxint/(mbp1*mbp1))
      mmax = intmax - mbase
      mmax = min((maxint/mbp1 - mbp1), mmax)
      if (mbnorm >= 2) then
          mbj = mb%mp(3)
          mcj = mc%mp(3)

!             Count the trailing zeros in ma.

          knz = n1
          if (ma%mp(n1+1) /= 0) then
              knz = n1
          else
              do j = ndig, 2, -1
                 if (ma%mp(j+1) /= 0) then
                     knz = j
                     exit
                 endif
              enddo
          endif

          mwa%mp(3) = 0
          mwd%mp(3) = 0
          do k = ndig+2, l
             mwa%mp(k+1) = 0
             mwd%mp(k+1) = 0
          enddo

!             (Inner Loop)

          do k = 2, n1
             mtemp = ma%mp(k+1)
             mwa%mp(k+2) = mtemp*mbj
             mwd%mp(k+2) = mtemp*mcj
          enddo
          if (mbj > mcj) then
              maxmwa = mbj
          else
              maxmwa = mcj
          endif
          do j = 3, n1
             mbj = mb%mp(j+1)
             mcj = mc%mp(j+1)
             if (mbj > mcj) then
                 maxmwa = maxmwa + mbj
             else
                 maxmwa = maxmwa + mcj
             endif
             jm1 = j - 1
             kl = min(knz, l-jm1)

!                       Major (Inner Loop)

             do k = j+2, j+kl
                mtemp = ma%mp(k-jm1)
                mwa%mp(k) = mwa%mp(k) + mtemp*mbj
                mwd%mp(k) = mwd%mp(k) + mtemp*mcj
             enddo

             if (maxmwa > mmax) then
                 maxmwa = 0

!                       Here normalization is only required for the range of digits currently
!                       changing in mwa.

                 do kb = jm1+kl, jm1+2, -1
                    mkt = int (mwa%mp(kb+1)/mbase)
                    mwa%mp(kb) = mwa%mp(kb) + mkt
                    mwa%mp(kb+1) = mwa%mp(kb+1) - mkt*mbase
                    mkt = int (mwd%mp(kb+1)/mbase)
                    mwd%mp(kb) = mwd%mp(kb) + mkt
                    mwd%mp(kb+1) = mwd%mp(kb+1) - mkt*mbase
                 enddo
             endif
          enddo

!             Perform the final normalization.  (Inner Loop)

          do kb = l+1, 4, -1
             mkt = int (mwa%mp(kb)/mbase)
             mwa%mp(kb-1) = mwa%mp(kb-1) + mkt
             mwa%mp(kb) = mwa%mp(kb) - mkt*mbase
             mkt = int (mwd%mp(kb)/mbase)
             mwd%mp(kb-1) = mwd%mp(kb-1) + mkt
             mwd%mp(kb) = mwd%mp(kb) - mkt*mbase
          enddo

      else

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          do j = 2, l
             mwa%mp(j+1) = 0
             mwd%mp(j+1) = 0
          enddo
          kj = ndig + 2
          do j = 2, n1
             kj = kj - 1
             mbkj = mb%mp(kj+1)
             mckj = mc%mp(kj+1)
             kl = l - kj + 1
             if (kl > n1) kl = n1
             ki = kl + 2
             kwa = kl+ kj + 1
             mkb = 0
             mkc = 0
             do k = 2, kl
                mt = ma%mp(ki-k+1)*mbkj + mwa%mp(kwa-k+1) + mkb
                mkb = int (mt/mbase)
                mwa%mp(kwa-k+1) = mt - mbase*mkb
                mt = ma%mp(ki-k+1)*mckj + mwd%mp(kwa-k+1) + mkc
                mkc = int (mt/mbase)
                mwd%mp(kwa-k+1) = mt - mbase*mkc
             enddo
             mwa%mp(kwa-kl) = mkb
             mwd%mp(kwa-kl) = mkc
          enddo

      endif

!             The multiplications are complete.
!             Round, affix the sign, and return.

      call fmmpyd3(1, ma, mb, mc, mwa, md)
      call fmmpyd3(2, ma, mb, mc, mwd, me)

      md%mp(1) = ma%mp(1)*mb%mp(1)
      me%mp(1) = ma%mp(1)*mc%mp(1)

      return
      end subroutine fmmpyd_m1

      subroutine fmmpyd_sc(ma, mb, mc, md, me, kresult)

!  Check for special cases for  md = ma * mb  and  me = ma * mc.

!  kresult = 1 is returned if a special case gives the values of md, me.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md, me
      integer :: kresult
      intent (in) :: ma, mb, mc
      intent (inout) :: md, me, kresult

      integer :: kb, kc, kovun

      if (mblogs /= mbase) call fmcons
      kresult = 0
      kc = 3100
      if (ndig >= kc .or.                                          &
          abs(ma%mp(2)) > mexpab .or. abs(mb%mp(2)) > mexpab .or.  &
          abs(mc%mp(2)) > mexpab .or. mbase*mbase <= mxbase/(4*mbase)) then
          kovun = 0
          if (ma%mp(2) == mexpov .or. ma%mp(2) == mexpun .or.  &
              mb%mp(2) == mexpov .or. mb%mp(2) == mexpun .or.  &
              mc%mp(2) == mexpov .or. mc%mp(2) == mexpun) kovun = 1
          if (ma%mp(2) == munkno .or. mb%mp(2) == munkno .or.  &
              mc%mp(2) == munkno) kovun = 2
          ncall = ncall + 1
          call fmmpy2(ma, mb, md)
          kb = kflag
          call fmmpy2(ma, mc, me)
          ncall = ncall - 1
          if (((kflag < 0 .or. kb < 0) .and. kovun == 0) .or.  &
              ((kflag == -4 .or. kb == -4) .and. kovun == 1)) then
              if (kflag == -4 .or. kb == -4) then
                  kflag = -4
              else if (kflag == -5 .or. kb == -5) then
                  kflag = -5
              else
                  kflag = min(kflag, kb)
              endif
          endif
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0) then
          call fmi2m2(0, md)
          call fmi2m2(0, me)
          kresult = 1
          return
      endif
      if (mb%mp(3) == 0) then
          call fmmpy2(ma, mc, me)
          call fmi2m2(0, md)
          kresult = 1
          return
      endif
      if (mc%mp(3) == 0) then
          call fmmpy2(ma, mb, md)
          call fmi2m2(0, me)
          kresult = 1
          return
      endif
      kflag = 0

      return
      end subroutine fmmpyd_sc

      subroutine fmmpye(ma, mb, mc, md, me, mf, mg)

!  Triple multiplication routine.

!      me = ma * mb,   mf = ma * mc,   mg = ma * md

!  It is usually slightly faster to do three multiplications that have a common factor with
!  one call.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md, me, mf, mg
      intent (in) :: ma, mb, mc, md
      intent (inout) :: me, mf, mg

      integer :: kovun

      ncall = ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == mexpov .or. abs(mb%mp(2)) == mexpov .or.  &
          abs(mc%mp(2)) == mexpov .or. abs(md%mp(2)) == mexpov) kovun = 1
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno .or.  &
          mc%mp(2) == munkno .or. md%mp(2) == munkno) kovun = 2
      if (ntrace /= 0) then
          namest(ncall) = 'FMMPYE'
          call fmntr_inp4(ma, mb, mc, md)
      endif

      call fmmpye2(ma, mb, mc, md, me, mf, mg)

      if ((abs(me%mp(2)) == mexpov .and. kovun == 0) .or.  &
          (abs(mf%mp(2)) == mexpov .and. kovun == 0) .or.  &
          (abs(mg%mp(2)) == mexpov .and. kovun == 0) .or.  &
          (abs(me%mp(2)) == munkno .and. kovun < 2)  .or.  &
          (abs(mf%mp(2)) == munkno .and. kovun < 2)  .or.  &
          (abs(mg%mp(2)) == munkno .and. kovun < 2)) then
          namest(ncall) = 'FMMPYE'
          call fmwarn
      endif
      if (ntrace /= 0) then
          call fmntr_out3(me, mf, mg)
      endif
      ncall = ncall - 1

      return
      end subroutine fmmpye

      subroutine fmmpye2(ma, mb, mc, md, me, mf, mg)

!  Triple multiplication routine.  me = ma * mb,   mf = ma * mc,   mg = ma * md

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md, me, mf, mg
      intent (in) :: ma, mb, mc, md
      intent (inout) :: me, mf, mg

      integer :: jrssav, kresult

      call fmalloc(me, ndig+2)
      call fmalloc(mf, ndig+2)
      call fmalloc(mg, ndig+2)
      call fmalloc(mwa, 2*ndig+30)
      call fmalloc(mwd, 2*ndig+30)
      call fmalloc(mwe, 2*ndig+30)
      call fmmpye_sc(ma, mb, mc, md, me, mf, mg, kresult)
      if (kresult > 0) then
          return
      endif
      jrssav = jrsign

      if (mblogs /= mbase) call fmcons

      call fmmpye_m1(ma, mb, mc, md, me, mf, mg)
      jrsign = jrssav

      return
      end subroutine fmmpye2

      subroutine fmmpye3(k, ma, mb, mc, md, mw, mr)

!  Round from the work area mw to mr.

!  k = 1 for rounding mw = ma * mb
!  k = 2 for rounding mw = ma * mc
!  k = 3 for rounding mw = ma * md

      use fmvals
      implicit none

      integer :: k
      type(multi) :: ma, mb, mc, md, mw, mr
      intent (in) :: k, ma, mb, mc, md
      intent (inout) :: mw, mr

      real (kind(1.0d0)) :: mlr
      double precision :: err
      integer :: j, kl, n1, nguard

      if (ncall > 1) then
          nguard = ngrd21
          if (nguard > ndig) nguard = ndig
      else
          nguard = ngrd52 - 1
      endif
      n1 = ndig + 1

      if (k == 1) then
          jrsign = ma%mp(1) * mb%mp(1)
      else if (k == 2) then
          jrsign = ma%mp(1) * mc%mp(1)
      else
          jrsign = ma%mp(1) * md%mp(1)
      endif
      if (mw%mp(3) == 0) then
          if (ncall >= 1) then
              kl = min(nguard, int(3*dlogtn/dlogmb + 1.5))
              err = 0
              do j = kl, 1, -1
                 err = (err + mw%mp(j+ndig+3)) / mbase
              enddo
              if ( (kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
                   (kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) then
                  if (k == 1) then
                      call fmmpy2(ma, mb, mr)
                  else if (k == 2) then
                      call fmmpy2(ma, mc, mr)
                  else
                      call fmmpy2(ma, md, mr)
                  endif
                  return
              endif
          endif
          mlr = 2*mw%mp(ndig+4) + 1
          if (kround == -1 .or. kround == 2) then
              call fmrnd(mw, ndig, nguard, 1)
          else if (mlr >= mbase) then
              if (mlr-1 > mbase .and. mw%mp(n1+2) < mbase-1) then
                  if (kround /= 0) then
                      mw%mp(n1+2) = mw%mp(n1+2) + 1
                      mw%mp(n1+3) = 0
                  endif
              else
                  call fmrnd(mw, ndig, nguard, 1)
              endif
          endif
      else
          if (ncall >= 1) then
              kl = min(nguard, int(3*dlogtn/dlogmb + 1.5))
              err = 0
              do j = kl, 1, -1
                 err = (err + mw%mp(j+ndig+2)) / mbase
              enddo
              if ( (kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
                   (kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) then
                  if (k == 1) then
                      call fmmpy2(ma, mb, mr)
                  else if (k == 2) then
                      call fmmpy2(ma, mc, mr)
                  else
                      call fmmpy2(ma, md, mr)
                  endif
                  return
              endif
          endif
          mlr = 2*mw%mp(ndig+3) + 1
          if (kround == -1 .or. kround == 2) then
              call fmrnd(mw, ndig, nguard, 0)
          else if (mlr >= mbase) then
              if (mlr-1 > mbase .and. mw%mp(n1+1) < mbase-1) then
                  if (kround /= 0) then
                      mw%mp(n1+1) = mw%mp(n1+1) + 1
                      mw%mp(n1+2) = 0
                  endif
              else
                  call fmrnd(mw, ndig, nguard, 0)
              endif
          endif
      endif
      call fmmove(mw, mr)

      return
      end subroutine fmmpye3

      subroutine fmmpye_m1(ma, mb, mc, md, me, mf, mg)

!  Method 1 for computing  me = ma * mb,   mf = ma * mc,   mg = ma * md

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md, me, mf, mg
      intent (in) :: ma, mb, mc, md
      intent (inout) :: me, mf, mg

      real (kind(1.0d0)) :: maxmwa, maxj, mbj, mbkj, mbnorm, mbp1, mcj, mckj, mdj, mdkj,  &
                            mkb, mkc, mkd, mkt, mmax, mt, mtemp
      integer :: j, jm1, k, kb, ki, kj, kl, knz, kwa, l, n1, nguard

      kflag = 0

!             nguard is the number of guard digits used.

      if (ncall > 1) then
          nguard = ngrd22
          if (nguard > ndig) nguard = ndig
      else
          nguard = ngrd52
          if (nguard > ndig) nguard = ndig
          if (mbase < 10**6) nguard = min(nguard+1, ndig+2)
      endif
      if ((ma%mp(3)*mb%mp(3) < mbase .or.  &
           ma%mp(3)*mc%mp(3) < mbase .or.  &
           ma%mp(3)*md%mp(3) < mbase) .and. nguard < 3) nguard = 3

      n1 = ndig + 1
      mwa%mp(2) = ma%mp(2) + mb%mp(2)
      mwd%mp(2) = ma%mp(2) + mc%mp(2)
      mwe%mp(2) = ma%mp(2) + md%mp(2)
      l = ndig + 1 + nguard
      mwa%mp(l+2) = 0
      mwd%mp(l+2) = 0
      mwe%mp(l+2) = 0

!             The multiplication loop begins here.

!             mbnorm is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             maxmwa is an upper bound on the size of values in mwa divided by (mbase-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      mbp1 = mbase + 1
      mbnorm = (maxint/(mbp1*mbp1))
      mmax = intmax - mbase
      mmax = min((maxint/mbp1 - mbp1), mmax)
      if (mbnorm >= 2) then
          mbj = mb%mp(3)
          mcj = mc%mp(3)
          mdj = md%mp(3)

!             Count the trailing zeros in ma.

          knz = n1
          if (ma%mp(n1+1) /= 0) then
              knz = n1
          else
              do j = ndig, 2, -1
                 if (ma%mp(j+1) /= 0) then
                     knz = j
                     exit
                 endif
              enddo
          endif

          mwa%mp(3) = 0
          mwd%mp(3) = 0
          mwe%mp(3) = 0
          do k = ndig+2, l
             mwa%mp(k+1) = 0
             mwd%mp(k+1) = 0
             mwe%mp(k+1) = 0
          enddo

!             (Inner Loop)

          do k = 2, n1
             mtemp = ma%mp(k+1)
             mwa%mp(k+2) = mtemp*mbj
             mwd%mp(k+2) = mtemp*mcj
             mwe%mp(k+2) = mtemp*mdj
          enddo
          maxmwa = mbj
          if (mcj > maxmwa) maxmwa = mcj
          if (mdj > maxmwa) maxmwa = mdj
          do j = 3, n1
             mbj = mb%mp(j+1)
             mcj = mc%mp(j+1)
             mdj = md%mp(j+1)
             maxj = mbj
             if (mcj > maxj) maxj = mcj
             if (mdj > maxj) maxj = mdj
             maxmwa = maxmwa + maxj
             jm1 = j - 1
             kl = min(knz, l-jm1)

!                       Major (Inner Loop)

             do k = j+2, j+kl
                mtemp = ma%mp(k-jm1)
                mwa%mp(k) = mwa%mp(k) + mtemp*mbj
                mwd%mp(k) = mwd%mp(k) + mtemp*mcj
                mwe%mp(k) = mwe%mp(k) + mtemp*mdj
             enddo

             if (maxmwa > mmax) then
                 maxmwa = 0

!                       Here normalization is only required for the range of digits currently
!                       changing in mwa.

                 do kb = jm1+kl, jm1+2, -1
                    mkt = int (mwa%mp(kb+1)/mbase)
                    mwa%mp(kb) = mwa%mp(kb) + mkt
                    mwa%mp(kb+1) = mwa%mp(kb+1) - mkt*mbase
                    mkt = int (mwd%mp(kb+1)/mbase)
                    mwd%mp(kb) = mwd%mp(kb) + mkt
                    mwd%mp(kb+1) = mwd%mp(kb+1) - mkt*mbase
                    mkt = int (mwe%mp(kb+1)/mbase)
                    mwe%mp(kb) = mwe%mp(kb) + mkt
                    mwe%mp(kb+1) = mwe%mp(kb+1) - mkt*mbase
                 enddo
             endif
          enddo

!             Perform the final normalization.  (Inner Loop)

          do kb = l+1, 4, -1
             mkt = int (mwa%mp(kb)/mbase)
             mwa%mp(kb-1) = mwa%mp(kb-1) + mkt
             mwa%mp(kb) = mwa%mp(kb) - mkt*mbase
             mkt = int (mwd%mp(kb)/mbase)
             mwd%mp(kb-1) = mwd%mp(kb-1) + mkt
             mwd%mp(kb) = mwd%mp(kb) - mkt*mbase
             mkt = int (mwe%mp(kb)/mbase)
             mwe%mp(kb-1) = mwe%mp(kb-1) + mkt
             mwe%mp(kb) = mwe%mp(kb) - mkt*mbase
          enddo

      else

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          do j = 2, l
             mwa%mp(j+1) = 0
             mwd%mp(j+1) = 0
             mwe%mp(j+1) = 0
          enddo
          kj = ndig + 2
          do j = 2, n1
             kj = kj - 1
             mbkj = mb%mp(kj+1)
             mckj = mc%mp(kj+1)
             mdkj = md%mp(kj+1)
             kl = l - kj + 1
             if (kl > n1) kl = n1
             ki = kl + 2
             kwa = kl+ kj + 1
             mkb = 0
             mkc = 0
             mkd = 0
             do k = 2, kl
                mt = ma%mp(ki-k+1)*mbkj + mwa%mp(kwa-k+1) + mkb
                mkb = int (mt/mbase)
                mwa%mp(kwa-k+1) = mt - mbase*mkb
                mt = ma%mp(ki-k+1)*mckj + mwd%mp(kwa-k+1) + mkc
                mkc = int (mt/mbase)
                mwd%mp(kwa-k+1) = mt - mbase*mkc
                mt = ma%mp(ki-k+1)*mdkj + mwe%mp(kwa-k+1) + mkd
                mkd = int (mt/mbase)
                mwe%mp(kwa-k+1) = mt - mbase*mkd
             enddo
             mwa%mp(kwa-kl) = mkb
             mwd%mp(kwa-kl) = mkc
             mwe%mp(kwa-kl) = mkd
          enddo

      endif

!             Round, affix the sign, and return.

      call fmmpye3(1, ma, mb, mc, md, mwa, me)
      call fmmpye3(2, ma, mb, mc, md, mwd, mf)
      call fmmpye3(3, ma, mb, mc, md, mwe, mg)

      me%mp(1) = ma%mp(1)*mb%mp(1)
      mf%mp(1) = ma%mp(1)*mc%mp(1)
      mg%mp(1) = ma%mp(1)*md%mp(1)

      return
      end subroutine fmmpye_m1

      subroutine fmmpye_sc(ma, mb, mc, md, me, mf, mg, kresult)

!  Check for special cases for  me = ma * mb,   mf = ma * mc,   mg = ma * md.

!  kresult = 1 is returned if a special case gives the values of md, me.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md, me, mf, mg
      integer :: kresult
      intent (in) :: ma, mb, mc, md
      intent (inout) :: me, mf, mg, kresult

      integer :: kb, kc, kj, kovun

      if (mblogs /= mbase) call fmcons
      kresult = 0
      kc = 1000
      if (ndig >= kc .or.                                          &
          abs(ma%mp(2)) > mexpab .or. abs(mb%mp(2)) > mexpab .or.  &
          abs(mc%mp(2)) > mexpab .or. abs(md%mp(2)) > mexpab .or.  &
          mbase*mbase <= mxbase/(4*mbase)) then
          kovun = 0
          if (ma%mp(2) == mexpov .or. ma%mp(2) == mexpun .or.  &
              mb%mp(2) == mexpov .or. mb%mp(2) == mexpun .or.  &
              mc%mp(2) == mexpov .or. mc%mp(2) == mexpun .or.  &
              md%mp(2) == mexpov .or. md%mp(2) == mexpun) kovun = 1
          if (ma%mp(2) == munkno .or. mb%mp(2) == munkno .or.  &
              mc%mp(2) == munkno .or. md%mp(2) == munkno) kovun = 2
          ncall = ncall + 1
          call fmmpy2(ma, mb, me)
          kb = kflag
          call fmmpy2(ma, mc, mf)
          kj = kflag
          call fmmpy2(ma, md, mg)
          ncall = ncall - 1
          if (((kflag < 0 .or. kb < 0 .or. kj < 0) .and. kovun == 0)  &
              .or. ((kflag == -4 .or. kb == -4 .or. kj == -4) .and.   &
              kovun == 1)) then
              if (kflag == -4 .or. kb == -4 .or. kj == -4) then
                  kflag = -4
              else if (kflag == -5 .or. kb == -5 .or. kj == -5) then
                  kflag = -5
              else
                  kflag = min(kflag, kb)
                  kflag = min(kflag, kj)
              endif
          endif
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0) then
          call fmi2m2(0, me)
          call fmi2m2(0, mf)
          call fmi2m2(0, mg)
          kresult = 1
          return
      endif
      if (mb%mp(3) == 0 .or. mc%mp(3) == 0 .or. md%mp(3) == 0) then
          call fmmpy2(ma, mb, me)
          call fmmpy2(ma, mc, mf)
          call fmmpy2(ma, md, mg)
          kresult = 1
          return
      endif
      kflag = 0

      return
      end subroutine fmmpye_sc

      recursive subroutine fmmpyfft(ma, mb)

!  Internal multiplication routine ma*mb for very high precision.
!  The result is returned in the internal work area mwa.
!  Fast Fourier transforms are used, and the number of digits carried is usually raised slightly,
!  because the fft needs for n to have only small prime factors.

!  Use one of two methods, depending on the base mbase.  When precision is high enough, the size of
!  the digits being convolved using fft's must be reduced in order to keep the convolution products
!  from being too big to exactly recover the integer results.  The fft operation has double
!  precision rounding errors, but the result of the convolution of two lists of integers is really
!  an integer.

!  For example, assume double precision carries 53 bits giving about 16 significant digit accuracy,
!  all the (positive) numbers in the two lists are less than k, and there are n numbers in each
!  list.  Then the convolution is an integer less than n*k*k.  A typical case might have ma and mb
!  in base 10**7 with 50,000 digits for about 350,000 significant digit precision.  This means
!  k = 10**7 and n = 5*10**4, so n*k*k = 5*10**18.  That is too big for this double precision.

!  Method 1:  If the base is a power of a small base ( mbase = b**l for 2 <= b <= 19 ), then change
!             ma and mb to a base that is a smaller power of b to reduce the size of the individual
!             digits.  Changing to this smaller base is a fast o(n) operation.

!             In the example above, ma and mb could be changed to numbers with about 120,000 digits
!             in base 10**3.  Then n*k*k = 1.2*10**11, so even after losing 2 or 3 digits to
!             rounding in the fft the results could be reliably rounded to the nearest integer.

!             This is the method used for the default FM power-of-ten base chosen in fmset.
!             It is faster than method 2.

!  Method 2:  Here a fast change to a smaller base is not available, so each of ma and mb is split
!             into two pieces.  Each piece is a number with the same base and precision as ma and
!             mb have, but has artificially small digits.

!             Suppose the base is near 10**7 but not a power, say mbase = b = 12345678, and ma or
!             mb is
!                       x = 1234567/b + 2345678/b**2 + ... + 9876543/b**n

!             Let k = sqrt(b) = 3513 be the upper bound on the size of the digits in the two
!             pieces, x1 and x2.  We write x = x1 + k*x2 by defining the digits of x1 to be the
!             digits of x mod k, and the digits of x2 to be the digits of x / k.  That gives

!                       x1 = 1504/b + 2507/b**2 + ... + 1500/b**n
!                       x2 =  351/b +  667/b**2 + ... + 2811/b**n

!             Now, x*y = ( x1 + k*x2 ) ( y1 + k*y2 )
!                      =   x1*y1 + k*(x1*y2 + x2*y1) + k**2*x2*y2

!             Since the digits of x1 and x2 are formed one at a time from the corresponding digits
!             of x, generating x1 and x2 is a fast o(n) operation.

!             The terms in these products are still written in base b, but the digits are small,
!             no more than k.  These four multiplications are reduced to three, computing
!             x1*y1, x2*y2, and (x1+x2)*(y1+y2).
!             Then x1*y2 + x2*y1 = (x1+x2)*(y1+y2) - x1*y1 - x2*y2.  See Knuth, v 2, section 4.3.3.

!             Method 2 is recursive, since if n is large enough n*k*k may still be too large for
!             the double precision rounding errors.  In that case another splitting is done, giving
!             digits less than sqrt(aint(sqrt(b))) = 59 in this example.

!             For b = 12345678 and 53-bit double precision, the first splitting is done for all n,
!             since b**2 > 10**14 is already too close to 16-digit integers.
!             A second splitting is done for n larger than about 4*10**5 (about 2.8 million decimal
!             digits), and a third for n > 1.4*10**9 (about 10 billion decimals).

      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma, mb
      type(multi) :: mxy(8)
      integer :: j, k, l, ndsave
      double precision :: b, bl, d, dmax


!             Check to see if the base is a power of a small integer.

      do j = 2, 19
         if (j == 2 .or. j == 10) then
             b = 12 - j
         else
             b = j
         endif
         bl = 1
         do l = 1, 100
            bl = bl*b
            if (mbase == bl) then
                call fmmpyfft1(ma, mb, b, l)
                mwa%mp(2) = ma%mp(2) + mb%mp(2)
                return
            endif
            if (mbase < bl) exit
         enddo
      enddo

!             Use method 2.

!             Find the maximum size of the digits in ma and mb.

      dmax = 0
      do j = 1, ndig
         d = ma%mp(j+2)
         if (d > dmax) dmax = d
         d = mb%mp(j+2)
         if (d > dmax) dmax = d
      enddo

!             Check to see if splitting is needed.

      if (dmax**2 > 1/(4.0d3*ndig*epsilon(1.0d0))) then
          k = int(sqrt(dmax))
          ndsave = ndig
          ndig = 2*ndig + 2
          call fmequ(ma, mxy(1), ndsave, ndig)
          call fmequ(ma, mxy(2), ndsave, ndig)
          call fmequ(mb, mxy(3), ndsave, ndig)
          call fmequ(mb, mxy(4), ndsave, ndig)
          call fmi2m2(0, mxy(5))
          call fmi2m2(0, mxy(6))
          call fmi2m2(0, mxy(7))
          call fmi2m2(0, mxy(8))
          do j = 1, ndig
             l = mxy(1)%mp(j+2)
             mxy(1)%mp(j+2) = mod(l, k)
             mxy(2)%mp(j+2) = l/k
             l = mxy(3)%mp(j+2)
             mxy(3)%mp(j+2) = mod(l, k)
             mxy(4)%mp(j+2) = l/k
          enddo

!             Normalize any of these having a zero leading digit.

          if (mxy(1)%mp(3) == 0) call fmmpyfft_norm(mxy(1))
          if (mxy(2)%mp(3) == 0) call fmmpyfft_norm(mxy(2))
          if (mxy(3)%mp(3) == 0) call fmmpyfft_norm(mxy(3))
          if (mxy(4)%mp(3) == 0) call fmmpyfft_norm(mxy(4))

          ndig = ndsave
          call fmmpyfft(mxy(1), mxy(3))
          ndig = 2*ndig + 2
          call fmmove(mwa, mxy(5))
          ndig = ndsave
          call fmmpyfft(mxy(2), mxy(4))
          ndig = 2*ndig + 2
          call fmmove(mwa, mxy(6))
          call fmadd2(mxy(1), mxy(2), mxy(7))
          call fmadd2(mxy(3), mxy(4), mxy(8))
          ndig = ndsave
          call fmmpyfft(mxy(7), mxy(8))
          ndig = 2*ndig + 2
          call fmmove(mwa, mxy(7))
          ksub = 1
          call fmadd2(mxy(7), mxy(5), mxy(1))
          call fmadd2(mxy(1), mxy(6), mxy(2))
          ksub = 0
          call fmmpyffti(mxy(6), k, mxy(3))
          call fmadd2(mxy(3), mxy(2), mxy(4))
          call fmmpyffti(mxy(4), k, mxy(3))
          call fmadd2(mxy(3), mxy(5), mxy(4))
          mwa%mp(1) = mxy(4)%mp(1)
          mwa%mp(2) = mxy(4)%mp(2)
          if (mwa%mp(3) == 0) mwa%mp(2) = mwa%mp(2) + 1
          ndig = ndsave
      else
          call fmmpyfft2(ma, mb)
          mwa%mp(2) = ma%mp(2) + mb%mp(2)
      endif

      return
      end subroutine fmmpyfft

      subroutine fmmpyfft1(ma, mb, b, l)

      use fmvals
      implicit none

!  Internal multiplication routine ma*mb for very high precision.
!  The base for the arithmetic (mbase) is a power of b, b**l, for 2 <= b <= 19.  This includes the
!  usual case where the default base chosen in fmset is a power of 10.
!  Fast Fourier transforms are used, and the number of digits carried is usually raised slightly,
!  because the fft needs for n to have only small prime factors.

      type(multi) :: ma, mb
      real (kind(0.0d0)) :: b
      integer :: l
      intent (in) :: ma, mb, b, l

      integer :: bestdiff, bestk, bestm, diff, j, j2, k, k2, ka, n, n2, nd, nd1,  &
                 num, numar, numai, numbr, numbi
      real (kind(0.0d0)) :: base, c, d, t, t2, theta, tma, tmb
      complex (kind(0.0d0)) :: ci, h1, h2, st, w

!             Initialize guard digits in mwa.

      nd1 = size(mwa%mp)-2
      do j = 2*ndig, min(2*ndig+30, nd1)
         mwa%mp(j+2) = 0
      enddo

!             If the base and/or number of digits is too large, rounding errors in the fft
!             calculation will cause the result to be wrong.
!             Reduce the base if necessary.

      nd = ndig
      base = mbase
      if (mbase**2 > 1/(1.0d3*nd*epsilon(1.0d0))) then
          base = 1/sqrt(1.0d3*nd*epsilon(1.0d0))
          k = log(base)/log(b)
          base = b**k
          nd = ndig*dble(l)/k + 1
      endif

!             Choose the number of digits to use for the fft.
!             Make the size of the array m*2**k where m is a small integer.

      k = 0
      k2 = 1
      do j = 1, 100
         k = k + 1
         k2 = 2*k2
         if (k2 > nd) exit
      enddo
      bestm = 1
      bestk = k
      bestdiff = 2**k - nd
      do j = 3, 15, 2
         k = 0
         k2 = j
         do j2 = 1, 100
            k = k + 1
            k2 = 2*k2
            if (k2 > nd) exit
         enddo
         diff = k2 - nd
         if (diff < bestdiff) then
             bestdiff = diff
             bestm = j
             bestk = k
         endif
      enddo
      n = bestm * 2**bestk
      n2 = n*2
      j = 0
      if (.not. allocated(cx)) then
          allocate(cx(n), stat=j)
      else if (size(cx) /= n) then
          deallocate(cx)
          allocate(cx(n), stat=j)
      endif
      if (j /= 0) then
          call fmdefine_error
      endif
      j = 0
      if (.not. allocated(cy)) then
          allocate(cy(n), stat=j)
      else if (size(cy) /= n) then
          deallocate(cy)
          allocate(cy(n), stat=j)
      endif
      if (j /= 0) then
          call fmdefine_error
      endif
      j = 0
      if (.not. allocated(cz)) then
          allocate(cz(n), stat=j)
      else if (size(cz) /= n) then
          deallocate(cz)
          allocate(cz(n), stat=j)
      endif
      if (j /= 0) then
          call fmdefine_error
      endif
      j = 0
      if (.not. allocated(roots_of_unity)) then
          allocate(roots_of_unity(0:n-1), stat=j)
      else if (size(roots_of_unity) /= n) then
          deallocate(roots_of_unity)
          allocate(roots_of_unity(0:n-1), stat=j)
      endif
      if (j /= 0) then
          call fmdefine_error
      endif
      call fmfft_init(n)
      n_roots_of_unity = n

!             Pad the lists of digits with zeros, then pack the length 2*n real arrays into
!             length n complex arrays to speed up the fft operations.

      if (base == mbase) then
          do j = ndig/2, n
             cx(j) = 0
             cy(j) = 0
          enddo
          do j = 2, ndig, 2
             cx(j/2) = cmplx( ma%mp(j+1) , ma%mp(j+2) , kind(0.0d0) )
             cy(j/2) = cmplx( mb%mp(j+1) , mb%mp(j+2) , kind(0.0d0) )
          enddo
          if (mod(ndig, 2) == 1) then
              cx(ndig/2+1) = ma%mp(ndig+2)
              cy(ndig/2+1) = mb%mp(ndig+2)
          endif
      else
          do j = ndig/2, n
             cx(j) = 0
             cy(j) = 0
          enddo
          d = mbase/base
          c = mbase*d
          tma = ma%mp(3)*mbase + ma%mp(4)
          numar = tma/c
          tma = tma - c*numar
          tmb = mb%mp(3)*mbase + mb%mp(4)
          numbr = tmb/c
          tmb = tmb - c*numbr
          k = 0
          do j = 3, ndig
             do
                if (c >= base) then
                    c = c/base
                else
                    tma = tma*mbase + ma%mp(j+2)
                    tmb = tmb*mbase + mb%mp(j+2)
                    c = c*mbase
                    exit
                endif
                numai = tma/c
                tma = tma - c*numai
                numbi = tmb/c
                tmb = tmb - c*numbi
                if (numar < 0) then
                    numar = numai
                    numbr = numbi
                else
                    k = k + 1
                    cx(k) = cmplx( dble(numar) , dble(numai) , kind(0.0d0) )
                    cy(k) = cmplx( dble(numbr) , dble(numbi) , kind(0.0d0) )
                    numar = -1
                endif
             enddo
          enddo
          do
             if (c >= base) then
                 c = c/base
             else
                 numai = tma*(base/c)
                 numbi = tmb*(base/c)
                 if (numar < 0) then
                     k = k + 1
                     cx(k) = cmplx( dble(numai) , 0.0d0 , kind(0.0d0) )
                     cy(k) = cmplx( dble(numbi) , 0.0d0 , kind(0.0d0) )
                 else
                     k = k + 1
                     cx(k) = cmplx( dble(numar) , dble(numai) , kind(0.0d0) )
                     cy(k) = cmplx( dble(numbr) , dble(numbi) , kind(0.0d0) )
                 endif
                 exit
             endif
             numai = tma/c
             tma = tma - c*numai
             numbi = tmb/c
             tmb = tmb - c*numbi
             if (numar < 0) then
                 numar = numai
                 numbr = numbi
             else
                 k = k + 1
                 cx(k) = cmplx( dble(numar) , dble(numai) , kind(0.0d0) )
                 cy(k) = cmplx( dble(numbr) , dble(numbi) , kind(0.0d0) )
                 numar = -1
             endif
          enddo
      endif

!             Transform.

      call fmfft(cx, n, cz)
      if (ksqr /= 1) then
          call fmfft(cy, n, cz)
      endif

!             Unpack the two transforms.

      theta = acos(-1.0d0)/n
      w = cmplx( cos(theta) , sin(theta) , kind(0.0d0) )
      st = cmplx( -2*sin(theta/2)**2 , sin(theta) , kind(0.0d0) )
      ci = cmplx( 0.0d0 , 1.0d0 , kind(0.0d0) )
      do j = 2, n/2
         h1 = 0.5d0*(cx(j)+conjg(cx(n+2-j)))
         h2 = -0.5d0*ci*(cx(j)-conjg(cx(n+2-j)))
         cx(j) = h1 + w*h2
         cx(n+2-j) = conjg(h1 - w*h2)
         if (ksqr /= 1) then
             h1 = 0.5d0*(cy(j)+conjg(cy(n+2-j)))
             h2 = -0.5d0*ci*(cy(j)-conjg(cy(n+2-j)))
             cy(j) = h1 + w*h2
             cy(n+2-j) = conjg(h1 - w*h2)
         endif
         w = w + st*w
      enddo
      cx(1) = cmplx( real(cx(1))+aimag(cx(1)) , real(cx(1))-aimag(cx(1)) , kind(0.0d0) )
      if (ksqr /= 1) then
          cy(1) = cmplx( real(cy(1))+aimag(cy(1)) , real(cy(1))-aimag(cy(1)) , kind(0.0d0) )
      endif

!             Multiply.

      if (ksqr /= 1) then
          cz(1) = cmplx( real(cx(1))*real(cy(1)) , aimag(cx(1))*aimag(cy(1)) , kind(0.0d0) )
          do j = 2, n
             cz(j) = cx(j)*cy(j)
          enddo
      else
          cz(1) = cmplx( real(cx(1))*real(cx(1)) , aimag(cx(1))*aimag(cx(1)) , kind(0.0d0) )
          do j = 2, n
             cz(j) = cx(j)*cx(j)
          enddo
      endif

!             Pack the product for input to the final fft.

      theta = -acos(-1.0d0)/n
      w = cmplx( cos(theta) , sin(theta) , kind(0.0d0) )
      st = cmplx( -2*sin(theta/2)**2 , sin(theta) , kind(0.0d0) )
      ci = cmplx( 0.0d0 , 1.0d0 , kind(0.0d0) )
      do j = 2, n/2
         h1 = 0.5d0*(cz(j)+conjg(cz(n+2-j)))
         h2 = 0.5d0*ci*(cz(j)-conjg(cz(n+2-j)))
         cz(j) = h1 + w*h2
         cz(n+2-j) = conjg(h1 - w*h2)
         w = w + st*w
      enddo
      cz(1) = 0.5d0 * cmplx( real(cz(1))+aimag(cz(1)) , real(cz(1))-aimag(cz(1)) , kind(0.0d0) )

!             Transform the product to get the convolution of the original inputs.

      call fmfft(cz, n, cy)
      t = 1.0d0/n
      do j = 1, n
         cz(j) = cz(j)*t
      enddo

!             Normalize the digits.

!             The cz array holds the result in scrambled order, with unnormalized digits.
!             The leading two digits of the convolution are in cz(1), then the next two
!             are in cz(n), then cz(n-1), ..., cz(2).
!             The imaginary part of cz(2) is zero (up to roundoff), for a total of 2*n-1
!             digits in the convolution.
!             These digits can be as big as n*base**2 here.
!
!             First normalize and unscramble.

      if (base == mbase) then
          d = aint( 0.5d0+real(cz(2)) , kind(0.0d0) )
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          ka = n2
          if (ka <= size(mwa%mp)-3) then
              mwa%mp(ka+2) = t2
          endif
          do j = 3, n
             d = aint( 0.5d0+aimag(cz(j)) , kind(0.0d0) ) + t
             t = aint( d/base, kind(0.0d0) )
             t2 = d - t*base
             ka = ka - 1
             if (ka <= size(mwa%mp)-3) then
                 mwa%mp(ka+2) = t2
             endif
             d = aint( 0.5d0+real(cz(j)) , kind(0.0d0) ) + t
             t = aint( d/base, kind(0.0d0) )
             t2 = d - t*base
             ka = ka - 1
             if (ka <= size(mwa%mp)-3) then
                 mwa%mp(ka+2) = t2
             endif
          enddo
          d = aint( 0.5d0+aimag(cz(1)) , kind(0.0d0) ) + t
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          ka = ka - 1
          mwa%mp(ka+2) = t2
          d = aint( 0.5d0+real(cz(1)) , kind(0.0d0) ) + t
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          ka = ka - 1
          mwa%mp(ka+2) = t2
          ka = ka - 1
          mwa%mp(ka+2) = t
      else
          ci = cmplx( 0.0d0 , 1.0d0 , kind(0.0d0) )
          d = aint( 0.5d0+real(cz(2)) , kind(0.0d0) )
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          ka = n
          cx(ka) = ci*t2
          do j = 3, n
             d = aint( 0.5d0+aimag(cz(j)) , kind(0.0d0) ) + t
             t = aint( d/base, kind(0.0d0) )
             t2 = d - t*base
             cx(ka) = t2 + cx(ka)
             d = aint( 0.5d0+real(cz(j)) , kind(0.0d0) ) + t
             t = aint( d/base, kind(0.0d0) )
             t2 = d - t*base
             ka = ka - 1
             cx(ka) = ci*t2
          enddo
          d = aint( 0.5d0+aimag(cz(1)) , kind(0.0d0) ) + t
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          cx(ka) = t2 + cx(ka)
          d = aint( 0.5d0+real(cz(1)) , kind(0.0d0) ) + t
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          ka = ka - 1
          cx(ka) = t + ci*t2
          tma = 0
          c = 1
          k = 0
          do j = 1, n2
             if (mod(j, 2) == 1) then
                 num = real(cx((j+1)/2))
             else
                 num = aimag(cx((j+1)/2))
             endif
             tma = tma*base + num
             c = c*base
             if (c < mbase) cycle
             c = c/mbase
             num = tma/c
             tma = tma - c*num
             k = k + 1
             if (k <= size(mwa%mp)-3 .and. k <= 2*ndig+2) then
                 mwa%mp(k+2) = num
             else
                 exit
             endif
          enddo
          k = k + 1
          if (k <= size(mwa%mp)-3 .and. k <= 2*ndig+2) mwa%mp(k+2) = tma*(mbase/c)
      endif

      return
      end subroutine fmmpyfft1

      subroutine fmmpyfft2(ma, mb)
      use fmvals
      implicit none

!  Internal multiplication routine ma*mb for very high precision.
!  Fast Fourier transforms are used, and the number of digits carried is usually raised slightly,
!  because the fft needs for n to have only small prime factors.
!  This routine is used for method 2 of fmmpyfft, where the base is not a power of a small number
!  and a different kind of splitting is used to avoid fft convolutions becoming too large.

      type(multi) :: ma, mb
      intent (in) :: ma, mb

      integer :: bestdiff, bestk, bestm, diff, j, j2, k, k2, ka, n, n2, nd, nd1,  &
                 num, numar, numai, numbr, numbi
      real (kind(0.0d0)) :: base, c, d, t, t2, theta, tma, tmb
      complex (kind(0.0d0)) :: ci, h1, h2, st, w

      nd = ndig
      base = mbase

!             Initialize guard digits in mwa.

      nd1 = size(mwa%mp)-2
      do j = 2*ndig, min(2*ndig+30, nd1)
         mwa%mp(j+2) = 0
      enddo

!             Choose the number of digits to use for the fft.  Make the size of the array have no
!             prime factors other than 2, 3, or 5.

      k = 0
      k2 = 1
      do j = 1, 100
         k = k + 1
         k2 = 2*k2
         if (k2 > nd) exit
      enddo
      bestm = 1
      bestk = k
      bestdiff = 2**k - nd
      do j = 3, 15, 2
         k = 0
         k2 = j
         do j2 = 1, 100
            k = k + 1
            k2 = 2*k2
            if (k2 > nd) exit
         enddo
         diff = k2 - nd
         if (diff < bestdiff) then
             bestdiff = diff
             bestm = j
             bestk = k
         endif
      enddo
      n = bestm * 2**bestk
      n2 = n*2
      j = 0
      if (.not. allocated(cx)) then
          allocate(cx(n), stat=j)
      else if (size(cx) /= n) then
          deallocate(cx)
          allocate(cx(n), stat=j)
      endif
      if (j /= 0) then
          call fmdefine_error
      endif
      j = 0
      if (.not. allocated(cy)) then
          allocate(cy(n), stat=j)
      else if (size(cy) /= n) then
          deallocate(cy)
          allocate(cy(n), stat=j)
      endif
      if (j /= 0) then
          call fmdefine_error
      endif
      j = 0
      if (.not. allocated(cz)) then
          allocate(cz(n), stat=j)
      else if (size(cz) /= n) then
          deallocate(cz)
          allocate(cz(n), stat=j)
      endif
      if (j /= 0) then
          call fmdefine_error
      endif
      j = 0
      if (.not. allocated(roots_of_unity)) then
          allocate(roots_of_unity(0:n-1), stat=j)
      else if (size(roots_of_unity) /= n) then
          deallocate(roots_of_unity)
          allocate(roots_of_unity(0:n-1), stat=j)
      endif
      if (j /= 0) then
          call fmdefine_error
      endif
      call fmfft_init(n)
      n_roots_of_unity = n

!             Pad the lists of digits with zeros, then pack the length 2*n real arrays into
!             length n complex arrays to speed up the fft operations.

      if (base == mbase) then
          do j = ndig/2, n
             cx(j) = 0
             cy(j) = 0
          enddo
          do j = 2, ndig, 2
             cx(j/2) = cmplx( ma%mp(j+1) , ma%mp(j+2) , kind(0.0d0) )
             cy(j/2) = cmplx( mb%mp(j+1) , mb%mp(j+2) , kind(0.0d0) )
          enddo
          if (mod(ndig, 2) == 1) then
              cx(ndig/2+1) = ma%mp(ndig+2)
              cy(ndig/2+1) = mb%mp(ndig+2)
          endif
      else
          do j = ndig/2, n
             cx(j) = 0
             cy(j) = 0
          enddo
          d = mbase/base
          c = mbase*d
          tma = ma%mp(3)*mbase + ma%mp(4)
          numar = tma/c
          tma = tma - c*numar
          tmb = mb%mp(3)*mbase + mb%mp(4)
          numbr = tmb/c
          tmb = tmb - c*numbr
          k = 0
          do j = 3, ndig
             do
                if (c >= base) then
                    c = c/base
                else
                    tma = tma*mbase + ma%mp(j+2)
                    tmb = tmb*mbase + mb%mp(j+2)
                    c = c*mbase
                    exit
                endif
                numai = tma/c
                tma = tma - c*numai
                numbi = tmb/c
                tmb = tmb - c*numbi
                if (numar < 0) then
                    numar = numai
                    numbr = numbi
                else
                    k = k + 1
                    cx(k) = cmplx( dble(numar) , dble(numai) , kind(0.0d0) )
                    cy(k) = cmplx( dble(numbr) , dble(numbi) , kind(0.0d0) )
                    numar = -1
                endif
             enddo
          enddo
          do
             if (c >= base) then
                 c = c/base
             else
                 numai = tma*(base/c)
                 numbi = tmb*(base/c)
                 if (numar < 0) then
                     k = k + 1
                     cx(k) = cmplx( dble(numai) , 0.0d0 , kind(0.0d0) )
                     cy(k) = cmplx( dble(numbi) , 0.0d0 , kind(0.0d0) )
                 else
                     k = k + 1
                     cx(k) = cmplx( dble(numar) , dble(numai) , kind(0.0d0) )
                     cy(k) = cmplx( dble(numbr) , dble(numbi) , kind(0.0d0) )
                 endif
                 exit
             endif
             numai = tma/c
             tma = tma - c*numai
             numbi = tmb/c
             tmb = tmb - c*numbi
             if (numar < 0) then
                 numar = numai
                 numbr = numbi
             else
                 k = k + 1
                 cx(k) = cmplx( dble(numar) , dble(numai) , kind(0.0d0) )
                 cy(k) = cmplx( dble(numbr) , dble(numbi) , kind(0.0d0) )
                 numar = -1
             endif
          enddo
      endif

!             Transform.

      call fmfft(cx, n, cz)
      if (ksqr /= 1) then
          call fmfft(cy, n, cz)
      endif

!             Unpack the two transforms.

      theta = acos(-1.0d0)/n
      w = cmplx( cos(theta) , sin(theta) , kind(0.0d0) )
      st = cmplx( -2*sin(theta/2)**2 , sin(theta) , kind(0.0d0) )
      ci = cmplx( 0.0d0 , 1.0d0 , kind(0.0d0) )
      do j = 2, n/2
         h1 = 0.5d0*(cx(j)+conjg(cx(n+2-j)))
         h2 = -0.5d0*ci*(cx(j)-conjg(cx(n+2-j)))
         cx(j) = h1 + w*h2
         cx(n+2-j) = conjg(h1 - w*h2)
         if (ksqr /= 1) then
             h1 = 0.5d0*(cy(j)+conjg(cy(n+2-j)))
             h2 = -0.5d0*ci*(cy(j)-conjg(cy(n+2-j)))
             cy(j) = h1 + w*h2
             cy(n+2-j) = conjg(h1 - w*h2)
         endif
         w = w + st*w
      enddo
      cx(1) = cmplx( real(cx(1))+aimag(cx(1)) , real(cx(1))-aimag(cx(1)) , kind(0.0d0) )
      if (ksqr /= 1) then
          cy(1) = cmplx( real(cy(1))+aimag(cy(1)) , real(cy(1))-aimag(cy(1)) , kind(0.0d0) )
      endif

!             Multiply.

      if (ksqr /= 1) then
          cz(1) = cmplx( real(cx(1))*real(cy(1)) , aimag(cx(1))*aimag(cy(1)) , kind(0.0d0) )
          do j = 2, n
             cz(j) = cx(j)*cy(j)
          enddo
      else
          cz(1) = cmplx( real(cx(1))*real(cx(1)) , aimag(cx(1))*aimag(cx(1)) , kind(0.0d0) )
          do j = 2, n
             cz(j) = cx(j)*cx(j)
          enddo
      endif

!             Pack the product for input to the final fft.

      theta = -acos(-1.0d0)/n
      w = cmplx( cos(theta) , sin(theta) , kind(0.0d0) )
      st = cmplx( -2*sin(theta/2)**2 , sin(theta) , kind(0.0d0) )
      ci = cmplx( 0.0d0 , 1.0d0 , kind(0.0d0) )
      do j = 2, n/2
         h1 = 0.5d0*(cz(j)+conjg(cz(n+2-j)))
         h2 = 0.5d0*ci*(cz(j)-conjg(cz(n+2-j)))
         cz(j) = h1 + w*h2
         cz(n+2-j) = conjg(h1 - w*h2)
         w = w + st*w
      enddo
      cz(1) = 0.5d0 * cmplx( real(cz(1))+aimag(cz(1)) , real(cz(1))-aimag(cz(1)) , kind(0.0d0) )

!             Transform the product to get the convolution of the original inputs.

      call fmfft(cz, n, cy)
      t = 1.0d0/n
      do j = 1, n
         cz(j) = cz(j)*t
      enddo

!             Normalize the digits.

!             The cz array holds the result in scrambled order, with unnormalized digits.
!             The leading two digits of the convolution are in cz(1), then the next two
!             are in cz(n), then cz(n-1), ..., cz(2).
!             The imaginary part of cz(2) is zero (up to roundoff), for a total of 2*n-1
!             digits in the convolution.
!             These digits can be as big as n*base**2 here.
!
!             First normalize and unscramble.

      if (base == mbase) then
          d = aint( 0.5d0+real(cz(2)) , kind(0.0d0) )
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          ka = n2
          if (ka <= size(mwa%mp)-3) then
              mwa%mp(ka+2) = t2
          endif
          do j = 3, n
             d = aint( 0.5d0+aimag(cz(j)) , kind(0.0d0) ) + t
             t = aint( d/base, kind(0.0d0) )
             t2 = d - t*base
             ka = ka - 1
             if (ka <= size(mwa%mp)-3) then
                 mwa%mp(ka+2) = t2
             endif
             d = aint( 0.5d0+real(cz(j)) , kind(0.0d0) ) + t
             t = aint( d/base, kind(0.0d0) )
             t2 = d - t*base
             ka = ka - 1
             if (ka <= size(mwa%mp)-3) then
                 mwa%mp(ka+2) = t2
             endif
          enddo
          d = aint( 0.5d0+aimag(cz(1)) , kind(0.0d0) ) + t
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          ka = ka - 1
          mwa%mp(ka+2) = t2
          d = aint( 0.5d0+real(cz(1)) , kind(0.0d0) ) + t
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          ka = ka - 1
          mwa%mp(ka+2) = t2
          ka = ka - 1
          mwa%mp(ka+2) = t
      else
          ci = cmplx( 0.0d0 , 1.0d0 , kind(0.0d0) )
          d = aint( 0.5d0+real(cz(2)) , kind(0.0d0) )
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          ka = n
          cx(ka) = ci*t2
          do j = 3, n
             d = aint( 0.5d0+aimag(cz(j)) , kind(0.0d0) ) + t
             t = aint( d/base, kind(0.0d0) )
             t2 = d - t*base
             cx(ka) = t2 + cx(ka)
             d = aint( 0.5d0+real(cz(j)) , kind(0.0d0) ) + t
             t = aint( d/base, kind(0.0d0) )
             t2 = d - t*base
             ka = ka - 1
             cx(ka) = ci*t2
          enddo
          d = aint( 0.5d0+aimag(cz(1)) , kind(0.0d0) ) + t
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          cx(ka) = t2 + cx(ka)
          d = aint( 0.5d0+real(cz(1)) , kind(0.0d0) ) + t
          t = aint( d/base, kind(0.0d0) )
          t2 = d - t*base
          ka = ka - 1
          cx(ka) = t + ci*t2
          tma = 0
          c = 1
          k = 0
          do j = 1, n2
             if (mod(j, 2) == 1) then
                 num = real(cx((j+1)/2))
             else
                 num = aimag(cx((j+1)/2))
             endif
             tma = tma*base + num
             c = c*base
             if (c < mbase) cycle
             c = c/mbase
             num = tma/c
             tma = tma - c*num
             k = k + 1
             if (k <= size(mwa%mp)-3 .and. k <= 2*ndig+2) then
                 mwa%mp(k+2) = num
             else
                 exit
             endif
          enddo
          k = k + 1
          if (k <= size(mwa%mp)-3 .and. k <= 2*ndig+2) mwa%mp(k+2) = tma*(mbase/c)
      endif

      return
      end subroutine fmmpyfft2

      subroutine fmmpyfft_norm(ma)

!  Normalize a number formed by the x1,x2 splitting done in fmmpyfft.

      use fmvals
      implicit none

      type(multi) :: ma
      intent (inout) :: ma

      integer :: j, kz

      kz = 0
      do j = 1, ndig
         if (ma%mp(j+2) == 0) then
             kz = j
         else
             exit
         endif
      enddo
      if (kz == 0) return
      if (kz == ndig) then
          call fmi2m2(0, ma)
          return
      endif
      do j = 1, ndig-kz
         ma%mp(j+2) = ma%mp(j+kz+2)
      enddo
      do j = ndig-kz+1, ndig
         ma%mp(j+2) = 0
      enddo
      ma%mp(2) = ma%mp(2) - kz

      return
      end subroutine fmmpyfft_norm

      subroutine fmmpyffti(ma, ival, mb)

!  mb = ma * ival

!  Multiply fm number ma by one word integer ival.

!  This routine is used during fft-based multiplication.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb

      real (kind(1.0d0)) :: mcarry, mkt, mlr, mval
      integer :: j, jrssav, ka, kb, kc, kshift, n1, nguard
      type(multi), save :: mxy

      call fmalloc(mb, ndig+2)
      call fmalloc(mwa, 2*ndig+30)

      if (mblogs /= mbase) call fmcons
      jrssav = jrsign
      ncall = ncall + 1
      kflag = 0
      n1 = ndig + 1

!             Check for special cases.

      if (ma%mp(2) == munkno .and. ma%mp(5) >= 0) then
          call fmunknown(mb)
          kflag = -4
          ncall = ncall - 1
          jrsign = jrssav
          return
      endif

      if (ma%mp(3) == 0) then
          call fmeq(ma, mb)
          ncall = ncall - 1
          jrsign = jrssav
          return
      endif

      if (abs(ma%mp(2)) >= mexpov) then
          call fmi2m(ival, mxy)
          call fmovun_mpy(ma, mxy, mb)
          if (ma%mp(2) /= munkno .and. mxy%mp(2) /= munkno .and.  &
              mb%mp(2) == munkno) then
              kflag = -4
          endif
          ncall = ncall - 1
          jrsign = jrssav
          return
      endif

      if (ival == 0) then
          call fmi2m2(0, mb)
          ncall = ncall - 1
          jrsign = jrssav
          return
      endif

      if (abs(ival) == 1) then
          do j = 1, ndig+2
             mb%mp(j) = ma%mp(j)
          enddo
          if (ma%mp(2) == mexpov) kflag = -5
          if (ma%mp(2) == mexpun) kflag = -6
          mb%mp(1) = ma%mp(1)*ival
          ncall = ncall - 1
          jrsign = jrssav
          return
      endif

      mval = abs(ival)

!             To leave room for the normalization, shift the product to the right kshift
!             places in mwa.

      kshift = int((log(dble(ma%mp(3)+1)*dble(mval)))/dlogmb)
      mwa%mp(2) = ma%mp(2) + kshift
      ka = 2 + kshift
      kb = n1 + kshift
      kc = ndig + 5
      do j = kb, kc
         mwa%mp(j+1) = 0
      enddo

      mcarry = 0

!             This is the main multiplication loop.

      do j = kb, ka, -1
         mkt = ma%mp(j-kshift+1)*mval + mcarry
         mcarry = int (mkt/mbase)
         mwa%mp(j+1) = mkt - mcarry*mbase
      enddo

!             Resolve the final carry.

      do j = ka-1, 2, -1
         mkt = int (mcarry/mbase)
         mwa%mp(j+1) = mcarry - mkt*mbase
         mcarry = mkt
      enddo

!             Now the first significant digit in the product is in
!             mwa%mp(3) or mwa%mp(4).
!             Round the result and move it to mb.

      if ((ma%mp(1) > 0 .and. ival > 0) .or. (ma%mp(1) < 0 .and. ival < 0)) then
          jrsign = 1
      else
          jrsign = -1
      endif
      if (mwa%mp(3) == 0) then
          mlr = 2*mwa%mp(ndig+4) + 1
          if (kround == -1 .or. kround == 2) then
              nguard = kshift - 1
              call fmrnd(mwa, ndig, nguard, 1)
          else if (mlr >= mbase) then
              if (mlr-1 > mbase .and. mwa%mp(n1+2) < mbase-1) then
                  if (kround /= 0) then
                      mwa%mp(n1+2) = mwa%mp(n1+2) + 1
                      mwa%mp(n1+3) = 0
                  endif
              else
                  nguard = kshift - 1
                  call fmrnd(mwa, ndig, nguard, 1)
              endif
          endif
      else
          mlr = 2*mwa%mp(ndig+3) + 1
          if (kround == -1 .or. kround == 2) then
              call fmrnd(mwa, ndig, kshift, 0)
          else if (mlr >= mbase) then
              if (mlr-1 > mbase .and. mwa%mp(n1+1) < mbase-1) then
                  if (kround /= 0) then
                      mwa%mp(n1+1) = mwa%mp(n1+1) + 1
                      mwa%mp(n1+2) = 0
                  endif
              else
                  call fmrnd(mwa, ndig, kshift, 0)
              endif
          endif
      endif
      call fmmove(mwa, mb)

!             Put the sign on the result.

      mb%mp(1) = jrsign
      ncall = ncall - 1
      jrsign = jrssav

      return
      end subroutine fmmpyffti

      subroutine fmmpyi(ma, ival, mb)

!  mb = ma * ival

!  Multiply fm number ma by one word integer ival.

!  This routine is faster than fmmpy when ival*mbase is a one word integer.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb

      kflag = 0
      ncall = ncall + 1
      namest(ncall) = 'FMMPYI'
      if (ntrace /= 0) then
          call fmntr_inp1i(ma, ival)
          call fmmpyi2(ma, ival, mb)
          call fmntr_out1(mb)
      else
          call fmmpyi2(ma, ival, mb)
      endif
      ncall = ncall - 1

      return
      end subroutine fmmpyi

      subroutine fmmpyi2(ma, ival, mb)

!  mb = ma * ival

!  Internal routine for multiplying by an integer.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb

      real (kind(1.0d0)) :: mcarry, mkt, mlr, mval
      integer :: j, jrssav, ka, kb, kc, kshift, n1, nguard, nmval, nv2
      type(multi), save :: mxy(1)

      call fmalloc(mb, ndig+2)
      call fmalloc(mwa, 2*ndig+30)

      if (ma%mp(2) == munkno .and. ma%mp(5) >= 0) then
          call fmunknown(mb)
          kflag = -4
          return
      endif

!             Check for special cases.

      if (abs(ma%mp(2)) >= mexpov) then
          call fmi2m(ival, mxy(1))
          call fmovun_mpy(ma, mxy(1), mb)
          if (ma%mp(2) /= munkno .and. mxy(1)%mp(2) /= munkno .and.  &
              mb%mp(2) == munkno) then
              kflag = -4
              call fmwarn
          endif
          return
      endif

      if (mblogs /= mbase) call fmcons
      jrssav = jrsign
      kflag = 0
      n1 = ndig + 1
      if (ma%mp(3) == 0) then
          call fmeq(ma, mb)
          jrsign = jrssav
          return
      endif

      if (ival == 0) then
          call fmi2m2(0, mb)
          jrsign = jrssav
          return
      endif

      if (abs(ival) == 1) then
          do j = 1, ndig+2
             mb%mp(j) = ma%mp(j)
          enddo
          if (ma%mp(2) == mexpov) kflag = -5
          if (ma%mp(2) == mexpun) kflag = -6
          mb%mp(1) = ma%mp(1)*ival
          jrsign = jrssav
          return
      endif

      mval = abs(ival)
      nmval = int(mval)
      nv2 = nmval - 1

!             To leave room for the normalization, shift the product to the right kshift
!             places in mwa.

      kshift = int((log(dble(ma%mp(3)+1)*dble(mval)))/dlogmb)

!             If ival is too big use fmmpy.

      if (kshift > ndig .or. mval > maxint/mbase .or.  &
          nmval /= abs(ival) .or. nv2 /= abs(ival)-1) then
          call fmi2m2(ival, mxy(1))
          call fmmpy2(ma, mxy(1), mb)
          jrsign = jrssav
          return
      endif

      mwa%mp(2) = ma%mp(2) + kshift
      ka = 2 + kshift
      kb = n1 + kshift
      kc = ndig + 5
      do j = kb, kc
         mwa%mp(j+1) = 0
      enddo

      mcarry = 0

!             This is the main multiplication loop.

      do j = kb, ka, -1
         mkt = ma%mp(j-kshift+1)*mval + mcarry
         mcarry = int (mkt/mbase)
         mwa%mp(j+1) = mkt - mcarry*mbase
      enddo

!             Resolve the final carry.

      do j = ka-1, 2, -1
         mkt = int (mcarry/mbase)
         mwa%mp(j+1) = mcarry - mkt*mbase
         mcarry = mkt
      enddo

!             Now the first significant digit in the product is in
!             mwa%mp(3) or mwa%mp(4).
!             Round the result and move it to mb.

      if ((ma%mp(1) > 0 .and. ival > 0) .or. (ma%mp(1) < 0 .and. ival < 0)) then
          jrsign = 1
      else
          jrsign = -1
      endif
      if (mwa%mp(3) == 0) then
          mlr = 2*mwa%mp(ndig+4) + 1
          if (kround == -1 .or. kround == 2) then
              nguard = kshift - 1
              call fmrnd(mwa, ndig, nguard, 1)
          else if (mlr >= mbase) then
              if (mlr-1 > mbase .and. mwa%mp(n1+2) < mbase-1) then
                  if (kround /= 0) then
                      mwa%mp(n1+2) = mwa%mp(n1+2) + 1
                      mwa%mp(n1+3) = 0
                  endif
              else
                  nguard = kshift - 1
                  call fmrnd(mwa, ndig, nguard, 1)
              endif
          endif
      else
          mlr = 2*mwa%mp(ndig+3) + 1
          if (kround == -1 .or. kround == 2) then
              call fmrnd(mwa, ndig, kshift, 0)
          else if (mlr >= mbase) then
              if (mlr-1 > mbase .and. mwa%mp(n1+1) < mbase-1) then
                  if (kround /= 0) then
                      mwa%mp(n1+1) = mwa%mp(n1+1) + 1
                      mwa%mp(n1+2) = 0
                  endif
              else
                  call fmrnd(mwa, ndig, kshift, 0)
              endif
          endif
      endif
      call fmmove(mwa, mb)

      if (kflag < 0) then
          namest(ncall) = 'FMMPYI'
          call fmwarn
      endif

!             Put the sign on the result.

      mb%mp(1) = jrsign
      jrsign = jrssav

      return
      end subroutine fmmpyi2

      subroutine fmmpyi2_r1(ma, ival)

!  ma = ma * ival

!  Internal routine for multiplying by an integer.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ival
      intent (inout) :: ma

      real (kind(1.0d0)) :: mcarry, mkt, mlr, mval
      integer :: j, jrssav, ka, kb, kc, kshift, n1, nguard, nmval, nv2
      type(multi), save :: mxy(2)

      call fmalloc(mwa, 2*ndig+30)

      if (ma%mp(2) == munkno .and. ma%mp(5) >= 0) then
          call fmunknown(ma)
          kflag = -4
          return
      endif

!             Check for special cases.

      if (abs(ma%mp(2)) >= mexpov) then
          call fmi2m(ival, mxy(1))
          call fmovun_mpy(ma, mxy(1), mxy(2))
          call fmeq(mxy(2), ma)
          if (ma%mp(2) /= munkno .and. mxy(1)%mp(2) /= munkno .and.  &
              ma%mp(2) == munkno) then
              kflag = -4
              call fmwarn
          endif
          return
      endif

      if (mblogs /= mbase) call fmcons
      jrssav = jrsign
      kflag = 0
      n1 = ndig + 1
      if (ma%mp(3) == 0) then
          jrsign = jrssav
          return
      endif

      if (ival == 0) then
          call fmi2m2(0, ma)
          jrsign = jrssav
          return
      endif

      if (abs(ival) == 1) then
          if (ma%mp(2) == mexpov) kflag = -5
          if (ma%mp(2) == mexpun) kflag = -6
          ma%mp(1) = ma%mp(1)*ival
          jrsign = jrssav
          return
      endif

      mval = abs(ival)
      nmval = int(mval)
      nv2 = nmval - 1

!             To leave room for the normalization, shift the product to the right kshift
!             places in mwa.

      kshift = int((log(dble(ma%mp(3)+1)*dble(mval)))/dlogmb)

!             If ival is too big use fmmpy.

      if (kshift > ndig .or. mval > maxint/mbase .or.  &
          nmval /= abs(ival) .or. nv2 /= abs(ival)-1) then
          call fmi2m2(ival, mxy(1))
          call fmmpy2_r1(ma, mxy(1))
          jrsign = jrssav
          return
      endif

      mwa%mp(2) = ma%mp(2) + kshift
      ka = 2 + kshift
      kb = n1 + kshift
      kc = ndig + 5
      do j = kb, kc
         mwa%mp(j+1) = 0
      enddo

      mcarry = 0

!             This is the main multiplication loop.

      do j = kb, ka, -1
         mkt = ma%mp(j-kshift+1)*mval + mcarry
         mcarry = int (mkt/mbase)
         mwa%mp(j+1) = mkt - mcarry*mbase
      enddo

!             Resolve the final carry.

      do j = ka-1, 2, -1
         mkt = int (mcarry/mbase)
         mwa%mp(j+1) = mcarry - mkt*mbase
         mcarry = mkt
      enddo

!             Now the first significant digit in the product is in
!             mwa%mp(3) or mwa%mp(4).
!             Round the result and move it to ma.

      if ((ma%mp(1) > 0 .and. ival > 0) .or. (ma%mp(1) < 0 .and. ival < 0)) then
          jrsign = 1
      else
          jrsign = -1
      endif
      if (mwa%mp(3) == 0) then
          mlr = 2*mwa%mp(ndig+4) + 1
          if (kround == -1 .or. kround == 2) then
              nguard = kshift - 1
              call fmrnd(mwa, ndig, nguard, 1)
          else if (mlr >= mbase) then
              if (mlr-1 > mbase .and. mwa%mp(n1+2) < mbase-1) then
                  if (kround /= 0) then
                      mwa%mp(n1+2) = mwa%mp(n1+2) + 1
                      mwa%mp(n1+3) = 0
                  endif
              else
                  nguard = kshift - 1
                  call fmrnd(mwa, ndig, nguard, 1)
              endif
          endif
      else
          mlr = 2*mwa%mp(ndig+3) + 1
          if (kround == -1 .or. kround == 2) then
              call fmrnd(mwa, ndig, kshift, 0)
          else if (mlr >= mbase) then
              if (mlr-1 > mbase .and. mwa%mp(n1+1) < mbase-1) then
                  if (kround /= 0) then
                      mwa%mp(n1+1) = mwa%mp(n1+1) + 1
                      mwa%mp(n1+2) = 0
                  endif
              else
                  call fmrnd(mwa, ndig, kshift, 0)
              endif
          endif
      endif
      call fmmove(mwa, ma)

      if (kflag < 0) then
          namest(ncall) = 'FMMPYI'
          call fmwarn
      endif

!             Put the sign on the result.

      ma%mp(1) = jrsign
      jrsign = jrssav

      return
      end subroutine fmmpyi2_r1

      subroutine fmmpyi_r1(ma, ival)

!  ma = ma * ival

!  Multiply fm number ma by one word integer ival.

!  This routine is faster than fmmpy when ival*mbase is a one word integer.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ival
      intent (inout) :: ma

      kflag = 0
      ncall = ncall + 1
      namest(ncall) = 'FMMPYI_R1'
      if (ntrace /= 0) then
          call fmntr_inp1i(ma, ival)
          call fmmpyi2_r1(ma, ival)
          call fmntr_out1(ma)
      else
          call fmmpyi2_r1(ma, ival)
      endif
      ncall = ncall - 1

      return
      end subroutine fmmpyi_r1

      subroutine fmnegate(ma)

!  Change the sign of ma.

      use fmvals
      implicit none

      type(multi) :: ma
      intent (inout) :: ma

      ma%mp(1) = -ma%mp(1)
      if (ma%mp(3) == 0) ma%mp(1) = 1
      if (ma%mp(2) == munkno .and. ma%mp(5) >= 0) ma%mp(1) = 1

      end subroutine fmnegate

      subroutine fmnint(ma, mb)

!  mb = nint(ma)  --  mb is returned as the nearest integer to ma.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: ma2
      double precision :: x, xe, xf, ye, yf
      integer :: kwrnsv, ndsave
      type(multi), save :: mxy(3)

      call fmalloc(mb, ndig+2)

      if (mblogs /= mbase) call fmcons
      ncall = ncall + 1
      if (ntrace /= 0) then
          namest(ncall) = 'FMNINT'
          call fmntr_inp1(ma)
      endif

      if (ma%mp(2) == munkno .and. ma%mp(5) < 0) then
          kflag = -4
          if (ma%mp(4) > ndig) then
              call fmeq(ma, mb)
          else if (ma%mp(4) < -ndig) then
              call fmi2m(0, mb)
              kflag = 0
          else
              call fmovun_xexf(ma, xe, xf)
              call fmst2m('1.0E+12', mb)
              call fmovun_xexf(mb, ye, yf)
              if (xe > ye .or. (xe == ye .and. xf > yf)) then
                  call fmeq(ma, mb)
              else
                  call fmunknown(mb)
                  x = dble(mbase)**xe * xf
                  if (aint(x) == 0) then
                      mb%mp(4) = 0
                      mb%mp(5) = -maxint * (1/dble(mbase))
                  else
                      x = anint(x)
                      call fmdpm2(x, mxy(1))
                      call fmovun_xexf(mxy(1), ye, yf)
                      kflag = -4
                      mb%mp(4) = ye
                      mb%mp(5) = -maxint * yf
                  endif
                  mb%mp(1) = ma%mp(1)
              endif
          endif
      else if (ma%mp(2) > mexpab) then
          call fmeq(ma, mb)
      else if (ma%mp(2) == mexpun) then
          call fmi2m(0, mb)
      else
          kwrnsv = kwarn
          kwarn = 0
          ndsave = ndig
          ndig = ndig + ngrd22
          call fmequ(ma, mxy(2), ndsave, ndig)
          if (ndsave > int(ma%mp(2))) then
              ma2 = ma%mp(1)
              mxy(2)%mp(1) = 1
              call fmi2m(1, mxy(1))
              call fmdivi_r1(mxy(1), 2)
              call fmadd(mxy(2), mxy(1), mxy(3))
              call fmint(mxy(3), mxy(2))
              if (ma2 < 0) call fmnegate(mxy(2))
              call fmequ(mxy(2), mb, ndig, ndsave)
          else
              call fmequ(mxy(2), mb, ndig, ndsave)
          endif
          kwarn = kwrnsv
          ndig = ndsave
      endif

      if (ntrace /= 0) then
          call fmntr_out1(mb)
      endif
      ncall = ncall - 1

      return
      end subroutine fmnint

      subroutine fmnorm2(x, n, mb)

!  mb = sqrt( x(1)**2 + x(2)**2 + ... + x(n)**2 )

      use fmvals
      implicit none

      integer :: n
      type(multi) :: x(n), mb
      intent (in) :: x, n
      intent (inout) :: mb

      integer :: j, kl, ndsave
      real (kind(1.0d0)) :: mxsave
      type(multi), save :: mxy(2)

      call fmalloc(mb, ndig+2)
      ncall = ncall + 1
      namest(ncall) = 'FMNORM2  '
      ndsave = ndig
      ndig = ndig + ngrd52
      mxsave = mxexp
      mxexp = mxexp2

!             Check for special cases.

      kl = 0
      do j = 1, n
         if (x(j)%mp(2) == munkno .and. x(j)%mp(5) >= 0) then
             call fmunknown(mxy(2))
             kl = 1
             exit
         endif
      enddo

      if (kl == 0) then
          call fmi2m(0, mxy(2))
          do j = 1, n
             call fmequ(x(j), mxy(1), ndsave, ndig)
             call fmsqr_r1(mxy(1))
             call fmadd_r1(mxy(2), mxy(1))
          enddo
          call fmsqrt_r1(mxy(2))
      endif

      mxexp = mxsave
      call fmequ(mxy(2), mb, ndig, ndsave)
      ndig = ndsave
      ncall = ncall - 1

      return
      end subroutine fmnorm2

      function fmnterms(y, c1, c2, jn, conv)

!  Internal routine for estimating the number of terms needed in a series.

!  y  is the effective argument used in the series.
!  c1, c2, jn describe the coefficients in the series.
!  conv = 1 for convergent series,
!       = 2 for asymptotic series.

      use fmvals
      implicit none
      double precision :: y
      integer :: c1, c2, jn, conv
      intent (in) :: y, c1, c2, jn, conv

      double precision :: a, b, c, fb, fc, tol, z, fmnterms
      double precision, external :: fmdplg

      if (conv == 1) then

!             Convergent series.

          z = y*log(y) - fmdplg(y+1)
          c = 1
          if (c2 == 1) then
              c = (sqrt(4*y + jn**2) - jn)/2
              z = c*log(y) - fmdplg(c+1) - fmdplg(c+jn+1)
          else if (c2 == -1) then
              z = (y*y/2)*log(y) + fmdplg(y*y/4+1) - fmdplg(y*y/2+1)
          endif
          if (abs(y) < 1) z = 0
          tol = z - ndig*dlogmb
          a = y/c1
          if (c2 == 1) then
              a = c
          endif
          if (a < 1) a = 1
          b = 2*a
          fb = c1*b*log(y) - fmdplg(c1*b+1)
          if (c2 == 0) then
              fb = c1*b*log(y) - fmdplg(c1*b+1)
          else if (c2 == 1) then
              fb = c1*b*log(y) - fmdplg(c1*b+1) - fmdplg(c1*(b+jn)+1)
          else if (c2 == -1) then
              fb = c1*b*log(y) + fmdplg(b+1) - fmdplg(c1*b+1)
          endif
          do while (fb > tol)
             a = b
             b = 2*b
             if (c2 == 0) then
                 fb = c1*b*log(y) - fmdplg(c1*b+1)
             else if (c2 == 1) then
                 fb = c1*b*log(y) - fmdplg(c1*b+1) - fmdplg(c1*(b+jn)+1)
             else if (c2 == -1) then
                 fb = c1*b*log(y) + fmdplg(b+1) - fmdplg(c1*b+1)
             endif
          enddo
          do while (b-a > 1)
             c = (a+b)/2
             fc = c1*c*log(y) - fmdplg(c1*c+1)
             if (c2 == 0) then
                 fc = c1*c*log(y) - fmdplg(c1*c+1)
             else if (c2 == 1) then
                 fc = c1*c*log(y) - fmdplg(c1*c+1) - fmdplg(c1*(c+jn)+1)
             else if (c2 == -1) then
                 fc = c1*c*log(y) + fmdplg(c+1) - fmdplg(c1*c+1)
             else
                 fc = c1*c*log(y) - fmdplg(c1*c+1)
             endif
             if (fc < tol) then
                 b = c
             else
                 a = c
             endif
          enddo
          fmnterms = (a+b)/2
      else

!             Asymptotic series.

          tol = -ndig*dlogmb
          a = 1
          b = y/c1
          if (c2 == 1) then
              b = y/2
          endif
          fb = fmdplg(c1*b+1) - c1*b*log(y)
          if (c2 == 0) then
              fb = fmdplg(c1*b+1) - c1*b*log(y)
          else if (c2 == 1) then
              if (-c1*b + jn >= 0) then
                  fb = fmdplg(c1*b+jn+1) - c1*b*log(y) - fmdplg(c1*b+1) - fmdplg(-c1*b+jn+1)
              else
                  fb = fmdplg(c1*b+jn+1) + fmdplg(c1*b-jn+1) - c1*b*log(y) - fmdplg(c1*b+1)
              endif
          endif
          do while (b-a > 1)
             if (abs(fb)/1.0d10 > abs(tol) .and. b/1.0d10 > a*1.1) then
                 c = b/1.0d10
             else if (abs(fb)/1.0d2 > abs(tol) .and. b/1.0d2 > a*1.1) then
                 c = b/1.0d2
             else
                 c = (a+b)/2
             endif
             fc = fmdplg(c1*c+1) - c1*c*log(y)
             if (c2 == 0) then
                 fc = fmdplg(c1*c+1) - c1*c*log(y)
             else if (c2 == 1) then
                 if (-c1*c + jn >= 0) then
                     fc = fmdplg(c1*c+jn+1) - c1*c*log(y) - fmdplg(c1*c+1) - fmdplg(-c1*c+jn+1)
                 else
                     fc = fmdplg(c1*c+jn+1) + fmdplg(c1*c-jn+1) - c1*c*log(y) - fmdplg(c1*c+1)
                 endif
             endif
             if (fc < tol) then
                 b = c
             else
                 a = c
             endif
          enddo
          fmnterms = (a+b)/2
      endif

      return
      end function fmnterms

      subroutine fmntr_inp1(ma)

!  Print FM numbers in base 10 format using fmout for conversion.
!  This is used for tracing input values to the fm routines.

!  ma  -  the fm number to be printed.

      use fmvals
      implicit none

      type(multi) :: ma
      intent (in) :: ma

      character(9) :: name

      if (abs(ntrace) <= 1) return
      if (ncall > lvltrc) return

      name = namest(ncall)
      if (kround == 1) then
          write (kw, "(' Input to ', a)") trim(name)
      else if (kround == 2) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (kround == 0) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (kround == -1) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (kw, "(' Input to ', a)") trim(name)
      endif

!             Check for base mbase internal format trace.

      if (ntrace < 0) then
          call fmntrj(ma, ndig)
      endif

!             Check for base 10 trace using fmout.

      if (ntrace > 0) then
          call fmprnt(ma)
      endif

      return
      end subroutine fmntr_inp1

      subroutine fmntr_inp1i(ma, ival)

!  Print fm numbers in base 10 format using fmout for conversion.
!  This is used for tracing input values to the fm routines.

!  ma   -  the fm number to be printed.
!  ival -  the integer to be printed.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ma, ival

      character(9) :: name

      if (abs(ntrace) <= 1) return
      if (ncall > lvltrc) return

      name = namest(ncall)
      if (kround == 1) then
          write (kw, "(' Input to ', a)") trim(name)
      else if (kround == 2) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (kround == 0) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (kround == -1) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (kw, "(' Input to ', a)") trim(name)
      endif

!             Check for base mbase internal format trace.

      if (ntrace < 0) then
          call fmntrj(ma, ndig)
      endif

!             Check for base 10 trace using fmout.

      if (ntrace > 0) then
          call fmprnt(ma)
      endif

      write (kw, "(1x, i20)") ival

      return
      end subroutine fmntr_inp1i

      subroutine fmntr_inp1ii(ma, k, n)

!  Internal routine for trace output of integer variables.

!  k,n     Integers to be printed.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: k, n
      intent (in) :: ma, k, n

      character(9) :: name

      if (abs(ntrace) <= 1) return
      if (ncall > lvltrc) return

      name = namest(ncall)
      if (kround == 1) then
          write (kw, "(' Input to ', a)") trim(name)
      else if (kround == 2) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (kround == 0) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (kround == -1) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (kw, "(' Input to ', a)") trim(name)
      endif

!             Check for base mbase internal format trace.

      if (ntrace < 0) then
          call fmntrj(ma, ndig)
      endif

!             Check for base 10 trace using fmout.

      if (ntrace > 0) then
          call fmprnt(ma)
      endif

      write (kw, "(1x, i20)") k
      write (kw, "(1x, i20)") n

      return
      end subroutine fmntr_inp1ii

      subroutine fmntr_inp2(ma, mb)

!  Print fm numbers in base 10 format using fmout for conversion.
!  This is used for tracing input values to the FM routines.

!  mb, mb  -  the two fm numbers to be printed.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma, mb

      character(9) :: name

      if (abs(ntrace) <= 1) return
      if (ncall > lvltrc) return

      name = namest(ncall)
      if (kround == 1) then
          write (kw, "(' Input to ', a)") trim(name)
      else if (kround == 2) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (kround == 0) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (kround == -1) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (kw, "(' Input to ', a)") trim(name)
      endif

!             Check for base mbase internal format trace.

      if (ntrace < 0) then
          call fmntrj(ma, ndig)
          call fmntrj(mb, ndig)
      endif

!             Check for base 10 trace using fmout.

      if (ntrace > 0) then
          call fmprnt(ma)
          call fmprnt(mb)
      endif

      return
      end subroutine fmntr_inp2

      subroutine fmntr_inp3(ma, mb, mc)

!  Print fm numbers in base 10 format using fmout for conversion.
!  This is used for tracing input values to the fm routines.

!  mb, mb, mc  -  the fm numbers to be printed.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb, mc

      character(9) :: name

      if (abs(ntrace) <= 1) return
      if (ncall > lvltrc) return

      name = namest(ncall)
      if (kround == 1) then
          write (kw, "(' Input to ', a)") trim(name)
      else if (kround == 2) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (kround == 0) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (kround == -1) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (kw, "(' Input to ', a)") trim(name)
      endif

!             Check for base mbase internal format trace.

      if (ntrace < 0) then
          call fmntrj(ma, ndig)
          call fmntrj(mb, ndig)
          call fmntrj(mc, ndig)
      endif

!             Check for base 10 trace using fmout.

      if (ntrace > 0) then
          call fmprnt(ma)
          call fmprnt(mb)
          call fmprnt(mc)
      endif

      return
      end subroutine fmntr_inp3

      subroutine fmntr_inp4(ma, mb, mc, md)

!  Print fm numbers in base 10 format using fmout for conversion.
!  This is used for tracing input values to the fm routines.

!  mb, mb, mc, md  -  the fm numbers to be printed.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc, md

      character(9) :: name

      if (abs(ntrace) <= 1) return
      if (ncall > lvltrc) return

      name = namest(ncall)
      if (kround == 1) then
          write (kw, "(' Input to ', a)") trim(name)
      else if (kround == 2) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (kround == 0) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (kround == -1) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (kw, "(' Input to ', a)") trim(name)
      endif

!             Check for base mbase internal format trace.

      if (ntrace < 0) then
          call fmntrj(ma, ndig)
          call fmntrj(mb, ndig)
          call fmntrj(mc, ndig)
          call fmntrj(md, ndig)
      endif

!             Check for base 10 trace using fmout.

      if (ntrace > 0) then
          call fmprnt(ma)
          call fmprnt(mb)
          call fmprnt(mc)
          call fmprnt(md)
      endif

      return
      end subroutine fmntr_inp4

      subroutine fmntr_inpd(x)

!  Internal routine for trace output of double precision variables.

!  x     Value to be printed.

      use fmvals
      implicit none

      double precision :: x
      intent (in) :: x

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return
      if (abs(ntrace) == 1) return

      name = namest(ncall)
      if (kround == 1) then
          write (kw, "(' Input to ', a)") trim(name)
      else if (kround == 2) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (kround == 0) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (kround == -1) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (kw, "(' Input to ', a)") trim(name)
      endif

      write (kw, "(1x, es30.20)") x

      return
      end subroutine fmntr_inpd

      subroutine fmntr_inpi(n)

!  Internal routine for trace output of integer variables.

!  n     Integer to be printed.

      use fmvals
      implicit none

      integer :: n
      intent (in) :: n

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return
      if (abs(ntrace) == 1) return

      name = namest(ncall)
      if (kround == 1) then
          write (kw, "(' Input to ', a)") trim(name)
      else if (kround == 2) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (kround == 0) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (kround == -1) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (kw, "(' Input to ', a)") trim(name)
      endif

      write (kw, "(1x, i20)") n

      return
      end subroutine fmntr_inpi

      subroutine fmntr_inpi1(ival, ma)

!  Print fm numbers in base 10 format using fmout for conversion.
!  This is used for tracing input values to the fm routines.

!  ival -  the integer to be printed.
!  ma   -  the fm number to be printed.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ma, ival

      character(9) :: name

      if (abs(ntrace) <= 1) return
      if (ncall > lvltrc) return

      name = namest(ncall)
      if (kround == 1) then
          write (kw, "(' Input to ', a)") trim(name)
      else if (kround == 2) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (kround == 0) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (kround == -1) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (kw, "(' Input to ', a)") trim(name)
      endif

      write (kw, "(1x, i20)") ival

!             Check for base mbase internal format trace.

      if (ntrace < 0) then
          call fmntrj(ma, ndig)
      endif

!             Check for base 10 trace using fmout.

      if (ntrace > 0) then
          call fmprnt(ma)
      endif

      return
      end subroutine fmntr_inpi1

      subroutine fmntr_inpii(n1, n2)

!  Internal routine for trace output of integer variables.

!  n1, n2     Integers to be printed.

      use fmvals
      implicit none

      integer :: n1, n2
      intent (in) :: n1, n2

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return
      if (abs(ntrace) == 1) return

      name = namest(ncall)
      if (kround == 1) then
          write (kw, "(' Input to ', a)") trim(name)
      else if (kround == 2) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (kround == 0) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (kround == -1) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (kw, "(' Input to ', a)") trim(name)
      endif

      write (kw, "(1x, i20)") n1
      write (kw, "(1x, i20)") n2

      return
      end subroutine fmntr_inpii

      subroutine fmntr_inpr(x)

!  Internal routine for trace output of single precision variables.

!  x     Value to be printed.

      use fmvals
      implicit none

      real :: x
      intent (in) :: x

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return
      if (abs(ntrace) == 1) return

      name = namest(ncall)
      if (kround == 1) then
          write (kw, "(' Input to ', a)") trim(name)
      else if (kround == 2) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (kround == 0) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (kround == -1) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (kw, "(' Input to ', a)") trim(name)
      endif

      write (kw, "(1x, es20.10)") x

      return
      end subroutine fmntr_inpr

      subroutine fmntr_inpz(z)

!  Internal routine for trace input of double precision variables.

!  z     Value to be printed.

      use fmvals
      implicit none

      complex :: z
      intent (in) :: z

      character(9) :: name
      double precision :: zreal, zimag

      if (ntrace == 0) return
      if (ncall > lvltrc) return
      if (abs(ntrace) == 1) return

      name = namest(ncall)
      if (kround == 1) then
          write (kw, "(' Input to ', a)") trim(name)
      else if (kround == 2) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward +infinity)'
      else if (kround == 0) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward zero)'
      else if (kround == -1) then
          write (kw, "(' Input to ', a, a)") name, '      (round toward -infinity)'
      else
          write (kw, "(' Input to ', a)") trim(name)
      endif

      zreal = dble(z)
      zimag = dble(aimag(z))
      if (zimag >= 0.0d0) then
          write (kw, "(1x, es20.10, ' +', es20.10, ' i')") zreal, zimag
      else
          write (kw, "(1x, es20.10, ' -', es20.10, ' i')") zreal, abs(zimag)
      endif

      return
      end subroutine fmntr_inpz

      subroutine fmntr_out1(ma)

!  Print fm numbers in base 10 format using fmout for conversion.
!  This is used for tracing output values from the fm routines.

!  ma  -  the fm number to be printed.

      use fmvals
      implicit none

      type(multi) :: ma
      intent (in) :: ma

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return

      name = namest(ncall)
      if (kflag == 0) then
          write (kw,                                                      &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10, 5X, 'NDIG =', I10)"                                &
                ) name, ncall, int(mbase), ndig
      else
          write (kw,                                                     &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"            &
                ) name, ncall, int(mbase), ndig, kflag
      endif

!             Check for base mbase internal format trace.

      if (ntrace < 0) then
          call fmntrj(ma, ndig)
      endif

!             Check for base 10 trace using fmout.

      if (ntrace > 0) then
          call fmprnt(ma)
      endif

      return
      end subroutine fmntr_out1

      subroutine fmntr_out2(ma, mb)

!  Print fm numbers in base 10 format using fmout for conversion.
!  This is used for tracing output values from the fm routines.

!  ma, mb  -  the fm numbers to be printed.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma, mb

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return

      name = namest(ncall)
      if (kflag == 0) then
          write (kw,                                                      &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10, 5X, 'NDIG =', I10)"                                &
                ) name, ncall, int(mbase), ndig
      else
          write (kw,                                                     &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"            &
                ) name, ncall, int(mbase), ndig, kflag
      endif

!             Check for base mbase internal format trace.

      if (ntrace < 0) then
          call fmntrj(ma, ndig)
          call fmntrj(mb, ndig)
      endif

!             Check for base 10 trace using fmout.

      if (ntrace > 0) then
          call fmprnt(ma)
          call fmprnt(mb)
      endif

      return
      end subroutine fmntr_out2

      subroutine fmntr_out3(ma, mb, mc)

!  Print fm numbers in base 10 format using fmout for conversion.
!  This is used for tracing output values from the fm routines.

!  ma, mb, mc  -  the fm numbers to be printed.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb, mc

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return

      name = namest(ncall)
      if (kflag == 0) then
          write (kw,                                                      &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10, 5X, 'NDIG =', I10)"                                &
                ) name, ncall, int(mbase), ndig
      else
          write (kw,                                                     &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"            &
                ) name, ncall, int(mbase), ndig, kflag
      endif

!             Check for base mbase internal format trace.

      if (ntrace < 0) then
          call fmntrj(ma, ndig)
          call fmntrj(mb, ndig)
          call fmntrj(mc, ndig)
      endif

!             Check for base 10 trace using fmout.

      if (ntrace > 0) then
          call fmprnt(ma)
          call fmprnt(mb)
          call fmprnt(mc)
      endif

      return
      end subroutine fmntr_out3

      subroutine fmntr_outd(x)

!  Internal routine for trace output of double precision variables.

!  x     Value to be printed.

      use fmvals
      implicit none

      double precision :: x
      intent (in) :: x

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return

      name = namest(ncall)
      if (kflag == 0) then
          write (kw,                                                      &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10, 5X, 'NDIG =', I10)"                                &
                ) name, ncall, int(mbase), ndig
      else
          write (kw,                                                     &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"            &
                ) name, ncall, int(mbase), ndig, kflag
      endif

      write (kw, "(1x, es30.20)") x

      return
      end subroutine fmntr_outd

      subroutine fmntr_outi(n)

!  Internal routine for trace output of integer variables.

!  n     Integer to be printed.

      use fmvals
      implicit none

      integer :: n
      intent (in) :: n

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return

      name = namest(ncall)
      if (kflag == 0) then
          write (kw,                                                      &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10, 5X, 'NDIG =', I10)"                                &
                ) name, ncall, int(mbase), ndig
      else
          write (kw,                                                     &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"            &
                ) name, ncall, int(mbase), ndig, kflag
      endif

      write (kw, "(1x, i20)") n

      return
      end subroutine fmntr_outi

      subroutine fmntr_outr(x)

!  Internal routine for trace output of real variables.

!  x     Value to be printed.

      use fmvals
      implicit none

      real :: x
      intent (in) :: x

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return

      name = namest(ncall)
      if (kflag == 0) then
          write (kw,                                                      &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10, 5X, 'NDIG =', I10)"                                &
                ) name, ncall, int(mbase), ndig
      else
          write (kw,                                                     &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"            &
                ) name, ncall, int(mbase), ndig, kflag
      endif

      write (kw, "(1x, es20.10)") x

      return
      end subroutine fmntr_outr

      subroutine fmntr_outz(z)

!  Internal routine for trace output of double precision variables.

!  z     Value to be printed.

      use fmvals
      implicit none

      complex :: z
      intent (in) :: z

      character(9) :: name
      double precision :: zreal, zimag

      if (ntrace == 0) return
      if (ncall > lvltrc) return

      name = namest(ncall)
      if (kflag == 0) then
          write (kw,                                                      &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10, 5X, 'NDIG =', I10)"                                &
                ) name, ncall, int(mbase), ndig
      else
          write (kw,                                                     &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"            &
                ) name, ncall, int(mbase), ndig, kflag
      endif

      zreal = dble(z)
      zimag = dble(aimag(z))
      if (zimag >= 0.0d0) then
          write (kw, "(1x, es20.10, ' +', es20.10, ' i')") zreal, zimag
      else
          write (kw, "(1x, es20.10, ' -', es20.10, ' i')") zreal, abs(zimag)
      endif

      return
      end subroutine fmntr_outz

      subroutine fmntrj(ma, nd)

!  Print trace output in internal base mbase format.  The number to be printed is in ma.

!  nd is the number of base mbase digits to be printed.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: nd
      intent (in) :: ma, nd

      character(99) :: form
      character(40), external :: fmfi
      character(40) :: st1, st2
      integer :: j, l, n

      l = int(log10(dble(mbase-1))) + 2
      n = (kswide-23)/l
      if (n > 10) n = 5*(n/5)
      if (nd <= n) then
          write (form, "(' (1x, i19, i', i2, ', ', i3, 'i', i2, ') ')") l+2, n-1, l
      else
          write (form, "(' (1x, i19, i', i2, ', ', i3, 'i', i2, '/"  //  &
                      "(22x, ', i3, 'i', i2, ')) ')"                     &
                ) l+2, n-1, l, n, l
      endif

      st1 = fmfi(int(ma%mp(1)))
      st2 = fmfi(int(ma%mp(2)))
      write (kw, "(A, A, A, A, A)") '            Sign = ', trim(st1),  &
                 '   Exponent = ', trim(st2), '   Digits:'
      write (form,*) '(13X, ', n, 'I', l, ')'
      if (ma%mp(5) < 0) then
          if (nd+2 >= 6) then
              write (kw, form) int(ma%mp(3)), 0, 0, (int(ma%mp(j)), j=6, nd+2)
          else if (nd+2 == 5) then
              write (kw, form) int(ma%mp(3)), 0, 0
          else
              write (kw, form) int(ma%mp(3)), 0
          endif
      else
          write (kw, form) (int(ma%mp(j)), j=3, nd+2)
      endif

      return
      end subroutine fmntrj

      subroutine fmout(ma, line, lb)

!  Convert a floating multiple precision number to a character array for output.

!  ma   is an fm number to be converted to an a1 character array in base 10 format.
!  line is the character(1) array in which the result is returned.
!  lb   is the length of line.

! jform1 and jform2 (in module fmvals) determine the format of line.

! jform1 = 0  normal setting  ( .314159m+6 )
!        = 1  es  format      ( 3.14159m+5 )
!        = 2  f   format      ( 314159.000 )

! jform2 = number of significant digits to display (if jform1 = 0, 1)
!        = number of digits after the decimal point (if jform1 = 2)

!          If jform2 == 0 and jform1 /= 2 then a default number of digits is chosen.
!          The default is roughly the full precision of ma.

!          If jform2 == 0 and jform1 == 2 then the number is returned in integer format with no
!          decimal point.  Rounding is done as with other settings, so the value displayed is the
!          nearest integer to ma.

!  If jform1 == 2 and ma is too large or too small to display in the requested format, it is
!  converted using jform1=0, jform2=0.

!  line should be dimensioned at least log10(mbase)*ndig + 15 on a 32-bit machine to allow for up to
!  10 digit exponents.  Replace 15 by 20 if 48-bit integers are used, 25 for 64-bit integers, ....

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: lb
      character :: line(lb)
      intent (in) :: ma, lb
      intent (inout) :: line

      type(multi), save :: mxy(2), mresult
      integer :: j, jfsave, kovun, kresult, ndsave, npower
      real (kind(1.0d0)) :: mbsave, mxsave

      jfsave = jform2
      if (jform2 == 0 .and. jform1 /= 2 .and. abs(ma%mp(2)) < mexpov) then
          jform2 = max( 1.5d0 + (ndig-1)*log10(dble(mbase)) , 5.0d0 )
      endif
      j = ntrace
      ntrace = 0
      mbsave = mbase
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmout_sc(ma, mxy, mresult, mbsave, ndsave, npower, line, lb, kresult)
      if (kresult > 0) then
          ntrace = j
          mbase = mbsave
          jform2 = jfsave
          call fmexit0(mxsave, ndsave)
          return
      endif

      call fmout_m1(mxy, mresult, npower, mbsave, ndsave, line, lb)

      ntrace = j
      mbase = mbsave
      jform2 = jfsave
      call fmexit0(mxsave, ndsave)
      call fmcons

      return
      end subroutine fmout

      subroutine fmout_err(line, lb)

      implicit none

      integer :: lb
      character :: line(lb)
      intent (in) :: lb
      intent (inout) :: line

      integer :: j

      do j = 1, lb
         line(j) = '*'
      enddo

      return
      end subroutine fmout_err

      subroutine fmout_m1(mxy, mx, npower, mbsave, ndsave, line, lb)

!  Method 1 for fmout.

      use fmvals
      implicit none

      type(multi) :: mxy(2), mx
      integer :: lb, ndsave, npower
      real (kind(1.0d0)) :: mbsave
      character :: line(lb)
      intent (in) :: mx, npower, mbsave, ndsave, lb
      intent (inout) :: mxy, line

      integer :: i, j, jd, jf1, jf2, jp, k, k0, k1, k2, k1sav, kd, kd1, kde, kdig, kdpt,  &
                 ke, ke2, kmid, kpt, kpt1, ksh, nd, ndg, nlz, ntz
      character :: numb(10) = (/ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' /), temp

      kdpt = 0
      jf1 = jform1
      jf2 = jform2
      k1 = 1
      jp = 10
      kd1 = mx%mp(3)
      ke = mx%mp(2)
      do j = 1, npower
         if (kd1 < jp) exit
         k1 = k1 + 1
         jp = 10 * jp
      enddo
      k0 = k1
      k1sav = k1

!             nd is the number of base ten digits to display in the current output format.

      if (jf1 <= 1) then
          nd = min( jf2, k1 + npower*(ndig-1) )
      else
          if (ke >= 1) then
              if (k1 + npower*(ke-1) + jf2 + 3 > lb) then
                  jf1 = 0
                  nd = max( 1.5d0 + (ndsave-1)*log10(dble(mbsave)) , 5.0d0 )
                  jf2 = nd
              else
                  nd = min( k1 + npower*(ke-1) + jf2, k1 + npower*(ndig-1) )
              endif
          else
              if (npower - k1 + npower*(-ke) >= jf2) then
                  jf1 = 0
                  nd = max( 1.5d0 + (ndsave-1)*log10(dble(mbsave)) , 5.0d0 )
                  jf2 = nd
              else
                  nd = min( jf2 - (npower - k1 + npower*(-ke)), k1 + npower*(ndig-1) )
              endif
          endif
      endif

      k = abs(k1-npower+ke*npower)
      if (k == 0) k = 1
      kdig = max( 1.0d0, log10(dble(k)) + 1 )
      k = lb - kdig - 4
      if (nd > k) then
          nd = k
          if (nd <= 0) then
              call fmout_err(line, lb)
              return
          endif
      endif
!             Shift mx if necessary to put the nd'th significant decimal at the right
!             end of a word boundary in base mbase.

      i = ceiling(dble(nd - k1)/dble(npower) + 1)
      ksh = k1 + npower*(i-1) - nd
      if (ksh >= k1) then
          ksh = npower - ksh
          call fmmpyi2(mx, 10**ksh, mxy(1))
          k1 = k1 + ksh
          i = ceiling(dble(nd - k1)/dble(npower) + 1)
      else
          call fmdivi2(mx, 10**ksh, mxy(1))
          k1 = k1 - ksh
      endif

      call fmalloc(mxy(2), i+4)
      if (i <= 2) then
          call fmequ_r1(mxy(1), ndig, ndig+2)
          do j = ndig+4, 5, -1
             mxy(1)%mp(j) = mxy(1)%mp(j-2)
          enddo
          mxy(1)%mp(3) = 1
          mxy(1)%mp(4) = 0
          call fmequ(mxy(1), mxy(2), ndig+2, i+2)
          if (mxy(2)%mp(4) > 0) then
              do j = 3, i+2
                 mxy(2)%mp(j) = mxy(2)%mp(j+1)
              enddo
          else
              do j = 3, i+2
                 mxy(2)%mp(j) = mxy(2)%mp(j+2)
              enddo
          endif
      else
          call fmequ(mxy(1), mxy(2), ndig, i)
      endif
      mxy(2)%mp(3+i) = 0

      k2 = 1
      jp = 10
      kd1 = mxy(2)%mp(3)
      do j = 1, npower
         if (kd1 < jp) exit
         k2 = k2 + 1
         jp = 10 * jp
      enddo

!             Check to see if rounding has caused the base mbase exponent of mx (ke) to change.

      if (k2 /= k1) then
          if (k0 == npower) then
              ke = ke + 1
          endif
          k1 = k2
          k1sav = k1sav + 1
          if (k1sav > npower) k1sav = 1
      endif

!             The first nd decimal digits have been rounded in mxy(2).
!             Build the output line.

      if (mx%mp(1) < 0) then
          line(1) = '-'
      endif
      if (jf1 == 2) then

!               Fixed format.

          kpt = 2
          if (ke >= 1) then
              ke2 = ke
              if (k1-k1sav < 0) ke2 = ke + 1
              do j = 1, ke2
                 kd = npower
                 if (j == 1) kd = k1
                 if (j > ndig) exit
                 kdig = mxy(2)%mp(j+2)
                 if (lb < kpt+kd-1) then
                     call fmout_err(line, lb)
                     return
                 endif
                 do jd = 1, kd
                    ndg = mod(kdig, 10)
                    line(kpt+kd-jd) = numb(ndg+1)
                    kdig = kdig / 10
                 enddo
                 kpt = kpt + kd
              enddo
              ksh = k1 - k1sav
              if (lb < kpt) then
                  call fmout_err(line, lb)
                  return
              endif
              if (ksh > 0) then
                  do j = kpt, kpt-ksh+1, -1
                     line(j) = line(j-1)
                  enddo
                  line(kpt-ksh) = '.'
                  kdpt = kpt - ksh
              else if (ksh < 0) then
                  ksh = npower + ksh
                  do j = kpt, kpt-ksh+1, -1
                     line(j) = line(j-1)
                  enddo
                  line(kpt-ksh) = '.'
                  kdpt = kpt - ksh
              else
                  line(kpt) = '.'
                  kdpt = kpt
              endif
              kpt = kpt + 1
              if (lb < kpt) then
                  call fmout_err(line, lb)
                  return
              endif
              if (jf2 == 0) then
                  do j = kpt, 1, -1
                     if (line(j) /= '.') then
                         line(j) = ' '
                     else
                         line(j) = ' '
                         return
                     endif
                  enddo
              endif
              j = ke2 + 1
              do while (kpt <= nd+2)
                 kd = npower
                 kdig = mxy(2)%mp(j+2)
                 if (lb < kpt+kd-1) then
                     call fmout_err(line, lb)
                     return
                 endif
                 do jd = 1, kd
                    ndg = mod(kdig, 10)
                    line(kpt+kd-jd) = numb(ndg+1)
                    kdig = kdig / 10
                 enddo
                 j = j + 1
                 kpt = kpt + kd
              enddo
          else
              nlz = max(0, npower - k1sav - npower*ke)
              if (lb < kpt+nlz) then
                  call fmout_err(line, lb)
                  return
              endif
              line(kpt) = '.'
              kdpt = kpt
              kpt = kpt + 1
              do j = 1, nlz
                 line(kpt) = '0'
                 kpt = kpt + 1
              enddo
              do j = 1, i
                 kd = npower
                 if (j == 1) kd = k1
                 kdig = mxy(2)%mp(j+2)
                 if (lb < kpt+kd-1) then
                     call fmout_err(line, lb)
                     return
                 endif
                 do jd = 1, kd
                    ndg = mod(kdig, 10)
                    line(kpt+kd-jd) = numb(ndg+1)
                    kdig = kdig / 10
                 enddo
                 kpt = kpt + kd
              enddo
          endif
          ntz = jf2 - (kpt-kdpt-1)
          if (ntz > 0) then
              if (lb < kpt+ntz-1) then
                  call fmout_err(line, lb)
                  return
              endif
              do j = 1, ntz
                 line(kpt) = '0'
                 kpt = kpt + 1
              enddo
          endif
      else
!
!               Exponential format.
!
          if (nd > jf2) jf2 = nd
          kpt = 2
          line(kpt) = '.'
          kpt = 3
          kde = (ke-1) * npower + k1sav - 1
          if (jf1 == 0) kde = kde + 1
          j = 1
          do while (kpt <= nd+2)
             kd = npower
             if (j == 1) kd = k1
             kdig = mxy(2)%mp(j+2)
             if (lb < kpt+kd-1) then
                 call fmout_err(line, lb)
                 return
             endif
             do jd = 1, kd
                ndg = mod(kdig, 10)
                line(kpt+kd-jd) = numb(ndg+1)
                kdig = kdig / 10
             enddo
             j = j + 1
             kpt = kpt + kd
          enddo
          jd = jf2
          do while (kpt-1 > jd+2)
              kpt = kpt - 1
              line(kpt) = ' '
          enddo
          if (jd > kpt-3) then
              if (lb < jd+2) then
                  call fmout_err(line, lb)
                  return
              endif
              do j = kpt-2, jd
                 line(kpt) = '0'
                 kpt = kpt + 1
              enddo
          endif
          if (lb < kpt+1) then
              call fmout_err(line, lb)
              return
          endif
          line(kpt) = cmchar
          kpt = kpt + 1
          if (kde < 0) then
              line(kpt) = '-'
          else
              line(kpt) = '+'
          endif
          kpt = kpt + 1
          kdig = abs(kde)
          kpt1 = kpt
          do while (kdig >= 0)
             ndg = mod(kdig, 10)
             if (lb < kpt) then
                 call fmout_err(line, lb)
                 return
             endif
             line(kpt) = numb(ndg+1)
             kdig = kdig / 10
             if (kdig == 0) exit
             kpt = kpt + 1
          enddo
          kmid = (kpt+kpt1)/2
          if (mod(kpt+kpt1, 2) == 0) kmid = kmid - 1
          do j = kpt1, kmid
             temp = line(j)
             line(j) = line(kpt+kpt1-j)
             line(kpt+kpt1-j) = temp
          enddo
      endif
      if (jf1 == 1) then
          line(2) = line(3)
          line(3) = '.'
      endif

      return
      end subroutine fmout_m1

      subroutine fmout_sc(ma, mxy, mresult, mbsave, ndsave, npower, line, lb, kresult)

!  Check for special cases.

!  mresult is returned as ma with its precision adjusted to the current output format,
!          and converted to a power of ten base if the original base is not a power of ten.

      use fmvals
      implicit none

      type(multi) :: ma, mxy(2), mresult
      integer :: ndsave, npower, lb, kresult
      real (kind(1.0d0)) :: mbsave
      character :: line(lb)
      intent (in) :: ma, mbsave, ndsave, lb
      intent (inout) :: mxy, mresult, npower, line, kresult

      integer :: j, k, kwrnsv, new_mbase, new_ndig
      character :: nunkno(12) = (/ ' ', ' ', ' ', 'U', 'N', 'K', 'N', 'O', 'W', 'N', ' ', ' ' /)
      character :: nexpov(12) = (/ ' ', ' ', ' ', 'O', 'V', 'E', 'R', 'F', 'L', 'O', 'W', ' ' /)
      character :: nexpun(12) = (/ ' ', ' ', ' ', 'U', 'N', 'D', 'E', 'R', 'F', 'L', 'O', 'W' /)

      namest(ncall) = 'FMOUT    '
      call fmcons
      kresult = 0

      kflag = 0
      kwrnsv = kwarn
      kwarn = 0
      do j = 1, lb
         line(j) = ' '
      enddo

!             Check for special values overflow, underflow, unknown.

      if (ma%mp(2) == munkno) then
          if (lb < 12) then
              call fmout_err(line, lb)
              kwarn = kwrnsv
              kresult = 1
              return
          endif
          do j = 1, 12
             line(j) = nunkno(j)
          enddo
          kwarn = kwrnsv
          kresult = 1
          return
      endif
      if (ma%mp(2) == mexpov) then
          if (lb < 12) then
              call fmout_err(line, lb)
              kwarn = kwrnsv
              kresult = 1
              return
          endif
          do j = 1, 12
             line(j) = nexpov(j)
          enddo
          line(2) = '+'
          if (ma%mp(1) < 0) line(2) = '-'
          kwarn = kwrnsv
          kresult = 1
          return
      endif
      if (ma%mp(2) == mexpun) then
          if (lb < 12) then
              call fmout_err(line, lb)
              kwarn = kwrnsv
              kresult = 1
              return
          endif
          do j = 1, 12
             line(j) = nexpun(j)
          enddo
          line(2) = '+'
          if (ma%mp(1) < 0) line(2) = '-'
          kwarn = kwrnsv
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0 .and. jform1 == 2 .and. jform2 == 0) then
          line(2) = '0'
          kwarn = kwrnsv
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0) then
          if (jform1 == 0) then
              if (lb < 5+jform2) then
                  call fmout_err(line, lb)
                  kwarn = kwrnsv
                  kresult = 1
                  return
              endif
              line(2) = '.'
              do j = 3, 2+jform2
                 line(j) = '0'
              enddo
              line(3+jform2) = cmchar
              line(5+jform2) = '0'
          else if (jform1 == 1) then
              if (lb < 5+jform2) then
                  call fmout_err(line, lb)
                  kwarn = kwrnsv
                  kresult = 1
                  return
              endif
              line(2) = '0'
              line(3) = '.'
              do j = 4, 2+jform2
                 line(j) = '0'
              enddo
              line(3+jform2) = cmchar
              line(5+jform2) = '0'
          else if (jform1 == 2) then
              if (jform2 <= 0) then
                  line(2) = '0'
              else
                  if (lb < 2+jform2) then
                      call fmout_err(line, lb)
                      kwarn = kwrnsv
                      kresult = 1
                      return
                  endif
                  line(2) = '.'
                  do j = 3, 2+jform2
                     line(j) = '0'
                  enddo
              endif
          endif
          kwarn = kwrnsv
          kresult = 1
          return
      endif

!             Check to see if the current base is a power of ten.

      npower = 0
      k = int(log10(dble(mxbase)))
      do j = 1, k
         if (10.0d0**j == mbsave) then
             if (mblogs /= mbase) call fmcons
             npower = j
             exit
         endif
      enddo

!             If the current base is not a power of ten, convert ma to a power of ten base.

      if (npower == 0) then
          call fmequ(ma, mxy(1), ndsave, ndig)
          npower = int(log10(dble(mxbase/4)))
          new_mbase = 10**npower
          new_ndig = max(3, int(2 * ndsave * log(dble(mbsave)) / log(dble(new_mbase))) )
          call fmchangebase(mxy(1), mresult, new_mbase, new_ndig)
          ndig = new_ndig
          mbase = new_mbase
      else
          call fmequ(ma, mresult, ndsave, ndig)
      endif

      kwarn = kwrnsv

      return
      end subroutine fmout_sc

      subroutine fmoverflow(k, ma)

!  Set ma to fm's special value for overflowed results.

!  k = -1 returns ma = -overflow

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: k
      intent (in) :: k
      intent (inout) :: ma

      integer :: j
      double precision :: d

      call fmalloc(ma, ndig+2)
      do j = 5, ndig+2
         ma%mp(j) = 0
      enddo
      ma%mp(1) = k
      ma%mp(2) = mexpov
      ma%mp(3) = 1
      if (huge(mbase)/mexpov > 1.0d+20) then
          d = 1.0d+10
      else
          d = 4
      endif
      ma%mp(4) = huge(mbase)/d
      ma%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))

      end subroutine fmoverflow

      subroutine fmovun_add(ma, mb, mc)

!  Internal addition routine.  mc = ma + mb

!  One or both arguments are overflow, underflow, or unknown, and this routine tries to track
!  exceptional operations for better error handling.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: j
      logical :: abs_ma_gt_abs_mb
      double precision :: xe, xf, ye, yf

      call fmalloc(mc, ndig+2)

      if ((ma%mp(2) == munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc)
          kflag = -4
          return
      endif
      kflag = 0
      if (ma%mp(3) == 0) then
          do j = 1, ndig+2
             mc%mp(j) = mb%mp(j)
          enddo
          kflag = 1
          return
      endif
      if (mb%mp(3) == 0) then
          do j = 1, ndig+2
             mc%mp(j) = ma%mp(j)
          enddo
          kflag = 1
          return
      endif
      if (kround /= 1) then
          call fmovun_xexf(ma, xe, xf)
          call fmovun_xexf(mb, ye, yf)
          if (abs(ma%mp(2)) < mexpov .and. mb%mp(5) < 0) then
              if (xe > ye + ndig) then
                  do j = 1, ndig+2
                     mc%mp(j) = ma%mp(j)
                  enddo
                  if (ma%mp(1) > 0 .and. mb%mp(1) > 0) then
                      if (kround == 2) call fmovun_rnd(mc, 1)
                  else if (ma%mp(1) < 0 .and. mb%mp(1) > 0) then
                      if (kround == 0 .or. kround == 2) call fmovun_rnd(mc, -1)
                  else if (ma%mp(1) > 0 .and. mb%mp(1) < 0) then
                      if (kround == -1 .or. kround == 0) call fmovun_rnd(mc, -1)
                  else if (ma%mp(1) < 0 .and. mb%mp(1) < 0) then
                      if (kround == -1) call fmovun_rnd(mc, 1)
                  endif
                  kflag = 1
                  return
              endif
          endif

          if (abs(mb%mp(2)) < mexpov .and. ma%mp(5) < 0) then
              if (ye > xe + ndig) then
                  do j = 1, ndig+2
                     mc%mp(j) = mb%mp(j)
                  enddo
                  if (mc%mp(1) > 0 .and. ma%mp(1) > 0) then
                      if (kround == 2) call fmovun_rnd(mc, 1)
                  else if (mc%mp(1) < 0 .and. ma%mp(1) > 0) then
                      if (kround == 0 .or. kround == 2) call fmovun_rnd(mc, -1)
                  else if (mc%mp(1) > 0 .and. ma%mp(1) < 0) then
                      if (kround == -1 .or. kround == 0) call fmovun_rnd(mc, -1)
                  else if (mc%mp(1) < 0 .and. ma%mp(1) < 0) then
                      if (kround == -1) call fmovun_rnd(mc, 1)
                  endif
                  kflag = 1
                  return
              endif
          endif
      endif
      do j = 2, ndig+2
         mc%mp(j) = 0
      enddo
      mc%mp(1) = 1

      abs_ma_gt_abs_mb = .true.
      call fmovun_xexf(ma, xe, xf)
      call fmovun_xexf(mb, ye, yf)
      if (ye > xe) then
          abs_ma_gt_abs_mb = .false.
      else if (ye == xe) then
          if (yf > xf) then
              abs_ma_gt_abs_mb = .false.
          endif
      endif

      if (abs_ma_gt_abs_mb) then
          if (ma%mp(1) > 0) then
              if (mb%mp(1) > 0) then
                  call fmovun_addp(ma, mb, mc)
                  mc%mp(1) = 1
              else
                  call fmovun_subp(ma, mb, mc)
                  mc%mp(1) = 1
              endif
          else
              if (mb%mp(1) > 0) then
                  call fmovun_subp(ma, mb, mc)
                  mc%mp(1) = -1
              else
                  call fmovun_addp(ma, mb, mc)
                  mc%mp(1) = -1
              endif
          endif
      else
          if (ma%mp(1) > 0) then
              if (mb%mp(1) > 0) then
                  call fmovun_addp(mb, ma, mc)
                  mc%mp(1) = 1
              else
                  call fmovun_subp(mb, ma, mc)
                  mc%mp(1) = -1
              endif
          else
              if (mb%mp(1) > 0) then
                  call fmovun_subp(mb, ma, mc)
                  mc%mp(1) = 1
              else
                  call fmovun_addp(mb, ma, mc)
                  mc%mp(1) = -1
              endif
          endif
      endif

      if (mc%mp(2) == munkno .and. kflag /= 1) kflag = -4
      if (mc%mp(2) == mexpov .and. kflag /= 1) kflag = -5
      if (mc%mp(2) == mexpun .and. kflag /= 1) kflag = -6

      return
      end subroutine fmovun_add

      subroutine fmovun_addp(ma, mb, mc)

!  Internal addition routine.  mc = ma + mb

!  The arguments are such that abs(ma) >= abs(mb) and both ma and mb are treated as positive,
!  meaning the sign bits are ignored.

!  One or both arguments are overflow, underflow, or unknown, and this routine tries to track
!  exceptional operations for better error handling.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: j
      double precision :: b, d, xe, xf, ye, yf, ze, zf

      call fmovun_xexf(ma, xe, xf)
      call fmovun_xexf(mb, ye, yf)


      if (xe-ye > ndig) then
          do j = 1, ndig+2
             mc%mp(j) = ma%mp(j)
          enddo
          kflag = 1
          return
      endif
      b = mbase
      if (ye-xe < log(epsilon(b)/b) / log(b)) then
          ze = xe
          zf = xf
      else
          ze = xe
          zf = xf + yf*b**(ye-xe)
      endif
      if (zf >= 1.0d0) then
          ze = ze + 1
          zf = zf / b
      endif
      if (huge(mbase)/mexpov > 1.0d+20) then
          d = 1.0d+10
      else
          d = 4
      endif
      if (ze > huge(mbase)/d) then
          ze = huge(mbase)/d
          zf = 1.0d0 - epsilon(1.0d0)
      else if (ze < -huge(mbase)/d) then
          ze = -huge(mbase)/d
          zf = 1.0d0 - epsilon(1.0d0)
      else if (ze == ze + 1.0d0) then
          zf = 1.0d0 - epsilon(1.0d0)
      endif
      mc%mp(4) = ze
      if (zf == 0) zf = 1.0d0 / b
      mc%mp(5) = -zf*maxint
      if (mc%mp(4) >= -mxexp0 .and. mc%mp(4) <= mxexp0+1) then
          mc%mp(1) = 1
          mc%mp(2) = munkno
          mc%mp(3) = 1
          do j = 4, ndig
             mc%mp(j+2) = 0
          enddo
          kflag = -4
          return
      else if (mc%mp(4) < -mxexp0) then
          mc%mp(2) = mexpun
          kflag = -6
      else if (mc%mp(4) > mxexp0+1) then
          mc%mp(2) = mexpov
          kflag = -5
      endif
      mc%mp(3) = 1

      end subroutine fmovun_addp

      subroutine fmovun_div(ma, mb, mc)

!  Internal division routine.  mc = ma / mb

!  One or both arguments are overflow, underflow, or unknown, and this routine tries to track
!  exceptional operations for better error handling.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: j
      double precision :: d, xe, xf, ye, yf, ze, zf

      call fmalloc(mc, ndig+2)

      if ((ma%mp(2) == munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc)
          kflag = -4
          return
      endif
      if (ma%mp(3) == 0) then
          do j = 2, ndig+2
             mc%mp(j) = 0
          enddo
          mc%mp(1) = 1
          kflag = 0
          return
      endif
      if (mb%mp(3) == 0) then
          call fmunknown(mc)
          kflag = -4
          return
      endif
      do j = 2, ndig+2
         mc%mp(j) = 0
      enddo
      mc%mp(1) = 1
      call fmovun_xexf(ma, xe, xf)
      call fmovun_xexf(mb, ye, yf)
      if (huge(mbase)/mexpov > 1.0d+20) then
          d = 1.0d+10
      else
          d = 4
      endif


      if ((xe ==  huge(mbase)/d .and. ye ==  huge(mbase)/d) .or.  &
          (xe == -huge(mbase)/d .and. ye == -huge(mbase)/d) ) then
          call fmunknown(mc)
          kflag = -4
          return
      endif
      mc%mp(1) = ma%mp(1) * mb%mp(1)
      ze = xe - ye
      zf = xf / yf
      if (xf/yf >= 1) then
          ze = xe - ye + 1
          zf = (xf / yf) / mbase
      endif
      if (ze > huge(mbase)/d) then
          ze = huge(mbase)/d
          zf = 1.0d0 - epsilon(1.0d0)
      else if (ze < -huge(mbase)/d) then
          ze = -huge(mbase)/d
          zf = 1.0d0 - epsilon(1.0d0)
      else if (ze == ze + 1.0d0) then
          zf = 1.0d0 - epsilon(1.0d0)
      endif
      if (zf == 0) zf = -epsilon(1.0d0)
      if (zf >= 1) then
          zf = zf / mbase
          ze = ze + 1
      else if (zf < 1.0d0/mbase) then
          zf = zf * mbase
          ze = ze - 1
      endif
      mc%mp(4) = ze
      mc%mp(5) = -zf*maxint
      if (mc%mp(4) >= -mxexp0 .and. mc%mp(4) <= mxexp0+1) then
          mc%mp(1) = ma%mp(1) * mb%mp(1)
          mc%mp(2) = munkno
          mc%mp(3) = 1
          do j = 4, ndig
             mc%mp(j+2) = 0
          enddo
          kflag = -4
          return
      else if (mc%mp(4) < -mxexp0) then
          mc%mp(2) = mexpun
          kflag = -6
      else if (mc%mp(4) > mxexp0+1) then
          mc%mp(2) = mexpov
          kflag = -5
      endif
      mc%mp(3) = 1

      return
      end subroutine fmovun_div

      subroutine fmovun_frac(ma, xf)

!  xf is a double precision approximation to the fractional part of fm number ma.

      use fmvals
      implicit none

      type(multi) :: ma
      double precision :: xf
      intent (in) :: ma
      intent (inout) :: xf

      double precision :: eps, t
      integer :: j, nd1

      xf = 0
      eps = epsilon(xf) / mbase
      t = 1.0d0 / mbase
      nd1 = size(ma%mp)-2
      do j = 1, min(ndig, nd1)
         xf = xf + ma%mp(2+j)*t
         t = t / mbase
         if (t < eps) exit
      enddo

      end subroutine fmovun_frac

      subroutine fmovun_mpy(ma, mb, mc)

!  Internal multiplication routine.  mc = ma * mb

!  One or both arguments are overflow, underflow, or unknown, and this routine tries to track
!  exceptional operations for better error handling.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: j
      double precision :: d, xe, xf, ye, yf, ze, zf

      call fmalloc(mc, ndig+2)

      if ((ma%mp(2) == munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc)
          kflag = -4
          return
      endif
      if (ma%mp(3) == 0 .or. mb%mp(3) == 0) then
          do j = 2, ndig+2
             mc%mp(j) = 0
          enddo
          mc%mp(1) = 1
          kflag = 0
          return
      endif
      do j = 2, ndig+2
         mc%mp(j) = 0
      enddo
      mc%mp(1) = 1
      call fmovun_xexf(ma, xe, xf)
      call fmovun_xexf(mb, ye, yf)
      if (huge(mbase)/mexpov > 1.0d+20) then
          d = 1.0d+10
      else
          d = 4
      endif

      if ((xe == huge(mbase)/d .and. ye == -huge(mbase)/d) .or.  &
          (xe == -huge(mbase)/d .and. ye == huge(mbase)/d) ) then
          call fmunknown(mc)
          kflag = -4
          return
      endif

      mc%mp(1) = ma%mp(1) * mb%mp(1)
      ze = xe + ye
      zf = xf * yf
      if (zf < 1.0d0/mbase) then
          ze = ze - 1
          zf = zf * mbase
      endif
      if (ze > huge(mbase)/d) then
          ze = huge(mbase)/d
          zf = 1.0d0 - epsilon(1.0d0)
      else if (ze < -huge(mbase)/d) then
          ze = -huge(mbase)/d
          zf = 1.0d0 - epsilon(1.0d0)
      else if (ze == ze + 1.0d0) then
          zf = 1.0d0 - epsilon(1.0d0)
      endif
      if (zf == 0) zf = -epsilon(1.0d0)
      mc%mp(4) = ze
      mc%mp(5) = -zf*maxint
      if (mc%mp(4) >= -mxexp0 .and. mc%mp(4) <= mxexp0+1) then
          mc%mp(1) = ma%mp(1) * mb%mp(1)
          mc%mp(2) = munkno
          mc%mp(3) = 1
          do j = 4, ndig
             mc%mp(j+2) = 0
          enddo
          kflag = -4
          return
      else if (mc%mp(4) < -mxexp0) then
          mc%mp(2) = mexpun
          kflag = -6
      else if (mc%mp(4) > mxexp0+1) then
          mc%mp(2) = mexpov
          kflag = -5
      endif
      mc%mp(3) = 1

      end subroutine fmovun_mpy

      subroutine fmovun_pwr(ma, mb, mc)

!  Internal power routine.  mc = ma**mb

!  One or both arguments are overflow, underflow, or unknown, or both are representable numbers
!  but mc is overflow or underflow.  This routine tries to track exceptional operations for better
!  error handling.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: i, j, k, kl
      double precision :: xe, xf, ye, yf
      real (kind(1.0d0)) :: m2
      type(multi), save :: mxy(3)
      logical, external :: fmcomp

      call fmalloc(mc, ndig+2)

      kl = 0
      if (( ma%mp(3) == 0 .and. mb%mp(3) == 0 ) .or.  &
          ( ma%mp(3) == 0 .and. mb%mp(1) < 0 )) then
          call fmunknown(mc)
          kflag = -4
          return
      endif
      if ((ma%mp(2) == munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc)
          kflag = -4
          return
      endif
      if (ma%mp(3) == 0) then
          call fmi2m(0, mc)
          return
      endif
      if (mb%mp(3) == 0) then
          call fmi2m(1, mc)
          return
      endif
      call fmovun_xexf(ma, xe, xf)
      call fmovun_xexf(mb, ye, yf)
      if (ma%mp(1) < 0 .and. mb%mp(2) == munkno) then
          m2 = 2
          if (ye <= ndig .or. mod(mbase, m2) /= 0) then
              call fmunknown(mc)
              return
          endif
      endif
      do j = 2, ndig+2
         mc%mp(j) = 0
      enddo
      mc%mp(1) = 1

      call fmovun_pwr2(ma, mb, mc, mxy, kl)
      if (ma%mp(1) < 0) then
          call fmovun_pwr3(mb, k)
          if (k == 0) then
              do i = 2, ndig
                 mc%mp(i+2) = 0
              enddo
              mc%mp(1) = 1
              mc%mp(2) = munkno
              mc%mp(3) = 1
              kflag = -4
          else if (k == 1) then
              mc%mp(1) = -1
          endif
      endif

      if (mb%mp(1) < 0) then
          call fmi2m(1, mxy(1))
          call fmdiv_r2(mxy(1), mc)
      endif

      if (kl /= 1 .and. kround /= 1) then
          call fmi2m(1, mxy(1))
          call fmabs(mc, mxy(2))
          if (fmcomp(mxy(1), '==', mxy(2))) then
              call fmtiny(mxy(2))
              call fmovun_xexf(ma, xe, xf)
              if (xe >= 1 .and. mb%mp(1) > 0) then
                  call fmadd(mxy(1), mxy(2), mc)
              else if (xe >= 1 .and. mb%mp(1) < 0) then
                  call fmsub(mxy(1), mxy(2), mc)
              else if (ma%mp(1) > 0 .and. mb%mp(1) > 0) then
                  call fmsub(mxy(1), mxy(2), mc)
              else if (ma%mp(1) > 0 .and. mb%mp(1) < 0) then
                  call fmadd(mxy(1), mxy(2), mc)
              else
                  call fmunknown(mc)
                  kflag = -4
              endif
          endif
      endif
      end subroutine fmovun_pwr

      subroutine fmovun_pwr2(ma, mb, mc, mxy, kl)

!  Return  mc = abs(ma) ** abs(mb)

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      type(multi) :: mxy(3)
      integer :: kl
      intent (in) :: ma, mb
      intent (inout) :: mc, mxy, kl

      integer :: k
      double precision :: alg, b, d, t, ue, uf, xe, xf, ye, yf, z1, z2
      logical, external :: fmcomp

      b = mbase
      if (ma%mp(2) == 1 .and. ma%mp(3) == 1) then
          call fmi2m(1, mxy(1))
          call fmabs(ma, mxy(2))
          if (fmcomp(mxy(1), '==', mxy(2))) then
              call fmi2m(1, mc)
              kl = 1
              return
          endif
      endif
      if (mb%mp(2) == 1 .and. mb%mp(3) == 1) then
          call fmi2m(1, mxy(1))
          call fmabs(mb, mxy(2))
          if (fmcomp(mxy(1), '==', mxy(2))) then
              call fmeq(ma, mc)
              return
          endif
      endif
      call fmovun_xe(ma, xe)
      if (xe > 0) then
          call fmabs(ma, mxy(1))
      else
          call fmi2m(1, mxy(1))
          call fmdiv(mxy(1), ma, mxy(2))
          call fmabs(mxy(2), mxy(1))
      endif
      call fmi2m(1, mxy(2))
      call fmsub_r2(mxy(1), mxy(2))
      call fmm2dp(mxy(2), t)
      if (kflag == -10) then
          alg = tiny(t) * 10.0d8
      else if (abs(t) < 1.0e-3) then
          alg = t
          do k = 1, 20
             if (k > log(epsilon(t)*(k+1)) / log(t)) exit
             alg = alg + (-1)**k * t**(k+1)/(k+1)
          enddo
      else
          call fmovun_xexf(mxy(1), xe, xf)
          alg = xe + log(xf) / log(b)
      endif
      call fmovun_xexf(mb, ye, yf)
      z1 = ye + log(yf)/log(b) + log(alg)/log(b)
      if (huge(mbase)/mexpov > 1.0d+20) then
          d = 1.0d+10
      else
          d = 4
      endif
      z2 = log(huge(mbase)/d)/log(b)
      if (abs(z1) >= z2) then
          if (z1 > 0) then
              call fmovun_xe(ma, xe)
              if (xe > 0) then
                  call fmoverflow(1, mc)
                  mc%mp(4) = huge(mbase)/d
                  kflag = -5
              else
                  call fmunderflow(1, mc)
                  mc%mp(4) = -huge(mbase)/d
                  kflag = -6
              endif
              mc%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
          else
              call fmi2m(1, mc)
          endif
          return
      endif
      if (z1 < -ndig) then
          call fmi2m(1, mc)
          return
      endif
      ue = b**ye * yf * alg
      if (ue == ue + 1) then
          uf = 1.0d0 - epsilon(1.0d0)
      else
          z1 = aint(ue)
          if (ue - z1 == 0) then
              ue = z1 + 1
              uf = 1/b
          else
              z1 = z1 + 1
              uf = b**( ue - z1 )
              ue = z1
          endif
      endif
      if (uf == 0) then
          ue = ue + 1
          uf = 1/b
      endif
      call fmovun_xe(ma, xe)
      if (xe <= 0) then
          ue = -ue + 1
          uf = (1.0d0/uf)/b
      endif
      if (ue > mxexp0+1) then
          call fmoverflow(1, mc)
          kflag = -5
      else if (ue < -mxexp0) then
          call fmunderflow(1, mc)
          kflag = -6
      else
          call fmunknown(mc)
          kflag = -4
      endif
      mc%mp(4) = ue
      mc%mp(5) = -maxint * uf

      return
      end subroutine fmovun_pwr2

      subroutine fmovun_pwr3(mb, k)

!  Return  k  as a code for determining the sign of ma**mb.

      use fmvals
      implicit none

      type(multi) :: mb
      integer :: k
      intent (in) :: mb
      intent (inout) :: k

      integer :: i, km, l, lb, lmb
      double precision :: ye

      k = 0
      call fmovun_xe(mb, ye)
      if (ye <= 0) then
          return
      else if (ye <= ndig) then
          l = ye + 2
          do i = l+1, ndig+2
             if (mb%mp(i) /= 0) then
                 k = 0
                 return
             endif
          enddo
          lb = mbase
          lmb = mb%mp(l)
          if (mod(lb, 2) == 0) then
              if (mod(lmb, 2) == 0) then
                  k = 2
                  return
              else
                  k = 1
                  return
              endif
          else
              km = 0
              do i = 3, l
                 lmb = mb%mp(i)
                 km = km + mod(lmb, 2)
              enddo
              k = 2 - mod(km, 2)
              return
          endif
      else if (ye > ndig) then
          l = ndig + 2
          lb = mbase
          lmb = mb%mp(l)
          if (mod(lb, 2) == 0) then
              k = 2
              return
          else
              km = 0
              do i = 3, l
                 lmb = mb%mp(i)
                 km = km + mod(lmb, 2)
              enddo
              k = 2 - mod(km, 2)
              return
          endif
      endif

      end subroutine fmovun_pwr3

      subroutine fmovun_rnd(ma, nd)

!  Internal routine for directed rounding of ma.

!  add nd to the last digit of ma and re-normalize. nd is plus or minus 1.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: nd
      intent (in) :: nd
      intent (inout) :: ma

      integer :: j

      ma%mp(ndig+2) = ma%mp(ndig+2) + nd

      if (ma%mp(ndig+2) >= mbase) then
          do j = ndig+1, 3, -1
             ma%mp(j+1) = ma%mp(j+1) - mbase
             ma%mp(j) = ma%mp(j) + 1
             if (ma%mp(j) < mbase) exit
          enddo
          if (ma%mp(3) >= mbase) then
              ma%mp(2) = ma%mp(2) + 1
              ma%mp(3) = 1
              do j = 4, ndig+2
                 ma%mp(j) = 0
              enddo
          endif
      else if (ma%mp(ndig+2) < 0) then
          do j = ndig+1, 3, -1
             ma%mp(j+1) = ma%mp(j+1) + mbase
             ma%mp(j) = ma%mp(j) - 1
             if (ma%mp(j) >= 0) exit
          enddo
          if (ma%mp(3) <= 0) then
              ma%mp(2) = ma%mp(2) - 1
              ma%mp(3) = 1
              do j = 3, ndig+2
                 ma%mp(j) = mbase - 1
              enddo
          endif
      endif
      if (ma%mp(2) < -mxexp) then
          ma%mp(4) = ma%mp(2)
          ma%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
          ma%mp(2) = mexpun
          ma%mp(3) = 1
      else if (ma%mp(2) > mxexp+1 .and. ma%mp(2) /= munkno) then
          ma%mp(4) = ma%mp(2)
          ma%mp(5) = -maxint * (1.0d0/mbase)
          ma%mp(2) = mexpov
          ma%mp(3) = 1
      endif

      end subroutine fmovun_rnd

      subroutine fmovun_sub(ma, mb, mc)

!  Internal subtraction routine.  mc = ma - mb

!  One or both arguments are overflow, underflow, or unknown, and this routine tries to track
!  exceptional operations for better error handling.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: j
      logical :: abs_ma_gt_abs_mb
      double precision :: xe, xf, ye, yf

      call fmalloc(mc, ndig+2)

      if ((ma%mp(2) == munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc)
          kflag = -4
          return
      endif
      kflag = 0
      if (ma%mp(3) == 0) then
          do j = 2, ndig+2
             mc%mp(j) = mb%mp(j)
          enddo
          mc%mp(1) = -mb%mp(1)
          if (mc%mp(2) == munkno .and. kflag /= 1) kflag = -4
          if (mc%mp(2) == mexpov .and. kflag /= 1) kflag = -5
          if (mc%mp(2) == mexpun .and. kflag /= 1) kflag = -6
          return
      endif
      if (mb%mp(3) == 0) then
          do j = 1, ndig+2
             mc%mp(j) = ma%mp(j)
          enddo
          kflag = 1
          return
      endif
      if (kround /= 1) then
          call fmovun_xexf(ma, xe, xf)
          call fmovun_xexf(mb, ye, yf)
          if (abs(ma%mp(2)) < mexpov .and. mb%mp(5) < 0) then
              if (xe > ye + ndig) then
                  do j = 1, ndig+2
                     mc%mp(j) = ma%mp(j)
                  enddo
                  if (ma%mp(1) > 0 .and. mb%mp(1) > 0) then
                      if (kround == 0 .or. kround == -1) call fmovun_rnd(mc, -1)
                  else if (ma%mp(1) < 0 .and. mb%mp(1) > 0) then
                      if (kround == -1) call fmovun_rnd(mc, 1)
                  else if (ma%mp(1) > 0 .and. mb%mp(1) < 0) then
                      if (kround == 2) call fmovun_rnd(mc, 1)
                  else if (ma%mp(1) < 0 .and. mb%mp(1) < 0) then
                      if (kround == 0 .or. kround == 2) call fmovun_rnd(mc, -1)
                  endif
                  kflag = 1
                  return
              endif
          endif

          if (abs(mb%mp(2)) < mexpov .and. ma%mp(5) < 0) then
              if (ye > xe + ndig) then
                  do j = 1, ndig+2
                     mc%mp(j) = mb%mp(j)
                  enddo
                  mc%mp(1) = -mb%mp(1)
                  if (mc%mp(1) > 0 .and. ma%mp(1) > 0) then
                      if (kround == 2) call fmovun_rnd(mc, 1)
                  else if (mc%mp(1) < 0 .and. ma%mp(1) > 0) then
                      if (kround == 0 .or. kround == 2) call fmovun_rnd(mc, -1)
                  else if (mc%mp(1) > 0 .and. ma%mp(1) < 0) then
                      if (kround == -1 .or. kround == 0) call fmovun_rnd(mc, -1)
                  else if (mc%mp(1) < 0 .and. ma%mp(1) < 0) then
                      if (kround == -1) call fmovun_rnd(mc, 1)
                  endif
                  if (mc%mp(2) == munkno .and. kflag /= 1) kflag = -4
                  if (mc%mp(2) == mexpov .and. kflag /= 1) kflag = -5
                  if (mc%mp(2) == mexpun .and. kflag /= 1) kflag = -6
                  return
              endif
          endif
      endif
      do j = 2, ndig+2
         mc%mp(j) = 0
      enddo
      mc%mp(1) = 1

      abs_ma_gt_abs_mb = .true.
      call fmovun_xexf(ma, xe, xf)
      call fmovun_xexf(mb, ye, yf)
      if (ye > xe) then
          abs_ma_gt_abs_mb = .false.
      else if (ye == xe) then
          if (yf > xf) then
              abs_ma_gt_abs_mb = .false.
          endif
      endif

      if (abs_ma_gt_abs_mb) then
          if (ma%mp(1) > 0) then
              if (mb%mp(1) > 0) then
                  call fmovun_subp(ma, mb, mc)
                  mc%mp(1) = 1
              else
                  call fmovun_addp(ma, mb, mc)
                  mc%mp(1) = 1
              endif
          else
              if (mb%mp(1) > 0) then
                  call fmovun_addp(ma, mb, mc)
                  mc%mp(1) = -1
              else
                  call fmovun_subp(ma, mb, mc)
                  mc%mp(1) = -1
              endif
          endif
      else
          if (ma%mp(1) > 0) then
              if (mb%mp(1) > 0) then
                  call fmovun_subp(mb, ma, mc)
                  mc%mp(1) = -1
                  if (kflag == 1) kflag = 0
              else
                  call fmovun_addp(mb, ma, mc)
                  mc%mp(1) = 1
                  if (kflag == 1) kflag = 0
              endif
          else
              if (mb%mp(1) > 0) then
                  call fmovun_addp(mb, ma, mc)
                  mc%mp(1) = -1
                  if (kflag == 1) kflag = 0
              else
                  call fmovun_subp(mb, ma, mc)
                  mc%mp(1) = 1
                  if (kflag == 1) kflag = 0
              endif
          endif
      endif

      if (mc%mp(2) == munkno .and. kflag /= 1) kflag = -4
      if (mc%mp(2) == mexpov .and. kflag /= 1) kflag = -5
      if (mc%mp(2) == mexpun .and. kflag /= 1) kflag = -6

      return
      end subroutine fmovun_sub

      subroutine fmovun_subp(ma, mb, mc)

!  Internal subtraction routine.  mc = ma - mb

!  The arguments are such that abs(ma) >= abs(mb) and both ma and mb are treated as positive,
!  meaning the sign bits are ignored.

!  One or both arguments are overflow, underflow, or unknown, and this routine tries to track
!  exceptional operations for better error handling.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: j, k
      double precision :: b, d, xe, xf, ye, yf, ze, zf

      call fmovun_xexf(ma, xe, xf)
      call fmovun_xexf(mb, ye, yf)


      if (xe-ye > ndig) then
          do j = 1, ndig+2
             mc%mp(j) = ma%mp(j)
          enddo
          kflag = 1
          return
      endif
      b = mbase
      if (xe == ye .and. xf == yf .and.  &
          (abs(ma%mp(2)) >= mexpov .or. abs(mb%mp(2)) >= mexpov)) then
          ze = 0
          zf = 0
          call fmunknown(mc)
          kflag = -4
          return
      else if (ye-xe < log(epsilon(b)/b) / log(b)) then
          ze = xe
          zf = xf
      else
          ze = xe
          zf = xf - yf*b**(ye-xe)
      endif
      if (zf > 0 .and. zf < 1.0d0/b) then
          k = -log(epsilon(b)/b)/log(b) + 1
          do j = 1, k
             ze = ze - 1
             zf = zf * b
             if (zf >= 1.0d0/b) exit
          enddo
      endif
      if (huge(mbase)/mexpov > 1.0d+20) then
          d = 1.0d+10
      else
          d = 4
      endif
      if (ze > huge(mbase)/d) then
          ze = huge(mbase)/d
          zf = 1.0d0 - epsilon(1.0d0)
      else if (ze < -huge(mbase)/d) then
          ze = -huge(mbase)/d
          zf = 1.0d0 - epsilon(1.0d0)
      else if (ze == ze + 1.0d0) then
          zf = 1.0d0 - epsilon(1.0d0)
      endif
      mc%mp(4) = ze
      if (zf == 0) zf = 1.0d0 / b
      mc%mp(5) = -zf*maxint
      if (mc%mp(4) >= -mxexp0 .and. mc%mp(4) <= mxexp0+1) then
          mc%mp(1) = 1
          mc%mp(2) = munkno
          mc%mp(3) = 1
          do j = 4, ndig
             mc%mp(j+2) = 0
          enddo
          kflag = -4
          return
      else if (mc%mp(4) < -mxexp0) then
          mc%mp(2) = mexpun
          kflag = -6
      else if (mc%mp(4) > mxexp0+1) then
          mc%mp(2) = mexpov
          kflag = -5
      endif
      mc%mp(3) = 1

      return
      end subroutine fmovun_subp

      subroutine fmovun_xe(ma, xe)

!  Return the over/underflow/unknown tracking exponent of ma in xe.

      use fmvals
      implicit none

      type(multi) :: ma
      double precision :: xe
      intent (in) :: ma
      intent (inout) :: xe

      if (abs(ma%mp(2)) >= mexpov) then
          xe = ma%mp(4)
      else
          xe = ma%mp(2)
      endif

      end subroutine fmovun_xe

      subroutine fmovun_xexf(ma, xe, xf)

!  Return the over/underflow/unknown tracking information of ma in xe, xf.

      use fmvals
      implicit none

      type(multi) :: ma
      double precision :: xe, xf
      intent (in) :: ma
      intent (inout) :: xe, xf

      double precision :: d

      if (ma%mp(3) == 0) then
          if (huge(mbase)/mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          xe = -huge(mbase)/d
          xf = 1.0d0 - epsilon(1.0d0)
      else if (abs(ma%mp(2)) >= mexpov) then
          xe = ma%mp(4)
          xf = ma%mp(5)
          if (xf >= 0) xf = 1.0d0 / mbase
          xf = -xf/maxint
      else
          xe = ma%mp(2)
          call fmovun_frac(ma, xf)
      endif

      end subroutine fmovun_xexf

      subroutine fmpack(ma, mp)

!  ma is packed two base mbase digits per word and returned in mp.

      use fmvals
      implicit none

      type(multi) :: ma, mp
      intent (in) :: ma
      intent (inout) :: mp

      integer :: j, kp

      call fmalloc(mp, ndig/2+4)

      if (abs(ma%mp(2)) >= mexpov) then
          do j = 1, 5
             mp%mp(j) = ma%mp(j)
          enddo
          do j = 6, ndig/2+4
             mp%mp(j) = 0
          enddo
          return
      endif

      kp = 2
      mp%mp(1) = ma%mp(1)
      mp%mp(2) = ma%mp(2)
      mp%mp(3) = abs(ma%mp(3))*mbase + ma%mp(4)
      if (ndig >= 4) then
          do j = 4, ndig, 2
             kp = kp + 1
             mp%mp(kp+1) = ma%mp(j+1)*mbase + ma%mp(j+2)
          enddo
      endif
      if (mod(ndig, 2) == 1) mp%mp(kp+2) = ma%mp(ndig+2)*mbase

      return
      end subroutine fmpack

      subroutine fmpgam(n, ma, mb)

!  mb = polygamma(n,ma)      (nth derivative of psi)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: n
      intent (in) :: n, ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, numtry, n_acc
      logical :: retry
      type(multi), save :: mxy(13), mresult, mretry

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmpgam_sc(n, ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fmpgam_m1(n, ma, mxy, mresult, ndsave, retry, n_acc)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmpgam

      subroutine fmpgam_m1(n, ma, mxy, mresult, ndsave, retry, n_acc)

!  Method 1 for computing polygamma(n,ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: n, ndsave, n_acc
      logical :: retry
      intent (in) :: n, ma, ndsave
      intent (inout) :: mxy, mresult, retry, n_acc

      double precision :: xe
      integer :: iextra, inta, j, j2, jn, jnc, jstart, k, kfl, kl, krflct, krsave,  &
                 kwrnsv, lshift, n1, nbot, nc, ndig2, ndsav1, ndsv2, nmxdif, nterm, ntop

!             Set the coefficients used in computing various derivatives of cot(pi*x)
!             for the reflection formula.

      integer :: kgcd(14) = (/ 1, 2, 2, 8, 8, 16, 16, 128, 128, 256, 256, 1024, 1024, 2048 /)
      integer :: kcoeff(56) = (/                                                            &
                           1,        1,                     3, 1,               3, 2,       &
                          15,  15,   2,                    45,  60, 17,                     &
                         315, 525, 231, 17,               315, 630, 378, 62,                &
                        2835,      6615,      5040,      1320,       62,                    &
                       14175,     37800,     34965,     12720,     1382,                    &
                      155925,    467775,    509355,    238425,    42306,     1382,          &
                      467775,   1559250,   1954260,   1121670,   280731,    21844,          &
                     6081075,  22297275,  31621590,  21531510,  7012005,   907725,  21844,  &
                    42567525, 170270100, 269594325, 212612400, 85630545, 15839460, 929569 /)
      type(multi), save :: mjsums(ljsums)
      logical, external :: fmcomp

      call fmequ(ma, mxy(1), ndsave, ndig)
      call fmeq(mxy(1), mxy(13))
      n_acc = nint(ndig*alogm2)
      retry = .true.

      if (n == 0) then
          call fmpsi(mxy(1), mresult)
          return
      endif
      if (n < 0 .or. ma%mp(3) == 0) then
          call fmunknown(mresult)
          kflag = -4
          retry = .false.
          return
      endif

!             Near zero pgam(x) is about n!/(-x)**(n+1).

      call fmovun_xe(mxy(13), xe)
      if (xe < (-ndig-1)) then
          call fmfcti(n, mxy(12))
          call fmnegate(mxy(13))
          call fmipwr(mxy(13), n+1, mxy(11))
          call fmdiv(mxy(12), mxy(11), mresult)
          return
      endif

!             Check for special cases.

      krflct = 0
      call fmdp2m(-0.5d0, mxy(5))
      if (fmcomp(mxy(13), '<=', mxy(5))) then
          krflct = 1
          kfl = 0
          call fmovun_xe(ma, xe)
          if (xe <= ndsave) then
              call fmint(mxy(13), mxy(9))
              if (fmcomp(mxy(13), '==', mxy(9))) kfl = -4
          else
              kfl = -4
          endif
          if (kfl /= 0) then
              call fmunknown(mresult)
              kflag = -4
              retry = .false.
              return
          else
              call fmi2m(1, mxy(4))
              call fmsub_r2(mxy(4), mxy(13))
          endif
      endif
      call fmovun_xe(ma, xe)
      if (xe > ndig+3) then
          call fmipwr(mxy(13), -n, mxy(10))
          call fmfcti(n-1, mxy(9))
          call fmmpy_r1(mxy(10), mxy(9))
          if (mod(n-1, 2) == 1) call fmnegate(mxy(10))
          if (kround /= 1) then
              if (mxy(10)%mp(2) /= mexpun) then
                  call fmmpyi(mxy(10), n, mxy(4))
                  call fmdivi_r1(mxy(4), 2)
                  call fmdiv_r1(mxy(4), mxy(13))
                  call fmadd_r1(mxy(10), mxy(4))
              endif
          endif
          call fmeq(mxy(10), mresult)
          return
      endif

!             To speed the asymptotic series calculation, increase the argument by lshift.

      iextra = 0
      kwrnsv = kwarn
      kwarn = 0
      call fmm2i(mxy(13), inta)
      kwarn = kwrnsv

      if (kflag == -4) then
          lshift = 0
      else
          lshift = max(0, int(real(ndig)*alogmb/4.46-real(inta)))
          lshift = lshift + (7*n)/20
      endif
      if (lshift > 0) lshift = 4*(lshift/4 + 1)

      if (lshift /= 0) then
          call fmi2m(lshift, mxy(4))
          call fmadd(mxy(13), mxy(4), mxy(12))
      else
          call fmeq(mxy(13), mxy(12))
      endif

!             Sum the asymptotic series.

      j2 = int(0.3*alogmb + 0.2*sqrt(real(ndig)))
      j2 = max(1, min(ljsums, j2))

!             mxy(13) is z
!             mxy(12) is z + lshift
!             mxy(9) is x**j2 = (1/(z+lshift)**2)**j2
!             mxy(10) is the current power of x times the quotient of factorials in each term
!             mxy(11) is the current term in the sum
!             mxy(8) is (n+1)!
!             mjsums holds the partial sums

      ndsav1 = ndig
      call fmfcti(n+1, mxy(8))
      call fmdivi(mxy(8), 2, mxy(10))
      j = -2*j2
      call fmipwr(mxy(12), j, mxy(9))
      call fmovun_xe(mxy(9), xe)
      if (abs(xe) >= mexpab) then
          j2 = 1
          call fmipwr(mxy(12), -2, mxy(9))
      endif

      nterm = 2
      do j = 1, j2
         nterm = 2*j
         call fmbern(nterm, mxy(10), mjsums(j))
         if (kflag == -11) then
             call fmunknown(mresult)
             kflag = -4
             retry = .false.
             return
         endif
         ntop = (n+nterm)*(n+nterm+1)
         call fmcsmpyi_r1(mxy(10), ntop)
         nbot = (nterm+1)*(nterm+2)
         call fmcsdivi_r1(mxy(10), nbot)
      enddo

      ndig2 = ndig
      kl = 1
      do while (kl == 1)
         call fmcsmpy_r1(mxy(10), mxy(9))
         nmxdif = min(ndsav1, ngrd22)
         do j = 1, j2
            nterm = nterm + 2
            call fmbern(nterm, mxy(10), mxy(11))
            if (kflag == -11) then
                call fmunknown(mresult)
                kflag = -4
                retry = .false.
                return
            endif
            ndig = ndsav1
            call fmcsadd_r1(mjsums(j), mxy(11))
            if (kflag /= 0) then
                kl = 0
                exit
            else
                nmxdif = max(nmxdif, ndsav1-int(mjsums(j)%mp(2)-mxy(11)%mp(2)))
                ndig = ndig2
                if (n+nterm > intmax/(n+nterm+1) .or. n+nterm > mxbase/(n+nterm+1)) then
                    call fmcsmpyi_r1(mxy(10), n+nterm)
                    call fmcsmpyi_r1(mxy(10), n+nterm+1)
                    call fmcsdivi_r1(mxy(10), nterm+1)
                    call fmcsdivi_r1(mxy(10), nterm+2)
                else
                    ntop = (n+nterm)*(n+nterm+1)
                    call fmcsmpyi_r1(mxy(10), ntop)
                    nbot = (nterm+1)*(nterm+2)
                    call fmcsdivi_r1(mxy(10), nbot)
                endif
            endif
         enddo
         if (kl == 0) exit
         ndig2 = nmxdif
         ndig = ndig2
      enddo

!             Put the j2 concurrent sums back together.

      ndig = ndsav1
      if (j2 > 1) then
          call fmi2m(1, mxy(9))
          call fmsqr(mxy(12), mxy(11))
          call fmdiv_r2(mxy(9), mxy(11))
          call fmeq(mjsums(j2), mxy(9))
          do j = j2-1, 1, -1
             call fmmpy_r1(mxy(9), mxy(11))
             call fmadd_r1(mxy(9), mjsums(j))
          enddo
          call fmeq(mxy(9), mjsums(1))
      endif
      call fmipwr(mxy(12), n+2, mxy(6))
      call fmdiv_r1(mjsums(1), mxy(6))

!             Add the initial terms to the asymptotic series.

      call fmdivi(mxy(8), n+1, mxy(9))
      call fmdivi(mxy(9), n, mxy(8))
      call fmmpyi(mxy(12), 2, mxy(7))
      call fmi2m(n, mxy(10))
      call fmadd(mxy(7), mxy(10), mxy(3))
      call fmcancel(mxy(7), mxy(10), mxy(3), k)
      n_acc = n_acc - k
      call fmeq(mxy(3), mxy(7))
      call fmmpy_r1(mxy(7), mxy(8))
      call fmmpyi_r1(mxy(6), 2)
      call fmdiv_r1(mxy(6), mxy(12))
      call fmdiv(mxy(7), mxy(6), mxy(10))
      call fmadd(mjsums(1), mxy(10), mxy(3))
      call fmcancel(mjsums(1), mxy(10), mxy(3), k)
      n_acc = n_acc - k
      call fmeq(mxy(3), mxy(10))
      if (mod(n-1, 2) == 1) call fmnegate(mxy(10))

!             Now pgam of the shifted argument has been computed.  Reverse the shifting.
!             The sum 1/(ma)**(n+1) + ... + 1/(ma+lshift-1)**(n+1) is computed.

!             mxy(13) is z
!             mxy(9) is n!
!             mxy(10) is the sum of the asymptotic series
!             mxy(11) is the sum 1/(ma)**(n+1) + ... + 1/(ma+lshift-1)**(n+1)

      if (lshift > 0) then
          call fmi2m(1, mxy(6))
          call fmeq(mxy(13), mxy(7))
          n1 = -(n + 1)
          call fmipwr(mxy(7), n1, mxy(11))
          do k = 1, lshift-1
             call fmadd_r1(mxy(7), mxy(6))
             call fmipwr(mxy(7), n1, mxy(12))
             call fmadd_r1(mxy(11), mxy(12))
          enddo
          call fmmpy_r2(mxy(9), mxy(11))
          if (mod(n+1, 2) == 1) call fmnegate(mxy(11))
          call fmadd(mxy(10), mxy(11), mxy(3))
          call fmcancel(mxy(10), mxy(11), mxy(3), k)
          n_acc = n_acc - k
          call fmeq(mxy(3), mxy(10))
      endif

!             Use the reflection formula if ma was less than -1/2.

      if (krflct == 1) then

!             mxy(11) is cot(Pi*z)
!             mxy(9) is mxy(11)**2

!             Reduce the argument before multiplying by Pi.

          call fmmpyi(mxy(13), 2, mxy(5))
          call fmint(mxy(5), mxy(9))
          if (fmcomp(mxy(5), '==', mxy(9))) then
              call fmi2m(0, mxy(11))
              call fmeq(mxy(11), mxy(9))
              call fmi2m(1, mxy(5))
          else
              call fmnint(mxy(13), mxy(5))
              call fmsub(mxy(13), mxy(5), mxy(9))
              ndsv2 = ndig

              kl = 1
              do while (kl == 1)
                 call fmpi(mxy(11))
                 call fmmpy_r1(mxy(11), mxy(9))
                 krsave = krad
                 krad = 1
                 call fmtan(mxy(11), mxy(2))
                 call fmeq(mxy(2), mxy(11))
                 krad = krsave
                 if ((mxy(11)%mp(2) < 0 .or. mxy(11)%mp(2) > 1) .and.  &
                     ndsv2 == ndig) then
                     iextra = int(max(-mxy(11)%mp(2), mxy(11)%mp(2)))
                     if (abs(mxy(11)%mp(2)) >= mexpov) iextra = 0
                     if (iextra > 0) then
                         call fmequ_r1(mxy(9), ndig, ndig+iextra)
                         ndig = ndig + iextra
                         cycle
                     else
                         kl = 0
                     endif
                 else
                     exit
                 endif
              enddo

              ndig = ndsv2
              call fmi2m(1, mxy(5))
              call fmdiv_r2(mxy(5), mxy(11))
              call fmsqr(mxy(11), mxy(9))
          endif
          nc = (n+1)/2

!             For n up to 14, use the stored coefficients to compute the Nth derivative
!             of Cot(Pi*z).  For larger n, the coefficients are generated from a recurrence
!             relation and stored as FM numbers.

          if (n <= 14) then
              jstart = (n*n + 4 - mod(n, 2))/4
              if (n <= 2) then
                  call fmi2m(1, mxy(6))
              else
                  call fmmpyi(mxy(9), kcoeff(jstart), mxy(6))
              endif
              do j = 2, nc
                 call fmi2m(kcoeff(jstart+j-1), mxy(7))
                 call fmadd_r1(mxy(6), mxy(7))
                 if (j < nc) call fmmpy_r1(mxy(6), mxy(9))
              enddo
              if (mod(n, 2) == 0) call fmmpy_r1(mxy(6), mxy(11))
              if (n > 1) call fmmpyi_r1(mxy(6), kgcd(n))
          else
              if (nc > ljsums) then
                  kflag = -12
                  write (kw,                                                         &
                         "(' For PGAM(', I5, ',*) with NDIG =', I5, ', ', I7, "  //  &
                         "' elements are needed'/' in array MJSUMS.', "          //  &
                         "'  The current dimension of MJSUMS IS', I7/)"              &
                        ) n, ndig, nc*(ndig+3), ljsums
                  call fmunknown(mresult)
                  return
              endif

              do j = 1, 7
                 call fmi2m(kcoeff(j+49), mjsums(j))
                 call fmmpyi_r1(mjsums(j), kgcd(14))
              enddo
              do jn = 15, n
                 jnc = (jn+1)/2
                 do k = jnc, 2, -1
                    if (k == jnc .and. mod(jn, 2) == 1) then
                        call fmeq(mjsums(k-1), mjsums(k))
                    else
                        call fmadd_r2(mjsums(k-1), mjsums(k))
                        call fmmpyi_r1(mjsums(k), jn-2*(k-1))
                    endif
                 enddo
                 call fmmpyi_r1(mjsums(1), jn)
              enddo

!             mjsums now has the coefficients needed for the polynomial in Cot**2 that defines
!             the Nth derivative of Cot.

              call fmeq(mjsums(1), mxy(6))
              do j = 2, nc
                 call fmmpy_r1(mxy(6), mxy(9))
                 call fmadd_r1(mxy(6), mjsums(j))
              enddo
              if (mod(n, 2) == 0) call fmmpy_r1(mxy(6), mxy(11))
          endif

!             To complete the calculation of the nth derivative of cot, multiply the polynomial
!             in cot**2 by csc**2.

          call fmadd(mxy(9), mxy(5), mxy(7))
          call fmmpy_r1(mxy(6), mxy(7))

          call fmpi(mxy(5))
          call fmipwr(mxy(5), n+1, mxy(7))
          call fmmpy_r1(mxy(6), mxy(7))
          if (mod(n, 2) == 1) call fmnegate(mxy(10))
          call fmadd(mxy(10), mxy(6), mxy(3))
          call fmcancel(mxy(10), mxy(6), mxy(3), k)
          n_acc = n_acc - k
          call fmeq(mxy(3), mxy(10))
      endif

      call fmeq(mxy(10), mresult)

      return
      end subroutine fmpgam_m1

      subroutine fmpgam_sc(n, ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = polygamma(n,ma).

!  kresult = 1 is returned if a special case gives the value of polygamma(n,ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: n, kresult, ndsave
      intent (in) :: n, ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      double precision :: xe, ye
      integer :: j, k, krsave, nds
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMPGAM   '
      j = ndig
      ndig = ndsave
      call fmntr_inpi1(n, ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      if (n == 0) then
          call fmpsi(malocal, mresult)
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (kround /= 1 .and. n >= 0) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          krsave = kround
          kround = 1
          nds = ndig
          ndig = ndig + ngrd52
          call fmequ(malocal, mxy(1), nds, ndig)
          call fmi2m(0, mxy(2))
          call fmsub(mxy(2), mxy(1), mxy(3))
          call fmipwr(mxy(3), -n-1, mxy(4))
          if (n >= 2) then
              call fmi2m(n, mxy(6))
              call fmfact(mxy(6), mxy(7))
              call fmmpy_r1(mxy(4), mxy(7))
          endif
          if (mod(n, 2) == 1) then
              call fmi2m(1, mxy(2))
              call fmbern(n+1, mxy(2), mxy(3))
              call fmabs(mxy(3), mxy(6))
              call fmpi(mxy(7))
              call fmipwr(mxy(7), n+1, mxy(8))
              call fmmpy(mxy(6), mxy(8), mxy(7))
              call fmi2m(2, mxy(2))
              call fmipwr(mxy(2), n-1, mxy(6))
              call fmmpy(mxy(6), mxy(7), mxy(8))
              call fmdivi(mxy(8), (n+1)/2, mxy(5))
          else
              call fmi2m(1, mxy(2))
              call fmbern(n, mxy(2), mxy(3))
              call fmabs(mxy(3), mxy(6))
              call fmpi(mxy(7))
              call fmipwr(mxy(7), n, mxy(8))
              call fmmpy(mxy(6), mxy(8), mxy(7))
              call fmi2m(2, mxy(2))
              call fmipwr(mxy(2), n-2, mxy(6))
              call fmmpy(mxy(6), mxy(7), mxy(8))
              call fmdivi(mxy(8), n/2, mxy(10))
              call fmi2m(1, mxy(2))
              call fmbern(n+2, mxy(2), mxy(3))
              call fmabs(mxy(3), mxy(6))
              call fmpi(mxy(7))
              call fmipwr(mxy(7), n+2, mxy(8))
              call fmmpy(mxy(6), mxy(8), mxy(7))
              call fmi2m(2, mxy(2))
              call fmipwr(mxy(2), n, mxy(6))
              call fmmpy(mxy(6), mxy(7), mxy(8))
              call fmdivi(mxy(8), (n+2)/2, mxy(11))
              call fmmpy(mxy(10), mxy(11), mxy(9))
              call fmsqrt(mxy(9), mxy(10))
              call fmi2m(0, mxy(8))
              call fmsub(mxy(8), mxy(10), mxy(5))
          endif
          call fmovun_xe(mxy(4), xe)
          call fmovun_xe(mxy(5), ye)
          if (xe - ye > ndsave+1 .and. abs(mxy(4)%mp(2)) < mexpov .and.  &
              abs(mxy(5)%mp(2)) < mexpov) then
              call fmequ(mxy(4), mxy(6), ndig, nds)
              call fmequ(mxy(6), mxy(8), nds, ndig)
              call fmsub(mxy(4), mxy(8), mxy(6))
              if (mxy(6)%mp(3) == 0) then
                  call fmequ(mxy(4), mxy(6), ndig, nds)
                  call fmequ(mxy(5), mxy(7), ndig, nds)
                  ndig = nds
                  kround = krsave
                  call fmadd(mxy(6), mxy(7), mresult)
              else
                  kround = krsave
                  call fmequ(mxy(4), mresult, ndig, nds)
              endif
              if (kflag == 1) kflag = 0
              ntrace = j
              kwarn = k
              ndig = nds
              kround = krsave
              kresult = 1
              return
          endif
          kflag = 0
          ntrace = j
          kwarn = k
          ndig = nds
          kround = krsave
      endif

      return
      end subroutine fmpgam_sc

      subroutine fmpi(ma)

!  ma = pi

      use fmvals
      implicit none

      type(multi) :: ma
      intent (inout) :: ma

      character(155) :: string
      character :: st2(155)
      integer :: j, k, ndmb, ndsave, ndsv
      type(multi), save :: mxy(1)

      call fmalloc(ma, ndig+2)

      if (mblogs /= mbase) call fmcons
      kflag = 0
      ncall = ncall + 1
      namest(ncall) = 'FMPI'
      if (abs(ntrace) >= 2 .and. ncall <= lvltrc) then
          write (kw, "(' Input to FMPI')")
      endif

!             Increase the working precision.

      ndsave = ndig
      if (ncall == 1) then
          k = ngrd52
          ndig = max(ndig+k, 3)
      endif

!             Check to see if pi has previously been computed in base mbase with
!             sufficient precision.

      if (mbspi == mbase .and. ndigpi >= ndig) then
          call fmequ(mpisav, ma, ndigpi, ndsave)
      else
          ndmb = int(150.0*2.302585/alogmb)
          if (ndmb >= ndig) then
              ndsv = ndig
              ndig = ndmb
              string = '3.141592653589793238462643383279502884197169'//  &
              '39937510582097494459230781640628620899862803482534211'//  &
              '7067982148086513282306647093844609550582231725359408128'
              k = min(int((ndig-1) * dlogmb / dlogtn + 3), len(string))
              do j = 1, k
                 st2(j) = string(j:j)
              enddo
              call fminp(st2, mpisav, 1, k)
              mbspi = mbase
              ndigpi = ndig
              if (abs(mpisav%mp(2)) > 10) ndigpi = 0
          else
              ndsv = ndig
              ndig = ndig + 2 + ndig/100
              call fmpi2(mxy(1))
              call fmeq(mxy(1), mpisav)
              mbspi = mbase
              ndigpi = ndig
              if (abs(mpisav%mp(2)) > 10) ndigpi = 0
          endif
          call fmequ(mpisav, ma, ndig, ndsave)
          ndig = ndsv
      endif

      ndig = ndsave
      if (ntrace /= 0) call fmntr_out1(ma)
      ncall = ncall - 1

      return
      end subroutine fmpi

      subroutine fmpi2(mpi)

!  Internal routine to compute pi.
!  The formula used is due to s. Ramanujan.  For low to moderate precision, this routine uses
!  the series
!                                                (4n)!(1103+26390n)
!  1/pi = (sqrt(8)/9801) * sum(n=0 to infinity) --------------------
!                                               ((n!)**4)(396**(4n))
!
!  For higher precision, see routine fmpi3.
!
!  The result is returned in mpi.

      use fmvals
      implicit none

      type(multi) :: mpi
      intent (inout) :: mpi

      double precision :: x
      real (kind(1.0d0)) :: mx
      integer :: nstack(49), j, k, kst, large, n, ndigrd, ndsave, nmethd
      type(multi), save :: mxy(4)

      call fmalloc(mpi, ndig+2)

!             Check for using binary splitting if precision is high.

      if (ndig >= 100) then
          nmethd = 2
      else
          nmethd = 1
      endif
      if (nmethd == 2) then
          call fmpi3(mpi)
          return
      endif

      if (mblogs /= mbase) call fmcons
      ndsave = ndig
      n = -1
      call fmi2m(1103, mpi)
      call fmi2m(0, mxy(1))
      call fmi2m(1, mxy(2))
      call fmi2m(26390, mxy(3))
      call fmi2m(1103, mxy(4))
      mx = mxbase**2/mbase
      if (mx > mxexp2) mx = mxexp2

      do
         n = n + 1
         large = int(mx)/(4*n + 3)
         j = 4*n + 1
         if (j > large) then
             call fmmpyi_r1(mxy(2), j)
             j = j + 1
             call fmmpyi_r1(mxy(2), j)
             j = j + 1
             call fmmpyi_r1(mxy(2), j)
         else if (j*(j+1) > large) then
             k = j*(j+1)
             call fmmpyi_r1(mxy(2), k)
             j = j + 2
             call fmmpyi_r1(mxy(2), j)
         else
             k = j*(j+1)*(j+2)
             call fmmpyi_r1(mxy(2), k)
         endif

         j = n + 1
         large = int(mxbase)/j
         if (j > large) then
             call fmdivi_r1(mxy(2), j)
             call fmdivi_r1(mxy(2), j)
             call fmdivi_r1(mxy(2), j)
         else if (j*j > large) then
             k = j*j
             call fmdivi_r1(mxy(2), k)
             call fmdivi_r1(mxy(2), j)
         else
             k = j*j*j
             call fmdivi_r1(mxy(2), k)
         endif

!             Break 4/396**4 into 1/(2178*2178*1296).

         j = 2178
         large = int(mxbase)/j
         if (j > large) then
             call fmdivi_r1(mxy(2), j)
             call fmdivi_r1(mxy(2), j)
             call fmdivi_r1(mxy(2), 1296)
         else
             k = j*j
             call fmdivi_r1(mxy(2), k)
             call fmdivi_r1(mxy(2), 1296)
         endif

         ndigrd = ndig
         ndig = ndsave
         call fmadd_r2(mxy(3), mxy(4))
         ndig = ndigrd
         call fmmpy(mxy(2), mxy(4), mxy(1))

         ndig = ndsave
         call fmadd_r1(mpi, mxy(1))
         ndig = max(ngrd22, ndsave - int(mpi%mp(2) - mxy(1)%mp(2)))
         if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         if (kflag == 1) exit
      enddo

      ndig = ndsave
      call fmi2m(8, mxy(2))
      x = 8
      x = sqrt(x)
      call fmdpm(x, mxy(4))
      call fmdig(nstack, kst)
      do j = 1, kst
         ndig = nstack(j)
         call fmdiv(mxy(2), mxy(4), mxy(1))
         call fmadd_r1(mxy(4), mxy(1))
         call fmdivi_r1(mxy(4), 2)
      enddo
      call fmi2m(9801, mxy(3))
      call fmmpy_r1(mpi, mxy(4))
      call fmdiv_r2(mxy(3), mpi)

      return
      end subroutine fmpi2

      subroutine fmpi3(mpi)
      use fmvals
      implicit none

!  Internal pi routine for very high precision.

!  The algorithm used is Chudnovskys' Ramanujan-style series with binary splitting.

!                                                  (-1)**n*(6n)!(13591409+545140134*n)
!  1/pi = (12/640320**(3/2)) * sum(n=0 to infinity) -----------------------------------
!                                                     (n!)**3*(3*n)!*(640320**(3n))
!  The result is returned in mpi.

      type(multi) :: mpi
      intent (inout) :: mpi

      integer :: k, level_of_recursion
      type(multi), save :: mxy(4)

      call fmalloc(mwa, 2*ndig+230)

!             Determine k, the number of terms to sum in the series for pi.

      k = ndig*dlogmb/3.2654441d+1 + 10
      level_of_recursion = 0
      call fmpi3_pqt(0, k, mxy(1), mxy(2), mxy(3), level_of_recursion)

      if (mxy(2)%mp(2) >= ndig .and. mxy(3)%mp(2) >= ndig) then
          call fmdiv(mxy(2), mxy(3), mxy(1))
          call fmi2m(640320, mxy(2))
          call fmsqrt(mxy(2), mxy(3))
          call fmmpyi_r1(mxy(3), 53360)
          call fmmpy(mxy(1), mxy(3), mpi)
      else
          if (mxy(2)%mp(2) >= ndig) then
              call fmeq(mxy(2), mxy(1))
          else
              call imi2fm(mxy(2), mxy(1))
          endif
          if (mxy(3)%mp(2) >= ndig) then
              call fmeq(mxy(3), mxy(4))
          else
              call imi2fm(mxy(3), mxy(4))
          endif
          call fmdiv(mxy(1), mxy(4), mxy(3))
          call fmi2m(640320, mxy(1))
          call fmsqrt(mxy(1), mxy(2))
          call fmmpyi_r1(mxy(2), 53360)
          call fmmpy(mxy(2), mxy(3), mpi)
      endif

      return
      end subroutine fmpi3

      recursive subroutine fmpi3_pqt(a, b, mp, mq, mt, level_of_recursion)

!  This routine does the binary splitting for computing the constant pi.

      use fmvals
      implicit none

      type(multi) :: mp, mq, mt
      integer :: a, b, level_of_recursion
      intent (in) :: a, b
      intent (inout) :: mp, mq, mt, level_of_recursion

      type(multi) :: mxy(6)
      integer :: j, ka, km, result_size
      real (kind(0.0d0)) :: da, db

      da = a
      db = b
      level_of_recursion = level_of_recursion + 1

      if (b-a < 10) then
          result_size = ( (db-da)*4.276666 + 3*( (db+0.5d0)*log(db+1) - db + 1/(12*(db+1)) -  &
                        ( (da+0.5d0)*log(da+1) - da + 1/(12*(da+1)) ) ) ) * 1.01 / dlogmb + 15
          result_size = max(5, result_size) + 5*log(dble(ndig))/dlogmb + 15
          call fmalloc(mp, result_size)
          result_size = ( (db-da)*36.93111 + 3*( (db+0.5d0)*log(db+1) - db + 1/(12*(db+1)) -  &
                        ( (da+0.5d0)*log(da+1) - da + 1/(12*(da+1)) ) ) ) * 1.01 / dlogmb + 15
          result_size = max(5, result_size) + 5*log(dble(ndig))/dlogmb + 15
          call fmalloc(mq, result_size)
          call fmalloc(mt, result_size)
          call fmalloc(mxy(1), result_size)
          call fmalloc(mxy(2), result_size)
          call fmalloc(mxy(3), result_size)
          call fmalloc(mxy(4), result_size)
          call fmalloc(mxy(5), result_size)
          call imi2m(1, mp)
          ka = a
          if (ka == 0) ka = 1
          do j = ka, b
             call immpyi(mp, -(6*j-5), mxy(2))
             call immpyi(mxy(2), 2*j-1, mxy(1))
             call immpyi(mxy(1), 6*j-1, mp)
          enddo

          call imi2m(640320, mxy(1))
          call imsqr(mxy(1), mxy(3))
          call immpy(mxy(3), mxy(1), mxy(2))
          call imdivi(mxy(2), 24, mxy(1))
          call imi2m(1, mq)
          do j = ka, b
             call immpyi(mq, j, mxy(3))
             call immpyi(mxy(3), j, mxy(2))
             call immpyi(mxy(2), j, mxy(3))
             call immpy(mxy(3), mxy(1), mq)
          enddo

          call imi2m(0, mt)
          if (a == 0) then
              call immpyi(mq, 13591409, mt)
          endif
          call imeq(mq, mxy(2))
          do j = ka, b
             call immpyi(mxy(2), -(6*j-5), mxy(3))
             call immpyi(mxy(3), 2*j-1, mxy(4))
             call immpyi(mxy(4), 6*j-1, mxy(2))
             call imdivi(mxy(2), j, mxy(3))
             call imdivi(mxy(3), j, mxy(4))
             call imdivi(mxy(4), j, mxy(3))
             call imdiv(mxy(3), mxy(1), mxy(2))
             call imi2m(545140134, mxy(3))
             call immpyi(mxy(3), j, mxy(4))
             call imi2m(13591409, mxy(3))
             call imadd(mxy(3), mxy(4), mxy(5))
             call immpy(mxy(2), mxy(5), mxy(3))
             call imadd(mt, mxy(3), mxy(4))
             call imeq(mxy(4), mt)
          enddo
      else
          km = a/2 + b/2 + mod(a, 2)*mod(b, 2)
          call fmpi3_pqt(a, km-1, mxy(1), mxy(2), mxy(3), level_of_recursion)
          call fmpi3_pqt(km, b, mxy(4), mxy(5), mxy(6), level_of_recursion)

!             mp is not needed in fmpi3, so this multiplication can be skipped at the top level
!             of the recursion.

          if (level_of_recursion > 1) then
              call im_or_fm_mpy(mxy(1), mxy(4), mp)
          else
              call imi2m(0, mp)
          endif
          call im_or_fm_mpy(mxy(2), mxy(5), mq)

          call im_or_fm_mpy(mxy(5), mxy(3), mxy(2))
          call im_or_fm_mpy(mxy(1), mxy(6), mxy(4))
          call im_or_fm_add(mxy(2), mxy(4), mt)
      endif

      level_of_recursion = level_of_recursion - 1

      return
      end subroutine fmpi3_pqt

      subroutine fmpoch(ma, n, mb)

!  mb = ma*(ma+1)*(ma+2)*...*(ma+n-1)       (pochhammer's symbol)

!  mb = gamma(ma+n)/gamma(ma)

!  For negative n, pochhammer(ma,n) = 1/pochhammer(ma+n,-n).


      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: n
      intent (in) :: ma, n
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(15), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmpoch_sc(ma, n, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call fmpoch_m1(ma, n, mxy, mresult, ndsave)
         if (n < 0) then
             call fmi2m(1, mxy(6))
             call fmdiv_r2(mxy(6), mresult)
         endif
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmpoch

      subroutine fmpoch_m1(ma, n, mxy, mresult, ndsave)

!  Method 1 for computing ma*(ma+1)*(ma+2)*...*(ma+n-1).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(15), mresult
      integer :: n, ndsave
      intent (in) :: ma, n, ndsave
      intent (inout) :: mxy, mresult

      real (kind(1.0d0)) :: ma2, mas, mbsign
      real :: t
      double precision :: xe
      integer :: iextra, j, jr, k, k0, k1, k2, klast, km08, kmb, lt, nt
      logical, external :: fmcomp

      call fmequ(ma, mxy(1), ndsave, ndig)

      ma2 = ma%mp(3)
      mas = ma%mp(1)
      nt = n
      call fmeq(mxy(1), mxy(13))

!             Check for special cases.

      iextra = 0
      if (n == 0) then
          call fmi2m(1, mresult)
          return
      endif
      if (nt < 0) then
          call fmaddi(mxy(1), nt)
          call fmeq(mxy(1), mxy(13))
          nt = -nt
          ma2 = mxy(1)%mp(3)
          mas = mxy(1)%mp(1)
      endif
      if (ma2 == 0) then
          if (nt > 0) then
              call fmi2m(0, mresult)
              return
          else
              call fmunknown(mresult)
              kflag = -4
              return
          endif
      endif
      if (nt == 0) then
          call fmi2m(1, mresult)
          return
      else if (nt == 1) then
          call fmeq(mxy(1), mresult)
          return
      endif
      call fmi2m(1, mxy(4))
      jr = kround
      kround = 1
      call fmadd(mxy(1), mxy(4), mxy(5))
      kround = jr
      if (fmcomp(mxy(5), '==', mxy(4))) then
          t = ndig
          j = int(15.21*sqrt(t)*alogmt + 42.87*sqrt(t) + 30.0)
          if (nt <= j) then
              k1 = nt - 1
              call fmfcti(k1, mresult)
              call fmmpy_r2(mxy(1), mresult)
              return
          endif
      endif

!             For large values of ma, the result is ma**nt.

      lt = ndig + 3 + int(2.0d0*log(dble(nt))/dlogmb)
      call fmovun_xe(mxy(1), xe)
      if (xe > lt) then
          call fmipwr(mxy(13), nt, mxy(11))
          if (kround /= 1 .and. nt > 1) then
              if (abs(mxy(11)%mp(2)) /= mexpov) then
                  call fmdiv(mxy(11), mxy(13), mxy(8))
                  if (mod(nt, 2) == 0) then
                      call fmmpyi_r1(mxy(8), nt-1)
                      call fmmpyi_r1(mxy(8), nt/2)
                  else
                      call fmmpyi_r1(mxy(8), (nt-1)/2)
                      call fmmpyi_r1(mxy(8), nt)
                  endif
                  call fmadd_r1(mxy(11), mxy(8))
              endif
          endif
          call fmeq(mxy(11), mresult)
          return
      endif

      mbsign = 1
      if (mas < 0) then
          call fmint(mxy(13), mxy(8))
          call fmi2m(nt, mxy(9))
          jr = kround
          kround = 1
          call fmadd(mxy(13), mxy(9), mxy(10))
          kround = jr
          if (fmcomp(mxy(13), '==', mxy(8))) then

!                  If ma is a negative integer and ma+nt is positive, then the result is zero.

              if (mxy(10)%mp(1)*mxy(10)%mp(3) > 0) then
                  call fmi2m(0, mresult)
                  return
              endif
          endif

!                  If ma is negative and ma+nt-1 is negative, then use the reflection formula
!                  Pochhammer(ma,nt) = (-1)**nt*Pochhammer(-ma-(nt-1),nt).

          call fmi2m(1, mxy(11))
          if (fmcomp(mxy(10), '<', mxy(11))) then

!                 Extra guard digits may be required to insure the reflection formula is accurate.

              iextra = max(int(mxy(13)%mp(2)), iextra)
              if (abs(mxy(13)%mp(2)) >= mexpov) iextra = 0
              if (iextra > 0) then
                  call fmequ_r1(mxy(13), ndig, ndig+iextra)
              endif
              ndig = ndig + iextra
              call fmi2m(nt-1, mxy(11))
              call fmnegate(mxy(13))
              call fmsub_r1(mxy(13), mxy(11))
              if (mod(nt, 2) == 1) mbsign = -1
          endif
      endif

!             If nt is large enough, it is faster to use two calls to fmlngm.
!             The formula below gives a rough approximation of where to change methods.

      t = ndig
      j = int(15.21*sqrt(t)*alogmt + 42.87*sqrt(t) + 25.03)
      if (nt > j) then
          call fmi2m(nt, mxy(4))
          call fmadd(mxy(13), mxy(4), mxy(14))

!             Compute iextra, the number of extra digits required to compensate for
!             cancellation error.

          if (max(mxy(13)%mp(2), mxy(14)%mp(2)) > iextra) then
              iextra = int(max(mxy(13)%mp(2), mxy(14)%mp(2)))
              if (abs(mxy(13)%mp(2)) >= mexpov .or. abs(mxy(14)%mp(2)) >= mexpov)  &
                  iextra = 0
          endif
          if (iextra > 0) then
              call fmequ_r1(mxy(13), ndig, ndig+iextra)
          endif
          ndig = ndig + iextra

          call fmi2m(-1, mxy(15))
          if (iextra > 0) then
              call fmi2m(nt, mxy(4))
              call fmadd(mxy(13), mxy(4), mxy(14))
          endif
          call fmi2m(2, mxy(9))
          kmb = 0
          if (mxy(13)%mp(1) < 0) then
              call fmmod(mxy(13), mxy(9), mxy(8))
              if (fmcomp(mxy(8), '>', mxy(15))) kmb = 1
          endif
          km08 = 0
          if (mxy(14)%mp(1) < 0) then
              call fmmod(mxy(14), mxy(9), mxy(8))
              if (fmcomp(mxy(8), '>', mxy(15))) km08 = 1
          endif
          call fmi2m(1, mxy(15))
          if (mxy(13)%mp(1) < 0 .and. kmb == 1) then
              call fmeq(mxy(13), mxy(15))
              call fmi2m(1, mxy(4))
              call fmadd(mxy(13), mxy(4), mxy(2))
              call fmlngm(mxy(2), mxy(13))
          else
              call fmlngm(mxy(13), mxy(3))
              call fmeq(mxy(3), mxy(13))
          endif
          if (mxy(14)%mp(1) < 0 .and. km08 == 1) then
              call fmi2m(-1, mxy(7))
              call fmadd_r1(mxy(14), mxy(7))
              call fmmpy(mxy(15), mxy(14), mxy(2))
              call fmlngm(mxy(2), mxy(14))
          else
              call fmlngm(mxy(14), mxy(3))
              call fmeq(mxy(3), mxy(14))
          endif

          call fmsub(mxy(14), mxy(13), mxy(11))
          call fmexp(mxy(11), mxy(2))
          call fmmpy(mxy(2), mxy(15), mxy(11))
      else

!             Compute the product z*(z+1)*...*(z+nt-1) four terms at a time to reduce the number
!             of fmmpy calls.

!             mxy(13) is z
!             mxy(6) is z**2
!             mxy(7) is z**3
!             mxy(8) is (z+k)*...*(z+k+3)
!             mxy(11) is the current product

!             If mxy(13) is negative and mxy(13)+nt is positive, extra digits are required when
!             mxy(13) is close to an integer.

          if (mxy(13)%mp(1) < 0) then
              call fmi2m(nt, mxy(8))
              call fmadd(mxy(13), mxy(8), mxy(9))
              if (mxy(9)%mp(1)*mxy(9)%mp(3) > 0) then
                  call fmnint(mxy(13), mxy(10))
                  if (mxy(10)%mp(3) /= 0) then
                      call fmsub(mxy(13), mxy(10), mxy(9))
                      iextra = max(iextra, ndig-ndsave)
                      if (max(mxy(13)%mp(2), mxy(9)%mp(2)) > iextra) then
                          iextra = int(max(mxy(13)%mp(2), mxy(9)%mp(2)))
                          if (abs(mxy(13)%mp(2)) >= mexpov .or.  &
                              abs(mxy(9)%mp(2)) >= mexpov) iextra = 0
                      endif
                      if (iextra > 0) then
                          call fmequ_r1(mxy(13), ndig, ndig+iextra)
                      endif
                      ndig = ndig + iextra
                  endif
              endif
          endif

          call fmi2m(1, mxy(11))
          if (nt >= 4) then
              call fmsqr(mxy(13), mxy(6))
              call fmmpy(mxy(13), mxy(6), mxy(7))
              call fmsqr(mxy(6), mxy(8))
              call fmcsmpyi(mxy(7), 6, mxy(12))
              call fmcsadd_r1(mxy(8), mxy(12))
              call fmcsmpyi(mxy(6), 11, mxy(12))
              call fmcsadd_r1(mxy(8), mxy(12))
              call fmcsmpyi(mxy(13), 6, mxy(12))
              call fmcsadd_r1(mxy(8), mxy(12))
              call fmeq(mxy(8), mxy(11))
              call fmcsmpyi_r1(mxy(7), 16)
              do k = 0, nt-8, 4
                 call fmcsadd_r1(mxy(8), mxy(7))
                 k2 = 24*(2*k + 7)
                 call fmcsmpyi(mxy(6), k2, mxy(12))
                 call fmcsadd_r1(mxy(8), mxy(12))
                 if (k <= sqrt(real(intmax)/49.0)) then
                     k1 = 8*(6*k*k + 42*k + 79)
                     call fmcsmpyi(mxy(13), k1, mxy(12))
                     call fmcsadd_r1(mxy(8), mxy(12))
                 else
                     k1 = 48*k
                     call fmcsmpyi(mxy(13), k1, mxy(12))
                     call fmcsmpyi_r1(mxy(12), k)
                     call fmcsadd_r1(mxy(8), mxy(12))
                     k1 = 336*k + 632
                     call fmcsmpyi(mxy(13), k1, mxy(12))
                     call fmcsadd_r1(mxy(8), mxy(12))
                 endif
                 if (k <= (real(intmax)/17.0)**0.3333) then
                     k0 = 8*(2*k + 7)*(k*k + 7*k + 15)
                     call fmaddi(mxy(8), k0)
                 else if (k <= sqrt(real(intmax)*0.9)) then
                     k0 = 8*(2*k + 7)
                     call fmi2m(k0, mxy(12))
                     k0 = k*k + 7*k + 15
                     call fmcsmpyi_r1(mxy(12), k0)
                     call fmcsadd_r1(mxy(8), mxy(12))
                 else
                     k0 = 8*(2*k + 7)
                     call fmi2m(k0, mxy(12))
                     call fmcsmpyi(mxy(12), k, mxy(9))
                     call fmcsmpyi_r1(mxy(9), k)
                     call fmcsadd_r1(mxy(8), mxy(9))
                     k0 = 7*k + 15
                     call fmcsmpyi_r1(mxy(12), k0)
                     call fmcsadd_r1(mxy(8), mxy(12))
                 endif
                 call fmcsmpy_r1(mxy(11), mxy(8))
              enddo
          endif

          klast = (nt/4)*4
          do j = klast, nt-1
             call fmi2m(j, mxy(9))
             call fmcsadd_r1(mxy(9), mxy(13))
             call fmcsmpy_r1(mxy(11), mxy(9))
          enddo
      endif

!             If the reflection formula was used, multiply by (-1)**nt.

      mxy(11)%mp(1) = mbsign*mxy(11)%mp(1)

      call fmeq(mxy(11), mresult)

      return
      end subroutine fmpoch_m1

      subroutine fmpoch_sc(ma, n, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = ma*(ma+1)*(ma+2)*...*(ma+n-1).

!  kresult = 1 is returned if a special case gives the value of ma*(ma+1)*(ma+2)*...*(ma+n-1).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(15), mresult
      integer :: n, kresult, ndsave
      intent (in) :: ma, n, ndsave
      intent (inout) :: mxy, mresult, kresult

      type(multi), save :: malocal
      double precision :: xe, ye
      integer :: j, k, k1, krsave, nds, nt

      kresult = 0

      namest(ncall) = 'FMPOCH   '
      j = ndig
      ndig = ndsave
      call fmntr_inp1i(ma, n)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      call fmovun_xe(malocal, xe)
      if (kround /= 1 .and. xe < -ndsave .and. n /= 0 .and. n /= 1) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          krsave = kround
          kround = 1
          nds = ndig
          ndig = ndig + ngrd52
          call fmequ(malocal, mxy(1), nds, ndig)
          nt = abs(n) - 1
          if (n < 0) nt = nt + 1
          call fmi2m(nt, mxy(2))
          call fmfact(mxy(2), mxy(3))
          call fmmpy(mxy(1), mxy(3), mxy(4))
          if (nt <= 20) then
              call fmi2m(1, mxy(2))
              call fmi2m(1, mxy(5))
              do k1 = 2, nt
                 call fmdivi(mxy(2), k1, mxy(6))
                 call fmadd_r1(mxy(5), mxy(6))
              enddo
          else
              call fmi2m(nt, mxy(7))
              call fmln(mxy(7), mxy(5))
              call fmeulr(mxy(6))
              call fmadd_r1(mxy(5), mxy(6))
              call fmi2m(1, mxy(2))
              call fmdiv(mxy(2), mxy(7), mxy(8))
              call fmdivi(mxy(8), 2, mxy(6))
              call fmadd_r1(mxy(5), mxy(6))
              call fmsqr(mxy(8), mxy(9))
              call fmdivi(mxy(9), 12, mxy(6))
              call fmsub_r1(mxy(5), mxy(6))
              call fmsqr(mxy(9), mxy(8))
              call fmdivi(mxy(8), 120, mxy(6))
              call fmadd_r1(mxy(5), mxy(6))
          endif
          if (n > 0) then
              call fmeq(mxy(4), mxy(6))
              call fmmpy(mxy(4), mxy(5), mxy(8))
              call fmmpy(mxy(1), mxy(8), mxy(7))
          else
              if (mod(nt, 2) == 0) then
                  call fmi2m(1, mxy(2))
              else
                  call fmi2m(-1, mxy(2))
              endif
              call fmdiv(mxy(2), mxy(3), mxy(6))
              call fmmpy(mxy(6), mxy(5), mxy(8))
              call fmmpy(mxy(1), mxy(8), mxy(7))
          endif
          call fmovun_xe(mxy(6), xe)
          call fmovun_xe(mxy(7), ye)
          if (xe - ye > ndsave+1 .and. xe < mexpov) then
              call fmequ(mxy(6), mxy(10), ndig, nds)
              call fmequ(mxy(6), mxy(9), ndig, nds)
              call fmequ(mxy(9), mxy(8), nds, ndig)
              call fmsub(mxy(6), mxy(8), mxy(9))
              if (mxy(9)%mp(3) == 0) then
                  call fmequ(mxy(6), mxy(8), ndig, nds)
                  call fmequ(mxy(7), mxy(9), ndig, nds)
                  ndig = nds
                  kround = krsave
                  call fmadd(mxy(8), mxy(9), mresult)
              else
                  kround = krsave
                  call fmequ(mxy(6), mresult, ndig, nds)
              endif
              kflag = 0
              ntrace = j
              kwarn = k
              ndig = nds
              kround = krsave
              kresult = 1
              return
          endif
          kflag = 0
          ntrace = j
          kwarn = k
          ndig = nds
          kround = krsave
      endif

      return
      end subroutine fmpoch_sc

      subroutine fmpower(ma, mb, mc)

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      call fmpwr(ma, mb, mc)

      return
      end subroutine fmpower

      subroutine fmprint(ma)

      use fmvals
      implicit none

      type(multi) :: ma
      intent (in) :: ma

      call fmprnt(ma)

      return
      end subroutine fmprint

      subroutine fmprnt(ma)

!  Print ma in base 10 format.

!  fmprnt can be called directly by the user for easy output in m format.
!  ma is converted using fmout and printed.

      use fmvals
      implicit none

      type(multi) :: ma

      character(20) :: form
      integer :: j, k, ksave, l, last, lb, nd, nexp
      intent (in) :: ma

      ncall = ncall + 1
      namest(ncall) = 'FMPRNT'
      ksave = kflag
      nd = int(real(ndig)*log10(real(mbase))) + 1
      if (nd < 2) nd = 2
      nexp = int(2.0*log10(real(mxbase))) + 16
      lb = max(jform2+nexp, nd+nexp)
      if (lb+50 > lmbuff) then
          if (lmbuff > 0) deallocate(cmbuff)
          allocate(cmbuff(lb+50), stat=j)
          if (j /= 0) then
              call fmdefine_error
          endif
          lmbuff = lb + 50
      endif
      call fmout(ma, cmbuff, lb)
      kflag = ksave
      last = lb + 1
      write (form, "(' (6X, ', I3, 'A1) ')") kswide-7
      do j = 1, lb
         if (cmbuff(last-j) /= ' ' .or. j == lb) then
             l = last - j
             write (kw, form) (cmbuff(k), k=1, l)
             ncall = ncall - 1
             return
         endif
      enddo
      ncall = ncall - 1

      return
      end subroutine fmprnt

      subroutine fmpsi(ma, mb)

!  mb = psi(ma)      derivative of ln(gamma(ma))

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(13), mresult, mretry

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmpsi_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      n_acc = nint(ndig*alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmpsi_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmpsi

      subroutine fmpsi_c(ndig_c, mbase_c, c)

!  Initialize the constants used in the psi polynomial.

      use fmvals
      implicit none

      integer :: ndig_c
      real (kind(1.0d0)) :: mbase_c
      type(multi) :: c(0:196)
      intent (inout) :: ndig_c, mbase_c, c

      integer :: ndsave
      character(220) :: st

      ndsave = ndig
      ndig = max(ndig, nint(210*dlogtn/dlogmb))
      ndig_c = ndig
      mbase_c = mbase

      st = " 9.227843350984671393934879099175975689578406640600764011942327651" //  &
           "151322732223353290630529367082532504853685527501929175190394959855" //  &
           "13457163775826002355076463746499666257062662262326057207404741752905084M-1"
      call fmst2m(st, c(0))
      st = " 3.949340668482264364724151666460251892189499012067984377355582293" //  &
           "700074704032008738336289006197587053040043189623371906796287246870" //  &
           "05007787935102946330866276831733309367762605095251006872140054796811559M-1"
      call fmst2m(st, c(1))
      st = " 7.705690315959428539973816151144999076498629234049888179227155534" //  &
           "183820578631309018645587360933525814619915779526071941849199599867" //  &
           "32832137763968372079001614539417829493600667191915755222424942439615639M-2"
      call fmst2m(st, c(2))
      st = " 1.982323371113819151600369654116790277475095191872690768297621544" //  &
           "412061618696884655690963594169991723299081390804274241458407157457" //  &
           "00453492820035147162192070877834809108370293261887348261752736042355062M-2"
      call fmst2m(st, c(3))
      st = " 5.677755143369926331365486457034168057080919501912811974192677903" //  &
           "803589786281484560043106557133336379620341466556609042800961779155" //  &
           "97084183511072180087644866286337180353598363962365128888981335276775240M-3"
      call fmst2m(st, c(4))
      st = " 1.718061984449139714517929790920527901817490032853561842408664004" //  &
           "332182901957897882773977938535170530279191162254558867398181448333" //  &
           "10185379291633807265673175253040965355618769627954139226236853166325794M-3"
      call fmst2m(st, c(5))
      st = " 5.367773819228268397975498497967595998635605652387064172831365716" //  &
           "014783173557353460969689138513239689614536514910748872867774198403" //  &
           "35440315798301033984562121069463585243906583353964676997567696691427804M-4"
      call fmst2m(st, c(6))
      st = " 1.711061979443393786852385086524652589607906498500203291102026525" //  &
           "829525747488143952872303723719711245236484702826900263542995480733" //  &
           "83970966270581799604618992754222287297459333028151505628361773822843426M-4"
      call fmst2m(st, c(7))
      st = " 5.526782608221441785276923241206048560585139488875654859661590978" //  &
           "505339025839895039306912716958615740860476584706026142537397072243" //  &
           "01530691324987642510909294868767654539697941540782602296415448362507489M-5"
      call fmst2m(st, c(8))
      st = " 1.801262781808533714595890031901700601953156447751725778899463629" //  &
           "146515191295439704196861038565275400689206320530767736809020353629" //  &
           "38073190695949842873953621603334722352596732052178932328832066541508011M-5"
      call fmst2m(st, c(9))
      st = " 5.907354119464558702282526469936468606435758208617119141436100054" //  &
           "059798219814702591843023560629835506072948141298603299797940044724" //  &
           "48291452340594666101827864743680486809340363559802370626936931930763706M-6"
      call fmst2m(st, c(10))
      st = " 1.945928308048298637998047739670960416088458003404533040952133252" //  &
           "019681940913049042808551900699474542980945266314269501249317870278" //  &
           "74908804736762623987426734001119677345511898921612599921683514419564006M-6"
      call fmst2m(st, c(11))
      st = " 6.430350784891467518365263573957142751058955098451367026716208967" //  &
           "268298442098128927139532681355390234484052117973406407648522438051" //  &
           "09390967296839296849960667716105732496299638299238322412706670233440209M-7"
      call fmst2m(st, c(12))
      st = " 2.129788087048292585451051353337474816961691545494827552022528629" //  &
           "410231774208766597829719984675128804906172087285080543161655047327" //  &
           "58375412105018997048159105561567647701210317140138410056728113033026445M-7"
      call fmst2m(st, c(13))
      st = " 7.065818202049355172851064506258762794870685817750656993289333226" //  &
           "715634227957307233434701754849436696844424928325302977575887819043" //  &
           "21794404770003433234833231074275648790842338915961498517998739808022623M-8"
      call fmst2m(st, c(14))
      st = " 2.347034615187173257148763672202323738899047153115310520358878708" //  &
           "702795315178628560484632246234627121875727895643809584057710305127" //  &
           "87278924224408794242543715977424052595827644319888981305672643671262471M-8"
      call fmst2m(st, c(15))
      st = " 7.803106649762273600293563029213088249090262679095379843972935643" //  &
           "290282459342081738636916671209602661597101103726013919619715976946" //  &
           "82488687750381269409404895538941410178728305136626722016628210197601304M-9"
      call fmst2m(st, c(16))
      st = " 2.595999374839856461644621939730454697218953331143174429987630039" //  &
           "542650045638001968668989649549309210492316961761661920993360907581" //  &
           "83943362125894719965856782417889275088010359200837997812612518790010306M-9"
      call fmst2m(st, c(17))
      st = " 8.640837414389256569577951013532585711448386302359330467618239497" //  &
           "053413093126642271180763027067164825596661845609758534245303980743" //  &
           "08087916612539453037312942192048368911659495539677311896754022319241514M-10"
      call fmst2m(st, c(18))
      st = " 2.877174665461131520386834493459437941874105957500564898511375137" //  &
           "311439002578360979763874789548515880868154509894190626699457757147" //  &
           "73686016316321832375029203457725272356560152718132192583462548282779007M-10"
      call fmst2m(st, c(19))
      st = " 9.582858468146311671960437304596644669478493760020748737659683908" //  &
           "789815983387663856449725613266381211899380089748749729674239142554" //  &
           "09417096385045411044655577509743953184783848043803078810843691683066120M-11"
      call fmst2m(st, c(20))
      st = " 3.192362617049000364818675299493504182177965826984960311647445893" //  &
           "562291482131615616774398545467628898736874378132707045074901954090" //  &
           "87857585211733812448598150553069088798592369166325857786128311238584878M-11"
      call fmst2m(st, c(21))
      st = " 1.063641452982306778871888232638725499778451985860322579723624373" //  &
           "042743512317431335223585983763945149600366863053831443772337083310" //  &
           "55022604714614305141359222385085339434173650339778299984225419876751487M-11"
      call fmst2m(st, c(22))
      st = " 3.544275868854612440207935801227503918837302795864246972321724495" //  &
           "355468544848206832825003613889968600093960257823513222253360353453" //  &
           "05713971042571842928244634878395967156692305652444148244943360077022711M-12"
      call fmst2m(st, c(23))
      st = " 1.181126956967686063705069366011844730919543312398681339013384460" //  &
           "767464082069171562896200433788460949822871886205681867819662919323" //  &
           "00910010651681302654526439685187828766124647111195799560742489176171727M-12"
      call fmst2m(st, c(24))
      st = " 3.936345173849846585066306986288647881678859105474359687899712967" //  &
           "448625102584861794056546209745855663655522551206324259480980022982" //  &
           "48196521666063662466312955017462793017857218058858813422030279362129550M-13"
      call fmst2m(st, c(25))
      st = " 1.311929116013669810041706041194547190318825658299932395783521476" //  &
           "062715708679008371003135237649339518303948243863280796328717056928" //  &
           "61088933385870034244218462559681704119429612455202721574336572434693909M-13"
      call fmst2m(st, c(26))
      st = " 4.372632654299231920401840242323289305929581151976933470616960496" //  &
           "030436497373880193006652887239443630902623173458012149767003641260" //  &
           "91381234213835299457171231108226264358946266150962591099913744278927353M-14"
      call fmst2m(st, c(27))
      st = " 1.457428209197515390994541694806166533046920066577489380555809169" //  &
           "326581787738147452100480717196733318418099673508724121255442697420" //  &
           "79428502647711159673409529291257489352915130912350484504348941167745402M-14"
      call fmst2m(st, c(28))
      st = " 4.857804189667246764735021219813567955136816185008613360441960672" //  &
           "940496363503624604027929086312123388047291007867151509866153218472" //  &
           "06384966879455254262531778810269062220190874499923455125800419069661498M-15"
      call fmst2m(st, c(29))
      st = " 1.619195639149486423325122007106269185336947307372971693371175669" //  &
           "889809582649582191406670950947339285199094038180244016830476463936" //  &
           "02101458401269222147875016156102854033684337727151883392617646517180429M-15"
      call fmst2m(st, c(30))
      st = " 5.397137809202938955975940495024829822845303110776022583879121893" //  &
           "921705867907147218379583534840013350252782358738567325002357267738" //  &
           "61010468743185749436896970436317859962951219444890985968097249049622718M-16"
      call fmst2m(st, c(31))
      st = " 1.799000703833061723835456309516522471727635932565177399470291246" //  &
           "245675486739349743760088108709128457742138295133686476564611083127" //  &
           "88305692939487359678233270751804270008374154159339121093086571227836484M-16"
      call fmst2m(st, c(32))
      st = " 5.996555960166587435989106305417312260461721595507168812416307139" //  &
           "617920826596045537450588005370606978697110903751234286759364296538" //  &
           "88342574088876310757201262943137995532500249048583561327234609512080698M-17"
      call fmst2m(st, c(33))
      st = " 1.998823729325601300227884046410698198743303225621025482564048890" //  &
           "140820433856911724428946203004508501377274799484714026521360076321" //  &
           "81570423267997358911300788282146663959893146975667195154844645417775406M-17"
      call fmst2m(st, c(34))
      st = " 6.662675132429289007245318420983808894124038069139542218571745865" //  &
           "030220152998942329578185363084791339999779092891491916899149034423" //  &
           "33275083724236395937279776479045434110852072326963373822046800189057081M-18"
      call fmst2m(st, c(35))
      st = " 2.220874055111200556512338059264850925555466107705796942638438370" //  &
           "439334710114183793262340326636387034843865608526952566379170604706" //  &
           "27391000045814717730873567070447343919893162122347939701787863570280570M-18"
      call fmst2m(st, c(36))
      st = " 7.402869382385770801058732735126460283848974699479515940427142498" //  &
           "169090369970169606837637347292197915595099714959178372809210169004" //  &
           "97096397918083614643468550094209927318490673314894967308013075647465808M-19"
      call fmst2m(st, c(37))
      st = " 2.467612094717547539757300850305893096186640705352512533565093161" //  &
           "524071499801682896819052946685011871151619653049568921247943861305" //  &
           "74027835796362386640519365699573759086773066188473623555158872217826510M-19"
      call fmst2m(st, c(38))
      st = " 8.225346069033827277619490875386000099087882850547971011202536869" //  &
           "560710353060722052873313849027274314019902150470472049910634941015" //  &
           "65431604021316042692200940962539817779136949003756418974351775701389418M-20"
      call fmst2m(st, c(39))
      st = " 2.741775128372239167169885703390452991143862808123403590500260252" //  &
           "686098892049313322445848356272884233074331136306076265803163875838" //  &
           "39997245835097889674208425702496742768010046284312175596063967715214956M-20"
      call fmst2m(st, c(40))
      st = " 9.139233192043922392172869121382982198915872580533647882222959712" //  &
           "340271164148043740483814963159921847750954087090085242066261297172" //  &
           "38743378565324605175470969019495974103495135080039518080872470260574797M-21"
      call fmst2m(st, c(41))
      st = " 3.046406755195530600990090643743590284251799899012276309359112089" //  &
           "108511649715687692732843107149352212491463042497645778261917818921" //  &
           "00104801732363345270093806101054860184893098558607015592900408049840396M-21"
      call fmst2m(st, c(42))
      st = " 1.015467841223081888268990685530571588993883516806444440463590063" //  &
           "919246457993838714361388326407974316725799445869567226317393205847" //  &
           "41823934922206879509013719077372316295552261963694116207153809783055715M-21"
      call fmst2m(st, c(43))
      st = " 3.384890111197057663463016207436882653098338276290627817566949828" //  &
           "395298842402236802648447435554701889903014892066703092691102459316" //  &
           "42305364341869125221913232186873905776329877020426296097438946487577807M-22"
      call fmst2m(st, c(44))
      st = " 1.128296030524118217901770376786986056339519574517002442090074882" //  &
           "057280000658483297467423203305781809303690428354763800658686040236" //  &
           "71779144955091790824204211870513439500061673502868286865350206893118470M-22"
      call fmst2m(st, c(45))
      st = " 3.760985085416611180417555002274204359368768836382888775095377932" //  &
           "135470299750400345139854657192126020629674958772171673259844584632" //  &
           "29740983608860531344547744626628209787912508838546108351215194899892193M-23"
      call fmst2m(st, c(46))
      st = " 1.253661274394284819616871799214565550306261501251793404757960132" //  &
           "128170781722119090896566129331363704599359253979761928823159537461" //  &
           "94504254386899126662346756986738717779547048333427719023221981595254954M-23"
      call fmst2m(st, c(47))
      st = " 4.178869862795538345454967070155508575326951978759241233273121057" //  &
           "066301381631679857138532781845567887396083218733585140280524330791" //  &
           "93670559242093402244963076978237398106292624308475677695772071716993274M-24"
      call fmst2m(st, c(48))
      st = " 1.392956357970703804166482382560887146464466644976989900838409857" //  &
           "521105907861179378438919270011579646317439048476258541449951226731" //  &
           "38419505723140506483598868257584439349831369024815848605796104120125198M-24"
      call fmst2m(st, c(49))
      st = " 4.643187202503244267904840086459603070244180285978311534148487451" //  &
           "448533368113912140098658002328251742282983537128133995397515041612" //  &
           "48378614922938242264999090255128209599611777303756393485557336865892384M-25"
      call fmst2m(st, c(50))
      st = " 1.547728903152056758023013339236654329438934392366540425603322082" //  &
           "857263082844161081125623346144761860535134488231475517768722978006" //  &
           "97598742236912925627747252856046998990338903727397536889459369962969529M-25"
      call fmst2m(st, c(51))
      st = " 5.159095932969129018305623899832229004426259340923333088824701344" //  &
           "793799573384328764667708388371262541343393211413511112875917018796" //  &
           "26630534722311094084888639746029822030436534231881230203368649013498048M-26"
      call fmst2m(st, c(52))
      st = " 1.719698541605578250055328719172355061652680958536807515991957911" //  &
           "829231225440009541518975734286993664349423799759754184346111779848" //  &
           "98079517451175822251033508127845088987176652373067048423597073312187144M-26"
      call fmst2m(st, c(53))
      st = " 5.732328215225532836270189877348903743690272187963364883413404892" //  &
           "515967840972047550982297271962784377794755127033081531768642894199" //  &
           "64735397060888178165089361563869938931990240827823701959473704067979558M-27"
      call fmst2m(st, c(54))
      st = " 1.910776007543699055364968001468624686158867348024934230266622903" //  &
           "018662755804722736204383531033467520086936412589269186167968820789" //  &
           "31707316415310370070101583553225900248595006769483528789991489268005919M-27"
      call fmst2m(st, c(55))
      st = " 6.369253197983874006821823217108741793471311336545161803572473280" //  &
           "581604669538018391744708133203440680673579856484395859330652484509" //  &
           "72888929728309163536568371996260645727875086529584444740409818707168597M-28"
      call fmst2m(st, c(56))
      st = " 2.123084359204225333255211453879706270058062440003428132183384754" //  &
           "529220299115266894193502387449244415133870841331224790006731846829" //  &
           "83950869831354206398680371015186352923965072680137000319344572605758909M-28"
      call fmst2m(st, c(57))
      st = " 7.076947763704848854568916919680447890729663289024670563717349289" //  &
           "716854593909643699182828273092172522117888394772977756940206908939" //  &
           "88161833503128621124125052157189818939182888192518392960394844544910580M-29"
      call fmst2m(st, c(58))
      st = " 2.358982562824326603834177965008914574063289371087237954036406546" //  &
           "340493525463133458597261132503854782619333331885562197138535071408" //  &
           "23201579847913351266307691059142085404786612749993269600147335936631424M-29"
      call fmst2m(st, c(59))
      st = " 7.863275146721236242647451555165511648580559926859636607085030645" //  &
           "828570768337179488776594015720853254496569344629950772241890794413" //  &
           "09501208585846001333592788550065884722420498762308117260230188148248777M-30"
      call fmst2m(st, c(60))
      st = " 2.621091699900456658110115330583854052361897297784388638216583319" //  &
           "454384526174907954107229789803487469826658513137203063896172131706" //  &
           "68596675776534544455338620395186907938046711829117294010990223395191200M-30"
      call fmst2m(st, c(61))
      st = " 8.736972293818315676196547510693128031654563870400207411221472197" //  &
           "802537238798558154077761157016481387194295979174198832797107057716" //  &
           "55476119097180397397991205334340641881095558538017176052985551441032265M-31"
      call fmst2m(st, c(62))
      st = " 2.912324088143640003892515793451613942403905838900460353749079195" //  &
           "711293166403329382629400828420996934679831800044190489170302330372" //  &
           "89702647828398182289986576193569329546458981411599932131292250327217139M-31"
      call fmst2m(st, c(63))
      st = " 9.707746935989309774922153324275043050136559616419228148856384390" //  &
           "891207031590122433573161121435856761535255587985039419083521928281" //  &
           "47684192432450134453307134064460958883080711047615861323976659104916668M-32"
      call fmst2m(st, c(64))
      st = " 3.235915639207398595265693615961166003757636977735808496558273648" //  &
           "928958056872747435108942393361659134982792854945130370217146958406" //  &
           "96083858500218202729498941860260710013473689957089195606216847161948489M-32"
      call fmst2m(st, c(65))
      st = " 1.078638544871873611955050957012575767956166828939502396913361632" //  &
           "134006203107387187862076294858437749004255229312668679921800233056" //  &
           "74417612290238598612397811829199658493331617719065112441605814593748378M-32"
      call fmst2m(st, c(66))
      st = " 3.595461812413097732268985825592100369404790978561873060558407383" //  &
           "209843595084925537819419221457817216101556873881028197503043710989" //  &
           "71993446117511506289219252721788791857419650690058381970466123873747686M-33"
      call fmst2m(st, c(67))
      st = " 1.198487269847745765578016200858552396971801017866213814921147936" //  &
           "194342329888616529805943628521815471009477410250705796740507122991" //  &
           "05724055220198767971701073860808057115160815984757015916251499607980512M-33"
      call fmst2m(st, c(68))
      st = " 3.994957563767602385747901769948142409291248613545961370363883891" //  &
           "289691397311922302379137927297721501329041681797620724073370767562" //  &
           "18203408450216245071443700831249773241142322486002435752961943222542254M-34"
      call fmst2m(st, c(69))
      st = " 1.331652520657979959724598554013660845601546719077233063789633368" //  &
           "960435001352641490522946960948433409671303505299895763210435682642" //  &
           "64618257123231948431647534610234863412519330901304158646595801812800221M-34"
      call fmst2m(st, c(70))
      st = " 4.438841734031881188976818132822337642864369008251133361954967150" //  &
           "427526248489023180060951578854782817826656197035293616050385245228" //  &
           "69777224342488088789975020608283234140930896389710286843599614310829011M-35"
      call fmst2m(st, c(71))
      st = " 1.479613910970280742873945057507129611414800958022743884631361380" //  &
           "691798159539547487537052914060034185767422767130178282321602757860" //  &
           "83348663879834983529553026971940768027904120497673742153199914849116728M-35"
      call fmst2m(st, c(72))
      st = " 4.932046368966736707433238163653472803158736679721922230398981807" //  &
           "148509857901058886361798749120231700519606437174141329665127637580" //  &
           "60684029229789780624847253236488984529122857484143590545454988280087620M-36"
      call fmst2m(st, c(73))
      st = " 1.644015456088695799904278450146142178669043440878937685558456872" //  &
           "964025555598274081805412440896705440428517289000442501284221387694" //  &
           "55648732942491166386921283069386388704660866255758554699458240090291278M-36"
      call fmst2m(st, c(74))
      st = " 5.480051519711778255840272708324976030739754268948537269674402054" //  &
           "568534364217773209485346648013194520472068667682265478950114643548" //  &
           "57817502762576875030228023959898997369951420244275748984693326649040707M-37"
      call fmst2m(st, c(75))
      st = " 1.826683839757957485171861873006044105081660879173944661934615164" //  &
           "058228248983434414103054534197242809510738787922754612090096010008" //  &
           "32972234391112427466530639806131521397347115826207673334357276487387067M-37"
      call fmst2m(st, c(76))
      st = " 6.088946132161603455339501324095998745526413263096303935940878780" //  &
           "526359496483279209617877435619263014735196336319313697924877016533" //  &
           "09653632325766553783756318556864993407257715531353455924785891667301524M-38"
      call fmst2m(st, c(77))
      st = " 2.029648710629304112312264073466486255977035674544143740902384580" //  &
           "066925825480897303013099124850654602496048781418796500497911435814" //  &
           "55895496319542786203501573229289360635504754435873888697991558050538067M-38"
      call fmst2m(st, c(78))
      st = " 6.765495701869604444386835156000328903984913424070294867383326826" //  &
           "380125179490385914541280070377395224806865489400873522529357739540" //  &
           "13593097642976584317974244356761507356447028338622758884083690956549688M-39"
      call fmst2m(st, c(79))
      st = " 2.255165233899515832701742852677093869944624882375775392021565853" //  &
           "727820148309140426329940190201858812882180125645736863330093959501" //  &
           "39799185623421035440349003272811535983000708934970150324591131369976675M-39"
      call fmst2m(st, c(80))
      st = " 7.517217446189171987910422000959627404182160006415193289405563037" //  &
           "073141918979212912887404738051712797448922513382013488736054976966" //  &
           "44850928549751713769786767895881754130344984097285305963557272547145616M-40"
      call fmst2m(st, c(81))
      st = " 2.505739148694087132524150695488551963220019249166337393102845297" //  &
           "929187685834976527612995960496060104814687111155509389611886823768" //  &
           "45665657833105762416203034605047428562380070279581109059970215759343049M-40"
      call fmst2m(st, c(82))
      st = " 8.352463828891198283454574490687921776166017804023933180339411723" //  &
           "551630949077812713723188475201183251308083861018090692334062700224" //  &
           "19315941542359676555596601655478811403243506810721773017251413934374514M-41"
      call fmst2m(st, c(83))
      st = " 2.784154609608126388309518953024776333056303224324599419154596270" //  &
           "687189694467353799519873714017939494084666475975688987152456659642" //  &
           "26654762776582515405508388836892873507912509482458807279902034848895589M-41"
      call fmst2m(st, c(84))
      st = " 9.280515365304738695722333964470955476404932927589213406274394075" //  &
           "824251507915677707145886824360137294712999378365268640074244947377" //  &
           "75283581062718625871709431187118953937401911092491908328625126927814924M-42"
      call fmst2m(st, c(85))
      st = " 3.093505121754325582272552779234873274821484670440649874514125833" //  &
           "450221430848146677414227286193944601969620041844899866725992046638" //  &
           "96302520509550456127533362858925937984066799183063861137995551939093475M-42"
      call fmst2m(st, c(86))
      st = " 1.031168373914628365020619376010732175534509522276934226759611010" //  &
           "510330113936747333958108874337789248731979567783939919999577683507" //  &
           "22523295728071715108784714082583918137083993400414421602035476389181042M-42"
      call fmst2m(st, c(87))
      st = " 3.437227913040060810736801880470831506837625258770689684886108518" //  &
           "300849420221764767894609466818173933155866849989575822424072255004" //  &
           "78234006087579117395941989824600255765731792341982892120664183263431722M-43"
      call fmst2m(st, c(88))
      st = " 1.145742637677845168748014850793946505879656739125856631649586463" //  &
           "591822853689599347930344326959430427527959142809100423533805439264" //  &
           "43279388738637495289806414123857142554621616733197424850302473869617722M-43"
      call fmst2m(st, c(89))
      st = " 3.819142125587379475420211530141217153875049185525247582904249203" //  &
           "019903748875977266231256469090038860233530356197288111009590135316" //  &
           "90898695851949084954771545562975566659699180249151895098720201541444897M-44"
      call fmst2m(st, c(90))
      st = " 1.273047375194433720039269643742156618287252568559809316454558670" //  &
           "180525454213261685018950248687574295353166212229651718103175620816" //  &
           "43760967542155803486826726482394407727128624904626495857158860946505910M-44"
      call fmst2m(st, c(91))
      st = " 4.243491250644713804047213900311521631782151086428302312117409417" //  &
           "778324805156532130172471108085960753421387148016192082165090341252" //  &
           "19545466280371097678329835612276755167203138210639186157532227100590980M-45"
      call fmst2m(st, c(92))
      st = " 1.414497083547388285661813522776106834139405615052171085969597516" //  &
           "047278841879024411976249475067654110853871648213868458414159189231" //  &
           "79891226179605118296023118379963942164595272691469246552143553753880550M-45"
      call fmst2m(st, c(93))
      st = " 4.714990278489170162988560867348152304757403878210496541497712053" //  &
           "006454958803147191193828617164924983154190125072717651655296406044" //  &
           "51236582999806300249260089437863523751237893569424876357019027689437850M-46"
      call fmst2m(st, c(94))
      st = " 1.571663426162525690358614617253775521309331567276009924639764177" //  &
           "358960165102899050236124157794756906336803102013665429067943394214" //  &
           "57838273206825762014705848617755003448485196508751247061517100802618351M-46"
      call fmst2m(st, c(95))
      st = " 5.238878087207091391268381971748475496510636983623239581337201528" //  &
           "761219196441713174722639342282806574120757748535810991181068549199" //  &
           "89053413431795493494028007267927630087829683052755847961739807896841957M-47"
      call fmst2m(st, c(96))
      st = " 1.746292695735365236274430121252895780353566878171851946466982282" //  &
           "916481274302755866597786442055146506112819565744487880483609437125" //  &
           "77321479855945945213560009077900564250744371125376843314616795699839063M-47"
      call fmst2m(st, c(97))
      st = " 5.820975652450387718877296368406106766373716711813705919181086521" //  &
           "999505975590854145900097731105648953941956782748776332821329494966" //  &
           "87768367928768066507060035439222042970126325626238817880646490785855621M-48"
      call fmst2m(st, c(98))
      st = " 1.940325217483255139116418908036918257576300407306275798031334364" //  &
           "409601786683742364221787811915022144162851994955921858529462196970" //  &
           "10653973717672741870614055497821682510355774493997650251816154517127732M-48"
      call fmst2m(st, c(99))
      st = " 6.467750724943665212448072244898217344228281509203436692886144544" //  &
           "710488376123702904475209151820097662127258578415899891069730495416" //  &
           "37336243969682934496722083054141458419645859035208215900305459742433866M-49"
      call fmst2m(st, c(100))
      st = " 2.155916908314425424664368170497409014232503939749568528677540140" //  &
           "384039734094541956602791846039169318650021459160866243512075243331" //  &
           "45679505658773347404938241005432513933656138666470399349344701169458177M-49"
      call fmst2m(st, c(101))
      st = " 7.186389694381093966835437692494728822349002314959532010292364775" //  &
           "394946247059389433028322727013522877670270796020110428790305813054" //  &
           "79391776953852548570365845653848831536967043669276608555999675341559488M-50"
      call fmst2m(st, c(102))
      st = " 2.395463231460283626767035225609077295862357711256733986014148707" //  &
           "753272199463531514035780844426290282772850231675309468999618270293" //  &
           "06226615257093166993337223904134396989045750924820301622864539591983840M-50"
      call fmst2m(st, c(103))
      st = " 7.984877438200742850444847499777309845694641795079466763347310518" //  &
           "973477267679513036692556925499430697000376845097566527468301532263" //  &
           "68593074139587048157403440914703927108798266764367635240248126118737063M-51"
      call fmst2m(st, c(104))
      st = " 2.661625812733530307120299705689856310419430305299514816454219978" //  &
           "167720121577781636596013737099879504260242494410428404547299997096" //  &
           "29214426445076866714408263418452627026007712187686306994919339537176315M-51"
      call fmst2m(st, c(105))
      st = " 8.872086042444974416164378071031044765486837933978062891736690757" //  &
           "063302976670153482438120949026393088923322321063932750682909484640" //  &
           "80118939886335367290880449750827102760828907286267653373299382121005954M-52"
      call fmst2m(st, c(106))
      st = " 2.957362014148293153495637994224156508433858704035708219961848704" //  &
           "752814743630032704058576844386754167614614033997051904620347311738" //  &
           "61904345412997662020042929619746892567448362596680832152684925750243880M-52"
      call fmst2m(st, c(107))
      st = " 9.857873380494231381920907655510228783611078844545021454399920772" //  &
           "141062619227406263790226964711069068688447840761328895136653289698" //  &
           "66981214088475384265075552305006338119605469313298818722398857563732976M-53"
      call fmst2m(st, c(108))
      st = " 3.285957793498057344874164686873206738067743142840216191903487618" //  &
           "019941680979531742712197349882728018267551869210987929616034749064" //  &
           "30303538626114994902987549690732156800575304242342439460223044767290112M-53"
      call fmst2m(st, c(109))
      st = " 1.095319264499347502683187139319325563979656486096742174653628128" //  &
           "976581637422575945930267442158932925061363256302618217044235776727" //  &
           "78289678865564842523041070219617158649346807209669750276034200426122137M-53"
      call fmst2m(st, c(110))
      st = " 3.651064214997812644923454493506674835323388056021714399807493703" //  &
           "605967302048397979154313095594794645711111183057404193592791956678" //  &
           "66172552061879738476243285533776439739119193738969145723129786576511450M-54"
      call fmst2m(st, c(111))
      st = " 1.217021404999267790636025855753778604335807084870166221152973014" //  &
           "506916159759972779875308117306931009803008009678064932776645093318" //  &
           "00842098229392080507684746488956996056988713932200497206909259105378943M-54"
      call fmst2m(st, c(112))
      st = " 4.056738016664218241273938781923458650417321982457636718798922936" //  &
           "477302304740685369168107498238001936713766023175775737524892409160" //  &
           "01634272341340971077361157145530586562647498591786411480985240150120553M-55"
      call fmst2m(st, c(113))
      st = " 1.352246005554737481879776083250264536787105289190169898749791140" //  &
           "348233188200740056915744202769004512689087720776827335229272164151" //  &
           "84364840446652924162659286494044457495071328336364564380197269062778195M-55"
      call fmst2m(st, c(114))
      st = " 4.507486685182453443237078181203119239131669164992680684219261837" //  &
           "277644454396847551795676165306867658683702735066801164086167252711" //  &
           "19484010084871947031012001315393818015815520382515662702573278448350109M-56"
      call fmst2m(st, c(115))
      st = " 1.502495561727483273655148872429157437910868921767186291387141573" //  &
           "512573119402964065902228084442655668385002115354783777594857713998" //  &
           "29523050153288241379342972449409357035473017504499197092941874010814147M-56"
      call fmst2m(st, c(116))
      st = " 5.008318539091607893624136610372602345176507591543467689236137943" //  &
           "884673550591046086592830872513439140608629637038740043915787148541" //  &
           "52394870950686380101306680838055095132070888200259040353691065606620624M-57"
      call fmst2m(st, c(117))
      st = " 1.669439513030535209901455630134076834170615280098683744729402670" //  &
           "296396657337808597037921736436660468249832659227172779367140247404" //  &
           "03362990043020714217884143429674645399729964793508983794394882884002423M-57"
      call fmst2m(st, c(118))
      st = " 5.564798376768448813071710669353659573416270465590122350543315121" //  &
           "413388656111319238743752535035180158976403027283093627581775200347" //  &
           "08950549480561185545001882864566882001602568174009919346046996759045750M-58"
      call fmst2m(st, c(119))
      st = " 1.854932792256149132707284865787646721627824417634136205769228907" //  &
           "351320889807301200265876310886504825399338639660085162561571671143" //  &
           "80178781198866361165024767169800779385647991333075996890986127709064413M-58"
      call fmst2m(st, c(120))
      st = " 6.183109307520495929899402826852708229420151109621107470264900121" //  &
           "134345986789710812316854495785567736467232785746686941727193331941" //  &
           "56103871513252933011548432169303614875570158457053586066135942237566488M-59"
      call fmst2m(st, c(121))
      st = " 2.061036435840165015185247594351604598673466050924812223481238383" //  &
           "744650549307488207514436927186243454249400309582767262472952477865" //  &
           "39488089477469737100729325446476505038057243548633416390135776998909246M-59"
      call fmst2m(st, c(122))
      st = " 6.870121452800549313664441945028230766782586053733765495536930184" //  &
           "148735432170307184364193773249356218482192867580453706078982702322" //  &
           "36906147589341063176294087284637487815185909131173012735635871205970777M-60"
      call fmst2m(st, c(123))
      st = " 2.290040484266849586983218139377689608197401631939278155837315152" //  &
           "749176998379162942186288612171254733497127165504629660957484257215" //  &
           "03960145633908464981886082313132803826782445898913850664341670496286810M-60"
      call fmst2m(st, c(124))
      st = " 7.633468280889498162681737525654781395094610920374961079941892134" //  &
           "693686042107521045090976432509818240749828811152884417434183792443" //  &
           "40208045334338980097933050903816256868615301460865703415771912193724986M-61"
      call fmst2m(st, c(125))
      st = " 2.544489426963165939078331773845571337558244149440634270398446661" //  &
           "730902552806699411443989280898922405978534154707887233634737588764" //  &
           "69277444899419995451128654151512085551424867809084295696469106990521519M-61"
      call fmst2m(st, c(126))
      st = " 8.481631423210552842388820742776895367676872160158770358942482422" //  &
           "735183525513672190915958631633045631581296672220414159119266677730" //  &
           "00882790484855601476924199497856972658319507003728226425960873810966916M-62"
      call fmst2m(st, c(127))
      st = " 2.827210474403517542161535621759888928745745898925998679999176972" //  &
           "500449767039313885942472306882332999282623012200216004408023722942" //  &
           "35548228163002484117039136830425719490113419540684925428659006215127579M-62"
      call fmst2m(st, c(128))
      st = " 9.424034914678391627284940507974624769084040519392748443016620129" //  &
           "151493273032159506798645125157903918497199981418255987213825116544" //  &
           "91313520782402912277192097971388451766192404480480266469096595803740649M-63"
      call fmst2m(st, c(129))
      st = " 3.141344971559463830781602278189827439570491126580879213267566098" //  &
           "634582653573961371388430476987677106802274861280003439184958337497" //  &
           "55871137194361985101053142410164165629409400589300651854575488722127625M-63"
      call fmst2m(st, c(130))
      st = " 1.047114990519821265682189619947088028639202210810159318824710297" //  &
           "418144878455534152843738752328520535580617712220747998447348456148" //  &
           "87128390653434870273058245640426383654361423379776610643883264096972007M-63"
      call fmst2m(st, c(131))
      st = " 3.490383301732737524161437551201638806706639111674055435356822668" //  &
           "242340068122359401431212212101510842260288841134358619348306937471" //  &
           "32292385947826289933592114188205257470612591292887863954967567373067619M-64"
      call fmst2m(st, c(132))
      st = " 1.163461100577579167692347221578745581156399690416630219259420060" //  &
           "140471624651128200456995286998175955667309375958539555927592191244" //  &
           "69108542176232753118949875989033621399852815112398485508138602381100101M-64"
      call fmst2m(st, c(133))
      st = " 3.878203668591930541404160833208709487069318555519787588536748926" //  &
           "079489227092349654317217820179356059640911818309293644987827038914" //  &
           "23113705652681321350172045452704473329699236304435049788227394174622197M-65"
      call fmst2m(st, c(134))
      st = " 1.292734556197310176075471134722937741048543949863716607618949311" //  &
           "134596575499614268058353886586544618677755951138400973297684683800" //  &
           "49929217081801053935564115665217627139106390261578300958135297518693689M-65"
      call fmst2m(st, c(135))
      st = " 4.309115187324367242603447591543502614635432074915146455974961100" //  &
           "783991800140039817841446475586229840527592677387439828807409996406" //  &
           "58572000140795436674747033557343891137764503605700790270107002153194098M-66"
      call fmst2m(st, c(136))
      st = " 1.436371729108122411455785149464652955014483913555925454567566343" //  &
           "033751539926464502402671954114290440329353433043868042553216356430" //  &
           "95760927792248401840769385171665086466412488627981015154342470344616262M-66"
      call fmst2m(st, c(137))
      st = " 4.787905763693741364655873712257673345968093702500400380413759009" //  &
           "343709671855218190105116076110599847270179980048633459127967075496" //  &
           "95329570740860986232312515609865359747150038120760918167660196395395859M-67"
      call fmst2m(st, c(138))
      st = " 1.595968587897913786502772040929797311513936155534630802777161042" //  &
           "323085710283013809416229252137018873920387828320283701537288724338" //  &
           "18222527779868222288064331588809401461453186408435455724607829956650895M-67"
      call fmst2m(st, c(139))
      st = " 5.319895292993045950719608811875781719400488218015940339624963833" //  &
           "904468790238424394665705538673163852924018058746539220799914498871" //  &
           "87123883979205073632821149986880853121193839902134978166092188353175974M-68"
      call fmst2m(st, c(140))
      st = " 1.773298430997681982500795106152343395146291244985375992301024831" //  &
           "172880492620523208419431056495256021417076918908947764372774801634" //  &
           "66308162036559401365955897830840212263006984532789801526556111330540563M-68"
      call fmst2m(st, c(141))
      st = " 5.910994769992273272321630775993113357374306776150164446878995429" //  &
           "199988365546454090281139320572057370171863201292260358152263114701" //  &
           "84849003352679924628129743645300899848128310062948455843231411729916686M-69"
      call fmst2m(st, c(142))
      st = " 1.970331589997424423436955364217490328008758498727308342596972914" //  &
           "838317948717210312982993577885955575234727205227508863543462414701" //  &
           "19790327280248261234206607030131137515730415891713737174983639027604997M-69"
      call fmst2m(st, c(143))
      st = " 6.567771966658081409780880644570952852212869394142774498275969597" //  &
           "051352302027804591436366292098249004955749719212407233759626410804" //  &
           "23094265521905707737671802871297906382006218125926665760693315871567840M-70"
      call fmst2m(st, c(144))
      st = " 2.189257322219360469508050905240435788723932139126639198455650265" //  &
           "181880562634665346793855787464756222043343074562742957750457331886" //  &
           "51136835170527293161085727720893207671856322049649329515124067695351675M-70"
      call fmst2m(st, c(145))
      st = " 7.297524407397868230646229744835872327874966073160276767231213689" //  &
           "623218792935837978230418401268856718201925396539510384196175753170" //  &
           "66652198429614667985969715027449338257278758408128943199367755324652975M-71"
      call fmst2m(st, c(146))
      st = " 2.432508135799289409953591617661733991864335564333111377209692880" //  &
           "074976374750213242253051652321561734041852268969020358465621089424" //  &
           "14424996317706067303976880419998421002358404179645130678096779653358570M-71"
      call fmst2m(st, c(147))
      st = " 8.108360452664298032524092931381732192579715420011362584102530122" //  &
           "399082594247638810857284958385615023239610775424662458807879174869" //  &
           "99208578767507795046313489342326234225642585624250987626962498888032182M-72"
      call fmst2m(st, c(148))
      st = " 2.702786817554766010677727150378738299179197264006681328494022283" //  &
           "461713062938474709283827967021738008108993688482511856757752986924" //  &
           "83022205593730217582984347916302439090400201412445704126518051302925734M-72"
      call fmst2m(st, c(149))
      st = " 9.009289391849220035183332673115118436689105231658609100131576105" //  &
           "746817524522178460300592879017536531814751063263253522537492214691" //  &
           "66287676119612980647194230638456363682773535596502263016913065096674627M-73"
      call fmst2m(st, c(150))
      st = " 3.003096463949740011625527637203839580670438558448697439316922582" //  &
           "080500699241877972753395936644410394325148621157014967621235051277" //  &
           "19702357955843408402299203602763881244696185804277033716869763248333675M-73"
      call fmst2m(st, c(151))
      st = " 1.001032154649913337182941137354579752756157403350587184082572655" //  &
           "668720365134577993101924383011283318540511319882434333492124758136" //  &
           "56328900549930706700593452010716708224185836746712866383541238461850333M-73"
      call fmst2m(st, c(152))
      st = " 3.336773848833044457211857959630261241457227305512566083673355396" //  &
           "481818433800591390918626541367515865084768432579659244905807486980" //  &
           "29134378942434319177868848768173954755492210535184756504211022367766391M-74"
      call fmst2m(st, c(153))
      st = " 1.112257949611014819054635753320402681213887420341206221531310860" //  &
           "985682956261502881389306545840511198169923612506852778221149565252" //  &
           "81459361368566900183720441504615495296290954141555036222396831117077406M-74"
      call fmst2m(st, c(154))
      st = " 3.707526498703382730161873261392491115828186807291897198915909604" //  &
           "155674067990161834342683376529820781124868349247913942628339699553" //  &
           "19187594923162356418905498458595704597809148916916571510786341062302288M-75"
      call fmst2m(st, c(155))
      st = " 1.235842166234460910044062971858447900664274034201950858925878124" //  &
           "083887957837752863211714821751135044697824600808010987957735653910" //  &
           "85021760966460551881259692413828184054079514253554146831394157759200228M-75"
      call fmst2m(st, c(156))
      st = " 4.119473887448203032928247987246026060335598144698999438082486484" //  &
           "981872504026407021712061503540785866057593612250257886109051123261" //  &
           "20553540800492774307915913243657294990555992068366814198248544293239073M-76"
      call fmst2m(st, c(157))
      st = " 1.373157962482734344300829830088785762819828470154677406792486349" //  &
           "582215434835624433211455183472833063222300779138846503724376654756" //  &
           "97153990917671843512951431419776274311910081550489091472125204982219742M-76"
      call fmst2m(st, c(158))
      st = " 4.577193208275781160871184364111765898905714315410964770181334551" //  &
           "559734462338946414187167832153901075953527960902149729732952392999" //  &
           "05739092117020357910064590291184764747354548289282230511803212990314666M-77"
      call fmst2m(st, c(159))
      st = " 1.525731069425260387008576333292791990843668717239246139931723054" //  &
           "113730949750810518714216058816633073359740920341684018573316882922" //  &
           "19161413294992398162552504179370639600545735768135221710078494678533369M-77"
      call fmst2m(st, c(160))
      st = " 5.085770231417534313032798702697681197383439273915544588375043156" //  &
           "982436257501835267954582765438953697752001176322824202363456833480" //  &
           "84822237757173265524313083452491401792161623828870993995239601500752613M-78"
      call fmst2m(st, c(161))
      st = " 1.695256743805844769784622112797766089615978935755501503220932068" //  &
           "343174291091693715417344263720144349029281513168498097220402832110" //  &
           "79996411923403065677514822313169241774858920814773828257766665033772313M-78"
      call fmst2m(st, c(162))
      st = " 5.650855812686156039255381634430268704055968949073218709347085199" //  &
           "742155287063313738806948673339105867918184157411397848315417982770" //  &
           "28216209989585045629974649193921980908524940232212434747464651403766044M-79"
      call fmst2m(st, c(163))
      st = " 1.883618604228718704942922337070948507896675501998486050379053659" //  &
           "203222058229334282486849245788565645787611354772468558241052640628" //  &
           "68090996198582244338892337657054683701568414292331480633193743238899042M-79"
      call fmst2m(st, c(164))
      st = " 6.278728680762256512149009149976440283047018296660977205232840187" //  &
           "711671745561355189005624289121525977497317264018845068610009630166" //  &
           "24422122072055952477161863795374233113339410369040977100353306447007727M-80"
      call fmst2m(st, c(165))
      st = " 2.092909560254085021920435547839978227290505174219696260063426880" //  &
           "879036670946017746113568504819405540190923727599189799888162522342" //  &
           "82688033004648088111864002916433340227047169032122354503266913856888244M-80"
      call fmst2m(st, c(166))
      st = " 6.976365200849595928568515913272594158672772019779337814697530205" //  &
           "514328112647957246760099455857571687826289491085647676946101437355" //  &
           "54833971648944261391739603826369822509790583940615701556419202194043338M-81"
      call fmst2m(st, c(167))
      st = " 2.325455066949873863606967397576505711197188840184692731505571050" //  &
           "057010126988203224760379663164013876837099897428308506101979830146" //  &
           "10509395537389044680077986544130564059305007513097257902320076380128891M-81"
      call fmst2m(st, c(168))
      st = " 7.751516889786273230333744396009595784689618339833872888076148749" //  &
           "510954270591897268986918218161521302808459344904049745958883339834" //  &
           "97636368620176777364813719377132199681517454923842508307735464876551893M-82"
      call fmst2m(st, c(169))
      st = " 2.583838963261950823751464199102541531987080961128181249653133059" //  &
           "486343391931814427787289188223115323267471180053604447425299309852" //  &
           "43333277896763688823725567334545875021894956285785557169534759498102028M-82"
      call fmst2m(st, c(170))
      st = " 8.612796544966339593464148319279864385495846603731409332903857040" //  &
           "341111578596179250787433586544432993469429659882790724588244062567" //  &
           "78136790746398664694553035857800597304056454220060017665421505719967290M-83"
      call fmst2m(st, c(171))
      st = " 2.870932181657563853682489496869596716118149568767000014172109841" //  &
           "753698478327036128411797178375480340579847035333592372289787795793" //  &
           "96627619330877369349750053557082939116418335842754914658257204585102926M-83"
      call fmst2m(st, c(172))
      st = " 9.569773927459502329189843968932453842109493094807395751883972275" //  &
           "108106634425357758674379648287072224301747951696615265196165041805" //  &
           "20236585969398304163224702023392754793840706634155432621406698219669058M-84"
      call fmst2m(st, c(173))
      st = " 3.189924642457193947274983048068918789864588583187967339730200869" //  &
           "383977309483707594218810831491599791827472770895338811393310795354" //  &
           "69234531929746996008196354596059905584934184315535092321474774208305020M-84"
      call fmst2m(st, c(174))
      st = " 1.063308229833233763649833968823830359312501010885534593366422641" //  &
           "631138341936187529001129656673501820789940104427992740873815715203" //  &
           "53412492554104141309331928436306992144198744553482555692829414468432600M-84"
      call fmst2m(st, c(175))
      st = " 3.544360766480896268661948406666249396818945618937640720661704673" //  &
           "296436347072454208561096669377429691244542539862734276732737789906" //  &
           "87985432036327462359694991859663225608649510569830536167392892074714882M-85"
      call fmst2m(st, c(176))
      st = " 1.181453391991692193233905477505817491959791629667967979777058345" //  &
           "391387128260137859898575835696679473316746285686162580343604354886" //  &
           "33746615556680423641254628884245686047585862162458511355057706178924765M-85"
      call fmst2m(st, c(177))
      st = " 3.938177969065104259816577437558454136986820863927184608342465808" //  &
           "644130213208017150749164656763736226904608349061342579349394401954" //  &
           "11955443745482049001748543874113465084785050139876732361231723529022225M-86"
      call fmst2m(st, c(178))
      st = " 1.312728231460229835781775849221721497298632770454454059027673781" //  &
           "147657857867325372034109920647863595009065024284231880168892910826" //  &
           "53488283009582034319652319525792167583043745345137953029043134270740314M-86"
      call fmst2m(st, c(179))
      st = " 4.375760815315077535413782421712416021566276398233684094737691912" //  &
           "768825492780444215747826165057411744207345952312538488710400858828" //  &
           "27700668026171627589196059317745967100234000846254430975531508363872519M-87"
      call fmst2m(st, c(180))
      st = " 1.458563929048378339389356324275832391447007080182288931684002700" //  &
           "009472184445323295339567304943041273340490012950372985830518037286" //  &
           "27460201464773612755677066535469683435847032008950889605333804095236722M-87"
      call fmst2m(st, c(181))
      st = " 4.861879359454319859107850617575234255777767433683221708284430699" //  &
           "990829575672698923326870227967687183467108336363217071248382357963" //  &
           "22818905179326628057052156616846776700350617514896748728636343647107755M-88"
      call fmst2m(st, c(182))
      st = " 1.620837575639336717669585897558965566795189581102158562505695709" //  &
           "761058058214152430539033470517727442776271455644632399079159816470" //  &
           "13032790990474394168725899077889253682309738675257461400762111892656053M-88"
      call fmst2m(st, c(183))
      st = " 5.402795219201229254205870902900594939962067229843983888917879564" //  &
           "569447106085277432976440651841249190437245953800537313805443864980" //  &
           "06342541344494885255739000367067646594242251182208803771724906930826406M-89"
      call fmst2m(st, c(184))
      st = " 1.799216964519093606731219963783752545188788013842673930468641591" //  &
           "448479933065901726577672674840349510506058583228709079379586399536" //  &
           "92651555915483777543359909186871398885320260440340033124792023837781809M-89"
      call fmst2m(st, c(185))
      st = " 5.997366309057088767075298231986828202847652039333576421385057338" //  &
           "145629178278871106675461140725723229061908016307033578803459780175" //  &
           "07666172639242691690123978056031089958911595034842389306632163036435150M-90"
      call fmst2m(st, c(186))
      st = " 2.011301294926252140726390741032210138299321852132295904710257720" //  &
           "158209117243470457856408196331997445864262615242552875300814542975" //  &
           "47170830674630176097026011113551746496002275896336822879606882224230602M-90"
      call fmst2m(st, c(187))
      st = " 6.704482593621562564692937104577317810644610039525202376129260569" //  &
           "861749723553513086341477081381278126242511169725032335903896422492" //  &
           "18854955408659222455853625926956312559220163444056344847372949727294762M-91"
      call fmst2m(st, c(188))
      st = " 2.160351395289544486253226495324951606774126604957407637555483550" //  &
           "521132050784441566021695109519541771023447038718264653048827134039" //  &
           "73414393141529555898480576201941789130545638907969682039980597723815399M-91"
      call fmst2m(st, c(189))
      st = " 7.200419569439204992397584876133276247439864059745857658513848169" //  &
           "634972230829808411159889094321665351721254003922021586700615812024" //  &
           "99355813646045295572813794504886619128172862586448322114482098387570581M-92"
      call fmst2m(st, c(190))
      st = " 2.784319712626698759566047586489485590648301900234226820496273235" //  &
           "253278946132569789086775657480520424132403062835830911025372468898" //  &
           "94806632232823225075878972837000029411691959653897178979682691313860829M-92"
      call fmst2m(st, c(191))
      st = " 9.284263699802481030477812401350944543556932743559221880685236144" //  &
           "608807942910647790463633201299242608070391986248492383364489375260" //  &
           "66506636257311455988821088223165685964257289358894735278070005979762986M-93"
      call fmst2m(st, c(192))
      st = " 1.469128321729119845643781712942080844517377977136622326900618953" //  &
           "248797751416855621723808444613828590416570423767280724666117572301" //  &
           "34285990191248448522554726873193884488157002183510418398417800853692970M-93"
      call fmst2m(st, c(193))
      st = " 4.886379978539319342120523930953291961277105452075509621364036950" //  &
           "981474984583217822110836621562995692449070713522036826314376565947" //  &
           "22694606242271109407828035720163781683675686187162678102051578537829111M-94"
      call fmst2m(st, c(194))
      st = " 7.046670647920504479063475010556879295393094797174920722994400551" //  &
           "715505897095883223398696557122758497726817737906295249088240133320" //  &
           "85226292447629611992116676332110323776745430326383013890000067486498923M-94"
      call fmst2m(st, c(195))
      st = " 2.351541158501990523752731749555092275030088173405523455954546630" //  &
           "113446321330723773662111826297238234224538212221014494477821368974" //  &
           "29678996883123994564079639022862654561283884722866834645277830050207084M-94"
      call fmst2m(st, c(196))

      ndig = ndsave

      end subroutine fmpsi_c

      subroutine fmpsi_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc)

!  Method selection for computing psi(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc

      integer :: k, kfl, krflct, krsave, nmethd
      double precision :: x, xe, z
      logical, external :: fmcomp

      retry = .true.

      n_acc = nint(ndig*alogm2)
      call fmequ(ma, mxy(1), ndsave, ndig)
      call fmeq(mxy(1), mxy(11))

!             Near zero Psi(x) is about -1/x.

      call fmovun_xe(mxy(11), xe)
      if (xe < (-ndig-1)) then
          call fmi2m(-1, mxy(3))
          call fmdiv(mxy(3), mxy(11), mresult)
          return
      endif

!             Check for special cases.

      krflct = 0
      call fmdpm(dble(-0.5), mxy(4))
      if (fmcomp(mxy(11), '<=', mxy(4))) then
          krflct = 1
          kfl = 0
          call fmovun_xe(mxy(1), xe)
          if (xe <= ndsave) then
              call fmint(mxy(11), mxy(7))
              if (fmcomp(mxy(11), '==', mxy(7))) kfl = -4
          else
              kfl = -4
          endif
          if (kfl /= 0) then
              call fmunknown(mresult)
              kflag = -4
              retry = .false.
              return
          else
              call fmi2m(1, mxy(3))
              call fmsub_r2(mxy(3), mxy(11))
          endif
      endif

!             Determine which method to use.

!             nmethd = 1 means use the polynomial approximation,
!                    = 2 means use the asymptotic series.

      nmethd = 1
      call fmnint(mxy(11), mxy(2))
      call fmsub(mxy(11), mxy(2), mxy(6))
      call fmm2dp(mxy(6), z)
      z = max(abs(z), 1.0d-50)
      if (kflag /= 0 .or. abs(z) >= 1) then
          nmethd = 2
      else
          if (190*log(z) - 90*dlogtn >= -ndig*dlogmb .or. -190*dlogtn >= -ndig*dlogmb) then
              nmethd = 2
          endif
      endif
      call fmm2dp(mxy(11), x)
      if (kflag /= 0) then
          nmethd = 2
      else if (nmethd == 1) then
          if (x > 35 - 8*log(z) + ndig*dlogmb/(2.5*dlogtn) .or. x > 250) nmethd = 2
      endif

      if (nmethd == 1) then
          call fmpsi_m1(mxy, mresult, ndsave, numtry, retry, n_acc, z)
      else if (nmethd == 2) then
          call fmpsi_m2(mxy, mresult, retry, n_acc)
      endif

!             Use the reflection formula if ma was less than -1/2.

      if (krflct == 1) then

!             Reduce the argument before multiplying by Pi.

          call fmnint(mxy(11), mxy(4))
          call fmsub(mxy(11), mxy(4), mxy(7))
          call fmcancel(mxy(11), mxy(4), mxy(7), k)
          n_acc = n_acc - k
          call fmpi(mxy(9))
          call fmmpy_r1(mxy(9), mxy(7))
          krsave = krad
          krad = 1
          call fmtan(mxy(9), mxy(2))
          krad = krsave
          call fmpi(mxy(9))
          call fmdiv_r2(mxy(9), mxy(2))
          call fmadd(mxy(8), mxy(2), mxy(3))
          call fmcancel(mxy(8), mxy(2), mxy(3), k)
          n_acc = n_acc - k
          call fmeq(mxy(3), mresult)
      endif

      return
      end subroutine fmpsi_m

      subroutine fmpsi_m1(mxy, mresult, ndsave, numtry, retry, n_acc, z)

!  Method 1 for computing psi(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(13), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      double precision :: z
      intent (in) :: numtry, ndsave, z
      intent (inout) :: mxy, mresult, retry, n_acc

      integer :: j, j2, k, k0, k0b, k1, k1b, k2, kl, lshift, ndsav1, nterm
      integer, save :: ndig_c = 0
      real (kind(1.0d0)), save :: mbase_c = 0
      type(multi), save :: mjsums(ljsums), c(0:196)


!             Method 1.  Use the polynomial c(0) + c(1)*(x-3) + ... + c(196)*(x-3)**196

      if (mxy(1)%mp(1) > 0 .and. ndsave+ngrd52 < ndig .and. numtry <= 0) ndig = ndsave + ngrd52
      n_acc = nint(ndig*alogm2)
      call fmm2i(mxy(2), lshift)
      lshift = lshift - 3
      if (ndig_c < ndig .or. mbase_c /= mbase) then
          call fmpsi_c(ndig_c, mbase_c, c)
      endif
      j2 = 0.42*log(z) + 7.9
      j2 = max(2, min(j2+mod(j2, 2), ljsums))
      ndsav1 = ndig
      do j = 1, j2
         call fmeq(c(j), mjsums(j))
      enddo
      call fmipwr(mxy(6), j2, mxy(5))
      call fmeq(mxy(5), mxy(7))
      nterm = j2
      kl = 1
      do while (kl == 1)
         if (nterm > j2) call fmcsmpy_r1(mxy(7), mxy(5))
         do j = 1, j2
            nterm = nterm + 1
            call fmeq(mxy(7), mxy(4))
            call fmcsmpy_r1(mxy(4), c(nterm))
            ndig = ndsav1
            call fmcsaddnn_r1(mjsums(j), mxy(4))
            if (kflag /= 0 .or. nterm == 196) then
                kl = 0
                exit
            endif
            ndig = max(ngrd22, ndsav1-int(mjsums(j)%mp(2) - mxy(4)%mp(2)))
            ndig = min(ndsav1, ndig)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         enddo
      enddo
      kflag = 0
      call fmcsnsums(j2, mjsums)
      ndig = ndsav1
      if (nterm == 196) then
          call fmpsi_m2(mxy, mresult, retry, n_acc)
          return
      endif
      call fmeq(mjsums(j2), mxy(8))
      call fmeq(mxy(6), mxy(3))
      call fmnegate(mxy(3))
      do j = 2, j2
         call fmcsmpy_r1(mxy(8), mxy(3))
         call fmcsadd_r1(mxy(8), mjsums(j2-j+1))
      enddo
      call fmcsmpy_r1(mxy(8), mxy(6))
      call fmadd_r1(mxy(8), c(0))

!             Now Psi of the shifted argument has been computed.  Reverse the shifting.
!             The sum 1/(ma-lshift) + ... + 1/(ma-1) is computed.

!             mxy(11) is z
!             mxy(4) is z**2
!             mxy(5) is 16*z**3
!             mxy(6) is the current four-term numerator
!             mxy(7) is the current four-term denominator
!             mxy(9) is the current sum

      if (lshift < 0) then
          call fmi2m(-1, mxy(4))
          call fmeq(mxy(11), mxy(5))
          if (mxy(8)%mp(1) > 0) then
              call fmeq(mxy(8), mxy(12))
              call fmi2m(0, mxy(13))
          else
              call fmeq(mxy(8), mxy(13))
              call fmi2m(0, mxy(12))
          endif
          do j = 1, -lshift
             call fmcsdiv(mxy(4), mxy(5), mxy(7))
             if (mxy(7)%mp(1) > 0) then
                 call fmadd_r1(mxy(12), mxy(7))
             else
                 call fmadd_r1(mxy(13), mxy(7))
             endif

             call fmcsadd_r1(mxy(8), mxy(7))
             call fmsub_r1(mxy(5), mxy(4))
          enddo
          call fmadd(mxy(12), mxy(13), mxy(8))
          call fmcancel(mxy(12), mxy(13), mxy(8), k)
          n_acc = n_acc - k
      endif
      if (lshift > 0) then
          call fmaddi(mxy(11), -lshift)
          if (mod(lshift, 4) /= 0) then
              call fmi2m(1, mxy(4))
              call fmeq(mxy(11), mxy(5))
              do j = 1, mod(lshift, 4)
                 call fmcsdiv(mxy(4), mxy(5), mxy(7))
                 call fmcsadd_r1(mxy(8), mxy(7))
                 call fmcsadd_r1(mxy(5), mxy(4))
              enddo
              call fmaddi(mxy(11), mod(lshift, 4))
          endif
          lshift = lshift - mod(lshift, 4)
      endif
      if (lshift > 0) then
          call fmsqr(mxy(11), mxy(4))
          call fmmpy(mxy(11), mxy(4), mxy(5))
          call fmsqr(mxy(4), mxy(6))
          call fmcsmpyi(mxy(5), 6, mxy(10))
          call fmcsadd_r1(mxy(6), mxy(10))
          call fmcsmpyi(mxy(4), 11, mxy(10))
          call fmcsadd_r1(mxy(6), mxy(10))
          call fmcsmpyi(mxy(11), 6, mxy(10))
          call fmadd(mxy(6), mxy(10), mxy(7))
          call fmcsmpyi(mxy(5), 4, mxy(6))
          call fmcsmpyi(mxy(4), 18, mxy(10))
          call fmcsadd_r1(mxy(6), mxy(10))
          call fmcsmpyi(mxy(11), 22, mxy(10))
          call fmcsadd_r1(mxy(6), mxy(10))
          call fmi2m(6, mxy(10))
          call fmcsadd_r1(mxy(6), mxy(10))
          call fmcsdiv(mxy(6), mxy(7), mxy(9))
          call fmcsmpyi_r1(mxy(5), 16)
          do k = 4, lshift-4, 4
             call fmcsadd_r1(mxy(7), mxy(5))

             call fmcsmpyi(mxy(4), 48, mxy(10))
             call fmcsadd_r1(mxy(6), mxy(10))

             k2 = 8*(6*k - 3)
             call fmcsmpyi(mxy(4), k2, mxy(10))
             call fmcsadd_r1(mxy(7), mxy(10))

             k1 = 16*(6*k - 3)
             call fmcsmpyi(mxy(11), k1, mxy(10))
             call fmcsadd_r1(mxy(6), mxy(10))

             if (k <= sqrt(real(intmax)/49.0)) then
                 k1 = 8*(6*k*k - 6*k + 7)
                 call fmcsmpyi(mxy(11), k1, mxy(10))
                 call fmcsadd_r1(mxy(7), mxy(10))

                 call fmi2m(k1, mxy(10))
                 call fmcsadd_r1(mxy(6), mxy(10))
             else
                 k1 = 48*k
                 call fmcsmpyi(mxy(11), k1, mxy(10))
                 call fmcsmpyi_r1(mxy(10), k)
                 call fmcsadd_r1(mxy(7), mxy(10))
                 k1b = 8*(-6*k + 7)
                 call fmcsmpyi(mxy(11), k1b, mxy(10))
                 call fmcsadd_r1(mxy(7), mxy(10))

                 call fmi2m(k1, mxy(10))
                 call fmcsmpyi_r1(mxy(10), k)
                 call fmcsadd_r1(mxy(6), mxy(10))
                 call fmi2m(k1b, mxy(10))
                 call fmcsadd_r1(mxy(6), mxy(10))
             endif
             if (k <= (real(intmax)/17.0)**0.3333) then
                 k0 = 8*(2*k - 1)*(k*k - k + 3)
                 call fmi2m(k0, mxy(10))
                 call fmcsadd_r1(mxy(7), mxy(10))
             else if (k <= sqrt(real(intmax)*0.9)) then
                 k0 = 8*(2*k - 1)
                 call fmi2m(k0, mxy(10))
                 k0b = k*k - k + 3
                 call fmcsmpyi_r1(mxy(10), k0b)
                 call fmcsadd_r1(mxy(7), mxy(10))
             else
                 k0 = 8*(2*k - 1)
                 call fmi2m(k0, mxy(10))
                 call fmcsmpyi_r1(mxy(10), k)
                 call fmcsmpyi_r1(mxy(10), k)
                 call fmcsadd_r1(mxy(7), mxy(10))
                 k0b = -k + 3
                 call fmi2m(k0, mxy(10))
                 call fmcsmpyi_r1(mxy(10), k0b)
                 call fmcsadd_r1(mxy(7), mxy(10))
             endif
             call fmcsdiv(mxy(6), mxy(7), mxy(10))
             call fmcsadd_r1(mxy(9), mxy(10))
          enddo
          call fmadd(mxy(8), mxy(9), mxy(3))
          call fmcancel(mxy(8), mxy(9), mxy(3), k)
          n_acc = n_acc - k
          call fmeq(mxy(3), mxy(8))
      endif

      call fmeq(mxy(8), mresult)

      return
      end subroutine fmpsi_m1

      subroutine fmpsi_m2(mxy, mresult, retry, n_acc)

!  Method 2 for computing psi(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(13), mresult
      logical :: retry
      integer :: n_acc
      intent (inout) :: mxy, mresult, retry, n_acc

      integer :: inta, j, j2, k, k0, k0b, k1, k1b, k2, kl, kwrnsv, lshift, ndenom,  &
                 ndig2, ndsav1, nmxdif, nterm
      double precision :: xe
      type(multi), save :: mjsums(ljsums)


!             Method 2.  Use the b(2n)/(2n*x**(2n) asymptotic series.
!                        To speed the asymptotic series calculation,
!                        increase the argument by lshift.

      n_acc = nint(ndig*alogm2)
      kwrnsv = kwarn
      kwarn = 0
      call fmm2i(mxy(11), inta)
      kwarn = kwrnsv

      if (kflag == -4) then
          lshift = 0
      else
          lshift = max(0, int(real(ndig)*alogmb/4.46-real(inta)))
      endif
      if (lshift > 0) lshift = 4*(lshift/4 + 1)

      if (lshift /= 0) then
          call fmi2m(lshift, mxy(3))
          call fmadd(mxy(11), mxy(3), mxy(10))
      else
          call fmeq(mxy(11), mxy(10))
      endif

!             Sum the asymptotic series.

      j2 = int(0.3*alogmb + 0.2*sqrt(real(ndig)))
      j2 = max(1, min(ljsums, j2))

!             mxy(11) is z
!             mxy(10) is z + lshift
!             mxy(7) is x**j2 = (1/(z+lshift)**2)**j2
!             mxy(8) is the current power of x
!             mxy(9) is the current term in the sum
!             mjsums is the partial sum

      ndsav1 = ndig
      call fmi2m(1, mxy(8))
      j = -2*j2
      call fmipwr(mxy(10), j, mxy(7))
      call fmovun_xe(mxy(7), xe)
      if (abs(xe) >= mexpab) then
          j2 = 1
          call fmipwr(mxy(10), -2, mxy(7))
      endif
      nterm = 2
      do j = 1, j2
         nterm = 2*j
         call fmbern(nterm, mxy(8), mxy(9))
         if (kflag == -11) then
             call fmunknown(mresult)
             kflag = -4
             retry = .false.
             return
         endif
         ndenom = nterm
         call fmdivi(mxy(9), ndenom, mjsums(j))
      enddo

      ndig2 = ndig
      kl = 1
      do while (kl == 1)
         call fmmpy_r1(mxy(8), mxy(7))
         nmxdif = min(ndsav1, ngrd22)
         do j = 1, j2
            nterm = nterm + 2
            call fmbern(nterm, mxy(8), mxy(9))
            if (kflag == -11) then
                call fmunknown(mresult)
                kflag = -4
                retry = .false.
                return
            endif
            ndenom = nterm
            call fmdivi_r1(mxy(9), ndenom)
            ndig = ndsav1
            call fmadd_r1(mjsums(j), mxy(9))
            nmxdif = max(nmxdif, ndsav1-int(mjsums(j)%mp(2)-mxy(9)%mp(2)))
            ndig = ndig2
            if (kflag /= 0) then
                kl = 0
                exit
            endif
         enddo
         if (kl == 0) exit
         ndig2 = nmxdif
         ndig = ndig2
      enddo

!             Put the j2 concurrent sums back together.

      ndig = ndsav1
      call fmi2m(1, mxy(7))
      call fmsqr(mxy(10), mxy(9))
      call fmdiv_r2(mxy(7), mxy(9))
      if (j2 > 1) then
          call fmeq(mjsums(j2), mxy(7))
          do j = j2-1, 1, -1
             call fmmpy_r1(mxy(7), mxy(9))
             call fmadd_r1(mxy(7), mjsums(j))
          enddo
          call fmeq(mxy(7), mjsums(1))
      endif

!             Add the log term to the asymptotic series.

!             mxy(8) is the current sum as the log terms are added
!             mxy(9) is now ln(z+lshift)

      call fmmpy(mjsums(1), mxy(9), mxy(8))
      call fmln(mxy(10), mxy(9))
      call fmi2m(1, mxy(4))
      call fmdiv(mxy(4), mxy(10), mxy(5))
      call fmdivi_r1(mxy(5), 2)
      call fmsub(mxy(9), mxy(5), mxy(3))
      call fmcancel(mxy(9), mxy(5), mxy(3), k)
      n_acc = n_acc - k
      call fmeq(mxy(3), mxy(5))
      call fmsub(mxy(5), mxy(8), mxy(3))
      call fmcancel(mxy(5), mxy(8), mxy(3), k)
      n_acc = n_acc - k
      call fmeq(mxy(3), mxy(8))

!             Now Psi of the shifted argument has been computed.  Reverse the shifting.
!             The sum 1/(ma) + ... + 1/(ma+lshift-1) is computed.

!             mxy(11) is z
!             mxy(4) is z**2
!             mxy(5) is 16*z**3
!             mxy(6) is the current four-term numerator
!             mxy(7) is the current four-term denominator
!             mxy(9) is the current sum

      if (lshift > 0) then
          call fmsqr(mxy(11), mxy(4))
          call fmmpy(mxy(11), mxy(4), mxy(5))
          call fmsqr(mxy(4), mxy(6))
          call fmmpyi(mxy(5), 6, mxy(10))
          call fmadd_r1(mxy(6), mxy(10))
          call fmmpyi(mxy(4), 11, mxy(10))
          call fmadd_r1(mxy(6), mxy(10))
          call fmmpyi(mxy(11), 6, mxy(10))
          call fmadd(mxy(6), mxy(10), mxy(7))
          call fmmpyi(mxy(5), 4, mxy(6))
          call fmmpyi(mxy(4), 18, mxy(10))
          call fmadd_r1(mxy(6), mxy(10))
          call fmmpyi(mxy(11), 22, mxy(10))
          call fmadd_r1(mxy(6), mxy(10))
          call fmi2m(6, mxy(10))
          call fmadd_r1(mxy(6), mxy(10))
          call fmdiv(mxy(6), mxy(7), mxy(9))
          call fmmpyi_r1(mxy(5), 16)
          do k = 4, lshift-4, 4
             call fmadd_r1(mxy(7), mxy(5))

             call fmmpyi(mxy(4), 48, mxy(10))
             call fmadd_r1(mxy(6), mxy(10))

             k2 = 8*(6*k - 3)
             call fmmpyi(mxy(4), k2, mxy(10))
             call fmadd_r1(mxy(7), mxy(10))

             k1 = 16*(6*k - 3)
             call fmmpyi(mxy(11), k1, mxy(10))
             call fmadd_r1(mxy(6), mxy(10))

             if (k <= sqrt(real(intmax)/49.0)) then
                 k1 = 8*(6*k*k - 6*k + 7)
                 call fmmpyi(mxy(11), k1, mxy(10))
                 call fmadd_r1(mxy(7), mxy(10))

                 call fmi2m(k1, mxy(10))
                 call fmadd_r1(mxy(6), mxy(10))
             else
                 k1 = 48*k
                 call fmmpyi(mxy(11), k1, mxy(10))
                 call fmmpyi_r1(mxy(10), k)
                 call fmadd_r1(mxy(7), mxy(10))
                 k1b = 8*(-6*k + 7)
                 call fmmpyi(mxy(11), k1b, mxy(10))
                 call fmadd_r1(mxy(7), mxy(10))

                 call fmi2m(k1, mxy(10))
                 call fmmpyi_r1(mxy(10), k)
                 call fmadd_r1(mxy(6), mxy(10))
                 call fmi2m(k1b, mxy(10))
                 call fmadd_r1(mxy(6), mxy(10))
             endif
             if (k <= (real(intmax)/17.0)**0.3333) then
                 k0 = 8*(2*k - 1)*(k*k - k + 3)
                 call fmi2m(k0, mxy(10))
                 call fmadd_r1(mxy(7), mxy(10))
             else if (k <= sqrt(real(intmax)*0.9)) then
                 k0 = 8*(2*k - 1)
                 call fmi2m(k0, mxy(10))
                 k0b = k*k - k + 3
                 call fmmpyi_r1(mxy(10), k0b)
                 call fmadd_r1(mxy(7), mxy(10))
             else
                 k0 = 8*(2*k - 1)
                 call fmi2m(k0, mxy(10))
                 call fmmpyi_r1(mxy(10), k)
                 call fmmpyi_r1(mxy(10), k)
                 call fmadd_r1(mxy(7), mxy(10))
                 k0b = -k + 3
                 call fmi2m(k0, mxy(10))
                 call fmmpyi_r1(mxy(10), k0b)
                 call fmadd_r1(mxy(7), mxy(10))
             endif
             call fmdiv(mxy(6), mxy(7), mxy(10))
             call fmadd_r1(mxy(9), mxy(10))
          enddo
          call fmsub(mxy(8), mxy(9), mxy(3))
          call fmcancel(mxy(8), mxy(9), mxy(3), k)
          n_acc = n_acc - k
          call fmeq(mxy(3), mxy(8))
      endif

      call fmeq(mxy(8), mresult)

      return
      end subroutine fmpsi_m2

      subroutine fmpsi_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = psi(ma).

!  kresult = 1 is returned if a special case gives the value of psi(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j, k, krsave, nds
      double precision :: xe, ye
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMPSI    '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      call fmovun_xe(malocal, xe)
      if (kround /= 1 .and. xe < -ndsave) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          krsave = kround
          kround = 1
          nds = ndig
          ndig = ndig + ngrd52
          call fmequ(malocal, mxy(1), nds, ndig)
          call fmi2m(0, mxy(2))
          call fmsub(mxy(2), mxy(1), mxy(3))
          call fmi2m(1, mxy(2))
          call fmdiv(mxy(2), mxy(3), mxy(4))
          call fmeulr(mxy(6))
          call fmmpyi(mxy(6), -1, mxy(5))
          call fmovun_xe(mxy(4), xe)
          call fmovun_xe(mxy(5), ye)
          if (xe - ye > ndsave+1 .and. xe < mexpov) then
              call fmequ(mxy(4), mxy(6), ndig, nds)
              call fmequ(mxy(6), mxy(8), nds, ndig)
              call fmsub(mxy(4), mxy(8), mxy(6))
              if (mxy(6)%mp(3) == 0) then
                  call fmequ(mxy(4), mxy(6), ndig, nds)
                  call fmequ(mxy(5), mxy(7), ndig, nds)
                  ndig = nds
                  kround = krsave
                  call fmadd(mxy(6), mxy(7), mresult)
              else
                  kround = krsave
                  call fmequ(mxy(4), mresult, ndig, nds)
              endif
              kflag = 0
              ntrace = j
              kwarn = k
              ndig = nds
              kround = krsave
              kresult = 1
              return
          endif
          kflag = 0
          ntrace = j
          kwarn = k
          ndig = nds
          kround = krsave
      endif

      return
      end subroutine fmpsi_sc

      subroutine fmpwr(ma, mb, mc)

!  mc = ma**mb

!  If mb can be expressed exactly as a one word integer, then fmipwr is used.  This is much faster
!  when mb is small, and using fmipwr allows ma to be negative.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(4), mresult

      call fmalloc(mc, ndig+2)
      call fmenter2(ma, mb, kovun, mxsave, ndsave)
      call fmpwr_sc(ma, mb, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mc, kovun, mxsave, ndsave)
          return
      endif

      retry = .true.
      do while (retry)
         retry = .false.
         call fmpwr_m1(ma, mb, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mc, kovun, mxsave, ndsave)

      return
      end subroutine fmpwr

      subroutine fmpwr_m1(ma, mb, mxy, mresult, ndsave)

!  Method 1 for computing ma**mb

      use fmvals
      implicit none

      type(multi) :: ma, mb, mxy(4), mresult
      integer :: ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult

      integer :: iextra, intmb, j, kfl, kwrnsv
      type(multi), save :: malocal, mblocal
      logical, external :: fmcomp

      call fmequ(ma, malocal, ndsave, ndig)
      call fmequ(mb, mblocal, ndsave, ndig)

      kwrnsv = kwarn
      kwarn = 0
      call fmm2i2(mblocal, intmb)
      kwarn = kwrnsv
      kfl = kflag

!             If the exponent is large or the base is very large, raise the precision.

      if (malocal%mp(2) /= 0) then
          j = int(log(abs(real(malocal%mp(2))))/alogmb)
          iextra = max(0, int(mblocal%mp(2))+j)
          if (abs(malocal%mp(2)) >= mexpov .or. abs(mblocal%mp(2)) >= mexpov) then
              iextra = 0
          endif
      else
          iextra = max(0, int(mblocal%mp(2)))
          if (abs(mblocal%mp(2)) >= mexpov) iextra = 0
      endif
      if (mblocal%mp(2)-ndig > log(alogmb*real(mxexp2))) then
          iextra = 0
      endif
      ndig = ndig + iextra

!             If the exponent is a small integer, call fmipwr.

      kwrnsv = kwarn
      kwarn = 0

      call fmequ(malocal, mxy(2), ndsave, ndig)

      if (kfl == 0) then
          call fmipwr(mxy(2), intmb, mxy(4))
      else if (mxy(2)%mp(3) == 0) then
          call fmunknown(mxy(4))
      else
          call fmequ(mblocal, mxy(1), ndsave, ndig)
          if (mxy(2)%mp(1) < 0) then
              call fmint(mxy(1), mxy(3))
              if (fmcomp(mxy(1), '==', mxy(3))) then
                  call fmi2m(2, mxy(3))
                  call fmmod(mxy(1), mxy(3), mxy(4))
                  j = -1
                  if (mxy(4)%mp(3) == 0) j = 1
                  call fmnegate(mxy(2))
                  call fmln(mxy(2), mxy(3))
                  call fmmpy_r1(mxy(3), mxy(1))
                  call fmexp(mxy(3), mxy(4))
                  if (j == -1) call fmnegate(mxy(4))
              else
                  call fmunknown(mxy(4))
              endif
          else
              call fmln(mxy(2), mxy(3))
              call fmmpy_r1(mxy(3), mxy(1))
              call fmexp(mxy(3), mxy(4))
          endif
      endif
      kwarn = kwrnsv
      call fmeq(mxy(4), mresult)

      return
      end subroutine fmpwr_m1

      subroutine fmpwr_sc(ma, mb, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = ma**mb

!  kresult = 1 is returned if a special case gives the value of ma**mb

      use fmvals
      implicit none

      type(multi) :: ma, mb, mxy(4), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult, kresult

      type(multi), save :: malocal, mblocal
      double precision :: b, x
      integer :: j, k, kc, kd, kwn, kx
      logical, external :: fmcomp

      kresult = 0

      namest(ncall) = 'FMPWR    '
      j = ndig
      ndig = ndsave
      call fmntr_inp2(ma, mb)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)
      call fmequ(mb, mblocal, ndsave, ndig)

      if ((malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) .or.  &
          (mblocal%mp(2) == munkno .and. mblocal%mp(5) >= 0)) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif
      if (malocal%mp(3) == 0) then
          if (mblocal%mp(3) == 0) then
              call fmunknown(mresult)
              kresult = 1
              return
          else if (mblocal%mp(1) > 0) then
              call fmi2m(0, mresult)
              kflag = 0
              kresult = 1
              return
          else
              call fmunknown(mresult)
              kresult = 1
              return
          endif
      endif
      if (mblocal%mp(3) == 0) then
          call fmi2m(1, mresult)
          kflag = 0
          kresult = 1
          return
      endif
      if (abs(malocal%mp(2)) >= mexpov .or. mblocal%mp(2) >= mexpov) then
          call fmovun_pwr(malocal, mblocal, mresult)
          kflag = 0
          kresult = 1
          return
      endif
      k = ntrace
      ntrace = 0
      call fmi2m(1, mxy(4))
      call fmabs(malocal, mxy(3))
      ntrace = k

      if (mblogs /= mbase) call fmcons

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (kround /= 1 .and. malocal%mp(1) >= 0 .and. malocal%mp(3) > 0 .and.  &
          malocal%mp(2) /= munkno .and. mblocal%mp(2) /= munkno) then
          j = ntrace
          ntrace = 0
          kwn = kwarn
          kwarn = 0
          b = mbase
          kc = 0
          kd = nint(log10(b))
          if (10.0d0**kd == b) then
              kc = 10
          else
              kd = nint(log(b)/log(2.0d0))
              if (2.0d0**kd == b) kc = 2
          endif
          if (kc > 0) then
              call fmm2dp(malocal, x)
              if (kflag == 0 .and. x > 0) then
                  kx = nint(log(x)/log(dble(kc)))
                  call fmi2m(kc, mxy(2))
                  call fmipwr(mxy(2), kx, mxy(3))
                  if (fmcomp(mxy(3), '==', malocal)) then
                      call fmmpyi(mblocal, kx, mxy(3))
                      call fmint(mxy(3), mxy(4))
                      if (fmcomp(mxy(3), '==', mxy(4))) then
                          call fmm2i(mxy(3), kd)
                          if (kflag == 0) then
                              call fmipwr(mxy(2), kd, mresult)
                              ntrace = j
                              kwarn = kwn
                              kresult = 1
                              return
                          endif
                      endif
                  endif
              endif
          endif
          if (mblocal%mp(2) == mexpun) then
              call fmeq(mblocal, mxy(3))
              if (malocal%mp(2) <= 0) call fmnegate(mxy(3))
          else
              call fmln(malocal, mxy(1))
              call fmmpy(mxy(1), mblocal, mxy(3))
          endif
          kflag = 0
          ntrace = j
          kwarn = kwn
          if (mxy(3)%mp(2) < -ndsave) then
              j = ntrace
              ntrace = 0
              kwn = kwarn
              kwarn = 0
              call fmi2m(1, mxy(1))
              call fmsub(malocal, mxy(1), mxy(2))
              if (mxy(2)%mp(3) == 0) then
                  call fmi2m(1, mxy(2))
              else
                  call fmadd(mxy(1), mxy(3), mxy(2))
              endif
              if (mxy(2)%mp(2) /= munkno) then
                  kflag = 0
                  ntrace = j
                  kwarn = kwn
                  call fmeq(mxy(2), mresult)
                  kresult = 1
                  return
              endif
          endif
      endif

      return
      end subroutine fmpwr_sc

      subroutine fmrational_power(ma, ival, jval, mb)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: ival, jval
      intent (in) :: ma, ival, jval
      intent (inout) :: mb

      call fmrpwr(ma, ival, jval, mb)

      return
      end subroutine fmrational_power

      subroutine fmrdc(ma, jsin, jcos, jswap)

!  Reduce ma using various trigonometric identities to an equivalent angle between 0 and 45 degrees.
!  The reduction is done in radians if krad (in module fmvals) is 1, in degrees if krad is 0.
!  jsin and jcos are returned +1 or -1 and jswap is returned to indicate that the sin and cos
!  functions have been interchanged as follows:

!  jswap = 0 means   sin(ma) = jsin*sin(returned value of ma)
!                    cos(ma) = jcos*cos(returned value of ma)

!  jswap = 1 means   sin(ma) = jsin*cos(returned value of ma)
!                    cos(ma) = jcos*sin(returned value of ma)

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: jsin, jcos, jswap
      intent (inout) :: ma
      intent (inout) :: jsin, jcos, jswap

      double precision :: x
      integer :: j, ndsave, ndsv
      logical, external :: fmcomp
      type(multi), save :: mxy(6)

      if (mblogs /= mbase) call fmcons
      jsin = 1
      jcos = 1
      jswap = 0
      ndsave = ndig
      if (krad == 0) then
          call fmi2m(360, mxy(2))
          call fmeq(ma, mxy(4))
          call fmmod(mxy(4), mxy(2), ma)
      endif

      if (abs(ma%mp(2)) < mexpov) then
          ndig = ndig + max(0, int(ma%mp(2)))
          if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
      endif

!             If ma is less than 1/mbase, no reduction is needed.

      if (ma%mp(2) < 0) then
          ndig = ndsave
          if (ma%mp(1) < 0) then
              ma%mp(1) = 1
              jsin = -1
          endif
          return
      endif

      j = 1
      if (krad == 1) then
          do
             if (mbspi /= mbase .or. ndigpi < ndig) then
                 ndsv = ndig
                 ndig = ndig + 2
                 call fmpi(mxy(4))
                 ndig = ndsv
             endif
             call fmequ(ma, mxy(4), ndsave, ndig)
             if (ma%mp(1) < 0) jsin = -1
             mxy(4)%mp(1) = 1
             if (mxy(4)%mp(2) == 0) then
                 call fmm2dp(mxy(4), x)
                 if (x <= 0.75) then
                     ndig = ndsave
                     call fmeq(mxy(4), ma)
                     return
                 endif
             endif
             call fmpi(mxy(6))
             call fmmpyi(mxy(6), 2, mxy(2))
             if (fmcomp(mxy(4), '>=', mxy(2))) then
                 call fmdiv(mxy(4), mxy(2), mxy(1))
                 call fmint(mxy(1), mxy(5))
                 call fmmpy_r1(mxy(5), mxy(2))
                 call fmsub_r1(mxy(4), mxy(5))
             endif
             call fmeq(mxy(6), mxy(3))
             if (fmcomp(mxy(4), '>=', mxy(3))) then
                 jsin = -jsin
                 call fmsub_r2(mxy(2), mxy(4))
             endif
             call fmdivi_r1(mxy(2), 4)
             if (fmcomp(mxy(4), '>=', mxy(2))) then
                 jcos = -jcos
                 call fmsub_r2(mxy(3), mxy(4))
             endif
             call fmdivi_r1(mxy(3), 4)
             if (fmcomp(mxy(4), '>=', mxy(3))) then
                 jswap = 1
                 call fmsub_r2(mxy(2), mxy(4))
             endif

!             If the reduced argument is close to zero, then cancellation has produced an
!             inaccurate value.
!             Raise ndig and do the reduction again.

             if (j == 1 .and. (mxy(4)%mp(2) < 0 .or. mxy(4)%mp(3) == 0)) then
                 j = 2
                 if (mxy(4)%mp(3) == 0) then
                     ndig = 2*ndig
                 else
                     ndig = ndig - int(mxy(4)%mp(2))
                     if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                 endif
                 jsin = 1
                 jcos = 1
                 jswap = 0
             else
                 exit
             endif
          enddo
      else
          call fmequ(ma, mxy(4), ndsave, ndig)
          if (ma%mp(1) < 0) jsin = -1
          mxy(4)%mp(1) = 1
          if (mxy(4)%mp(2) == 0) then
              call fmm2dp(mxy(4), x)
              if (x <= 44.0) then
                  ndig = ndsave
                  call fmeq(mxy(4), ma)
                  return
              endif
          endif
          call fmi2m(360, mxy(2))
          if (fmcomp(mxy(4), '>=', mxy(2))) then
              call fmdiv(mxy(4), mxy(2), mxy(1))
              call fmint(mxy(1), mxy(5))
              call fmmpy_r1(mxy(5), mxy(2))
              call fmsub_r1(mxy(4), mxy(5))
          endif
          call fmi2m(180, mxy(3))
          if (fmcomp(mxy(4), '>=', mxy(3))) then
              jsin = -jsin
              call fmsub_r2(mxy(2), mxy(4))
          endif
          call fmi2m(90, mxy(2))
          if (fmcomp(mxy(4), '>=', mxy(2))) then
              jcos = -jcos
              call fmsub_r2(mxy(3), mxy(4))
          endif
          call fmi2m(45, mxy(3))
          if (fmcomp(mxy(4), '>=', mxy(3))) then
              jswap = 1
              call fmsub_r2(mxy(2), mxy(4))
          endif
      endif

!             Round the result and return.

      call fmequ(mxy(4), ma, ndig, ndsave)
      ndig = ndsave

      return
      end subroutine fmrdc

      subroutine fmread(kread, ma)

!  Read ma on unit kread.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  Only one number is allowed on the line(s).

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: kread
      intent (in) :: kread
      intent (inout) :: ma

      character :: line(132)
      integer :: j, jstat, k, kamper, l2, lb, ndsave
      type(multi), save :: mxy(1)

      call fmalloc(ma, ndig+2)

      if (mblogs /= mbase) call fmcons
      ncall = ncall + 1
      namest(ncall) = 'FMREAD'
      ndsave = ndig
      ndig = max(ndig+ngrd52, 3)
      lb = 0
      kamper = 0

      do
         read (kread, "(132A1)", iostat=jstat) line
         if (jstat /= 0) then
             kflag = -4
             call fmwarn
             ndig = ndsave
             call fmunknown(ma)
             ncall = ncall - 1
             return
         endif

!             Scan the line and look for '&'

         do j = 1, 132
            if (line(j) == '&') then
                kamper = 1
                exit
            endif
            if (line(j) /= ' ') then
                lb = lb + 1
                if (lb > lmbuff) then

!                If cmbuff runs out of space, try to re-allocate it with a bigger size.

                    if (lmbuff > 0) then
                        allocate(move_cmbuff(lmbuff), stat=k)
                        if (k /= 0) then
                            call fmdefine_error
                        endif
                        do k = 1, lmbuff
                           move_cmbuff(k) = cmbuff(k)
                        enddo
                        deallocate(cmbuff)
                        l2 = max(10000, 2*lmbuff)
                        allocate(cmbuff(l2), stat=k)
                        if (k /= 0) then
                            call fmdefine_error
                        endif
                        do k = 1, l2
                           cmbuff(k) = ' '
                        enddo
                        do k = 1, lmbuff
                           cmbuff(k) = move_cmbuff(k)
                        enddo
                        deallocate(move_cmbuff)
                        lmbuff = l2
                    else
                        allocate(cmbuff(10000), stat=jstat)
                        if (jstat /= 0) then
                            call fmdefine_error
                        endif
                        lmbuff = 10000
                    endif
                endif
                cmbuff(lb) = line(j)
            endif
         enddo
         if (kamper == 0) exit
         kamper = 0
      enddo

      ncall = ncall - 1
      call fminp(cmbuff, mxy(1), 1, lb)
      ncall = ncall + 1

      call fmequ(mxy(1), ma, ndig, ndsave)
      ndig = ndsave
      ncall = ncall - 1

      return
      end subroutine fmread

      subroutine fmrnd(mw, nd, nguard, kshift)

!  Round mw to nd digits (base mbase).

!  mw is non-negative and has nd+nguard+kshift digits.

!  nguard is the number of guard digits carried.
!  kshift is 1 if a left shift is pending when the first digit of mw is 0.

!  Round to position mw%mp(nd+2+kshift) using the guard digits
!  mw%mp(nd+3+kshift), ..., mw%mp(nd+2+nguard+kshift).

!  This routine is designed to be called only from within the fm package.
!  The user should call fmequ to round numbers.

      use fmvals
      implicit none

      type(multi) :: mw
      integer :: nd, nguard, kshift
      intent (in) :: nd, kshift, nguard
      intent (inout) :: mw

      real (kind(1.0d0)) :: m2, mkt
      integer :: j, k, kb, kl, kup, l

      l = nd + 2 + kshift
      kup = 0
      do while (kup == 0)
         kup = -1
         if (kround == -1) then
             if (jrsign == 1) return
             kl = 0
             do j = nd+2+kshift, nd+1+nguard+kshift
                if (mw%mp(j+1) > 0) then
                    mw%mp(kshift+nd+2) = mw%mp(kshift+nd+2) + 1
                    mw%mp(kshift+nd+3) = 0
                    if (mw%mp(kshift+nd+2) < mbase) return
                    l = nd + 2 + kshift
                    kl = 1
                    exit
                endif
             enddo
             if (kl == 0) then
                 return
             else
                 exit
             endif
         endif

         if (kround == 2) then
             if (jrsign == -1) return
             kl = 0
             do j = nd+2+kshift, nd+1+nguard+kshift
                if (mw%mp(j+1) > 0) then
                    mw%mp(kshift+nd+2) = mw%mp(kshift+nd+2) + 1
                    mw%mp(kshift+nd+3) = 0
                    if (mw%mp(kshift+nd+2) < mbase) return
                    l = nd + 2 + kshift
                    kl = 1
                    exit
                endif
             enddo
             if (kl == 0) then
                 return
             else
                 exit
             endif
         endif

         if (kround == 0) return
         l = nd + 2 + kshift
         if (2*(mw%mp(l+1)+1) < mbase) return
         if (2*mw%mp(l+1) > mbase) then
             mw%mp(l) = mw%mp(l) + 1
             mw%mp(l+1) = 0
             if (mw%mp(l) < mbase) return
             exit
         endif

!             If the first guard digit gives a value close to 1/2 then further guard digits must
!             be examined.

         m2 = 2
         if (int(mbase-aint (mbase/m2)*m2) == 0) then
             if (2*mw%mp(l+1) < mbase) return
             if (2*mw%mp(l+1) == mbase) then
                 if (nguard >= 2) then
                     kl = 0
                     do j = 2, nguard
                        if (mw%mp(j+l) > 0) then
                            kl = 1
                            exit
                        endif
                     enddo
                     if (kl == 1) then
                         kup = 1
                         exit
                     endif
                 endif

!                       Round to even.

                 if (int(mw%mp(l)-aint (mw%mp(l)/m2)*m2) == 0) return
                 kup = 1
             endif
         else
             if (2*mw%mp(l+1)+1 == mbase) then
                 if (nguard >= 2) then
                     kl = 0
                     do j = 2, nguard
                        if (2*(mw%mp(j+l)+1) < mbase) return
                        if (2*mw%mp(j+l) > mbase) then
                            kl = 1
                            exit
                        endif
                     enddo
                     if (kl == 1) then
                         kup = 1
                         exit
                     endif
                     if (nguard <= ndig) return
                     m2 = 2
                     if (int(mw%mp(l)-aint (mw%mp(l)/m2)*m2) == 0) then
                         return
                     else
                         kup = 1
                     endif
                 endif
             endif
         endif
      enddo

!             Round up.

      if (kup == 1) then
          mw%mp(l) = mw%mp(l) + 1
          mw%mp(l+1) = 0
      endif

!             Check whether there was a carry in the rounded digit.

      kb = l - 1
      if (kb >= 3) then
          k = kb + 1
          do j = 3, kb
             k = k - 1
             if (mw%mp(k+1) < mbase) return
             mkt = aint (mw%mp(k+1)/mbase)
             mw%mp(k) = mw%mp(k) + mkt
             mw%mp(k+1) = mw%mp(k+1) - mkt*mbase
          enddo
      endif

!             If there is a carry in the first digit then the exponent must be adjusted and the
!             number shifted right.

      if (mw%mp(3) >= mbase) then
          if (kb >= 4) then
              k = kb + 1
              do j = 4, kb
                 k = k - 1
                 mw%mp(k+1) = mw%mp(k)
              enddo
          endif

          mkt = aint (mw%mp(3)/mbase)
          if (kb >= 3) mw%mp(4) = mw%mp(3) - mkt*mbase
          mw%mp(3) = mkt
          mw%mp(2) = mw%mp(2) + 1
      endif

      return
      end subroutine fmrnd

      subroutine fmrpwr(ma, ival, jval, mb)

!  mb = ma**(ival/jval)   rational exponentiation.

!  This routine is faster than fmpwr when ival and jval are small integers.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: ival, jval
      intent (in) :: ma, ival, jval
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: ival2, jval2, kovun, kresult, ndsave
      type(multi), save :: mxy(3), mresult
      logical :: retry

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmrpwr_sc(ma, ival, jval, ival2, jval2, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call fmrpwr_m1(ma, ival, jval, ival2, jval2, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmrpwr

      subroutine fmrpwr_m1(ma, ival, jval, ival2, jval2, mxy, mresult, ndsave)

!  Method 1 for computing ma**(ival/jval).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(3), mresult
      integer :: ival, jval, ival2, jval2, ndsave
      intent (in) :: ma, ival, jval, ival2, jval2, ndsave
      intent (inout) :: mxy, mresult

      double precision :: x, f
      real (kind(1.0d0)) :: ma1
      integer :: nstack(49), ijsign, invert, j, kst, l, lval

      call fmequ(ma, mxy(1), ndsave, ndig)
      ijsign = 1
      if (ival > 0 .and. jval < 0) ijsign = -1
      if (ival < 0 .and. jval > 0) ijsign = -1

!             Invert ma if ma > 1 and ival or jval is large.

      invert = 0
      if (ma%mp(2) > 0) then
          if (ival > 5 .or. jval > 5) then
              invert = 1
              call fmi2m(1, mxy(2))
              call fmdiv_r2(mxy(2), mxy(1))
          endif
      endif

!             Generate the first approximation to abs(ma)**(1/jval2).

      ma1 = mxy(1)%mp(2)
      mxy(1)%mp(2) = 0
      mxy(1)%mp(1) = 1
      call fmm2dp(mxy(1), x)
      l = int(ma1/jval2)
      f = ma1/dble(jval2) - l
      x = x**(1.0d0/jval2) * dble(mbase)**f
      call fmdpm(x, mresult)
      mresult%mp(2) = mresult%mp(2) + l
      mxy(1)%mp(2) = ma1

!             Initialize.

      call fmi2m(0, mxy(3))
      call fmdig(nstack, kst)

!             Newton iteration.

      do j = 1, kst
         ndig = nstack(j)
         if (j < kst) ndig = ndig + 1
         lval = jval2 - 1
         call fmipwr(mresult, lval, mxy(3))
         call fmdiv_r2(mxy(1), mxy(3))
         call fmmpyi_r1(mresult, lval)
         call fmadd_r1(mresult, mxy(3))
         call fmdivi_r1(mresult, jval2)
      enddo

      if (ma%mp(1) < 0) call fmnegate(mresult)
      call fmipwr(mresult, ijsign*ival2, mxy(3))
      call fmeq(mxy(3), mresult)
      if (invert == 1) then
          call fmi2m(1, mxy(2))
          call fmdiv_r2(mxy(2), mresult)
      endif

      return
      end subroutine fmrpwr_m1

      subroutine fmrpwr_sc(ma, ival, jval, ival2, jval2, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = ma**(ival/jval)

!  kresult = 1 is returned if a special case gives the value of rpwr(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(3), mresult
      integer :: ival, jval, ival2, jval2, kresult, ndsave
      intent (in) :: ma, ival, jval, ndsave
      intent (inout) :: ival2, jval2, mxy, mresult, kresult

      real (kind(1.0d0)) :: ma2
      double precision :: b, xe, xe1, xf, xf1, ye, yf, z1, z2
      integer :: ijsign, j

      kresult = 0

      namest(ncall) = 'FMRPWR   '
      j = ndig
      ndig = ndsave
      call fmntr_inp1ii(ma, ival, jval)
      ndig = j

      call fmequ(ma, mxy(1), ndsave, ndig)

      if (mxy(1)%mp(2) == munkno .and. mxy(1)%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

!             Use gcd-reduced positive exponents.

      ijsign = 1
      ival2 = abs(ival)
      jval2 = abs(jval)
      if (ival > 0 .and. jval < 0) ijsign = -1
      if (ival < 0 .and. jval > 0) ijsign = -1
      if (ival2 > 0 .and. jval2 > 0) call fmgcdi(ival2, jval2)
      ma2 = ma%mp(3)

      if ((ma%mp(2) == munkno .and. ma%mp(5) >= 0) .or. jval2 == 0 .or.  &
          (ijsign <= 0 .and. ma2 == 0)) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      if (ival2 == 0) then
          call fmi2m2(1, mresult)
          kresult = 1
          return
      endif

      if (jval2 == 1) then
          call fmipwr(mxy(1), ijsign*ival2, mresult)
          kresult = 1
          return
      endif

      if (ma2 == 0) then
          call fmeq(ma, mresult)
          kresult = 1
          return
      endif

      if (ma%mp(1) < 0) then
          if (mod(jval2, 2) == 0) then
              jval2 = 0
              call fmunknown(mresult)
              kresult = 1
              return
          else
              mxy(1)%mp(1) = 1
          endif
      endif

      call fmi2m(ival2, mxy(2))
      call fmdivi_r1(mxy(2), jval2)
      if (abs(ma%mp(2)) >= mexpov) then
          if (ijsign == -1) call fmmpyi_r1(mxy(2), ijsign)
          call fmovun_pwr(mxy(1), mxy(2), mresult)
          if (ma%mp(1) < 0 .and. mod(ival2, 2) /= 0 .and. mod(jval2, 2) /= 0) then
              if (mresult%mp(2) /= munkno .or. mresult%mp(5) < 0) mresult%mp(1) = -1
          endif
          kresult = 1
          return
      else
          if (size(ma%mp) >= 5) then
              if (ma%mp(5) < 0) then
                  xe = ma%mp(4)
                  xf = ma%mp(5)
                  xf = -xf/maxint
              else
                  xe = abs(ma%mp(2))
                  call fmovun_frac(ma, xf)
              endif
          else
              xe = abs(ma%mp(2))
              call fmovun_frac(ma, xf)
          endif
          if (size(mxy(2)%mp) >= 5) then
              if (mxy(2)%mp(5) < 0) then
                  ye = mxy(2)%mp(4)
                  yf = mxy(2)%mp(5)
                  yf = -yf/maxint
              else
                  ye = abs(mxy(2)%mp(2))
                  call fmovun_frac(mxy(2), yf)
              endif
          else
              ye = abs(mxy(2)%mp(2))
              call fmovun_frac(mxy(2), yf)
          endif
          b = mbase
          xe1 = xe
          xf1 = xf
          if (xe <= 0) then
              xe1 = -xe
              xf1 = 1.0d0/xf
          endif
          z1 = ye*log(b) + log(yf) + log(xe1*log(b) + log(xf1))
          z2 = log(dble(mxexp2)) + log(log(b))
          if (z1 >= z2 .and. mxy(2)%mp(2) > 0) then
              if (ijsign == -1) call fmmpyi_r1(mxy(2), ijsign)
              call fmovun_pwr(mxy(1), mxy(2), mresult)
              if (ma%mp(1) < 0 .and. mod(ival2, 2) /= 0 .and. mod(jval2, 2) /= 0) then
                  if (mresult%mp(2) /= munkno) mresult%mp(1) = -1
              endif
              kresult = 1
              return
          endif
      endif

      return
      end subroutine fmrpwr_sc

      subroutine fms(ma, mb)

!  mb = s(ma)    Fresnel Sine Integral.

!  Integral from 0 to ma of sin(pi*t**2/2) dt.


      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(16), mresult, mretry

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fms_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      n_acc = nint(ndig*alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fms_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc)
         if (ma%mp(1) == -1) call fmnegate(mresult)
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fms

      subroutine fms_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc)

!  Method selection for computing s(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(16), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc

      double precision :: x, xe, y
      integer :: iextra, jr, kflagx, nmethd
      logical, external :: fmcomp

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, ndig)
      call fmeq(mxy(1), mxy(13))
      mxy(1)%mp(1) = 1
      n_acc = nint(ndig*alogm2)

!             Check for special cases.

      if (mxy(1)%mp(3) == 0) then
          call fmeq(mxy(1), mresult)
          retry = .false.
          return
      endif
      call fmovun_xe(mxy(1), xe)
      if (4*xe < -ndig) then
          call fmsqr(mxy(1), mxy(11))
          call fmmpy_r2(mxy(1), mxy(11))
          call fmpi(mxy(3))
          call fmdivi(mxy(3), 6, mxy(4))
          call fmmpy_r1(mxy(11), mxy(4))
          call fmeq(mxy(11), mresult)
          return
      endif
      call fmint(mxy(1), mxy(8))
      if (xe > ndig .and. fmcomp(mxy(1), '==', mxy(8)) .and. mxy(1)%mp(2) /= mexpov) then
          call fmi2m(1, mxy(8))
          if (mxy(1)%mp(1) < 0) then
              call fmdivi(mxy(8), -2, mxy(11))
          else
              call fmdivi(mxy(8), 2, mxy(11))
          endif
          call fmpi(mxy(6))
          call fmmpy_r1(mxy(6), mxy(1))
          call fmdiv_r2(mxy(8), mxy(6))
          jr = kround
          if (kround == -1 .and. ma%mp(1) < 0) kround =  2
          if (kround ==  2 .and. ma%mp(1) < 0) kround = -1
          call fmsub_r1(mxy(11), mxy(6))
          kround = jr
          call fmeq(mxy(11), mresult)
          retry = .false.
          return
      endif
      call fmovun_xe(mxy(1), xe)
      if (xe > ndig) then
          call fmi2m(1, mxy(8))
          if (mxy(1)%mp(1) < 0) then
              call fmdivi(mxy(8), -2, mxy(11))
          else
              call fmdivi(mxy(8), 2, mxy(11))
          endif
          call fmeq(mxy(11), mresult)
          return
      endif

!             x is a double precision approximation to the input argument to this function.

      call fmm2dp(mxy(1), x)
      kflagx = kflag
      call fmovun_xe(mxy(1), xe)
      if (kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif

!             If ma is large in magnitude, use more guard digits.

      iextra = min(max(int(mxy(1)%mp(2)), 0) , int(2.0+alogmx/alogmb))
      if (abs(mxy(1)%mp(2)) >= mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(1), ndig, ndig+iextra)
      endif
      ndig = ndig + iextra
      n_acc = nint(ndig*alogm2)

!             Determine which method to use.

!             nmethd = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      if (kflagx == 0) then
          if (abs(x) < sqrt(huge(x)/(4*log(huge(x))))) then
              y = (dppi*x*x-1)/2
              y = (2*y+1.5)*log(2*y+2) - (2*y+1) - y*dlogtw - (y+0.5)*log(y+1) + y - y*log(dppi*x*x)
              if (y <= -(ndig+1)*dlogmb) then
                  nmethd = 2
              else
                  nmethd = 1
              endif
          else
              nmethd = 2
          endif
      else
          call fmovun_xe(mxy(1), xe)
          if (xe <= 0) then
              nmethd = 1
          else
              nmethd = 2
          endif
      endif

      if (nmethd == 1) then
          call fms_m1(mxy, mresult, ndsave, numtry, n_acc, kflagx, x)
      else if (nmethd == 2) then
          call fms_m2(mxy, mresult, ndsave, numtry, n_acc)
      endif

      return
      end subroutine fms_m

      subroutine fms_m1(mxy, mresult, ndsave, numtry, n_acc, kflagx, x)

!  Method 1 for computing s(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(16), mresult
      integer :: ndsave, numtry, n_acc, kflagx
      double precision :: x
      intent (in) :: numtry, ndsave, kflagx, x
      intent (inout) :: mxy, mresult, n_acc

      double precision :: xe
      integer :: iextra, j, j2, k, kl, large, nbot, ndsav1, nterm
      type(multi), save :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 1.  Use x times the series (-1)**n*(pi*x*x/2)**(2*n+1)/((4*n+3)*(2*n+1)!).

!             mxy(6) is the current term
!             mxy(9) is pi*x*x/2

      iextra = 0
      if (kflagx == 0) then
          iextra = max(0.0d0, (0.096*x*x + 0.033*abs(x) - 0.5)*log(1.0e7)/alogmb)*1.02
          if (iextra > 0) then
              call fmequ_r1(mxy(1), ndig, ndig+iextra)
          endif
      endif
      ndig = ndig + iextra
      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig-1)
      endif
      n_acc = nint(ndig*alogm2)

      if (kflagx == 0) then
          j2 = int(0.68*sqrt(fmnterms(3.14159d0*x*x/2, 2, 0, 0, 1)) - 1.6)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = ndig

!             Split into j2 concurrent sums.

      call fmsqr(mxy(1), mxy(4))
      call fmcsdivi(mxy(4), 2, mxy(9))
      call fmpi(mxy(3))
      call fmcsmpy_r1(mxy(9), mxy(3))
      call fmi2m(1, mxy(6))
      call fmcsdivi(mxy(6), 3, mjsums(1))
      nterm = 0
      do j = 2, j2
         nterm = nterm + 2
         nbot = nterm*(nterm+1)
         large = int(intmax/nterm)
         if (nterm > large .or. nbot > mxbase) then
             call fmcsdivi_r1(mxy(6), nterm)
             call fmcsdivi_r1(mxy(6), nterm+1)
         else
             call fmcsdivi_r1(mxy(6), nbot)
         endif
         call fmcsdivi(mxy(6), 2*nterm+3, mjsums(j))
      enddo
      call fmovun_xe(mxy(1), xe)
      if (xe < -ndig) then
          kl = 0
      else
          call fmipwr(mxy(9), 2*j2, mxy(7))
          kl = 1
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(6), mxy(7))
         do j = 1, j2
            nterm = nterm + 2
            large = int(intmax/nterm)
            if (nterm > large .or. nterm > mxbase/(nterm-1)) then
                call fmcsdivi_r1(mxy(6), nterm)
                call fmcsdivi_r1(mxy(6), nterm+1)
            else
                nbot = nterm*(nterm+1)
                call fmcsdivi_r1(mxy(6), nbot)
            endif
            call fmcsdivi(mxy(6), 2*nterm+3, mxy(2))
            ndig = ndsav1
            call fmcsaddnn_r1(mjsums(j), mxy(2))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            ndig = ndsav1 - int(mjsums(j)%mp(2)-mxy(6)%mp(2))
            ndig = min(ndsav1, ndig)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         enddo
         if (kl == 0) exit
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call fmcsnsums(j2, mjsums)
      call fmsqr(mxy(9), mxy(8))
      mxy(8)%mp(1) = -1
      if (mjsums(1)%mp(1) > 0) then
          call fmeq(mjsums(1), mxy(15))
          call fmi2m(0, mxy(16))
      else
          call fmeq(mjsums(1), mxy(16))
          call fmi2m(0, mxy(15))
      endif
      call fmeq(mxy(8), mxy(12))
      do j = 1, j2-1
         call fmmpy(mxy(12), mjsums(j+1), mxy(3))
         if (mxy(3)%mp(1) > 0) then
             call fmadd_r1(mxy(15), mxy(3))
         else
             call fmadd_r1(mxy(16), mxy(3))
         endif
         call fmmpy_r1(mxy(12), mxy(8))
      enddo
      call fmadd(mxy(15), mxy(16), mxy(11))
      call fmcancel(mxy(15), mxy(16), mxy(11), k)
      n_acc = n_acc - k
      call fmcsmpy_r1(mxy(11), mxy(1))
      call fmcsmpy_r1(mxy(11), mxy(9))

      call fmeq(mxy(11), mresult)

      return
      end subroutine fms_m1

      subroutine fms_m2(mxy, mresult, ndsave, numtry, n_acc)

!  Method 2 for computing s(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(16), mresult
      integer :: ndsave, numtry, n_acc
      intent (in) :: ndsave, numtry
      intent (inout) :: mxy, mresult, n_acc

      integer :: krsave

!             Method 2.  Use the two n!/x**n asymptotic series for f(x) and g(x).
!                        Then s(x) = 0.5 - f(x)*cos(pi*x*x/2) - g(x)*sin(pi*x*x/2).

      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig-1)
      endif
      n_acc = nint(ndig*alogm2)
      call fmfgfi(mxy(1), mxy(12), mxy(13))
      call fmsqr(mxy(1), mxy(4))
      krsave = krad
      krad = 0
      call fmmpyi(mxy(4), 90, mxy(7))
      call fmcssn(mxy(7), mxy(14), mxy(10))
      krad = krsave
      if (mxy(1)%mp(2) == munkno .and. mxy(1)%mp(5) < 0 .and.        &
          ( (mxy(14)%mp(2) == munkno .and. mxy(14)%mp(5) >= 0) .or.  &
            (mxy(10)%mp(2) == munkno .and. mxy(10)%mp(5) >= 0) )) then
          call fmunknown(mxy(11))
          mxy(11)%mp(4) = 0
          mxy(11)%mp(5) = -maxint * 0.5d0
      else
          call fmmpy(mxy(12), mxy(14), mxy(11))
          call fmmpy(mxy(13), mxy(10), mxy(7))
          call fmi2m(1, mxy(4))
          call fmdivi(mxy(4), 2, mxy(5))
          call fmsub(mxy(5), mxy(11), mxy(6))
          call fmsub(mxy(6), mxy(7), mxy(11))
      endif

      call fmeq(mxy(11), mresult)

      return
      end subroutine fms_m2

      subroutine fms_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = s(ma).

!  kresult = 1 is returned if a special case gives the value of s(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMS      '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      return
      end subroutine fms_sc

      subroutine fmsetvar(string)

!  Change the value of one of the internal fm variables.
!  string must have the format  ' variablename = value ', with no embedded blanks in variablename.

      use fmvals
      implicit none
      character(*) :: string
      intent (in) :: string

      character(9) :: varname
      integer :: ival, j, kpteq, kpt1, kpt2
      double precision :: dval
      real (kind(1.0d0)) :: mval

      character(52) :: letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'

!             Find the equal sign.

      kpteq = index(string, '=')
      if (kpteq <= 0) then
          write (kw,*) ' '
          write (kw,*) ' Cannot find the equal sign in FMSETVAR.'
          write (kw,*) ' Input string:  ', string
          return
      endif

!             Find the variable name.

      kpt1 = 0
      kpt2 = 0
      do j = 1, kpteq-1
         if (kpt1 == 0 .and. string(j:j) /= ' ') kpt1 = j
      enddo
      do j = kpteq-1, 1, -1
         if (kpt2 == 0 .and. string(j:j) /= ' ') kpt2 = j
      enddo
      if (kpt1 == 0) then
          write (kw,*) ' '
          write (kw,*) ' Cannot find the variable name in FMSETVAR.'
          write (kw,*) ' Input string:  ', string
          return
      endif

!             Convert any lower case letters to upper case in the variable name, for name matching.

      varname = ' '
      do j = kpt1, kpt2
         ival = index(letters, string(j:j))
         if (ival > 26 .and. ival <= 52) then
             varname(j-kpt1+1:j-kpt1+1) = letters(ival-26:ival-26)
         else
             varname(j-kpt1+1:j-kpt1+1) = string(j:j)
         endif
      enddo

!             cmchar is a special case, since the value is a character.

      if (varname == 'CMCHAR') then
          kpt1 = 0
          kpt2 = 0
          do j = kpteq+1, len(string)
             if (kpt1 == 0 .and. string(j:j) /= ' ') kpt1 = j
          enddo
          do j = len(string), kpteq+1, -1
             if (kpt2 == 0 .and. string(j:j) /= ' ') kpt2 = j
          enddo
          if (kpt1 == kpt2 .and. index(letters, string(kpt1:kpt2)) > 0) then
              cmchar = string(kpt1:kpt2)
              return
          else
              write (kw,*) ' '
              write (kw,*) ' Only a single letter is allowed after the equal sign in FMSETVAR.'
              write (kw,*) ' Input string:  ', string
              return
          endif
      endif

!             Convert the value after the equal sign.

      if (kpteq+1 <= len(string)) then
          if (index(string(kpteq+1:len(string)), '=') /= 0) then
              write (kw,*) ' '
              write (kw,*) ' Only a single equal sign is allowed in FMSETVAR.'
              write (kw,*) ' Input string:  ', string
              return
          endif
          call fmst2d(string(kpteq+1:len(string)), dval)
          if (kflag /= 0) then
              write (kw,*) ' '
              write (kw,*) ' Invalid value after the equal sign in FMSETVAR.'
              write (kw,*) ' Input string:  ', string
              return
          endif
      else
          write (kw,*) ' '
          write (kw,*) ' Cannot find a value after the equal sign in FMSETVAR.'
          write (kw,*) ' Input string:  ', string
          return
      endif

!             Check the list of variable names.

      if (varname == 'JFORM1') then
          jform1 = nint(dval)
          if (jform1 < 0 .or. jform1 > 2) then
              write (kw,*) ' '
              write (kw,*) ' FMSETVAR:  Input string:  ', string
              write (kw,*) '            ', jform1, ' is an invalid value for JFORM1'
              jform1 = 1
              write (kw,*) '            Valid values are 0, 1, 2.  JFORM1 was set to ', jform1
          endif
      else if (varname == 'JFORM2') then
          jform2 = nint(dval)
          if (jform2 < 0) then
              write (kw,*) ' '
              write (kw,*) ' FMSETVAR:  Input string:  ', string
              write (kw,*) '            ', jform2, ' is an invalid value for JFORM2'
              jform2 = 1
              write (kw,*) '            It should be nonnegative.  JFORM2 was set to ', jform2
          endif
      else if (varname == 'JFORMZ') then
          jformz = nint(dval)
          if (jformz < 1 .or. jformz > 3) then
              write (kw,*) ' '
              write (kw,*) ' FMSETVAR:  Input string:  ', string
              write (kw,*) '            ', jformz, ' is an invalid value for JFORMZ'
              jformz = 1
              write (kw,*) '            Valid values are 1, 2, 3.  JFORMZ was set to ', jformz
          endif
      else if (varname == 'JPRNTZ') then
          jprntz = nint(dval)
          if (jprntz < 1 .or. jprntz > 2) then
              write (kw,*) ' '
              write (kw,*) ' FMSETVAR:  Input string:  ', string
              write (kw,*) '            ', jprntz, ' is an invalid value for JPRNTZ'
              jprntz = 1
              write (kw,*) '            Valid values are 1, 2.  JPRNTZ was set to ', jprntz
          endif
      else if (varname == 'KESWCH') then
          keswch = nint(dval)
          if (keswch < 0 .or. keswch > 1) then
              write (kw,*) ' '
              write (kw,*) ' FMSETVAR:  Input string:  ', string
              write (kw,*) '            ', keswch, ' is an invalid value for KESWCH'
              keswch = 1
              write (kw,*) '            Valid values are 0, 1.  KESWCH was set to ', keswch
          endif
      else if (varname == 'KRAD') then
          krad = nint(dval)
          if (krad < 0 .or. krad > 1) then
              write (kw,*) ' '
              write (kw,*) ' FMSETVAR:  Input string:  ', string
              write (kw,*) '            ', krad, ' is an invalid value for KRAD'
              krad = 1
              write (kw,*) '            Valid values are 0, 1.  KRAD was set to ', krad
          endif
      else if (varname == 'KROUND') then
          kround = nint(dval)
          if (kround < -1 .or. kround > 2) then
              write (kw,*) ' '
              write (kw,*) ' FMSETVAR:  Input string:  ', string
              write (kw,*) '            ', kround, ' is an invalid value for KROUND'
              kround = 1
              write (kw,*) '            Valid values are -1, 0, 1, 2.  KROUND was set to ', kround
          endif
      else if (varname == 'KRPERF') then
          write (kw,*) ' '
          write (kw,*) ' FMSETVAR:  Input string:  ', string
          write (kw,*) '            KRPERF is no longer used.  Now perfect rounding is ',  &
                       'always done.'
          write (kw,*) ' '
      else if (varname == 'KSWIDE') then
          kswide = nint(dval)
          if (kswide < 10) then
              write (kw,*) ' '
              write (kw,*) ' FMSETVAR:  Input string:  ', string
              write (kw,*) '            ', kswide, ' is an invalid value for KSWIDE'
              kswide = 80
              write (kw,*) '            It should be 10 or more.  KSWIDE was set to ', kswide
          endif
      else if (varname == 'KW') then
          kw = nint(dval)
      else if (varname == 'KWARN') then
          kwarn = nint(dval)
          if (kwarn < 0 .or. kwarn > 2) then
              write (kw,*) ' '
              write (kw,*) ' FMSETVAR:  Input string:  ', string
              write (kw,*) '            ', kwarn, ' is an invalid value for KWARN'
              kwarn = 1
              write (kw,*) '            Valid values are 0, 1, 2.  KWARN was set to ', kwarn
          endif
      else if (varname == 'LVLTRC') then
          lvltrc = nint(dval)
          if (lvltrc < 0) then
              write (kw,*) ' '
              write (kw,*) ' FMSETVAR:  Input string:  ', string
              write (kw,*) '            ', lvltrc, ' is an invalid value for LVLTRC'
              lvltrc = 1
              write (kw,*) '            It should be nonnegative.  LVLTRC was set to ', lvltrc
          endif
      else if (varname == 'NDIG') then
          ival = ndig
          ndig = nint(dval)
          if (ndig < 3) then
              write (kw,*) ' '
              write (kw,*) ' FMSETVAR:  Input string:  ', string
              write (kw,*) '            ', ndig, ' is an invalid value for NDIG'
              ndig = ival
              write (kw,*) '            It should be > 2.  NDIG was not changed from ', ndig
              kflag = -1
          endif
      else if (varname == 'NTRACE') then
          ntrace = nint(dval)
          if (ntrace < -2 .or. ntrace > 2) then
              write (kw,*) ' '
              write (kw,*) ' FMSETVAR:  Input string:  ', string
              write (kw,*) '            ', ntrace, ' is an invalid value for NTRACE'
              ntrace = 0
              write (kw,*) '            Valid values are -2, -1, 0, 1, 2.  NTRACE was set to ',  &
                           ntrace
          endif
      else if (varname == 'MBASE') then
          mval = mbase
          mbase = aint (0.5 + dval)
          if (mbase < 2) then
              write (kw,*) ' '
              write (kw,*) ' FMSETVAR:  Input string:  ', string
              write (kw,*) '            ', mbase, ' is an invalid value for MBASE'
              mbase = mval
              write (kw,*) '            It should be > 1.  MBASE was not changed from ', mbase
              kflag = -2
          endif
          if (mbase > mxbase) then
              write (kw,*) ' '
              write (kw,*) ' FMSETVAR:  Input string:  ', string
              write (kw,*) '            ', mbase, ' is an invalid value for MBASE'
              mbase = mval
              write (kw,*) '            It should be <= ', mxbase,  &
                           '.  MBASE was not changed from ', mbase
              kflag = -2
          endif
      else if (varname == 'MXEXP') then
          mxexp = aint (dval)
          if (mxexp < 10 .or. mxexp > mxexp2/2.01d0) then
              write (kw,*) ' '
              write (kw,*) ' FMSETVAR:  Input string:  ', string
              write (kw,*) '            ', mxexp, ' is an invalid value for MXEXP'
              mxexp = int(mxexp2/2.01d0)
              write (kw,*) '            Valid values are 10 to ',  &
                           int(mxexp2/2.01d0), '  MXEXP was set to ', mxexp
          endif
      else
          write (kw,*) ' Variable name not recognized in FMSETVAR.'
          write (kw,*) ' Input string:  ', string
          return
      endif

      call fmcons

      return
      end subroutine fmsetvar

      subroutine fmshi(ma, mb)

!  mb = hyperbolic sine integral(ma)

!  Integral from 0 to ma of sinh(t) / t  dt.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(12), mresult, mretry

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmshi_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      n_acc = nint(ndig*alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmshi_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc)
         if (ma%mp(1) == -1) mresult%mp(1) = -1
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmshi

      subroutine fmshi_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc)

!  Method selection for computing shi(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(12), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc

      double precision :: d, x, xe, y
      integer :: iextra, kflagx, nmethd

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, ndig)
      mxy(1)%mp(1) = 1
      n_acc = nint(ndig*alogm2)

!             x is a double precision approximation to the input argument to this function.

      call fmm2dp(mxy(1), x)
      kflagx = kflag
      call fmovun_xe(mxy(1), xe)
      if (kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif

!             Check for special cases.

      if (mxy(1)%mp(3) == 0) then
          call fmi2m(0, mresult)
          retry = .false.
          return
      else if (mxy(1)%mp(2) == mexpun) then
          call fmeq(mxy(1), mresult)
          retry = .false.
          return
      else if (mxy(1)%mp(2) == mexpov) then
          call fmoverflow(1, mxy(8))
          if (huge(mbase)/mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          mxy(8)%mp(4) = huge(mbase)/d
          mxy(8)%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))
          kflag = -5
          call fmeq(mxy(8), mresult)
          retry = .false.
          return
      endif

!             If ma is large in magnitude, use more guard digits.

      iextra = min(max(int(mxy(1)%mp(2)), 0) , int(2.0+alogmx/alogmb))
      if (abs(mxy(1)%mp(2)) >= mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(1), ndig, ndig+iextra)
      endif
      ndig = ndig + iextra

!             Determine which method to use.

!             nmethd = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      nmethd = 1
      if (kflagx /= 0) then
          call fmovun_xe(mxy(1), xe)
          if (xe <= 0) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          y = (ndig+5)*dlogmb
          if (abs(x) > y+(dlogtp+log(y))/2.0d0) nmethd = 2
      endif

      if (nmethd == 1) then
          call fmshi_m1(mxy, mresult, ndsave, numtry, kflagx, x)
      else if (nmethd == 2) then
          call fmshi_m2(mxy, mresult, ndsave, numtry)
      endif
      if (ma%mp(1) == -1) call fmnegate(mresult)

      return
      end subroutine fmshi_m

      subroutine fmshi_m1(mxy, mresult, ndsave, numtry, kflagx, x)

!  Method 1 for computing shi(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(12), mresult
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: numtry, ndsave, kflagx, x
      intent (inout) :: mxy, mresult

      double precision :: xe
      integer :: j, j2, kl, large, nbot, ndsav1, nterm
      type(multi), save :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 1.  Use the x**(2*n+1)/((2*n+1)*(2*n+1)!) series.

      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig-1)
      endif
      if (kflagx == 0) then
          j2 = int(0.62*sqrt(fmnterms(x, 2, 0, 0, 1)) - 1.3)
          j2 = max(1, min(ljsums, j2))
      else
          j2 = 2
      endif
      ndsav1 = ndig

!             Split into j2 concurrent sums.

      call fmeq(mxy(1), mxy(7))
      call fmeq(mxy(1), mjsums(1))
      nterm = 1
      do j = 2, j2
         nterm = nterm + 2
         nbot = nterm*(nterm-1)
         large = int(intmax/nterm)
         if (nterm > large .or. nbot > mxbase) then
             call fmcsdivi_r1(mxy(7), nterm)
             call fmcsdivi_r1(mxy(7), nterm-1)
         else
             call fmcsdivi_r1(mxy(7), nbot)
         endif
         call fmcsdivi(mxy(7), nterm, mjsums(j))
      enddo
      call fmovun_xe(mxy(1), xe)
      if (xe < -ndig) then
          kl = 0
      else
          kl = 1
          call fmipwr(mxy(1), 2*j2, mxy(5))
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(7), mxy(5))
         do j = 1, j2
            nterm = nterm + 2
            large = int(intmax/nterm)
            if (nterm > large .or. nterm > mxbase/(nterm-1)) then
                call fmcsdivi_r1(mxy(7), nterm)
                call fmcsdivi_r1(mxy(7), nterm-1)
            else
                nbot = nterm*(nterm-1)
                call fmcsdivi_r1(mxy(7), nbot)
            endif
            call fmcsdivi(mxy(7), nterm, mxy(4))
            ndig = ndsav1
            call fmcsaddnn_r1(mjsums(j), mxy(4))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            ndig = ndsav1 - int(mjsums(j)%mp(2)-mxy(4)%mp(2))
            ndig = min(ndsav1, ndig)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         enddo
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call fmcsnsums(j2, mjsums)
      call fmeq(mjsums(j2), mxy(8))
      if (j2 >= 2) then
          call fmsqr(mxy(1), mxy(6))
          do j = 2, j2
             call fmcsmpy_r1(mxy(8), mxy(6))
             call fmadd_r1(mxy(8), mjsums(j2-j+1))
          enddo
      endif

      call fmeq(mxy(8), mresult)

      return
      end subroutine fmshi_m1

      subroutine fmshi_m2(mxy, mresult, ndsave, numtry)

!  Method 2 for computing shi(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(12), mresult
      integer :: ndsave, numtry
      intent (in) :: ndsave, numtry
      intent (inout) :: mxy, mresult

!             Method 2.  Use the two n!/x**n asymptotic series for f(x) and g(x).
!                        Then Shi(x) = f(x)*cosh(x) + g(x)*sinh(x).

      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig-2)
      endif
      call fmfhgh(mxy(1), mxy(9), mxy(10))
      call fmchsh(mxy(1), mxy(11), mxy(12))
      if (mxy(11)%mp(2) < mexpov) then
          call fmmpy(mxy(9), mxy(11), mxy(2))
          call fmmpy(mxy(10), mxy(12), mxy(3))
          call fmadd(mxy(2), mxy(3), mxy(8))
      else
          call fmadd(mxy(9), mxy(10), mxy(5))
          call fmdivi_r1(mxy(5), 2)
          call fmln(mxy(5), mxy(8))
          call fmadd(mxy(1), mxy(8), mxy(5))
          call fmexp(mxy(5), mxy(8))
      endif

      call fmeq(mxy(8), mresult)

      return
      end subroutine fmshi_m2

      subroutine fmshi_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = shi(ma).

!  kresult = 1 is returned if a special case gives the value of shi(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(12), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j, k, kl, krsave, nds
      double precision :: xe, ye
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMSHI    '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      k = 0
      if (kround /= 1) then
          j = ntrace
          ntrace = 0
          kl = kwarn
          kwarn = 0
          call fmsqr(malocal, mxy(1))
          call fmdivi(mxy(1), 18, mxy(2))
          call fmovun_xe(mxy(2), xe)
          if (xe < -ndig) k = 1
          ntrace = j
          kwarn = kl
      endif
      if (kround /= 1 .and. k == 1) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          krsave = kround
          kround = 1
          nds = ndig
          ndig = ndig + ngrd52
          call fmequ(malocal, mxy(1), nds, ndig)
          call fmsqr(mxy(1), mxy(2))
          call fmmpy(mxy(1), mxy(2), mxy(3))
          call fmdivi(mxy(3), 18, mxy(5))
          call fmeq(mxy(1), mxy(4))
          call fmovun_xe(mxy(4), xe)
          call fmovun_xe(mxy(5), ye)
          if (xe - ye > ndig .and. mxy(4)%mp(2) > mexpun) then
              call fmequ(mxy(4), mxy(10), ndig, nds)
              call fmequ(mxy(4), mxy(6), ndig, nds)
              call fmequ(mxy(6), mxy(8), nds, ndig)
              call fmsub(mxy(4), mxy(8), mxy(6))
              if (mxy(6)%mp(3) == 0) then
                  call fmequ(mxy(4), mxy(6), ndig, nds)
                  call fmequ(mxy(5), mxy(7), ndig, nds)
                  ndig = nds
                  kround = krsave
                  call fmadd(mxy(6), mxy(7), mxy(9))
                  if (mxy(9)%mp(2) >= mexpov) then
                      if (mxy(6)%mp(1) > 0) then
                          if (mxy(7)%mp(1) < 0 .and. (kround == -1 .or. kround == 0)) then
                              call fmeq(mxy(6), mxy(1))
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2))
                              call fmsub(mxy(1), mxy(2), mxy(3))
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mxy(9))
                          else if (mxy(7)%mp(1) > 0 .and. kround == 2) then
                              call fmeq(mxy(6), mxy(1))
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2))
                              call fmadd(mxy(1), mxy(2), mxy(3))
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mxy(9))
                          else
                              kround = krsave
                              call fmeq(mxy(10), mxy(9))
                          endif
                      else
                          if (mxy(7)%mp(1) < 0 .and. kround == -1) then
                              call fmeq(mxy(6), mxy(1))
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2))
                              call fmadd(mxy(1), mxy(2), mxy(3))
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mxy(9))
                          else if (mxy(7)%mp(1) > 0 .and. (kround == 2 .or. kround == 0)) then
                              call fmeq(mxy(6), mxy(1))
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2))
                              call fmsub(mxy(1), mxy(2), mxy(3))
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mxy(9))
                          else
                              kround = krsave
                              call fmeq(mxy(10), mxy(9))
                          endif
                      endif
                  endif
                  call fmequ(mxy(9), mresult, ndig, nds)
              else
                  kround = krsave
                  call fmequ(mxy(4), mresult, ndig, nds)
              endif
              if (ma%mp(1) == -1) mresult%mp(1) = -1
              kflag = 0
              ntrace = j
              kwarn = k
              ndig = nds
              kround = krsave
              kresult = 1
              return
          endif
          kflag = 0
          ntrace = j
          kwarn = k
          ndig = nds
          kround = krsave
      endif

      return
      end subroutine fmshi_sc

      subroutine fmsi(ma, mb)

!  mb = sine integral(ma)

!  Integral from 0 to ma of sin(t) / t  dt.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(13), mresult, mretry

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmenter_sp(ndsave)
      call fmsi_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      n_acc = nint(ndig*alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call fmsi_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc)
         if (ma%mp(1) < 0) mresult%mp(1) = -1
         if (retry) then
             retry = .false.
             call fmcheck_accuracy(mresult, ndsave, retry)
             if (.not. retry) then
                 call fmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)
             endif
         endif
         numtry = numtry + 1
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmsi

      subroutine fmsi_m(ma, mxy, mresult, ndsave, numtry, retry, n_acc)

!  Method selection for computing shi(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc

      double precision :: x, xe, y
      integer :: iextra, kflagx, nmethd

      retry = .true.

      call fmequ(ma, mxy(1), ndsave, ndig)
      mxy(1)%mp(1) = 1
      n_acc = nint(ndig*alogm2)

!             x is a double precision approximation to the input argument to this function.

      call fmm2dp(mxy(1), x)
      kflagx = kflag
      call fmovun_xe(mxy(1), xe)
      if (kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax
          if (mxy(1)%mp(1) < 0) x = -x
          kflagx = 0
      endif

!             Check for special cases.

      if (mxy(1)%mp(3) == 0) then
          call fmi2m(0, mresult)
          retry = .false.
          return
      else if (mxy(1)%mp(2) == mexpun) then
          call fmeq(mxy(1), mresult)
          retry = .false.
          return
      else if (xe > ndig) then
          call fmpi(mresult)
          call fmdivi_r1(mresult, 2)
          return
      endif

!             If ma is large in magnitude, use more guard digits.

      iextra = min(max(int(mxy(1)%mp(2)), 0) , int(2.0+alogmx/alogmb))
      if (abs(mxy(1)%mp(2)) >= mexpov) iextra = 0
      if (iextra > 0) then
          call fmequ_r1(mxy(1), ndig, ndig+iextra)
      endif
      ndig = ndig + iextra
      n_acc = nint(ndig*alogm2)

!             Determine which method to use.

!             nmethd = 1 means use the convergent series,
!                    = 2 means use the asymptotic series.

      nmethd = 1
      if (kflagx /= 0) then
          call fmovun_xe(mxy(1), xe)
          if (xe <= 0) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          y = (ndig+5)*dlogmb
          if (abs(x) > y+(dlogtp+log(y))/2.0d0) nmethd = 2
      endif

      if (nmethd == 1) then
          call fmsi_m1(mxy, mresult, numtry, n_acc, kflagx, x)
      else if (nmethd == 2) then
          call fmsi_m2(mxy, mresult, n_acc)
      endif

      return
      end subroutine fmsi_m

      subroutine fmsi_m1(mxy, mresult, numtry, n_acc, kflagx, x)

!  Method 1 for computing shi(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(13), mresult
      integer :: numtry, n_acc, kflagx
      double precision :: x
      intent (in) :: numtry, kflagx, x
      intent (inout) :: mxy, mresult, n_acc

      double precision :: xe, y
      integer :: iextra, j, j2, k, kl, large, nbot, ndsav1, nterm
      type(multi), save :: mjsums(ljsums)
      double precision, external :: fmnterms

!             Method 1.  Use the (-1)**n*x**(2*n+1)/((2*n+1)*(2*n+1)!) series.

      iextra = 0
      if (kflagx == 0) then
          y = nint(abs(x)/2)
          y = 2*y*log(abs(x)+1.0e-9) - log(2*y+1.0e-9) - (2*y+0.5)*log(2*y+1) + 2*y
          y = 1.03*y/dlogmb - 7/alogmt
          iextra = max(0, int(y+1))
          if (abs(x) < 5 .and. numtry <= 0) then
              ndig = ndig - 2
              iextra = 0
          endif
      endif
      if (iextra > 0) then
          call fmequ_r1(mxy(1), ndig, ndig+iextra)
      endif
      ndig = ndig + iextra
      n_acc = nint(ndig*alogm2)

      if (kflagx == 0) then
          j2 = int(0.64*sqrt(fmnterms(x, 2, 0, 0, 1)) - 1.4)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = ndig

!             Split into j2 concurrent sums.

      call fmeq(mxy(1), mxy(7))
      call fmeq(mxy(1), mjsums(1))
      nterm = 1
      do j = 2, j2
         nterm = nterm + 2
         large = int(intmax/nterm)
         nbot = nterm*(nterm-1)
         if (nterm > large .or. nbot > mxbase) then
             call fmcsdivi_r1(mxy(7), nterm)
             nbot = nterm - 1
             call fmcsdivi_r1(mxy(7), nbot)
         else
             call fmcsdivi_r1(mxy(7), nbot)
         endif
         call fmcsdivi(mxy(7), nterm, mjsums(j))
      enddo
      call fmovun_xe(mxy(1), xe)
      if (xe < -ndig) then
          kl = 0
      else
          kl = 1
          call fmipwr(mxy(1), 2*j2, mxy(5))
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(7), mxy(5))
         do j = 1, j2
            nterm = nterm + 2
            large = int(intmax/nterm)
            if (nterm > large .or. nterm > mxbase/(nterm-1)) then
                call fmcsdivi_r1(mxy(7), nterm)
                nbot = nterm - 1
                call fmcsdivi_r1(mxy(7), nbot)
            else
                nbot = nterm*(nterm-1)
                call fmcsdivi_r1(mxy(7), nbot)
            endif
            call fmcsdivi(mxy(7), nterm, mxy(4))
            ndig = ndsav1
            call fmcsaddnn_r1(mjsums(j), mxy(4))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            ndig = ndsav1 - int(mjsums(j)%mp(2)-mxy(4)%mp(2))
            ndig = min(ndsav1, ndig)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         enddo
         if (kl == 0) exit
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call fmcsnsums(j2, mjsums)
      call fmsqr(mxy(1), mxy(5))
      mxy(5)%mp(1) = -1
      call fmsqr(mxy(1), mxy(5))
      mxy(5)%mp(1) = -1
      if (mjsums(1)%mp(1) > 0) then
          call fmeq(mjsums(1), mxy(12))
          call fmi2m(0, mxy(13))
      else
          call fmeq(mjsums(1), mxy(13))
          call fmi2m(0, mxy(12))
      endif
      call fmeq(mxy(5), mxy(7))
      do j = 1, j2-1
         call fmmpy(mxy(7), mjsums(j+1), mxy(3))
         if (mxy(3)%mp(1) > 0) then
             call fmadd_r1(mxy(12), mxy(3))
         else
             call fmadd_r1(mxy(13), mxy(3))
         endif
         call fmmpy_r1(mxy(7), mxy(5))
      enddo
      call fmadd(mxy(12), mxy(13), mxy(8))
      call fmcancel(mxy(12), mxy(13), mxy(8), k)
      n_acc = n_acc - k

      call fmeq(mxy(8), mresult)

      return
      end subroutine fmsi_m1

      subroutine fmsi_m2(mxy, mresult, n_acc)

!  Method 2 for computing shi(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(13), mresult
      integer :: n_acc
      intent (inout) :: mxy, mresult, n_acc

      integer :: krsave

!             Method 2.  Use the two n!/x**n asymptotic series for f(x) and g(x).
!                        Then Si(x) = pi/2 - f(x)*cos(x) - g(x)*sin(x).

      call fmfxgx(mxy(1), mxy(10), mxy(11))
      n_acc = nint(ndig*alogm2)
      krsave = krad
      krad = 1
      call fmcssn(mxy(1), mxy(12), mxy(13))
      krad = krsave
      if (mxy(1)%mp(2) == munkno .and. mxy(1)%mp(5) < 0 .and.        &
          ( (mxy(12)%mp(2) == munkno .and. mxy(12)%mp(5) >= 0) .or.  &
            (mxy(13)%mp(2) == munkno .and. mxy(13)%mp(5) >= 0) )) then
          call fmunknown(mxy(8))
          mxy(8)%mp(4) = 1
          mxy(8)%mp(5) = -maxint * (1.570796326794897d0) / mbase
      else
          call fmpi(mxy(9))
          if (mxy(12)%mp(2) == munkno .or. mxy(13)%mp(2) == munkno) then
              call fmmpyi(mxy(9), 2, mxy(8))
              call fmdiv(mxy(1), mxy(8), mxy(3))
              call fmint(mxy(3), mxy(2))
              call fmmpy(mxy(2), mxy(8), mxy(3))
              call fmsub(mxy(1), mxy(3), mxy(8))
              krsave = krad
              krad = 1
              call fmcssn(mxy(8), mxy(12), mxy(13))
              krad = krsave
          endif
          call fmdivi(mxy(9), 2, mxy(2))
          call fmmpy(mxy(10), mxy(12), mxy(3))
          call fmsub_r1(mxy(2), mxy(3))
          call fmmpy(mxy(11), mxy(13), mxy(3))
          call fmsub(mxy(2), mxy(3), mxy(8))
      endif

      call fmeq(mxy(8), mresult)

      return
      end subroutine fmsi_m2

      subroutine fmsi_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = shi(ma).

!  kresult = 1 is returned if a special case gives the value of shi(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(13), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      integer :: j, k, kl, krsave, nds
      double precision :: xe, ye
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMSI     '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      k = 0
      if (kround /= 1) then
          j = ntrace
          ntrace = 0
          kl = kwarn
          kwarn = 0
          call fmsqr(malocal, mxy(1))
          call fmdivi(mxy(1), 18, mxy(2))
          call fmovun_xe(mxy(2), xe)
          if (xe < -ndig) k = 1
          ntrace = j
          kwarn = kl
      endif
      if (kround /= 1 .and. k == 1) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          krsave = kround
          kround = 1
          nds = ndig
          ndig = ndig + ngrd52
          call fmequ(malocal, mxy(1), nds, ndig)
          call fmsqr(mxy(1), mxy(2))
          call fmmpy(mxy(1), mxy(2), mxy(3))
          call fmdivi(mxy(3), -18, mxy(5))
          call fmeq(mxy(1), mxy(4))
          call fmovun_xe(mxy(4), xe)
          call fmovun_xe(mxy(5), ye)
          if (xe - ye > ndig .and. mxy(4)%mp(2) > mexpun) then
              call fmequ(mxy(4), mxy(10), ndig, nds)
              call fmequ(mxy(4), mxy(6), ndig, nds)
              call fmequ(mxy(6), mxy(8), nds, ndig)
              call fmsub(mxy(4), mxy(8), mxy(6))
              if (mxy(6)%mp(3) == 0) then
                  call fmequ(mxy(4), mxy(6), ndig, nds)
                  call fmequ(mxy(5), mxy(7), ndig, nds)
                  ndig = nds
                  kround = krsave
                  call fmadd(mxy(6), mxy(7), mresult)
                  if (mresult%mp(2) >= mexpov) then
                      if (mxy(6)%mp(1) > 0) then
                          if (mxy(7)%mp(1) < 0 .and. (kround == -1 .or. kround == 0)) then
                              call fmeq(mxy(6), mxy(1))
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2))
                              call fmsub(mxy(1), mxy(2), mxy(3))
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mresult)
                          else if (mxy(7)%mp(1) > 0 .and. kround == 2) then
                              call fmeq(mxy(6), mxy(1))
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2))
                              call fmadd(mxy(1), mxy(2), mxy(3))
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mresult)
                          else
                              kround = krsave
                              call fmeq(mxy(10), mresult)
                          endif
                      else
                          if (mxy(7)%mp(1) < 0 .and. kround == -1) then
                              call fmeq(mxy(6), mxy(1))
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2))
                              call fmadd(mxy(1), mxy(2), mxy(3))
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mresult)
                          else if (mxy(7)%mp(1) > 0 .and. (kround == 2 .or. kround == 0)) then
                              call fmeq(mxy(6), mxy(1))
                              mxy(1)%mp(2) = 0
                              call fmulp(mxy(1), mxy(2))
                              call fmsub(mxy(1), mxy(2), mxy(3))
                              mxy(3)%mp(2) = mxy(6)%mp(2) + mxy(3)%mp(2)
                              call fmeq(mxy(3), mresult)
                          else
                              kround = krsave
                              call fmeq(mxy(10), mresult)
                          endif
                      endif
                  endif
              else
                  kround = krsave
                  call fmequ(mxy(4), mresult, ndig, nds)
              endif
              ntrace = j
              kwarn = k
              ndig = nds
              kround = krsave
              if (ma%mp(1) < 0) mresult%mp(1) = -1
              kresult = 1
              return
          endif
          kflag = 0
          ntrace = j
          kwarn = k
          ndig = nds
          kround = krsave
      endif

      return
      end subroutine fmsi_sc

      subroutine fmsign(ma, mb, mc)

!  mc = sign(ma, mb)

!  mc is set to abs(ma) if mb is positive or zero, or -abs(ma) if mb is negative.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: kwrnsv

      call fmalloc(mc, ndig+2)

      kflag = 0
      ncall = ncall + 1
      namest(ncall) = 'FMSIGN'
      if (ntrace /= 0) call fmntr_inp2(ma, mb)

      kwrnsv = kwarn
      kwarn = 0
      if ((ma%mp(2) == munkno .and. ma%mp(5) >= 0) .or.  &
          (mb%mp(2) == munkno .and. mb%mp(5) >= 0)) then
          call fmunknown(mc)
          kflag = -4
      else if (mb%mp(1) >= 0) then
          call fmeq(ma, mc)
          mc%mp(1) = 1
      else
          call fmeq(ma, mc)
          if (mc%mp(3) /= 0) mc%mp(1) = -1
      endif

      kwarn = kwrnsv
      if (ntrace /= 0) call fmntr_out1(mc)
      ncall = ncall - 1

      return
      end subroutine fmsign

      subroutine fmsin(ma, mb)

!  mb = sin(ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(6), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmsin_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call fmsin_m1(ma, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmsin

      subroutine fmsin2(ma, mb)

!  Internal subroutine for mb = sin(ma) where 0 <= ma <= 1.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: maxv
      integer :: j, j2, k, k2, kl, ks, kthree, kwrnsv, l, l2, large, n2, nbot, ndsav1, ndsave, nterm
      real :: alog3, alogt, b, t, tj
      type(multi), save :: mxy(3), mjsums(ljsums)

      call fmalloc(mb, ndig+2)

      if (mblogs /= mbase) call fmcons
      if (ma%mp(3) == 0) then
          call fmeq(ma, mb)
          return
      endif
      ndsave = ndig
      kwrnsv = kwarn
      kwarn = 0

!             Use the direct series
!                  sin(x) = x - x**3/3! + x**5/5! - ...

!             The argument will be divided by 3**k2 before the series is summed.  The series will be
!             added as j2 concurrent series.

      b = real(mbase)
      k = ngrd52
      t = max(ndig-k, 2)
      alog3 = log(3.0)
      alogt = log(t)
      tj = 0.55*(ndig*alogmt)**0.3333
      j2 = int(tj)
      j2 = max(2, min(j2+mod(j2, 2), ljsums))
      k2 = max(1, int(0.62*(ndig*alogmt)**0.3333 - 0.8))

      tj = -(real(ma%mp(2))*alogmb +  &
             log(real(ma%mp(3))/b + real(ma%mp(4))/(b*b)))/alog3 - 0.3
      if (tj >= k2) then
          l = k2
      else if (tj > 0) then
          l = int(tj)
      else
          l = 0
      endif
      k2 = k2 - l
      if (k2 <= 0) then
          k2 = 0
          j2 = int(.43*sqrt(t*alogmb/(alogt+real(l)*alog3)) + .33)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      endif

      n2 = int(t*alogmb/(alogt+real(l)*alog3))
      l2 = int((log(1+real(n2)/3.0d0**k2)+k2*log(3.0d0))/alogmb)
      ndig = ndig + l2
      ndsav1 = ndig

!             Divide the argument by 3**k2.

      call fmequ(ma, mxy(1), ndsave, ndig)
      kthree = 1
      maxv = mxbase/3
      if (k2 > 0) then
          do j = 1, k2
             kthree = 3*kthree
             if (kthree > maxv) then
                 call fmcsdivi_r1(mxy(1), kthree)
                 kthree = 1
             endif
          enddo
          if (kthree > 1) call fmcsdivi_r1(mxy(1), kthree)
      endif

!             Split into j2 concurrent sums and reduce ndig while computing each term in the sum
!             as the terms get smaller.

      call fmi2m(1, mjsums(1))
      call fmi2m(1, mxy(2))
      nterm = 3
      do j = 2, j2
         nbot = nterm*(nterm-1)
         call fmcsdivi_r1(mxy(2), nbot)
         call fmeq(mxy(2), mjsums(j))
         nterm = nterm + 2
      enddo
      ks = 0
      if (mxy(1)%mp(2) < -ndig) then
          ks = 1
      else
          call fmipwr(mxy(1), 2*j2, mxy(3))
          if (mxy(3)%mp(2) < -ndig) ks = 1
      endif

      if (ks == 0) then
          kl = 1
          do while (kl == 1)
             call fmcsmpy_r1(mxy(2), mxy(3))
             do j = 1, j2
                large = int(intmax/nterm)
                if (nterm > large .or. nterm > mxbase/(nterm-1)) then
                    call fmcsdivi_r1(mxy(2), nterm)
                    nbot = nterm - 1
                    call fmcsdivi_r1(mxy(2), nbot)
                else
                    nbot = nterm*(nterm-1)
                    call fmcsdivi_r1(mxy(2), nbot)
                endif
                ndig = ndsav1
                call fmcsaddnn_r1(mjsums(j), mxy(2))
                if (kflag /= 0) then
                     kl = 0
                     exit
                 endif
                ndig = ndsav1 - int(mjsums(j)%mp(2)-mxy(2)%mp(2))
                if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                nterm = nterm + 2
             enddo
          enddo
      endif

!             Put the j2 separate sums back together.

      kflag = 0
      call fmcsnsums(j2, mjsums)
      call fmsqr(mxy(1), mxy(2))
      call fmnegate(mxy(2))
      call fmeq(mjsums(j2), mxy(3))
      do j = 2, j2
         call fmcsmpy_r1(mxy(3), mxy(2))
         call fmadd_r1(mxy(3), mjsums(j2-j+1))
      enddo
      call fmcsmpy_r1(mxy(3), mxy(1))

!             Reverse the effect of reducing the argument to compute sin(ma).

      ndig = ndsav1
      if (k2 > 0) then
          call fmi2m(3, mxy(1))
          do j = 1, k2
             call fmsqr(mxy(3), mxy(2))
             call fmcsmpyi_r1(mxy(2), -4)
             call fmadd_r2(mxy(1), mxy(2))
             call fmcsmpy_r1(mxy(3), mxy(2))
          enddo
      endif

      call fmequ(mxy(3), mb, ndsav1, ndsave)
      ndig = ndsave
      kwarn = kwrnsv

      return
      end subroutine fmsin2

      subroutine fmsin_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing sin(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(6), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      integer :: jcos, jsin, jswap, kwrnsv, ndsv

      call fmequ(ma, mxy(6), ndsave, ndig)
      mxy(6)%mp(1) = 1
      call fmeq(mxy(6), mxy(5))
      if (ma%mp(2) > 3*10**5 .and. krad == 1) then
          call fmunknown(mresult)
          return
      endif

!             Reduce the argument, convert to radians if the input is in degrees, and evaluate
!             the function.

      kwrnsv = kwarn
      kwarn = 0
      call fmrdc(mxy(6), jsin, jcos, jswap)
      if (kround /= 1 .and. krad /= 1) then
          call fmi2m(30, mxy(1))
          call fmsub(mxy(6), mxy(1), mxy(2))
          if (mxy(2)%mp(3) == 0 .and. jswap == 0) then
              call fmst2m('0.5', mxy(1))
              call fmmpyi(mxy(1), jsin, mresult)
              if (ma%mp(1) < 0) call fmnegate(mresult)
              return
          endif
      endif
      kwarn = kwrnsv
      if (mxy(6)%mp(2) == munkno) then
          if (krad /= 1 .or. jswap == 0) then
              call fmeq(mxy(5), mresult)
              call fmrdc(mresult, jsin, jcos, jswap)
              if (ma%mp(1) < 0) call fmnegate(mresult)
              return
          endif
          if (mbspi /= mbase .or. ndigpi < ndig) then
              ndsv = ndig
              ndig = ndig + 2
              call fmpi(mxy(3))
              ndig = ndsv
          endif
          call fmpi(mxy(4))
          call fmdiv(mxy(5), mxy(4), mxy(3))
          call fmmpyi_r1(mxy(3), 2)
          call fmnint(mxy(3), mxy(2))
          call fmmpy(mxy(2), mxy(4), mxy(1))
          call fmdivi_r1(mxy(1), 2)
          call fmsub_r2(mxy(5), mxy(1))
          if (mxy(1)%mp(3) == 0) call fmulp(mxy(5), mxy(1))
          call fmi2m(1, mxy(3))
          call fmsqr_r1(mxy(1))
          call fmdivi_r1(mxy(1), 2)
          call fmsub_r2(mxy(3), mxy(1))
          call fmsub_r1(mxy(1), mxy(3))
          if (mxy(1)%mp(3) == 0) then
              call fmi2m(jsin, mxy(6))
          else
              call fmeq(mxy(5), mxy(6))
              call fmrdc(mxy(6), jsin, jcos, jswap)
          endif
          call fmeq(mxy(6), mresult)
          if (ma%mp(1) < 0) call fmnegate(mresult)
          return
      endif
      if (krad == 0) then
          if (mbspi /= mbase .or. ndigpi < ndig) then
              ndsv = ndig
              ndig = ndig + 2
              call fmpi(mxy(4))
              ndig = ndsv
          endif
          call fmpi(mxy(4))
          call fmmpy_r1(mxy(6), mxy(4))
          call fmdivi_r1(mxy(6), 180)
      endif
      if (mxy(6)%mp(2) /= munkno) then
          if (jswap == 0) then
              if (mxy(6)%mp(2) < 0 .or. ndig <= 50) then
                  call fmsin2(mxy(6), mxy(4))
                  call fmeq(mxy(4), mxy(6))
              else
                  call fmcos2(mxy(6), mxy(4))
                  call fmi2m(1, mxy(2))
                  call fmsqr_r1(mxy(4))
                  call fmsub_r2(mxy(2), mxy(4))
                  call fmsqrt(mxy(4), mxy(6))
              endif
          else
              call fmcos2(mxy(6), mxy(4))
              call fmeq(mxy(4), mxy(6))
          endif
      endif
      call fmeq(mxy(6), mresult)
      if (jsin == -1) call fmnegate(mresult)
      if (ma%mp(1) < 0) call fmnegate(mresult)

      return
      end subroutine fmsin_m1

      subroutine fmsin_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = sin(ma).

!  kresult = 1 is returned if a special case gives the value of sin(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(6), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      double precision :: b, pi, x, xe, xf
      integer :: j, k
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMSIN    '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      if (malocal%mp(2) == munkno) then
          if (malocal%mp(5) < 0) then
              call fmovun_xexf(malocal, xe, xf)
              if (2*xe < -ndsave) then
                  if (krad == 1) then
                      call fmeq(malocal, mresult)
                  else
                      call fmpi(mxy(2))
                      call fmmpy_r2(malocal, mxy(2))
                      call fmdivi(mxy(2), 180, mresult)
                  endif
              else
                  call fmunknown(mresult)
                  if (xe*dlogmb+log(xf) < log(1.0d+12)) then
                      b = mbase
                      if (krad == 1) then
                          x = sin(xf*b**xe)
                      else
                          pi = acos(-1.0d0)
                          x = sin(pi*xf*b**xe/180.0d0)
                      endif
                      if (malocal%mp(1) < 0) x = -x
                      if (x < 0) then
                          mresult%mp(1) = -1
                          x = -x
                      endif
                      if (x == 1.0d0) then
                          xe = 1
                          xf = 1/b
                      else
                          xe = 0
                          xf = x
                      endif
                      do j = 1, 5
                         if (xf >= 1) then
                             xe = xe + 1
                             xf = xf / b
                         else if (xf < 1.0d0/b) then
                             xe = xe - 1
                             xf = xf * b
                         else
                             exit
                         endif
                      enddo
                      mresult%mp(4) = xe
                      mresult%mp(5) = -xf*maxint
                  endif
              endif
          else
              call fmunknown(mresult)
          endif
          kresult = 1
          return
      endif
      if (malocal%mp(2) == mexpun) then
          call fmeq(malocal, mresult)
          if (krad == 0) then
              call fmdivi(mresult, 180, mxy(2))
              call fmpi(mxy(1))
              call fmmpy(mxy(2), mxy(1), mresult)
          endif
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (kround /= 1 .and. malocal%mp(2) < -ndsave .and. krad == 1) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          call fmsqr(malocal, mxy(1))
          call fmmpy(mxy(1), malocal, mxy(2))
          call fmdivi(mxy(2), -6, mxy(3))
          if (mxy(3)%mp(2) > mexpun) then
              call fmadd(malocal, mxy(3), mresult)
          else if (malocal%mp(2) == mexpun) then
              call fmeq(malocal, mresult)
          else if (malocal%mp(1) < 0 .and. (kround == 2 .or. kround == 0)) then
              call fmeq(malocal, mxy(1))
              mxy(1)%mp(2) = 0
              call fmulp(mxy(1), mxy(2))
              call fmsub(mxy(1), mxy(2), mxy(3))
              mxy(3)%mp(2) = malocal%mp(2) + mxy(3)%mp(2)
              call fmeq(mxy(3), mresult)
          else if (malocal%mp(1) >= 0 .and. (kround == -1 .or. kround == 0)) then
              call fmeq(malocal, mxy(1))
              mxy(1)%mp(2) = 0
              call fmulp(mxy(1), mxy(2))
              call fmsub(mxy(1), mxy(2), mxy(3))
              mxy(3)%mp(2) = malocal%mp(2) + mxy(3)%mp(2)
              call fmeq(mxy(3), mresult)
          else
              call fmeq(malocal, mresult)
          endif
          if (kflag > 0) kflag = 0
          ntrace = j
          kwarn = k
          kresult = 1
      endif

      return
      end subroutine fmsin_sc

      subroutine fmsinh(ma, mb)

!  mb = sinh(ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(5), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmsinh_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call fmsinh_m1(ma, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmsinh

      subroutine fmsinh_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing sinh(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      integer :: nmethd

      call fmequ(ma, mxy(3), ndsave, ndig)
      mxy(3)%mp(1) = 1

!             Use a series for small arguments, fmexp for large ones.

      if (mbase > 99) then
          if (mxy(3)%mp(2) <= 0) then
              nmethd = 1
          else if (mxy(3)%mp(2) >= 2) then
              nmethd = 2
          else if (abs(mxy(3)%mp(3)) < 10) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          if (mxy(3)%mp(2) <= 0) then
              nmethd = 1
          else
              nmethd = 2
          endif
      endif

      if (nmethd == 1) then
          if (mxy(3)%mp(2) < 0 .or. ndig <= 50) then
              call fmsinh2(mxy(3), mxy(4))
              call fmeq(mxy(4), mxy(3))
          else
              call fmcosh2(mxy(3), mxy(4))
              call fmi2m(1, mxy(2))
              call fmsqr_r1(mxy(4))
              call fmsub_r1(mxy(4), mxy(2))
              call fmsqrt(mxy(4), mxy(3))
          endif
      else
          call fmexp(mxy(3), mxy(5))
          call fmeq(mxy(5), mxy(3))
          if (mxy(3)%mp(2) == mexpov) then
              if (ma%mp(1) < 0) call fmnegate(mxy(3))
              call fmeq(mxy(3), mresult)
              return
          else if (mxy(3)%mp(2) == mexpun) then
              mxy(3)%mp(2) = mexpov
              if (ma%mp(1) < 0) call fmnegate(mxy(3))
              call fmeq(mxy(3), mresult)
              return
          endif
          if (int(mxy(3)%mp(2)) <= (ndig+1)/2) then
              call fmi2m(1, mxy(1))
              call fmdiv_r1(mxy(1), mxy(3))
              call fmsub_r1(mxy(3), mxy(1))
          endif
          call fmdivi_r1(mxy(3), 2)
      endif
      if (ma%mp(1) < 0) call fmnegate(mxy(3))
      call fmeq(mxy(3), mresult)

      return
      end subroutine fmsinh_m1

      subroutine fmsinh_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = sinh(ma).

!  kresult = 1 is returned if a special case gives the value of sinh(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      double precision :: xe
      integer :: j, k
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMSINH   '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0) then
          call fmi2m(0, mresult)
          kresult = 1
          return
      endif
      if (malocal%mp(2) == munkno) then
          if (malocal%mp(5) < 0) then
              call fmovun_xe(malocal, xe)
              if (2*xe < -ndsave) then
                  call fmeq(malocal, mxy(1))
                  call fmsqr(malocal, mxy(2))
                  call fmmpy_r1(mxy(2), mxy(1))
                  call fmdivi_r1(mxy(2), 6)
                  call fmadd(mxy(1), mxy(2), mresult)
              else
                  call fmexp(malocal, mxy(2))
                  call fmi2m(1, mxy(1))
                  call fmdiv_r1(mxy(1), mxy(2))
                  call fmsub_r2(mxy(2), mxy(1))
                  call fmdivi(mxy(1), 2, mresult)
              endif
          else
              call fmunknown(mresult)
          endif
          kresult = 1
          return
      endif
      if (malocal%mp(2) == mexpov) then
          k = malocal%mp(1)
          call fmabs(malocal, mxy(1))
          call fmexp(mxy(1), mresult)
          if (k < 0) mresult%mp(1) = -1
          kresult = 1
          return
      endif
      if (malocal%mp(2) == mexpun) then
          call fmeq(malocal, mresult)
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (kround /= 1 .and. malocal%mp(2) < -ndsave) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          call fmsqr(malocal, mxy(1))
          call fmmpy(mxy(1), malocal, mxy(2))
          call fmdivi(mxy(2), 6, mxy(3))
          if (mxy(3)%mp(2) > mexpun) then
              call fmadd(malocal, mxy(3), mresult)
          else if (malocal%mp(2) == mexpun) then
              call fmeq(malocal, mresult)
          else if (malocal%mp(1) < 0 .and. kround == -1) then
              call fmeq(malocal, mxy(1))
              mxy(1)%mp(2) = 0
              call fmulp(mxy(1), mxy(2))
              call fmadd(mxy(1), mxy(2), mresult)
              mresult%mp(2) = malocal%mp(2) + mresult%mp(2)
          else if (malocal%mp(1) >= 0 .and. kround == 2) then
              call fmeq(malocal, mxy(1))
              mxy(1)%mp(2) = 0
              call fmulp(mxy(1), mxy(2))
              call fmadd(mxy(1), mxy(2), mresult)
              mresult%mp(2) = malocal%mp(2) + mresult%mp(2)
          else
              call fmeq(malocal, mresult)
          endif
          if (kflag > 0) kflag = 0
          ntrace = j
          kwarn = k
          kresult = 1
          return
      endif

      return
      end subroutine fmsinh_sc

      subroutine fmsinh2(ma, mb)

!  Internal subroutine for mb = sinh(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: maxv
      integer :: j, j2, k, k2, kl, kthree, kwrnsv, l, l2, large, n2, nbot, ndsav1, ndsave, nterm
      real :: alog3, alogt, b, t, tj
      type(multi), save :: mxy(3), mjsums(ljsums)

      call fmalloc(mb, ndig+2)

      if (mblogs /= mbase) call fmcons
      if (ma%mp(3) == 0) then
          call fmeq(ma, mb)
          return
      endif
      ndsave = ndig
      kwrnsv = kwarn
      kwarn = 0

!             Use the direct series
!                  sinh(x) = x + x**3/3! + x**5/5! - ...

!             The argument will be divided by 3**k2 before the series is summed.
!             The series will be added as j2 concurrent series.

      b = real(mbase)
      k = ngrd52
      t = max(ndig-k, 2)
      alog3 = log(3.0)
      alogt = log(t)
      tj = 0.67*(ndig*alogmt)**0.3333 - 0.3
      j2 = int(tj)
      j2 = max(2, min(j2, ljsums))
      k2 = max(2, int(0.6*(ndig*alogmt)**0.3333 - 0.8))

      tj = -(real(ma%mp(2))*alogmb +  &
             log(real(ma%mp(3))/b + real(ma%mp(4))/(b*b)))/alog3 - 0.3
      if (tj >= k2) then
          l = k2
      else if (tj > 0) then
          l = int(tj)
      else
          l = 0
      endif
      k2 = k2 - l
      if (k2 <= 0) then
          k2 = 0
          j2 = int(.43*sqrt(t*alogmb/(alogt+real(l)*alog3)) + .33)
          j2 = max(1, min(j2, ljsums))
      endif

      n2 = int(t*alogmb/(alogt+real(l)*alog3))
      l2 = int(log(real(n2)+3.0d0**k2)/alogmb)
      ndig = ndig + l2
      ndsav1 = ndig

!             Divide the argument by 3**k2.

      call fmequ(ma, mxy(1), ndsave, ndig)
      kthree = 1
      maxv = mxbase/3
      if (k2 > 0) then
          do j = 1, k2
             kthree = 3*kthree
             if (kthree > maxv) then
                 call fmcsdivi_r1(mxy(1), kthree)
                 kthree = 1
             endif
          enddo
          if (kthree > 1) call fmcsdivi_r1(mxy(1), kthree)
      endif

!             Split into j2 concurrent sums and reduce ndig while computing each term in the sum
!             as the terms get smaller.

      call fmeq(mxy(1), mxy(2))
      nterm = 1
      do j = 1, j2
         nbot = nterm*(nterm-1)
         if (nbot > 1) call fmcsdivi_r1(mxy(2), nbot)
         nterm = nterm + 2
         call fmeq(mxy(2), mjsums(j))
      enddo
      call fmsqr_r1(mxy(1))

      kl = 1
      if (mxy(1)%mp(2) < -ndig) then
          kl = 0
      else
          call fmipwr(mxy(1), j2, mxy(3))
      endif

      do while (kl == 1)
         call fmcsmpy_r1(mxy(2), mxy(3))
         do j = 1, j2
            large = int(intmax/nterm)
            if (nterm > large .or. nterm > mxbase/(nterm-1)) then
                call fmcsdivi_r1(mxy(2), nterm)
                nbot = nterm - 1
                call fmcsdivi_r1(mxy(2), nbot)
            else
                nbot = nterm*(nterm-1)
                call fmcsdivi_r1(mxy(2), nbot)
            endif
            ndig = ndsav1
            call fmcsaddnn_r1(mjsums(j), mxy(2))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            ndig = ndsav1 - int(mjsums(j)%mp(2)-mxy(2)%mp(2))
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
            nterm = nterm + 2
         enddo
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call fmcsnsums(j2, mjsums)
      call fmeq(mjsums(j2), mxy(3))
      do j = 2, j2
         call fmcsmpy_r1(mxy(3), mxy(1))
         call fmadd_r1(mxy(3), mjsums(j2-j+1))
      enddo

!             Reverse the effect of reducing the argument to compute sinh(ma).

      ndig = ndsav1
      if (k2 > 0) then
          call fmi2m(3, mxy(1))
          do j = 1, k2
             call fmsqr(mxy(3), mxy(2))
             call fmcsmpyi_r1(mxy(2), 4)
             call fmadd_r2(mxy(1), mxy(2))
             call fmcsmpy_r1(mxy(3), mxy(2))
          enddo
      endif

      call fmequ(mxy(3), mb, ndsav1, ndsave)
      ndig = ndsave
      kwarn = kwrnsv

      return
      end subroutine fmsinh2

      subroutine fmsp2m(x, ma)

!  ma = x

!  Convert a single precision number to fm format.

!  This version tries to convert the single precision machine number to fm with accuracy of nearly
!  full fm precision.
!  If conversion to fm with approximately double precision accuracy is good enough, it is faster to
!  call fmdpm(dble(x), ma)

      use fmvals
      implicit none

      real :: x
      type(multi) :: ma
      intent (in) :: x
      intent (inout) :: ma

      double precision :: xdp, y, yt
      integer :: j, k

      call fmalloc(ma, ndig+2)

      ncall = ncall + 1
      namest(ncall) = 'FMSP2M'
      xdp = dble(x)
      if (ntrace /= 0) call fmntr_inpd(xdp)

!             Check for x = + or - Infinity, or Nan.  Return unknown if so.

      if (x > huge(x) .or. x < -huge(x) .or. (.not.(x == x))) then
          do j = 2, ndig
             ma%mp(j+2) = 0
          enddo
          kflag = -4
          ma%mp(2) = munkno
          ma%mp(3) = 1
          ma%mp(1) = 1
          call fmwarn
          if (ntrace /= 0) call fmntr_out1(ma)
          ncall = ncall - 1
          return
      endif

!             Check to see if x is exactly a small integer.  If so, converting as an integer
!             is better.  Also see if x is exactly a small integer divided by a small power of two.

      y = mxexp2
      if (abs(xdp) < y) then
          k = int(xdp)
          y = k
          if (y == xdp) then
              call fmi2m2(k, ma)
              if (ntrace /= 0) call fmntr_out1(ma)
              ncall = ncall - 1
              return
          endif
      endif
      if (abs(xdp) < 1.0d0) then
          y = 4096.0d0 * xdp
          k = int(y)
          yt = k
          if (y == yt) then
              call fmi2m2(k, ma)
              call fmdivi_r1(ma, 4096)
              if (ntrace /= 0) call fmntr_out1(ma)
              ncall = ncall - 1
              return
          endif
      endif

      call fmdp2m2(xdp, ma)

      if (ntrace /= 0) call fmntr_out1(ma)
      ncall = ncall - 1

      return
      end subroutine fmsp2m

      subroutine fmsqr(ma, mb)

!  mb = ma**2

!  This routine performs the trace printing for squaring.
!  fmsqr2 is used to do the arithmetic.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      integer :: kovun

      ncall = ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == mexpov) kovun = 1
      if (ma%mp(2) == munkno) kovun = 2
      if (ntrace /= 0) then
          namest(ncall) = 'FMSQR    '
          call fmntr_inp1(ma)
      endif

      call fmsqr2(ma, mb)

      if ((abs(mb%mp(2)) == mexpov .and. kovun == 0) .or.  &
          (abs(mb%mp(2)) == munkno .and. kovun < 2)) then
          namest(ncall) = 'FMSQR    '
          call fmwarn
      endif
      if (ntrace /= 0) then
          call fmntr_out1(mb)
      endif
      ncall = ncall - 1

      return
      end subroutine fmsqr

      subroutine fmsqr2(ma, mb)

!  Internal squaring routine.  mb = ma**2

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      logical :: retry
      integer :: kresult, kr_retry

      call fmalloc(mwa, 2*ndig+30)
      call fmalloc(mb, ndig+2)
      call fmsqr_sc(ma, mb, kresult)
      if (kresult > 0) then
          return
      endif

      if (mblogs /= mbase) call fmcons

      kr_retry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call fmsqr_m1(ma, mb, kr_retry, retry)
      enddo

      return
      end subroutine fmsqr2

      subroutine fmsqr2_r1(ma)

!  ma = ma**2.

      use fmvals
      implicit none

      type(multi) :: ma
      intent (inout) :: ma
      type(multi), save :: mxy(1)

      call fmsqr2(ma, mxy(1))
      call fmeq(mxy(1), ma)

      return
      end subroutine fmsqr2_r1

      subroutine fmsqr_m1(ma, mb, kr_retry, retry)

!  Method 1 for computing ma**2

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: kr_retry
      logical :: retry
      intent (in) :: ma
      intent (inout) :: mb, kr_retry, retry

      real (kind(1.0d0)) :: maxmax, maxmwa, mbj, mbkj, mbnorm, mbp1, mk, mka, mkt, mmax, mr, mt
      double precision :: err
      real :: c
      integer :: j, jm1, jrssav, k, kb, ki, kj, kl, knz, kshift, kwa, l, n1, nguard, nmethd, nzda

      kflag = 0
      jrssav = jrsign
      if (mblogs /= mbase) call fmcons

!             Check for using an fft-based method if precision is very high.

      c = 1300
      if (ndig >= c) then
          nzda = 0
          do j = 2, ndig
             if (ma%mp(j+2) == 0) nzda = nzda + 1
          enddo
          if (ndig-nzda < 50 .or. real(nzda)/ndig > 0.8) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          nmethd = 1
      endif
      if (nmethd == 2) then
          ksqr = 1
          call fmmpy2(ma, ma, mb)
          ksqr = 0
          return
      endif

      maxmax = 0
      n1 = ndig + 1
      mwa%mp(2) = ma%mp(2) + ma%mp(2)

!             nguard is the number of guard digits used.

      if (ncall > 1) then
          nguard = ngrd22
          if (nguard > ndig) nguard = ndig
      else
          nguard = ngrd52
          if (nguard > ndig) nguard = ndig
          if (kr_retry >= 1) then
              nguard = ndig + 2
          else if (mbase < 10**6) then
              nguard = min(nguard+1, ndig+2)
          endif
      endif
      if (ma%mp(3)*ma%mp(3) < mbase .and. nguard < 3) nguard = 3

      l = n1 + nguard
      mwa%mp(l+2) = 0

!             The multiplication loop begins here.

!             mbnorm is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             maxmwa is an upper bound on the size of values in mwa divided by (mbase-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      mbp1 = mbase + 1
      mbnorm = (maxint/(mbp1*mbp1))
      mmax = intmax - mbase
      mmax = min((maxint/mbp1 - mbp1), mmax)
      if (mbnorm >= 2) then
          mbj = ma%mp(3)

!             Count the trailing zeros in ma.

          knz = n1
          if (ma%mp(n1+1) /= 0) then
              knz = n1
          else
              do j = ndig, 2, -1
                 if (ma%mp(j+1) /= 0) then
                     knz = j
                     exit
                 endif
              enddo
          endif

          mwa%mp(3) = 0
          mwa%mp(4) = 0
          do k = ndig+2, l
             mwa%mp(k+1) = 0
          enddo

!             (Inner Loop)

          do k = 4, n1+1
             mwa%mp(k+1) = ma%mp(k)*mbj
          enddo
          maxmwa = mbj
          do j = 3, min(l/2, n1)
             mbj = ma%mp(j+1)
             if (mbj /= 0) then
                 maxmwa = maxmwa + mbj
                 jm1 = j - 1
                 kl = min(knz, l-jm1)

!                       Major (Inner Loop)

                 do k = 2*j+1, jm1+kl+1
                    mwa%mp(k) = mwa%mp(k) + ma%mp(k-jm1)*mbj
                 enddo
             endif

             if (maxmwa > mmax) then
                 maxmax = max(maxmax, maxmwa)
                 maxmwa = 0
                 jm1 = j - 1
                 kl = min(knz, l-jm1)

!                       Normalization is only required for the range of digits currently
!                       changing in mwa.

                 do kb = jm1+kl, 2*j, -1
                    mkt = int (mwa%mp(kb+1)/mbase)
                    mwa%mp(kb) = mwa%mp(kb) + mkt
                    mwa%mp(kb+1) = mwa%mp(kb+1) - mkt*mbase
                 enddo
             endif
          enddo

!             Double mwa, add the square terms, and perform the final normalization.  (Inner Loop)

          if (2*max(maxmax, maxmwa)+mbase > mmax) then
              do kb = l+1, 5, -1
                 mkt = int (mwa%mp(kb)/mbase)
                 mwa%mp(kb-1) = mwa%mp(kb-1) + mkt
                 mwa%mp(kb) = mwa%mp(kb) - mkt*mbase
              enddo
          endif

          do j = 4, l, 2
             if (j/2 <= n1) then
                 mka = ma%mp(1+j/2)
                 mwa%mp(j) = 2*mwa%mp(j) + mka*mka
                 mwa%mp(j+1) = 2*mwa%mp(j+1)
             else
                 mwa%mp(j) = 2*mwa%mp(j)
                 mwa%mp(j+1) = 2*mwa%mp(j+1)
             endif
          enddo
          if (mod(l, 2) == 1) then
              if ((l+1)/2 <= n1) then
                  mka = ma%mp(1+(l+1)/2)
                  mwa%mp(l+1) = 2*mwa%mp(l+1) + mka*mka
              else
                  mwa%mp(l+1) = 2*mwa%mp(l+1)
              endif
          endif

          do kb = l+1, 4, -1
             mkt = int (mwa%mp(kb)/mbase)
             mwa%mp(kb-1) = mwa%mp(kb-1) + mkt
             mwa%mp(kb) = mwa%mp(kb) - mkt*mbase
          enddo

      else

!             If normalization must be done for each digit, combine the two loops and normalize as
!             the digits are multiplied.

          do j = 2, l
             mwa%mp(j+1) = 0
          enddo
          kj = ndig + 2
          do j = 2, n1
             kj = kj - 1
             mbkj = ma%mp(kj+1)
             if (mbkj == 0) cycle
             kl = l - kj + 1
             if (kl > n1) kl = n1
             ki = kl + 2
             kwa = kl+ kj + 1
             mk = 0
             do k = 2, kl
                mt = ma%mp(ki-k+1)*mbkj + mwa%mp(kwa-k+1) + mk
                mk = int (mt/mbase)
                mwa%mp(kwa-k+1) = mt - mbase*mk
             enddo
             mwa%mp(kwa-kl) = mk
          enddo

      endif

!             Set kshift = 1 if a shift left is necessary.

      if (mwa%mp(3) == 0) then
          kshift = 1
      else
          kshift = 0
      endif

!             The multiplication is complete.  Round the result and move it to mb.

      jrsign = 1

!             Try again with more guard digits if the current guard digits are too close to 1/2 ulp.

      if (ncall >= 1) then
          kl = min(nguard, int(3*dlogtn/dlogmb + 1.5))
          err = 0
          do j = kl, 1, -1
             err = (err + mwa%mp(j+kshift+ndig+2)) / mbase
          enddo
          if ( (kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
               (kround /= 1 .and. (err > 0.998 .or. err < 0.002)) ) kr_retry = kr_retry + 1
      endif
      if (kr_retry == 1 .and. nguard < ndig+2) then
          kr_retry = 2
          retry = .true.
          return
      endif
      mr = 2*mwa%mp(kshift+ndig+3) + 1
      if (kround == -1 .or. kround == 2) then
          call fmrnd(mwa, ndig, nguard, kshift)
      else if (mr >= mbase) then
          if (mr-1 > mbase .and. mwa%mp(kshift+n1+1) < mbase-1) then
              if (kround /= 0) then
                  mwa%mp(kshift+n1+1) = mwa%mp(kshift+n1+1) + 1
                  mwa%mp(kshift+n1+2) = 0
              endif
          else
              call fmrnd(mwa, ndig, nguard, kshift)
          endif
      endif
      call fmmove(mwa, mb)

      mb%mp(1) = 1
      ksqr = 0
      jrsign = jrssav

      return
      end subroutine fmsqr_m1

      subroutine fmsqr_r1(ma)

!  ma = ma**2    faster than using fmmpy.

      use fmvals
      implicit none

      type(multi) :: ma
      intent (inout) :: ma

      ncall = ncall + 1
      if (ntrace /= 0) then
          namest(ncall) = 'FMSQR_R1'
          call fmntr_inp1(ma)

          call fmsqr2_r1(ma)

          namest(ncall) = 'FMSQR_R1'
          call fmntr_out1(ma)
      else
          call fmsqr2_r1(ma)
      endif
      ncall = ncall - 1

      return
      end subroutine fmsqr_r1

      subroutine fmsqr_sc(ma, mb, kresult)

!  Check for special cases for mb = ma**2

!  kresult = 1 is returned if a special case gives the value of ma.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: kresult
      intent (in) :: ma
      intent (inout) :: mb, kresult

      type(multi), save :: mxy(1)

      if (mblogs /= mbase) call fmcons
      kresult = 0
      kflag = 0
      if (ma%mp(2) == munkno .and. ma%mp(5) >= 0) then
          call fmunknown(mb)
          kflag = -4
          kresult = 1
          return
      endif
      if (ma%mp(2) == munkno) then
          call fmeq(ma, mxy(1))
          call fmovun_mpy(ma, mxy(1), mb)
          kresult = 1
          return
      endif
      if (abs(ma%mp(2)) == mexpov) then
          call fmeq(ma, mxy(1))
          call fmovun_mpy(ma, mxy(1), mb)
          kresult = 1
          return
      endif
      if (ma%mp(3) == 0) then
          call fmi2m2(0, mb)
          kresult = 1
          return
      endif

      return
      end subroutine fmsqr_sc

      subroutine fmsqrt(ma, mb)

!  mb = sqrt(ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(4), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmsqrt_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call fmsqrt_m(ma, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmsqrt

      subroutine fmsqrt_m(ma, mxy, mresult, ndsave)

!  Method selection for computing sqrt(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      integer :: km4, nmethd
      nmethd = 1
      if (mbase >= 1000 .and. mbase <= mxbase/1.5d0 .and. ndig*alogmt < 1400) then
          nmethd = 4
      else if (ndig*alogmt > 50000) then
          nmethd = 3
      else if (ndig*alogmt > 2750) then
          nmethd = 2
      endif

      if (nmethd == 1) then
          call fmsqrt_m1(ma, mxy, mresult, ndsave)
      else if (nmethd == 2) then
          call fmsqrt_m2(ma, mxy, mresult, ndsave)
      else if (nmethd == 3) then
          call fmsqrt_m3(ma, mxy, mresult, ndsave)
      else if (nmethd == 4) then
          call fmsqrt_m4(ma, mxy, mresult, ndsave, km4)
          if (km4 > 0) then
              call fmsqrt_m1(ma, mxy, mresult, ndsave)
          endif
      endif

      return
      end subroutine fmsqrt_m

      subroutine fmsqrt_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing sqrt(ma).

!  Ordinary Newton iteration.

      use fmvals
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      double precision :: x, xb
      real (kind(1.0d0)) :: ma1, mke
      integer :: nstack(49), j, kma1, kst

      call fmequ(ma, mxy(2), ndsave, ndig)

!             Generate the first approximation.

      ma1 = ma%mp(2)
      mxy(2)%mp(2) = 0
      call fmm2dp(mxy(2), x)
      x = sqrt(x)
      mke = ma1/2
      kma1 = int(abs(ma1))
      if (mod(kma1, 2) == 1) then
          xb = mbase
          x = x*sqrt(xb)
          mke = (ma1-1)/2
      endif
      call fmdpm(x, mxy(3))
      mxy(3)%mp(2) = mxy(3)%mp(2) + mke

!             Initialize.

      call fmi2m(0, mxy(1))
      mxy(2)%mp(2) = ma1
      call fmdig(nstack, kst)

!             Newton iteration.

      do j = 1, kst
         ndig = nstack(j)
         call fmcsdiv(mxy(2), mxy(3), mxy(1))
         call fmcsadd_r1(mxy(3), mxy(1))
         call fmcsdivi_r1(mxy(3), 2)
      enddo
      mxy(3)%mp(1) = 1
      call fmeq(mxy(3), mresult)

      return
      end subroutine fmsqrt_m1

      subroutine fmsqrt_m2(ma, mxy, mresult, ndsave)

!  Method 2 for computing sqrt(ma).

!  Modified Newton iteration.
!                              x2 = x1 - (x1**2 - a) / (2*x1)
!                              where the square is done at full current precision,
!                              and the division is done at half current precision.

      use fmvals
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      double precision :: x, xb
      real (kind(1.0d0)) :: ma1, mke
      integer :: nstack(49), j, kma1, kst

      call fmequ(ma, mxy(2), ndsave, ndig)

!             Generate the first approximation.

      ma1 = ma%mp(2)
      mxy(2)%mp(2) = 0
      call fmm2dp(mxy(2), x)
      x = sqrt(x)
      mke = ma1/2
      kma1 = int(abs(ma1))
      if (mod(kma1, 2) == 1) then
          xb = mbase
          x = x*sqrt(xb)
          mke = (ma1-1)/2
      endif
      call fmdpm(x, mxy(3))
      mxy(3)%mp(2) = mxy(3)%mp(2) + mke

!             Initialize.

      call fmi2m(0, mxy(1))
      call fmi2m(0, mxy(4))
      mxy(2)%mp(2) = ma1
      call fmdig(nstack, kst)

!             Newton iteration.

      do j = 1, kst
         ndig = nstack(j)
         call fmsqr(mxy(3), mxy(1))
         call fmsub_r1(mxy(1), mxy(2))
         if (j > 1) ndig = nstack(j-1)
         call fmadd(mxy(3), mxy(3), mxy(4))
         call fmdiv_r2(mxy(1), mxy(4))
         ndig = nstack(j)
         call fmsub_r1(mxy(3), mxy(4))
      enddo
      mxy(3)%mp(1) = 1
      call fmeq(mxy(3), mresult)

      return
      end subroutine fmsqrt_m2

      subroutine fmsqrt_m3(ma, mxy, mresult, ndsave)

!  Method 3 for computing sqrt(ma).

!  Karp's method.  Newton iteration for 1/sqrt(a)
!                  x2 = x1 + (1 - a*x1**2)*x1/2
!                  where a*x1**2 is done at full current precision,
!                  and *x1/2 is done at half current precision.

      use fmvals
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      double precision :: x, xb
      real (kind(1.0d0)) :: ma1, mke
      integer :: nstack(49), j, kma1, kst

      call fmequ(ma, mxy(2), ndsave, ndig)

!             Generate the first approximation to 1/sqrt(a).

      ma1 = ma%mp(2)
      mxy(2)%mp(2) = 0
      call fmm2dp(mxy(2), x)
      x = 1.0d0/sqrt(x)
      mke = -ma1/2
      kma1 = int(abs(ma1))
      if (mod(kma1, 2) == 1) then
          xb = mbase
          x = x*sqrt(xb)
          mke = -(ma1+1)/2
      endif
      call fmdpm(x, mxy(3))
      mxy(3)%mp(2) = mxy(3)%mp(2) + mke

!             Initialize.

      call fmi2m(1, mxy(1))
      call fmi2m(0, mxy(4))
      mxy(2)%mp(2) = ma1
      call fmdig(nstack, kst)

!             Newton iteration for 1/sqrt(a).

      do j = 1, kst-1
         ndig = nstack(j)
         call fmsqr(mxy(3), mxy(4))
         call fmmpy_r2(mxy(2), mxy(4))
         call fmsub_r2(mxy(1), mxy(4))
         if (j > 1) ndig = nstack(j-1)
         call fmmpy_r2(mxy(3), mxy(4))
         call fmdivi_r1(mxy(4), 2)
         ndig = nstack(j)
         call fmadd_r1(mxy(3), mxy(4))
      enddo

!             Karp's method for speeding up the last iteration and getting sqrt(a).
!             For the last iteration, combine a*x1 to get
!             a*x1 + x1*(a - (a*x1)**2)/2
!             where only the square, -, and + need full precision.

      ndig = nstack(kst)
      if (kst > 1) ndig = nstack(kst-1)
      call fmmpy(mxy(2), mxy(3), mxy(4))
      ndig = nstack(kst)
      call fmsqr(mxy(4), mxy(1))
      call fmsub_r2(mxy(2), mxy(1))
      if (kst > 1) ndig = nstack(kst-1)
      call fmmpy_r2(mxy(3), mxy(1))
      call fmdivi_r1(mxy(1), 2)
      ndig = nstack(kst)
      call fmadd(mxy(4), mxy(1), mxy(3))
      mxy(3)%mp(1) = 1
      call fmeq(mxy(3), mresult)

      return
      end subroutine fmsqrt_m3

      subroutine fmsqrt_m4(ma, mxy, mresult, ndsave, km4)

!  Method 4 for computing sqrt(ma).

!  Direct method.  This is the old-fashioned sqrt algorithm that uses two digits at a time
!                  from ma and is a bit like long division.

      use fmvals
      implicit none

      type(multi) :: ma, mxy(4), mresult
      integer :: ndsave, km4
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, km4

      double precision :: dc, dp, x
      real (kind(1.0d0)) :: mke
      integer :: j, jpt, k, kl, kn

      km4 = 0
      call fmequ(ma, mxy(2), ndsave, ndig)

      call fmi2m(1, mxy(1))
      call fmi2m(1, mxy(3))
      call fmi2m(1, mxy(4))
      mxy(1)%mp(3) = mxy(2)%mp(3)
      mxy(1)%mp(2) = 1
      dc = mxy(1)%mp(3)
      jpt = 2
      kn = max(1, int(min(1000.0d0, maxint/(2*mbase**2)-5)))
      if (mod(int(abs(mxy(2)%mp(2))), 2) == 0) then
          mxy(1)%mp(2) = 1
          mxy(1)%mp(3) = mxy(2)%mp(3) * mbase + mxy(2)%mp(4)
          dc = mxy(1)%mp(3)
          jpt = 3
      endif
      x = int(sqrt(dc))
      mke = 2
      if (mod(mxy(2)%mp(2), mke) == 0) then
          mxy(3)%mp(2) = mxy(2)%mp(2) / 2
      else
          mxy(3)%mp(2) = (mxy(2)%mp(2)+1) / 2
      endif
      mxy(3)%mp(3) = x
      mxy(4)%mp(2) = 1
      mke = x
      mxy(4)%mp(3) = mke*mke
      mxy(1)%mp(3) = mxy(1)%mp(3) - mxy(4)%mp(3)
      dp = mxy(3)%mp(3)
      do j = 2, ndig
         mxy(1)%mp(2) = mxy(1)%mp(2) + 2
         if (jpt <= ndig) then
             mxy(1)%mp(j+2) = mxy(2)%mp(jpt+2)
         endif
         if (jpt+1 <= ndig) then
             mxy(1)%mp(j+3) = mxy(2)%mp(jpt+3)
         endif
         jpt = jpt + 2
         dc = mxy(1)%mp(3)
         if (ndig >= 4) then
             dc = ((dc*mbase + mxy(1)%mp(4))*mbase + mxy(1)%mp(5))*mbase +  &
                   mxy(1)%mp(6)
         else if (ndig == 3) then
             dc = ((dc*mbase + mxy(1)%mp(4))*mbase + mxy(1)%mp(5))*mbase
         else
             dc = ((dc*mbase + mxy(1)%mp(4))*mbase)*mbase
         endif
         if (j <= 4) then
             dp = mxy(3)%mp(3)
             if (ndig >= 3) then
                 dp = (dp*mbase + mxy(3)%mp(4))*mbase + mxy(3)%mp(5)
             else
                 dp = (dp*mbase + mxy(3)%mp(4))*mbase
             endif
         endif
         if (j <= 2) then
             dc = dc*dble(mbase)**int(mxy(1)%mp(2)-4)
             dp = dp*dble(mbase)**(j-4)
             x = floor(dp*mbase*(sqrt(1+dc/(dp*mbase)**2)-1))
         else
             if (int(mxy(1)%mp(2))-j-1 /= 0) then
                 dc = dc*dble(mbase)**(int(mxy(1)%mp(2))-j-1)
             endif
             x = floor(dc/(2.0d0*dp))
         endif
         if (abs(2.0d0 * x * mbase) >= maxint) then
             km4 = 1
             call fmeq(mxy(3), mresult)
             return
         endif
         mxy(4)%mp(2) = j
         kl = min(j, ndig/2+2+ndig/10)
         do k = 3, kl+1
            mke = x
            mxy(4)%mp(k) = 2 * mke * mxy(3)%mp(k)
         enddo
         mke = x
         mxy(4)%mp(j+2) = mke * mke
         mxy(3)%mp(j+2) = x
         if (j == ndig) exit
         if (mxy(1)%mp(2) - mxy(4)%mp(2) /= 1) then
             km4 = 1
             call fmeq(mxy(3), mresult)
             return
         endif
         mxy(1)%mp(2) = mxy(1)%mp(2) - 1
         mxy(1)%mp(3) = mxy(1)%mp(3) * mbase + mxy(1)%mp(4) -  &
                                  mxy(4)%mp(3)
         kl = min(j, ndig/2+2+ndig/10)
         do k = 4, kl+2
            mxy(1)%mp(k) = mxy(1)%mp(k+1) - mxy(4)%mp(k)
         enddo
         mxy(1)%mp(j+3) = 0
         if (mod(j, kn) == 0) then
             do k = j+2, 4, -1
                if (mod(mxy(1)%mp(k), mbase) == 0) then
                    kl = mxy(1)%mp(k) / mbase
                else if (mxy(1)%mp(k) > 0) then
                    kl = mxy(1)%mp(k) / mbase
                else
                    kl = mxy(1)%mp(k) / mbase - 1
                endif
                mxy(1)%mp(k-1) = mxy(1)%mp(k-1) + kl
                mxy(1)%mp(k) = mxy(1)%mp(k) - kl*mbase
             enddo
         endif
      enddo
      do k = ndig+2, 4, -1
         if (mxy(3)%mp(k) >= 0 .and. mxy(3)%mp(k) < mbase) cycle
         if (mod(mxy(3)%mp(k), mbase) == 0) then
             kl = mxy(3)%mp(k) / mbase
         else if (mxy(3)%mp(k) > 0) then
             kl = mxy(3)%mp(k) / mbase
         else
             kl = mxy(3)%mp(k) / mbase - 1
         endif
         mxy(3)%mp(k-1) = mxy(3)%mp(k-1) + kl
         mxy(3)%mp(k) = mxy(3)%mp(k) - kl*mbase
      enddo
      mxy(3)%mp(1) = 1
      call fmeq(mxy(3), mresult)

      return
      end subroutine fmsqrt_m4

      subroutine fmsqrt_r1(ma)

!  ma = sqrt(ma)

      use fmvals
      implicit none

      type(multi) :: ma
      intent (inout) :: ma

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(4), mresult

      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmsqrt_r1_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, ma, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call fmsqrt_m(ma, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, ma, kovun, mxsave, ndsave)

      return
      end subroutine fmsqrt_r1

      subroutine fmsqrt_r1_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = sqrt(ma).

!  kresult = 1 is returned if a special case gives the value of sqrt(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      double precision :: xe, xf
      integer :: j
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMSQRT_R1'
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (mblogs /= mbase) call fmcons
      if (malocal%mp(1) < 0 .or. (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0)) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif
      if (malocal%mp(3) == 0) then
          call fmi2m(0, mresult)
          kresult = 1
          return
      endif
      if (abs(malocal%mp(2)) >= mexpov) then
          call fmovun_xexf(malocal, xe, xf)
          if (mod(xe, 2.0d0) == 0) then
              xe = xe/2
              xf = sqrt(xf)
          else
              xe = (xe+1)/2
              xf = sqrt(xf/mbase)
          endif
          if (xe >= -mxexp0 .and. xe <= mxexp0+1) then
              call fmunknown(mresult)
              mresult%mp(4) = xe
              mresult%mp(5) = -xf*maxint
          else if (xe < -mxexp0) then
              call fmunderflow(1, mresult)
              mresult%mp(4) = xe
              mresult%mp(5) = -xf*maxint
          else
              call fmoverflow(1, mresult)
              mresult%mp(4) = xe
              mresult%mp(5) = -xf*maxint
          endif
          kresult = 1
          return
      endif

      return
      end subroutine fmsqrt_r1_sc

      subroutine fmsqrt_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = sqrt(ma).

!  kresult = 1 is returned if a special case gives the value of sqrt(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      double precision :: xe, xf
      integer :: j
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMSQRT   '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (mblogs /= mbase) call fmcons
      if (malocal%mp(1) < 0 .or. (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0)) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif
      if (malocal%mp(3) == 0) then
          call fmi2m(0, mresult)
          kresult = 1
          return
      endif
      if (abs(malocal%mp(2)) >= mexpov) then
          call fmovun_xexf(malocal, xe, xf)
          if (mod(xe, 2.0d0) == 0) then
              xe = xe/2
              xf = sqrt(xf)
          else
              xe = (xe+1)/2
              xf = sqrt(xf/mbase)
          endif
          if (xe >= -mxexp0 .and. xe <= mxexp0+1) then
              call fmunknown(mresult)
              mresult%mp(4) = xe
              mresult%mp(5) = -xf*maxint
          else if (xe < -mxexp0) then
              call fmunderflow(1, mresult)
              mresult%mp(4) = xe
              mresult%mp(5) = -xf*maxint
          else
              call fmoverflow(1, mresult)
              mresult%mp(4) = xe
              mresult%mp(5) = -xf*maxint
          endif
          kresult = 1
          return
      endif

      return
      end subroutine fmsqrt_sc

      subroutine fmst2d(string, x)

!  string contains a free-format number that is converted to double precision and returned in x.

!  This routine is used mostly by the fm routines that control fomatting and printing of fm numbers.

!  The input number may be in integer or any real format. The convention is made that if
!  no digits appear before 'e' then 1.0 is assumed.  For example, 'e6' is converted as '1.0e+6'.

      use fmvals
      implicit none

      character(*) :: string
      double precision :: x
      intent (in) :: string
      intent (inout) :: x

      integer :: j, jstate, kdigfl, kerr, kexp, kpt, ksign, ksignx, kstart, kstop, ktype, kval, n2
      double precision :: f1, f2

      integer :: jtrans(8, 4) = reshape(  (/    &
                   2, 9, 7, 7, 7, 7, 9, 9,      &
                   3, 3, 3, 5, 5, 8, 8, 8,      &
                   4, 4, 4, 9, 9, 9, 9, 9,      &
                   6, 6, 6, 6, 6, 9, 9, 9   /)  &
        , (/ 8, 4 /) )

      character :: kblank = ' '

      jstate = 1
      ksign = 1
      f1 = 0.0d0
      f2 = 0.0d0
      n2 = 0
      ksignx = 1
      kexp = 0
      kstart = 1
      kstop = len(string)
      kerr = 0
      kflag = 0

!             kdigfl will be 1 if any digits are found before 'e'.

      kdigfl = 0

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      if (lhash == 0) call fmhtbl

!             Scan the number.

      do j = kstart, kstop
         if (string(j:j) == kblank) cycle
         kpt = ichar(string(j:j))
         if (kpt < lhash1 .or. kpt > lhash2) then
             write (kw,                                                         &
                "(/' Error in input conversion.'/"                          //  &
                "' ICHAR function was out of range for the current', "      //  &
                "' dimensions.'/' ICHAR(''', A, ''') gave the value ', "    //  &
                "I12, ', which is outside the currently'/' dimensioned', "  //  &
                "' bounds of (', I5, ':', I5, ') for variables KHASHT ', "  //  &
                "'and KHASHV.'/' Re-define the two parameters ', "          //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain', "   //  &
                "' all possible output values from ICHAR.'//)"                  &
                   ) string(j:j), kpt, lhash1, lhash2
             ktype = 5
             kval  = 0
         else
             ktype = khasht(kpt)
             kval  = khashv(kpt)
         endif
         if (ktype >= 5) then
             kerr = 1
             exit
         endif

         jstate = jtrans(jstate, ktype)

         select case (jstate)

!             State 2.  Sign of the number.

         case (2)
             ksign = kval

!             State 3.  Digits before a decimal point.

         case (3)
             kdigfl = 1
             f1 = 10.0d0*f1 + kval

!             State 4.  Decimal point

         case (4)
             cycle

!             State 5.  Digits after a decimal point.

         case (5)
             kdigfl = 1
             f2 = 10.0d0*f2 + kval
             n2 = n2 + 1

!             State 6.  Precision indicator.

         case (6)
             if (kdigfl == 0) f1 = 1.0d0

!             State 7.  Sign of the exponent.

         case (7)
             ksignx = kval

!             State 8.  Digits of the exponent.

         case (8)
             kexp = 10*kexp + kval

         case default
             kerr = 1
             exit

         end select

      enddo

      if (kerr == 0) then

!             Form the number and return.

          kexp = ksignx*kexp
          x = ksign*(f1 + f2/10.0d0**n2)*10.0d0**kexp
      else

!             Error in converting the number.

          x = -1.0d+31
          kflag = -4
      endif

      return
      end subroutine fmst2d

      subroutine fmst2m(string, ma)

!  ma = string

!  Convert a character string to fm format.
!  This is often more convenient than using fminp, which converts an array of character(1) values.

!  The default convention is that if no digits appear before 'e' then 1.0 is assumed.
!  For example, 'e6' is converted as '1.0e+6'.
!  Change variable keswch in module fmvals to zero if 'e6' should be converted as '0.0e+6' and
!  zero returned in ma.

      use fmvals
      implicit none

      character(*) :: string
      type(multi) :: ma
      intent (in) :: string
      intent (inout) :: ma

      integer :: j, lb, kfsave

      if (mblogs /= mbase) call fmcons
      ncall = ncall + 1
      namest(ncall) = 'FMST2M'
      lb = len(string)
      if (lb > lmbuff) then
          if (lmbuff > 0) deallocate(cmbuff)
          allocate(cmbuff(lb), stat=j)
          if (j /= 0) then
              call fmdefine_error
          endif
          lmbuff = lb
      endif
      kfsave = kflag

      do j = 1, lb
         cmbuff(j) = string(j:j)
      enddo
      ncall = ncall - 1
      call fminp(cmbuff, ma, 1, lb)
      ncall = ncall + 1

      if (kfsave /= 0) kflag = kfsave
      ncall = ncall - 1

      return
      end subroutine fmst2m

      subroutine fmsub(ma, mb, mc)

!  mc = ma + mb

!  This routine performs the trace printing for subtraction.  fmsub2 is used to do the arithmetic.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: kovun

      ncall = ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == mexpov .or. abs(mb%mp(2)) == mexpov) kovun = 1
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) kovun = 2
      if (ntrace /= 0) then
          namest(ncall) = 'FMSUB'
          call fmntr_inp2(ma, mb)
      endif

      call fmsub2(ma, mb, mc)

      if ((abs(mc%mp(2)) == mexpov .and. kovun == 0) .or.  &
          (abs(mc%mp(2)) == munkno .and. kovun < 2)) then
          namest(ncall) = 'FMSUB'
          call fmwarn
      endif
      if (ntrace /= 0) then
          call fmntr_out1(mc)
      endif
      ncall = ncall - 1

      return
      end subroutine fmsub

      subroutine fmsub2(ma, mb, mc)

!  Internal subtraction routine.  mc = ma - mb

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      logical :: retry
      integer :: jsign, kresult

      call fmalloc(mc, ndig+2)
      call fmalloc(mwa, 2*ndig+30)
      ksub = 1
      call fmadd_sc(ma, mb, mc, kresult)
      ksub = 0
      if (kresult > 0) then
          return
      endif

      if (mblogs /= mbase) call fmcons

      kround_retry = 0
      jsign = 1
      retry = .true.
      do while (retry)
         retry = .false.
         ksub = 1
         call fmadd_m1(ma, mb, jsign, retry)
         ksub = 0
      enddo

!             Transfer to mc and fix the sign of the result.

      call fmmove(mwa, mc)
      mc%mp(1) = 1
      if (jsign < 0 .and. mc%mp(3) /= 0) mc%mp(1) = -1

      kround_retry = 0

      return
      end subroutine fmsub2

      subroutine fmsub_r1(ma, mb)

!  ma = ma - mb

!  This routine performs the trace printing for subtraction.  fmsub2_r1 does the arithmetic.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb

      integer :: kovun

      ksub = 1
      ncall = ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == mexpov .or. abs(mb%mp(2)) == mexpov) kovun = 1
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) kovun = 2
      if (ntrace /= 0) then
          namest(ncall) = 'FMSUB_R1'
          call fmntr_inp2(ma, mb)
      endif

      call fmadd2_r1(ma, mb)

      if ((abs(ma%mp(2)) == mexpov .and. kovun == 0) .or.  &
          (abs(ma%mp(2)) == munkno .and. kovun < 2)) then
          namest(ncall) = 'FMSUB_R1'
          call fmwarn
      endif
      if (ntrace /= 0) then
          call fmntr_out1(ma)
      endif
      ksub = 0
      ncall = ncall - 1

      return
      end subroutine fmsub_r1

      subroutine fmsub_r2(ma, mb)

!  mb = ma - mb

!  This routine performs the trace printing for subtraction.  fmsub2_r2 does the arithmetic.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      integer :: kovun

      ksub = 1
      ncall = ncall + 1
      kovun = 0
      if (abs(ma%mp(2)) == mexpov .or. abs(mb%mp(2)) == mexpov) kovun = 1
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) kovun = 2
      if (ntrace /= 0) then
          namest(ncall) = 'FMSUB_R2'
          call fmntr_inp2(ma, mb)
      endif

      call fmadd2_r2(ma, mb)

      if ((abs(mb%mp(2)) == mexpov .and. kovun == 0) .or.  &
          (abs(mb%mp(2)) == munkno .and. kovun < 2)) then
          namest(ncall) = 'FMSUB_R2'
          call fmwarn
      endif
      if (ntrace /= 0) then
          call fmntr_out1(mb)
      endif
      ksub = 0
      ncall = ncall - 1

      return
      end subroutine fmsub_r2

      subroutine fmtan(ma, mb)

!  mb = tan(ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(5), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmtan_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call fmtan_m1(ma, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmtan

      subroutine fmtan_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing tan(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      integer :: jcos, jsin, jswap, kl, ndsv, ntry

      ntry = 1
      kl = 1
      do while (kl == 1)
         call fmequ(ma, mxy(5), ndsave, ndig)
         mxy(5)%mp(1) = 1

!             Reduce the argument, convert to radians if the input is in degrees, and evaluate
!             the function.

         call fmrdc(mxy(5), jsin, jcos, jswap)
         if (kround /= 1 .and. krad /= 1) then
             call fmi2m(45, mxy(1))
             call fmsub(mxy(5), mxy(1), mxy(2))
             if (mxy(2)%mp(3) == 0) then
                 call fmi2m(1, mxy(1))
                 call fmmpyi(mxy(1), jsin/jcos, mresult)
                 if (ma%mp(1) < 0) call fmnegate(mresult)
                 return
             endif
         endif
         if (mxy(5)%mp(2) == munkno) then
             call fmeq(mxy(5), mresult)
             if (ma%mp(1) < 0) call fmnegate(mresult)
             return
         endif
         if (mxy(5)%mp(3) == 0) then
             if (jswap == 1) then
                 call fmunknown(mxy(5))
             endif
             call fmeq(mxy(5), mresult)
             return
         endif
         if (krad == 0) then
             if (mbspi /= mbase .or. ndigpi < ndig) then
                 ndsv = ndig
                 ndig = ndig + 2
                 call fmpi(mxy(4))
                 ndig = ndsv
             endif
             call fmpi(mxy(4))
             call fmmpy_r1(mxy(5), mxy(4))
             call fmdivi_r1(mxy(5), 180)
         endif
         if (mxy(5)%mp(2) /= munkno) then
             if (jswap == 0) then
                 if (mxy(5)%mp(2) < 0) then
                     call fmsin2(mxy(5), mxy(4))
                     mxy(4)%mp(1) = jsin*mxy(4)%mp(1)
                     call fmsqr(mxy(4), mxy(2))
                     call fmi2m(1, mxy(1))
                     call fmsub_r2(mxy(1), mxy(2))
                     if (mxy(2)%mp(2) < 0 .and. ntry == 1) then
                         ntry = 2
                         ndig = ndig - int(mxy(2)%mp(2))
                         if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                         cycle
                     endif
                     call fmsqrt(mxy(2), mxy(3))
                     mxy(3)%mp(1) = jcos*mxy(3)%mp(1)
                     call fmdiv(mxy(4), mxy(3), mxy(5))
                 else
                     call fmcos2(mxy(5), mxy(4))
                     mxy(4)%mp(1) = jcos*mxy(4)%mp(1)
                     call fmsqr(mxy(4), mxy(2))
                     call fmi2m(1, mxy(1))
                     call fmsub_r2(mxy(1), mxy(2))
                     if (mxy(2)%mp(2) < 0 .and. ntry == 1) then
                         ntry = 2
                         ndig = ndig - int(mxy(2)%mp(2))
                         if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                         cycle
                     endif
                     call fmsqrt(mxy(2), mxy(3))
                     mxy(3)%mp(1) = jsin*mxy(3)%mp(1)
                     call fmdiv(mxy(3), mxy(4), mxy(5))
                 endif
             else
                 if (mxy(5)%mp(2) < 0) then
                     call fmsin2(mxy(5), mxy(4))
                     mxy(4)%mp(1) = jcos*mxy(4)%mp(1)
                     call fmsqr(mxy(4), mxy(2))
                     call fmi2m(1, mxy(1))
                     call fmsub_r2(mxy(1), mxy(2))
                     if (mxy(2)%mp(2) < 0 .and. ntry == 1) then
                         ntry = 2
                         ndig = ndig - int(mxy(2)%mp(2))
                         if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                         cycle
                     endif
                     call fmsqrt(mxy(2), mxy(3))
                     mxy(3)%mp(1) = jsin*mxy(3)%mp(1)
                     call fmdiv(mxy(3), mxy(4), mxy(5))
                 else
                     call fmcos2(mxy(5), mxy(4))
                     mxy(4)%mp(1) = jsin*mxy(4)%mp(1)
                     call fmsqr(mxy(4), mxy(2))
                     call fmi2m(1, mxy(1))
                     call fmsub_r2(mxy(1), mxy(2))
                     if (mxy(2)%mp(2) < 0 .and. ntry == 1) then
                         ntry = 2
                         ndig = ndig - int(mxy(2)%mp(2))
                         if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
                         cycle
                     endif
                     call fmsqrt(mxy(2), mxy(3))
                     mxy(3)%mp(1) = jcos*mxy(3)%mp(1)
                     call fmdiv(mxy(4), mxy(3), mxy(5))
                 endif
             endif
         endif
         kl = 0
      enddo
      call fmeq(mxy(5), mresult)
      if (ma%mp(1) < 0) call fmnegate(mresult)

      return
      end subroutine fmtan_m1

      subroutine fmtan_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = tan(ma).

!  kresult = 1 is returned if a special case gives the value of tan(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      double precision :: b, pi, x, xe, xf
      integer :: j, k
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMTAN    '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif
      if (malocal%mp(2) == munkno) then
          if (malocal%mp(5) < 0) then
              call fmovun_xexf(malocal, xe, xf)
              if (2*xe < -ndsave) then
                  if (krad == 1) then
                      call fmeq(malocal, mresult)
                  else
                      call fmpi(mxy(2))
                      call fmmpy_r2(malocal, mxy(2))
                      call fmdivi(mxy(2), 180, mresult)
                  endif
              else
                  call fmunknown(mresult)
                  if (xe*dlogmb+log(xf) < log(1.0d+12)) then
                      b = mbase
                      if (krad == 1) then
                          x = tan(xf*b**xe)
                      else
                          pi = acos(-1.0d0)
                          x = tan(pi*xf*b**xe/180.0d0)
                      endif
                      if (malocal%mp(1) < 0) x = -x
                      if (x < 0) then
                          mresult%mp(1) = -1
                          x = -x
                      endif
                      if (x == 1.0d0) then
                          xe = 1
                          xf = 1/b
                      else
                          xe = 0
                          xf = x
                      endif
                      mresult%mp(4) = xe
                      mresult%mp(5) = -xf*maxint
                  endif
              endif
          else
              call fmunknown(mresult)
          endif
          kresult = 1
          return
      endif
      if (malocal%mp(2) == mexpun) then
          call fmeq(malocal, mresult)
          if (krad == 0) then
              call fmdivi(mresult, 180, mxy(2))
              call fmpi(mxy(1))
              call fmmpy(mxy(2), mxy(1), mresult)
          endif
          kresult = 1
          return
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (kround /= 1 .and. malocal%mp(2) < -ndsave .and. krad == 1) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          call fmsqr(malocal, mxy(1))
          call fmmpy(mxy(1), malocal, mxy(2))
          call fmdivi(mxy(2), 3, mxy(3))
          if (mxy(3)%mp(2) > mexpun) then
              call fmadd(malocal, mxy(3), mresult)
          else if (malocal%mp(2) == mexpun) then
              call fmeq(malocal, mresult)
          else if (malocal%mp(1) < 0 .and. kround == -1) then
              call fmeq(malocal, mxy(1))
              mxy(1)%mp(2) = 0
              call fmulp(mxy(1), mxy(2))
              call fmadd(mxy(1), mxy(2), mresult)
              mresult%mp(2) = malocal%mp(2) + mresult%mp(2)
          else if (malocal%mp(1) >= 0 .and. kround == 2) then
              call fmeq(malocal, mxy(1))
              mxy(1)%mp(2) = 0
              call fmulp(mxy(1), mxy(2))
              call fmadd(mxy(1), mxy(2), mresult)
              mresult%mp(2) = malocal%mp(2) + mresult%mp(2)
          else
              call fmeq(malocal, mresult)
          endif
          if (kflag > 0) kflag = 0
          ntrace = j
          kwarn = k
          kresult = 1
          return
      endif
      if (malocal%mp(2) > 3*10**5 .and. krad == 1) then
          call fmunknown(mresult)
          kresult = 1
      endif

      return
      end subroutine fmtan_sc

      subroutine fmtanh(ma, mb)

!  mb = tanh(ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(5), mresult

      call fmalloc(mb, ndig+2)
      call fmenter1(ma, kovun, mxsave, ndsave)
      call fmtanh_sc(ma, mxy, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call fmtanh_m1(ma, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine fmtanh

      subroutine fmtanh_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing tanh(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      integer :: k, kwrnsv
      real :: x, xt

      call fmequ(ma, mxy(5), ndsave, ndig)
      kwrnsv = kwarn
      if (ma%mp(3) == 0) then
          kwarn = kwrnsv
          if (ma%mp(1) < 0) call fmnegate(mxy(5))
          call fmeq(mxy(5), mresult)
          return
      endif
      mxy(5)%mp(1) = 1

      if (ma%mp(2) >= 1) then
          xt = real((ndig+1)/2)*alogmb
          k = int(log(xt)/alogmb)
          if (ma%mp(2) > k+1) then
              call fmi2m(1, mxy(5))
              kwarn = kwrnsv
              if (ma%mp(1) < 0) call fmnegate(mxy(5))
              call fmeq(mxy(5), mresult)
              return
          else
              x = real(mxy(5)%mp(3)*mbase+mxy(5)%mp(4))*  &
                  real(mbase)**int(mxy(5)%mp(2)-2)
              if (x > xt+5.0) then
                  call fmi2m(1, mxy(5))
                  kwarn = kwrnsv
                  if (ma%mp(1) < 0) call fmnegate(mxy(5))
                  call fmeq(mxy(5), mresult)
                  return
              endif
          endif
      endif
      if (mxy(5)%mp(2) == 0 .and. ndig < 50) then
          call fmexp2(mxy(5), mxy(3))
          call fmsqr_r1(mxy(3))
          call fmi2m(1, mxy(1))
          call fmsub(mxy(3), mxy(1), mxy(2))
          call fmadd_r2(mxy(3), mxy(1))
          call fmdiv(mxy(2), mxy(1), mxy(5))
          kwarn = kwrnsv
          if (ma%mp(1) < 0) call fmnegate(mxy(5))
          call fmeq(mxy(5), mresult)
          return
      endif
      if (mxy(5)%mp(2) >= 0 .and. mxy(5)%mp(3) /= 0) then
          call fmcosh(mxy(5), mxy(4))
          if (mxy(4)%mp(2) > ndig) then
              if (ma%mp(1) > 0) then
                  call fmi2m(1, mxy(5))
                  kwarn = kwrnsv
                  if (ma%mp(1) < 0) call fmnegate(mxy(5))
                  call fmeq(mxy(5), mresult)
                  return
              else
                  call fmi2m(-1, mxy(5))
                  kwarn = kwrnsv
                  if (ma%mp(1) < 0) call fmnegate(mxy(5))
                  call fmeq(mxy(5), mresult)
                  return
              endif
          endif
          call fmsqr(mxy(4), mxy(2))
          call fmi2m(-1, mxy(1))
          call fmadd_r1(mxy(2), mxy(1))
          call fmsqrt_r1(mxy(2))
          call fmdiv(mxy(2), mxy(4), mxy(5))
      else
          call fmsinh(mxy(5), mxy(4))
          call fmsqr(mxy(4), mxy(2))
          call fmi2m(1, mxy(1))
          call fmadd_r1(mxy(2), mxy(1))
          call fmsqrt_r1(mxy(2))
          call fmdiv(mxy(4), mxy(2), mxy(5))
      endif
      kwarn = kwrnsv
      if (ma%mp(1) < 0) call fmnegate(mxy(5))
      call fmeq(mxy(5), mresult)

      return
      end subroutine fmtanh_m1

      subroutine fmtanh_sc(ma, mxy, ndsave, mresult, kresult)

!  Check for special cases for mresult = tanh(ma).

!  kresult = 1 is returned if a special case gives the value of tanh(ma).

      use fmvals
      implicit none

      type(multi) :: ma, mxy(5), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, kresult

      double precision :: xe
      integer :: j, k
      logical :: lcomp
      logical, external :: fmcomp
      type(multi), save :: malocal

      kresult = 0

      namest(ncall) = 'FMTANH   '
      j = ndig
      ndig = ndsave
      call fmntr_inp1(ma)
      ndig = j

      call fmequ(ma, malocal, ndsave, ndig)

      if (malocal%mp(2) == munkno .and. malocal%mp(5) >= 0) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif
      call fmovun_xe(malocal, xe)
      if (2*xe < -ndsave) then
          kflag = 0
          ndig = ndig + ngrd22
          call fmequ(malocal, mxy(1), ndig-ngrd22, ndig)
          call fmeq(mxy(1), mxy(3))
          if (kround /= 1) then
              call fmipwr(mxy(1), 3, mxy(3))
              call fmdivi_r1(mxy(3), 3)
              call fmsub_r2(mxy(1), mxy(3))
          endif
          call fmequ(mxy(3), mresult, ndig, ndig-ngrd22)
          ndig = ndig - ngrd22
          kresult = 1
          return
      endif
      if (malocal%mp(2) >= mexpov) then
          j = ntrace
          ntrace = 0
          call fmabs(malocal, mxy(1))
          call fmmpyi(mxy(1), -2, mxy(2))
          call fmexp(mxy(2), mxy(3))
          call fmmpyi_r1(mxy(3), 2)
          if (malocal%mp(1) > 0) then
              call fmi2m(1, mxy(1))
              call fmsub(mxy(1), mxy(3), mxy(2))
          else
              call fmi2m(-1, mxy(1))
              call fmadd(mxy(1), mxy(3), mxy(2))
          endif
          ntrace = j
          if (kflag == 1) then
              kflag = 0
              call fmeq(mxy(2), mresult)
              kresult = 1
              return
          endif
      endif

!             Rounding for special cases in non-standard rounding modes (kround = -1, 0, or 2).

      if (kround /= 1 .and. malocal%mp(2) < -ndsave) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          call fmsqr(malocal, mxy(1))
          call fmmpy(mxy(1), malocal, mxy(2))
          call fmdivi(mxy(2), -3, mxy(3))
          if (mxy(3)%mp(2) > mexpun) then
              call fmadd(malocal, mxy(3), mresult)
          else if (malocal%mp(2) == mexpun) then
              call fmeq(malocal, mresult)
          else if (malocal%mp(1) < 0 .and. (kround == 2 .or. kround == 0)) then
              call fmeq(malocal, mxy(1))
              mxy(1)%mp(2) = 0
              call fmulp(mxy(1), mxy(2))
              call fmsub(mxy(1), mxy(2), mxy(3))
              mxy(3)%mp(2) = malocal%mp(2) + mxy(3)%mp(2)
              call fmeq(mxy(3), mresult)
          else if (malocal%mp(1) >= 0 .and. (kround == -1 .or. kround == 0)) then
              call fmeq(malocal, mxy(1))
              mxy(1)%mp(2) = 0
              call fmulp(mxy(1), mxy(2))
              call fmsub(mxy(1), mxy(2), mxy(3))
              mxy(3)%mp(2) = malocal%mp(2) + mxy(3)%mp(2)
              call fmeq(mxy(3), mresult)
          else
              call fmeq(malocal, mresult)
          endif
          if (kflag > 0) kflag = 0
          ntrace = j
          kwarn = k
          kresult = 1
          return
      endif
      j = ntrace
      ntrace = 0
      call fmabs(malocal, mxy(1))
      call fmdp2m(dlogmb*ndig, mxy(2))
      lcomp = fmcomp(mxy(1), '>', mxy(2))
      ntrace = j
      if (kround /= 1 .and. lcomp .and. malocal%mp(2) /= munkno) then
          j = ntrace
          ntrace = 0
          k = kwarn
          kwarn = 0
          if (malocal%mp(1) < 0 .and. (kround == 0 .or. kround == 2)) then
              call fmi2m(-1, mxy(1))
              call fmtiny(mxy(2))
              call fmadd(mxy(1), mxy(2), mxy(3))
          else if (malocal%mp(1) > 0 .and. (kround == 0 .or. kround == -1)) then
              call fmi2m(1, mxy(1))
              call fmtiny(mxy(2))
              call fmsub(mxy(1), mxy(2), mxy(3))
          else if (malocal%mp(1) < 0) then
              call fmi2m(-1, mxy(3))
          else
              call fmi2m(1, mxy(3))
          endif
          call fmeq(mxy(3), mresult)
          kflag = 0
          ntrace = j
          kwarn = k
          kresult = 1
          return
      endif

      return
      end subroutine fmtanh_sc

      subroutine fmtiny(ma)

!     ma = The smallest positive representable fm number using the current base and precision.

      use fmvals
      implicit none

      type(multi) :: ma
      intent (inout) :: ma

      integer :: j, n1

      call fmalloc(ma, ndig+2)
      ncall = ncall + 1
      namest(ncall) = 'FMTINY'

      if (mblogs /= mbase) call fmcons
      kflag = 0
      n1 = ndig + 1
      do j = 3, n1
         ma%mp(j+1) = 0
      enddo
      ma%mp(2) = -mxexp0
      ma%mp(1) = 1
      ma%mp(3) = 1

      if (ntrace /= 0) call fmntr_out1(ma)
      ncall = ncall - 1

      return
      end subroutine fmtiny

      subroutine fmtrap(ma)

!  If ma has overflowed or underflowed, replace it by the appropriate symbol.

      use fmvals
      implicit none

      type(multi) :: ma
      intent (inout) :: ma

      integer :: sign_ma
      double precision :: d, xe, xf

      if (ma%mp(2) == mexpov .or. ma%mp(2) == mexpun) then
          if (size(ma%mp) >= 5) then
              if (ma%mp(5) < 0) then
                  if (ma%mp(2) == mexpov .and. kflag /= 1) kflag = -5
                  if (ma%mp(2) == mexpun .and. kflag /= 1) kflag = -6
                  return
              endif
          endif
      endif
      if (ncall <= 0) return
      sign_ma = ma%mp(1)

      if (ma%mp(2) > mxexp+1) then
          xe = ma%mp(2)
          call fmovun_frac(ma, xf)
          if (huge(mbase)/mexpov > 1.0d+20) then
              d = 1.0d+10
          else
              d = 4
          endif
          if (xe > huge(mbase)/d) then
              xe = huge(mbase)/d
              xf = 1.0d0 - epsilon(1.0d0)
          else if (xe < -huge(mbase)/d) then
              xe = -huge(mbase)/d
              xf = 1.0d0 - epsilon(1.0d0)
          else if (xe == xe + 1.0d0) then
              xf = 1.0d0 - epsilon(1.0d0)
          endif

          if (sign_ma > 0) then
              call fmi2m2(0, ma)
              ma%mp(2) = mexpov
              ma%mp(3) = 1
          else
              call fmi2m2(0, ma)
              ma%mp(2) = mexpov
              ma%mp(3) = 1
              ma%mp(1) = -1
          endif
          ma%mp(4) = xe
          ma%mp(5) = -xf*maxint
          kflag = -5
      endif

      if (ma%mp(2) < -mxexp) then
          xe = ma%mp(2)
          call fmovun_frac(ma, xf)
          if (ma%mp(1) > 0) then
              call fmi2m2(0, ma)
              ma%mp(2) = mexpun
              ma%mp(3) = 1
          else
              call fmi2m2(0, ma)
              ma%mp(2) = mexpun
              ma%mp(3) = 1
              ma%mp(1) = -1
          endif
          ma%mp(4) = xe
          ma%mp(5) = -xf*maxint
          kflag = -6
      endif

      return
      end subroutine fmtrap

      subroutine fmulp(ma, mb)

!  mb = The value of one Unit in the Last Place of ma at the current base and precision.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: ma1
      integer :: j, kwrnsv, n1

      call fmalloc(mb, ndig+2)
      call fmalloc(mwa, 2*ndig+30)

      if (mblogs /= mbase) call fmcons
      kflag = 0
      ncall = ncall + 1
      namest(ncall) = 'FMULP'
      if (ntrace /= 0) call fmntr_inp1(ma)

      ma1 = ma%mp(2)
      n1 = ndig + 1
      do j = 3, n1
         mwa%mp(j+1) = 0
      enddo
      mwa%mp(3) = 1
      mwa%mp(2) = ma%mp(2) - ndig + 1
      if (abs(ma%mp(2)) >= mexpov .and. ma%mp(5) < 0) then
          call fmeq(ma, mb)
          mb%mp(4) = mb%mp(4) - ndig
          if (mb%mp(4) < -mxexp) mb%mp(2) = mexpun
          if (mb%mp(4) > 0 .and. mb%mp(4) <= mxexp+1) mb%mp(2) = munkno
          mb%mp(5) = -maxint*(1.0d0/mbase)
      else if (ma%mp(3) == 0 .or. ma%mp(2) == munkno) then
          call fmunknown(mb)
      else
          kwrnsv = kwarn
          if (ma1 == mexpun) kwarn = 0
          if (ma%mp(1) < 0) then
              call fmmove(mwa, mb)
              mb%mp(1) = 1
              if (mb%mp(2) /= munkno .and. mb%mp(3) /= 0) mb%mp(1) = -1
          else
              call fmmove(mwa, mb)
              mb%mp(1) = 1
          endif
          kwarn = kwrnsv
      endif

      if (mb%mp(2) == munkno) kflag = -4
      if (mb%mp(2) == mexpov) kflag = -5
      if (mb%mp(2) == mexpun) kflag = -6
      if (mb%mp(2) == munkno .and. ma%mp(2) /= munkno) call fmwarn
      if (mb%mp(2) == mexpun .and. ma%mp(2) /= munkno .and.  &
          ma%mp(2) /= mexpun) then
          call fmwarn
      endif
      if (ntrace /= 0) then
          call fmntr_out1(mb)
      endif
      ncall = ncall - 1

      return
      end subroutine fmulp

      subroutine fmunderflow(k, ma)

!  Set ma to fm's special value for underflowed results.

!  k = -1 returns ma = -undeflow

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: k
      intent (in) :: k
      intent (inout) :: ma

      integer :: j
      double precision :: d

      call fmalloc(ma, ndig+2)
      do j = 5, ndig+2
         ma%mp(j) = 0
      enddo
      ma%mp(1) = k
      ma%mp(2) = mexpun
      ma%mp(3) = 1
      if (huge(mbase)/mexpov > 1.0d+20) then
          d = 1.0d+10
      else
          d = 4
      endif
      ma%mp(4) = -huge(mbase)/d
      ma%mp(5) = -maxint * (1.0d0 - epsilon(1.0d0))

      end subroutine fmunderflow

      subroutine fmunknown(ma)

!  Set ma to fm's special value for unknown results.

      use fmvals
      implicit none

      type(multi) :: ma
      intent (inout) :: ma

      integer :: j

      call fmalloc(ma, ndig+2)
      do j = 4, ndig+2
         ma%mp(j) = 0
      enddo
      ma%mp(1) = 1
      ma%mp(2) = munkno
      ma%mp(3) = 1

      end subroutine fmunknown

      subroutine fmunpk(mp, ma)

!  mp is unpacked and the value returned in ma.

      use fmvals
      implicit none

      type(multi) :: ma, mp
      intent (in) :: mp
      intent (inout) :: ma

      integer :: j, kp

      call fmalloc(ma, ndig+2)

      if (abs(mp%mp(2)) >= mexpov) then
          do j = 1, 5
             ma%mp(j) = mp%mp(j)
          enddo
          do j = 6, ndig+2
             ma%mp(j) = 0
          enddo
          return
      endif

      kp = 2
      ma%mp(1) = mp%mp(1)
      ma%mp(2) = mp%mp(2)
      ma%mp(3) = aint (abs(mp%mp(3))/mbase)
      ma%mp(4) = abs(mp%mp(3)) - ma%mp(3)*mbase
      if (ndig >= 4) then
          do j = 4, ndig, 2
             kp = kp + 1
             ma%mp(j+1) = aint (mp%mp(kp+1)/mbase)
             ma%mp(j+2) = mp%mp(kp+1) - ma%mp(j+1)*mbase
          enddo
      endif
      if (mod(ndig, 2) == 1) then
          ma%mp(ndig+2) = aint (mp%mp(kp+2)/mbase)
      endif

      return
      end subroutine fmunpk

      subroutine fmvars

!  Write the values of the fm global variables in module fmvals.

      use fmvals
      implicit none

      write (kw,*) ' '
      write (kw,*) ' Current values of the FM global variables.'
      write (kw,*) ' '
      write (kw,*) ' ALOGM2 = ', alogm2
      write (kw,*) ' ALOGMB = ', alogmb
      write (kw,*) ' ALOGMT = ', alogmt
      write (kw,*) ' ALOGMX = ', alogmx
      write (kw,*) ' CMCHAR = ', cmchar
      write (kw,*) ' DLOGEB = ', dlogeb
      write (kw,*) ' DLOGMB = ', dlogmb
      write (kw,*) ' DLOGPI = ', dlogpi
      write (kw,*) ' DLOGTN = ', dlogtn
      write (kw,*) ' DLOGTP = ', dlogtp
      write (kw,*) ' DLOGTW = ', dlogtw
      write (kw,*) ' DPEPS  = ', dpeps
      write (kw,*) ' DPMAX  = ', dpmax
      write (kw,*) ' DPPI   = ', dppi
      write (kw,*) ' INTMAX = ', intmax
      write (kw,*) ' IUNKNO = ', iunkno
      write (kw,*) ' JFORM1 = ', jform1
      write (kw,*) ' JFORM2 = ', jform2
      write (kw,*) ' JFORMZ = ', jformz
      write (kw,*) ' JPRNTZ = ', jprntz
      write (kw,*) ' KESWCH = ', keswch
      write (kw,*) ' KFLAG  = ', kflag
      write (kw,*) ' KRAD   = ', krad
      write (kw,*) ' KROUND = ', kround
      write (kw,*) ' KSUB   = ', ksub
      write (kw,*) ' KSWIDE = ', kswide
      write (kw,*) ' KW     = ', kw
      write (kw,*) ' KWARN  = ', kwarn
      write (kw,*) ' LHASH  = ', lhash
      write (kw,*) ' LHASH1 = ', lhash1
      write (kw,*) ' LHASH2 = ', lhash2
      write (kw,*) ' LJSUMS = ', ljsums
      write (kw,*) ' LMBERN = ', lmbern
      write (kw,*) ' LMBUFF = ', lmbuff
      write (kw,*) ' LMBUFZ = ', lmbufz
      write (kw,*) ' LVLTRC = ', lvltrc
      write (kw,*) ' MAXINT = ', maxint
      write (kw,*) ' MBASE  = ', mbase
      write (kw,*) ' MBLOGS = ', mblogs
      write (kw,*) ' MBS2PI = ', mbs2pi
      write (kw,*) ' MBSBRN = ', mbsbrn
      write (kw,*) ' MBSE   = ', mbse
      write (kw,*) ' MBSEUL = ', mbseul
      write (kw,*) ' MBSGAM = ', mbsgam
      write (kw,*) ' MBSLB  = ', mbslb
      write (kw,*) ' MBSLI  = ', mbsli
      write (kw,*) ' MBSPI  = ', mbspi
      write (kw,*) ' MEXPAB = ', mexpab
      write (kw,*) ' MEXPOV = ', mexpov
      write (kw,*) ' MEXPUN = ', mexpun
      write (kw,*) ' MUNKNO = ', munkno
      write (kw,*) ' MXBASE = ', mxbase
      write (kw,*) ' MXEXP  = ', mxexp
      write (kw,*) ' MXEXP2 = ', mxexp2
      write (kw,*) ' NCALL  = ', ncall
      write (kw,*) ' NDG2PI = ', ndg2pi
      write (kw,*) ' NDGEUL = ', ndgeul
      write (kw,*) ' NDGGAM = ', ndggam
      write (kw,*) ' NDIG   = ', ndig
      write (kw,*) ' NDIGE  = ', ndige
      write (kw,*) ' NDIGLB = ', ndiglb
      write (kw,*) ' NDIGLI = ', ndigli
      write (kw,*) ' NDIGPI = ', ndigpi
      write (kw,*) ' NGRD21 = ', ngrd21
      write (kw,*) ' NGRD22 = ', ngrd22
      write (kw,*) ' NGRD52 = ', ngrd52
      write (kw,*) ' NTRACE = ', ntrace
      write (kw,*) ' NUMBRN = ', numbrn
      write (kw,*) ' RUNKNO = ', runkno
      write (kw,*) ' SPMAX  = ', spmax
      write (kw,*) ' '
      write (kw,*) ' RADIX(1) = ', radix(1), '    DIGITS(1) = ', digits(1)
      write (kw,*) '    HUGE(1) = ', huge(1)
      write (kw,*) ' RADIX(1.0) = ', radix(1.0), '    DIGITS(1.0) = ', digits(1.0)
      write (kw,*) '    HUGE(1.0)    = ', huge(1.0)
      write (kw,*) '    TINY(1.0)    = ', tiny(1.0)
      write (kw,*) '    EPSILON(1.0) = ', epsilon(1.0)
      write (kw,*) ' RADIX(1.0D0) = ', radix(1.0d0), '    DIGITS(1.0D0) = ', digits(1.0d0)
      write (kw,*) '    HUGE(1.0D0)    = ', huge(1.0d0)
      write (kw,*) '    TINY(1.0D0)    = ', tiny(1.0d0)
      write (kw,*) '    EPSILON(1.0D0) = ', epsilon(1.0d0)
      write (kw,*) ' '

      return
      end subroutine fmvars

      subroutine fmwarn

!  Called by one of the fm routines to print a warning message if any error condition arises
!  in that routine.

      use fmvals
      implicit none

      character(9) :: name
      integer :: ncs

      if (kflag >= 0 .or. ncall /= 1 .or. kwarn <= 0) return
      ncs = ncall
      name = namest(ncall)
      write (kw,                                     &
             "(/' Error of type KFLAG =', I3, "  //  &
             "' in FM package in routine ', A/)"     &
            ) kflag, trim(name)

      ncall = ncall - 1
      do while (ncall > 0)
         name = namest(ncall)
         write (kw, "( ' called from ', A)") trim(name)
         ncall = ncall - 1
      enddo

      if (kflag == -1) then
          write (kw, "(' NDIG must be at least 3'/)")
      else if (kflag == -2) then
          write (kw, "(' MBASE must be between 2 and', I10/)") int(mxbase)
      else if (kflag == -3) then
          write (kw,                                                      &
                 "(' An input argument is not a valid FM number.', "  //  &
                 "'  Its exponent is out of range.'/)"                    &
                )
          write (kw, "(' UNKNOWN has been returned.'/)")
      else if (kflag == -4 .or. kflag == -7) then
          write (kw, "(' Invalid input argument for this routine.'/)")
          write (kw, "(' UNKNOWN has been returned.'/)")
      else if (kflag == -5) then
          write (kw, "(' The result has overflowed.'/)")
      else if (kflag == -6) then
          write (kw, "(' The result has underflowed.'/)")
      else if (kflag == -8 .and. (name == 'FMOUT' .or. name == 'ZMOUT')) then
          write (kw,                                                          &
                 "(' The result array is not big enough to hold the', "   //  &
                 "' output character string'/' in the current format.'/"  //  &
                 "' The result ''***...***'' has been returned.'/)"           &
                )
      else if (kflag == -8 .and. (name == 'FMREAD' .or. name == 'ZMREAD')) then
          write (kw,                                                         &
                 "(' The CMBUFF array is not big enough to hold the', "  //  &
                 "' input character string'/"                            //  &
                 "' UNKNOWN has been returned.'/)"                           &
                )
      else if (kflag == -9) then
          write (kw,                                                &
                 "(' Precision could not be raised enough to'"  //  &
                 ", ' provide all requested guard digits.'/)"       &
                )
          write (kw,                                         &
                 "(I23, ' digits were requested (NDIG).'/)"  &
                ) ndig
          write (kw, "(' UNKNOWN has been returned.'/)")
      else if (kflag == -10) then
          if (name == 'FMM2SP') then
              write (kw,                                                      &
                     "(' An FM number was too small in magnitude to ', "  //  &
                     "'convert to single precision.'/)"                       &
                    )
          else
              write (kw,                                                      &
                     "(' An FM number was too small in magnitude to ', "  //  &
                     "'convert to double precision.'/)"                       &
                    )
          endif
          write (kw, "(' Zero has been returned.'/)")
      else if (kflag == -11) then
          write (kw, "(' UNKNOWN has been returned.'/)")
      else if (kflag == -12) then
          write (kw, "(' Array MJSUMS is not large enough.')")
      endif

      ncall = ncs
      if (kwarn >= 2) then
          stop
      endif

      return
      end subroutine fmwarn

      subroutine fmwrit(kwrite, ma)

!  Write ma on unit kwrite.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  These numbers can then be read easily using fmread.

      use fmvals
      implicit none

      integer :: kwrite
      type(multi) :: ma
      intent (in) :: ma, kwrite

      integer :: j, jf1sav, jf2sav, k, ksave, l, last, lb, nd, ndsave, nexp
      type(multi), save :: mxy(1)

      ncall = ncall + 1
      namest(ncall) = 'FMWRIT'
      ndsave = ndig
      ndig = max(ndig+ngrd52, 3)

      call fmequ(ma, mxy(1), ndsave, ndig)
      ksave = kflag
      nd = int(real(ndig)*log10(real(mbase))) + 1
      if (nd < 2) nd = 2
      nexp = int(2.0*log10(real(mxbase))) + 16
      lb = nd + nexp

      jf1sav = jform1
      jf2sav = jform2
      jform1 = 1
      jform2 = nd + 6
      if (lb > lmbuff) then
          if (lmbuff > 0) deallocate(cmbuff)
          allocate(cmbuff(lb), stat=j)
          if (j /= 0) then
              call fmdefine_error
          endif
          lmbuff = lb
      endif

      call fmout(mxy(1), cmbuff, lb)

      kflag = ksave
      ndig = ndsave
      jform1 = jf1sav
      jform2 = jf2sav
      last = lb + 1
      do j = 1, lb
         if (cmbuff(last-j) /= ' ' .or. j == lb) then
             l = last - j
             if (mod(l, 73) /= 0) then
                 write (kwrite, "(4X, 73A1, ' &')") (cmbuff(k), k=1, l)
             else
                 if (l > 73) write (kwrite, "(4X, 73A1, ' &')") (cmbuff(k), k=1, l-73)
                 write (kwrite, "(4X, 73A1)") (cmbuff(k), k=l-72, l)
             endif
             ncall = ncall - 1
             return
         endif
      enddo
      ncall = ncall - 1

      return
      end subroutine fmwrit

      subroutine fmwrite(kwrite, ma)

      use fmvals
      implicit none

      integer :: kwrite
      type(multi) :: ma
      intent (in) :: kwrite, ma

      call fmwrit(kwrite, ma)

      return
      end subroutine fmwrite


!  The random number routines use integer multiple precision arithmetic.

      subroutine fm_random_number(value)

!  fm_random_number generates pseudo-random numbers uniform on (0,1).
!  value is returned as the next random (double precision) number.
!  Neither zero nor one will be returned in value.

!  This version uses the fm package to implement a multiplicative congruential generator.
!  Both the modulus and the multiplier are 49-digit primes, and the period is over 1.0e+49.

!  This generator passes the spectral test, with mu(2), ..., mu(6) =
!    3.40,   4.35,   3.98,   3.19,   3.20.
!  It also has passed Marsaglia's DieHard test suite for random generators.

!  The typical usage is to call fm_random_seed_put once with seed defined as an integer array of
!  length 7 containing seven seed values used to initialize the generator.  A default seed is used
!  if no call to fm_random_seed_put is done.  Then each call to fm_random_number returns the next
!  random value.

!  This example seeds the generator and then fills the array r with random values between 0 and 1.

!        seed = (/ 314159, 265358, 979323, 846264, 338327, 950288, 419716 /)
!        call fm_random_seed_put(seed)
!        do j = 1, n
!           call fm_random_number(r(j))
!        enddo

!  In a fm_random_seed_get call, the seed array is returned that would later restart the generator
!  in fm_random_number at the same place in the sequence.

!      seed = (/ 314159, 265358, 979323, 846264, 338327, 950288, 419716 /)
!      call fm_random_seed_put(seed)
!      do j = 1, 100
!         call fm_random_number(r(j))
!      enddo

!      call fm_random_seed_get(seed)
!      do j = 101, 200
!         call fm_random_number(r(j))
!      enddo

!      call fm_random_seed_put(seed)
!      do j = 201, 300
!         call fm_random_number(r(j))
!      enddo

!  Here the seed is saved after 100 calls.  The seed is used to re-set the generator after 200 calls
!  to the same state it had after 100 calls, and r(201), ..., r(300) is the same sequence as
!  r(101), ..., r(200).

      use fmvals
      implicit none

      double precision :: value
      intent (inout) :: value

      double precision :: dpx
      integer :: j, jbase, kl, last_digit_of_x, pos_of_last_digit
      integer :: seed(7) = (/314159, 265358, 979323, 846264, 338327, 950288, 419716/)
      save jbase, seed
      real (kind(1.0d0)) :: msave
      logical, external :: imcomp
      type(multi), save :: mxy(2)


      ncall = ncall + 1
      if (ncall <= lvltrc .and. abs(ntrace) >= 2) then
          namest(ncall) = 'FM_RANDOM'
          write (kw, "(' Input to fm_random_number')")
      endif

!             Variables (in module fmvals).

!             mbrand is the base (value of mbase) used for computing the random numbers.  This
!                    allows the user to change mbase without causing problems in fm_random_number.

!             The multiplicative congruence used by the generator is
!                 x = ( a*x + c ) mod m
!             where all four are integers.
!             mrnx is x  (the current random integer)
!             mrna is a  (the multiplier, defined in fm_random_seed_put)
!             mrnc is c  (c = 1 for this generator)
!             mrnm is m  (the modulus, defined in fm_random_seed_put)

!             x is the current value of the random sequence.
!             value is then returned as approximately x/m.

      msave = mbase
      mbase = mbrand
      if (msave /= mbase) call fmcons

!             start_random_sequence =  0  for normal operation.  Get the next random value.
!                                   =  1  for the first call after the user has called
!                                         fm_random_seed.  Use that value in mrnx to initialize.
!                                   = -1  for the first user call if there was no initializing call
!                                         to fm_random_seed.  Use a default seed to initialize mrnx.

      if (start_random_sequence /= 0) then
          if (start_random_sequence == -1) then
              call fm_random_seed_put(seed)
          endif
          start_random_sequence = 0
      endif
      jbase = int(mbase) - 1

!             Get the next number in the sequence.

      dpx = mrnx%mp(3)
      kl = 1
      do while (kl == 1)
         call immpym(mrna, mrnx, mrnm, mxy(2))
         pos_of_last_digit = int(mxy(2)%mp(2)) + 2
         do j = 1, pos_of_last_digit
            mrnx%mp(j) = mxy(2)%mp(j)
         enddo
         last_digit_of_x = int(mrnx%mp(pos_of_last_digit))
         if (last_digit_of_x == last_digit_of_m_m1) then
             call imadd(mrnx, mrnc, mxy(1))
             call imeq(mxy(1), mrnx)
             if (imcomp(mrnx, '>=', mrnm)) then
                 call imsub(mrnx, mrnm, mxy(1))
                 call imeq(mxy(1), mrnx)
             endif
         else if (last_digit_of_x < jbase) then
             mrnx%mp(pos_of_last_digit) = mrnx%mp(pos_of_last_digit) + 1
         else
             call imadd(mrnx, mrnc, mxy(1))
             call imeq(mxy(1), mrnx)
         endif

!             Convert to double precision.

         dpx = mrnx%mp(3)
         do j = 4, pos_of_last_digit
            dpx = mbase*dpx + mrnx%mp(j)
         enddo

         dpx = dpx*dpm
         if (dpx >= 1.0d0 .or. dpx <= 0.0d0) then
             cycle
         else
             kl = 0
         endif
      enddo

      value = dpx

      if (ncall <= lvltrc .and. abs(ntrace) >= 1) then
          write (kw,                                                     &
                 "(' ', A, 5X, 'Call level =', I2, 5X, 'MBASE =', I10)"  &
                ) 'fm_random_number', ncall, int(mbase)
          write (kw, "(1X, D30.20)") value
      endif
      ncall = ncall - 1

      if (msave /= mbase) then
          mbase = msave
          call fmcons
      endif

      return
      end subroutine fm_random_number

      subroutine fm_random_seed_get(seed)

!  Return seed(1) through seed(7) as the current state of the generator.
!  See the comments in routine fm_random_number.

      use fmvals
      implicit none

      integer :: seed(7)
      intent (inout) :: seed

      real (kind(1.0d0)) :: msave
      integer :: scr(7) = (/462643, 383279, 502884, 197163, 141592, 653589, 793238/)
      integer :: j, k
      type(multi), save :: mxy(3)


      msave = mbase
      mbase = mbrand
      if (mblogs /= mbase) call fmcons
      k = 10**7
      call imi2m(k, mxy(2))
      call imeq(mrnx, mxy(1))
      do j = 7, 1, -1
         call immod(mxy(1), mxy(2), mxy(3))
         call imm2i(mxy(3), seed(j))
         seed(j) = seed(j) - scr(j)
         if (seed(j) < 0) then
             seed(j) = seed(j) + k
         endif
         call imdivi(mxy(1), k, mxy(3))
         call imeq(mxy(3), mxy(1))
      enddo
      mbase = msave
      if (mblogs /= mbase) call fmcons

      return
      end subroutine fm_random_seed_get

      subroutine fm_random_seed_put(seed)

!  Use seed(1) through seed(7) to initialize the fm_random_number generator.
!  See the comments in routine fm_random_number.

      use fmvals
      implicit none

      integer :: seed(7)
      intent (in) :: seed

      real (kind(1.0d0)) :: msave
      integer :: scr(7) = (/462643, 383279, 502884, 197163, 141592, 653589, 793238/)
      integer :: j, k, l
      type(multi), save :: mxy(2)


      msave = mbase
      mbase = mbrand
      if (mblogs /= mbase) call fmcons
      call imst2m('1424133622579837639401183671018194926834820238197', mrna)
      call imst2m('2070613773952029032014000773560846464373793273739', mrnm)
      k = 10**7
      l = abs(seed(1)) + scr(1)
      if (l <= k) then
          call imi2m(l, mrnx)
      else
          call imi2m(l-k, mrnx)
      endif
      do j = 2, 7
         call immpyi(mrnx, k, mxy(2))
         l = abs(seed(j)) + scr(j)
         if (l <= k) then
             call imi2m(l, mxy(1))
         else
             call imi2m(l-k, mxy(1))
         endif
         call imadd(mxy(2), mxy(1), mrnx)
      enddo
      call immod(mrnx, mrnm, mxy(2))
      call imeq(mxy(2), mrnx)
      start_random_sequence = 1
      j = mrnm%mp(2)
      last_digit_of_m_m1 = int(mrnm%mp(j+2)) - 1
      call imi2m(1, mrnc)
      call imm2dp(mrnm, dpm)
      dpm = 1.0d0/dpm

      mbase = msave
      if (mblogs /= mbase) call fmcons

      return
      end subroutine fm_random_seed_put

      subroutine fm_random_seed_size(size)

!  Return the size of the seed array used by the fm_random_number generator.

      use fmvals
      implicit none

      integer :: size
      intent (inout) :: size

      size = 7

      return
      end subroutine fm_random_seed_size


!  Here are the routines that work with packed fm numbers.  All names are the same as unpacked
!  versions with 'fm' replaced by 'fp'.

!  This packed format is not available when using the fm, im, or zm derived types.

      subroutine fpabs(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmabs(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpabs

      subroutine fpacos(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmacos(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpacos

      subroutine fpacosh(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmacosh(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpacosh

      subroutine fpadd(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmadd(mpa, mpb, mpc)
      call fmpack(mpc, mc)
      return
      end subroutine fpadd

      subroutine fpadd_r1(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmadd_r1(mpa, mpb)
      call fmpack(mpa, ma)
      return
      end subroutine fpadd_r1

      subroutine fpadd_r2(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmadd_r2(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpadd_r2

      subroutine fpaddi(ma, l)
      use fmvals
      implicit none
      type(multi) :: ma
      intent (inout) :: ma
      intent (in) :: l
      integer :: l
      call fmunpk(ma, mpa)
      call fmaddi(mpa, l)
      call fmpack(mpa, ma)
      return
      end subroutine fpaddi

      subroutine fpasin(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmasin(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpasin

      subroutine fpasinh(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmasinh(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpasinh

      subroutine fpatan(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmatan(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpatan

      subroutine fpatan2(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fpatn2(ma, mb, mc)
      return
      end subroutine fpatan2

      subroutine fpatanh(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmatanh(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpatanh

      subroutine fpatn2(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmatn2(mpa, mpb, mpc)
      call fmpack(mpc, mc)
      return
      end subroutine fpatn2

      subroutine fpbern(intval, ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      integer :: intval
      intent (in) :: ma, intval
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmbern(intval, mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpbern

      subroutine fpbernoulli(intval, ma)
      use fmvals
      implicit none
      type(multi) :: ma
      integer :: intval
      intent (in) :: intval
      intent (inout) :: ma
      call fmbernoulli(intval, mpa)
      call fmpack(mpa, ma)
      return
      end subroutine fpbernoulli

      subroutine fpbesj(ival, ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmbesj(ival, mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpbesj

      subroutine fpbesy(ival, ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmbesy(ival, mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpbesy

      subroutine fpbeta(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmbeta(mpa, mpb, mpc)
      call fmpack(mpc, mc)
      return
      end subroutine fpbeta

      subroutine fpbig(ma)
      use fmvals
      implicit none
      type(multi) :: ma
      intent (inout) :: ma
      call fmbig(mpa)
      call fmpack(mpa, ma)
      return
      end subroutine fpbig

      subroutine fpc(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmc(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpc

      subroutine fpchi(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmchi(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpchi

      subroutine fpchsh(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      call fmunpk(ma, mpa)
      call fmchsh(mpa, mpb, mpc)
      call fmpack(mpb, mb)
      call fmpack(mpc, mc)
      return
      end subroutine fpchsh

      subroutine fpci(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmci(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpci

      subroutine fpcmbi(n, k, ma)
      use fmvals
      implicit none
      type(multi) :: ma
      integer :: k, n
      intent (in) :: n, k
      intent (inout) :: ma
      call fmcmbi(n, k, mpa)
      call fmpack(mpa, ma)
      return
      end subroutine fpcmbi

      subroutine fpcomb(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmcomb(mpa, mpb, mpc)
      call fmpack(mpc, mc)
      return
      end subroutine fpcomb

      function fpcomp(ma, lrel, mb)
      use fmvals
      implicit none
      logical :: fpcomp
      logical, external :: fmcomp
      character(*) :: lrel
      type(multi) :: ma, mb
      intent (in) :: ma, mb, lrel
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      fpcomp = fmcomp(mpa, lrel, mpb)
      return
      end function fpcomp

      function fpcompare(ma, lrel, mb)
      use fmvals
      implicit none
      logical :: fpcompare
      character(*) :: lrel
      type(multi) :: ma, mb
      intent (in) :: ma, mb, lrel
      logical, external :: fpcomp
      fpcompare = fpcomp(ma, lrel, mb)
      return
      end function fpcompare

      subroutine fpcos(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmcos(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpcos

      subroutine fpcos_sin(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      call fpcssn(ma, mb, mc)
      return
      end subroutine fpcos_sin

      subroutine fpcosh(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmcosh(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpcosh

      subroutine fpcosh_sinh(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      call fpchsh(ma, mb, mc)
      return
      end subroutine fpcosh_sinh

      subroutine fpcssn(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      call fmunpk(ma, mpa)
      call fmcssn(mpa, mpb, mpc)
      call fmpack(mpb, mb)
      call fmpack(mpc, mc)
      return
      end subroutine fpcssn

      subroutine fpdig(nstack, kst)
      use fmvals
      implicit none
      integer :: nstack(49), kst
      intent (inout) :: nstack, kst
      call fmdig(nstack, kst)
      return
      end subroutine fpdig

      subroutine fpdim(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmdim(mpa, mpb, mpc)
      call fmpack(mpc, mc)
      return
      end subroutine fpdim

      subroutine fpdiv(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmdiv(mpa, mpb, mpc)
      call fmpack(mpc, mc)
      return
      end subroutine fpdiv

      subroutine fpdiv_r1(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmdiv_r1(mpa, mpb)
      call fmpack(mpa, ma)
      return
      end subroutine fpdiv_r1

      subroutine fpdiv_r2(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmdiv_r2(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpdiv_r2

      subroutine fpdivi(ma, ival, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma, ival
      intent (inout) :: mb
      integer :: ival
      call fmunpk(ma, mpa)
      call fmdivi(mpa, ival, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpdivi

      subroutine fpdivi_r1(ma, ival)
      use fmvals
      implicit none
      type(multi) :: ma
      intent (inout) :: ma
      intent (in) :: ival
      integer :: ival
      call fmunpk(ma, mpa)
      call fmdivi_r1(mpa, ival)
      call fmpack(mpa, ma)
      return
      end subroutine fpdivi_r1

      subroutine fpdp2m(x, ma)
      use fmvals
      implicit none
      double precision :: x
      type(multi) :: ma
      intent (in) :: x
      intent (inout) :: ma
      call fmdp2m(x, mpa)
      call fmpack(mpa, ma)
      return
      end subroutine fpdp2m

      subroutine fpdpm(x, ma)
      use fmvals
      implicit none
      double precision :: x
      type(multi) :: ma
      intent (in) :: x
      intent (inout) :: ma
      call fmdpm(x, mpa)
      call fmpack(mpa, ma)
      return
      end subroutine fpdpm

      subroutine fpei(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmei(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpei

      subroutine fpen(ival, ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmen(ival, mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpen

      subroutine fpeq(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmeq(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpeq

      subroutine fpequ(ma, mb, nda, ndb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      integer :: nda, ndb
      intent (in) :: ma, nda, ndb
      intent (inout) :: mb
      call fpequ_unpck(ma, nda, mpa)
      call fmequ_r1(mpa, nda, ndb)
      call fpequ_pack(mpa, ndb, mb)
      return
      end subroutine fpequ

      subroutine fpequ_pack(ma, nd, mp)

!  ma (with nd digits) is packed two base mbase digits per word and returned in mp.

      use fmvals
      implicit none
      type(multi) :: ma, mp
      intent (in) :: ma, nd
      intent (inout) :: mp
      integer :: j, kp, nd
      call fmalloc(mp, nd/2+4)
      if (abs(ma%mp(2)) >= mexpov) then
          do j = 1, 5
             mp%mp(j) = ma%mp(j)
          enddo
          do j = 6, nd/2+4
             mp%mp(j) = 0
          enddo
          return
      endif
      kp = 2
      mp%mp(1) = ma%mp(1)
      mp%mp(2) = ma%mp(2)
      mp%mp(3) = abs(ma%mp(3))*mbase + ma%mp(4)
      if (nd >= 4) then
          do j = 4, nd, 2
             kp = kp + 1
             mp%mp(kp+1) = ma%mp(j+1)*mbase + ma%mp(j+2)
          enddo
      endif
      if (mod(nd, 2) == 1) mp%mp(kp+2) = ma%mp(nd+2)*mbase
      return
      end subroutine fpequ_pack

      subroutine fpequ_r1(ma, nda, ndb)
      use fmvals
      implicit none
      type(multi) :: ma
      integer :: nda, ndb
      intent (inout) :: ma
      intent (in) :: nda, ndb
      call fpequ_unpck(ma, nda, mpa)
      call fmequ_r1(mpa, nda, ndb)
      call fpequ_pack(mpa, ndb, ma)
      return
      end subroutine fpequ_r1

      subroutine fpequ_unpck(mp, nd, ma)

!  mp (with nd digits) is unpacked and the value returned in ma.

      use fmvals
      implicit none
      type(multi) :: ma, mp
      intent (in) :: mp, nd
      intent (inout) :: ma
      integer :: j, kp, nd
      call fmalloc(ma, nd+2)
      if (abs(mp%mp(2)) >= mexpov) then
          do j = 1, 5
             ma%mp(j) = mp%mp(j)
          enddo
          do j = 6, nd+2
             ma%mp(j) = 0
          enddo
          return
      endif
      kp = 2
      ma%mp(1) = mp%mp(1)
      ma%mp(2) = mp%mp(2)
      ma%mp(3) = aint (abs(mp%mp(3))/mbase)
      ma%mp(4) = abs(mp%mp(3)) - ma%mp(3)*mbase
      if (nd >= 4) then
          do j = 4, nd, 2
             kp = kp + 1
             ma%mp(j+1) = aint (mp%mp(kp+1)/mbase)
             ma%mp(j+2) = mp%mp(kp+1) - ma%mp(j+1)*mbase
          enddo
      endif
      if (mod(nd, 2) == 1) then
          ma%mp(nd+2) = aint (mp%mp(kp+2)/mbase)
      endif
      return
      end subroutine fpequ_unpck

      subroutine fperf(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmerf(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fperf

      subroutine fperfc(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmerfc(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fperfc

      subroutine fperfcs(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmerfcs(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fperfcs

      subroutine fpeuler(ma)
      use fmvals
      implicit none
      type(multi) :: ma
      intent (inout) :: ma
      call fpeulr(ma)
      return
      end subroutine fpeuler

      subroutine fpeulr(ma)
      use fmvals
      implicit none
      type(multi) :: ma
      intent (inout) :: ma
      call fmeulr(mpa)
      call fmpack(mpa, ma)
      return
      end subroutine fpeulr

      subroutine fpexp(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmexp(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpexp

      subroutine fpfact(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmfact(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpfact

      subroutine fpflag(k)
      use fmvals
      implicit none
      integer :: k
      intent (inout) :: k
      k = kflag
      return
      end subroutine fpflag

      subroutine fpform(form, ma, string)
      use fmvals
      implicit none
      character(*) :: form, string
      type(multi) :: ma
      intent (in) :: ma, form
      intent (inout) :: string
      call fmunpk(ma, mpa)
      call fmform(form, mpa, string)
      return
      end subroutine fpform

      subroutine fpfprint(form, ma)
      use fmvals
      implicit none
      character(*) :: form
      type(multi) :: ma
      intent (in) :: ma, form
      call fpfprt(form, ma)
      return
      end subroutine fpfprint

      subroutine fpfprt(form, ma)
      use fmvals
      implicit none
      character(*) :: form
      type(multi) :: ma
      intent (in) :: ma, form
      call fmunpk(ma, mpa)
      call fmfprt(form, mpa)
      return
      end subroutine fpfprt

      subroutine fpgam(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmgam(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpgam

      subroutine fphypot(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmhypot(mpa, mpb, mpc)
      call fmpack(mpc, mc)
      return
      end subroutine fphypot

      subroutine fpi2m(ival, ma)
      use fmvals
      implicit none
      integer :: ival
      type(multi) :: ma
      intent (in) :: ival
      intent (inout) :: ma
      call fmi2m(ival, mpa)
      call fmpack(mpa, ma)
      return
      end subroutine fpi2m

      subroutine fpibta(ma, mb, mc, md)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmunpk(mc, mpc)
      call fmibta(mpa, mpb, mpc, mpd)
      call fmpack(mpd, md)
      return
      end subroutine fpibta

      subroutine fpigm1(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmigm1(mpa, mpb, mpc)
      call fmpack(mpc, mc)
      return
      end subroutine fpigm1

      subroutine fpigm2(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmigm2(mpa, mpb, mpc)
      call fmpack(mpc, mc)
      return
      end subroutine fpigm2

      subroutine fpinp(line, ma, la, lb)
      use fmvals
      implicit none
      integer :: la, lb
      character :: line(lb)
      type(multi) :: ma
      intent (in) :: line, la, lb
      intent (inout) :: ma
      call fminp(line, mpa, la, lb)
      call fmpack(mpa, ma)
      return
      end subroutine fpinp

      subroutine fpint(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmint(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpint

      subroutine fpipower(ma, ival, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      call fpipwr(ma, ival, mb)
      return
      end subroutine fpipower

      subroutine fpipwr(ma, ival, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma, ival
      intent (inout) :: mb
      integer :: ival
      call fmunpk(ma, mpa)
      call fmipwr(mpa, ival, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpipwr

      subroutine fplerc(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmlerc(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fplerc

      subroutine fplg10(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmlg10(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fplg10

      subroutine fpli(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmli(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpli

      subroutine fpln(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmln(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpln

      subroutine fplngm(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmlngm(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fplngm

      subroutine fplni(ival, ma)
      use fmvals
      implicit none
      integer :: ival
      type(multi) :: ma
      intent (in) :: ival
      intent (inout) :: ma
      call fmlni(ival, mpa)
      call fmpack(mpa, ma)
      return
      end subroutine fplni

      subroutine fplog10(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fplg10(ma, mb)
      return
      end subroutine fplog10

      subroutine fpm2dp(ma, x)
      use fmvals
      implicit none
      type(multi) :: ma
      double precision :: x
      intent (in) :: ma
      intent (inout) :: x
      call fmunpk(ma, mpa)
      call fmm2dp(mpa, x)
      return
      end subroutine fpm2dp

      subroutine fpm2i(ma, ival)
      use fmvals
      implicit none
      type(multi) :: ma
      intent (in) :: ma
      intent (inout) :: ival
      integer :: ival
      call fmunpk(ma, mpa)
      call fmm2i(mpa, ival)
      return
      end subroutine fpm2i

      subroutine fpm2sp(ma, x)
      use fmvals
      implicit none
      type(multi) :: ma
      intent (in) :: ma
      intent (inout) :: x
      real :: x
      call fmunpk(ma, mpa)
      call fmm2sp(mpa, x)
      return
      end subroutine fpm2sp

      subroutine fpmax(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmmax(mpa, mpb, mpc)
      call fmpack(mpc, mc)
      return
      end subroutine fpmax

      subroutine fpmin(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmmin(mpa, mpb, mpc)
      call fmpack(mpc, mc)
      return
      end subroutine fpmin

      subroutine fpmod(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmmod(mpa, mpb, mpc)
      call fmpack(mpc, mc)
      return
      end subroutine fpmod

      subroutine fpmpy(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmmpy(mpa, mpb, mpc)
      call fmpack(mpc, mc)
      return
      end subroutine fpmpy

      subroutine fpmpy_r1(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmmpy_r1(mpa, mpb)
      call fmpack(mpa, ma)
      return
      end subroutine fpmpy_r1

      subroutine fpmpy_r2(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmmpy_r2(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpmpy_r2

      subroutine fpmpyi(ma, ival, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma, ival
      intent (inout) :: mb
      integer :: ival
      call fmunpk(ma, mpa)
      call fmmpyi(mpa, ival, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpmpyi

      subroutine fpmpyi_r1(ma, ival)
      use fmvals
      implicit none
      type(multi) :: ma
      intent (inout) :: ma
      intent (in) :: ival
      integer :: ival
      call fmunpk(ma, mpa)
      call fmmpyi_r1(mpa, ival)
      call fmpack(mpa, ma)
      return
      end subroutine fpmpyi_r1

      subroutine fpnint(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmnint(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpnint

      subroutine fpout(ma, line, lb)
      use fmvals
      implicit none
      type(multi) :: ma
      intent (in) :: ma, lb
      intent (inout) :: line
      integer :: lb
      character :: line(lb)
      call fmunpk(ma, mpa)
      call fmout(mpa, line, lb)
      return
      end subroutine fpout

      subroutine fppgam(n, ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      integer :: n
      intent (in) :: ma, n
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmpgam(n, mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fppgam

      subroutine fppi(ma)
      use fmvals
      implicit none
      type(multi) :: ma
      intent (inout) :: ma
      call fmpi(mpa)
      call fmpack(mpa, ma)
      return
      end subroutine fppi

      subroutine fppoch(ma, n, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      integer :: n
      intent (in) :: ma, n
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmpoch(mpa, n, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fppoch

      subroutine fppower(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fppwr(ma, mb, mc)
      return
      end subroutine fppower

      subroutine fpprint(ma)
      use fmvals
      implicit none
      type(multi) :: ma
      intent (in) :: ma
      call fpprnt(ma)
      return
      end subroutine fpprint

      subroutine fpprnt(ma)
      use fmvals
      implicit none
      type(multi) :: ma
      intent (in) :: ma
      call fmunpk(ma, mpa)
      call fmprnt(mpa)
      return
      end subroutine fpprnt

      subroutine fppsi(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmpsi(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fppsi

      subroutine fppwr(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmpwr(mpa, mpb, mpc)
      call fmpack(mpc, mc)
      return
      end subroutine fppwr

      subroutine fprational_power(ma, ival, jval, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      integer :: ival, jval
      intent (in) :: ma, ival, jval
      intent (inout) :: mb
      call fprpwr(ma, ival, jval, mb)
      return
      end subroutine fprational_power

      subroutine fpread(kread, ma)
      use fmvals
      implicit none
      integer :: kread
      type(multi) :: ma
      intent (in) :: kread
      intent (inout) :: ma
      call fmread(kread, mpa)
      call fmpack(mpa, ma)
      return
      end subroutine fpread

      subroutine fprpwr(ma, kval, jval, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma, kval, jval
      intent (inout) :: mb
      integer :: kval, jval
      call fmunpk(ma, mpa)
      call fmrpwr(mpa, kval, jval, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fprpwr

      subroutine fps(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fms(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fps

      subroutine fpset(nprec)
      use fmvals
      implicit none
      integer :: nprec
      intent (in) :: nprec
      call fmset(nprec)
      return
      end subroutine fpset

      subroutine fpsetvar(string)
      use fmvals
      implicit none
      character(*) :: string
      intent (in) :: string
      call fmsetvar(string)
      return
      end subroutine fpsetvar

      subroutine fpshi(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmshi(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpshi

      subroutine fpsi(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmsi(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpsi

      subroutine fpsign(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmsign(mpa, mpb, mpc)
      call fmpack(mpc, mc)
      return
      end subroutine fpsign

      subroutine fpsin(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmsin(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpsin

      subroutine fpsinh(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmsinh(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpsinh

      subroutine fpsp2m(x, ma)
      use fmvals
      implicit none
      real :: x
      type(multi) :: ma
      intent (in) :: x
      intent (inout) :: ma
      call fmsp2m(x, mpa)
      call fmpack(mpa, ma)
      return
      end subroutine fpsp2m

      subroutine fpsqr(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmsqr(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpsqr

      subroutine fpsqr_r1(ma)
      use fmvals
      implicit none
      type(multi) :: ma
      intent (inout) :: ma
      call fmunpk(ma, mpa)
      call fmsqr_r1(mpa)
      call fmpack(mpa, ma)
      return
      end subroutine fpsqr_r1

      subroutine fpsqrt(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmsqrt(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpsqrt

      subroutine fpsqrt_r1(ma)
      use fmvals
      implicit none
      type(multi) :: ma
      intent (inout) :: ma
      call fmunpk(ma, mpa)
      call fmsqrt_r1(mpa)
      call fmpack(mpa, ma)
      return
      end subroutine fpsqrt_r1

      subroutine fpst2m(string, ma)
      use fmvals
      implicit none
      character(*) :: string
      type(multi) :: ma
      intent (in) :: string
      intent (inout) :: ma
      call fmst2m(string, mpa)
      call fmpack(mpa, ma)
      return
      end subroutine fpst2m

      subroutine fpsub(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmsub(mpa, mpb, mpc)
      call fmpack(mpc, mc)
      return
      end subroutine fpsub

      subroutine fpsub_r1(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmsub_r1(mpa, mpb)
      call fmpack(mpa, ma)
      return
      end subroutine fpsub_r1

      subroutine fpsub_r2(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmunpk(mb, mpb)
      call fmsub_r2(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpsub_r2

      subroutine fptan(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmtan(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fptan

      subroutine fptanh(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmtanh(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fptanh

      subroutine fptiny(ma)
      use fmvals
      implicit none
      type(multi) :: ma
      intent (inout) :: ma
      call fmtiny(mpa)
      call fmpack(mpa, ma)
      return
      end subroutine fptiny

      subroutine fpulp(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call fmulp(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine fpulp

      subroutine fpvars
      use fmvals
      implicit none
      call fmvars
      return
      end subroutine fpvars

      subroutine fpwrit(kwrite, ma)
      use fmvals
      implicit none
      integer :: kwrite
      type(multi) :: ma
      intent (in) :: ma, kwrite
      call fmunpk(ma, mpa)
      call fmwrit(kwrite, mpa)
      return
      end subroutine fpwrit

      subroutine fpwrite(kwrite, ma)
      use fmvals
      implicit none
      integer :: kwrite
      type(multi) :: ma
      intent (in) :: ma, kwrite
      call fpwrit(kwrite, ma)
      return
      end subroutine fpwrite


      subroutine im_or_fm_add(ma, mb, mc)

!  Internal routine used by binary splitting algorithms.
!  ma and mb are integers, but if they get bigger than the current precision can represent exactly,
!  it is faster to use fm routines in place of im routines.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      type(multi), save :: m1, m2
      integer :: result_size

      if (max(ma%mp(2), mb%mp(2)) > ndig) then
          call fmalloc(mc, ndig+2)
      else
          result_size = max(ma%mp(2), mb%mp(2)) + 4
          if (abs(result_size) >= mexpov) result_size = 5
          result_size = max(5, result_size)
          call fmalloc(mc, result_size)
      endif

      if (max(ma%mp(2), mb%mp(2)) > ndig) then
          if (ma%mp(2) >= ndig .and. mb%mp(2) >= ndig) then
              call fmadd(ma, mb, mc)
          else if (ma%mp(2) >= ndig .and. mb%mp(2) < ndig) then
              call imi2fm(mb, m2)
              call fmadd(ma, m2, mc)
          else if (ma%mp(2) < ndig .and. mb%mp(2) >= ndig) then
              call imi2fm(ma, m1)
              call fmadd(m1, mb, mc)
          else if (ma%mp(2) < ndig .and. mb%mp(2) < ndig) then
              call imi2fm(ma, m1)
              call imi2fm(mb, m2)
              call fmadd(m1, m2, mc)
          endif
      else
          call imadd(ma, mb, mc)
      endif

      return
      end subroutine im_or_fm_add

      subroutine im_or_fm_eq(ma, mb)

!  Internal routine used by binary splitting algorithms.
!  ma is an integer, but if it gets bigger than the current precision can represent exactly,
!  it is faster to use fm routines in place of im routines.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      if (ma%mp(2) >= ndig) then
          call fmeq(ma, mb)
      else
          call imeq(ma, mb)
      endif

      return
      end subroutine im_or_fm_eq

      subroutine im_or_fm_mpy(ma, mb, mc)

!  Internal routine used by binary splitting algorithms.
!  ma and mb are integers, but if they get bigger than the current precision can represent exactly,
!  it is faster to use fm routines in place of im routines.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      type(multi), save :: m1, m2
      integer :: result_size

      if (ma%mp(2)+mb%mp(2) > ndig) then
          call fmalloc(mc, ndig+2)
      else
          if (ma%mp(2) >= mexpov .or. mb%mp(2) >= mexpov) then
              result_size = 5
          else
              result_size = ma%mp(2) + mb%mp(2) + 4
          endif
          result_size = max(5, result_size)
          call fmalloc(mc, result_size)
      endif

      if (ma%mp(2)+mb%mp(2) > ndig) then
          if (ma%mp(2) >= ndig .and. mb%mp(2) >= ndig) then
              call fmmpy(ma, mb, mc)
          else if (ma%mp(2) >= ndig .and. mb%mp(2) < ndig) then
              call imi2fm(mb, m2)
              call fmmpy(ma, m2, mc)
          else if (ma%mp(2) < ndig .and. mb%mp(2) >= ndig) then
              call imi2fm(ma, m1)
              call fmmpy(m1, mb, mc)
          else if (ma%mp(2) < ndig .and. mb%mp(2) < ndig) then
              call imi2fm(ma, m1)
              call imi2fm(mb, m2)
              call fmmpy(m1, m2, mc)
          endif
      else
          call immpy(ma, mb, mc)
      endif

      return
      end subroutine im_or_fm_mpy

      subroutine im_or_fm_sqr(ma, mb)

!  Internal routine used by binary splitting algorithms.
!  ma and mb are integers, but if they get bigger than the current precision can represent exactly,
!  it is faster to use fm routines in place of im routines.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      type(multi), save :: m1
      integer :: result_size

      if (2*ma%mp(2) > ndig) then
          call fmalloc(mb, ndig+2)
      else
          result_size = 2*ma%mp(2) + 4
          if (abs(result_size) >= mexpov) result_size = 5
          result_size = max(5, result_size)
          call fmalloc(mb, result_size)
      endif

      if (2*ma%mp(2) > ndig) then
          if (ma%mp(2) >= ndig) then
              call fmsqr(ma, mb)
          else
              call imi2fm(ma, m1)
              call fmsqr(m1, mb)
          endif
      else
          call imsqr(ma, mb)
      endif

      return
      end subroutine im_or_fm_sqr



!  The im routines perform integer multiple-precision arithmetic.

      subroutine imabs(ma, mb)

!  mb = abs(ma)

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      integer :: kwrnsv, ndsave, result_size

      result_size = max(5, int(ma%mp(2)+3))
      if (abs(result_size) >= mexpov) result_size = 5
      call fmalloc(mb, result_size)

      ncall = ncall + 1
      mb%mp(5) = 0
      ndsave = ndig
      if (ntrace /= 0) then
          namest(ncall) = 'IMABS'
          call imntr_inp1(ma)
      endif

      kflag = 0
      kwrnsv = kwarn
      kwarn = 0
      call imeq(ma, mb)
      mb%mp(1) = 1
      kwarn = kwrnsv

      if (ntrace /= 0) call imntr_out1(mb)
      ncall = ncall - 1
      ndig = ndsave

      return
      end subroutine imabs

      function imabs_greater_than(u, v)

!  Return true if abs(u) > abs(v) for IM numbers u, v.

      use fmvals
      implicit none

      logical :: imabs_greater_than
      type(multi) :: u, v
      intent (in) :: u, v

      integer :: j

      if (u%mp(2) > v%mp(2)) then
          imabs_greater_than = .true.
          return
      else if (u%mp(2) < v%mp(2)) then
          imabs_greater_than = .false.
          return
      endif

      imabs_greater_than = .false.
      do j = 1, int(u%mp(2))
         if (u%mp(j+2) > v%mp(j+2)) then
             imabs_greater_than = .true.
             return
         else if (u%mp(j+2) < v%mp(j+2)) then
             imabs_greater_than = .false.
             return
         endif
      enddo

      end function imabs_greater_than

      subroutine imadd(ma, mb, mc)

!  mc = ma + mb

!  This routine performs the trace printing.  imadd2 is used to do the arithmetic.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      ncall = ncall + 1
      if (ntrace /= 0) then
          namest(ncall) = 'IMADD'
          call imntr_inp2(ma, mb)

          call imadd2(ma, mb, mc)

          call imntr_out1(mc)
      else
          call imadd2(ma, mb, mc)
      endif
      ncall = ncall - 1

      return
      end subroutine imadd

      subroutine imadd2(ma, mb, mc)

!  mc = ma + mb

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: kresult, ndsave, result_size

      result_size = max(ma%mp(2), mb%mp(2)) + 4
      if (abs(result_size) >= mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mc, result_size)

      ndsave = ndig
      kflag = 0
      mc%mp(5) = 0

      call imadd_sc(ma, mb, mc, kresult)
      if (kresult > 0) return

      call imadd3(ma, mb, mc)

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      ndig = ndsave

      return
      end subroutine imadd2

      subroutine imadd3(ma, mb, mc)

!  Internal addition routine.  mc = ma + mb

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      real (kind(1.0d0)) :: mbs
      integer :: j, jcomp, jsign, n1

      if (mblogs /= mbase) call fmcons
      if (ma%mp(3) == 0) then
          call imeq(mb, mc)
          kflag = 1
          if (ksub == 1) then
              call fmnegate(mc)
              kflag = 0
          endif
          return
      endif
      if (mb%mp(3) == 0) then
          call imeq(ma, mc)
          kflag = 1
          return
      endif

      kflag = 0
      n1 = max(ma%mp(2), mb%mp(2)) + 1

!             jsign is the sign of the result of ma + mb.

      jsign = 1
      mbs = mb%mp(1)
      if (ksub == 1) mbs = -mbs

!             See which one is larger in absolute value.

      jcomp = 2
      if (ma%mp(2) > mb%mp(2)) then
          jcomp = 1
      else if (mb%mp(2) > ma%mp(2)) then
          jcomp = 3
      else
          do j = 2, n1
             if (ma%mp(j+1) > mb%mp(j+1)) then
                 jcomp = 1
                 exit
             endif
             if (mb%mp(j+1) > ma%mp(j+1)) then
                 jcomp = 3
                 exit
             endif
          enddo
      endif

      if (jcomp < 3) then
          if (ma%mp(1) < 0) jsign = -1
          if (ma%mp(1)*mbs > 0) then
              call imaddp(ma, mb)
          else
              call imaddn(ma, mb)
          endif
      else
          if (mbs < 0) jsign = -1
          if (ma%mp(1)*mbs > 0) then
              call imaddp(mb, ma)
          else
              call imaddn(mb, ma)
          endif
      endif

!             Transfer to mc and fix the sign of the result.

      ndig = int(mwa%mp(2))
      if (ndig < 3) ndig = 3
      call fmmove(mwa, mc)
      mc%mp(1) = 1
      if (jsign < 0 .and. mc%mp(3) /= 0) mc%mp(1) = -1

      if (kflag < 0) then
          if (ksub == 1) then
              namest(ncall) = 'IMSUB'
          else
              namest(ncall) = 'IMADD'
          endif
          call fmwarn
      endif

      return
      end subroutine imadd3

      subroutine imadd_sc(ma, mb, mc, kresult)

!  Special cases for mc = ma + mb

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      integer :: kresult
      intent (in) :: ma, mb
      intent (inout) :: mc, kresult

      real (kind(1.0d0)) :: mda, mdab, mdb

      kresult = 0
      if (ma%mp(2) <= 2) then
          if (mb%mp(2) <= 2 .and. ma%mp(2) >= 0 .and. mb%mp(2) >= 0) then
              if (ma%mp(2) <= 1) then
                  mda = ma%mp(1) * ma%mp(3)
              else
                  mda = ma%mp(1) * (ma%mp(3)*mbase + ma%mp(4))
              endif
              if (mb%mp(2) <= 1) then
                  mdb = mb%mp(1) * mb%mp(3)
              else
                  mdb = mb%mp(1) * (mb%mp(3)*mbase + mb%mp(4))
              endif
              mdab = mda + mdb
              if (abs(mdab) < mbase) then
                  mc%mp(2) = 1
                  if (mdab == 0) mc%mp(2) = 0
                  if (mdab < 0) then
                      mc%mp(3) = -mdab
                      mc%mp(1) = -1
                  else
                      mc%mp(3) = mdab
                      mc%mp(1) = 1
                  endif
                  mc%mp(4) = 0
                  if (mda == 0 .or. mdb == 0) kflag = 1
                  kresult = 1
                  return
              else if (abs(mdab) < mbase*mbase) then
                  mc%mp(2) = 2
                  if (mdab < 0) then
                      mc%mp(3) = aint (-mdab/mbase)
                      mc%mp(4) = abs(-mdab - mbase*mc%mp(3))
                      mc%mp(1) = -1
                  else
                      mc%mp(3) = aint (mdab/mbase)
                      mc%mp(4) = abs(mdab - mbase*mc%mp(3))
                      mc%mp(1) = 1
                  endif
                  if (mda == 0 .or. mdb == 0) kflag = 1
                  kresult = 1
                  return
              endif
          endif
      endif

      if (ma%mp(2) < 0 .or. mb%mp(2) < 0 .or.  &
          ma%mp(2) >= mexpov .or. mb%mp(2) >= mexpov) then
          if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) then
              call imi2m2(0, mc)
              mc%mp(2) = munkno
              mc%mp(3) = 1
              kflag = -4
              kresult = 1
              return
          endif
          if (ma%mp(2) == mexpov) then
              if (ma%mp(1) == mb%mp(1) .or. mb%mp(3) == 0) then
                  mc%mp(1) = ma%mp(1)
                  mc%mp(2) = ma%mp(2)
                  mc%mp(3) = ma%mp(3)
                  mc%mp(4) = ma%mp(4)
                  kflag = -5
                  kresult = 1
                  return
              else
                  kflag = -4
                  namest(ncall) = 'IMADD'
                  call fmwarn
                  call imi2m2(0, mc)
                  mc%mp(2) = munkno
                  mc%mp(3) = 1
                  kresult = 1
                  return
              endif
          endif
          if (mb%mp(2) == mexpov) then
              if (mb%mp(1) == ma%mp(1) .or. ma%mp(3) == 0) then
                  mc%mp(1) = mb%mp(1)
                  mc%mp(2) = mb%mp(2)
                  mc%mp(3) = mb%mp(3)
                  mc%mp(4) = mb%mp(4)
                  kflag = -5
                  kresult = 1
                  return
              else
                  kflag = -4
                  namest(ncall) = 'IMADD'
                  call fmwarn
                  call imi2m2(0, mc)
                  mc%mp(2) = munkno
                  mc%mp(3) = 1
                  kresult = 1
                  return
              endif
          endif
          kflag = -4
          namest(ncall) = 'IMADD'
          call fmwarn
          call imi2m2(0, mc)
          mc%mp(2) = munkno
          mc%mp(3) = 1
          kresult = 1
      endif

      return
      end subroutine imadd_sc

      subroutine imaddn(ma, mb)

!  Internal addition routine.  mwa = ma - mb
!  The arguments are such that ma >= mb >= 0.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma, mb

      real (kind(1.0d0)) :: mk
      integer :: j, k, kl, kp1, kp2, kpt, ksh, n1, result_size

      result_size = 2*ma%mp(2) + 30
      if (abs(result_size) >= mexpov) result_size = 32
      result_size = max(32, result_size)
      call fmalloc(mwa, result_size)

      if (ma%mp(2) == mexpov .or. mb%mp(2) == mexpov) then
          kflag = -4
          mwa%mp(2) = munkno
          mwa%mp(3) = 1
          mwa%mp(4) = 0
          return
      endif

      n1 = ma%mp(2) + 1
      mk = ma%mp(2) - mb%mp(2)
      k = int(mk)

!             Subtract mb from ma.

      kp1 = min(n1, k+1)
      do j = 1, kp1
         mwa%mp(j+1) = ma%mp(j+1)
      enddo
      kp2 = k + 2

!             (Inner Loop)

      do j = kp2+1, n1+1
         mwa%mp(j) = ma%mp(j) - mb%mp(j-k)
      enddo
      mwa%mp(1+n1+1) = 0

!             Normalize.  Fix the sign of any negative digit.

      if (k > 0) then
          do j = n1, kp2, -1
             if (mwa%mp(j+1) < 0) then
                 mwa%mp(j+1) = mwa%mp(j+1) + mbase
                 mwa%mp(j) = mwa%mp(j) - 1
             endif
          enddo
          kpt = kp2 - 1
          do while (mwa%mp(kpt+1) < 0 .and. kpt >= 3)
             mwa%mp(kpt+1) = mwa%mp(kpt+1) + mbase
             mwa%mp(kpt) = mwa%mp(kpt) - 1
             kpt = kpt - 1
          enddo
      else
          do j = n1, 3, -1
             if (mwa%mp(j+1) < 0) then
                 mwa%mp(j+1) = mwa%mp(j+1) + mbase
                 mwa%mp(j) = mwa%mp(j) - 1
             endif
          enddo
      endif

!             Shift left if there are any leading zeros in the mantissa.

      ksh = 0
      kl = 1
      do j = 2, n1
         if (mwa%mp(j+1) > 0) then
             ksh = j - 2
             kl = 0
             exit
         endif
      enddo
      if (kl == 1) then
          mwa%mp(2) = 0
          mwa%mp(4) = 0
          return
      endif

      if (ksh > 0) then
          kl = n1 - ksh
          do j = 2, kl
             mwa%mp(j+1) = mwa%mp(j+ksh+1)
          enddo
          do j = kl+1, n1
             mwa%mp(j+1) = 0
          enddo
          mwa%mp(2) = mwa%mp(2) - ksh
      endif

      return
      end subroutine imaddn

      subroutine imaddp(ma, mb)

!  Internal addition routine.  mwa = ma + mb
!  The arguments are such that ma >= mb >= 0.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma, mb

      real (kind(1.0d0)) :: mk
      integer :: j, k, kp2, kpt, n1, result_size

      result_size = 2*(ma%mp(2)+1) + 30
      if (abs(result_size) >= mexpov) result_size = 32
      result_size = max(32, result_size)
      call fmalloc(mwa, result_size)

      n1 = ma%mp(2) + 1
      mk = ma%mp(2) - mb%mp(2)
      k = int(mk)

!             Add ma and mb.

      mwa%mp(2) = ma%mp(2) + 1
      mwa%mp(3) = 0
      do j = 2, k+1
         mwa%mp(j+2) = ma%mp(j+1)
      enddo
      kp2 = k + 2

!             (Inner Loop)

      do j = kp2+1, n1+1
         mwa%mp(j+1) = ma%mp(j) + mb%mp(j-k)
      enddo
      mwa%mp(n1+3) = 0

!             Normalize.  Fix any digit not less than mbase.

      if (k > 0) then
          do j = n1+1, kp2, -1
             if (mwa%mp(j+1) >= mbase) then
                 mwa%mp(j+1) = mwa%mp(j+1) - mbase
                 mwa%mp(j) = mwa%mp(j) + 1
             endif
          enddo
          kpt = kp2 - 1
          do while (mwa%mp(kpt+1) >= mbase .and. kpt >= 3)
             mwa%mp(kpt+1) = mwa%mp(kpt+1) - mbase
             mwa%mp(kpt) = mwa%mp(kpt) + 1
             kpt = kpt - 1
          enddo
      else
          do j = n1+1, 3, -1
             if (mwa%mp(j+1) >= mbase) then
                 mwa%mp(j+1) = mwa%mp(j+1) - mbase
                 mwa%mp(j) = mwa%mp(j) + 1
             endif
          enddo
      endif

      return
      end subroutine imaddp

      subroutine imbig(ma)

!  ma = a very large im integer.

!  Before version 1.3 of fm, this routine returned the largest representable im integer.
!  Starting with version 1.3 the size of im integers is limited only by the space available
!  in the working array mwk in fmsave.f95.
!  But if this routine set ma as large as possible, it would leave no room for other
!  fm/im/zm numbers.  So a result of 10**(10**6) is returned here.

      use fmvals
      implicit none

      type(multi) :: ma
      intent (inout) :: ma

      integer :: l, result_size
      type(multi), save :: mxy(2)

      l = 1.05d+6*log(10.0d0)/log(dble(mbase)) + 3
      result_size = l + 3
      result_size = max(5, result_size)
      call fmalloc(ma, result_size)

      ncall = ncall + 1
      ma%mp(5) = 0
      namest(ncall) = 'IMBIG'

      if (mblogs /= mbase) call fmcons
      kflag = 0
      call imi2m(10, mxy(1))
      call imi2m(10**6, mxy(2))
      call impwr(mxy(1), mxy(2), ma)

      if (ntrace /= 0 .and. ncall <= lvltrc) then
          write (kw,                                                      &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', I10)"  &
                ) 'IMBIG', ncall, int(mbase)
          write (kw,*) '       1.0M+1000000'
      endif
      ncall = ncall - 1

      return
      end subroutine imbig

      subroutine imcomb(ma, mb, mc)

!  Binomial coefficients for integers.  ma, mb, mc, are all multiprecision integers.

!  mc = ma choose mb = ma! / ( mb! * (ma-mb)! )

!  This routine extends this definition to allow negative integer values for ma and/or mb.
!  The standard recurrence comb(n,k) = comb(n-1,k-1) + comb(n-1,k) can be used to define
!  comb(n,k) for all integers n,k starting from the initializing definitions
!  comb(0,k) = 0, for all k except 0,
!  comb(n,0) = 1, for all n.
!  Ex:  n = 1, k = 1 => comb(1,1) = comb(0,0)   +  comb(0,1)
!                    => comb(1,1) =         1   +          0,  so  comb(1,1)   =  1
!       n = 0, k = 0 => comb(0,0) = comb(-1,-1) + comb(-1,0)
!                    =>         1 = comb(-1,-1) +          1,  so  comb(-1,-1) =  0
!       n = 0, k = 1 => comb(0,1) = comb(-1,0)  + comb(-1,1)
!                    =>         0 =          1  + comb(-1,1),  so  comb(-1,1)  = -1

!  This definition agrees with the standard factorial definition when n and k are non-negative
!  integers.  The factorial definition is undefined when n or k is a negative integer, since
!  x! has singularities at negative integers.

!  For negative n or k, this extended definition simplifies to:
!  if k < 0,             comb(n,k) = 0
!  if k >= 0 and n < 0,  comb(n,k) = (-1)**k * comb(-n+k-1,k)

!  These extended definitions are useful in some combinatorial applications.
!  Reference:  Concrete Mathematics - Graham, Knuth, Patashnik, Addison-Wesley, 1989.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      type(multi), save :: mt, mxy(3)
      integer :: j, k, kmod2, kresult, l, n

      ncall = ncall + 1
      call imi2m(0, mc)
      mc%mp(5) = 0
      if (ntrace /= 0) then
          namest(ncall) = 'IMCOMB'
          call imntr_inp2(ma, mb)
      endif

      call imm2i(ma, n)
      if (kflag == 0) then
          call imm2i(mb, k)
          if (kflag == 0) then
              call imcombi(n, k, mt)
              call imeq(mt, mc)
              if (ntrace /= 0) call imntr_out1(mc)
              ncall = ncall - 1
              return
          endif
      endif
      if (mblogs /= mbase) call fmcons

      call imcomb_sc(ma, mb, mt, mxy, l, kresult)
      if (kresult == 0) then

!             Compute the binomial coefficient.

          call imeq(mxy(3), mt)
          call imi2m(1, mxy(1))
          do j = 2, l
             call imsub(mxy(3), mxy(1), mxy(2))
             call imeq(mxy(2), mxy(3))
             call immpy(mxy(3), mt, mxy(2))
             call imdivi(mxy(2), j, mt)
          enddo
      endif

      call immodi(mb, 2, kmod2)
      if (ma%mp(1) < 0 .and. kmod2 == 1) call fmnegate(mt)
      call imeq(mt, mc)
      if (ntrace /= 0) call imntr_out1(mc)
      ncall = ncall - 1

      return
      end subroutine imcomb

      subroutine imcomb2(ma, mb, mc)

!  Binomial coefficients for integers.  ma, mb, mc, are all multiprecision integers.

!  mc = ma choose mb = ma! / ( mb! * (ma-mb)! )

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      type(multi), save :: mxy(3)
      integer :: j, j1, j1fac, kmod2, kpt, kpt2, kresult, l, r
      type(multi), allocatable :: top(:)
      type(multi), save :: mt

      ncall = ncall + 1
      call imi2m(0, mc)
      mc%mp(5) = 0
      if (ntrace /= 0) then
          namest(ncall) = 'IMCOMB2'
          call imntr_inp2(ma, mb)
      endif

      if (mblogs /= mbase) call fmcons

      if (ma%mp(1) < 0) then
          call imsub(mb, ma, mxy(1))
          call imi2m(1, mxy(2))
          call imsub(mxy(1), mxy(2), mxy(3))
      else
          call imeq(ma, mxy(3))
      endif

      call imcomb2_sc(mb, mxy, mt, l, kresult)
      if (kresult == 0) then

!             Compute the binomial coefficient by making a list of the numerator terms
!             n, n-1, ..., n-l+1.  Then divide out each of the denominator terms 2, 3, ..., l.

          allocate(top(l), stat=j)
          if (j /= 0) then
              call fmdefine_error
          endif
          call imi2m(1, mxy(1))
          call imeq(mxy(3), top(1))
          do j = 2, l
             call imsub(top(j-1), mxy(1), top(j))
          enddo

          do j = l, 2, -1
             call immodi(mxy(3), j, r)
             kpt = r + 1
             do while (kpt <= l)
                call immodi(top(kpt), j, r)
                if (r == 0) then
                    call imdivi(top(kpt), j, mxy(2))
                    call imeq(mxy(2), top(kpt))
                    exit
                endif
                kpt = kpt + j
                if (kpt > l) then
                    j1 = j
                    do while (j1 > 1)
                       call imcomb2_factor(j1, j1fac)
                       call immodi(mxy(3), j1fac, r)
                       kpt2 = r + 1
                       do while (kpt2 <= l)
                          call immodi(top(kpt2), j1fac, r)
                          if (r == 0) then
                              call imdivi(top(kpt2), j1fac, mxy(2))
                              call imeq(mxy(2), top(kpt2))
                              exit
                          endif
                          kpt2 = kpt2 + j1fac
                       enddo
                    enddo
                endif
             enddo
          enddo

!             Form the product of the remaining top terms.

          call imeq(top(1), mt)
          do j = 2, l
             if (top(j)%mp(2) > 1 .or.  &
                (top(j)%mp(2) == 1 .and. top(j)%mp(3) > 1)) then
                 call immpy(top(j), mt, mxy(2))
                 call imeq(mxy(2), mt)
             endif
          enddo

          deallocate(top)
      endif

      call imi2m(2, mxy(1))
      call immod(mb, mxy(1), mxy(2))
      call imm2i(mxy(2), kmod2)
      if (ma%mp(1) < 0 .and. kmod2 == 1) call fmnegate(mt)
      call imeq(mt, mc)
      if (ntrace /= 0) call imntr_out1(mc)
      ncall = ncall - 1

      return
      end subroutine imcomb2

      subroutine imcomb2_factor(j1, j1fac)

!  Return j1fac as one prime factor of j1, and return j1 with the value j1 / j1fac

      implicit none

      integer :: j1, j1fac
      intent (inout) :: j1, j1fac

      integer :: j

      if (mod(j1, 2) == 0) then
          j1fac = 2
          j1 = j1 / j1fac
          return
      endif

      if (mod(j1, 3) == 0) then
          j1fac = 3
          j1 = j1 / j1fac
          return
      endif

      do j = 5, int(sqrt(dble(j1)))+1, 6
         j1fac = j
         if (mod(j1, j1fac) == 0) then
             j1 = j1 / j1fac
             return
         endif
         j1fac = j + 2
         if (mod(j1, j1fac) == 0) then
             j1 = j1 / j1fac
             return
         endif
      enddo

      j1fac = j1
      j1 = 1

      end subroutine imcomb2_factor

      subroutine imcomb2_sc(mb, mxy, mresult, l, kresult)

!  Special cases for  ma choose mb = ma! / ( mb! * (ma-mb)! )

      use fmvals
      implicit none

      type(multi) :: mb, mxy(3), mresult
      integer :: l, kresult
      intent (in) :: mb
      intent (inout) :: mxy, mresult, l, kresult

      kresult = 0
      call imsub(mxy(3), mb, mxy(1))
      call immin(mb, mxy(1), mxy(2))
      if (mxy(2)%mp(1) < 0) then
          call imi2m(0, mresult)
          kresult = 1
          return
      else if (mxy(2)%mp(3) == 0) then
          call imi2m(1, mresult)
          kresult = 1
          return
      endif
      call imm2i(mxy(2), l)

!             If l = min(k,n-k) is too big to represent as a machine integer, return unknown,
!             since the binomial result mc would have over half a billion digits.

      if (kflag /= 0) then
          call imunknown(mresult)
          kresult = 1
          return
      endif
      if (l == 1) then
          call imeq(mxy(3), mresult)
          kresult = 1
          return
      endif

      return
      end subroutine imcomb2_sc

      subroutine imcomb_sc(ma, mb, mresult, mxy, l, kresult)

!  Special cases for  ma choose mb = ma! / ( mb! * (ma-mb)! )

      use fmvals
      implicit none

      type(multi) :: ma, mb, mresult, mxy(3)
      integer :: l, kresult
      intent (in) :: ma, mb
      intent (inout) :: mresult, mxy, l, kresult

      kresult = 0
      if (ma%mp(1) < 0) then
          call imsub(mb, ma, mxy(1))
          call imi2m(1, mxy(2))
          call imsub(mxy(1), mxy(2), mxy(3))
      else
          call imeq(ma, mxy(3))
      endif
      call imsub(mxy(3), mb, mxy(1))
      call immin(mb, mxy(1), mxy(2))
      if (mxy(2)%mp(1) < 0) then
          call imi2m(0, mresult)
          kresult = 1
          return
      else if (mxy(2)%mp(3) == 0) then
          call imi2m(1, mresult)
          kresult = 1
          return
      endif
      call imm2i(mxy(2), l)

!             If l = min(k,n-k) is too big to represent as a machine integer, return unknown,
!             since the binomial result mc would have over half a billion digits.

      if (kflag /= 0) then
          call imunknown(mresult)
          kresult = 1
          return
      endif
      if (l == 1) then
          call imeq(mxy(3), mresult)
          kresult = 1
          return
      endif
      if (l > 10) then
          call imcomb2(mxy(3), mxy(2), mresult)
          kresult = 1
          return
      endif

      return
      end subroutine imcomb_sc

      subroutine imcombi(n, k, ma)

!  Binomial coefficients for integers.
!  n, k, are machine precision integers, ma is a multiprecision integer.

!  ma = n choose k = n! / ( k! * (n-k)! )

!  See the comments in imcomb about results for negative n, etc.

      use fmvals
      implicit none

      integer :: n, k
      type(multi) :: ma
      intent (in) :: n, k
      intent (inout) :: ma

      type(multi), save :: mxy(2)
      integer :: l, n1, nmethd
      integer :: j, kstart, kt, large, larged, ndiv, nextd, nextn, nmpy, ntd, ntn, result_size
      double precision :: cn, ck, cnk, e, logn, logk, lognk, pi

      if (mblogs /= mbase) call fmcons

      n1 = n
      if (n < 0) n1 = -n + k - 1
      cn = max(1, n1)
      ck = max(1, k)
      ck = min(ck, cn)
      cnk = max(1, n1-k)
      cnk = min(cnk, cn)
      e = exp(1.0d0)
      pi = acos(-1.0d0)
      logn = (log( 2*pi*cn )/2) + cn*log( cn/e ) + log( 1 + 1/(12.0d0*cn) )
      logk = (log( 2*pi*ck )/2) + ck*log( ck/e ) + log( 1 + 1/(12.0d0*ck) )
      lognk = (log( 2*pi*cnk )/2) + cnk*log( cnk/e ) + log( 1 + 1/(12.0d0*cnk) )
      l = min(k, n1-k)
      if (logn < 1.0d+10) then
          result_size = (logn - logk - lognk) / dlogmb + 7
      else
          result_size = (l*log(cn) - min(logk, lognk)) / dlogmb + 7
      endif
      if (abs(result_size) >= mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(ma, result_size)

      if (l < 0) then
          call imi2m(0, ma)
          return
      else if (l == 0) then
          call imi2m(1, ma)
          if (n < 0 .and. mod(k, 2) == 1) call fmnegate(ma)
          return
      else if (l == 1) then
          call imi2m(n1, ma)
          if (n < 0 .and. mod(k, 2) == 1) call fmnegate(ma)
          return
      endif
      ma%mp(5) = 0

!             Determine which method to use.

      nmethd = 2
      if (n1 >= 2100) then
          if (n1 >= 10**7) then
              if (l >= 8) nmethd = 1
          else
              if (l > exp(10.7d0 - 0.53d0*log(cn))) nmethd = 1
          endif
      endif

      if (nmethd == 1) then
          call imfact_p(n1-l+1, n1, mxy(1))
          call imfact_p(2, l, mxy(2))
          call imdiv(mxy(1), mxy(2), ma)
          if (n < 0 .and. mod(k, 2) == 1) call fmnegate(ma)
          return
      endif

!             Find the largest value for n1 choose j using integers.

      ntn = n1
      ntd = 1
      large = int(intmax/n1)
      do j = 2, l
         if (ntn <= large) then
             ntn = (ntn*((n1+1)-j))/j
         else
             call imi2m(ntn, ma)
             ntn = (n1+1) - j
             ntd = j
             exit
         endif
      enddo

      if (ntd == 1) then
          call imi2m(ntn, ma)
          if (n < 0 .and. mod(k, 2) == 1) call fmnegate(ma)
          return
      endif

      nextn = ntn
      nextd = ntd
      kstart = ntd + 1

!             Compute the rest of n1 choose k.

      larged = min(large, int(mxbase))
      do kt = kstart, l
         nextn = nextn - 1
         nextd = nextd + 1
         if (ntn >= large .or. ntd >= larged) then
             call immpyi(ma, ntn, mxy(1))
             call imdivi(mxy(1), ntd, ma)
             ntn = nextn
             ntd = nextd
             cycle
         endif
         nmpy = ntn*nextn
         ndiv = ntd*nextd
         if (nmpy <= large .and. ndiv <= larged) then
             ntn = nmpy
             ntd = ndiv
         else
             call fmgcdi(nmpy, ndiv)
             if (nmpy <= large .and. ndiv <= larged) then
                 ntn = nmpy
                 ntd = ndiv
             else
                 call immpyi(ma, ntn, mxy(1))
                 call imdivi(mxy(1), ntd, ma)
                 ntn = nextn
                 ntd = nextd
             endif
         endif
      enddo
      call fmgcdi(ntn, ntd)
      call immpyi(ma, ntn, mxy(1))
      call imdivi(mxy(1), ntd, ma)

      if (n < 0 .and. mod(k, 2) == 1) call fmnegate(ma)

      return
      end subroutine imcombi

      function imcomp(ma, lrel, mb)

!  Logical comparison of FM numbers ma and mb.

!  lrel is a character description of the comparison to be done:
!  lrel = 'eq' returns imcomp = .true. if ma == mb
!       = 'ne', 'ge', 'gt', 'le', 'lt' also work like a logical if.
!       = '==', '/=', '<', '<=', '>', '>=' may be used.

      use fmvals
      implicit none

      logical :: imcomp
      character(*) :: lrel
      type(multi) :: ma, mb
      intent (in) :: ma, lrel, mb

      character(2) :: jrel
      integer :: jcomp, kresult, ndsave, ntrsav

      ncall = ncall + 1
      namest(ncall) = 'IMCOMP'

      if (ncall <= lvltrc .and. abs(ntrace) >= 2) then
          write (kw, "(' Input to IMCOMP')")
          ndsave = ndig
          if (ntrace > 0) then
              call imprnt(ma)
              if (index('=/<>', lrel(1:1)) > 0) then
                  write (kw, "(8X, A)") lrel
              else
                  write (kw, "(7X, '.', A, '.')") lrel
              endif
              call imprnt(mb)
          else
              ndig = max(3, int(ma%mp(2)))
              ntrsav = ntrace
              call imntrj(ma, ndig)
              if (index('=/<>', lrel(1:1)) > 0) then
                  write (kw, "(8X, A)") lrel
              else
                  write (kw, "(7X, '.', A, '.')") lrel
              endif
              ndig = max(3, int(mb%mp(2)))
              call imntrj(mb, ndig)
              ntrace = ntrsav
          endif
          ndig = ndsave
      endif

      call imcomp_sc(ma, lrel, mb, jrel, kresult)
      if (kresult == 0) then
          call imcomp_m1(ma, mb, jcomp)
      else
          imcomp = .false.
          call imcomp2(0)
          return
      endif

!             jcomp is 1 if ma > mb
!                      2 if ma == mb
!                      3 if ma < mb

!             Match the jcomp value to the requested comparison.

      if (jcomp == 1 .and. ma%mp(1) < 0) then
          jcomp = 3
      else if (jcomp == 3 .and. mb%mp(1) < 0) then
          jcomp = 1
      endif

      imcomp = .false.
      if (jcomp == 1 .and. (jrel == 'GT' .or. jrel == 'GE' .or. jrel == 'NE')) imcomp = .true.
      if (jcomp == 2 .and. (jrel == 'EQ' .or. jrel == 'GE' .or. jrel == 'LE')) imcomp = .true.
      if (jcomp == 3 .and. (jrel == 'NE' .or. jrel == 'LT' .or. jrel == 'LE')) imcomp = .true.

      jcomp = 0
      if (imcomp) jcomp = 1
      call imcomp2(jcomp)

      return
      end function imcomp

      subroutine imcomp2(jcomp)

!  Trace printing on exit from imcomp.

      use fmvals
      implicit none

      integer :: jcomp
      intent (in) :: jcomp

      if (ntrace /= 0) then
          if (ncall <= lvltrc .and. abs(ntrace) >= 1) then
              if (kflag == 0) then
                  write (kw,                                              &
                         "(' IMCOMP', 15X, 'Call level =', I2, 5X, "  //  &
                         "'MBASE =', I10)"                                &
                        ) ncall, int(mbase)
              else
                  write (kw,                                             &
                         "(' IMCOMP', 6X, 'Call level =', I2, 4X, "  //  &
                         "'MBASE =', I10, 4X, 'KFLAG =', I3)"            &
                        ) ncall, int(mbase), kflag
              endif
              if (jcomp == 1) then
                  write (kw, "(7X, '.TRUE.')")
              else
                  write (kw, "(7X, '.FALSE.')")
              endif
          endif
      endif
      ncall = ncall - 1

      return
      end subroutine imcomp2

      subroutine imcomp_m1(ma, mb, jcomp)

!  jcomp will be 1 if ma > mb
!                2 if ma == mb
!                3 if ma < mb

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: jcomp
      intent (in) :: ma, mb
      intent (inout) :: jcomp

      integer :: j, nlast

!             Check for zero.

      kflag = 0
      if (ma%mp(3) == 0) then
          jcomp = 2
          if (mb%mp(3) == 0) return
          if (mb%mp(1) < 0) jcomp = 1
          if (mb%mp(1) > 0) jcomp = 3
          return
      endif
      if (mb%mp(3) == 0) then
          jcomp = 1
          if (ma%mp(1) < 0) jcomp = 3
          return
      endif

!             Check for opposite signs.

      if (ma%mp(1) > 0 .and. mb%mp(1) < 0) then
          jcomp = 1
          return
      endif
      if (mb%mp(1) > 0 .and. ma%mp(1) < 0) then
          jcomp = 3
          return
      endif

!             See which one is larger in absolute value.

      if (ma%mp(2) > mb%mp(2)) then
          jcomp = 1
          return
      endif
      if (mb%mp(2) > ma%mp(2)) then
          jcomp = 3
          return
      endif
      nlast = int(ma%mp(2)) + 1

      do j = 2, nlast
         if (abs(ma%mp(j+1)) > abs(mb%mp(j+1))) then
             jcomp = 1
             return
         endif
         if (abs(mb%mp(j+1)) > abs(ma%mp(j+1))) then
             jcomp = 3
             return
         endif
      enddo

      jcomp = 2

      return
      end subroutine imcomp_m1

      subroutine imcomp_sc(ma, lrel, mb, jrel, kresult)

!  Special cases for logical comparison of FM numbers ma and mb.

      use fmvals
      implicit none

      character(*) :: lrel
      type(multi) :: ma, mb
      character(2) :: jrel
      integer :: kresult
      intent (in) :: ma, lrel, mb
      intent (inout) :: jrel, kresult

      kresult = 0

      jrel = lrel
      if (lrel /= 'EQ' .and. lrel /= 'NE' .and. lrel /= 'LT' .and.  &
          lrel /= 'GT' .and. lrel /= 'LE' .and. lrel /= 'GE') then
          if (lrel == 'eq' .or. lrel == '==') then
              jrel = 'EQ'
          else if (lrel == 'ne' .or. lrel == '/=') then
              jrel = 'NE'
          else if (lrel == 'lt' .or. lrel == '<') then
              jrel = 'LT'
          else if (lrel == 'gt' .or. lrel == '>') then
              jrel = 'GT'
          else if (lrel == 'le' .or. lrel == '<=') then
              jrel = 'LE'
          else if (lrel == 'ge' .or. lrel == '>=') then
              jrel = 'GE'
          else
              kflag = -4
              if (ncall /= 1 .or. kwarn <= 0) then
                  kresult = 1
                  return
              endif
              write (kw,                                                         &
                     "(/' Error of type KFLAG = -4 in FM package in', "      //  &
                     "' routine IMCOMP'//1X, A, ' is not one of the six', "  //  &
                     "' recognized comparisons.'//' .FALSE. has been', "     //  &
                     "' returned.'/)"                                            &
                    ) lrel
              if (kwarn >= 2) then
                  stop
              endif
              kresult = 1
              return
          endif
      endif

      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) then
          kflag = -4
          kresult = 1
          return
      endif

      if (abs(ma%mp(2)) == mexpov .and. ma%mp(2) == mb%mp(2) .and.  &
          ma%mp(3) == mb%mp(3) .and. ma%mp(1) == mb%mp(1)) then
          kflag = -4
          if (ncall /= 1 .or. kwarn <= 0) then
              kresult = 1
              return
          endif
          write (kw,                                                      &
                 "(/' Error of type KFLAG = -4 in FM package in ', "  //  &
                 "'routine IMCOMP'//' Two numbers in the same ', "    //  &
                 "'overflow category cannot be compared.'//"          //  &
                 "' .FALSE. has been returned.'/)"                        &
                )
          if (kwarn >= 2) then
              stop
          endif
          kresult = 1
          return
      endif

      return
      end subroutine imcomp_sc

      function imcompare(ma, lrel, mb)

      use fmvals
      implicit none

      logical :: imcompare
      character(*) :: lrel
      type(multi) :: ma, mb
      intent (in) :: ma, lrel, mb
      logical, external :: imcomp

      imcompare = imcomp(ma, lrel, mb)

      return
      end function imcompare

      subroutine imdim(ma, mb, mc)

!  mc = dim(ma, mb)

!  Positive difference.  mc = ma - mb  if ma >= mb,
!                           = 0        otherwise.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: kovfl, result_size
      logical, external :: imcomp

      result_size = max(ma%mp(2), mb%mp(2)) + 3
      if (abs(result_size) >= mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mc, result_size)

      kflag = 0
      ncall = ncall + 1
      namest(ncall) = 'IMDIM'
      mc%mp(5) = 0
      if (ntrace /= 0) then
          call imntr_inp2(ma, mb)
      endif

      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) then
          call imunknown(mc)
          kflag = -4
          call imdim2(mc)
          return
      endif
      if (ma%mp(2) < 0 .or. mb%mp(2) < 0) then
          kflag = -4
          call fmwarn
          call imunknown(mc)
          call imdim2(mc)
          return
      endif
      kovfl = 0
      if (ma%mp(2) == mexpov .or. mb%mp(2) == mexpov) then
          kovfl = 1
          if (ma%mp(2) == mexpov .and. mb%mp(2) == mexpov .and.  &
              ma%mp(3) == mb%mp(3) .and. ma%mp(1) == mb%mp(1)) then
              kflag = -4
              call fmwarn
              call imunknown(mc)
              call imdim2(mc)
              return
          endif
      endif

      if (imcomp(ma, '>=', mb)) then
          call imsub(ma, mb, mc)
          if (kflag == 1) kflag = 0
      else
          mc%mp(2) = 0
          mc%mp(3) = 0
          mc%mp(4) = 0
          mc%mp(1) = 1
      endif

      if (mc%mp(2) >= mexpov) then
          if (mc%mp(2) == munkno) then
              kflag = -4
              call fmwarn
          else if (ncall == 1 .or. mc%mp(2) >= mexpov) then
              if (mc%mp(1) > 0) then
                  call imst2m('OVERFLOW', mc)
              else
                  call imst2m('-OVERFLOW', mc)
              endif
              kflag = -5
              if (kovfl /= 1) then
                  call fmwarn
              endif
          endif
      endif

      call imdim2(mc)

      return
      end subroutine imdim

      subroutine imdim2(mc)

!  Check for output tracing in imdim.

      use fmvals
      implicit none

      type(multi) :: mc
      intent (inout) :: mc

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      if (ntrace /= 0) call imntr_out1(mc)
      ncall = ncall - 1

      return
      end subroutine imdim2

      subroutine imdiv(ma, mb, mc)

!  mc = int(ma/mb)

!  Use imdivr if both int(ma/mb) and mod(ma,mb) are needed.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: kl, ndsave, result_size
      type(multi), save :: mxy

      if (ma%mp(2) >= mexpov .or. mb%mp(2) >= mexpov) then
          result_size = 5
      else
          result_size = ma%mp(2) - mb%mp(2) + 6
      endif
      result_size = max(5, result_size)
      call fmalloc(mc, result_size)

      ncall = ncall + 1
      mc%mp(5) = 0
      kflag = 0
      ndsave = ndig
      if (ntrace /= 0) then
          namest(ncall) = 'IMDIV'
          call imntr_inp2(ma, mb)
      endif

      kl = 1
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) then
          call imunknown(mc)
          kflag = -4
          kl = 0
      endif

      if (kl == 1) then
          krem = 0
          call imdivr(ma, mb, mc, mxy)
          krem = 1

          if (mc%mp(2) == munkno) then
              kflag = -4
              namest(ncall) = 'IMDIV'
              call fmwarn
          endif
      endif

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      if (ntrace /= 0) call imntr_out1(mc)
      ncall = ncall - 1
      ndig = ndsave

      return
      end subroutine imdiv

      subroutine imdivi(ma, idiv, mb)

!  mb = int(ma/idiv)

!  Use imdvir if both int(ma/idiv) and mod(ma,idiv) are needed.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma, idiv
      intent (inout) :: mb

      integer :: idiv, irem, kl, ndsave, result_size

      result_size = max(5, int(ma%mp(2)+3))
      if (abs(result_size) >= mexpov) result_size = 5
      call fmalloc(mb, result_size)

      ncall = ncall + 1
      mb%mp(5) = 0
      kflag = 0
      ndsave = ndig
      if (ntrace /= 0) then
          namest(ncall) = 'IMDIVI'
          call imntr_inp1i(ma, idiv)
      endif

      kl = 1
      if (ma%mp(2) == munkno) then
          call imunknown(mb)
          kflag = -4
          kl = 0
      endif

      if (kl == 1) then
          call imdvir(ma, idiv, mb, irem)

          if (mb%mp(2) == munkno) then
              kflag = -4
              namest(ncall) = 'IMDIVI'
              call fmwarn
          endif
      endif

      if (mb%mp(2) <= 1) mb%mp(4) = 0
      if (ntrace /= 0) call imntr_out1(mb)
      ncall = ncall - 1
      ndig = ndsave

      return
      end subroutine imdivi

      subroutine imdivr(ma, mb, mc, md)

!  mc = int(ma / mb),    md = remainder from the division.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md
      intent (in) :: ma, mb
      intent (inout) :: mc, md

      double precision :: xb, xbr, xbase, xmwa
      real (kind(1.0d0)) :: maxmwa, mb1, mbp1, mcarry, mkt, mlmax, mqd
      integer :: j, jb, jl, k, ka, kb, kl, klt, kltflg, kptmwa, kresult, lcrrct, na1, nb1, nd,  &
                 ndsave, nguard, nl, nmbwds, nmethd, ntrsav, result_size
      type(multi), save :: mxy(4)
      logical, external :: imcomp

      if (ma%mp(2) >= mexpov .or. mb%mp(2) >= mexpov) then
          result_size = 5
      else
          result_size = ma%mp(2) - mb%mp(2) + 6
      endif
      result_size = max(5, result_size)
      call fmalloc(mc, result_size)
      result_size = max(5, int(mb%mp(2)+3)) + 2
      if (abs(result_size) >= mexpov) result_size = ma%mp(2) + 5
      if (abs(result_size) >= mexpov) result_size = 5
      call fmalloc(md, result_size)
      result_size = 2*ma%mp(2) + 30
      if (abs(result_size) >= mexpov) result_size = 32
      result_size = max(32, result_size)
      call fmalloc(mwa, result_size)

      ncall = ncall + 1
      mc%mp(5) = 0
      md%mp(5) = 0
      ndsave = ndig
      if (ntrace /= 0) then
          namest(ncall) = 'IMDIVR'
          call imntr_inp2(ma, mb)
      endif
      kflag = 0
      ntrsav = ntrace
      ntrace = 0

      call imdivr_sc(ma, mb, mc, md, kresult)
      if (kresult == 1) then
          call imdivr3(mc, md, ndsave, ntrsav)
          return
      endif

      kltflg = 0
      kl = int(mb%mp(2))
      if (abs(kl) >= mexpov) kl = 2
      result_size = abs(mb%mp(2)) + 4
      if (abs(result_size) >= mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mxy(1), result_size)

      do j = 0, kl+1
         mxy(1)%mp(j+1) = mb%mp(j+1)
      enddo
      mxy(1)%mp(1) = 1
      if (kl == 1) mxy(1)%mp(4) = 0
      if (ma%mp(2) == mxy(1)%mp(2) .and.  &
          abs(ma%mp(3)) <= mxy(1)%mp(3)) then
          klt = 1
          do j = 2, kl+1
             if (ma%mp(j+1) /= mxy(1)%mp(j+1)) then
                 klt = 0
                 exit
             endif
          enddo
          if (klt == 1) kltflg = 2
          if (kltflg == 0) then
              do j = 2, kl+1
                 if (ma%mp(j+1) < mxy(1)%mp(j+1)) then
                     kltflg = 1
                     exit
                 else if (ma%mp(j+1) > mxy(1)%mp(j+1)) then
                     exit
                 endif
              enddo
          endif
      endif
      if (ma%mp(2) < mb%mp(2) .or. kltflg >= 1) then
          if (kltflg /= 2) then
              call imeq(ma, md)
              md%mp(1) = abs(md%mp(1))
              call imi2m(0, mc)
          else
              call imi2m(1, mc)
              call imi2m(0, md)
          endif
          call imdivr2(ma, mb, mc, md)
          call imdivr3(mc, md, ndsave, ntrsav)
          return
      endif

      ndig = int(ma%mp(2)) + 2
      if (ndig < 3) ndig = 3
      if (abs(ma%mp(2)) >= mexpov) ndig = 3


!             Check for using an fft-based method if precision is very high.

      nd = 1000
      if (int(ma%mp(2))-int(mb%mp(2)) >= nd) then
          nmethd = 2
      else
          nmethd = 1
      endif
      if (nmethd == 2) then
          call imi2fm(ma, mxy(1))
          mxy(1)%mp(1) = 1
          call imi2fm(mb, mxy(2))
          mxy(2)%mp(1) = 1
          call fmdiv(mxy(1), mxy(2), mxy(3))
          call imfm2i(mxy(3), mc)
          if (krem /= 1) then
              call imi2m(0, md)
          else
              call imabs(ma, mxy(1))
              call imabs(mb, mxy(2))
              call immpy(mc, mxy(2), mxy(3))
              call imsub(mxy(1), mxy(3), mxy(4))
              call imeq(mxy(4), md)
              if (md%mp(1) == -1) then
                  call imi2m(1, mxy(3))
                  call imsub(mc, mxy(3), mxy(4))
                  call imeq(mxy(4), mc)
                  call imadd(md, mxy(2), mxy(4))
                  call imeq(mxy(4), md)
              else if (imcomp(md, '>=', mxy(2))) then
                  call imi2m(1, mxy(3))
                  call imadd(mc, mxy(3), mxy(4))
                  call imeq(mxy(4), mc)
                  call imsub(md, mxy(2), mxy(4))
                  call imeq(mxy(4), md)
              endif
          endif
          call imdivr2(ma, mb, mc, md)
          call imdivr3(mc, md, ndsave, ntrsav)
          return
      endif

!             nguard is the number of guard digits used.

      nguard = 1
      na1 = int(ma%mp(2)) + 1
      nb1 = int(mb%mp(2)) + 1

!             Copy ma into the working array.

      do j = 3, na1
         mwa%mp(j+2) = ma%mp(j+1)
      enddo
      mwa%mp(2) = ma%mp(2) - mb%mp(2) + 1
      mwa%mp(3) = 0
      nl = na1 + nguard + 3
      do j = na1+2, nl
         mwa%mp(j+1) = 0
      enddo

      mb1 = mb%mp(2)
      mwa%mp(4) = ma%mp(3)

!             nmbwds is the number of words of mb used to compute the estimated quotient digit mqd.

      nmbwds = 4
      if (mbase < 100) nmbwds = 7

!             xb is an approximation of mb used in estimating the quotient digits.

      xbase = dble(mbase)
      xb = 0
      jl = nmbwds
      if (jl <= nb1) then
          do j = 2, jl
             xb = xb*xbase + dble(mb%mp(j+1))
          enddo
      else
          do j = 2, jl
             if (j <= nb1) then
                 xb = xb*xbase + dble(mb%mp(j+1))
             else
                 xb = xb*xbase
             endif
          enddo
      endif
      if (jl+1 <= nb1) then
          xb = xb + dble(mb%mp(jl+2))/xbase
      endif
      xbr = 1.0d0/xb

!             mlmax determines when to normalize all of mwa.

      mbp1 = mbase + 1
      mlmax = maxint/mbp1
      mkt = intmax - mbase
      mlmax = min(mlmax, mkt)

!             maxmwa is an upper bound on the size of values in mwa divided by mbase-1.
!             It is used to determine whether normalization can be postponed.

      maxmwa = 0

!             kptmwa points to the next digit in the quotient.

      kptmwa = 2
      ka = kptmwa + 1
      kb = ka + int(mb1) - 1
      jb = ka - 2

!             This is the start of the division loop.

!             xmwa is an approximation of the active part of mwa used in estimating quotient digits.

      klt = 1
      do while (klt == 1)
         kl = kptmwa + nmbwds - 1
         if (kl <= nl) then
             xmwa = ((dble(mwa%mp(kptmwa+1))*xbase + dble(mwa%mp(kptmwa+2)))*xbase  &
                    + dble(mwa%mp(kptmwa+3)))*xbase + dble(mwa%mp(kptmwa+4))
             do j = kptmwa+4, kl
                xmwa = xmwa*xbase + dble(mwa%mp(j+1))
             enddo
         else
             xmwa = dble(mwa%mp(kptmwa+1))
             do j = kptmwa+1, kl
                if (j <= nl) then
                    xmwa = xmwa*xbase + dble(mwa%mp(j+1))
                else
                    xmwa = xmwa*xbase
                endif
             enddo
         endif

!             mqd is the estimated quotient digit.

         mqd = aint(xmwa*xbr)
         if (mqd < 0) mqd = mqd - 1

         if (mqd > 0) then
             maxmwa = maxmwa + mqd
         else
             maxmwa = maxmwa - mqd
         endif

!             See if mwa must be normalized.

         ka = kptmwa + 1
         kb = ka + int(mb1) - 1
         if (maxmwa >= mlmax) then
             do j = kb, ka, -1
                if (mwa%mp(j+1) < 0) then
                    mcarry = int((-mwa%mp(j+1)-1)/mbase) + 1
                    mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
                    mwa%mp(j) = mwa%mp(j) - mcarry
                else if (mwa%mp(j+1) >= mbase) then
                    mcarry = -int(mwa%mp(j+1)/mbase)
                    mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
                    mwa%mp(j) = mwa%mp(j) - mcarry
                endif
             enddo
             xmwa = 0
             if (kl <= nl) then
                 do j = kptmwa, kl
                    xmwa = xmwa*xbase + dble(mwa%mp(j+1))
                 enddo
             else
                 do j = kptmwa, kl
                    if (j <= nl) then
                        xmwa = xmwa*xbase + dble(mwa%mp(j+1))
                    else
                        xmwa = xmwa*xbase
                    endif
                 enddo
             endif
             mqd = aint(xmwa*xbr)
             if (mqd < 0) mqd = mqd - 1
             if (mqd > 0) then
                 maxmwa = mqd
             else
                 maxmwa = -mqd
             endif
         endif

!             Subtract mqd*mb from mwa.

         jb = ka - 2
         if (mqd /= 0) then

!             Major (Inner Loop)

             do j = ka+1, kb+1
                mwa%mp(j) = mwa%mp(j) - mqd*mb%mp(j-jb)
             enddo
         endif

         mwa%mp(ka+1) = mwa%mp(ka+1) + mwa%mp(ka)*mbase
         mwa%mp(kptmwa+1) = mqd

         kptmwa = kptmwa + 1
         if (kptmwa-2 >= mwa%mp(2)) klt = 0
      enddo

!             Final normalization.

      kptmwa = kptmwa - 1
      do j = kptmwa, 3, -1
         if (mwa%mp(j+1) < 0) then
             mcarry = int((-mwa%mp(j+1)-1)/mbase) + 1
             mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
             mwa%mp(j) = mwa%mp(j) - mcarry
         else if (mwa%mp(j+1) >= mbase) then
             mcarry = -int(mwa%mp(j+1)/mbase)
             mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
             mwa%mp(j) = mwa%mp(j) - mcarry
         endif
      enddo

      lcrrct = 0
      klt = 1
      do while (klt == 1)
         do j = kptmwa+int(mb1), kptmwa+2, -1
            if (mwa%mp(j+1) < 0) then
                mcarry = int((-mwa%mp(j+1)-1)/mbase) + 1
                mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
                mwa%mp(j) = mwa%mp(j) - mcarry
            else if (mwa%mp(j+1) >= mbase) then
                mcarry = -int(mwa%mp(j+1)/mbase)
                mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
                mwa%mp(j) = mwa%mp(j) - mcarry
            endif
         enddo

!             Due to rounding, the remainder may not be between 0 and abs(mb) here.
!             Correct if necessary.

         klt = 0
         if (mwa%mp(ka+1) < 0) then
             lcrrct = lcrrct - 1
             do j = ka, kb
                mwa%mp(j+1) = mwa%mp(j+1) + mb%mp(j-jb+1)
             enddo
             klt = 1
             cycle
         else if (mwa%mp(ka+1) >= mbase) then
             lcrrct = lcrrct + 1
             do j = ka, kb
                mwa%mp(j+1) = mwa%mp(j+1) - mb%mp(j-jb+1)
             enddo
             klt = 1
             cycle
         endif
      enddo
      if (mwa%mp(3) /= 0 .or. kptmwa == 2) then
          do j = 1, int(mwa%mp(2))+1
             mc%mp(j+1) = mwa%mp(j+1)
          enddo
      else
          do j = 3, int(mwa%mp(2))+1
             mc%mp(j) = mwa%mp(j+1)
          enddo
          if (mc%mp(3) /= 0) then
              mc%mp(2) = mwa%mp(2) - 1
          else
              mc%mp(2) = 0
          endif
      endif
      if (mc%mp(2) <= 1) mc%mp(4) = 0
      mc%mp(1) = 1

      if (mwa%mp(kptmwa+2) /= 0) then
          do j = 1, int(mb1)
             md%mp(j+2) = mwa%mp(j+kptmwa+1)
          enddo
          md%mp(2) = mb1
      else
          klt = 1
          do j = 1, int(mb1)
             if (mwa%mp(j+kptmwa+1) /= 0) then
                 do k = j, int(mb1)
                    md%mp(k-j+3) = mwa%mp(k+kptmwa+1)
                 enddo
                 md%mp(2) = mb1 + 1 - j
                 klt = 0
                 exit
             endif
          enddo
          if (klt == 1) then
              md%mp(2) = 0
              md%mp(3) = 0
          endif
      endif
      if (md%mp(2) <= 1) md%mp(4) = 0
      md%mp(1) = 1

!             If the remainder had to be corrected, make the corresponding adjustment in
!             the quotient.

      if (md%mp(2) > mxy(1)%mp(2) .or.    &
         (md%mp(2) == mxy(1)%mp(2) .and.  &
          abs(md%mp(3)) >= mxy(1)%mp(3))) then
          if (imcomp(md, '>=', mxy(1))) then
              call imsub(md, mxy(1), mxy(3))
              call imeq(mxy(3), md)
              lcrrct = lcrrct + 1
          endif
      endif
      if (lcrrct /= 0) then
          call imi2m(lcrrct, mxy(2))
          call imadd(mxy(2), mc, mxy(3))
          call imeq(mxy(3), mc)
      endif

      call imdivr2(ma, mb, mc, md)
      call imdivr3(mc, md, ndsave, ntrsav)

      return
      end subroutine imdivr

      subroutine imdivr2(ma, mb, mc, md)

!  Fix signs for the results from imdivr.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md
      intent (in) :: ma, mb
      intent (inout) :: mc, md

      mc%mp(1) = 1
      md%mp(1) = 1
      if (ma%mp(1) < 0 .and. mb%mp(1) > 0) then
          if (mc%mp(2) /= munkno .and. mc%mp(3) /= 0) mc%mp(1) = -1
          if (md%mp(2) /= munkno .and. md%mp(3) /= 0) md%mp(1) = -1
      else if (ma%mp(1) > 0 .and. mb%mp(1) < 0) then
          if (mc%mp(2) /= munkno .and. mc%mp(3) /= 0) mc%mp(1) = -1
      else if (ma%mp(1) < 0 .and. mb%mp(1) < 0) then
          if (md%mp(2) /= munkno .and. md%mp(3) /= 0) md%mp(1) = -1
      endif

      return
      end subroutine imdivr2

      subroutine imdivr3(mc, md, ndsave, ntrsav)

!  Check for trace output from imdiv.

      use fmvals
      implicit none

      type(multi) :: mc, md
      integer :: ndsave, ntrsav
      intent (in) :: ndsave
      intent (inout) :: mc, md, ntrsav


      if (mc%mp(2) <= 1) mc%mp(4) = 0
      if (md%mp(2) <= 1) md%mp(4) = 0
      ntrace = ntrsav
      if (ntrace /= 0) then
          call imntr_out1(mc)
          if (abs(ntrace) >= 1 .and. ncall <= lvltrc) then
              if (ntrace < 0) then
                  ndig = max(3, int(md%mp(2)))
                  ntrsav = ntrace
                  call imntrj(md, ndig)
                  ntrace = ntrsav
              else
                  call imprnt(md)
              endif
          endif
      endif
      ncall = ncall - 1
      ndig = ndsave

      return
      end subroutine imdivr3

      subroutine imdivr_sc(ma, mb, mc, md, kresult)

!  mc = int(ma / mb),    md = remainder from the division.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md
      integer :: kresult
      intent (in) :: ma, mb
      intent (inout) :: mc, md, kresult

      real (kind(1.0d0)) :: mda, mdab, mdb, mdr

      kresult = 0
      if (mblogs /= mbase) call fmcons

!             Check for special cases.

      if (mb%mp(2) == 1 .and. ma%mp(2) /= munkno) then
          if (mb%mp(1)*mb%mp(3) == 1) then
              call imeq(ma, mc)
              md%mp(2) = 0
              md%mp(3) = 0
              md%mp(4) = 0
              md%mp(1) = 1
              kresult = 1
              return
          else if (mb%mp(1)*mb%mp(3) == -1) then
              call imeq(ma, mc)
              call fmnegate(mc)
              md%mp(2) = 0
              md%mp(3) = 0
              md%mp(4) = 0
              md%mp(1) = 1
              kresult = 1
              return
          endif
      endif
      if (ma%mp(2) < mb%mp(2) .and. mb%mp(2) /= munkno) return
      if (ma%mp(2) < 0 .or. mb%mp(2) < 0 .or. mb%mp(3) == 0 .or.  &
          ma%mp(2) >= mexpov .or. mb%mp(2) >= mexpov) then
          kflag = -4
          if (ma%mp(2) /= munkno .and. mb%mp(2) /= munkno) then
              namest(ncall) = 'IMDIVR'
              call fmwarn
          endif
          call imunknown(mc)
          call imunknown(md)
          kresult = 1
          return
      endif
      if (ma%mp(2) <= 2) then
          if (mb%mp(2) > 2) return
          if (mb%mp(3) == 0) return
          if (ma%mp(2) <= 1) then
              mda = ma%mp(1) * ma%mp(3)
          else
              mda = ma%mp(1) * (ma%mp(3)*mbase + ma%mp(4))
          endif
          if (mb%mp(2) <= 1) then
              mdb = mb%mp(1) * mb%mp(3)
          else
              mdb = mb%mp(1) * (mb%mp(3)*mbase + mb%mp(4))
          endif
          mdab = aint (mda / mdb)
          mdr = mda - mdab*mdb
          if (abs(mdab) < mbase) then
              mc%mp(2) = 1
              if (mdab == 0) mc%mp(2) = 0
              if (mdab >= 0) then
                  mc%mp(3) = mdab
                  mc%mp(1) = 1
              else
                  mc%mp(3) = -mdab
                  mc%mp(1) = -1
              endif
              mc%mp(4) = 0
          else if (abs(mdab) < mbase*mbase) then
              mc%mp(2) = 2
              if (mdab >= 0) then
                  mc%mp(3) = aint (mdab/mbase)
                  mc%mp(4) = abs(mdab - mbase*mc%mp(3))
                  mc%mp(1) = 1
              else
                  mc%mp(3) = aint (-mdab/mbase)
                  mc%mp(4) = abs(-mdab - mbase*mc%mp(3))
                  mc%mp(1) = -1
              endif
          else
              return
          endif
          if (abs(mdr) < mbase) then
              md%mp(2) = 1
              if (mdr == 0) md%mp(2) = 0
              if (mdr >= 0) then
                  md%mp(3) = mdr
                  md%mp(1) = 1
              else
                  md%mp(3) = -mdr
                  md%mp(1) = -1
              endif
              md%mp(4) = 0
              kresult = 1
              return
          else if (abs(mdr) < mbase*mbase) then
              md%mp(2) = 2
              if (mdr >= 0) then
                  md%mp(3) = aint (mdr/mbase)
                  md%mp(4) = abs(mdr - mbase*md%mp(3))
                  md%mp(1) = 1
              else
                  md%mp(3) = aint (-mdr/mbase)
                  md%mp(4) = abs(-mdr - mbase*md%mp(3))
                  md%mp(1) = -1
              endif
              kresult = 1
              return
          endif
      endif

      return
      end subroutine imdivr_sc

      subroutine imdp2m(x, ma)

!  ma = x

!  Convert the integer part of a double precision to an im number.

      use fmvals
      implicit none

      double precision :: x
      type(multi) :: ma
      intent (in) :: x
      intent (inout) :: ma

      integer :: ndsave
      type(multi), save :: mxy

      ncall = ncall + 1
      kflag = 0
      namest(ncall) = 'IMDP2M'
      if (ntrace /= 0) call imntr_inpd(x)

      ndsave = ndig
      if (abs(x) < 1) then
          call imi2m(0, ma)
      else
          ndig = max(3, int(log(abs(x))/log(dble(mbase)))+2)
          call fmdp2m(x, mxy)
          call imfm2i(mxy, ma)
      endif

      if (ntrace /= 0) call imntr_out1(ma)
      ndig = ndsave
      ncall = ncall - 1

      return
      end subroutine imdp2m

      subroutine imdvir(ma, idiv, mb, irem)

!  mb = int(ma / idiv),    irem = remainder from the division.

!  Division by a one word integer.  The remainder is also a one word integer.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: idiv, irem
      intent (in) :: ma, idiv
      intent (inout) :: mb, irem

      real (kind(1.0d0)) :: mkt, modint, mvalp
      integer :: j, ka, kl, klt, kltflg, kpt, kresult, n1, ndsave, nmval, ntrsav, nv2, result_size
      type(multi), save :: mxy(3)

      result_size = max(5, int(ma%mp(2)+5))
      if (abs(result_size) >= mexpov) result_size = 5
      call fmalloc(mb, result_size)
      result_size = 2*ma%mp(2) + 30
      if (abs(result_size) >= mexpov) result_size = 32
      result_size = max(32, result_size)
      call fmalloc(mwa, result_size)

      ncall = ncall + 1
      mb%mp(5) = 0
      kflag = 0
      ndsave = ndig
      kltflg = 0
      ntrsav = ntrace
      ntrace = 0
      mkt = abs(idiv)
      if (mkt < mbase) then
          call fmalloc(mxy(1), 5)
          mxy(1)%mp(2) = 1
          mxy(1)%mp(3) = abs(idiv)
          mxy(1)%mp(4) = 0
          mxy(1)%mp(5) = 0
          mxy(1)%mp(1) = 1
          if (idiv < 0) mxy(1)%mp(1) = -1
      else if (mkt < mbase*mbase) then
          call fmalloc(mxy(1), 6)
          mxy(1)%mp(2) = 2
          mxy(1)%mp(3) = int(mkt/mbase)
          mxy(1)%mp(4) = mkt - mxy(1)%mp(3)*mbase
          mxy(1)%mp(5) = 0
          mxy(1)%mp(6) = 0
          mxy(1)%mp(1) = 1
          if (idiv < 0) mxy(1)%mp(1) = -1
      else
          call imi2m(idiv, mxy(1))
      endif
      ntrace = ntrsav
      if (ntrace /= 0) then
          namest(ncall) = 'IMDVIR'
          call imntr_inp1i(ma, idiv)
      endif

      call imdvir_sc(ma, idiv, mb, irem, kresult)
      if (kresult == 1) then
          call imdvir3(mb, irem, ndsave)
          return
      endif

      mxy(1)%mp(1) = 1
      kl = mxy(1)%mp(2)
      if (ma%mp(2) <= mxy(1)%mp(2)) then
          if (ma%mp(2) == mxy(1)%mp(2) .and.  &
              abs(ma%mp(3)) <= mxy(1)%mp(3)) then
              klt = 1
              do j = 2, kl+1
                 if (ma%mp(j+1) /= mxy(1)%mp(j+1)) then
                     if (ma%mp(j+1) < mxy(1)%mp(j+1)) kltflg = 1
                     klt = 0
                     exit
                 endif
              enddo
              if (klt == 1) kltflg = 2
          endif
          if (ma%mp(2) < mxy(1)%mp(2) .or. kltflg >= 1) then
              if (kltflg /= 2) then
                  call imm2i(ma, irem)
                  irem = abs(irem)
                  call imi2m(0, mb)
              else
                  call imi2m(1, mb)
                  irem = 0
              endif
              call imdvir2(ma, idiv, mb, irem)
              call imdvir3(mb, irem, ndsave)
              return
          endif
      endif
      ndig = int(ma%mp(2))
      if (ndig < 3) ndig = 3
      if (abs(ma%mp(2)) >= mexpov) ndig = 3
      n1 = int(ma%mp(2)) + 1

!             if abs(idiv) >= mxbase use imdivr.

      mvalp = abs(idiv)
      nmval = int(mvalp)
      nv2 = nmval - 1
      if (abs(idiv) > mxbase .or. nmval /= abs(idiv) .or. nv2 /= abs(idiv)-1) then
          call imi2m(idiv, mxy(2))
          call imdivr(ma, mxy(2), mxy(1), mxy(3))
          call imeq(mxy(1), mb)
          call imeq(mxy(3), mxy(2))
          call imm2i(mxy(2), irem)
          call imdvir3(mb, irem, ndsave)
          return
      endif

!             Find the first significant digit of the quotient.

      mkt = ma%mp(3)
      klt = 1
      kpt = 2
      if (mkt >= mvalp) then
          kpt = 2
          klt = 0
      endif
      if (klt == 1) then
          do j = 3, n1
             mkt = mkt*mbase + ma%mp(j+1)
             if (mkt >= mvalp) then
                 kpt = j
                 klt = 0
                 exit
             endif
          enddo
      endif
      if (klt == 1) then
          call imm2i(ma, irem)
          call imi2m(0, mb)
          call imdvir3(mb, irem, ndsave)
          return
      endif

!             Do the rest of the division.

      ka = kpt + 1
      mwa%mp(2) = ma%mp(2) + 2 - kpt
      mwa%mp(3) = int (mkt/mvalp)
      modint = mkt - mwa%mp(3)*mvalp
      if (ka <= n1) then
          kl = 3 - ka

!             (Inner Loop)

          do j = ka+1, n1+1
             mkt = modint*mbase + ma%mp(j)
             mwa%mp(kl+j) = int (mkt/mvalp)
             modint = mkt - mwa%mp(kl+j)*mvalp
          enddo
      endif

      do j = 1, int(mwa%mp(2))+1
         mb%mp(j+1) = mwa%mp(j+1)
      enddo
      irem = int(modint)

      call imdvir2(ma, idiv, mb, irem)
      call imdvir3(mb, irem, ndsave)

      return
      end subroutine imdvir

      subroutine imdvir2(ma, idiv, mb, irem)

!  Check for the signs of the results for imdvir.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: idiv, irem
      intent (in) :: ma, idiv
      intent (inout) :: mb, irem

      mb%mp(1) = 1
      if (ma%mp(1) < 0 .and. idiv > 0) then
          if (mb%mp(2) /= munkno .and. mb%mp(3) /= 0) mb%mp(1) = -1
          irem = -irem
      else if (ma%mp(1) > 0 .and. idiv < 0) then
          if (mb%mp(2) /= munkno .and. mb%mp(3) /= 0) mb%mp(1) = -1
      else if (ma%mp(1) < 0 .and. idiv < 0) then
          irem = -irem
      endif

      return
      end subroutine imdvir2

      subroutine imdvir3(mb, irem, ndsave)

!  Output tracing for imdvir.

      use fmvals
      implicit none

      type(multi) :: mb
      integer :: irem, ndsave
      intent (in) :: ndsave
      intent (inout) :: mb, irem

      if (mb%mp(2) <= 1) mb%mp(4) = 0
      if (ntrace /= 0 .and. ncall <= lvltrc) then
          call imntr_out1i(mb, irem)
      endif

      ncall = ncall - 1
      ndig = ndsave

      return
      end subroutine imdvir3

      subroutine imdvir_sc(ma, idiv, mb, irem, kresult)

!  mb = int(ma / idiv),    irem = remainder from the division.

!  Division by a one word integer.  The remainder is also a one word integer.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: idiv, irem, kresult
      intent (in) :: ma, idiv
      intent (inout) :: mb, irem, kresult

      real (kind(1.0d0)) :: mda, mdab, mdb, mdr
      integer :: jdiv

      kresult = 0
      jdiv = abs(idiv)

      if (ma%mp(2) < 0) then
          irem = iunkno
          kflag = -4
          namest(ncall) = 'IMDVIR'
          call fmwarn
          call imunknown(mb)
          kresult = 1
          return
      endif
      if (jdiv == 1 .and. ma%mp(2) /= munkno) then
          if (idiv == 1) then
              call imeq(ma, mb)
              irem = 0
              kresult = 1
              return
          else
              call imeq(ma, mb)
              call fmnegate(mb)
              irem = 0
              kresult = 1
              return
          endif
      endif
      if (ma%mp(2) >= mexpov .or. idiv == 0) then
          kflag = -4
          if (ma%mp(2) /= munkno) then
              namest(ncall) = 'IMDVIR'
              call fmwarn
          endif
          call imunknown(mb)
          irem = iunkno
          kresult = 1
          return
      endif
      if (ma%mp(2) <= 2) then
          if (ma%mp(2) <= 1) then
              mda = ma%mp(1) * ma%mp(3)
          else
              mda = ma%mp(1) * (ma%mp(3)*mbase + ma%mp(4))
          endif
          mdb = idiv
          mdab = aint (mda/mdb)
          mdr = mda - mdab*mdb
          if (abs(mdab) < mbase) then
              mb%mp(2) = 1
              if (mdab == 0) mb%mp(2) = 0
              if (mdab < 0) then
                  mb%mp(3) = -mdab
                  mb%mp(1) = -1
              else
                  mb%mp(3) = mdab
                  mb%mp(1) = 1
              endif
              mb%mp(4) = 0
          else if (abs(mdab) < mbase*mbase) then
              mb%mp(2) = 2
              if (mdab < 0) then
                  mb%mp(3) = aint (-mdab/mbase)
                  mb%mp(4) = abs(-mdab - mbase*mb%mp(3))
                  mb%mp(1) = -1
              else
                  mb%mp(3) = aint (mdab/mbase)
                  mb%mp(4) = abs(mdab - mbase*mb%mp(3))
                  mb%mp(1) = 1
              endif
          else
              return
          endif
          irem = int(mdr)
          kresult = 1
          return
      endif

      return
      end subroutine imdvir_sc

      subroutine imeq(ma, mb)

!  mb = ma

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      integer :: j, kdg, result_size

      result_size = ma%mp(2)+3
      if (abs(result_size) >= mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mb, result_size)

      mb%mp(5) = 0
      kdg = max(2, int(ma%mp(2))) + 2
      if (kdg > size(ma%mp)) kdg = 4
      do j = 1, kdg
         mb%mp(j) = ma%mp(j)
      enddo
      if (kdg == 4 .and. abs(ma%mp(2)) >= mexpov) mb%mp(5) = ma%mp(5)

      return
      end subroutine imeq

      subroutine imfact(n, ma)

!  ma = n!   (n factorial)  n is a machine precision integer and ma is an im number.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: n
      intent (in) :: n
      intent (inout) :: ma

      integer :: j, k, ndsave, result_size

      k = max(n, 2)
      result_size = 10 + (log(2.0d0*dppi*k)/2 + k*log(dble(k)) - k) / dlogmb
      if (abs(result_size) >= mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(ma, result_size)

      ncall = ncall + 1
      ma%mp(5) = 0
      kflag = 0
      ndsave = ndig
      if (ntrace /= 0) then
          namest(ncall) = 'IMFACT'
          call imntr_inpi(n)
      endif

      if (n < 0) then
          call imunknown(ma)
          kflag = -4
      else if (n <= 12) then
          k = 1
          do j = 2, n
             k = k*j
          enddo
          call imi2m(k, ma)
      else
          call imfact_p(2, n, ma)
      endif

      if (ma%mp(2) <= 1) ma%mp(4) = 0
      if (ntrace /= 0) call imntr_out1(ma)
      ncall = ncall - 1
      ndig = ndsave

      return
      end subroutine imfact

      recursive subroutine imfact_p(a, b, mp)

!  This routine does the binary splitting for computing n!
!  mp = a * (a+1) * ... * b.

      use fmvals
      implicit none

      integer :: a, b
      type(multi) :: mp
      intent (in) :: a, b
      intent (inout) :: mp

      type(multi) :: mxy(2)
      integer :: j, m, result_size
      real (kind(0.0d0)) :: da, db, dla, dlb

      da = a
      db = b
      if ((db+0.5d0)*log(db+1) > 1.0d+10) then
          result_size = (b-a+1)*log(db) / dlogmb + 7 + ngrd52
      else
          if (a >= 2) then
              dla = (da+0.5d0)*log(da) - da + 1/(12*(da))
          else
              dla = 0
          endif
          if (b >= 2) then
              dlb = (db+0.5d0)*log(db) - db + 1/(12*(db))
          else
              dlb = 0
          endif
          result_size = ( dlb - dla ) / dlogmb + 7 + ngrd52
      endif
      result_size = max(5, result_size)
      call fmalloc(mp, result_size)

      mp%mp(5) = 0
      if (b-a < 25) then
          call fmalloc(mxy(1), result_size)
          call imi2m(a, mp)
          do j = a+1, b-1, 2
             call immpyi(mp, j, mxy(1))
             call immpyi(mxy(1), j+1, mp)
          enddo
          if (mod(b-a, 2) == 1) then
              call immpyi(mp, b, mxy(1))
              call imeq(mxy(1), mp)
          endif
      else
          m = a/2 + b/2 + mod(a, 2)*mod(b, 2)
          call imfact_p(a, m, mxy(1))
          call imfact_p(m+1, b, mxy(2))
          call immpy(mxy(1), mxy(2), mp)

      endif

      return
      end subroutine imfact_p

      subroutine imfm2i(ma, mb)

!  mb = int(ma)

!  Convert from real (fm) format to integer (im) format.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      integer :: j, ntrsav, ndgsav, result_size
      type(multi), save :: mxy(1)

      result_size = max(5, int(ma%mp(2)+4))
      if (abs(result_size) >= mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mb, result_size)

      ncall = ncall + 1
      mb%mp(5) = 0
      kflag = 0
      ntrsav = ntrace
      ntrace = 0
      ndgsav = ndig
      if (abs(ma%mp(2)+3) >= mexpov) then
          ndig = 3
          call fmeq(ma, mb)
          ndig = ndgsav
      else
          ndig = min(ndig, result_size-3)
          if (ndig < 3) ndig = 3
          call fmint(ma, mxy(1))
          call fmeq(mxy(1), mb)
          ndig = ndgsav
          do j = ndig+2, int(ma%mp(2))+1
             mb%mp(j+1) = 0
          enddo
          if (mb%mp(2) <= 1) mb%mp(4) = 0
      endif
      ntrace = ntrsav
      ncall = ncall - 1

      return
      end subroutine imfm2i

      subroutine imform(form, ma, string)

!  Convert an im number (ma) to a character string base 10 (string) using form format.

!  form can be one of these types:  iw,  fw.d,  ew.d,  esw.d,  1pew.d  for positive integers w,d.

      use fmvals
      implicit none

      character(*) :: form, string
      type(multi) :: ma
      intent (in) :: form, ma
      intent (inout) :: string

      integer :: ndsave

      ncall = ncall + 1
      kflag = 0
      namest(ncall) = 'IMFORM'
      ndsave = ndig
      ndig = int(ma%mp(2))
      if (ndig < 3) ndig = 3
      if (abs(ma%mp(2)) >= mexpov) ndig = 3

      call fmform(form, ma, string)

      ncall = ncall - 1
      ndig = ndsave

      return
      end subroutine imform

      subroutine imfprint(form, ma)

      use fmvals
      implicit none

      character(*) :: form
      type(multi) :: ma
      intent (in) :: form, ma

      call imfprt(form, ma)

      return
      end subroutine imfprint

      subroutine imfprt(form, ma)

!  Print an im number (ma) on unit kw using form format.

!  form can be one of these types:  iw,  fw.d,  ew.d,  esw.d,  1pew.d  for positive integers w,d.

      use fmvals
      implicit none

      character(*) :: form
      type(multi) :: ma
      intent (in) :: form, ma

      integer :: ndsave

      ncall = ncall + 1
      kflag = 0
      namest(ncall) = 'IMFPRT'
      ndsave = ndig
      ndig = int(ma%mp(2))
      if (ndig < 3) ndig = 3
      if (abs(ma%mp(2)) >= mexpov) ndig = 3

      call fmfprt(form, ma)

      ncall = ncall - 1
      ndig = ndsave

      return
      end subroutine imfprt

      subroutine imgcd(ma, mb, mc)

!  Lehmer's gcd algorithm for mc = gcd(ma,mb).

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: j, k
      double precision :: abcd_max, dpbase, a1, b1, c1, d1, q1a, q1b, t1, t2, t3, u1, v1
      character(25) :: st
      logical, external :: imabs_greater_than
      type(multi), save :: mxy(4)
      integer :: ndsave, result_size

      result_size = max(ma%mp(2), mb%mp(2)) + 3
      if (abs(result_size) >= mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mc, result_size)

      ncall = ncall + 1
      mc%mp(5) = 0
      kflag = 0
      ndsave = ndig
      if (ntrace /= 0) then
          namest(ncall) = 'IMGCD'
          call imntr_inp2(ma, mb)
      endif

!             Check for special cases.

      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) then
          call imunknown(mc)
          kflag = -4
          call imgcd_tr(mc, ndsave)
          return
      else if (mb%mp(3) == 0) then
          call imabs(ma, mc)
          call imgcd_tr(mc, ndsave)
          return
      else if (ma%mp(3) == 0) then
          call imabs(mb, mc)
          call imgcd_tr(mc, ndsave)
          return
      else if (mb%mp(2) == 1 .and. abs(mb%mp(3)) == 1) then
          call imi2m(1, mc)
          call imgcd_tr(mc, ndsave)
          return
      else if (ma%mp(2) == 1 .and. abs(ma%mp(3)) == 1) then
          call imi2m(1, mc)
          call imgcd_tr(mc, ndsave)
          return
      else if (ma%mp(2) < 0 .or. mb%mp(2) < 0 .or.  &
          ma%mp(2) >= mexpov .or. mb%mp(2) >= mexpov) then
          kflag = -4
          namest(ncall) = 'IMGCD'
          call fmwarn
          call imunknown(mc)
          call imgcd_tr(mc, ndsave)
          return
      endif

      call fmalloc(mxy(1), result_size)
      call fmalloc(mxy(2), result_size)
      call fmalloc(mxy(3), result_size)
      call fmalloc(mxy(4), result_size)
      call imabs(ma, mxy(3))
      call imabs(mb, mxy(4))
      if (imabs_greater_than(mxy(3), mxy(4))) then
          call imeq(mxy(3), mxy(1))
          call imeq(mxy(4), mxy(2))
      else
          call imeq(mxy(4), mxy(1))
          call imeq(mxy(3), mxy(2))
      endif

      if (mbase < 1000) then
          call imgcd2(ma, mb, mc)
          call imgcd_tr(mc, ndsave)
          return
      endif

      abcd_max = (maxint / mbase) / 2
      dpbase = mbase
      t1 = 1.0d-3 / epsilon(1.0d0)
      call imi2m(1, mxy(3))
      t2 = dpbase
      k = 1
      do while (t2 < t1)
         mxy(3)%mp(2) = mxy(3)%mp(2) + 1
         k = k + 1
         mxy(3)%mp(k+2) = 0
         t2 = t2 * dpbase
      enddo
      mxy(3)%mp(3) = aint( dpbase * t1 / t2 )

!             mxy(1) >= mxy(2) > 0 during the algorithm.

      do while (imabs_greater_than(mxy(1), mxy(3)))

         if (mxy(1)%mp(2) == mxy(2)%mp(2)) then
             u1 = mxy(1)%mp(3)
             v1 = mxy(2)%mp(3)
             do j = 2, int(mxy(1)%mp(2))
                if (u1 < maxint / (10 * dpbase)) then
                    u1 = u1 * dpbase + mxy(1)%mp(j+2)
                    v1 = v1 * dpbase + mxy(2)%mp(j+2)
                else
                    t1 = (mxy(1)%mp(j+2) + 1.0d-2) / dpbase
                    t2 = (mxy(2)%mp(j+2) + 1.0d-2) / dpbase
                    do while (u1 < maxint / 100)
                       t1 = t1 * 10
                       k = t1
                       t1 = t1 - k
                       u1 = u1 * 10 + k

                       t2 = t2 * 10
                       k = t2
                       t2 = t2 - k
                       v1 = v1 * 10 + k
                    enddo
                    exit
                endif
             enddo
         else if (mxy(1)%mp(2) == mxy(2)%mp(2) + 1) then
             u1 = mxy(1)%mp(3)
             v1 = 0
             do j = 2, int(mxy(1)%mp(2))
                if (u1 < maxint / (10 * dpbase)) then
                    u1 = u1 * dpbase + mxy(1)%mp(j+2)
                    v1 = v1 * dpbase + mxy(2)%mp(j+1)
                else
                    t1 = (mxy(1)%mp(j+2)   + 1.0d-2) / dpbase
                    t2 = (mxy(2)%mp(j+1) + 1.0d-2) / dpbase
                    do while (u1 < maxint / 100)
                       t1 = t1 * 10
                       k = t1
                       t1 = t1 - k
                       u1 = u1 * 10 + k

                       t2 = t2 * 10
                       k = t2
                       t2 = t2 - k
                       v1 = v1 * 10 + k
                    enddo
                    exit
                endif
             enddo
         else
             u1 = 1
             v1 = 0
         endif

         a1 = 1
         b1 = 0
         c1 = 0
         d1 = 1
         q1a = 0
         q1b = 0

         do while (q1a == q1b)
            if (v1 + c1 /= 0.0d0 .and. v1 + d1 /= 0.0d0) then
                q1a = aint( (u1 + a1) / (v1 + c1) )
                q1b = aint( (u1 + b1) / (v1 + d1) )
                if (q1a == q1b) then
                    t1 = a1 - q1a*c1
                    t2 = b1 - q1a*d1
                    t3 = u1 - q1a*v1
                    if (abs(t1) > abcd_max .or. abs(t2) > abcd_max) then
                        exit
                    else
                        a1 = c1
                        c1 = t1
                        b1 = d1
                        d1 = t2
                        u1 = v1
                        v1 = t3
                    endif
                endif
            else
                exit
            endif
         enddo

         if (b1 == 0) then
             call immod(mxy(1), mxy(2), mxy(4))
             call imeq(mxy(2), mxy(1))
             call imeq(mxy(4), mxy(2))
             if (mxy(2)%mp(3) == 0) then
                 call imeq(mxy(1), mc)
                 call imgcd_tr(mc, ndsave)
                 return
             endif
         else
             call imgcd_reduce_uv(mxy(1), mxy(2), mxy(4), a1, b1, c1, d1)
         endif
      enddo

!             Finish the gcd using double precision.

      if (mxy(2)%mp(3) == 0) then
          call imeq(mxy(1), mc)
          call imgcd_tr(mc, ndsave)
          return
      endif
      u1 = 0
      do j = 1, int(mxy(1)%mp(2))
         u1 = u1 * dpbase + mxy(1)%mp(j+2)
      enddo
      v1 = 0
      do j = 1, int(mxy(2)%mp(2))
         v1 = v1 * dpbase + mxy(2)%mp(j+2)
      enddo
      do while (v1 > 0)
         t1 = mod(u1, v1)
         u1 = v1
         v1 = t1
      enddo
      if (u1 < dpbase) then
          mxy(1)%mp(2) = 1
          mxy(1)%mp(3) = u1
          mxy(1)%mp(4) = 0
      else if (u1 < dpbase*dpbase) then
          mxy(1)%mp(2) = 2
          mxy(1)%mp(3) = aint(u1/dpbase)
          mxy(1)%mp(4) = mod(u1, dpbase)
      else
          if (abs(u1) < huge(1)) then
              k = u1
              call imi2m(k, mxy(1))
          else
              write (st, '(E25.16)') u1
              call imst2m(st, mxy(1))
          endif
      endif

      call imeq(mxy(1), mc)

      if (mc%mp(2) == munkno) then
          kflag = -4
          namest(ncall) = 'IMGCD'
          call fmwarn
      endif

      call imgcd_tr(mc, ndsave)

      return
      end subroutine imgcd

      subroutine imgcd2(ma, mb, mc)

!  mc is returned as the greatest common divisor of ma and mb.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: kl, ndsave, result_size
      type(multi), save :: mxy(4)

      result_size = max(ma%mp(2), mb%mp(2)) + 3
      if (abs(result_size) >= mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mc, result_size)

      ncall = ncall + 1
      mc%mp(5) = 0
      kflag = 0
      ndsave = ndig
      if (ntrace /= 0) then
          namest(ncall) = 'IMGCD2'
          call imntr_inp2(ma, mb)
      endif

!             Check for special cases.

      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) then
          call imunknown(mc)
          kflag = -4
          call imgcd_tr(mc, ndsave)
          return
      else if (mb%mp(3) == 0) then
          call imabs(ma, mc)
          call imgcd_tr(mc, ndsave)
          return
      else if (ma%mp(3) == 0) then
          call imabs(mb, mc)
          call imgcd_tr(mc, ndsave)
          return
      else if (mb%mp(2) == 1 .and. abs(mb%mp(3)) == 1) then
          call imi2m(1, mc)
          call imgcd_tr(mc, ndsave)
          return
      else if (ma%mp(2) == 1 .and. abs(ma%mp(3)) == 1) then
          call imi2m(1, mc)
          call imgcd_tr(mc, ndsave)
          return
      else if (ma%mp(2) < 0 .or. mb%mp(2) < 0 .or.  &
          ma%mp(2) >= mexpov .or. mb%mp(2) >= mexpov) then
          kflag = -4
          namest(ncall) = 'IMGCD2'
          call fmwarn
          call imunknown(mc)
          call imgcd_tr(mc, ndsave)
          return
      endif

      call imabs(ma, mxy(3))
      call imabs(mb, mxy(2))
      call immax(mxy(3), mxy(2), mxy(1))
      call immin(mxy(3), mxy(2), mxy(4))
      call imeq(mxy(4), mxy(2))
      kl = 1
      do while (kl == 1)
         call imdivr(mxy(1), mxy(2), mxy(4), mxy(3))
         if (mxy(3)%mp(3) /= 0) then
             call imeq(mxy(2), mxy(1))
             call imeq(mxy(3), mxy(2))
         else
             kl = 0
         endif
      enddo
      call imeq(mxy(2), mc)

      if (mc%mp(2) == munkno) then
          kflag = -4
          namest(ncall) = 'IMGCD2'
          call fmwarn
      endif

      call imgcd_tr(mc, ndsave)

      return
      end subroutine imgcd2

      subroutine imgcd_reduce_uv(mu, mv, mv_shift, a1, b1, c1, d1)

!  Return  mu = a1 * mu + b1 * mv,
!  and     mv = c1 * mu + d1 * mv.

      use fmvals
      implicit none

      type(multi) :: mu, mv, mv_shift
      double precision :: a1, b1, c1, d1
      intent (in) :: a1, b1, c1, d1
      intent (inout) :: mu, mv, mv_shift

      integer :: j, k, n_u, n_v
      double precision :: u1, v1

      n_u = mu%mp(2)
      n_v = mv%mp(2)
      k = n_u - n_v
      if (k == 0) then
          do j = 3, n_u+2
             u1 = mu%mp(j)
             v1 = mv%mp(j)
             mu%mp(j-1) = a1 * u1 + b1 * v1
             mv%mp(j-1) = c1 * u1 + d1 * v1
          enddo
      else
          do j = 3, k+2
             mv_shift%mp(j) = 0
          enddo
          do j = 3, n_v+2
             mv_shift%mp(j+k) = mv%mp(j)
          enddo
          n_v = n_u
          do j = 3, n_u+2
             u1 = mu%mp(j)
             v1 = mv_shift%mp(j)
             mu%mp(j-1) = a1 * u1 + b1 * v1
             mv%mp(j-1) = c1 * u1 + d1 * v1
          enddo
      endif

!             Normalize the digits in mu and mv.

      do j = n_u+1, 2, -1
         if (mu%mp(j) < 0) then
             k = (-mu%mp(j)-1) / mbase + 1
             mu%mp(j) = mu%mp(j) + k * mbase
             mu%mp(j-1) = mu%mp(j-1) - k
         else
             k = mu%mp(j) / mbase
             mu%mp(j) = mu%mp(j) - k * mbase
             mu%mp(j-1) = mu%mp(j-1) + k
         endif
      enddo

      do j = n_v+1, 2, -1
         if (mv%mp(j) < 0) then
             k = (-mv%mp(j)-1) / mbase + 1
             mv%mp(j) = mv%mp(j) + k * mbase
             mv%mp(j-1) = mv%mp(j-1) - k
         else
             k = mv%mp(j) / mbase
             mv%mp(j) = mv%mp(j) - k * mbase
             mv%mp(j-1) = mv%mp(j-1) + k
         endif
      enddo

!             Normalize the numbers if there are leading zeros.

      if (mu%mp(2) == 0) then
          mu%mp(2) = n_u - 1
      else
          do j = n_u+2, 3, -1
             mu%mp(j) = mu%mp(j-1)
          enddo
          mu%mp(2) = n_u
      endif
      k = 0
      do j = 3, n_u+2
         if (mu%mp(j) == 0) then
             k = k + 1
         else
             exit
         endif
      enddo
      if (k > 0) then
          mu%mp(2) = mu%mp(2) - k
          do j = 3, int(mu%mp(2))+2
             mu%mp(j) = mu%mp(j+k)
          enddo
          do j = 0, k-1
             mu%mp(2+n_u-j) = 0
          enddo
      endif

      if (mv%mp(2) == 0) then
          mv%mp(2) = n_v - 1
      else
          do j = n_v+2, 3, -1
             mv%mp(j) = mv%mp(j-1)
          enddo
          mv%mp(2) = n_v
      endif
      k = 0
      do j = 3, n_v+2
         if (mv%mp(j) == 0) then
             k = k + 1
         else
             exit
         endif
      enddo
      if (k > 0) then
          mv%mp(2) = mv%mp(2) - k
          do j = 3, int(mv%mp(2))+2
             mv%mp(j) = mv%mp(j+k)
          enddo
          do j = 0, k-1
             mv%mp(2+n_v-j) = 0
          enddo
      endif

      end subroutine imgcd_reduce_uv

      subroutine imgcd_tr(mc, ndsave)

!  Trace output for imgcd.

      use fmvals
      implicit none

      type(multi) :: mc
      integer :: ndsave
      intent (in) :: ndsave
      intent (inout) :: mc

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      if (ntrace /= 0) call imntr_out1(mc)
      ncall = ncall - 1
      ndig = ndsave

      return
      end subroutine imgcd_tr

      subroutine imi2fm(ma, mb)

!  mb = ma

!  Convert from integer (im) format to real (fm) format.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      integer :: kdg

      call fmalloc(mb, ndig+2)

      ncall = ncall + 1
      kflag = 0
      kdg = max(3, int(ma%mp(2)))
      if (ma%mp(2) >= mexpov) kdg = 3
      call fmequ(ma, mb, kdg, ndig)
      ncall = ncall - 1

      return
      end subroutine imi2fm

      subroutine imi2m(ival, ma)

!  ma = ival

!  This routine performs the trace printing.  imi2m2 is used to do the conversion.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ival
      intent (inout) :: ma

      ncall = ncall + 1
      if (ntrace /= 0) then
          namest(ncall) = 'IMI2M'
          call imntr_inpi(ival)

          call imi2m2(ival, ma)

          call imntr_out1(ma)
      else
          call imi2m2(ival, ma)
      endif
      ncall = ncall - 1

      return
      end subroutine imi2m

      subroutine imi2m2(ival, ma)

!  ma = ival

!  Convert a one word integer to im format.

      use fmvals
      implicit none

      integer :: ival
      type(multi) :: ma
      intent (in) :: ival
      intent (inout) :: ma

      integer :: ndsave, result_size
      double precision :: dt

      kflag = 0
      ndsave = ndig
      if (ival == 0) then
          ndig = 3
      else
          dt = log(dble(abs(ival)))/dlogmb + 2
          ndig = max(3, int(dt))
      endif
      result_size = ndig + 3
      if (abs(result_size) >= mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(ma, result_size)

      ma%mp(5) = 0
      call fmi2m2(ival, ma)
      if (ma%mp(2) <= 1) ma%mp(4) = 0
      ndig = ndsave

      return
      end subroutine imi2m2

      subroutine iminp(line, ma, la, lb)

!  Convert an array of characters to multiple precision integer format.

!  line is an a1 character array of length lb to be converted to im format and returned in ma.
!  Convert the section line(la:lb)

      use fmvals
      implicit none

      integer :: la, lb
      character :: line(lb)
      type(multi) :: ma
      intent (in) :: line, la, lb
      intent (inout) :: ma

      integer :: kfsave, ndsave


      ncall = ncall + 1
      kflag = 0
      ndsave = ndig
      namest(ncall) = 'IMINP'

      ndig = 50
      ncall = ncall - 1
      call fminp(line, mwi, la, lb)
      ncall = ncall + 1
      if (mwi%mp(2) > 50 .and. abs(mwi%mp(2)) < mexpov) then
          ndig = int(mwi%mp(2) + 1)
          if (ndig < 3) ndig = 3
          ncall = ncall - 1
          call fminp(line, mwi, la, lb)
          ncall = ncall + 1
      endif
      kfsave = kflag
      call imfm2i(mwi, ma)
      kflag = kfsave

      if (ma%mp(2) <= 1) ma%mp(4) = 0
      ndig = ndsave
      if (ntrace /= 0) call imntr_out1(ma)
      ncall = ncall - 1

      return
      end subroutine iminp

      subroutine imm2dp(ma, x)

!  x = ma

!  Convert an im number to double precision.

!  If kflag = -4 is returned for a value of ma that is in the range of the machine's double
!  precision number system, change the definition of dpmax in routine fmset to reflect the
!  current machine's range.

      use fmvals
      implicit none

      type(multi) :: ma
      double precision :: x
      intent (in) :: ma
      intent (inout) :: x

      integer :: nd2, ndsave

      ncall = ncall + 1
      kflag = 0
      namest(ncall) = 'IMM2DP'
      if (ntrace /= 0) call imntr_inp1(ma)

      ndsave = ndig
      ndig = max(3, int(ma%mp(2)))
      nd2 = 2 - log(epsilon(1.0d0))/dlogmb
      if (ndig >= nd2) ndig = nd2
      if (ndig < 3) ndig = 3
      call fmm2dp2(ma, x)

      if (ntrace /= 0) call imntr_outd(x)
      ndig = ndsave
      ncall = ncall - 1

      return
      end subroutine imm2dp

      subroutine imm2i(ma, ival)

!  ival = ma

!  Convert an im number to a one word integer.

!  kflag =  0 is returned if the conversion is exact.
!        = -4 is returned if ma is larger than intmax in magnitude.  ival = iunkno is returned as
!             an indication that ival could not be computed without integer overflow.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: ival
      intent (in) :: ma
      intent (inout) :: ival

      integer :: ndsave

      ncall = ncall + 1
      ndsave = ndig
      if (ntrace /= 0) then
          namest(ncall) = 'IMM2I'
          call imntr_inp1(ma)
      endif

      ndig = int(ma%mp(2))
      if (ndig < 3) ndig = 3
      if (abs(ma%mp(2)) >= mexpov) ndig = 3
      kflag = 0
      call fmm2i(ma, ival)

      if (kflag == -4 .and. ma%mp(2) /= munkno) then
          namest(ncall) = 'IMM2I'
          call fmwarn
      endif
      if (abs(ntrace) >= 1 .and. ncall <= lvltrc) then
          call imntr_outi(ival)
      endif
      ncall = ncall - 1
      ndig = ndsave

      return
      end subroutine imm2i

      subroutine imm2sp(ma, x)

!  x = ma

!  Convert an im number to single precision.

!  if kflag = -4 is returned for a value of ma that is in the range of the machine's single
!  precision number system, change the definition of spmax in routine fmset to reflect the
!  current machine's range.

      use fmvals
      implicit none

      type(multi) :: ma
      real :: x
      intent (in) :: ma
      intent (inout) :: x

      double precision :: y
      integer :: nd2, ndsave

      ncall = ncall + 1
      kflag = 0
      namest(ncall) = 'IMM2SP'
      if (ntrace /= 0) call imntr_inp1(ma)

      ndsave = ndig
      ndig = max(3, int(ma%mp(2)))
      nd2 = 2 - log(epsilon(1.0d0))/dlogmb
      if (ndig >= nd2) ndig = nd2
      if (ndig < 3) ndig = 3
      call fmm2dp2(ma, y)
      if (abs(y) <= dble(huge(x))) then
          x = y
      else
          x = runkno
          kflag = -4
          if (ma%mp(2) /= munkno) call fmwarn
      endif

      if (ntrace /= 0) call imntr_outr(x)
      ndig = ndsave
      ncall = ncall - 1

      return
      end subroutine imm2sp

      subroutine immax(ma, mb, mc)

!  mc = max(ma,mb)

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: kwrnsv
      logical, external :: imcomp

      kflag = 0
      ncall = ncall + 1
      call imi2m(0, mc)
      mc%mp(5) = 0
      if (ntrace /= 0) then
          namest(ncall) = 'IMMAX'
          call imntr_inp2(ma, mb)
      endif

      kwrnsv = kwarn
      kwarn = 0
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) then
          call imunknown(mc)
          kflag = -4
      else if (imcomp(ma, '< ', mb)) then
          call imeq(mb, mc)
      else
          call imeq(ma, mc)
      endif

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      kwarn = kwrnsv
      if (ntrace /= 0) call imntr_out1(mc)
      ncall = ncall - 1

      return
      end subroutine immax

      subroutine immin(ma, mb, mc)

!  mc = min(ma,mb)

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: kwrnsv
      logical, external :: imcomp

      kflag = 0
      ncall = ncall + 1
      call imi2m(0, mc)
      mc%mp(5) = 0
      if (ntrace /= 0) then
          namest(ncall) = 'IMMIN'
          call imntr_inp2(ma, mb)
      endif

      kwrnsv = kwarn
      kwarn = 0
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) then
          call imunknown(mc)
          kflag = -4
      else if (imcomp(ma, '> ', mb)) then
          call imeq(mb, mc)
      else
          call imeq(ma, mc)
      endif

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      kwarn = kwrnsv
      if (ntrace /= 0) call imntr_out1(mc)
      ncall = ncall - 1

      return
      end subroutine immin

      subroutine immod(ma, mb, mc)

!  mc = mod(ma,mb)

!  Use imdivr if both int(ma/mb) and mod(ma,mb) are needed.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: kl, ndsave, result_size
      type(multi), save :: mxy(2)

      result_size = min(ma%mp(2), mb%mp(2)) + 3
      if (abs(result_size) >= mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mc, result_size)

      ncall = ncall + 1
      mc%mp(5) = 0
      kflag = 0
      ndsave = ndig
      if (ntrace /= 0) then
          namest(ncall) = 'IMMOD'
          call imntr_inp2(ma, mb)
      endif

      kl = 1
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) then
          call imunknown(mc)
          kflag = -4
          kl = 0
      endif

      if (kl == 1) then
          call imdivr(ma, mb, mxy(1), mxy(2))
          call imeq(mxy(2), mc)

          if (mc%mp(2) == munkno) then
              kflag = -4
              namest(ncall) = 'IMMOD'
              call fmwarn
          endif
      endif

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      if (ntrace /= 0) call imntr_out1(mc)
      ncall = ncall - 1
      ndig = ndsave

      return
      end subroutine immod

      subroutine immodi(ma, imod, irem)

!  Internal routine to return integer irem = mod( ma , imod ).
!  abs(imod) should be less than maxint/mbase for faster mod calculation.

!  ma is a multiple precision im integer.
!  imod and irem are one-word integers.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: imod, irem
      intent (in) :: ma, imod
      intent (inout) :: irem

      type(multi), save :: t1, t2
      integer :: j, n
      real (kind(1.0d0)) :: mmod, mrem

      mmod = abs(imod)
      n = ma%mp(2)

!             If abs(imod) is more than than maxint/mbase, do it the hard way, since the
!             mbase*mrem in the fast method could be too big to represent exactly in d.p.

      if (mmod >= maxint/mbase) then
          call imi2m(abs(imod), t1)
          call immod(ma, t1, t2)
          call imm2i(t2, irem)
      else
          mrem = 0
          do j = 3, n+2
             mrem = mod( mbase*mrem + ma%mp(j) , mmod )
          enddo
          irem = mrem
      endif

      if (ma%mp(1) < 0) irem = -irem

      end subroutine immodi

      subroutine immpy(ma, mb, mc)

!  mc = ma * mb

!  This routine performs the trace printing.  immpy2 is used to do the arithmetic.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      ncall = ncall + 1
      if (ntrace /= 0) then
          namest(ncall) = 'IMMPY'
          call imntr_inp2(ma, mb)

          call immpy2(ma, mb, mc)

          call imntr_out1(mc)
      else
          call immpy2(ma, mb, mc)
      endif
      ncall = ncall - 1

      return
      end subroutine immpy

      subroutine immpy2(ma, mb, mc)

!  mc = ma * mb

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      real (kind(1.0d0)) :: mdab
      integer :: ndsave, result_size

      if (ma%mp(2) >= mexpov .or. mb%mp(2) >= mexpov) then
          result_size = 5
      else
          result_size = ma%mp(2) + mb%mp(2) + 4
      endif
      result_size = max(5, result_size)
      call fmalloc(mc, result_size)

      mc%mp(5) = 0
      kflag = 0
      ndsave = ndig

      if (ma%mp(2) <= 1 .and. mb%mp(2) <= 1) then
          mdab = ma%mp(1) * ma%mp(3) * mb%mp(1) * mb%mp(3)
          if (abs(mdab) < mbase) then
              mc%mp(2) = 1
              if (mdab == 0) mc%mp(2) = 0
              if (mdab >= 0) then
                  mc%mp(3) = mdab
                  mc%mp(1) = 1
              else
                  mc%mp(3) = -mdab
                  mc%mp(1) = -1
              endif
              mc%mp(4) = 0
              ndig = ndsave
              return
          else if (abs(mdab) < mbase*mbase) then
              mc%mp(2) = 2
              if (mdab >= 0) then
                  mc%mp(3) = aint (mdab/mbase)
                  mc%mp(4) = abs(mdab - mbase*mc%mp(3))
                  mc%mp(1) = 1
              else
                  mc%mp(3) = aint (-mdab/mbase)
                  mc%mp(4) = abs(-mdab - mbase*mc%mp(3))
                  mc%mp(1) = -1
              endif
              ndig = ndsave
              return
          endif
      endif

!             Check for special cases.

      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) then
          kflag = -4
          call imi2m2(0, mc)
          mc%mp(2) = munkno
          mc%mp(3) = 1
          ndig = ndsave
          return
      endif
      if (ma%mp(3) == 0 .or. mb%mp(3) == 0) then
          mc%mp(1) = 1
          mc%mp(2) = 0
          mc%mp(3) = 0
          mc%mp(4) = 0
          ndig = ndsave
          return
      endif
      if (ma%mp(2) == mexpov .or. mb%mp(2) == mexpov) then
          kflag = -5
          if (ma%mp(1)*mb%mp(1) < 0) then
              call imi2m2(-1, mc)
              mc%mp(2) = mexpov
              mc%mp(3) = 1
          else
              call imi2m2(1, mc)
              mc%mp(2) = mexpov
              mc%mp(3) = 1
          endif
          ndig = ndsave
          return
      endif
      if (ma%mp(2) < 0 .or. mb%mp(2) < 0) then
          kflag = -4
          namest(ncall) = 'IMMPY'
          call fmwarn
          call imi2m2(0, mc)
          mc%mp(2) = munkno
          mc%mp(3) = 1
          ndig = ndsave
          return
      endif
      if (mb%mp(2) == 1 .and. mb%mp(3) == 1 .and. mb%mp(1) == 1) then
          call imeq(ma, mc)
          if (mc%mp(2) <= 1) mc%mp(4) = 0
          ndig = ndsave
          return
      else if (mb%mp(2) == 1 .and. mb%mp(3) == 1 .and. mb%mp(1) == -1) then
          call imeq(ma, mc)
          call fmnegate(mc)
          if (mc%mp(2) <= 1) mc%mp(4) = 0
          ndig = ndsave
          return
      else if (ma%mp(2) == 1 .and. ma%mp(3) == 1 .and. ma%mp(1) == 1) then
          call imeq(mb, mc)
          if (mc%mp(2) <= 1) mc%mp(4) = 0
          ndig = ndsave
          return
      else if (ma%mp(2) == 1 .and. ma%mp(3) == 1 .and. ma%mp(1) == -1) then
          call imeq(mb, mc)
          call fmnegate(mc)
          if (mc%mp(2) <= 1) mc%mp(4) = 0
          ndig = ndsave
          return
      endif
      ndig = int(ma%mp(2) + mb%mp(2))
      if (ndig < 3) ndig = 3
      call immpy3(ma, mb)

!             Transfer to mc and fix the sign of the result.

      ndig = int(mwa%mp(2))
      if (ndig < 3) ndig = 3
      if (ma%mp(1)*mb%mp(1) < 0) then
          call fmmove(mwa, mc)
          mc%mp(1) = -1
      else
          call fmmove(mwa, mc)
          mc%mp(1) = 1
      endif

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      ndig = ndsave

      return
      end subroutine immpy2

      subroutine immpy3(ma, mb)

!  Internal multiplication of ma*mb.  The result is returned in mwa.  Both ma and mb are positive.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma, mb

      real (kind(1.0d0)) :: maxmwa, mbj, mbp1, mkt, mmax
      integer :: j, jm1, k, kb, kl, klma, klmb, n1, nd, nmethd, nzda, nzdb, result_size
      type(multi), save :: mxy(2)

      result_size = 2*(ma%mp(2)+mb%mp(2)) + 30
      if (abs(result_size) >= mexpov) result_size = 32
      result_size = max(32, result_size)
      call fmalloc(mwa, result_size)

      n1 = ndig + 1
      mwa%mp(2) = ma%mp(2) + mb%mp(2)
      mwa%mp(n1+2) = 0

!             Check for using an fft-based method if precision is very high.

      nd = max(ma%mp(2), mb%mp(2))
      if (log(7.0d0*nd/3.0d0) < log(7.0d3/3.0d0)*min(ma%mp(2), mb%mp(2))/1.0d3) then
          nzda = int(ma%mp(2))
          nzdb = int(mb%mp(2))
          do j = 2, int(mb%mp(2))
             if (mb%mp(j+2) == 0) nzdb = nzdb - 1
          enddo
          if (real(nzda)*nzdb < 65.0*nd*log(real(nd))) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          nmethd = 1
      endif
      if (nmethd == 2) then
          nd = ndig
          ndig = max(int(ma%mp(2)), int(mb%mp(2)))
          ndig = max(3, ndig)
          call imi2fm(ma, mxy(1))
          call imi2fm(mb, mxy(2))
          call fmmpyfft(mxy(1), mxy(2))
          ndig = nd
          return
      endif

!             The multiplication loop begins here.

!             maxmwa is an upper bound on the size of values in mwa divided by (mbase-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      mbp1 = mbase + 1
      mmax = intmax - mbase
      mmax = min((maxint/mbp1 - mbp1), mmax)
      mbj = mb%mp(3)
      mwa%mp(3) = 0
      klma = int(ma%mp(2))
      do k = klma+3, n1
         mwa%mp(k+1) = 0
      enddo

!             (Inner Loop)

      do k = 3, klma+2
         mwa%mp(k+1) = ma%mp(k)*mbj
      enddo
      maxmwa = mbj
      kl = klma + 1
      if (maxmwa > mmax) then
          maxmwa = 0
          kl = klma + 1
          do kb = kl+1, 3, -1
             mkt = int (mwa%mp(kb+1)/mbase)
             mwa%mp(kb) = mwa%mp(kb) + mkt
             mwa%mp(kb+1) = mwa%mp(kb+1) - mkt*mbase
          enddo
      endif
      jm1 = 2
      klmb = int(mb%mp(2))
      do j = 3, klmb+1
         mbj = mb%mp(j+1)
         if (mbj /= 0) then
             maxmwa = maxmwa + mbj
             jm1 = j - 1
             kl = klma + 1

!                       Major (Inner Loop)

             do k = j+2, j+klma+1
                mwa%mp(k) = mwa%mp(k) + ma%mp(k-jm1)*mbj
             enddo
         endif

         if (maxmwa > mmax) then
             maxmwa = 0

!                       Here normalization is only required for the range of digits currently
!                       changing in mwa.

             do kb = jm1+kl, jm1+2, -1
                mkt = int (mwa%mp(kb+1)/mbase)
                mwa%mp(kb) = mwa%mp(kb) + mkt
                mwa%mp(kb+1) = mwa%mp(kb+1) - mkt*mbase
             enddo
         endif
      enddo

!             Perform the final normalization.  (Inner Loop)

      do kb = n1+1, 4, -1
         mkt = int (mwa%mp(kb)/mbase)
         mwa%mp(kb-1) = mwa%mp(kb-1) + mkt
         mwa%mp(kb) = mwa%mp(kb) - mkt*mbase
      enddo

      return
      end subroutine immpy3

      subroutine immpy_mod(ma, mb, mc, md)

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md

      call immpym(ma, mb, mc, md)

      return
      end subroutine immpy_mod

      subroutine immpyi(ma, ival, mb)

!  mb = ma * ival

!  This routine performs the trace printing.  immpyi2 is used to do the arithmetic.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb

      ncall = ncall + 1
      if (ntrace /= 0) then
          namest(ncall) = 'IMMPYI'
          call imntr_inp1i(ma, ival)

          call immpyi2(ma, ival, mb)

          call imntr_out1(mb)
      else
          call immpyi2(ma, ival, mb)
      endif
      ncall = ncall - 1

      return
      end subroutine immpyi

      subroutine immpyi2(ma, ival, mb)

!  mb = ma * ival

!  Multiplication by a one word integer.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb

      real (kind(1.0d0)) :: mcarry, mdab, mkt, mval
      double precision :: dt
      integer :: j, ka, kb, kc, kshift, n1, ndsave, nmval, nv2, result_size
      type(multi), save :: mxy(1)

      dt = log(dble(abs(ival)+1))/dlogmb + 1
      result_size = ma%mp(2) + dt + 4
      if (abs(result_size) >= mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mb, result_size)
      result_size = 2*result_size + 30
      if (abs(result_size) >= mexpov) result_size = 32
      result_size = max(32, result_size)
      call fmalloc(mwa, result_size)
      mb%mp(5) = 0
      kflag = 0
      ndsave = ndig

!             Check for special cases.

      if (ma%mp(2) <= 1) then
          mdab = ma%mp(1) * ma%mp(3) * ival
          if (abs(mdab) < mbase) then
              mb%mp(2) = 1
              if (mdab == 0) mb%mp(2) = 0
              mb%mp(1) = 1
              if (mdab < 0) mb%mp(1) = -1
              mb%mp(3) = abs(mdab)
              mb%mp(4) = 0
              ndig = ndsave
              return
          else if (abs(mdab) < mbase*mbase) then
              mb%mp(2) = 2
              mb%mp(1) = 1
              if (mdab < 0) mb%mp(1) = -1
              mdab = abs(mdab)
              mb%mp(3) = aint (mdab/mbase)
              mb%mp(4) = mdab - mbase*mb%mp(3)
              ndig = ndsave
              return
          endif
      endif

      if (ma%mp(2) < 0) then
          kflag = -4
          namest(ncall) = 'IMMPYI'
          call fmwarn
          call imi2m2(0, mb)
          mb%mp(2) = munkno
          mb%mp(3) = 1
          ndig = ndsave
          return
      endif
      if (ma%mp(2) == munkno) then
          kflag = -4
          call imi2m2(0, mb)
          mb%mp(2) = munkno
          mb%mp(3) = 1
          ndig = ndsave
          return
      else if (ival == 0) then
          call imi2m2(0, mb)
          mb%mp(4) = 0
          ndig = ndsave
          return
      else if (ival == 1) then
          call imeq(ma, mb)
          if (mb%mp(2) <= 1) mb%mp(4) = 0
          ndig = ndsave
          return
      else if (ival == -1) then
          call imeq(ma, mb)
          call fmnegate(mb)
          if (mb%mp(2) <= 1) mb%mp(4) = 0
          ndig = ndsave
          return
      else if (ma%mp(2) == 1 .and. ma%mp(3)*ma%mp(1) == 1) then
          call imi2m2(ival, mb)
          if (mb%mp(2) <= 1) mb%mp(4) = 0
          ndig = ndsave
          return
      else if (ma%mp(2) == 1 .and. ma%mp(3)*ma%mp(1) == -1) then
          call imi2m2(ival, mb)
          call fmnegate(mb)
          if (mb%mp(2) <= 1) mb%mp(4) = 0
          ndig = ndsave
          return
      else if (ma%mp(2) == mexpov) then
          kflag = -5
          call imi2m2(1, mb)
          mb%mp(2) = mexpov
          mb%mp(3) = 1
          if ((ival > 0 .and. ma%mp(1) < 0) .or. (ival < 0 .and.ma%mp(1) > 0)) then
              mb%mp(1) = -1
          endif
          ndig = ndsave
          return
      endif

!             Work with positive numbers.

      mval = abs(ival)
      nmval = int(mval)
      nv2 = nmval - 1
      ndig = int(ma%mp(2))
      if (ndig < 3) ndig = 3
      if (abs(ma%mp(2)) >= mexpov) ndig = 3
      n1 = ndig + 1

!             To leave room for normalization, shift the product to the right kshift places in mwa.

      kshift = int((log(dble(ma%mp(3)+1)*dble(mval)))/dlogmb)

!             If ival is too big, use immpy2.

      if (kshift > ndig .or. mval > maxint/mbase .or.  &
          nmval /= abs(ival) .or. nv2 /= abs(ival)-1) then
          call imi2m2(ival, mxy(1))
          call immpy2(ma, mxy(1), mb)
          if (mb%mp(2) <= 1) mb%mp(4) = 0
          ndig = ndsave
          return
      endif

      mwa%mp(2) = ma%mp(2) + kshift
      ka = 2 + kshift
      kb = n1 + kshift
      kc = ndig + 5
      do j = kb, kc
         mwa%mp(j+1) = 0
      enddo

      mcarry = 0

!             This is the main multiplication loop.

      do j = kb, ka, -1
         mkt = ma%mp(j-kshift+1)*mval + mcarry
         mcarry = int (mkt/mbase)
         mwa%mp(j+1) = mkt - mcarry*mbase
      enddo

!             Resolve the final carry.

      do j = ka-1, 2, -1
         mkt = int (mcarry/mbase)
         mwa%mp(j+1) = mcarry - mkt*mbase
         mcarry = mkt
      enddo

!             Now the first significant digit in the product is in
!             mwa%mp(3) or mwa%mp(4).

      if (mwa%mp(3) == 0) then
          mb%mp(2) = mwa%mp(2) - 1
          do j = 3, kb
             mb%mp(j) = mwa%mp(j+1)
          enddo
      else
          mb%mp(2) = mwa%mp(2)
          do j = 2, kb
             mb%mp(j+1) = mwa%mp(j+1)
          enddo
      endif

!             Put the sign on the result.

      mb%mp(1) = 1
      if ((ival > 0 .and. ma%mp(1) < 0) .or. (ival < 0 .and.ma%mp(1) > 0)) mb%mp(1) = -1

      if (mb%mp(2) <= 1) mb%mp(4) = 0
      ndig = ndsave

      return
      end subroutine immpyi2

      subroutine immpym(ma, mb, mc, md)

!  md = ma * mb mod mc

!  This routine is slightly faster than calling immpy and immod separately.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md

      real (kind(1.0d0)) :: maxmwa, mbp1, mc1, mcarry, mdc, mdab, mkt, mlmax, mqd, mt1
      double precision :: xb, xbase, xbr, xmwa
      integer :: j, jb, jl, k, ka, kb, kl, kld, kltflg, kptmwa, n1, na1, nc1, ndsave,  &
                 nguard, nl, nmcwds, result_size
      type(multi), save :: mxy(3)
      logical, external :: imcomp

      result_size = mc%mp(2) + 4
      if (abs(result_size) >= mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(md, result_size)
      result_size = 2*(ma%mp(2)+mb%mp(2)) + 30
      if (abs(result_size) >= mexpov) result_size = 32
      result_size = max(32, result_size)
      call fmalloc(mwa, result_size)

      ncall = ncall + 1
      md%mp(5) = 0
      ndsave = ndig
      kflag = 0
      if (ntrace /= 0) then
          namest(ncall) = 'IMMPYM'
          call imntr_inp3(ma, mb, mc)
      endif

      if (ma%mp(2) <= 1) then
          kl = 1
          do while (kl == 1)
             kl = 0
             if (mb%mp(2) > 1) exit
             if (ma%mp(2) < 0 .or. mb%mp(2) < 0) exit
             mdab = ma%mp(1) * ma%mp(3) * mb%mp(1) * mb%mp(3)
             if (mc%mp(2) <= 2) then
                 if (mc%mp(3) == 0) exit
                 if (mc%mp(2) <= 1) then
                     mdc = mc%mp(1) * mc%mp(3)
                 else
                     mdc = mc%mp(1) * (mc%mp(3)*mbase + mc%mp(4))
                 endif
                 mdab = mod(mdab, mdc)
             endif
             if (abs(mdab) < mbase) then
                 md%mp(2) = 1
                 if (mdab == 0) md%mp(2) = 0
                 md%mp(1) = 1
                 if (mdab < 0) md%mp(1) = -1
                 md%mp(3) = abs(mdab)
                 md%mp(4) = 0
                 call immpym2(1, ndsave, md)
                 return
             else if (abs(mdab) < mbase*mbase) then
                 md%mp(2) = 2
                 md%mp(1) = 1
                 if (mdab < 0) md%mp(1) = -1
                 mdab = abs(mdab)
                 md%mp(3) = aint (mdab/mbase)
                 md%mp(4) = mdab - mbase*md%mp(3)
                 call immpym2(1, ndsave, md)
                 return
             endif
          enddo
      endif

!             Check for special cases.

      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno .or.  &
          mc%mp(2) == munkno) then
          kflag = -4
          call imunknown(md)
          call immpym2(0, ndsave, md)
          return
      else if (mc%mp(3) == 0 .or. ma%mp(2) < 0 .or. mb%mp(2) < 0 .or.  &
               mc%mp(2) < 0 .or. ma%mp(2) >= mexpov .or.               &
               mb%mp(2) >= mexpov .or. mc%mp(2) >= mexpov) then
          kflag = -4
          namest(ncall) = 'IMMPYM'
          call fmwarn
          call imunknown(md)
          call immpym2(0, ndsave, md)
          return
      else if (ma%mp(3) == 0 .or. mb%mp(3) == 0) then
          call imi2m(0, md)
          call immpym2(0, ndsave, md)
          return
      else if (mc%mp(2) == 1 .and. mc%mp(3) == 1) then
          call imi2m(0, md)
          call immpym2(0, ndsave, md)
          return
      else if (mb%mp(2) == 1 .and. mb%mp(3) == 1 .and. mb%mp(1) == 1) then
          call immod(ma, mc, md)
          call immpym2(1, ndsave, md)
          return
      else if (mb%mp(2) == 1 .and. mb%mp(3) == 1 .and. mb%mp(1) == -1) then
          call immod(ma, mc, md)
          call fmnegate(md)
          call immpym2(1, ndsave, md)
          return
      else if (ma%mp(2) == 1 .and. ma%mp(3) == 1 .and. ma%mp(1) == 1) then
          call immod(mb, mc, md)
          call immpym2(1, ndsave, md)
          return
      else if (ma%mp(2) == 1 .and. ma%mp(3) == 1 .and. ma%mp(1) == -1) then
          call immod(mb, mc, md)
          call fmnegate(md)
          call immpym2(1, ndsave, md)
          return
      endif

      ndig = int(ma%mp(2) + mb%mp(2))
      if (ndig < 3) ndig = 3

!             Check for using an fft-based method if precision is very high.

      if (ndig >= 1000) then
          call immpy(ma, mb, mxy(1))
          call immod(mxy(1), mc, mxy(2))
          call imeq(mxy(2), md)
          call immpym2(1, ndsave, md)
          return
      endif

      n1 = ndig + 1

!             It is faster if the second argument is the one with fewer digits.

      if (ma%mp(2) < mb%mp(2)) then
          call immpy3(mb, ma)
      else
          call immpy3(ma, mb)
      endif

!             Now do the division to find mwa mod mc.

      kltflg = 0
      if (mwa%mp(3) == 0) then
          mwa%mp(2) = mwa%mp(2) - 1
      else
          do j = n1, 2, -1
             mwa%mp(j+2) = mwa%mp(j+1)
          enddo
          mwa%mp(3) = 0
      endif
      kl = int(mc%mp(2))
      mt1 = max(ma%mp(2), mb%mp(2))
      result_size = max(mt1, mc%mp(2)) + 4
      if (abs(result_size) >= mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mxy(1), result_size)
      call fmalloc(mxy(2), result_size)
      do j = 1, kl+2
         mxy(1)%mp(j) = mc%mp(j)
      enddo
      mxy(1)%mp(1) = 1
      if (mwa%mp(2) == mxy(1)%mp(2) .and.  &
          abs(mwa%mp(4)) <= mxy(1)%mp(3)) then
          do j = 4, n1+1
             mxy(2)%mp(j) = mwa%mp(j+1)
          enddo
          mxy(2)%mp(3) = abs(mwa%mp(4))
          mxy(2)%mp(2) = mwa%mp(2)
          mxy(2)%mp(1) = 1
          if (imcomp(mxy(2), '==', mxy(1))) then
              kltflg = 2
          else if (imcomp(mxy(2), '< ', mxy(1))) then
              kltflg = 1
          endif
      endif
      if (mwa%mp(2) < mc%mp(2) .or. kltflg >= 1) then
          if (kltflg /= 2) then
              do j = 3, n1+1
                 md%mp(j) = mwa%mp(j+1)
              enddo
              md%mp(2) = mwa%mp(2)
          else
              call imi2m(0, md)
          endif
          md%mp(1) = 1
          if (ma%mp(1)*mb%mp(1) < 0) call fmnegate(md)
          call immpym2(1, ndsave, md)
          return
      endif

      ndig = int(mwa%mp(2))
      if (ndig < 3) ndig = 3

!             nguard is the number of guard digits used.

      nguard = 1
      na1 = int(mwa%mp(2)) + 1
      nc1 = int(mc%mp(2)) + 1
      mwa%mp(2) = mwa%mp(2) - mc%mp(2) + 1
      nl = na1 + nguard + 3
      do j = na1+2, nl
         mwa%mp(j+1) = 0
      enddo

!             Work only with positive numbers.

      mc1 = mc%mp(2)

!             nmcwds is the number of words of mc used to compute the estimated quotient digit mqd.

      nmcwds = 4
      if (mbase < 100) nmcwds = 7

!             xb is an approximation of mc used in estimating the quotient digits.

      xbase = dble(mbase)
      xb = 0
      jl = nmcwds
      if (jl <= nc1) then
          do j = 2, jl
             xb = xb*xbase + dble(mc%mp(j+1))
          enddo
      else
          do j = 2, jl
             if (j <= nc1) then
                 xb = xb*xbase + dble(mc%mp(j+1))
             else
                 xb = xb*xbase
             endif
          enddo
      endif
      if (jl+1 <= nc1) then
          xb = xb + dble(mc%mp(jl+2))/xbase
      endif
      xbr = 1.0d0/xb

!             mlmax determines when to normalize all of mwa.

      mbp1 = mbase + 1
      mlmax = maxint/mbp1
      mkt = intmax - mbase
      mlmax = min(mlmax, mkt)

!             maxmwa is an upper bound on the size of values in mwa divided by mbase-1.
!             It is used to determine whether normalization can be postponed.

      maxmwa = 0

!             kptmwa points to the next digit in the quotient.

      kptmwa = 2

!             This is the start of the division loop.

!             xmwa is an approximation of the active part of mwa used in estimating quotient digits.

      ka = kptmwa + 1
      kb = ka + int(mc1) - 1
      jb = ka - 2
      kld = 1
      do while (kld == 1)
         kld = 0
         kl = kptmwa + nmcwds - 1
         if (kl <= nl) then
             xmwa = ((dble(mwa%mp(kptmwa+1))*xbase + dble(mwa%mp(kptmwa+2)))*xbase  &
                    + dble(mwa%mp(kptmwa+3)))*xbase + dble(mwa%mp(kptmwa+4))
             do j = kptmwa+4, kl
                xmwa = xmwa*xbase + dble(mwa%mp(j+1))
             enddo
         else
             xmwa = dble(mwa%mp(kptmwa+1))
             do j = kptmwa+1, kl
                if (j <= nl) then
                    xmwa = xmwa*xbase + dble(mwa%mp(j+1))
                else
                    xmwa = xmwa*xbase
                endif
             enddo
         endif

!             mqd is the estimated quotient digit.

         mqd = aint(xmwa*xbr)
         if (mqd < 0) mqd = mqd - 1

         if (mqd > 0) then
             maxmwa = maxmwa + mqd
         else
             maxmwa = maxmwa - mqd
         endif

!             See if mwa must be normalized.

         ka = kptmwa + 1
         kb = ka + int(mc1) - 1
         if (maxmwa >= mlmax) then
             do j = kb, ka, -1
                if (mwa%mp(j+1) < 0) then
                    mcarry = int((-mwa%mp(j+1)-1)/mbase) + 1
                    mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
                    mwa%mp(j) = mwa%mp(j) - mcarry
                else if (mwa%mp(j+1) >= mbase) then
                    mcarry = -int(mwa%mp(j+1)/mbase)
                    mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
                    mwa%mp(j) = mwa%mp(j) - mcarry
                endif
             enddo
             xmwa = 0
             if (kl <= nl) then
                 do j = kptmwa, kl
                    xmwa = xmwa*xbase + dble(mwa%mp(j+1))
                 enddo
             else
                 do j = kptmwa, kl
                    if (j <= nl) then
                        xmwa = xmwa*xbase + dble(mwa%mp(j+1))
                    else
                        xmwa = xmwa*xbase
                    endif
                 enddo
             endif
             mqd = aint(xmwa*xbr)
             if (mqd < 0) mqd = mqd - 1
             if (mqd > 0) then
                 maxmwa = mqd
             else
                 maxmwa = -mqd
             endif
         endif

!             Subtract mqd*mc from mwa.

         jb = ka - 2
         if (mqd /= 0) then

!             Major (Inner Loop)

             do j = ka+1, kb+1
                mwa%mp(j) = mwa%mp(j) - mqd*mc%mp(j-jb)
             enddo
         endif

         mwa%mp(ka+1) = mwa%mp(ka+1) + mwa%mp(ka)*mbase
         mwa%mp(kptmwa+1) = mqd

         kptmwa = kptmwa + 1
         if (kptmwa-2 < mwa%mp(2)) kld = 1
      enddo

!             Final normalization.

      kptmwa = kptmwa - 1
      do j = kptmwa, 3, -1
         if (mwa%mp(j+1) < 0) then
             mcarry = int((-mwa%mp(j+1)-1)/mbase) + 1
             mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
             mwa%mp(j) = mwa%mp(j) - mcarry
         else if (mwa%mp(j+1) >= mbase) then
             mcarry = -int(mwa%mp(j+1)/mbase)
             mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
             mwa%mp(j) = mwa%mp(j) - mcarry
         endif
      enddo

      kld = 1
      do while (kld == 1)
         kld = 0
         do j = kptmwa+int(mc1), kptmwa+2, -1
            if (mwa%mp(j+1) < 0) then
                mcarry = int((-mwa%mp(j+1)-1)/mbase) + 1
                mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
                mwa%mp(j) = mwa%mp(j) - mcarry
            else if (mwa%mp(j+1) >= mbase) then
                mcarry = -int(mwa%mp(j+1)/mbase)
                mwa%mp(j+1) = mwa%mp(j+1) + mcarry*mbase
                mwa%mp(j) = mwa%mp(j) - mcarry
            endif
         enddo

!             Due to rounding, the remainder may not be between 0 and abs(mc) here.
!             Correct if necessary.

         if (mwa%mp(ka+1) < 0) then
             do j = ka, kb
                mwa%mp(j+1) = mwa%mp(j+1) + mc%mp(j-jb+1)
             enddo
             kld = 1
         else if (mwa%mp(ka+1) >= mbase) then
             do j = ka, kb
                mwa%mp(j+1) = mwa%mp(j+1) - mc%mp(j-jb+1)
             enddo
             kld = 1
         endif
      enddo

      if (mwa%mp(kptmwa+2) /= 0) then
          do j = 1, int(mc1)
             md%mp(j+2) = mwa%mp(j+kptmwa+1)
          enddo
          md%mp(2) = mc1
      else
          kld = 1
          do j = 1, int(mc1)
             if (mwa%mp(j+kptmwa+1) /= 0) then
                 do k = j, int(mc1)
                    md%mp(k-j+3) = mwa%mp(k+kptmwa+1)
                 enddo
                 md%mp(2) = mc1 + 1 - j
                 kld = 0
                 exit
             endif
          enddo
          if (kld == 1) then
              md%mp(2) = 0
              md%mp(3) = 0
          endif
      endif
      if (md%mp(2) <= 1) md%mp(4) = 0

      if (md%mp(2) > mxy(1)%mp(2) .or.    &
         (md%mp(2) == mxy(1)%mp(2) .and.  &
          abs(md%mp(3)) >= mxy(1)%mp(3))) then
          md%mp(1) = 1
          if (imcomp(md, '>=', mxy(1))) then
              call imsub(md, mxy(1), mxy(3))
              call imeq(mxy(3), md)
          endif
      endif

      md%mp(1) = 1
      if (ma%mp(1)*mb%mp(1) < 0) then
          call fmnegate(md)
      endif

      call immpym2(1, ndsave, md)

      return
      end subroutine immpym

      subroutine immpym2(kf, ndsave, md)

      use fmvals
      implicit none

      integer :: kf, ndsave
      type(multi) :: md
      intent (in) :: kf, ndsave
      intent (inout) :: md

      if (kf == 1) then
          if (md%mp(2) == munkno) then
              kflag = -4
              namest(ncall) = 'IMMPYM'
              call fmwarn
          endif
      endif

      if (md%mp(2) <= 1) md%mp(4) = 0
      if (ntrace /= 0) call imntr_out1(md)
      ncall = ncall - 1
      ndig = ndsave

      return
      end subroutine immpym2

      subroutine imntr_inp1(ma)

!  Print im numbers in base 10 format.  This is used for trace input from the im routines.

      use fmvals
      implicit none

      type(multi) :: ma
      intent (in) :: ma

      integer :: ndsave
      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return
      if (abs(ntrace) == 1) return

      name = namest(ncall)
      write (kw, "(' Input to ', A)") trim(name)

      ndsave = ndig
      if (ntrace < 0) then
          ndig = max(3, int(ma%mp(2)))
          if (abs(ma%mp(2)) >= mexpov) ndig = 3
          call imntrj(ma, ndig)
      endif

      if (ntrace > 0) then
          call imprnt(ma)
      endif

      ndig = ndsave

      return
      end subroutine imntr_inp1

      subroutine imntr_inp1i(ma, n)

!  Print im numbers in base 10 format.  This is used for trace input from the im routines.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: n
      intent (in) :: ma, n

      integer :: ndsave
      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return
      if (abs(ntrace) == 1) return

      name = namest(ncall)
      write (kw, "(' Input to ', A)") trim(name)

      ndsave = ndig
      if (ntrace < 0) then
          ndig = max(3, int(ma%mp(2)))
          if (abs(ma%mp(2)) >= mexpov) ndig = 3
          call imntrj(ma, ndig)
      endif

      if (ntrace > 0) then
          call imprnt(ma)
      endif

      write (kw, "(1X, I20)") n

      ndig = ndsave

      return
      end subroutine imntr_inp1i

      subroutine imntr_inp2(ma, mb)

!  Print im numbers in base 10 format.  This is used for trace input from the im routines.

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma, mb

      integer :: ndsave
      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return
      if (abs(ntrace) == 1) return

      name = namest(ncall)
      write (kw, "(' Input to ', A)") trim(name)

      ndsave = ndig
      if (ntrace < 0) then
          ndig = max(3, int(ma%mp(2)))
          if (abs(ma%mp(2)) >= mexpov) ndig = 3
          call imntrj(ma, ndig)
          ndig = max(3, int(mb%mp(2)))
          if (abs(mb%mp(2)) >= mexpov) ndig = 3
          call imntrj(mb, ndig)
      else if (ntrace > 0) then
          call imprnt(ma)
          call imprnt(mb)
      endif

      ndig = ndsave

      return
      end subroutine imntr_inp2

      subroutine imntr_inp3(ma, mb, mc)

!  Print im numbers in base 10 format.  This is used for trace input from the im routines.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb, mc

      integer :: ndsave
      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return
      if (abs(ntrace) == 1) return

      name = namest(ncall)
      write (kw, "(' Input to ', A)") trim(name)

      ndsave = ndig
      if (ntrace < 0) then
          ndig = max(3, int(ma%mp(2)))
          if (abs(ma%mp(2)) >= mexpov) ndig = 3
          call imntrj(ma, ndig)
          ndig = max(3, int(mb%mp(2)))
          if (abs(mb%mp(2)) >= mexpov) ndig = 3
          call imntrj(mb, ndig)
          ndig = max(3, int(mc%mp(2)))
          if (abs(mc%mp(2)) >= mexpov) ndig = 3
          call imntrj(mc, ndig)
      else if (ntrace > 0) then
          call imprnt(ma)
          call imprnt(mb)
          call imprnt(mc)
      endif

      ndig = ndsave

      return
      end subroutine imntr_inp3

      subroutine imntr_inpd(x)

!  Internal routine for trace input of double precision variables.

      use fmvals
      implicit none

      double precision :: x
      intent (in) :: x

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return
      if (abs(ntrace) == 1) return

      name = namest(ncall)
      write (kw, "(' Input to ', A)") trim(name)

      write (kw, "(1x, es30.20)") x

      return
      end subroutine imntr_inpd

      subroutine imntr_inpi(n)

!  Internal routine for trace input of integer variables.

      use fmvals
      implicit none

      integer :: n
      intent (in) :: n

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return
      if (abs(ntrace) == 1) return

      name = namest(ncall)
      write (kw, "(' Input to ', A)") trim(name)

      write (kw, "(1X, I20)") n

      return
      end subroutine imntr_inpi

      subroutine imntr_inpr(x)

!  Internal routine for trace input of real variables.

      use fmvals
      implicit none

      real :: x
      intent (in) :: x

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return
      if (abs(ntrace) == 1) return

      name = namest(ncall)
      write (kw, "(' Input to ', A)") trim(name)

      write (kw, "(1x, es20.10)") x

      return
      end subroutine imntr_inpr

      subroutine imntr_out1(ma)

!  Print im numbers in base 10 format.  This is used for trace output from the im routines.

      use fmvals
      implicit none

      type(multi) :: ma
      intent (in) :: ma

      integer :: ndsave
      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return
      name = namest(ncall)
      if (kflag == 0) then
          write (kw,                                                      &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10)"                                                   &
                ) name, ncall, int(mbase)
      else
          write (kw,                                                     &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'KFLAG =', I3)"                               &
                ) name, ncall, int(mbase), kflag
      endif

      ndsave = ndig
      if (ntrace < 0) then
          ndig = max(3, int(ma%mp(2)))
          if (abs(ma%mp(2)) >= mexpov) ndig = 3
          call imntrj(ma, ndig)
      else if (ntrace > 0) then
          call imprnt(ma)
      endif

      ndig = ndsave

      return
      end subroutine imntr_out1

      subroutine imntr_out1i(ma, n)

!  Print im numbers in base 10 format.  This is used for trace output from the im routines.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: n
      intent (in) :: ma, n

      integer :: ndsave
      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return
      name = namest(ncall)
      if (kflag == 0) then
          write (kw,                                                      &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10)"                                                   &
                ) name, ncall, int(mbase)
      else
          write (kw,                                                     &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'KFLAG =', I3)"                               &
                ) name, ncall, int(mbase), kflag
      endif

      ndsave = ndig
      if (ntrace < 0) then
          ndig = max(3, int(ma%mp(2)))
          if (abs(ma%mp(2)) >= mexpov) ndig = 3
          call imntrj(ma, ndig)
      else if (ntrace > 0) then
          call imprnt(ma)
      endif

      write (kw, "(1X, I20)") n

      ndig = ndsave

      return
      end subroutine imntr_out1i

      subroutine imntr_outd(x)

!  Internal routine for trace output of double precision variables.

      use fmvals
      implicit none

      double precision :: x
      intent (in) :: x

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return

      name = namest(ncall)
      if (kflag == 0) then
          write (kw, "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', I10)")  &
                 name, ncall, int(mbase)
      else
          write (kw,                                                     &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'KFLAG =', I3)"                               &
                ) name, ncall, int(mbase), kflag
      endif

      write (kw, "(1x, es30.20)") x

      return
      end subroutine imntr_outd

      subroutine imntr_outi(n)

!  Internal routine for trace output of integer variables.

      use fmvals
      implicit none

      integer :: n

      character(9) :: name
      intent (in) :: n

      if (ntrace == 0) return
      if (ncall > lvltrc) return

      name = namest(ncall)
      if (kflag == 0) then
          write (kw, "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', I10)")  &
                 name, ncall, int(mbase)
      else
          write (kw,                                                     &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'KFLAG =', I3)"                               &
                ) name, ncall, int(mbase), kflag
      endif

      write (kw, "(1X, I20)") n

      return
      end subroutine imntr_outi

      subroutine imntr_outr(x)

!  Internal routine for trace output of real variables.

      use fmvals
      implicit none

      real :: x
      intent (in) :: x

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return

      name = namest(ncall)
      if (kflag == 0) then
          write (kw, "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', I10)")  &
                 name, ncall, int(mbase)
      else
          write (kw,                                                     &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'KFLAG =', I3)"                               &
                ) name, ncall, int(mbase), kflag
      endif

      write (kw, "(1x, es20.10)") x

      return
      end subroutine imntr_outr

      subroutine imntrj(ma, nd)

!  Print trace output in internal base mbase format.  The number to be printed is in ma.

!  nd is the number of base mbase digits to be printed.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: nd
      intent (in) :: ma, nd

      character(99) :: form
      integer :: j, l, n

      l = int(log10(dble(mbase-1))) + 2
      n = (kswide-23)/l
      if (n > 10) n = 5*(n/5)
      if (nd <= n) then
          write (form, "(' (1X, I19, I', I2, ', ', I3, 'I', I2, ') ')") l+2, n-1, l
      else
          write (form,                                                                     &
                 "(' (1X, I19, I', I2, ', ', I3, 'I', I2, '/(22X, ', I3, 'I', I2, ')) ')"  &
                ) l+2, n-1, l, n, l
      endif
      if (int(ma%mp(2)) >= 2) then
          write (kw, *) '            Sign = ', int(ma%mp(1)),  &
                       '  Exponent = ', int(ma%mp(2)), '  Digits:'
          write (form, *) '(13X, ', n, 'I', l, ')'
          write (kw, form) (int(ma%mp(j)), j=3, nd+2)
      else
          write (kw, *) '            Sign = ', int(ma%mp(1)),  &
                       '  Exponent = ', int(ma%mp(2)), '  Digits:'
          write (form, *) '(13X, ', n, 'I', l, ')'
          write (kw, form) int(ma%mp(3)), (0, j=4, nd+2)
      endif

      return
      end subroutine imntrj

      subroutine imout(ma, line, lb)

!  Convert an integer multiple precision number to a character array for output.

!  ma   is an im number to be converted to an a1 character array in base 10 format.
!  line is the character(1) array in which the result is returned.
!  lb   is the length of line.

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: lb
      character :: line(lb)
      intent (in) :: ma, lb
      intent (inout) :: line

      integer :: jf1sav, jf2sav, ndsave

      ncall = ncall + 1
      kflag = 0
      ndsave = ndig
      namest(ncall) = 'IMOUT'

      ndsave = ndig
      jf1sav = jform1
      jf2sav = jform2
      jform1 = 2
      jform2 = 0
      ndig = max(3, int(ma%mp(2)))
      if (abs(ma%mp(2)) >= mexpov) ndig = 3
      call fmout(ma, line, lb)

      ndig = ndsave
      jform1 = jf1sav
      jform2 = jf2sav
      ncall = ncall - 1

      return
      end subroutine imout

      subroutine impack(ma, mp)

!  ma is packed two base mbase digits per word and returned in mp.

      use fmvals
      implicit none

      type(multi) :: ma, mp
      intent (in) :: ma
      intent (inout) :: mp

      integer :: j, kp, kma1, result_size

      result_size = ma%mp(2)/2 + 4
      if (abs(result_size) >= mexpov/2) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mp, result_size)

      mp%mp(5) = 0
      kma1 = int(ma%mp(2))
      if (kma1 <= 2) kma1 = 2
      if (abs(kma1) >= mexpov) kma1 = 2
      kp = 2
      mp%mp(2) = ma%mp(2)
      mp%mp(3) = abs(ma%mp(3))*mbase + ma%mp(4)
      mp%mp(1) = 1
      if (ma%mp(1) < 0) mp%mp(1) = -1
      if (kma1 >= 4) then
          do j = 4, kma1, 2
             kp = kp + 1
             mp%mp(kp+1) = ma%mp(j+1)*mbase + ma%mp(j+2)
          enddo
      endif
      if (mod(kma1, 2) == 1) mp%mp(kp+2) = ma%mp(kma1+2)*mbase

      return
      end subroutine impack

      subroutine impmod(ma, mb, mc, md)

!  md = mod(ma**mb,mc)

!  The binary multiplication method used requires an average of 1.5 * log2(mb) operations.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md

      integer :: irem, kl, kwrnsv, ndsave, result_size
      type(multi), save :: mxy(6)

      result_size = mc%mp(2) + 3
      if (abs(result_size) >= mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(md, result_size)
      kflag = 0
      ncall = ncall + 1
      md%mp(5) = 0
      ndsave = ndig
      if (ntrace /= 0) then
          namest(ncall) = 'IMPMOD'
          call imntr_inp3(ma, mb, mc)
      endif

!             Check for special cases.

      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno .or.        &
          mc%mp(2) == munkno .or. ma%mp(2) == mexpov .or.        &
          mb%mp(2) == mexpov .or. mc%mp(2) == mexpov .or.        &
          ma%mp(2) < 0 .or. mb%mp(2) < 0 .or. mc%mp(2) < 0 .or.  &
          (mb%mp(1)*mb%mp(3) <= 0 .and. ma%mp(3) == 0) .or.      &
          mc%mp(3) == 0) then
          kflag = -4
          if (ma%mp(2) /= munkno .and. mb%mp(2) /= munkno .and.  &
              mc%mp(2) /=munkno) then
              namest(ncall) = 'IMPMOD'
              call fmwarn
          endif
          call imunknown(md)
          if (ntrace /= 0) call imntr_out1(md)
          ndig = ndsave
          ncall = ncall - 1
          return
      endif

      if (mb%mp(3) == 0) then
          call imi2m(1, md)
          if (ntrace /= 0) call imntr_out1(md)
          ndig = ndsave
          ncall = ncall - 1
          return
      endif

      if (mb%mp(2) == 1 .and. abs(mb%mp(3)) == 1) then
          kwrnsv = kwarn
          kwarn = 0
          if (mb%mp(1) == 1) then
              call immod(ma, mc, mxy(6))
          else
              call imi2m(1, mxy(2))
              call imdivr(mxy(2), ma, mxy(1), mxy(3))
              call immod(mxy(1), mc, mxy(6))
          endif
          call imeq(mxy(6), md)
          if (ntrace /= 0) call imntr_out1(md)
          ndig = ndsave
          ncall = ncall - 1
          kwarn = kwrnsv
          return
      endif

      if (ma%mp(3) == 0) then
          call imi2m(0, md)
          if (ntrace /= 0) call imntr_out1(md)
          ndig = ndsave
          ncall = ncall - 1
          return
      endif

!             Initialize.

      kwrnsv = kwarn
      kwarn = 0
      call imabs(mb, mxy(3))
      call imdivr(ma, mc, mxy(1), mxy(2))
      call imeq(mc, mxy(1))
      call imdvir(mxy(3), 2, mxy(6), irem)
      if (irem == 0) then
          call imi2m(1, mxy(6))
      else
          call imeq(mxy(2), mxy(6))
      endif
      call imdvir(mxy(3), 2, mxy(4), irem)
      call imeq(mxy(4), mxy(3))

!             This is the multiplication loop.

      kl = 1
      do while (kl == 1)
         kl = 0
         call imdvir(mxy(3), 2, mxy(4), irem)
         call imeq(mxy(4), mxy(3))
         call immpym(mxy(2), mxy(2), mxy(1), mxy(5))
         call imeq(mxy(5), mxy(2))
         if (irem == 1) then
             call immpym(mxy(2), mxy(6), mxy(1), mxy(5))
             call imeq(mxy(5), mxy(6))
         endif
         if (mxy(3)%mp(3) > 0 .and. mxy(6)%mp(3) /= 0) kl = 1
      enddo

      if (mb%mp(1) < 0) then
          call imi2m(1, mxy(2))
          krem = 0
          call imdivr(mxy(2), mxy(6), mxy(4), mxy(3))
          krem = 1
          call imeq(mxy(4), mxy(6))
      endif
      kwarn = kwrnsv
      call imeq(mxy(6), md)
      if (kflag < 0) then
          namest(ncall) = 'IMPMOD'
          call fmwarn
      endif
      if (md%mp(2) <= 1) md%mp(4) = 0
      if (ntrace /= 0) call imntr_out1(md)
      ndig = ndsave
      ncall = ncall - 1

      return
      end subroutine impmod

      subroutine impower(ma, mb, mc)

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      call impwr(ma, mb, mc)

      return
      end subroutine impower

      subroutine impower_mod(ma, mb, mc, md)

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md

      call impmod(ma, mb, mc, md)

      return
      end subroutine impower_mod

      subroutine imprint(ma)

      use fmvals
      implicit none

      type(multi) :: ma
      intent (in) :: ma

      call imprnt(ma)

      return
      end subroutine imprint

      subroutine imprnt(ma)

!  Print ma in base 10 format.

      use fmvals
      implicit none

      type(multi) :: ma
      intent (in) :: ma

      integer :: jf1sav, jf2sav, ndsave

      ndsave = ndig
      jf1sav = jform1
      jf2sav = jform2
      jform1 = 2
      jform2 = 0
      ndig = max(3, int(ma%mp(2)))
      if (abs(ma%mp(2)) >= mexpov) ndig = 3
      call fmprnt(ma)
      jform1 = jf1sav
      jform2 = jf2sav
      ndig = ndsave

      return
      end subroutine imprnt

      subroutine impwr(ma, mb, mc)

!  mc = ma**mb

!  The binary multiplication method used requires an average of 1.5 * log2(mb) multiplications.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      double precision :: da, db
      integer :: irem, iremb, jsign, kl, kovfl, kwrnsv, result_size
      type(multi), save :: mxy(5)

      kovfl = 0
      if ((ma%mp(2) == 1 .and. ma%mp(3) == 1) .or.  &
          ma%mp(3) == 0 .or. mb%mp(3) == 0) then
          result_size = 5
      else
          result_size = 5
          kovfl = 1
          kwrnsv = kwarn
          kwarn = 0
          call imm2dp(ma, da)
          if (kflag == 0) then
              call imm2dp(mb, db)
              if (kflag == 0) then
                  result_size = abs(db)*log(abs(da)+1)/dlogmb + 5
                  kovfl = 0
                  if (abs(result_size) >= mexpov) then
                      result_size = 5
                      kovfl = 1
                  endif
              endif
          else
              call imm2dp(mb, db)
              if (kflag == 0) then
                  result_size = min(huge(1)/10.0d0, abs(db)*(abs(ma%mp(2))+1) + 5)
                  kovfl = 0
                  if (abs(result_size) >= mexpov .or. abs(ma%mp(2)) >= mexpov) then
                      result_size = 5
                      kovfl = 1
                  endif
              endif
          endif
          kwarn = kwrnsv
      endif
      if (mb%mp(1) < 0 .and. ma%mp(3) /= 0) then
          result_size = 5
      endif
      result_size = max(5, result_size)
      if (abs(result_size) >= mexpov) result_size = 5
      call fmalloc(mc, result_size)

      kflag = 0
      ncall = ncall + 1
      mc%mp(5) = 0
      if (ntrace /= 0) then
          namest(ncall) = 'IMPWR'
          call imntr_inp2(ma, mb)
      endif
      kwrnsv = kwarn

!             Check for special cases.

      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno .or.          &
          ma%mp(2) < 0 .or. mb%mp(2) < 0 .or. ((mb%mp(1) < 0 .or.  &
          mb%mp(3) == 0) .and. ma%mp(3) == 0)) then
          kflag = -4
          if (ma%mp(2) /= munkno .and. mb%mp(2) /= munkno) then
              kwarn = kwrnsv
              namest(ncall) = 'IMPWR'
              call fmwarn
          endif
          call imunknown(mc)
          call impwr2(mc, kwrnsv)
          return
      endif

      if (mb%mp(3) == 0) then
          call imi2m(1, mc)
          call impwr2(mc, kwrnsv)
          return
      endif

      if (ma%mp(2) == 1 .and. ma%mp(3) == 1) then
          kwarn = 0
          if (ma%mp(1) == 1) then
              call imi2m(1, mc)
          else
              call imi2m(2, mxy(1))
              call imdivr(mb, mxy(1), mxy(4), mxy(2))
              call imeq(mxy(4), mxy(1))
              if (mxy(2)%mp(2) == munkno) then
                  kflag = -4
                  kwarn = kwrnsv
                  namest(ncall) = 'IMPWR'
                  call fmwarn
                  call imunknown(mc)
              else if (mxy(2)%mp(3) == 0) then
                  call imi2m(1, mc)
              else
                  call imi2m(-1, mc)
              endif
          endif
          call impwr2(mc, kwrnsv)
          return
      endif

      if (mb%mp(2) == 1 .and. mb%mp(3) == 1) then
          kwarn = 0
          if (mb%mp(1) == 1) then
              call imeq(ma, mc)
          else
              call imi2m(1, mxy(1))
              krem = 0
              call imdivr(mxy(1), ma, mxy(3), mxy(2))
              call imeq(mxy(3), mc)
              krem = 1
          endif
          call impwr2(mc, kwrnsv)
          return
      endif

      if (ma%mp(3) == 0) then
          call imi2m(0, mc)
          call impwr2(mc, kwrnsv)
          return
      endif

      if (mb%mp(1) < 0) then
          call imi2m(0, mc)
          call impwr2(mc, kwrnsv)
          return
      endif

      if (mb%mp(2) == mexpov) then
          if (mb%mp(1) < 0) then
              call imi2m(0, mc)
          else if (ma%mp(1) > 0) then
              call imst2m('OVERFLOW', mc)
              kflag = -5
          else
              kflag = -4
              kwarn = kwrnsv
              namest(ncall) = 'IMPWR'
              call fmwarn
              call imunknown(mc)
          endif
          call impwr2(mc, kwrnsv)
          return
      endif

      if (ma%mp(2) == mexpov) then
          jsign = 1
          if (ma%mp(1) < 0) jsign = -1
          if (mb%mp(1) > 0) then
              call imdvir(mb, 2, mxy(1), irem)
              call imst2m('OVERFLOW', mc)
              mc%mp(1) = jsign**irem
              kflag = -5
          else
              call imi2m(0, mc)
          endif
          call impwr2(mc, kwrnsv)
          return
      endif

      if (kovfl == 1) then
          if (mb%mp(1) <= 0) then
              call imi2m(0, mc)
          else if (ma%mp(1) >= 0) then
              call imst2m('OVERFLOW', mc)
              kflag = -5
              kwarn = kwrnsv
              namest(ncall) = 'IMPWR'
              call fmwarn
          else
              call imdvir(mb, 2, mxy(1), irem)
              call imst2m('OVERFLOW', mc)
              mc%mp(1) = (-1)**irem
              kflag = -5
              kwarn = kwrnsv
              namest(ncall) = 'IMPWR'
              call fmwarn
          endif
          call impwr2(mc, kwrnsv)
          return
      endif

!             Initialize.

      call fmalloc(mxy(1), result_size)
      call fmalloc(mxy(3), result_size)
      call fmalloc(mxy(5), result_size)
      kwarn = 0
      call imabs(mb, mxy(2))

      call imeq(ma, mxy(1))

      call imdvir(mb, 2, mxy(4), iremb)
      call imeq(mxy(4), mc)
      if (iremb == 0) then
          call imi2m(1, mc)
      else
          call imeq(mxy(1), mc)
      endif
      call imdvir(mxy(2), 2, mxy(4), irem)
      call imeq(mxy(4), mxy(2))

!             This is the multiplication loop.

      kl = 1
      do while (kl == 1)
         kl = 0
         call imdvir(mxy(2), 2, mxy(4), irem)
         call imeq(mxy(4), mxy(2))
         call imsqr(mxy(1), mxy(5))
         call imeq(mxy(5), mxy(1))
         if (irem == 1) then
             call immpy(mxy(1), mc, mxy(3))
             call imeq(mxy(3), mc)
         endif
         if (mxy(1)%mp(2) == mexpov) then
             call imeq(mxy(1), mc)
             if (ma%mp(1) < 0 .and. iremb == 1) mc%mp(1) = -1
             exit
         endif
         if (mxy(2)%mp(3) > 0) kl = 1
      enddo

      if (mb%mp(1) < 0) then
          call imi2m(1, mxy(1))
          krem = 0
          call imdivr(mxy(1), mc, mxy(4), mxy(2))
          krem = 1
          call imeq(mxy(4), mc)
      endif

      if (mc%mp(2) >= mexpov) then
          if (ncall == 1 .or. mc%mp(2) >= mexpov) then
              if (mc%mp(1) > 0) then
                  call imst2m('OVERFLOW', mc)
              else
                  call imst2m('-OVERFLOW', mc)
              endif
              kflag = -5
              kwarn = kwrnsv
              namest(ncall) = 'IMPWR'
              call fmwarn
          endif
      endif

      call impwr2(mc, kwrnsv)

      return
      end subroutine impwr

      subroutine impwr2(mc, kwrnsv)

      use fmvals
      implicit none

      type(multi) :: mc
      integer :: kwrnsv
      intent (in) :: kwrnsv
      intent (inout) :: mc

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      kwarn = kwrnsv
      if (ntrace /= 0) then
          namest(ncall) = 'IMPWR'
          call imntr_out1(mc)
      endif
      ncall = ncall - 1

      return
      end subroutine impwr2

      subroutine imread(kread, ma)

!  Read ma on unit kread.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  Only one number is allowed on the line(s).

      use fmvals
      implicit none

      type(multi) :: ma
      integer :: kread
      intent (in) :: kread
      intent (inout) :: ma

      character :: line(132)
      integer :: j, jstat, k, kamper, l2, lb

      ncall = ncall + 1
      call imi2m(0, ma)
      ma%mp(5) = 0
      namest(ncall) = 'IMREAD'
      lb = 0
      kamper = 0

      do
         read (kread, "(132A1)", iostat=jstat) line
         if (jstat /= 0) then
             kflag = -4
             call fmwarn
             call fmunknown(ma)
             ncall = ncall - 1
             return
         endif

!             Scan the line and look for '&'

         do j = 1, 132
            if (line(j) == '&') then
                kamper = 1
                exit
            endif
            if (line(j) /= ' ') then
                lb = lb + 1
                if (lb > lmbuff) then

!                If cmbuff runs out of space, try to re-allocate it with a bigger size.

                    if (lmbuff > 0) then
                        allocate(move_cmbuff(lmbuff), stat=k)
                        if (k /= 0) then
                            call fmdefine_error
                        endif
                        do k = 1, lmbuff
                           move_cmbuff(k) = cmbuff(k)
                        enddo
                        deallocate(cmbuff)
                        l2 = max(10000, 2*lmbuff)
                        allocate(cmbuff(l2), stat=k)
                        if (k /= 0) then
                            call fmdefine_error
                        endif
                        do k = 1, l2
                           cmbuff(k) = ' '
                        enddo
                        do k = 1, lmbuff
                           cmbuff(k) = move_cmbuff(k)
                        enddo
                        deallocate(move_cmbuff)
                        lmbuff = l2
                    else
                        allocate(cmbuff(10000), stat=k)
                        if (k /= 0) then
                            call fmdefine_error
                        endif
                        lmbuff = 10000
                    endif
                endif
                cmbuff(lb) = line(j)
            endif
         enddo
         if (kamper == 0) exit
         kamper = 0
      enddo

      call iminp(cmbuff, ma, 1, lb)
      ncall = ncall - 1

      return
      end subroutine imread

      subroutine imsign(ma, mb, mc)

!  mc = sign(ma,mb)

!  mc is set to abs(ma) if mb is positive or zero, or -abs(ma) if mb is negative.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc

      integer :: kwrnsv, ndsave, result_size
      intent (in) :: ma, mb
      intent (inout) :: mc

      result_size = ma%mp(2) + 3
      if (abs(result_size) >= mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mc, result_size)

      kflag = 0
      ncall = ncall + 1
      mc%mp(5) = 0
      ndsave = ndig
      if (ntrace /= 0) then
          namest(ncall) = 'IMSIGN'
          call imntr_inp2(ma, mb)
      endif

      ndig = int(ma%mp(2))
      if (ndig < 3) ndig = 3
      if (abs(ma%mp(2)) >= mexpov) ndig = 3
      kwrnsv = kwarn
      kwarn = 0
      if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) then
          call imunknown(mc)
          kflag = -4
      else if (ma%mp(2) < 0 .or. mb%mp(2) < 0) then
          kflag = -4
          namest(ncall) = 'IMSIGN'
          call fmwarn
          call imunknown(mc)
      else if (mb%mp(1) >= 0) then
          call imeq(ma, mc)
          mc%mp(1) = 1
      else
          call imeq(ma, mc)
          if (mc%mp(2) /= munkno .and. mc%mp(3) /= 0) mc%mp(1) = -1
      endif

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      kwarn = kwrnsv
      if (ntrace /= 0) call imntr_out1(mc)
      ncall = ncall - 1
      ndig = ndsave

      return
      end subroutine imsign

      subroutine imsp2m(x, ma)

!  ma = x

!  Convert the integer part of a single precision to an im number.

      use fmvals
      implicit none

      real :: x
      type(multi) :: ma
      intent (in) :: x
      intent (inout) :: ma

      integer :: ndsave
      type(multi), save :: mxy

      ncall = ncall + 1
      kflag = 0
      namest(ncall) = 'IMSP2M'
      if (ntrace /= 0) call imntr_inpr(x)

      ndsave = ndig
      if (abs(x) < 1) then
          call imi2m(0, ma)
      else
          ndig = max(3, int(log(abs(x))/log(dble(mbase)))+2)
          call fmsp2m(x, mxy)
          call imfm2i(mxy, ma)
      endif

      if (ntrace /= 0) call imntr_out1(ma)
      ndig = ndsave
      ncall = ncall - 1

      return
      end subroutine imsp2m

      subroutine imsqr(ma, mb)

!  mb = ma**2

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mdab
      integer :: ndsave, result_size

      result_size = 2*ma%mp(2) + 4
      if (abs(result_size) >= mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mb, result_size)

      ncall = ncall + 1
      mb%mp(5) = 0
      kflag = 0
      ndsave = ndig
      if (ntrace /= 0) then
          namest(ncall) = 'IMSQR'
          call imntr_inp1(ma)
      endif

      if (ma%mp(2) <= 1) then
          if (ma%mp(2) >= 0) then
              mdab = ma%mp(3) * ma%mp(3)
              if (abs(mdab) < mbase) then
                  mb%mp(2) = 1
                  if (mdab == 0) mb%mp(2) = 0
                  mb%mp(3) = mdab
                  mb%mp(4) = 0
                  call imsqr3(mb, ndsave)
                  return
              else if (abs(mdab) < mbase*mbase) then
                  mb%mp(2) = 2
                  mb%mp(3) = aint (mdab/mbase)
                  mb%mp(4) = mdab - mbase*mb%mp(3)
                  call imsqr3(mb, ndsave)
                  return
              endif
          endif
      endif

      if (ma%mp(2) == munkno) then
          kflag = -4
          call imunknown(mb)
          call imsqr3(mb, ndsave)
          return
      endif
      if (ma%mp(3) == 0) then
          mb%mp(1) = 1
          mb%mp(2) = 0
          mb%mp(3) = 0
          mb%mp(4) = 0
          call imsqr3(mb, ndsave)
          return
      endif
      if (ma%mp(2) == mexpov) then
          kflag = -5
          call imst2m('OVERFLOW', mb)
          call imsqr3(mb, ndsave)
          return
      endif
      if (ma%mp(2) == 1 .and. abs(ma%mp(3)) == 1) then
          call imi2m(1, mb)
          call imsqr3(mb, ndsave)
          return
      else if (ma%mp(2) < 0) then
          kflag = -4
          namest(ncall) = 'IMSQR'
          call fmwarn
          call imunknown(mb)
          call imsqr3(mb, ndsave)
          return
      endif

      ndig = int(ma%mp(2) + ma%mp(2))
      if (ndig < 3) ndig = 3

      call imsqr2(ma, mb)

      call imsqr3(mb, ndsave)

      return
      end subroutine imsqr

      subroutine imsqr2(ma, mb)

!  mb = ma**2

      use fmvals
      implicit none

      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: maxmax, maxmwa, mbj, mbkj, mbnorm, mbp1, mk, mka, mkt, mmax, mt
      integer :: j, jm1, k, kb, ki, kj, kl, knz, kovun, kwa, l, n1, nd, nmethd, nzda, result_size
      type(multi), save :: mxy(2)

      result_size = 2*ma%mp(2) + 30
      if (abs(result_size) >= mexpov) result_size = 32
      result_size = max(32, result_size)
      call fmalloc(mwa, result_size)

!             ksqr is used to tell fmmpyfft that only one input fft is needed.

      ksqr = 1
      if (mblogs /= mbase) call fmcons
      if (mbase*mbase <= mxbase/(4*mbase)) then
          kovun = 0
          if (ma%mp(2) == mexpov .or. ma%mp(2) == mexpun) kovun = 1
          if (ma%mp(2) == munkno) kovun = 2
          ncall = ncall + 1
          call immpy(ma, ma, mb)
          ncall = ncall - 1
          if ((kflag < 0 .and. kovun == 0) .or. (kflag == -4 .and. kovun == 1)) then
              namest(ncall) = 'IMSQR'
              call fmwarn
          endif
          call imsqr4(mb, 0)
          return
      else if (ma%mp(3) == 0) then
          call imeq(ma, mb)
          call imsqr4(mb, 0)
          return
      endif
      kflag = 0
      maxmax = 0
      n1 = int(ma%mp(2)) + 1
      mwa%mp(2) = ma%mp(2) + ma%mp(2)

!             Check for using an fft-based method if precision is very high.

      nd = 1000
      if (ndig >= nd) then
          nzda = 0
          do j = 2, int(ma%mp(2))
             if (ma%mp(j+2) == 0) nzda = nzda + 1
          enddo
          if (ma%mp(2)-nzda < 50 .or. real(nzda)/ma%mp(2) > 0.8) then
              nmethd = 1
          else
              nmethd = 2
          endif
      else
          nmethd = 1
      endif
      if (nmethd == 2) then
          nd = ndig
          ndig = int(ma%mp(2))
          if (ndig < 3) ndig = 3
          if (abs(ma%mp(2)) >= mexpov) ndig = 3
          call imi2fm(ma, mxy(1))
          call imi2fm(ma, mxy(2))
          call fmmpyfft(mxy(1), mxy(2))
          ndig = nd
          call imsqr4(mb, 1)
          return
      endif

      l = n1 + int(ma%mp(2))
      mwa%mp(l+2) = 0

!             The multiplication loop begins here.

!             mbnorm is the minimum number of digits that can be multiplied before normalization
!                    is required.
!             maxmwa is an upper bound on the size of values in mwa divided by (mbase-1).  It is
!                    used to determine whether to normalize before the next digit is multiplied.

      mbp1 = mbase + 1
      mbnorm = (maxint/(mbp1*mbp1))
      mmax = intmax - mbase
      mmax = min((maxint/mbp1 - mbp1), mmax)
      knz = n1
      if (mbnorm >= 2) then
          mbj = ma%mp(3)

!             Count the trailing zeros in ma.

          if (ma%mp(n1+1) /= 0) then
              knz = n1
          else
              do j = int(ma%mp(2)), 2, -1
                 if (ma%mp(j+1) /= 0) then
                     knz = j
                     exit
                 endif
              enddo
          endif

          mwa%mp(3) = 0
          mwa%mp(4) = 0
          do k = n1+1, l
             mwa%mp(k+1) = 0
          enddo

!             (Inner Loop)

          do k = 4, n1+1
             mwa%mp(k+1) = ma%mp(k)*mbj
          enddo
          maxmwa = mbj
          do j = 3, n1
             mbj = ma%mp(j+1)
             if (mbj /= 0) then
                 maxmwa = maxmwa + mbj
                 jm1 = j - 1
                 kl = min(knz, l-jm1)

!                       Major (Inner Loop)

                 do k = 2*j+1, jm1+kl+1
                    mwa%mp(k) = mwa%mp(k) + ma%mp(k-jm1)*mbj
                 enddo
             endif

             if (maxmwa > mmax) then
                 maxmax = max(maxmax, maxmwa)
                 maxmwa = 0
                 jm1 = j - 1
                 kl = min(knz, l-jm1)

!                       Normalization is only required for the range of digits currently
!                       changing in mwa.

                 do kb = jm1+kl, 2*j, -1
                    mkt = int (mwa%mp(kb+1)/mbase)
                    mwa%mp(kb) = mwa%mp(kb) + mkt
                    mwa%mp(kb+1) = mwa%mp(kb+1) - mkt*mbase
                 enddo
             endif
          enddo

!             Double mwa, add the square terms, and perform the final normalization.  (Inner Loop)

          if (2*max(maxmax, maxmwa)+mbase > mmax) then
              do kb = l+1, 5, -1
                 mkt = int (mwa%mp(kb)/mbase)
                 mwa%mp(kb-1) = mwa%mp(kb-1) + mkt
                 mwa%mp(kb) = mwa%mp(kb) - mkt*mbase
              enddo
          endif

          do j = 4, l, 2
             if (j/2 <= n1) then
                 mka = ma%mp(1+j/2)
                 mwa%mp(j) = 2*mwa%mp(j) + mka*mka
                 mwa%mp(j+1) = 2*mwa%mp(j+1)
             else
                 mwa%mp(j) = 2*mwa%mp(j)
                 mwa%mp(j+1) = 2*mwa%mp(j+1)
             endif
          enddo
          if (mod(l, 2) == 1) then
              if ((l+1)/2 <= n1) then
                  mka = ma%mp(1+(l+1)/2)
                  mwa%mp(l+1) = 2*mwa%mp(l+1) + mka*mka
              else
                  mwa%mp(l+1) = 2*mwa%mp(l+1)
              endif
          endif

          do kb = l+1, 4, -1
             mkt = int (mwa%mp(kb)/mbase)
             mwa%mp(kb-1) = mwa%mp(kb-1) + mkt
             mwa%mp(kb) = mwa%mp(kb) - mkt*mbase
          enddo

      else

!             If normalization must be done for each digit, combine the two loops and normalize
!             as the digits are multiplied.

          do j = 2, l
             mwa%mp(j+1) = 0
          enddo
          kj = ma%mp(2) + 2
          do j = 2, n1
             kj = kj - 1
             mbkj = ma%mp(kj+1)
             if (mbkj == 0) cycle
             kl = l - kj + 1
             if (kl > n1) kl = n1
             ki = kl + 2
             kwa = kl+ kj + 1
             mk = 0
             do k = 2, kl
                mt = ma%mp(ki-k+1)*mbkj + mwa%mp(kwa-k+1) + mk
                mk = int (mt/mbase)
                mwa%mp(kwa-k+1) = mt - mbase*mk
             enddo
             mwa%mp(kwa-kl) = mk
          enddo

      endif

!             The multiplication is complete.

      call imsqr4(mb, 1)

      return
      end subroutine imsqr2

      subroutine imsqr3(mb, ndsave)

      use fmvals
      implicit none

      type(multi) :: mb
      integer :: ndsave
      intent (in) :: ndsave
      intent (inout) :: mb

      if (mb%mp(2) <= 1) mb%mp(4) = 0
      mb%mp(1) = 1
      if (ntrace /= 0) call imntr_out1(mb)
      ncall = ncall - 1
      ndig = ndsave

      return
      end subroutine imsqr3

      subroutine imsqr4(mb, kf)

      use fmvals
      implicit none

      type(multi) :: mb
      integer :: kf
      intent (in) :: kf
      intent (inout) :: mb

      if (kf == 1) then
          ndig = int(mwa%mp(2))
          if (ndig < 3) ndig = 3
          call fmmove(mwa, mb)

          if (kflag < 0) then
              namest(ncall) = 'IMSQR'
              call fmwarn
          endif
      endif

      mb%mp(1) = 1
      ksqr = 0

      return
      end subroutine imsqr4

      subroutine imst2m(string, ma)

!  ma = string

!  Convert a character string to im format.

      use fmvals
      implicit none

      character(*) :: string
      type(multi) :: ma
      intent (in) :: string
      intent (inout) :: ma

      integer :: j, lb, kfsave

      if (mblogs /= mbase) call fmcons
      ncall = ncall + 1
      namest(ncall) = 'IMST2M'
      lb = len(string)
      if (lb > lmbuff) then
          if (lmbuff > 0) deallocate(cmbuff)
          allocate(cmbuff(lb), stat=j)
          if (j /= 0) then
              call fmdefine_error
          endif
          lmbuff = lb
      endif
      kfsave = kflag

      do j = 1, lb
         cmbuff(j) = string(j:j)
      enddo

      call iminp(cmbuff, ma, 1, lb)

      if (ma%mp(2) <= 1) ma%mp(4) = 0
      if (kfsave /= 0) kflag = kfsave
      ncall = ncall - 1

      return
      end subroutine imst2m

      subroutine imsub(ma, mb, mc)

!  mc = ma - mb

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc

      real (kind(1.0d0)) :: mda, mdab, mdb
      integer :: ndsave, result_size

      result_size = max(ma%mp(2), mb%mp(2)) + 4
      if (abs(result_size) >= mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(mc, result_size)

      ncall = ncall + 1
      mc%mp(5) = 0
      kflag = 0
      ndsave = ndig
      if (ntrace /= 0) then
          namest(ncall) = 'IMSUB'
          call imntr_inp2(ma, mb)
      endif

      if (ma%mp(2) <= 2) then
          if (.not. (mb%mp(2) > 2 .or. ma%mp(2) < 0 .or. mb%mp(2) < 0)) then
              if (ma%mp(2) <= 1) then
                  mda = ma%mp(1) * ma%mp(3)
              else
                  mda = ma%mp(1) * (ma%mp(3)*mbase + ma%mp(4))
              endif
              if (mb%mp(2) <= 1) then
                  mdb = mb%mp(1) * mb%mp(3)
              else
                  mdb = mb%mp(1) * (mb%mp(3)*mbase + mb%mp(4))
              endif
              mdab = mda - mdb
              if (abs(mdab) < mbase) then
                  mc%mp(2) = 1
                  if (mdab == 0) mc%mp(2) = 0
                  mc%mp(1) = 1
                  if (mdab < 0) mc%mp(1) = -1
                  mc%mp(3) = abs(mdab)
                  mc%mp(4) = 0
                  if (mda == 0 .or. mdb == 0) kflag = 1
                  call imsub2(mc, ndsave)
                  return
              else if (abs(mdab) < mbase*mbase) then
                  mc%mp(2) = 2
                  mc%mp(1) = 1
                  if (mdab < 0) mc%mp(1) = -1
                  mdab = abs(mdab)
                  mc%mp(3) = aint (mdab/mbase)
                  mc%mp(4) = mdab - mbase*mc%mp(3)
                  if (mda == 0 .or. mdb == 0) kflag = 1
                  call imsub2(mc, ndsave)
                  return
              endif
          endif
      endif

      if (ma%mp(2) < 0 .or. mb%mp(2) < 0 .or.  &
          ma%mp(2) >= mexpov .or. mb%mp(2) >= mexpov) then
          if (ma%mp(2) == munkno .or. mb%mp(2) == munkno) then
              call imunknown(mc)
              kflag = -4
              call imsub2(mc, ndsave)
              return
          endif
          if (ma%mp(2) == mexpov) then
              if (ma%mp(1) == -mb%mp(1) .or. mb%mp(3) == 0) then
                  mc%mp(1) = ma%mp(1)
                  mc%mp(2) = ma%mp(2)
                  mc%mp(3) = ma%mp(3)
                  mc%mp(4) = ma%mp(4)
                  kflag = -5
                  call imsub2(mc, ndsave)
                  return
              else
                  kflag = -4
                  namest(ncall) = 'IMSUB'
                  call fmwarn
                  call imunknown(mc)
                  call imsub2(mc, ndsave)
                  return
              endif
          endif
          if (mb%mp(2) == mexpov) then
              if (-mb%mp(1) == ma%mp(1) .or. ma%mp(3) == 0) then
                  mc%mp(1) = -mb%mp(1)
                  mc%mp(2) = mb%mp(2)
                  mc%mp(3) = mb%mp(3)
                  mc%mp(4) = mb%mp(4)
                  kflag = -5
                  call imsub2(mc, ndsave)
                  return
              else
                  kflag = -4
                  namest(ncall) = 'IMSUB'
                  call fmwarn
                  call imunknown(mc)
                  call imsub2(mc, ndsave)
                  return
              endif
          endif
          kflag = -4
          namest(ncall) = 'IMSUB'
          call fmwarn
          call imunknown(mc)
          call imsub2(mc, ndsave)
          return
      endif

!             imadd3 will negate mb and add.

      ksub = 1
      call imadd3(ma, mb, mc)
      ksub = 0

      call imsub2(mc, ndsave)

      return
      end subroutine imsub

      subroutine imsub2(mc, ndsave)

      use fmvals
      implicit none

      type(multi) :: mc
      integer :: ndsave
      intent (in) :: ndsave
      intent (inout) :: mc

      if (mc%mp(2) <= 1) mc%mp(4) = 0
      if (ntrace /= 0) call imntr_out1(mc)
      ncall = ncall - 1
      ndig = ndsave

      return
      end subroutine imsub2

      subroutine imunknown(ma)

!  Set ma to the im special value for unknown results.

      use fmvals
      implicit none

      type(multi) :: ma
      intent (inout) :: ma

      integer :: j

      call fmalloc(ma, 5)
      do j = 4, 5
         ma%mp(j) = 0
      enddo
      ma%mp(1) = 1
      ma%mp(2) = munkno
      ma%mp(3) = 1

      end subroutine imunknown

      subroutine imunpk(mp, ma)

!  mp is unpacked and the value returned in ma.

      use fmvals
      implicit none

      type(multi) :: ma, mp
      intent (in) :: mp
      intent (inout) :: ma

      integer :: j, kp, kma1, result_size

      result_size = mp%mp(2) + 3
      if (abs(result_size) >= mexpov) result_size = 5
      result_size = max(5, result_size)
      call fmalloc(ma, result_size)

      ma%mp(5) = 0
      kma1 = int(mp%mp(2))
      if (kma1 <= 2) kma1 = 2
      if (abs(kma1) >= mexpov) kma1 = 2
      kp = 2
      ma%mp(2) = mp%mp(2)
      ma%mp(3) = aint (abs(mp%mp(3))/mbase)
      ma%mp(4) = abs(mp%mp(3)) - ma%mp(3)*mbase
      ma%mp(1) = 1
      if (mp%mp(1) < 0) ma%mp(1) = -1
      if (kma1 >= 4) then
          do j = 4, kma1, 2
             kp = kp + 1
             ma%mp(j+1) = aint (mp%mp(kp+1)/mbase)
             ma%mp(j+2) = mp%mp(kp+1) - ma%mp(j+1)*mbase
          enddo
      endif
      if (mod(kma1, 2) == 1) ma%mp(kma1+2) = aint (mp%mp(kp+2)/mbase)

      return
      end subroutine imunpk

      subroutine imwrit(kwrite, ma)

!  Write ma on unit kwrite.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  These numbers can then be read easily using imread.

      use fmvals
      implicit none

      integer :: kwrite
      type(multi) :: ma
      intent (in) :: kwrite, ma

      integer :: j, k, ksave, l, last, lb, nd, ndsave, nexp

      ncall = ncall + 1
      namest(ncall) = 'IMWRIT'
      ndsave = ndig
      ndig = max(3, int(ma%mp(2)))
      if (ma%mp(2) >= mexpov) ndig = 3

      ksave = kflag
      nd = int(real(ndig)*log10(real(mbase))) + 1
      if (nd < 2) nd = 2
      nexp = int(2.0*log10(real(mxbase))) + 16
      lb = nd + nexp
      if (lb > lmbuff) then
          if (lmbuff > 0) deallocate(cmbuff)
          allocate(cmbuff(lb), stat=j)
          if (j /= 0) then
              call fmdefine_error
          endif
          lmbuff = lb
      endif

      call imout(ma, cmbuff, lb)

      kflag = ksave
      ndig = ndsave
      last = lb + 1
      do j = 1, lb
         if (cmbuff(last-j) /= ' ' .or. j == lb) then
             l = last - j
             if (mod(l, 73) /= 0) then
                 write (kwrite, "(4X, 73A1, ' &')") (cmbuff(k), k=1, l)
             else
                 if (l > 73) write (kwrite, "(4X, 73A1, ' &')") (cmbuff(k), k=1, l-73)
                 write (kwrite, "(4X, 73A1)") (cmbuff(k), k=l-72, l)
             endif
             ncall = ncall - 1
             return
         endif
      enddo
      ncall = ncall - 1

      return
      end subroutine imwrit

      subroutine imwrite(kwrite, ma)

      use fmvals
      implicit none

      integer :: kwrite
      type(multi) :: ma
      intent (in) :: kwrite, ma

      call imwrit(kwrite, ma)

      return
      end subroutine imwrite

      subroutine ipabs(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call imunpk(ma, mpa)
      call imabs(mpa, mpb)
      call impack(mpb, mb)
      return
      end subroutine ipabs

      subroutine ipadd(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call imunpk(ma, mpa)
      call imunpk(mb, mpb)
      call imadd(mpa, mpb, mpc)
      call impack(mpc, mc)
      return
      end subroutine ipadd

      subroutine ipbig(ma)
      use fmvals
      implicit none
      type(multi) :: ma
      intent (inout) :: ma
      call imbig(mpb)
      call impack(mpb, ma)
      return
      end subroutine ipbig

      subroutine ipcomb(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call imunpk(ma, mpa)
      call imunpk(mb, mpb)
      call imcomb(mpa, mpb, mpc)
      call impack(mpc, mc)
      return
      end subroutine ipcomb

      function ipcomp(ma, lrel, mb)
      use fmvals
      implicit none
      logical :: ipcomp
      character(*) :: lrel
      type(multi) :: ma, mb
      intent (in) :: ma, mb, lrel
      logical, external ::imcomp
      call imunpk(ma, mpa)
      call imunpk(mb, mpb)
      ipcomp = imcomp(mpa, lrel, mpb)
      return
      end function ipcomp

      function ipcompare(ma, lrel, mb)
      use fmvals
      implicit none
      logical :: ipcompare
      character(*) :: lrel
      type(multi) :: ma, mb
      intent (in) :: ma, mb, lrel
      logical, external :: ipcomp
      ipcompare = ipcomp(ma, lrel, mb)
      return
      end function ipcompare

      subroutine ipdim(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call imunpk(ma, mpa)
      call imunpk(mb, mpb)
      call imdim(mpa, mpb, mpc)
      call impack(mpc, mc)
      return
      end subroutine ipdim

      subroutine ipdiv(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call imunpk(ma, mpa)
      call imunpk(mb, mpb)
      call imdiv(mpa, mpb, mpc)
      call impack(mpc, mc)
      return
      end subroutine ipdiv

      subroutine ipdivi(ma, ival, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      call imunpk(ma, mpa)
      call imdivi(mpa, ival, mpb)
      call impack(mpb, mb)
      return
      end subroutine ipdivi

      subroutine ipdivr(ma, mb, mc, md)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc, md
      intent (in) :: ma, mb
      intent (inout) :: mc, md
      call imunpk(ma, mpa)
      call imunpk(mb, mpb)
      call imdivr(mpa, mpb, mpc, mpd)
      call impack(mpc, mc)
      call impack(mpd, md)
      return
      end subroutine ipdivr

      subroutine ipdvir(ma, ival, mb, irem)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      integer :: ival, irem
      intent (in) :: ma, ival
      intent (inout) :: mb, irem
      call imunpk(ma, mpa)
      call imdvir(mpa, ival, mpb, irem)
      call impack(mpb, mb)
      return
      end subroutine ipdvir

      subroutine ipeq(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call imunpk(ma, mpa)
      call imeq(mpa, mpb)
      call impack(mpb, mb)
      return
      end subroutine ipeq

      subroutine ipfact(ival, ma)
      use fmvals
      implicit none
      integer :: ival
      type(multi) :: ma
      intent (in) :: ival
      intent (inout) :: ma
      call imfact(ival, mpa)
      call impack(mpa, ma)
      return
      end subroutine ipfact

      subroutine ipfm2i(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fmunpk(ma, mpa)
      call imfm2i(mpa, mpb)
      call impack(mpb, mb)
      return
      end subroutine ipfm2i

      subroutine ipform(form, ma, string)
      use fmvals
      implicit none
      character(*) :: form, string
      type(multi) :: ma
      intent (in) :: ma, form
      intent (inout) :: string
      call imunpk(ma, mpa)
      call imform(form, mpa, string)
      return
      end subroutine ipform

      subroutine ipfprint(form, ma)
      use fmvals
      implicit none
      character(*) :: form
      type(multi) :: ma
      intent (in) :: ma, form
      call ipfprt(form, ma)
      return
      end subroutine ipfprint

      subroutine ipfprt(form, ma)
      use fmvals
      implicit none
      character(*) :: form
      type(multi) :: ma
      intent (in) :: ma, form
      call imunpk(ma, mpa)
      call imfprt(form, mpa)
      return
      end subroutine ipfprt

      subroutine ipgcd(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call imunpk(ma, mpa)
      call imunpk(mb, mpb)
      call imgcd(mpa, mpb, mpc)
      call impack(mpc, mc)
      return
      end subroutine ipgcd

      subroutine ipi2fm(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call imunpk(ma, mpa)
      call imi2fm(mpa, mpb)
      call fmpack(mpb, mb)
      return
      end subroutine ipi2fm

      subroutine ipi2m(ival, ma)
      use fmvals
      implicit none
      type(multi) :: ma
      integer :: ival
      intent (in) :: ival
      intent (inout) :: ma
      call imi2m(ival, mpa)
      call impack(mpa, ma)
      return
      end subroutine ipi2m

      subroutine ipinp(line, ma, la, lb)
      use fmvals
      implicit none
      integer :: la, lb
      character :: line(lb)
      type(multi) :: ma
      intent (in) :: line, la, lb
      intent (inout) :: ma
      call iminp(line, mpa, la, lb)
      call impack(mpa, ma)
      return
      end subroutine ipinp

      subroutine ipm2dp(ma, dval)
      use fmvals
      implicit none
      type(multi) :: ma
      double precision :: dval
      intent (in) :: ma
      intent (inout) :: dval
      call imunpk(ma, mpa)
      call imm2dp(mpa, dval)
      return
      end subroutine ipm2dp

      subroutine ipm2i(ma, ival)
      use fmvals
      implicit none
      type(multi) :: ma
      integer :: ival
      intent (in) :: ma
      intent (inout) :: ival
      call imunpk(ma, mpa)
      call imm2i(mpa, ival)
      return
      end subroutine ipm2i

      subroutine ipmax(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call imunpk(ma, mpa)
      call imunpk(mb, mpb)
      call immax(mpa, mpb, mpc)
      call impack(mpc, mc)
      return
      end subroutine ipmax

      subroutine ipmin(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call imunpk(ma, mpa)
      call imunpk(mb, mpb)
      call immin(mpa, mpb, mpc)
      call impack(mpc, mc)
      return
      end subroutine ipmin

      subroutine ipmod(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call imunpk(ma, mpa)
      call imunpk(mb, mpb)
      call immod(mpa, mpb, mpc)
      call impack(mpc, mc)
      return
      end subroutine ipmod

      subroutine ipmpy(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call imunpk(ma, mpa)
      call imunpk(mb, mpb)
      call immpy(mpa, mpb, mpc)
      call impack(mpc, mc)
      return
      end subroutine ipmpy

      subroutine ipmpy_mod(ma, mb, mc, md)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md
      call ipmpym(ma, mb, mc, md)
      return
      end subroutine ipmpy_mod

      subroutine ipmpyi(ma, ival, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      call imunpk(ma, mpa)
      call immpyi(mpa, ival, mpb)
      call impack(mpb, mb)
      return
      end subroutine ipmpyi

      subroutine ipmpym(ma, mb, mc, md)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md
      call imunpk(ma, mpa)
      call imunpk(mb, mpb)
      call imunpk(mc, mpc)
      call immpym(mpa, mpb, mpc, mpd)
      call impack(mpd, md)
      return
      end subroutine ipmpym

      subroutine ipout(ma, line, lb)
      use fmvals
      implicit none
      type(multi) :: ma
      integer :: lb
      character :: line(lb)
      intent (in) :: ma, lb
      intent (inout) :: line
      call imunpk(ma, mpa)
      call imout(mpa, line, lb)
      return
      end subroutine ipout

      subroutine ippmod(ma, mb, mc, md)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md
      call imunpk(ma, mpa)
      call imunpk(mb, mpb)
      call imunpk(mc, mpc)
      call impmod(mpa, mpb, mpc, mpd)
      call impack(mpd, md)
      return
      end subroutine ippmod

      subroutine ippower(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call ippwr(ma, mb, mc)
      return
      end subroutine ippower

      subroutine ippower_mod(ma, mb, mc, md)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md
      call ippmod(ma, mb, mc, md)
      return
      end subroutine ippower_mod

      subroutine ipprint(ma)
      use fmvals
      implicit none
      type(multi) :: ma
      intent (in) :: ma
      call ipprnt(ma)
      return
      end subroutine ipprint

      subroutine ipprnt(ma)
      use fmvals
      implicit none
      type(multi) :: ma
      intent (in) :: ma
      call imunpk(ma, mpa)
      call imprnt(mpa)
      return
      end subroutine ipprnt

      subroutine ippwr(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call imunpk(ma, mpa)
      call imunpk(mb, mpb)
      call impwr(mpa, mpb, mpc)
      call impack(mpc, mc)
      return
      end subroutine ippwr

      subroutine ipread(kread, ma)
      use fmvals
      implicit none
      type(multi) :: ma
      integer :: kread
      intent (in) :: kread
      intent (inout) :: ma
      call imread(kread, mpa)
      call impack(mpa, ma)
      return
      end subroutine ipread

      subroutine ipsign(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call imunpk(ma, mpa)
      call imunpk(mb, mpb)
      call imsign(mpa, mpb, mpc)
      call impack(mpc, mc)
      return
      end subroutine ipsign

      subroutine ipsqr(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call imunpk(ma, mpa)
      call imsqr(mpa, mpb)
      call impack(mpb, mb)
      return
      end subroutine ipsqr

      subroutine ipst2m(string, ma)
      use fmvals
      implicit none
      character(*) :: string
      type(multi) :: ma
      intent (in) :: string
      intent (inout) :: ma
      call imst2m(string, mpa)
      call impack(mpa, ma)
      return
      end subroutine ipst2m

      subroutine ipsub(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call imunpk(ma, mpa)
      call imunpk(mb, mpb)
      call imsub(mpa, mpb, mpc)
      call impack(mpc, mc)
      return
      end subroutine ipsub

      subroutine ipwrit(kwrite, ma)
      use fmvals
      implicit none
      integer :: kwrite
      type(multi) :: ma
      intent (in) :: ma, kwrite
      call imunpk(ma, mpa)
      call imwrit(kwrite, mpa)
      return
      end subroutine ipwrit

      subroutine ipwrite(kwrite, ma)
      use fmvals
      implicit none
      integer :: kwrite
      type(multi) :: ma
      intent (in) :: ma, kwrite
      call ipwrit(kwrite, ma)
      return
      end subroutine ipwrite


!  The zm routines perform complex multiple-precision arithmetic.


      subroutine zmset(nprec)

!  Set precision to at least nprec significant digits for using zm arithmetic.

      use fmvals
      implicit none

      integer :: nprec
      intent (in) :: nprec

!             Set jformz to ' 1.23 + 4.56 i ' format.

      jformz = 1

!             Set jprntz to print real and imaginary parts on one line whenever possible.

      jprntz = 1

!             Use fmset to initialize the other variables.

      call fmset(nprec)

      return
      end subroutine zmset

      subroutine zm2i2m(integ1, integ2, ma)

!  ma = integ1 + integ2 i

      use fmvals
      implicit none

      integer :: integ1, integ2
      type(multi) :: ma(2)
      intent (in) :: integ1, integ2
      intent (inout) :: ma

      ncall = ncall + 1
      namest(ncall) = 'ZM2I2M'
      if (ntrace /= 0) then
          call fmntr_inpii(integ1, integ2)
      endif

      call fmi2m(integ1, ma(1))
      call fmi2m(integ2, ma(2))

      if (ntrace /= 0) call zmntr_out1(ma)
      ncall = ncall - 1

      return
      end subroutine zm2i2m

      subroutine zmabs(ma, mbfm)

!  mbfm = abs(ma)

!  Complex absolute value.  The result is a real fm number.

      use fmvals
      implicit none

      type(multi) :: ma(2), mbfm
      intent (in) :: ma
      intent (inout) :: mbfm

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(3), mresult

      call fmalloc(mbfm, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmabs_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mbfm, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmabs_m1(ma, mxy, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mbfm, kovun, mxsave, ndsave)

      return
      end subroutine zmabs

      subroutine zmabs_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing abs(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(3), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      type(multi), save :: mz01(2)

      call zmequ(ma, mz01, ndsave, ndig)

      call fmsqr(mz01(1), mxy(1))
      call fmsqr(mz01(2), mxy(2))
      call fmadd(mxy(1), mxy(2), mxy(3))
      call fmsqrt(mxy(3), mresult)

      return
      end subroutine zmabs_m1

      subroutine zmabs_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = abs(ma).

!  kresult = 1 is returned if a special case gives the value of abs(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMABS    '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      if (ma(1)%mp(3) == 0) then
          call fmabs(malocal(2), mresult)
          kresult = 1
          return
      else if (ma(2)%mp(3) == 0) then
          call fmabs(malocal(1), mresult)
          kresult = 1
          return
      endif

      return
      end subroutine zmabs_sc

      subroutine zmacos(ma, mb)

!  mb = acos(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(4), mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmacos_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmacos_m1(ma, mxy, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmacos

      subroutine zmacos_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing acos(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(4), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      integer :: j
      double precision :: xe, ye
      type(multi), save :: mz01(2), mz02(2), mz03(2), mz04(2), mz05(2)

      call zmequ(ma, mz04, ndsave, ndig)

      call fmovun_xe(mz04(1), xe)
      call fmovun_xe(mz04(2), ye)
      if ((mz04(1)%mp(3) == 0 .or. xe*2 <= -ndig) .and.  &
          (mz04(2)%mp(3) == 0 .or. ye*2 <= -ndig)) then
          call fmpi(mz01(1))
          call fmdivi_r1(mz01(1), 2)
          call fmi2m(0, mz01(2))
          call zmsub(mz01, mz04, mresult)
          return
      endif

      call zmi2m(0, mz01)
      call zmi2m(1, mz03)
      call zmsub(mz03, mz04, mz02)
      call zmadd(mz03, mz04, mz05)
      call zmmpy(mz02, mz05, mz03)
      if ((mz03(1)%mp(2) == munkno .and. mz03(1)%mp(5) >= 0) .or.  &
          (mz03(2)%mp(2) == munkno .and. mz03(2)%mp(5) >= 0)) then
          call zmi2m(1, mz03)
          call zmsqr(mz04, mz05)
          call zmsub_r1(mz03, mz05)
      endif
      call zmsqrt(mz03, mz02)
      do j = 1, ndig+2
         mz03(1)%mp(j) = mz02(2)%mp(j)
         mz03(2)%mp(j) = mz02(1)%mp(j)
      enddo
      call fmnegate(mz03(1))

      if ((ma(1)%mp(3) /= 0 .and. mz03(1)%mp(2) == ma(1)%mp(2)     .and.  &
          mz03(1)%mp(1)*mz03(1)%mp(3) == ma(1)%mp(1)*ma(1)%mp(3)) .or.    &
          (ma(2)%mp(3) /= 0 .and. mz03(2)%mp(2) == ma(2)%mp(2)     .and.  &
          mz03(2)%mp(1)*mz03(2)%mp(3) == ma(2)%mp(1)*ma(2)%mp(3)) ) then
          call zmadd(mz04, mz03, mz05)
          call fmsqr(mz05(1), mxy(2))
          call fmsqr(mz05(2), mxy(3))
          call fmadd(mxy(2), mxy(3), mxy(4))
          call fmi2m(1, mxy(1))
          call fmsub_r2(mxy(4), mxy(1))
          if (mxy(1)%mp(2) < 0) then
              ndig = ndig - int(mxy(1)%mp(2))
              if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
              call zmequ_r1(mz04, ndsave, ndig)
              call zmi2m(0, mz01)
              call zmi2m(1, mz03)
              call zmsub(mz03, mz04, mz02)
              call zmadd(mz03, mz04, mz05)
              call zmmpy(mz02, mz05, mz03)
              if ((mz03(1)%mp(2) == munkno .and. mz03(1)%mp(5) >= 0) .or.  &
                  (mz03(2)%mp(2) == munkno .and. mz03(2)%mp(5) >= 0)) then
                  call zmi2m(1, mz03)
                  call zmsqr(mz04, mz05)
                  call zmsub_r1(mz03, mz05)
              endif
              call zmsqrt(mz03, mz02)
              do j = 1, ndig+2
                 mz03(1)%mp(j) = mz02(2)%mp(j)
                 mz03(2)%mp(j) = mz02(1)%mp(j)
              enddo
              call fmnegate(mz03(1))
              call zmadd(mz04, mz03, mz05)
          endif

          call zmln(mz05, mz03)
          do j = 1, ndig+2
             mz01(1)%mp(j) = mz03(2)%mp(j)
             mz01(2)%mp(j) = mz03(1)%mp(j)
          enddo
          call fmnegate(mz01(2))
      else
          call zmsub(mz04, mz03, mz05)
          call fmsqr(mz05(1), mxy(2))
          call fmsqr(mz05(2), mxy(3))
          call fmadd(mxy(2), mxy(3), mxy(4))
          call fmi2m(1, mxy(1))
          call fmsub_r2(mxy(4), mxy(1))
          if (mxy(1)%mp(2) < 0) then
              ndig = ndig - int(mxy(1)%mp(2))
              if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
              call zmequ_r1(mz04, ndsave, ndig)
              call zmi2m(0, mz01)
              call zmi2m(1, mz03)
              call zmsub(mz03, mz04, mz02)
              call zmadd(mz03, mz04, mz05)
              call zmmpy(mz02, mz05, mz03)
              if ((mz03(1)%mp(2) == munkno .and. mz03(1)%mp(5) >= 0) .or.  &
                  (mz03(2)%mp(2) == munkno .and. mz03(2)%mp(5) >= 0)) then
                  call zmi2m(1, mz03)
                  call zmsqr(mz04, mz05)
                  call zmsub_r1(mz03, mz05)
              endif
              call zmsqrt(mz03, mz02)
              do j = 1, ndig+2
                 mz03(1)%mp(j) = mz02(2)%mp(j)
                 mz03(2)%mp(j) = mz02(1)%mp(j)
              enddo
              call fmnegate(mz03(1))
              call zmsub(mz04, mz03, mz05)
          endif

          call zmln(mz05, mz03)
          do j = 1, ndig+2
             mz01(1)%mp(j) = mz03(2)%mp(j)
             mz01(2)%mp(j) = mz03(1)%mp(j)
          enddo
          call fmnegate(mz01(1))
      endif
      call zmeq(mz01, mresult)

      return
      end subroutine zmacos_m1

      subroutine zmacos_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = acos(ma).

!  kresult = 1 is returned if a special case gives the value of acos(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j, krsave
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMACOS   '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call fmpi(mresult(1))
          call fmdivi_r1(mresult(1), 2)
          call fmi2m(0, mresult(2))
          kresult = 1
          return
      else if (malocal(2)%mp(3) == 0) then
          krsave = krad
          krad = 1
          call fmacos(malocal(1), mresult(1))
          krad = krsave
          if (kflag == 0) then
              call fmi2m(0, mresult(2))
              kresult = 1
              return
          endif
      endif

      return
      end subroutine zmacos_sc

      subroutine zmacosh(ma, mb)

!  mb = acosh(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmacosh_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmacosh_m1(ma, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmacosh

      subroutine zmacosh_m1(ma, mresult, ndsave)

!  Method 1 for computing acosh(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult

      integer :: kl
      double precision :: xe, ye
      type(multi), save :: mz01(2), mz02(2), mz03(2), mz04(2), mz05(2)

      call zmequ(ma, mz04, ndsave, ndig)

      kl = 1
      call fmovun_xe(mz04(1), xe)
      call fmovun_xe(mz04(2), ye)
      if ((mz04(1)%mp(3) == 0 .or. xe*4 <= -ndig) .and.  &
          (mz04(2)%mp(3) == 0 .or. ye*4 <= -ndig)) then
          call fmpi(mz02(1))
          call fmdivi_r1(mz02(1), 2)
          call fmi2m(0, mz02(2))
          call zmsub(mz02, mz04, mz03)
          if (mz04(2)%mp(2) /= mexpun) then
              call zmipwr(mz04, 3, mz02)
              call zmdivi(mz02, 6, mz01)
              call zmsub(mz03, mz01, mz02)
              call fmeq(mz02(1), mz01(2))
              call fmmpyi(mz02(2), -1, mz01(1))
          else
              call fmipwr(mz04(1), 3, mz02(1))
              call fmdivi(mz02(1), 6, mz01(1))
              call fmsub(mz03(1), mz01(1), mz01(2))
              call fmmpyi(mz03(2), -1, mz01(1))
          endif
          if (mz04(2)%mp(1) < 0) then
              mz01(2)%mp(1) = -1
              call fmnegate(mz01(1))
          endif
          kl = 0
      endif

      if (kl == 1) then
          call zmi2m(1, mz03)
          call zmadd(mz04, mz03, mz05)
          call zmsqrt(mz05, mz02)
          call zmsub(mz04, mz03, mz05)
          call zmsqrt(mz05, mz01)
          call zmmpy(mz01, mz02, mz05)
          call zmadd(mz04, mz05, mz02)
          call zmln(mz02, mz01)
      endif

      if (ma(2)%mp(3) == 0 .and. xe <= 0) then
          call fmi2m(0, mz01(1))
      endif
      if ((mz01(1)%mp(2) == munkno .and. mz01(1)%mp(5) >= 0) .or.  &
          (mz01(2)%mp(2) == munkno .and. mz01(2)%mp(5) >= 0)) then
          ndig = ndig + ngrd22
          call zmequ(ma, mz01, ndsave, ndig)
          call zmacos(mz01, mz02)
          call zm2i2m(0, 1, mz03)
          mz03(2)%mp(1) = ma(2)%mp(1)
          call zmmpy(mz03, mz02, mz01)
          call zmequ_r1(mz01, ndig, ndig-ngrd22)
      endif

      call zmeq(mz01, mresult)

      return
      end subroutine zmacosh_m1

      subroutine zmacosh_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = acosh(ma).

!  kresult = 1 is returned if a special case gives the value of acosh(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMACOSH  '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call fmpi(mresult(2))
          call fmdivi_r1(mresult(2), 2)
          call fmi2m(0, mresult(1))
          kresult = 1
          return
      else if (malocal(2)%mp(3) == 0) then
          call fmacosh(malocal(1), mresult(1))
          if (kflag == 0) then
              call fmi2m(0, mresult(2))
              kresult = 1
              return
          endif
      endif

      return
      end subroutine zmacosh_sc

      subroutine zmadd(ma, mb, mc)

!  mc = ma + mb

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: kf1, kfi, kfr, kovun, kwrnsv, ntrsav
      double precision :: xe, ye

      call zmalloc(mc, ndig+2)
      ntrsav = ntrace
      ncall = ncall + 1
      if (ntrace /= 0) then
          namest(ncall) = 'ZMADD'
          call zmntr_inp2(ma, mb)
      endif
      ntrace = 0
      kovun = 0
      if (ma(1)%mp(2) == mexpov .or. ma(1)%mp(2) == mexpun) kovun = 1
      if (ma(2)%mp(2) == mexpov .or. ma(2)%mp(2) == mexpun) kovun = 1
      if (mb(1)%mp(2) == mexpov .or. mb(1)%mp(2) == mexpun) kovun = 1
      if (mb(2)%mp(2) == mexpov .or. mb(2)%mp(2) == mexpun) kovun = 1
      if (ma(1)%mp(2) == munkno .or. ma(2)%mp(2) == munkno) kovun = 2
      if (mb(1)%mp(2) == munkno .or. mb(2)%mp(2) == munkno) kovun = 2

!             Force fmadd to use more guard digits for user calls.

      ncall = ncall - 1

      kwrnsv = kwarn
      kwarn = 0

      call fmadd(ma(1), mb(1), mc(1))
      kf1 = kflag
      call fmadd(ma(2), mb(2), mc(2))

      ncall = ncall + 1
      if (ntrsav /= 0) then
          ntrace = ntrsav
          namest(ncall) = 'ZMADD'
      endif
      kwarn = kwrnsv
      if (kflag == 1) kflag = kf1
      if (kflag == 1) then
          kflag = 0
          if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
              kflag = 1
          else if (mb(1)%mp(3) == 0 .and. mb(2)%mp(3) == 0) then
              kflag = 1
          else if (ma(1)%mp(3) == 0 .and. mb(1)%mp(3) == 0) then
              kflag = 1
          else if (ma(2)%mp(3) == 0 .and. mb(2)%mp(3) == 0) then
              kflag = 1
          else
              if (ma(1)%mp(3) == 0) then
                  kfr = 1
              else if (mb(1)%mp(3) == 0) then
                  kfr = 2
              else
                  call fmovun_xe(ma(1), xe)
                  call fmovun_xe(mb(1), ye)
                  kfr = 2
                  if (xe < ye) kfr = 1
              endif
              if (ma(2)%mp(3) == 0) then
                  kfi = 1
              else if (mb(2)%mp(3) == 0) then
                  kfi = 2
              else
                  call fmovun_xe(ma(2), xe)
                  call fmovun_xe(mb(2), ye)
                  kfi = 2
                  if (xe < ye) kfi = 1
              endif
              if (kfr == kfi) kflag = 1
          endif
      endif

      if (mc(1)%mp(2) == munkno .or. mc(2)%mp(2) == munkno) then
          if (kflag /= 1) kflag = -4
      else if (mc(1)%mp(2) == mexpov .or. mc(2)%mp(2) == mexpov) then
          if (kflag /= 1) kflag = -5
      else if (mc(1)%mp(2) == mexpun .or. mc(2)%mp(2) == mexpun) then
          if (kflag /= 1) kflag = -6
      endif
      if ((mc(1)%mp(2) == munkno .and. kovun /= 2) .or.  &
          (mc(2)%mp(2) == munkno .and. kovun /= 2) .or.  &
          (mc(1)%mp(2) == mexpun .and. kovun == 0) .or.  &
          (mc(2)%mp(2) == mexpun .and. kovun == 0) .or.  &
          (mc(1)%mp(2) == mexpov .and. kovun == 0) .or.  &
          (mc(2)%mp(2) == mexpov .and. kovun == 0)) then
          namest(ncall) = 'ZMADD'
          call fmwarn
      endif
      if (ntrace /= 0) then
          call zmntr_out1(mc)
      endif
      ncall = ncall - 1

      return
      end subroutine zmadd

      subroutine zmadd_r1(ma, mb)

!  ma = ma + mb

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (inout) :: ma
      intent (in) :: mb

      integer :: k
      type(multi), save :: mt(2)

      call zmadd(ma, mb, mt)
      k = kflag
      call zmeq(mt, ma)
      kflag = k

      end subroutine zmadd_r1

      subroutine zmadd_r2(ma, mb)

!  mb = ma + mb

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      integer :: k
      type(multi), save :: mt(2)

      call zmadd(ma, mb, mt)
      k = kflag
      call zmeq(mt, mb)
      kflag = k

      end subroutine zmadd_r2

      subroutine zmaddi(ma, integ)

!  ma = ma + integ        Increment by one-word (real) integer.

      use fmvals
      implicit none

      type(multi) :: ma(2)
      integer :: integ
      intent (inout) :: ma
      intent (in) :: integ

      integer :: kovun, kwrnsv, ntrsav


      ncall = ncall + 1
      if (ntrace /= 0) then
          namest(ncall) = 'ZMADDI'
          call zmntr_inp1i(ma, integ)
      endif
      kovun = 0
      if (ma(1)%mp(2) == mexpov .or. ma(1)%mp(2) == mexpun) kovun = 1
      if (ma(2)%mp(2) == mexpov .or. ma(2)%mp(2) == mexpun) kovun = 1
      if (ma(1)%mp(2) == munkno .or. ma(2)%mp(2) == munkno) kovun = 2

!             Force fmaddi to use more guard digits for user calls.

      ncall = ncall - 1
      ntrsav = ntrace
      ntrace = 0
      kwrnsv = kwarn
      kwarn = 0

      call fmaddi(ma(1), integ)

      ntrace = ntrsav
      kwarn = kwrnsv
      ncall = ncall + 1
      if (ntrace /= 0) namest(ncall) = 'ZMADDI'
      if (ma(1)%mp(2) == munkno .or. ma(2)%mp(2) == munkno) then
          kflag = -4
      else if (ma(1)%mp(2) == mexpov .or. ma(2)%mp(2) == mexpov) then
          if (kflag /= 1) kflag = -5
      else if (ma(1)%mp(2) == mexpun .or. ma(2)%mp(2) == mexpun) then
          if (kflag /= 1) kflag = -6
      endif
      if ((ma(1)%mp(2) == munkno .and. kovun /= 2) .or.  &
          (ma(2)%mp(2) == munkno .and. kovun /= 2) .or.  &
          (ma(1)%mp(2) == mexpun .and. kovun == 0) .or.  &
          (ma(2)%mp(2) == mexpun .and. kovun == 0) .or.  &
          (ma(1)%mp(2) == mexpov .and. kovun == 0) .or.  &
          (ma(2)%mp(2) == mexpov .and. kovun == 0)) then
          call fmwarn
      endif
      if (ntrace /= 0) call zmntr_out1(ma)
      ncall = ncall - 1

      return
      end subroutine zmaddi

      subroutine zmalloc(ma, n_size)

!  Allocate zm number ma with size n_size.

      use fmvals
      implicit none

      type(multi) :: ma(2)
      integer :: n_size
      intent (in) :: n_size
      intent (inout) :: ma

      if (.not. allocated(ma(1)%mp)) then
          allocate(ma(1)%mp(max(n_size, 5)), stat=k_stat)
          if (k_stat /= 0) call fmdefine_error
      else if (size(ma(1)%mp) < max(n_size, 5)) then
          deallocate(ma(1)%mp)
          allocate(ma(1)%mp(max(n_size, 5)), stat=k_stat)
          if (k_stat /= 0) call fmdefine_error
      endif

      if (.not. allocated(ma(2)%mp)) then
          allocate(ma(2)%mp(max(n_size, 5)), stat=k_stat)
          if (k_stat /= 0) call fmdefine_error
      else if (size(ma(2)%mp) < max(n_size, 5)) then
          deallocate(ma(2)%mp)
          allocate(ma(2)%mp(max(n_size, 5)), stat=k_stat)
          if (k_stat /= 0) call fmdefine_error
      endif

      return
      end subroutine zmalloc

      subroutine zmarg(ma, mbfm)

!  mbfm = arg(ma)

!  Complex argument.  The result is a real fm number.

      use fmvals
      implicit none

      type(multi) :: ma(2), mbfm
      intent (in) :: ma
      intent (inout) :: mbfm

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mresult

      call fmalloc(mbfm, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmarg_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call fmexit1(mresult, mbfm, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmarg_m1(ma, mresult, ndsave)
         call fmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call fmexit1(mresult, mbfm, kovun, mxsave, ndsave)

      return
      end subroutine zmarg

      subroutine zmarg_m1(ma, mresult, ndsave)

!  Method 1 for computing arg(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult

      type(multi), save :: mz01(2)

      call zmequ(ma, mz01, ndsave, ndig)

      call fmatn2(mz01(2), mz01(1), mresult)

      return
      end subroutine zmarg_m1

      subroutine zmarg_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = arg(ma).

!  kresult = 1 is returned if a special case gives the value of arg(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      double precision :: ar, b, x, xe, xf, y, ye, yf, ze, zf
      type(multi), save :: malocal(2), mz01(2)

      kresult = 0

      namest(ncall) = 'ZMARG    '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call fmunknown(mresult)
          kresult = 1
          return
      endif

      if (malocal(2)%mp(3) == 0 .and. malocal(1)%mp(1) > 0) then
          call fmi2m(0, mresult)
      else if (malocal(2)%mp(3) == 0 .and. malocal(1)%mp(1) < 0) then
          if (krad == 1) then
              call fmpi(mresult)
          else
              call fmi2m(180, mresult)
          endif
      else if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(1) > 0) then
          if (krad == 1) then
              call fmpi(mresult)
              call fmdivi_r1(mresult, 2)
          else
              call fmi2m(90, mresult)
          endif
      else if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(1) < 0) then
          if (krad == 1) then
              call fmpi(mresult)
              call fmdivi_r1(mresult, -2)
          else
              call fmi2m(-90, mresult)
          endif
      else if (abs(malocal(1)%mp(2)) >= mexpov .or.  &
               abs(malocal(2)%mp(2)) >= mexpov) then
          call fmunknown(mresult)
          call fmovun_xexf(malocal(1), xe, xf)
          call fmovun_xexf(malocal(2), ye, yf)
          ze = min(xe, ye)
          zf = 1 - epsilon(1.0d0)
          xe = xe - ze
          ye = ye - ze
          call fmdp2m(huge(ze)/1.0d+10, mz01(1))
          call fmovun_xe(mz01(1), ze)
          if (xe > ze .and. malocal(1)%mp(1) > 0) then
              call fmdiv(malocal(2), malocal(1), mz01(2))
              call fmovun_xexf(mz01(2), ze, zf)
          else
              if (xe > ze) xe = ze
              if (ye > ze) ye = ze
              b = mbase
              x = b**xe * xf * malocal(1)%mp(1)
              y = b**ye * yf * malocal(2)%mp(1)
              ar = atan2(y, x)
              if (ar < 0) mresult%mp(1) = -1
              ar = abs(ar)
              if (ar >= 1) then
                  ze = 0
                  do while (ar >= 1)
                     ze = ze + 1
                     ar = ar / b
                     zf = ar
                  enddo
              else
                  ze = 1
                  do while (ar < 1)
                     ze = ze - 1
                     zf = ar
                     ar = ar * b
                  enddo
              endif
          endif
          mresult%mp(4) = ze
          mresult%mp(5) = -zf*maxint
          if (malocal(2)%mp(1) < 0) mresult%mp(1) = -1
          kflag = -4
          return
      endif

      return
      end subroutine zmarg_sc

      subroutine zmasin(ma, mb)

!  mb = asin(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(4), mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmasin_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmasin_m1(ma, mxy, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmasin

      subroutine zmasin_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing asin(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(4), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      integer :: j
      type(multi), save :: mz01(2), mz02(2), mz03(2), mz04(2), mz05(2)

      call zmequ(ma, mz04, ndsave, ndig)

      call zmi2m(0, mz01)
      call zmi2m(1, mz03)
      call zmsub(mz03, mz04, mz02)
      call zmadd(mz03, mz04, mz05)
      call zmmpy(mz02, mz05, mz03)
      if ((mz03(1)%mp(2) == munkno .and. mz03(1)%mp(5) >= 0) .or.  &
          (mz03(2)%mp(2) == munkno .and. mz03(2)%mp(5) >= 0)) then
          call zmi2m(1, mz03)
          call zmsqr(mz04, mz05)
          call zmsub_r1(mz03, mz05)
      endif
      call zmsqrt(mz03, mz02)
      do j = 1, ndig+2
         mz03(1)%mp(j) = mz04(2)%mp(j)
         mz03(2)%mp(j) = mz04(1)%mp(j)
      enddo
      call fmnegate(mz03(1))

      if ((mz02(1)%mp(3) /= 0 .and.                                          &
           mz03(1)%mp(2) == mz02(1)%mp(2) .and.                              &
           mz03(1)%mp(1)*mz03(1)%mp(3) == mz02(1)%mp(1)*mz02(1)%mp(3)) .or.  &
          (mz02(2)%mp(3) /= 0 .and. mz03(2)%mp(2) == mz02(2)%mp(2) .and.     &
           mz03(2)%mp(1)*mz03(2)%mp(3) == mz02(2)%mp(1)*mz02(2)%mp(3)) ) then
          call zmadd(mz02, mz03, mz05)
          call fmsqr(mz05(1), mxy(2))
          call fmsqr(mz05(2), mxy(3))
          call fmadd(mxy(2), mxy(3), mxy(4))
          call fmi2m(1, mxy(1))
          call fmsub_r2(mxy(4), mxy(1))
          if (mxy(1)%mp(2) < 0) then
              ndig = ndig - int(mxy(1)%mp(2))
              if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
              call zmequ_r1(mz04, ndsave, ndig)
              call zmi2m(0, mz01)
              call zmi2m(1, mz03)
              call zmsub(mz03, mz04, mz02)
              call zmadd(mz03, mz04, mz05)
              call zmmpy(mz02, mz05, mz03)
              call zmsqrt(mz03, mz02)
              do j = 1, ndig+2
                 mz03(1)%mp(j) = mz04(2)%mp(j)
                 mz03(2)%mp(j) = mz04(1)%mp(j)
              enddo
              call fmnegate(mz03(1))
              call zmadd(mz02, mz03, mz05)
          endif

          call zmln(mz05, mz03)
          do j = 1, ndig+2
             mz01(1)%mp(j) = mz03(2)%mp(j)
             mz01(2)%mp(j) = mz03(1)%mp(j)
          enddo
          call fmnegate(mz01(2))
      else
          call zmsub(mz02, mz03, mz05)
          call fmsqr(mz05(1), mxy(2))
          call fmsqr(mz05(2), mxy(3))
          call fmadd(mxy(2), mxy(3), mxy(4))
          call fmi2m(1, mxy(1))
          call fmsub_r2(mxy(4), mxy(1))
          if (mxy(1)%mp(2) < 0) then
              ndig = ndig - int(mxy(1)%mp(2))
              if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
              call zmequ_r1(mz04, ndsave, ndig)
              call zmi2m(0, mz01)
              call zmi2m(1, mz03)
              call zmsub(mz03, mz04, mz02)
              call zmadd(mz03, mz04, mz05)
              call zmmpy(mz02, mz05, mz03)
              if ((mz03(1)%mp(2) == munkno .and. mz03(1)%mp(5) >= 0) .or.  &
                  (mz03(2)%mp(2) == munkno .and. mz03(2)%mp(5) >= 0)) then
                  call zmi2m(1, mz03)
                  call zmsqr(mz04, mz05)
                  call zmsub_r1(mz03, mz05)
              endif
              call zmsqrt(mz03, mz02)
              do j = 1, ndig+2
                 mz03(1)%mp(j) = mz04(2)%mp(j)
                 mz03(2)%mp(j) = mz04(1)%mp(j)
              enddo
              call fmnegate(mz03(1))
              call zmsub(mz02, mz03, mz05)
          endif
          call zmln(mz05, mz03)
          do j = 1, ndig+2
             mz01(1)%mp(j) = mz03(2)%mp(j)
             mz01(2)%mp(j) = mz03(1)%mp(j)
          enddo
          call fmnegate(mz01(1))
      endif

      call zmeq(mz01, mresult)

      return
      end subroutine zmasin_m1

      subroutine zmasin_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = asin(ma).

!  kresult = 1 is returned if a special case gives the value of asin(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      double precision :: xe, ye
      integer :: j, krsave
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMASIN   '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      call fmovun_xe(ma(1), xe)
      call fmovun_xe(ma(2), ye)
      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
          call zmi2m(0, mresult)
          kresult = 1
          return
      else if ((ma(1)%mp(3) == 0 .or. xe*2 <= -ndsave) .and.  &
               (ma(2)%mp(3) == 0 .or. ye*2 <= -ndsave)) then
          call zmeq(malocal, mresult)
          kresult = 1
          return
      else if (ma(2)%mp(3) == 0) then
          krsave = krad
          krad = 1
          call fmasin(malocal(1), mresult(1))
          krad = krsave
          if (kflag == 0) then
              call fmi2m(0, mresult(2))
              kresult = 1
              return
          endif
      endif

      return
      end subroutine zmasin_sc

      subroutine zmasinh(ma, mb)

!  mb = asinh(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmasinh_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmasinh_m1(ma, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmasinh

      subroutine zmasinh_m1(ma, mresult, ndsave)

!  Method 1 for computing asinh(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult

      double precision :: b, xe, xf, ye, yf
      integer :: j, ndsav2
      type(multi), save :: mz01(2), mz02(2), mz03(2), mz04(2), mz05(2)

      call zmequ(ma, mz04, ndsave, ndig)


      ndsav2 = ndig
      do j = 1, 5
         call zmi2m(1, mz03)
         call zmsqr(mz04, mz02)
         call zmadd(mz03, mz02, mz05)
         call zmsqrt(mz05, mz02)
         call zmadd(mz02, mz04, mz05)
         if (mz05(1)%mp(3) == 0 .and. mz05(1)%mp(5) >= 0 .and.  &
             mz05(2)%mp(3) == 0 .and. mz05(2)%mp(5) >= 0) then
             if (j < 5) then
                 ndig = 2*ndig
                 call zmequ_r1(mz04, ndig/2, ndig)
                 cycle
             else
                 ndig = ndsav2
                 call zmunknown(mz01)
                 exit
             endif
         endif
         if ((mz05(1)%mp(2) == munkno .and. mz05(1)%mp(5) >= 0) .or.  &
             (mz05(2)%mp(2) == munkno .and. mz05(2)%mp(5) >= 0)) then
             ndig = ndsav2
             call zmunknown(mz01)
             exit
         endif
         call fmovun_xexf(mz02(1), xe, xf)
         call fmovun_xexf(mz04(1), ye, yf)
         if (xe < ye) then
             xe = ye
             xf = yf
         endif
         call fmovun_xexf(mz05(1), ye, yf)
         b = mbase
         if (log(xf) - (ye-xe+ndig-ndsav2)*log(b) - log(yf) >= 5*log(10.0d0)) then
             if (mz05(1)%mp(5) < 0) then
                 ndig = ndsav2
                 call zmunknown(mz01)
                 exit
             else
                 ndig = 2*ndig
                 call zmequ_r1(mz04, ndig/2, ndig)
                 cycle
             endif
         endif
         call fmovun_xexf(mz02(2), xe, xf)
         call fmovun_xexf(mz04(2), ye, yf)
         if (xe < ye) then
             xe = ye
             xf = yf
         endif
         call fmovun_xexf(mz05(2), ye, yf)
         if (log(xf) - (ye-xe+ndig-ndsav2)*log(b) - log(yf) >= 5*log(10.0d0)) then
             if (mz05(1)%mp(5) < 0) then
                 ndig = ndsav2
                 call zmunknown(mz01)
                 exit
             else
                 ndig = 2*ndig
                 call zmequ_r1(mz04, ndig/2, ndig)
                 cycle
             endif
         endif
         call zmln(mz05, mz01)
         call zmequ_r1(mz01, ndig, ndsav2)
         ndig = ndsav2
         if (j < 5) exit
      enddo

      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(2) <= 0) then
          call fmi2m(0, mz01(1))
      endif

      call zmeq(mz01, mresult)

      return
      end subroutine zmasinh_m1

      subroutine zmasinh_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = asinh(ma).

!  kresult = 1 is returned if a special case gives the value of asinh(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      double precision :: xe, ye
      integer :: j
      type(multi), save :: mz02(2), mz03(2), malocal(2)

      kresult = 0

      namest(ncall) = 'ZMASINH  '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      call fmovun_xe(malocal(1), xe)
      call fmovun_xe(malocal(2), ye)
      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
          call zmi2m(0, mresult)
          kresult = 1
          return
      else if ((ma(1)%mp(3) == 0 .or. xe*2 <= -ndsave) .and.  &
               (ma(2)%mp(3) == 0 .or. ye*2 <= -ndsave)) then
          if (kround == 1) then
              call zmeq(malocal, mresult)
          else
              call zmipwr(malocal, 3, mz03)
              call zmdivi(mz03, 6, mz02)
              call zmsub(malocal, mz02, mresult)
          endif
          kresult = 1
          return
      else if (ma(2)%mp(3) == 0) then
          call fmasinh(malocal(1), mresult(1))
          if (kflag == 0) then
              call fmi2m(0, mresult(2))
              kresult = 1
              return
          endif
      endif

      return
      end subroutine zmasinh_sc

      subroutine zmatan(ma, mb)

!  mb = atan(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(5), mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmatan_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmatan_m1(ma, mxy, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmatan

      subroutine zmatan_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing atan(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(5), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      integer :: j, jterm
      double precision :: x, xe, ye
      type(multi), save :: mz01(2), mz02(2), mz03(2), mz04(2), mz05(2)
      logical, external :: fmcomp

      call zmequ(ma, mz04, ndsave, ndig)

      call fmovun_xe(mz04(1), xe)
      call fmovun_xe(mz04(2), ye)
      x = 1.0e+5
      call fmdpm(x, mxy(1))
      call fmabs(mz04(1), mxy(2))
      call fmabs(mz04(2), mxy(3))
      call fmadd_r2(mxy(2), mxy(3))

      if (fmcomp(mxy(3), '>=', mxy(1))) then
          call zmi2m(0, mz03)
          call fmpi(mz03(1))
          call fmdivi_r1(mz03(1), 2)
          if (ma(1)%mp(1) < 0) call fmnegate(mz03(1))
          call zmi2m(1, mz01)
          call zmdiv(mz01, mz04, mz05)
          call zmeq(mz05, mz02)
          call zmsub(mz03, mz05, mz01)
          call zmeq(mz01, mz03)
          if (xe > ndig .or. ye > ndig) then
              call zmeq(mz03, mresult)
              return
          endif
          call zmsqr(mz05, mz01)
          jterm = 1
          do
             call zmmpy(mz02, mz01, mz05)
             call zmeq(mz05, mz02)
             jterm = jterm + 2
             call fmeq(mz02(1), mxy(4))
             call fmeq(mz02(2), mxy(5))
             call zmdivi(mz02, jterm, mz05)
             call zmeq(mz05, mz02)
             call zmadd(mz03, mz02, mz05)
             call zmeq(mz05, mz03)
             if (kflag /= 0) then
                 call zmeq(mz03, mresult)
                 return
             endif
             call fmeq(mxy(4), mz02(1))
             call fmeq(mxy(5), mz02(2))
             call zmmpy(mz02, mz01, mz05)
             call zmeq(mz05, mz02)
             jterm = jterm + 2
             call fmeq(mz02(1), mxy(4))
             call fmeq(mz02(2), mxy(5))
             call zmdivi(mz02, jterm, mz05)
             call zmeq(mz05, mz02)
             call zmsub(mz03, mz02, mz05)
             call zmeq(mz05, mz03)
             if (kflag /= 0) then
                 call zmeq(mz03, mresult)
                 return
             endif
             call fmeq(mxy(4), mz02(1))
             call fmeq(mxy(5), mz02(2))
          enddo
      else
          call zm2i2m(0, 1, mz01)
          call zmsub(mz01, mz04, mz03)
          call zmadd(mz01, mz04, mz05)
          call zmdiv(mz05, mz03, mz02)
          call fmsqr(mz02(1), mxy(3))
          call fmsqr(mz02(2), mxy(4))
          call fmadd(mxy(3), mxy(4), mxy(5))
          call fmi2m(1, mxy(2))
          call fmsub_r2(mxy(5), mxy(2))
          call fmovun_xe(mxy(2), xe)
          if (xe < 0) then
              ndig = ndig - int(mxy(2)%mp(2))
              if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
              call zmequ_r1(mz04, ndsave, ndig)
              call zm2i2m(0, 1, mz01)
              call zmsub(mz01, mz04, mz03)
              call zmadd(mz01, mz04, mz05)
              call zmdiv(mz05, mz03, mz02)
          endif
          call zmln(mz02, mz05)
          call zmdivi(mz05, 2, mz02)
          do j = 1, ndig+2
             mz03(1)%mp(j) = mz02(2)%mp(j)
             mz03(2)%mp(j) = mz02(1)%mp(j)
          enddo
          call fmnegate(mz03(1))
      endif

      call zmeq(mz03, mresult)

      return
      end subroutine zmatan_m1

      subroutine zmatan_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = atan(ma).

!  kresult = 1 is returned if a special case gives the value of atan(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      double precision :: xe, ye
      integer :: j, krsave
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMATAN   '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif
      call fmovun_xe(malocal(1), xe)
      call fmovun_xe(malocal(2), ye)
      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
          call zmi2m(0, mresult)
          kresult = 1
          return
      else if ((ma(1)%mp(3) == 0 .or. xe*2 <= -ndsave) .and.  &
               (ma(2)%mp(3) == 0 .or. ye*2 <= -ndsave)) then
          call zmeq(malocal, mresult)
          kresult = 1
          return
      else if (ma(2)%mp(3) == 0) then
          krsave = krad
          krad = 1
          call fmatan(malocal(1), mresult(1))
          krad = krsave
          if (kflag == 0) then
              call fmi2m(0, mresult(2))
              kresult = 1
              return
          endif
      endif

      return
      end subroutine zmatan_sc

      subroutine zmatanh(ma, mb)

!  mb = atanh(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(5), mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmatanh_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmatanh_m1(ma, mxy, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmatanh

      subroutine zmatanh_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing atanh(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(5), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      integer :: jterm
      double precision :: xe, ye
      type(multi), save :: mz01(2), mz02(2), mz03(2), mz04(2), mz05(2), mz06(2)
      logical, external :: fmcomp

      call zmequ(ma, mz04, ndsave, ndig)

      call fmdpm(1.0d+5, mxy(1))
      call fmabs(mz04(1), mxy(2))
      call fmabs(mz04(2), mxy(3))
      call fmadd_r2(mxy(2), mxy(3))

      if (fmcomp(mxy(3), '>=', mxy(1))) then
          call zmi2m(0, mz03)
          call fmpi(mz03(2))
          if (ma(2)%mp(1) > 0) then
              call fmdivi_r1(mz03(2), 2)
          else
              call fmdivi_r1(mz03(2), -2)
          endif
          if (ma(1)%mp(1) < 0) call fmnegate(mz03(1))
          call zmi2m(1, mz01)
          call zmdiv(mz01, mz04, mz05)
          call zmeq(mz05, mz02)
          call zmadd(mz03, mz05, mz01)
          call zmeq(mz01, mz03)
          call fmovun_xe(ma(1), xe)
          call fmovun_xe(ma(2), ye)
          if (xe > ndig .or. ye > ndig) then
              if (ma(2)%mp(3) == 0 .and. xe >= 1) mz03(2)%mp(1) = -ma(1)%mp(1)
              if (ma(1)%mp(3) == 0) call fmi2m(0, mz03(1))
              call zmeq(mz03, mresult)
              return
          endif
          call zmsqr(mz05, mz01)
          jterm = 1
          do
             call zmmpy(mz02, mz01, mz05)
             call zmeq(mz05, mz02)
             jterm = jterm + 2
             call zmdivi(mz02, jterm, mz06)
             call zmadd(mz03, mz06, mz05)
             call zmeq(mz05, mz03)
             if (kflag /= 0) then
                 if (ma(2)%mp(3) == 0 .and. xe >= 1) mz03(2)%mp(1) = -ma(1)%mp(1)
                 if (ma(1)%mp(3) == 0) call fmi2m(0, mz03(1))
                 call zmeq(mz03, mresult)
                 return
             endif
          enddo
      else
          call zmi2m(0, mz03)
          call zmi2m(1, mz01)
          call zmsub(mz01, mz04, mz02)
          call zmadd(mz01, mz04, mz05)
          call zmdiv(mz05, mz02, mz03)
          call fmsqr(mz03(1), mxy(3))
          call fmsqr(mz03(2), mxy(4))
          call fmadd(mxy(3), mxy(4), mxy(5))
          call fmi2m(1, mxy(2))
          call fmsub_r2(mxy(5), mxy(2))
          call fmovun_xe(mxy(2), xe)
          if (xe < 0) then
              ndig = ndig - int(mxy(2)%mp(2))
              if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
              call zmequ_r1(mz04, ndsave, ndig)
              call zmi2m(1, mz01)
              call zmsub(mz01, mz04, mz02)
              call zmadd(mz01, mz04, mz05)
              call zmdiv(mz05, mz02, mz03)
          endif
          call zmln(mz03, mz05)
          call zmdivi(mz05, 2, mz03)
      endif

      call fmovun_xe(ma(1), xe)
      if (ma(2)%mp(3) == 0 .and. xe >= 1) then
          mz03(2)%mp(1) = -ma(1)%mp(1)
      endif
      if (ma(1)%mp(3) == 0) then
          call fmi2m(0, mz03(1))
      endif

      call zmeq(mz03, mresult)

      return
      end subroutine zmatanh_m1

      subroutine zmatanh_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = atanh(ma).

!  kresult = 1 is returned if a special case gives the value of atanh(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      double precision :: xe, ye
      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMATANH  '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      call fmovun_xe(malocal(1), xe)
      call fmovun_xe(malocal(2), ye)
      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
          call zmi2m(0, mresult)
          kresult = 1
          return
      else if ((ma(1)%mp(3) == 0 .or. xe*2 <= -ndsave) .and.  &
               (ma(2)%mp(3) == 0 .or. ye*2 <= -ndsave)) then
          call zmeq(malocal, mresult)
          kresult = 1
          return
      else if (ma(2)%mp(3) == 0 .and. ye <= 0) then
          call fmatanh(malocal(1), mresult(1))
          if (kflag == 0) then
              call fmi2m(0, mresult(2))
              kresult = 1
              return
          endif
      endif

      return
      end subroutine zmatanh_sc

      subroutine zmcheck_accuracy(ma, ndsave, retry)

!  Internal routine used by routines that need to check for rounding accuracy.

!  Return retry = .true. if we need to try again with more guard digits because the current
!  guard digits in ma are too close to 1/2 ulp.

      use fmvals
      implicit none

      type(multi) :: ma(2)
      integer :: ndsave
      logical :: retry
      intent (in) :: ma, ndsave
      intent (inout) :: retry

      integer :: j, kl
      double precision :: err

      if (abs(ma(1)%mp(2)) >= mexpov .or. abs(ma(2)%mp(2)) >= mexpov) return
      if (ndig >= 2*ndsave+10) return

      if (ncall >= 1) then
          kl = min(ndig-ndsave, int(3*dlogtn/dlogmb + 2.5))
          err = 0
          do j = kl, 1, -1
             err = (err + ma(1)%mp(j+ndsave+2)) / mbase
          enddo
          if ((kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
              (kround /= 1 .and. (err > 0.998 .or. err < 0.002))) then
              ndig = 2*ndsave+10
              retry = .true.
              return
          endif
      endif

      if (ncall >= 1) then
          kl = min(ndig-ndsave, int(3*dlogtn/dlogmb + 2.5))
          err = 0
          do j = kl, 1, -1
             err = (err + ma(2)%mp(j+ndsave+2)) / mbase
          enddo
          if ((kround == 1 .and. err > 0.498 .and. err < 0.502) .or.  &
              (kround /= 1 .and. (err > 0.998 .or. err < 0.002))) then
              ndig = 2*ndsave+10
              retry = .true.
          endif
      endif

      return
      end subroutine zmcheck_accuracy

      subroutine zmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)

!  Some routines monitor cancellation error to see if a retry is needed at higher precision.

      use fmvals
      implicit none

      type(multi) :: mresult(2), mretry(2)
      integer :: n_acc, ndsave, numtry
      logical :: retry
      intent (in) :: mresult, ndsave
      intent (inout) :: n_acc, numtry, mretry, retry

      integer :: iextra, j, kl, ndold, ngoal, ndgoal

      if (ncall >= 1 .and. abs(mresult(1)%mp(2)) <= mxexp .and.  &
          abs(mresult(2)%mp(2)) <= mxexp) then
          ngoal = int(real(ndsave)*alogm2) + 17
      else
          ngoal = int(-mxexp2)
      endif

      if (n_acc <= ngoal) then
          if (numtry > 0) then
              ndgoal = int(real(ngoal)/alogm2 + 1.0)
              kl = 0
              do j = 1, ndgoal+1
                 if (mretry(1)%mp(j+1) /= mresult(1)%mp(j+1) .or.  &
                     mretry(2)%mp(j+1) /= mresult(2)%mp(j+1)) then
                     kl = 1
                     exit
                 endif
              enddo
              if (kl == 0) then
                  return
              endif
          endif
          iextra = int(real(ngoal-n_acc)/alogm2 + 23.03/alogmb) + 1
          ndold = ndig
          ndig = ndig + iextra
          call zmequ(mresult, mretry, ndold, ndig)
          retry = .true.
      endif

      return
      end subroutine zmcheck_cancellation

      subroutine zmchsh(ma, mb, mc)

!  mb = cosh(ma),    mc = sinh(ma).

!  If both the hyperbolic sine and cosine are needed, this routine is faster than calling both
!  zmcosh and zmsinh.

!  mb and mc must be distinct.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma
      intent (inout) :: mb, mc

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mresult1(2), mresult2(2)

      call zmalloc(mb, ndig+2)
      call zmalloc(mc, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmchsh_sc(ma, ndsave, mresult1, mresult2, kresult)
      if (kresult > 0) then
          call zmexit2(mresult1, mresult2, mb, mc, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmchsh_m1(ma, mresult1, mresult2, ndsave)
         call zmcheck_accuracy(mresult1, ndsave, retry)
         if (retry) cycle
         call zmcheck_accuracy(mresult2, ndsave, retry)
      enddo

      call zmexit2(mresult1, mresult2, mb, mc, kovun, mxsave, ndsave)

      return
      end subroutine zmchsh

      subroutine zmchsh_m1(ma, mresult1, mresult2, ndsave)

!  Method 1 for computing chsh(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult1(2), mresult2(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult1, mresult2

      type(multi), save :: mz01(2), mz02(2), mz03(2), mz04(2), mz05(2)

      call zmequ(ma, mz04, ndsave, ndig)

!             Find sinh(real(ma)) and cosh(real(ma)).

      call fmchsh(mz04(1), mz02(1), mz02(2))

!             Find sin(imag(ma)) and cos(imag(ma)).

      call fmcssn(mz04(2), mz03(1), mz03(2))

!             cosh(ma) =  cosh(real(ma))*cos(imag(ma)) + sinh(real(ma))*sin(imag(ma)) i

      call fmmpy(mz02(1), mz03(1), mz01(1))
      call fmmpy(mz02(2), mz03(2), mz01(2))

!             sinh(ma) =  sinh(real(ma))*cos(imag(ma)) + cosh(real(ma))*sin(imag(ma)) i

      call fmmpy(mz02(2), mz03(1), mz05(1))
      call fmmpy(mz02(1), mz03(2), mz05(2))

      call zmeq(mz01, mresult1)
      call zmeq(mz05, mresult2)

      return
      end subroutine zmchsh_m1

      subroutine zmchsh_sc(ma, ndsave, mresult1, mresult2, kresult)

!  Check for special cases for {mresult1,mresult2} = chsh(ma).

!  kresult = 1 is returned if a special case gives the value of chsh(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult1(2), mresult2(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult1, mresult2, kresult

      integer :: j, kl
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMCHSH   '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult1)
          call zmunknown(mresult2)
          kresult = 1
          return
      endif

      if (abs(ma(1)%mp(2)) >= mexpov .or. abs(ma(2)%mp(2)) >= mexpov) then
          call zmcosh(malocal, mresult1)
          kl = kflag
          call zmsinh(malocal, mresult2)
          kflag = max(kflag, kl)
          kresult = 1
          return
      endif

      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
          call zmi2m(1, mresult1)
          call zmi2m(0, mresult2)
          kresult = 1
          return
      else if (ma(2)%mp(3) == 0) then
          call fmchsh(malocal(1), mresult1(1), mresult2(1))
          call fmi2m(0, mresult1(2))
          call fmi2m(0, mresult2(2))
          kresult = 1
          return
      else if (ma(1)%mp(3) == 0) then
          call fmcssn(malocal(2), mresult1(1), mresult2(2))
          call fmi2m(0, mresult1(2))
          call fmi2m(0, mresult2(1))
          kresult = 1
          return
      endif

      return
      end subroutine zmchsh_sc

      subroutine zmcmpx(mafm, mbfm, mc)

!  mc = complex( mafm , mbfm )

!  mafm and mbfm are real fm numbers, mc is a complex zm number.

      use fmvals
      implicit none

      type(multi) :: mafm, mbfm, mc(2)
      intent (in) :: mafm, mbfm
      intent (inout) :: mc

      call zmalloc(mc, ndig+2)

      kflag = 0
      ncall = ncall + 1
      namest(ncall) = 'ZMCMPX'
      if (ntrace /= 0) call fmntr_inp2(mafm, mbfm)

      call fmeq(mafm, mc(1))
      call fmeq(mbfm, mc(2))

      if (ntrace /= 0) call zmntr_out1(mc)
      ncall = ncall - 1

      return
      end subroutine zmcmpx

      subroutine zmcomb(ma, mb, mc)

!  mc = combination(ma,mb)   --   binomial coefficient

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma, mb
      intent (inout) :: mc

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(2, 8), mresult(2)

      call zmalloc(mc, ndig+2)
      call zmenter2(ma, mb, kovun, mxsave, ndsave)
      call zmcomb_sc(ma, mb, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mc, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons
      retry = .true.
      do while (retry)
         retry = .false.
         call zmcomb_m1(ma, mb, mxy, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mc, kovun, mxsave, ndsave)

      return
      end subroutine zmcomb

      subroutine zmcomb_m1(ma, mb, mxy, mresult, ndsave)

!  Method 1 for computing comb(ma,mb).

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2), mxy(2, 8), mresult(2)
      integer :: ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult

      integer :: k, kl, ntry, na, nd1
      logical, external :: fmcomp

!             comb(a,b) = a! / ( b! * (a-b)! )
!                       = gamma(a+1) / ( gamma(b+1) * gamma(a-b+1) )
!                       = exp( ln(gamma(a+1)) - ln(gamma(b+1)) - ln(gamma(a-b+1)) )


      nd1 = ndig
      ntry = 0
      kl = 1
      do while (kl == 1)
         ntry = ntry + 1
         call zmequ(ma, mxy(1:2, 1), ndsave, ndig)
         call zmequ(mb, mxy(1:2, 2), ndsave, ndig)

         call zmi2m(1, mxy(1:2, 3))

         call zmadd(mxy(1:2, 1), mxy(1:2, 3), mxy(1:2, 4))
         call zmlngm(mxy(1:2, 4), mxy(1:2, 6))

         call zmadd(mxy(1:2, 2), mxy(1:2, 3), mxy(1:2, 4))
         call zmlngm(mxy(1:2, 4), mxy(1:2, 5))
         call zmsub_r1(mxy(1:2, 6), mxy(1:2, 5))

         call zmadd(mxy(1:2, 1), mxy(1:2, 3), mxy(1:2, 4))
         call zmsub_r1(mxy(1:2, 4), mxy(1:2, 2))
         call zmlngm(mxy(1:2, 4), mxy(1:2, 5))
         call zmsub_r1(mxy(1:2, 6), mxy(1:2, 5))

         if (mxy(2, 6)%mp(2) > nd1+ngrd52) then
             call zmunknown(mresult)
             return
         endif
         call zmexp(mxy(1:2, 6), mxy(1:2, 8))

         if (ntry == 1) then
             call zmequ(mxy(1:2, 8), mxy(1:2, 7), ndig, ndig+ngrd52)
             ndig = ndig + ngrd52
             cycle
         else
             call zmequ(mxy(1:2, 7), mxy(1:2, 3), ndig, ndsave)
             call zmequ(mxy(1:2, 8), mxy(1:2, 4), ndig, ndsave)
             k = ndig
             ndig = ndsave
             na = 0
             if (fmcomp(mxy(1, 3), '==', mxy(1, 4)) .and.  &
                 fmcomp(mxy(2, 3), '==', mxy(2, 4))) na = 1
             if (abs(mxy(1, 4)%mp(2)) >= mexpov .and.  &
                 fmcomp(mxy(2, 3), '==', mxy(2, 4))) na = 1
             if (abs(mxy(2, 4)%mp(2)) >= mexpov .and.  &
                 fmcomp(mxy(1, 3), '==', mxy(1, 4))) na = 1
             if (mxy(1, 4)%mp(2) == mexpov .and.  &
                 mxy(2, 4)%mp(2) == mexpov) na = 1
             if (mxy(1, 4)%mp(2) == mexpov .and.  &
                 mxy(2, 4)%mp(3) == 0) then
                 if (mxy(2, 5)%mp(3) /= 0) na = 0
             endif
             if (mxy(2, 4)%mp(2) == mexpov .and. mxy(1, 4)%mp(3) == 0) then
                 if (mxy(1, 5)%mp(3) /= 0) na = 0
             endif
             if (na == 0) then
                 if (ntry == 5) then
                     call zmunknown(mxy(1:2, 8))
                     ndig = k
                     exit
                 else
                     call zmequ(mxy(1:2, 8), mxy(1:2, 7), k, 2*k)
                     ndig = 2*k
                     if (ma(1)%mp(2) == munkno .or. ma(2)%mp(2) == munkno .or.  &
                         mb(1)%mp(2) == munkno .or. mb(2)%mp(2) == munkno) then
                         ndig = k
                         exit
                     endif
                     cycle
                 endif
             else
                 ndig = k
                 exit
             endif
         endif
      enddo

      call zmeq(mxy(1:2, 8), mresult)

      return
      end subroutine zmcomb_m1

      subroutine zmcomb_sc(ma, mb, ndsave, mresult, kresult)

!  Check for special cases for mresult = comb(ma,mb).

!  kresult = 1 is returned if a special case gives the value of comb(ma,mb).

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2), mblocal(2)
      logical, external :: fmcomp

      kresult = 0

      namest(ncall) = 'ZMCOMB   '
      j = ndig
      ndig = ndsave
      call zmntr_inp2(ma, mb)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)
      call zmequ(mb, mblocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif
      if ((mblocal(1)%mp(2) == munkno .and. mblocal(1)%mp(5) >= 0) .or.  &
          (mblocal(2)%mp(2) == munkno .and. mblocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

!             If ma and mb are real, use fmcomb.

      if (malocal(2)%mp(3) == 0 .and. mblocal(2)%mp(3) == 0) then
          call fmcomb(malocal(1), mblocal(1), mresult(1))
          call fmi2m(0, mresult(2))
          kresult = 1
          return
      endif

!                   if ma = mb or mb = 0 return 1.

      if ( (fmcomp(malocal(1), "==", mblocal(1)) .and. fmcomp(malocal(2), "==", mblocal(2))) .or.  &
           (mblocal(1)%mp(3) == 0 .and. mblocal(2)%mp(3) == 0) ) then
          call zmi2m(1, mresult)
          kresult = 1
          return
      endif

      return
      end subroutine zmcomb_sc

      subroutine zmcomplex(mafm, mbfm, mc)

      use fmvals
      implicit none

      type(multi) :: mafm, mbfm, mc(2)
      intent (in) ::  mafm, mbfm
      intent (inout) :: mc

      call zmcmpx(mafm, mbfm, mc)

      return
      end subroutine zmcomplex

      subroutine zmconj(ma, mb)

!  mb = conjg(ma)

!  Complex conjugate.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      kflag = 0
      ncall = ncall + 1
      namest(ncall) = 'ZMCONJ'
      if (ntrace /= 0) call zmntr_inp1(ma)

      call fmeq(ma(1), mb(1))
      call fmeq(ma(2), mb(2))
      call fmnegate(mb(2))

      if (ntrace /= 0) call zmntr_out1(mb)
      ncall = ncall - 1

      return
      end subroutine zmconj

      subroutine zmconjugate(ma, mb)

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) ::  ma
      intent (inout) :: mb

      call zmconj(ma, mb)

      return
      end subroutine zmconjugate

      subroutine zmcos(ma, mb)

!  mb = cos(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) ::  ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(5), mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmcos_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmcos_m1(ma, mxy, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmcos

      subroutine zmcos_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing cos(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(5), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      type(multi), save :: mz01(2), mz02(2)

      call zmequ(ma, mz02, ndsave, ndig)

!             Find cos(real(ma)) and sin(real(ma)).

      call fmcssn(mz02(1), mz01(1), mz01(2))

!             Find cosh(imag(ma)) and sinh(imag(ma)).

      call fmchsh(mz02(2), mxy(1), mxy(2))

!             cos(ma) =  cos(real(ma))*cosh(imag(ma)) - sin(real(ma))*sinh(imag(ma)) i

      if (mxy(1)%mp(2) == mexpov) then
          call fmabs(mz01(1), mxy(1))
          call fmdivi_r1(mxy(1), 2)
          call fmln(mxy(1), mxy(2))
          call fmabs(mz02(2), mxy(3))
          call fmadd(mxy(2), mxy(3), mxy(5))
          call fmexp(mxy(5), mxy(4))
          if (mz01(1)%mp(1) < 0) call fmnegate(mxy(4))

          call fmabs(mz01(2), mxy(1))
          call fmdivi_r1(mxy(1), 2)
          call fmln(mxy(1), mxy(2))
          call fmadd(mxy(2), mxy(3), mxy(1))
          call fmexp(mxy(1), mxy(5))
          if (mz02(2)%mp(1) > 0) call fmnegate(mxy(5))
          if (mz01(2)%mp(1) < 0) call fmnegate(mxy(5))

          call fmeq(mxy(4), mz01(1))
          call fmeq(mxy(5), mz01(2))
      else
          call fmmpy_r1(mz01(1), mxy(1))
          call fmnegate(mxy(2))
          call fmmpy_r1(mz01(2), mxy(2))
      endif

      call zmeq(mz01, mresult)

      return
      end subroutine zmcos_m1

      subroutine zmcos_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = cos(ma).

!  kresult = 1 is returned if a special case gives the value of cos(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMCOS    '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call zmi2m(1, mresult)
          kresult = 1
          return
      else if (malocal(2)%mp(3) == 0) then
          call fmcos(malocal(1), mresult(1))
          call fmi2m(0, mresult(2))
          kresult = 1
          return
      else if (malocal(1)%mp(3) == 0) then
          call fmcosh(malocal(2), mresult(1))
          call fmi2m(0, mresult(2))
          kresult = 1
          return
      endif

      return
      end subroutine zmcos_sc

      subroutine zmcos_sin(ma, mb, mc)

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) ::  ma
      intent (inout) :: mb, mc

      call zmcssn(ma, mb, mc)

      return
      end subroutine zmcos_sin

      subroutine zmcosh(ma, mb)

!  mb = cosh(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) ::  ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(5), mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmcosh_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmcosh_m1(ma, mxy, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmcosh

      subroutine zmcosh_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing cosh(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(5), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      type(multi), save :: mz01(2), mz02(2)

      call zmequ(ma, mz02, ndsave, ndig)

!             Find cos(imag(ma)) and sin(imag(ma)).

      call fmcssn(mz02(2), mz01(1), mz01(2))

!             Find cosh(real(ma)) and sinh(real(ma)).

      call fmchsh(mz02(1), mxy(1), mxy(2))

!             cosh(ma) =  cosh(real(ma))*cos(imag(ma)) + sinh(real(ma))*sin(imag(ma)) i

      if (mxy(1)%mp(2) == mexpov) then
          call fmabs(mz01(1), mxy(1))
          call fmdivi_r1(mxy(1), 2)
          call fmln(mxy(1), mxy(2))
          call fmabs(mz02(1), mxy(3))
          call fmadd(mxy(2), mxy(3), mxy(5))
          call fmexp(mxy(5), mxy(4))
          if (mz01(1)%mp(1) < 0) call fmnegate(mxy(4))

          call fmabs(mz01(2), mxy(1))
          call fmdivi_r1(mxy(1), 2)
          call fmln(mxy(1), mxy(2))
          call fmadd(mxy(2), mxy(3), mxy(1))
          call fmexp(mxy(1), mxy(5))
          if (mz02(1)%mp(1) < 0) call fmnegate(mxy(5))
          if (mz01(2)%mp(1) < 0) call fmnegate(mxy(5))

          call fmeq(mxy(4), mz01(1))
          call fmeq(mxy(5), mz01(2))
      else
          call fmmpy_r1(mz01(1), mxy(1))
          call fmmpy_r1(mz01(2), mxy(2))
      endif

      call zmeq(mz01, mresult)

      return
      end subroutine zmcosh_m1

      subroutine zmcosh_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = cosh(ma).

!  kresult = 1 is returned if a special case gives the value of cosh(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMCOSH   '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call zmi2m(1, mresult)
          kresult = 1
          return
      else if (malocal(1)%mp(3) == 0) then
          call fmcos(malocal(2), mresult(1))
          call fmi2m(0, mresult(2))
          kresult = 1
          return
      else if (malocal(2)%mp(3) == 0) then
          call fmcosh(malocal(1), mresult(1))
          call fmi2m(0, mresult(2))
          kresult = 1
          return
      endif

      return
      end subroutine zmcosh_sc

      subroutine zmcosh_sinh(ma, mb, mc)

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) ::  ma
      intent (inout) :: mb, mc

      call zmchsh(ma, mb, mc)

      return
      end subroutine zmcosh_sinh

      subroutine zmcssn(ma, mb, mc)

!  mb = cos(ma),    mc = sin(ma).

!  If both the sine and cosine are needed, this routine is faster than calling both zmcos and zmsin.

!  mb and mc must be distinct.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma
      intent (inout) :: mb, mc

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mresult1(2), mresult2(2)

      call zmalloc(mb, ndig+2)
      call zmalloc(mc, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmcssn_sc(ma, ndsave, mresult1, mresult2, kresult)
      if (kresult > 0) then
          call zmexit2(mresult1, mresult2, mb, mc, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmcssn_m1(ma, mresult1, mresult2, ndsave)
         call zmcheck_accuracy(mresult1, ndsave, retry)
         if (retry) cycle
         call zmcheck_accuracy(mresult2, ndsave, retry)
      enddo

      call zmexit2(mresult1, mresult2, mb, mc, kovun, mxsave, ndsave)

      return
      end subroutine zmcssn

      subroutine zmcssn_m1(ma, mresult1, mresult2, ndsave)

!  Method 1 for computing cssn(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult1(2), mresult2(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult1, mresult2

      integer :: krsave
      type(multi), save :: mz01(2), mz02(2), mz03(2), mz04(2), mz05(2)

      krsave = krad
      krad = 1

      call zmequ(ma, mz04, ndsave, ndig)

!             Find sin(real(ma)) and cos(real(ma)).

      call fmcssn(mz04(1), mz02(1), mz02(2))

!             Find sinh(imag(ma)) and cosh(imag(ma)).

      call fmchsh(mz04(2), mz03(1), mz03(2))

!             cos(ma) =  cos(real(ma))*cosh(imag(ma)) - sin(real(ma))*sinh(imag(ma)) i

      call fmmpy(mz02(1), mz03(1), mz01(1))
      call fmmpy(mz02(2), mz03(2), mz01(2))
      call fmnegate(mz01(2))

!             sin(ma) =  sin(real(ma))*cosh(imag(ma)) + cos(real(ma))*sinh(imag(ma)) i

      call fmmpy(mz02(2), mz03(1), mz05(1))
      call fmmpy(mz02(1), mz03(2), mz05(2))

      if (mz05(1)%mp(2) == munkno .or. mz05(2)%mp(2) == munkno) then
          call zmcos(mz04, mz01)
          call zmsin(mz04, mz05)
      endif

      call zmeq(mz01, mresult1)
      call zmeq(mz05, mresult2)
      krad = krsave

      return
      end subroutine zmcssn_m1

      subroutine zmcssn_sc(ma, ndsave, mresult1, mresult2, kresult)

!  Check for special cases for {mresult1,mresult2} = cssn(ma).

!  kresult = 1 is returned if a special case gives the value of cssn(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult1(2), mresult2(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult1, mresult2, kresult

      integer :: j, krsave
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMCSSN   '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      krsave = krad
      krad = 1

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult1)
          call zmunknown(mresult2)
          krad = krsave
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call zmi2m(1, mresult1)
          call zmi2m(0, mresult2)
          krad = krsave
          kresult = 1
          return
      else if (malocal(2)%mp(3) == 0) then
          call fmcssn(malocal(1), mresult1(1), mresult2(1))
          call fmi2m(0, mresult1(2))
          call fmi2m(0, mresult2(2))
          krad = krsave
          kresult = 1
          return
      else if (malocal(1)%mp(3) == 0) then
          call fmchsh(malocal(2), mresult1(1), mresult2(2))
          call fmi2m(0, mresult1(2))
          call fmi2m(0, mresult2(1))
          krad = krsave
          kresult = 1
          return
      endif
      krad = krsave

      return
      end subroutine zmcssn_sc

      subroutine zmdiv(ma, mb, mc)

!  mc = ma / mb

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma, mb
      intent (inout) :: mc

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(8), mresult(2)

      call zmalloc(mc, ndig+2)
      call zmenter2(ma, mb, kovun, mxsave, ndsave)
      call zmdiv_sc(ma, mb, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mc, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmdiv_m1(ma, mb, mxy, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mc, kovun, mxsave, ndsave)

      return
      end subroutine zmdiv

      subroutine zmdiv_m1(ma, mb, mxy, mresult, ndsave)

!  Method 1 for computing  mc = ma / mb

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2), mxy(8), mresult(2)
      integer :: ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult

      integer :: j, kl
      real (kind(1.0d0)) :: maxexp
      type(multi), save :: mz01(2), mz02(2)
      logical, external :: fmcomp

      call fmequ(ma(1), mxy(5), ndsave, ndig)
      call fmequ(ma(2), mxy(6), ndsave, ndig)
      call fmequ(mb(1), mxy(7), ndsave, ndig)
      call fmequ(mb(2), mxy(8), ndsave, ndig)

      if (mxy(5)%mp(3) == 0 .and. mxy(6)%mp(3) == 0) then
          call zmi2m(0, mresult)
          return
      else if (mxy(8)%mp(3) == 0) then
          call fmdiv(mxy(5), mxy(7), mresult(1))
          call fmdiv(mxy(6), mxy(7), mresult(2))
          return
      else if (mxy(7)%mp(3) == 0) then
          call fmdiv(mxy(6), mxy(8), mresult(1))
          call fmdiv(mxy(5), mxy(8), mresult(2))
          call fmnegate(mresult(2))
          return
      else if (mxy(6)%mp(3) == 0) then
          call fmsqr(mxy(7), mxy(3))
          call fmsqr(mxy(8), mxy(4))
          call fmadd_r2(mxy(3), mxy(4))
          call fmdiv(mxy(7), mxy(4), mresult(1))
          call fmmpy_r2(mxy(5), mresult(1))
          call fmdiv(mxy(8), mxy(4), mresult(2))
          call fmmpy_r2(mxy(5), mresult(2))
          call fmnegate(mresult(2))
          return
      else if (mxy(5)%mp(3) == 0) then
          call fmsqr(mxy(7), mxy(3))
          call fmsqr(mxy(8), mxy(4))
          call fmadd_r2(mxy(3), mxy(4))
          call fmdiv(mxy(8), mxy(4), mresult(1))
          call fmmpy_r2(mxy(6), mresult(1))
          call fmdiv(mxy(7), mxy(4), mresult(2))
          call fmmpy_r2(mxy(6), mresult(2))
          return
      endif
      if (abs(mxy(5)%mp(2)) >= mexpov .or. abs(mxy(6)%mp(2)) >= mexpov .or.  &
          abs(mxy(7)%mp(2)) >= mexpov .or. abs(mxy(8)%mp(2)) >= mexpov ) then
          call zmi2m(0, mz01)
          call zmdiv_unov(mxy(5), mxy(6), mxy(7), mxy(8), mresult)
          return
      endif

!             Method for  ( a + b i ) / ( c + d i ):

!             if  abs(c) <= abs(d)  then

!                 p = c / d
!                 result = ( a*p + b )/( c*p + d ) + ( b*p - a )/( c*p + d ) i

!             else

!                 p = d / c
!                 result = ( b*p + a )/( d*p + c ) + ( b - a*p )/( d*p + c ) i


      if (mxy(7)%mp(3) == 0) then
          call fmi2m(0, mxy(4))
          j = 1
      else if (mxy(8)%mp(3) == 0) then
          call fmi2m(0, mxy(4))
          j = 2
      else if (mxy(7)%mp(2) < mxy(8)%mp(2)) then
          call fmdiv(mxy(7), mxy(8), mxy(4))
          j = 1
      else if (mxy(8)%mp(2) < mxy(7)%mp(2)) then
          call fmdiv(mxy(8), mxy(7), mxy(4))
          j = 2
      else if (mxy(7)%mp(3) < mxy(8)%mp(3)) then
          call fmdiv(mxy(7), mxy(8), mxy(4))
          j = 1
      else if (mxy(8)%mp(3) < mxy(7)%mp(3)) then
          call fmdiv(mxy(8), mxy(7), mxy(4))
          j = 2
      else if (mxy(7)%mp(4) < mxy(8)%mp(4)) then
          call fmdiv(mxy(7), mxy(8), mxy(4))
          j = 1
      else if (mxy(8)%mp(4) < mxy(7)%mp(4)) then
          call fmdiv(mxy(8), mxy(7), mxy(4))
          j = 2
      else if (fmcomp(mxy(7), '<=', mxy(8))) then
          call fmdiv(mxy(7), mxy(8), mxy(4))
          j = 1
      else
          call fmdiv(mxy(8), mxy(7), mxy(4))
          j = 2
      endif

      kl = 1
      do while (kl == 1)
         kl = 0
         if (j == 1) then
             call fmdiv(mxy(7), mxy(8), mxy(4))
             call fmmpye(mxy(4), mxy(5), mxy(6), mxy(7), mz01(1), mz01(2), mxy(3))
             call fmadd_r1(mxy(3), mxy(8))
             maxexp = max(mxy(6)%mp(2), mz01(1)%mp(2))
             call fmadd_r2(mxy(6), mz01(1))
             if (mz01(1)%mp(2) < maxexp) exit
             maxexp = max(mz01(2)%mp(2), mxy(5)%mp(2))
             call fmsub_r1(mz01(2), mxy(5))
             if (mz01(2)%mp(2) < maxexp) exit
             call fmdivd(mz01(1), mz01(2), mxy(3), mz02(1), mz02(2))
             call zmeq(mz02, mresult)
             return
         else
             call fmdiv(mxy(8), mxy(7), mxy(4))
             call fmmpye(mxy(4), mxy(6), mxy(5), mxy(8), mz01(1), mz01(2), mxy(3))
             call fmadd_r1(mxy(3), mxy(7))
             maxexp = max(mxy(5)%mp(2), mz01(1)%mp(2))
             call fmadd_r2(mxy(5), mz01(1))
             if (mz01(1)%mp(2) < maxexp) exit
             maxexp = max(mz01(2)%mp(2), mxy(6)%mp(2))
             call fmsub_r2(mxy(6), mz01(2))
             if (mz01(2)%mp(2) < maxexp) exit
             call fmdivd(mz01(1), mz01(2), mxy(3), mz02(1), mz02(2))
             call zmeq(mz02, mresult)
             return
         endif
      enddo

!             When there was cancellation error above, raise precision and use
!             the more stable formula.
!             ( a*c + b*d ) / ( c*c + d*d ) + ( b*c - a*d ) / ( c*c + d*d ) i

      call fmequ_r1(mxy(5), ndig, 2*ndig)
      call fmequ_r1(mxy(6), ndig, 2*ndig)
      call fmequ_r1(mxy(7), ndig, 2*ndig)
      call fmequ_r1(mxy(8), ndig, 2*ndig)
      ndig = 2*ndig
      call fmmpye(mxy(7), mxy(5), mxy(6), mxy(7), mz01(1), mz01(2), mxy(3))
      call fmmpye(mxy(8), mxy(6), mxy(5), mxy(8), mxy(1), mxy(2), mxy(4))
      call fmadd_r2(mxy(3), mxy(4))
      call fmadd_r1(mz01(1), mxy(1))
      call fmsub_r1(mz01(2), mxy(2))
      call fmdivd(mz01(1), mz01(2), mxy(4), mz02(1), mz02(2))

      call zmeq(mz02, mresult)

      return
      end subroutine zmdiv_m1

      subroutine zmdiv_r1(ma, mb)

!  ma = ma / mb

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (inout) :: ma
      intent (in) :: mb

      type(multi), save :: mt(2)

      call zmdiv(ma, mb, mt)
      call zmeq(mt, ma)

      end subroutine zmdiv_r1

      subroutine zmdiv_r2(ma, mb)

!  mb = ma / mb

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      type(multi), save :: mt(2)

      call zmdiv(ma, mb, mt)
      call zmeq(mt, mb)

      end subroutine zmdiv_r2

      subroutine zmdiv_sc(ma, mb, ndsave, mresult, kresult)

!  Check for special cases for  mc = ma / mb

!  kresult = 1 is returned if a special case gives the value of the result.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2), mblocal(2)

      kresult = 0

      namest(ncall) = 'ZMDIV    '
      j = ndig
      ndig = ndsave
      call zmntr_inp2(ma, mb)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)
      call zmequ(mb, mblocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0) .or.  &
          (mblocal(1)%mp(2) == munkno .and. mblocal(1)%mp(5) >= 0) .or.  &
          (mblocal(2)%mp(2) == munkno .and. mblocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      if (mblocal(1)%mp(3) == 0 .and. mblocal(2)%mp(3) == 0) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif
      if (malocal(1)%mp(2) == mblocal(1)%mp(2) .and.  &
          malocal(1)%mp(3) == mblocal(1)%mp(3) .and.  &
          malocal(1)%mp(1) == mblocal(1)%mp(1)) then
          if (malocal(2)%mp(2) == mblocal(2)%mp(2) .and.  &
              malocal(2)%mp(3) == mblocal(2)%mp(3) .and.  &
              malocal(2)%mp(1) == mblocal(2)%mp(1)) then
              do j = 3, ndsave+1
                 if (malocal(1)%mp(j+1) /= mblocal(1)%mp(j+1)) return
                 if (malocal(2)%mp(j+1) /= mblocal(2)%mp(j+1)) return
              enddo
              if (abs(malocal(1)%mp(2)) < mexpov .and.  &
                  abs(malocal(2)%mp(2)) < mexpov .and.  &
                  abs(mblocal(1)%mp(2)) < mexpov .and.  &
                  abs(mblocal(2)%mp(2)) < mexpov) then
                  call zmi2m(1, mresult)
                  kresult = 1
                  return
              endif
          endif
      endif
      if (malocal(1)%mp(2) == mblocal(1)%mp(2) .and.  &
          malocal(1)%mp(3) == mblocal(1)%mp(3) .and.  &
          (-malocal(1)%mp(1)) == mblocal(1)%mp(1)) then
          if (malocal(2)%mp(2) == mblocal(2)%mp(2) .and.  &
              malocal(2)%mp(3) == mblocal(2)%mp(3) .and.  &
              (-malocal(2)%mp(1)) == mblocal(2)%mp(1)) then
              do j = 3, ndsave+1
                 if (malocal(1)%mp(j+1) /= mblocal(1)%mp(j+1)) return
                 if (malocal(2)%mp(j+1) /= mblocal(2)%mp(j+1)) return
              enddo
              if (abs(malocal(1)%mp(2)) < mexpov .and.  &
                  abs(malocal(2)%mp(2)) < mexpov .and.  &
                  abs(mblocal(1)%mp(2)) < mexpov .and.  &
                  abs(mblocal(2)%mp(2)) < mexpov) then
                  call zmi2m(-1, mresult)
                  kresult = 1
                  return
              endif
          endif
      endif

      return
      end subroutine zmdiv_sc

      subroutine zmdiv_unov(ma, mb, mc, md, mz)

!  Check special cases where at least one of ma, mb, mc, md is underflow or overflow.

!  Return mz as the result.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md, mz(2)
      intent (inout) :: mz
      intent (in) :: ma, mb, mc, md

      type(multi), save :: mxy(7)
      double precision :: a_xe, a_xf, b_xe, b_xf, c_xe, c_xf, d, d_xe, d_xf, t1, t2, t3, t4

      call fmsqr(mc, mxy(4))
      call fmsqr(md, mxy(5))
      call fmadd(mxy(4), mxy(5), mxy(3))
      call fmmpy(ma, mc, mxy(4))
      call fmmpy(mb, md, mxy(5))
      call fmadd(mxy(4), mxy(5), mxy(6))
      call fmdiv(mxy(6), mxy(3), mz(1))
      call fmmpy(mb, mc, mxy(4))
      call fmmpy(ma, md, mxy(5))
      call fmsub(mxy(4), mxy(5), mxy(6))
      call fmdiv(mxy(6), mxy(3), mz(2))
      if (mz(1)%mp(2) /= munkno .and. mz(2)%mp(2) /= munkno) return
      if (.not. ( (mz(1)%mp(2) == munkno .and. mz(1)%mp(5) >= 0) .or.  &
                  (mz(2)%mp(2) == munkno .and. mz(2)%mp(5) >= 0) )) return

      call fmsqr(ma, mxy(4))
      call fmsqr(mb, mxy(5))
      call fmadd(mxy(4), mxy(5), mxy(2))
      call fmsqr(mc, mxy(4))
      call fmsqr(md, mxy(5))
      call fmadd(mxy(4), mxy(5), mxy(3))
      call fmdiv(mxy(2), mxy(3), mxy(5))
      call fmovun_xexf(ma, a_xe, a_xf)
      call fmovun_xexf(mb, b_xe, b_xf)
      call fmovun_xexf(mc, c_xe, c_xf)
      call fmovun_xexf(md, d_xe, d_xf)
      if (huge(mbase)/mexpov > 1.0d+20) then
          d = 1.0d+10
      else
          d = 4
      endif
      t1 = max(a_xe, b_xe) - max(c_xe, d_xe)
      if (t1 >= (huge(mbase)/d)/2 .or. t1 <= -(huge(mbase)/d)/2) then
          mxy(5)%mp(4) = t1
          call fmeq(mxy(5), mxy(4))
      else
          call fmsqrt(mxy(5), mxy(4))
      endif
      if (mxy(4)%mp(2) /= munkno .and. abs(mxy(4)%mp(2)) == mexpov) then
          t3 = dlogmb*(a_xe - b_xe)/2 + log(a_xf)
          t4 = dlogmb*(b_xe - a_xe)/2 + log(b_xf)
          if (log(tiny(t3)) <= t3 .and. t3 <= log(huge(t3))) then
              t3 = ma%mp(1) * dble(mbase)**( (a_xe - b_xe)/2 ) * a_xf
              t4 = mb%mp(1) * dble(mbase)**( (b_xe - a_xe)/2 ) * b_xf
              t1 = atan2(t4, t3)
          else
              if (ma%mp(1) > 0 .and. a_xe > b_xe) then
                  t1 = 0
              else if (mb%mp(1) > 0 .and. b_xe > a_xe) then
                  t1 = asin(1.0d0)
              else if (mb%mp(1) < 0 .and. b_xe > a_xe) then
                  t1 = asin(-1.0d0)
              else if (ma%mp(1) < 0 .and. mb%mp(1) > 0 .and. a_xe > b_xe) then
                  t1 = acos(-1.0d0)
              else
                  t1 = -acos(-1.0)
              endif
          endif

          t3 = dlogmb*(c_xe - d_xe)/2 + log(c_xf)
          t4 = dlogmb*(d_xe - c_xe)/2 + log(d_xf)
          if (log(tiny(t3)) <= t3 .and. t3 <= log(huge(t3))) then
              t3 = mc%mp(1) * dble(mbase)**( (c_xe - d_xe)/2 ) * c_xf
              t4 = md%mp(1) * dble(mbase)**( (d_xe - c_xe)/2 ) * d_xf
              t2 = atan2(t4, t3)
          else
              if (mc%mp(1) > 0 .and. c_xe > d_xe) then
                  t2 = 0
              else if (md%mp(1) > 0 .and. d_xe > c_xe) then
                  t2 = asin(1.0d0)
              else if (md%mp(1) < 0 .and. d_xe > c_xe) then
                  t2 = asin(-1.0d0)
              else if (mc%mp(1) < 0 .and. md%mp(1) > 0 .and. c_xe > d_xe) then
                  t2 = acos(-1.0d0)
              else
                  t2 = -acos(-1.0)
              endif
          endif

          call fmdp2m(cos(t1-t2), mxy(3))
          call fmmpy(mxy(3), mxy(4), mz(1))
          call fmdp2m(sin(t1-t2), mxy(3))
          call fmmpy(mxy(3), mxy(4), mz(2))
          if (mz(1)%mp(2) /= munkno .and. mz(2)%mp(2) /= munkno) return
      else if (abs(mxy(4)%mp(2)) < mexpov) then
          call fmovun_xexf(ma, a_xe, a_xf)
          call fmovun_xexf(mb, b_xe, b_xf)
          call fmovun_xexf(mc, c_xe, c_xf)
          call fmovun_xexf(md, d_xe, d_xf)
          call fmmpy(ma, mc, mxy(1))
          call fmmpy(mb, md, mxy(2))
          call fmmpy(ma, md, mxy(3))
          call fmmpy(mb, mc, mxy(4))
          call fmadd(mxy(1), mxy(2), mz(1))
          call fmsub(mxy(4), mxy(3), mz(2))
          if (a_xe+c_xe > b_xe+d_xe + ndig) call fmeq(mxy(1), mz(1))
          if (b_xe+d_xe > a_xe+c_xe + ndig) call fmeq(mxy(2), mz(1))
          if (a_xe+d_xe > b_xe+c_xe + ndig) call fmmpyi(mxy(3), -1, mz(2))
          if (b_xe+c_xe > a_xe+d_xe + ndig) call fmeq(mxy(4), mz(2))
          call fmsqr(mc, mxy(5))
          call fmsqr(md, mxy(6))
          call fmadd(mxy(5), mxy(6), mxy(7))
          call fmdiv_r1(mz(1), mxy(7))
          call fmdiv_r1(mz(2), mxy(7))
          if (mz(1)%mp(2) /= munkno .and. mz(2)%mp(2) /= munkno) return
      endif

      call zmunknown(mz)

      return
      end subroutine zmdiv_unov

      subroutine zmdivi(ma, integ, mb)

!  mb = ma / integ        Divide by one-word (real) integer.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      integer :: integ
      intent (in) :: ma, integ
      intent (inout) :: mb

      integer :: kovun, kwrnsv, ntrsav

      call zmalloc(mb, ndig+2)

      if ((ma(1)%mp(2) == munkno .and. ma(1)%mp(5) >= 0) .or.  &
          (ma(2)%mp(2) == munkno .and. ma(2)%mp(5) >= 0)) then
          ncall = ncall + 1
          namest(ncall) = 'ZMDIVI   '
          call zmntr_inp1i(ma, integ)
          call zmunknown(mb)
          kflag = -4
          call zmntr_out1(mb)
          ncall = ncall - 1
          return
      endif

      ncall = ncall + 1
      if (ntrace /= 0) then
          namest(ncall) = 'ZMDIVI'
          call zmntr_inp1i(ma, integ)
      endif
      kovun = 0
      if (ma(1)%mp(2) == mexpov .or. ma(1)%mp(2) == mexpun) kovun = 1
      if (ma(2)%mp(2) == mexpov .or. ma(2)%mp(2) == mexpun) kovun = 1
      if (ma(1)%mp(2) == munkno .or. ma(2)%mp(2) == munkno) kovun = 2

!             Force fmdivi to use more guard digits for user calls.

      ncall = ncall - 1
      ntrsav = ntrace
      ntrace = 0
      kwrnsv = kwarn
      kwarn = 0

      call fmdivi(ma(1), integ, mb(1))
      call fmdivi(ma(2), integ, mb(2))

      ntrace = ntrsav
      kwarn = kwrnsv
      ncall = ncall + 1
      if (ntrace /= 0) namest(ncall) = 'ZMDIVI'
      if (mb(1)%mp(2) == munkno .or. mb(2)%mp(2) == munkno) then
          kflag = -4
      else if (mb(1)%mp(2) == mexpov .or. mb(2)%mp(2) == mexpov) then
          kflag = -5
      else if (mb(1)%mp(2) == mexpun .or. mb(2)%mp(2) == mexpun) then
          kflag = -6
      endif
      if ((mb(1)%mp(2) == munkno .and. kovun /= 2) .or.  &
          (mb(2)%mp(2) == munkno .and. kovun /= 2) .or.  &
          (mb(1)%mp(2) == mexpun .and. kovun == 0) .or.  &
          (mb(2)%mp(2) == mexpun .and. kovun == 0) .or.  &
          (mb(1)%mp(2) == mexpov .and. kovun == 0) .or.  &
          (mb(2)%mp(2) == mexpov .and. kovun == 0)) then
          namest(ncall) = 'ZMDIVI'
          call fmwarn
      endif
      if (ntrace /= 0) call zmntr_out1(mb)
      ncall = ncall - 1

      return
      end subroutine zmdivi

      subroutine zmdivi_r1(ma, ival)

!  ma = ma / ival

      use fmvals
      implicit none

      type(multi) :: ma(2)
      integer :: ival
      intent (inout) :: ma
      intent (in) :: ival

      type(multi), save :: mt(2)

      call zmdivi(ma, ival, mt)
      call zmeq(mt, ma)

      return
      end subroutine zmdivi_r1

      subroutine zmenter1(ma, kovun, mxsave, ndsave)

!  At the start of a function this routine raises precision, and extends the
!  overflow/underflow threshold.

      use fmvals
      implicit none

      type(multi) :: ma(2)
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (in) :: ma
      intent (inout) :: kovun, mxsave, ndsave

      integer :: k

      if (mblogs /= mbase) call fmcons
      kovun = 0
      if (ma(1)%mp(2) == mexpov .or. ma(1)%mp(2) == mexpun) kovun = 1
      if (ma(2)%mp(2) == mexpov .or. ma(2)%mp(2) == mexpun) kovun = 1
      if (ma(1)%mp(2) == munkno .or. ma(2)%mp(2) == munkno) kovun = 2

!             Increase the working precision.

      ncall = ncall + 1
      ndsave = ndig
      if (ncall == 1) then
          k = max(ngrd52, 2)
          ndig = max(ndig+k, 3)
          if (mbase >= 100*abs(ma(1)%mp(3)) .or.  &
              mbase >= 100*abs(ma(2)%mp(3))) then
              ndig = ndig + 1
          endif
          kround1 = kround
      else if (kround1 /= 1) then
          ndig = ndig + ngrd22
      endif

!             Extend the overflow/underflow threshold.

      mxsave = mxexp
      mxexp = mxexp2

      return
      end subroutine zmenter1

      subroutine zmenter2(ma, mb, kovun, mxsave, ndsave)

!  At the start of a function this routine raises precision, and extends the
!  overflow/underflow threshold.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (in) :: ma, mb
      intent (inout) :: kovun, mxsave, ndsave

      integer :: k

      if (mblogs /= mbase) call fmcons
      kovun = 0
      if (ma(1)%mp(2) == mexpov .or. ma(1)%mp(2) == mexpun) kovun = 1
      if (ma(2)%mp(2) == mexpov .or. ma(2)%mp(2) == mexpun) kovun = 1
      if (mb(1)%mp(2) == mexpov .or. mb(1)%mp(2) == mexpun) kovun = 1
      if (mb(2)%mp(2) == mexpov .or. mb(2)%mp(2) == mexpun) kovun = 1
      if (ma(1)%mp(2) == munkno .or. ma(2)%mp(2) == munkno) kovun = 2
      if (mb(1)%mp(2) == munkno .or. mb(2)%mp(2) == munkno) kovun = 2

!             Increase the working precision.

      ncall = ncall + 1
      ndsave = ndig
      if (ncall == 1) then
          k = max(ngrd52, 2)
          ndig = max(ndig+k, 3)
          if (mbase >= 100*abs(ma(1)%mp(3)) .or.  &
              mbase >= 100*abs(ma(2)%mp(3))) then
              ndig = ndig + 1
          endif
          kround1 = kround
      else if (kround1 /= 1) then
          ndig = ndig + ngrd22
      endif

!             Extend the overflow/underflow threshold.

      mxsave = mxexp
      mxexp = mxexp2

      return
      end subroutine zmenter2

      subroutine zmeq(ma, mb)

!  mb = ma

!  This is the standard form of equality, where ma and mb both have precision ndig.
!  use zmequ for assignments that also change precision.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      call fmeq(ma(1), mb(1))
      call fmeq(ma(2), mb(2))

      return
      end subroutine zmeq

      subroutine zmequ(ma, mb, nda, ndb)

!  Set mb (having ndb digits) equal to ma (having nda digits).

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      integer :: nda, ndb
      intent (in) :: nda, ndb
      intent (in) :: ma
      intent (inout) :: mb

      call fmequ(ma(1), mb(1), nda, ndb)
      call fmequ(ma(2), mb(2), nda, ndb)

      return
      end subroutine zmequ

      subroutine zmequ_r1(ma, nda, ndb)

!  Change precision of ma from nda digits on input to ndb digits on output.

!  If ndb is less than nda the result is rounded to ndb digits.

!  If ndb is greater than nda the result has zero digits padded on the right.

      use fmvals
      implicit none

      type(multi) :: ma(2)
      integer :: nda, ndb
      intent (in) :: nda, ndb
      intent (inout) :: ma

      call fmequ_r1(ma(1), nda, ndb)
      call fmequ_r1(ma(2), nda, ndb)

      return
      end subroutine zmequ_r1

      subroutine zmerf(ma, mb)

!  mb = erf(ma)    Error function.

!  2/sqrt(pi) * integral from 0 to ma of e**(-t**2) dt.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(2, 15), mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmerf_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call zmerf_m(ma, mxy, mresult, ndsave, numtry, retry)
         if (retry) then
             retry = .false.
             call zmcheck_accuracy(mresult, ndsave, retry)
         endif
         numtry = numtry + 1
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmerf

      subroutine zmerf_m(ma, mxy, mresult, ndsave, numtry, retry)

!  Method selection for computing erf(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(2, 15), mresult(2)
      integer :: ndsave, numtry
      logical :: retry
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, numtry, retry

      double precision :: c1, c2, c4, x, xe, xk
      integer :: kflagx, nmethd
      logical, external :: fmcomp

      retry = .true.

      call zmequ(ma, mxy(1:2, 1), ndsave, ndig)

!             Check for special cases.

      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
          call zmeq(mxy(1:2, 1), mresult)
          retry = .false.
          return
      endif
      call zmabs(mxy(1:2, 1), mxy(1, 2))
      call fmovun_xe(mxy(1, 2), xe)
      if (xe <= -ndig/2) then
          call fmpi(mxy(1, 3))
          call fmsqrt(mxy(1, 3), mxy(1, 4))
          call fmi2m(2, mxy(1, 5))
          call fmdiv(mxy(1, 5), mxy(1, 4), mxy(1, 6))
          call fmmpy(mxy(1, 1), mxy(1, 6), mxy(1, 3))
          call fmmpy(mxy(2, 1), mxy(1, 6), mxy(2, 3))
          call zmeq(mxy(1:2, 3), mresult)
          return
      endif

!             x is a double precision approximation to the size of input argument to this function.

      call zmabs(mxy(1:2, 1), mxy(1, 4))
      call fmm2dp(mxy(1, 4), x)
      kflagx = kflag
      call fmovun_xe(mxy(1, 4), xe)
      if (kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax**0.33d0
          kflagx = 0
      else if (kflag == 0 .and. x < 1.0d0/dpmax**0.33d0) then
          x = 1.0d0/dpmax**0.33d0
      endif
      if (kflag /= 0 .and. xe > 0) then
          x = dpmax**0.33d0
          kflagx = 0
      else if (kflag == 0 .and. x > dpmax**0.33d0) then
          x = dpmax**0.33d0
      endif

!             Determine which method to use.

!             nmethd = 1 use the convergent series,
!                    = 2 use a 2nd convergent series,
!                    = 3 use a continued fraction expansion,
!                    = 4 use an asymptotic series.

      xk = max(3.0d0, (2*x**2 + 1)/2)
      xk = -xk + log(2*xk-1)*(2*xk-0.5d0) + log(xk-1)*(-xk+0.5d0) - log(2.0d0)*(2*xk-1) -  &
           log(x)*(2*xk+1)
      if (-xk/dlogmb > ndig+(3+ndig/20)*ngrd52) then
          nmethd = 4
      else
          c4 = 5.0
          xk = 0.0
          do while (-xk/dlogmb <= ndig+(3+ndig/20)*ngrd52)
             c4 = 2 * c4
             xk = max(3.0d0, (2*c4**2 + 1)/2)
             xk = -xk + log(2*xk-1)*(2*xk-0.5d0) + log(xk-1)*(-xk+0.5d0) - log(2.0d0)*(2*xk-1) -  &
                  log(c4)*(2*xk+1)
          enddo
          c1 = c4/2
          do while (c4-c1 > 0.1)
             c2 = (c1 + c4) / 2
             xk = max(3.0d0, (2*c2**2 + 1)/2)
             xk = -xk + log(2*xk-1)*(2*xk-0.5d0) + log(xk-1)*(-xk+0.5d0) - log(2.0d0)*(2*xk-1) -  &
                  log(c2)*(2*xk+1)
             if (-xk/dlogmb > ndig+(3+ndig/20)*ngrd52) then
                 c4 = c2
             else
                 c1 = c2
             endif
          enddo
          if (x > 0.75*c4 .and. x > c4 - 5) then
              nmethd = 3
          else
              call fmdiv(mxy(2, 1), mxy(1, 1), mxy(1, 15))
              call fmabs(mxy(1, 15), mxy(2, 15))
              call fmdp2m(1.5d0, mxy(1, 15))
              if (fmcomp(mxy(2, 15), '>', mxy(1, 15))) then
                  if (x > 0.70*c4) then
                      nmethd = 2
                  else
                      nmethd = 1
                  endif
              else
                  if (x > 6.0) then
                      nmethd = 2
                  else
                      nmethd = 1
                  endif
              endif
          endif
      endif

      if (nmethd == 1) then
          call zmerf_m1(mxy, mresult, ndsave, numtry, kflagx, x)
      else if (nmethd == 2) then
          call zmerf_m2(mxy, mresult, ndsave, numtry, kflagx, x)
      else if (nmethd == 3) then
          call zmerf_m3(mxy, mresult, ndsave, numtry, kflagx, x)
      else if (nmethd == 4) then
          call zmerf_m4(mxy, mresult, ndsave, numtry, kflagx, x)
      endif

      return
      end subroutine zmerf_m

      subroutine zmerf_m1(mxy, mresult, ndsave, numtry, kflagx, x)

!  Method 1 for computing erf(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult

      double precision :: xe
      integer :: iextra, j, j2, kl, nd, nd1, ndsav1, nterm
      type(multi), save :: mjsums(2, ljsums)
      double precision, external :: fmnterms

!             Method 1.  Use the (-1)**n x**(2n+1) / n! / (2n+1) series.

!                        = ( 2 / sqrt(pi) ) * ( x - x**3/1! + x**5/2! - x**7/3! + ... )

      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig+ngrd52)
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, ndig)

!             If ma is large in magnitude or close to the real line, use more guard digits.

      call fmsqr(mxy(1, 1), mxy(1, 15))
      call fmsqr(mxy(2, 1), mxy(2, 15))
      call fmmpy(mxy(1, 1), mxy(2, 1), mxy(1, 14))
      call fmst2m('-4.409869', mxy(1, 13))

      call fmst2m(' 0.000918', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(1, 1))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m(' 0.002513', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(2, 1))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m(' 0.124040', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(1, 15))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m('-0.000288', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(1, 14))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m(' 0.001638', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(2, 15))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmm2i(mxy(1, 13), iextra)
      iextra = max(0, nint((iextra+3) * 16.11809565d0 / dlogmb)+1)
      if (iextra > 0) then
          call zmequ_r1(mxy(1:2, 1), ndig, ndig+iextra)
      endif
      ndig = ndig + iextra
      if (kflagx == 0) then
          j2 = int(0.66*sqrt(fmnterms(x**2, 1, 0, 0, 1)) - 0.8)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call zmi2m(1, mxy(1:2, 6))
      call zmi2m(1, mjsums(1:2, 1))

      do j = 2, j2
         if (nterm > 1) then
             call zmdivi_r1(mxy(1:2, 6), nterm)
         endif
         call zmdivi(mxy(1:2, 6), 2*nterm+1, mjsums(1:2, j))
         nterm = nterm + 1
      enddo
      call zmabs(mxy(1:2, 1), mxy(1, 15))
      call fmovun_xe(mxy(1, 15), xe)
      if (xe < -ndig) then
          kl = 0
      else
          kl = 1
          call zmipwr(mxy(1:2, 1), 2*j2, mxy(1:2, 5))
      endif

      do while (kl == 1)
         call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 5))
         do j = 1, j2
            call zmdivi_r1(mxy(1:2, 6), nterm)
            call zmdivi(mxy(1:2, 6), 2*nterm+1, mxy(1:2, 4))
            ndig = ndsav1
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 4))
            if (kflag == 1 .or.                                                    &
                (mjsums(1, j)%mp(2) == munkno .and. mjsums(1, j)%mp(5) >= 0) .or.  &
                (mjsums(2, j)%mp(2) == munkno .and. mjsums(2, j)%mp(5) >= 0)) then
                kl = 0
                exit
            endif
            nd = mjsums(1, j)%mp(2)-mxy(1, 4)%mp(2)
            nd1 = mjsums(2, j)%mp(2)-mxy(2, 4)%mp(2)
            nd = ndsav1 - int(min(nd, nd1))
            ndig = min(ndsav1, nd)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
            nterm = nterm + 1
         enddo
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call zmsqr(mxy(1:2, 1), mxy(1:2, 4))
      call zmnegate(mxy(1:2, 4))
      call zmeq(mjsums(1:2, j2), mxy(1:2, 5))

      do j = 2, j2
         call zmmpy(mxy(1:2, 5), mxy(1:2, 4), mxy(1:2, 15))
         call zmadd(mxy(1:2, 15), mjsums(1:2, j2-j+1), mxy(1:2, 5))
      enddo

      call zmmpy_r1(mxy(1:2, 5), mxy(1:2, 1))

      call fmpi(mxy(1, 4))
      call fmi2m(0, mxy(2, 4))
      call zmsqrt(mxy(1:2, 4), mxy(1:2, 3))
      call zmmpyi(mxy(1:2, 5), 2, mxy(1:2, 4))
      call zmdiv_r2(mxy(1:2, 4), mxy(1:2, 3))

      call zmeq(mxy(1:2, 3), mresult)

      return
      end subroutine zmerf_m1

      subroutine zmerf_m2(mxy, mresult, ndsave, numtry, kflagx, x)

!  Method 2 for computing erf(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult

      double precision :: xe
      integer :: iextra, j, j2, kl, nd, nd1, ndsav1, nterm
      type(multi), save :: mjsums(2, ljsums)
      double precision, external :: fmnterms

!             Method 2.  Use the x**(2n+1) * 2**(n+1) / (1*3*5*...*(2n+1)) series.

      iextra = 0
      call fmsqr(mxy(1, 1), mxy(1, 15))
      call fmsqr(mxy(2, 1), mxy(2, 15))
      call fmmpy(mxy(1, 1), mxy(2, 1), mxy(1, 14))
      call fmst2m('-2.156685', mxy(1, 13))

      call fmst2m('-0.000490', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(1, 1))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m('-0.000013', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(2, 1))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m(' 0.062094', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(1, 15))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m(' 0.000027', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(1, 14))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m(' 0.062030', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(2, 15))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmm2i(mxy(1, 13), iextra)
      iextra = max(0, nint((iextra+3) * 16.11809565d0 / dlogmb)+1)
      ndig = ndig + iextra
      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig) + 1
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, ndig)
      if (kflagx == 0) then
          j2 = int(0.51*sqrt(fmnterms(2*x, 2, -1, 0, 1)))
      else
          j2 = 1
      endif
      j2 = max(1, min(ljsums, j2))
      ndsav1 = ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call zmmpyi(mxy(1:2, 1), 2, mxy(1:2, 6))
      call zmeq(mxy(1:2, 6), mjsums(1:2, 1))
      do j = 2, j2
         call zmmpyi_r1(mxy(1:2, 6), 2)
         call zmdivi_r1(mxy(1:2, 6), 2*nterm+1)
         call zmeq(mxy(1:2, 6), mjsums(1:2, j))
         nterm = nterm + 1
      enddo
      call zmabs(mxy(1:2, 1), mxy(1, 15))
      call fmovun_xe(mxy(1, 15), xe)
      if (xe < -ndig) then
          kl = 0
      else
          kl = 1
          call zmipwr(mxy(1:2, 1), 2*j2, mxy(1:2, 5))
      endif

      do while (kl == 1)
         call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 5))
         do j = 1, j2
            call zmmpyi(mxy(1:2, 6), 2, mxy(1:2, 15))
            call zmdivi(mxy(1:2, 15), 2*nterm+1, mxy(1:2, 6))
            ndig = ndsav1
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 6))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            nd = mjsums(1, j)%mp(2)-mxy(1, 6)%mp(2)
            nd1 = mjsums(2, j)%mp(2)-mxy(2, 6)%mp(2)
            nd = ndsav1 - int(min(nd, nd1))
            ndig = min(ndsav1, nd)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
            nterm = nterm + 1
         enddo
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call zmsqr(mxy(1:2, 1), mxy(1:2, 6))
      call zmeq(mjsums(1:2, j2), mxy(1:2, 5))
      do j = 2, j2
         call zmmpy(mxy(1:2, 5), mxy(1:2, 6), mxy(1:2, 15))
         call zmadd(mxy(1:2, 15), mjsums(1:2, j2-j+1), mxy(1:2, 5))
      enddo

      call fmpi(mxy(1, 4))
      call fmi2m(0, mxy(2, 4))
      call zmsqrt(mxy(1:2, 4), mxy(1:2, 3))
      call zmdiv_r2(mxy(1:2, 5), mxy(1:2, 3))
      call zmexp(mxy(1:2, 6), mxy(1:2, 4))
      call zmdiv_r1(mxy(1:2, 3), mxy(1:2, 4))

      call zmeq(mxy(1:2, 3), mresult)

      return
      end subroutine zmerf_m2

      subroutine zmerf_m3(mxy, mresult, ndsave, numtry, kflagx, x)

!  Method 3 for computing erf(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult

      integer :: k, ksma, kt, nd, nd1, ndsav1, ndsav2, nterms
      logical, external :: fmcomp

!             Method 3.  Continued fraction expansion (asymptotic).
!                        Used for Re(x) > 0, erf(x) = -erf(-x) otherwise.

!                                  erf(x) = 1 + (-exp(-x**2)/sqrt(pi)) /
!                                                                   x + 1 /
!                                                                     2*x + 2 /
!                                                                           x + 3 /
!                                                                             2*x + 4 /
!                                                                                   x + 5 ...

      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig) + 1
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, ndig)
      ndsav1 = ndig
      ksma = mxy(1, 1)%mp(1)
      if (ksma < 0) then
          call zmnegate(mxy(1:2, 1))
      endif

      call zmeq(mxy(1:2, 1), mxy(1:2, 2))

      call zmsqr(mxy(1:2, 2), mxy(1:2, 4))
      call zmmpyi(mxy(1:2, 4), -1, mxy(1:2, 15))
      call zmexp(mxy(1:2, 15), mxy(1:2, 10))
      call zmmpyi(mxy(1:2, 10), -1, mxy(1:2, 15))
      call fmpi(mxy(1, 10))
      call fmsqrt_r1(mxy(1, 10))
      call fmi2m(0, mxy(2, 10))
      call zmdiv_r2(mxy(1:2, 15), mxy(1:2, 10))
      call zmdiv_r1(mxy(1:2, 10), mxy(1:2, 2))
      call zmi2m(-31, mxy(1:2, 13))

      call fmi2m(1, mxy(1, 15))
      call fmulp(mxy(1, 15), mxy(2, 15))
      call fmdiv(mxy(1, 1), mxy(2, 1), mxy(1, 15))
      call fmsqr_r1(mxy(1, 15))
      if (fmcomp(mxy(1, 15), '<', mxy(2, 15))) then
          call zmi2m(0, mxy(1:2, 15))
      else
          call zmi2m(1, mxy(1:2, 15))
      endif
      call zmadd(mxy(1:2, 15), mxy(1:2, 10), mxy(1:2, 14))
      call zmi2m(1, mxy(1:2, 8))
      call zmeq(mxy(1:2, 2), mxy(1:2, 9))
      nterms = int(intmax/10)

!             Continued fraction loop.

      ndsav2 = ndig
      do k = 3, nterms
         call zmmpyi(mxy(1:2, 2), 1+mod(k, 2), mxy(1:2, 11))
         call zmmpy_r1(mxy(1:2, 11), mxy(1:2, 9))
         call zmmpyi(mxy(1:2, 8), k-2, mxy(1:2, 12))
         call zmadd(mxy(1:2, 11), mxy(1:2, 12), mxy(1:2, 7))
         call zmmpy_r1(mxy(1:2, 10), mxy(1:2, 12))
         call zmdiv_r1(mxy(1:2, 10), mxy(1:2, 7))
         call zmnegate(mxy(1:2, 10))
         call zmeq(mxy(1:2, 9), mxy(1:2, 8))
         call zmeq(mxy(1:2, 7), mxy(1:2, 9))
         ndig = ndsav2
         call zmadd_r1(mxy(1:2, 14), mxy(1:2, 10))

!             Check for convergence.

         if (kflag == 1 .and. k > 2) then
             exit
         endif
         kt = max(1000, int(2*alogmt*ndsave))
         if (k > kt) then
             if (ksma < 0) then
                 call zmnegate(mxy(1:2, 1))
             endif
             call zmerf_m2(mxy, mresult, ndsave, numtry, kflagx, x)
             return
         endif
         call zmeq(mxy(1:2, 10), mxy(1:2, 13))
         nd = mxy(1, 14)%mp(2)-mxy(1, 10)%mp(2)
         nd1 = mxy(2, 14)%mp(2)-mxy(2, 10)%mp(2)
         nd = min(ndsav2, max(ngrd22, ndsav2-int(min(nd, nd1))))
         ndig = nd
         if (k == nterms) then
             call zmunknown(mresult)
             kflag = -4
             return
         endif
      enddo

      call zmeq(mxy(1:2, 14), mxy(1:2, 3))
      if (ksma < 0) then
          call zmnegate(mxy(1:2, 3))
      endif
      ndig = ndsav1

      call zmeq(mxy(1:2, 3), mresult)

      return
      end subroutine zmerf_m3

      subroutine zmerf_m4(mxy, mresult, ndsave, numtry, kflagx, x)

!  Method 4 for computing erf(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult

      double precision :: xe
      integer :: j, j2, kl, ksma, kt, nd, nd1, ndsav1, nterm
      type(multi), save :: mjsums(2, ljsums)
      double precision, external :: fmnterms
      logical, external :: fmcomp

!             Method 4.  Asymptotic series
!                        1 - ( Exp(-x**2) / Sqrt(Pi) ) *
!                            Sum_{k=0}**Infinity (  (-1)**k * poch(1/2,k) / x**(2*k+1) )

!             The series is  1/x - (1/2) / x**3  +  ( 1*3 )/(2**2) / x**5 - ( 1*3*5 )/(2**3) / x**7
!                            + ...

      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig-1)
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, ndig)
      ksma = mxy(1, 1)%mp(1)
      if (ksma < 0) then
          call zmnegate(mxy(1:2, 1))
      endif
      if (kflagx == 0) then
          j2 = int(0.66*sqrt(fmnterms(x**2, 1, 0, 0, 0)) - 0.8)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call zmsqr(mxy(1:2, 1), mxy(1:2, 15))
      call zmmpyi(mxy(1:2, 15), 2, mxy(1:2, 7))
      call zmi2m(1, mxy(1:2, 8))
      call zmdiv(mxy(1:2, 8), mxy(1:2, 7), mxy(1:2, 6))
      call zmi2m(1, mjsums(1:2, 1))
      do j = 2, j2
         nterm = nterm + 1
         call zmmpyi_r1(mxy(1:2, 8), 2*nterm-3)
         call zmeq(mxy(1:2, 8), mjsums(1:2, j))
      enddo
      call zmabs(mxy(1:2, 1), mxy(1, 15))
      call fmovun_xe(mxy(1, 15), xe)
      if (xe < -ndig) then
          kl = 0
      else
          kl = 1
          call zmipwr(mxy(1:2, 6), j2, mxy(1:2, 7))
          call zmi2m(-31, mxy(1:2, 13))
      endif

      do while (kl == 1)
         call zmmpy_r2(mxy(1:2, 7), mxy(1:2, 8))
         do j = 1, j2
            nterm = nterm + 1
            call zmmpyi_r1(mxy(1:2, 8), 2*nterm-3)
            ndig = ndsav1
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 8))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            kt = max(19000, int(6*alogmt*ndsave))
            if (nterm > kt) then
                call zmabs(mxy(1:2, 8), mxy(1, 15))
                call zmabs(mxy(1:2, 13), mxy(2, 15))
                if (fmcomp(mxy(1, 15), '>', mxy(2, 15))) then
                    if (ksma < 0) then
                        call zmnegate(mxy(1:2, 1))
                    endif
                    call zmerf_m2(mxy, mresult, ndsave, numtry, kflagx, x)
                    return
                endif
            endif
            call zmeq(mxy(1:2, 8), mxy(1:2, 13))
            nd = mjsums(1, j)%mp(2)-mxy(1, 8)%mp(2)
            nd1 = mjsums(2, j)%mp(2)-mxy(2, 8)%mp(2)
            nd = ndsav1 - int(min(nd, nd1))
            ndig = min(ndsav1, nd)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         enddo
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call zmmpyi(mxy(1:2, 6), -1, mxy(1:2, 4))
      call zmi2m(1, mxy(1:2, 5))
      do j = 2, j2
         call zmmpy_r1(mxy(1:2, 5), mxy(1:2, 4))
         call zmmpy(mxy(1:2, 5), mjsums(1:2, j), mxy(1:2, 15))
         call zmadd(mxy(1:2, 15), mjsums(1:2, 1), mxy(1:2, 8))
         call zmeq(mxy(1:2, 8), mjsums(1:2, 1))
      enddo
      call fmmpy(mxy(1, 1), mxy(2, 1), mxy(2, 15))
      call fmmpyi_r1(mxy(2, 15), -2)
      call fmi2m(0, mxy(1, 15))
      call zmexp(mxy(1:2, 15), mxy(1:2, 14))
      call zmmpy(mjsums(1:2, 1), mxy(1:2, 14), mxy(1:2, 15))
      call fmpi(mxy(1, 4))
      call fmsqrt(mxy(1, 4), mxy(1, 8))
      call fmi2m(0, mxy(2, 8))
      call zmmpy(mxy(1:2, 8), mxy(1:2, 1), mxy(1:2, 14))
      call zmdiv(mxy(1:2, 15), mxy(1:2, 14), mxy(1:2, 13))
      call fmadd(mxy(2, 1), mxy(1, 1), mxy(1, 12))
      call fmsub(mxy(2, 1), mxy(1, 1), mxy(1, 11))
      call fmmpy(mxy(1, 12), mxy(1, 11), mxy(1, 10))
      call fmexp(mxy(1, 10), mxy(1, 12))
      call fmmpy(mxy(1, 13), mxy(1, 12), mxy(1, 4))
      call fmmpy(mxy(2, 13), mxy(1, 12), mxy(2, 4))

      if (mxy(1, 4)%mp(2) == munkno .and. mxy(1, 4)%mp(5) >= 0) then
          call fmabs(mxy(1, 13), mxy(1, 14))
          call fmln(mxy(1, 14), mxy(1, 15))
          call fmadd(mxy(1, 10), mxy(1, 15), mxy(1, 14))
          call fmexp(mxy(1, 14), mxy(1, 4))
          mxy(1, 4)%mp(1) = mxy(1, 13)%mp(1)
      endif
      if (mxy(2, 4)%mp(2) == munkno .and. mxy(2, 4)%mp(5) >= 0) then
          call fmabs(mxy(2, 13), mxy(1, 14))
          call fmln(mxy(1, 14), mxy(1, 15))
          call fmadd(mxy(1, 10), mxy(1, 15), mxy(1, 14))
          call fmexp(mxy(1, 14), mxy(2, 4))
          mxy(2, 4)%mp(1) = mxy(2, 13)%mp(1)
      endif
      call fmi2m(1, mxy(1, 15))
      call fmulp(mxy(1, 15), mxy(2, 15))
      call fmdiv(mxy(1, 1), mxy(2, 1), mxy(1, 15))
      call fmsqr_r1(mxy(1, 15))
      if (fmcomp(mxy(1, 15), '<', mxy(2, 15))) then
          call zmi2m(0, mxy(1:2, 15))
          call zmsub(mxy(1:2, 15), mxy(1:2, 4), mxy(1:2, 3))
      else
          call zmi2m(1, mxy(1:2, 15))
          call zmsub(mxy(1:2, 15), mxy(1:2, 4), mxy(1:2, 3))
      endif

      if (ksma < 0) then
          call zmnegate(mxy(1:2, 3))
      endif

      call zmeq(mxy(1:2, 3), mresult)

      return
      end subroutine zmerf_m4

      subroutine zmerf_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = erf(ma).

!  kresult = 1 is returned if a special case gives the value of erf(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMERF    '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

!             If ma is real, use fmerf.

      if (malocal(2)%mp(3) == 0) then
          call fmerf(malocal(1), mresult(1))
          call fmi2m(0, mresult(2))
          kresult = 1
          return
      endif

      return
      end subroutine zmerf_sc

      subroutine zmerfc(ma, mb)

!  mb = erfc(ma)    Complimentary error function.

!  1 - 2/sqrt(pi) * integral from 0 to ma of e**(-t**2) dt.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(2, 15), mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmerfc_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call zmerfc_m(ma, mxy, mresult, ndsave, numtry, retry)
         if (retry) then
             retry = .false.
             call zmcheck_accuracy(mresult, ndsave, retry)
         endif
         numtry = numtry + 1
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmerfc

      subroutine zmerfc_m(ma, mxy, mresult, ndsave, numtry, retry)

!  Method selection for computing erfc(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(2, 15), mresult(2)
      integer :: ndsave, numtry
      logical :: retry
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, numtry, retry

      double precision :: c1, c2, c4, x, xe, xk
      integer :: kflagx, nmethd
      logical, external :: fmcomp

      retry = .true.

      call zmequ(ma, mxy(1:2, 1), ndsave, ndig)

!             Check for special cases.

      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
          call zmeq(mxy(1:2, 1), mresult)
          retry = .false.
          return
      endif
      call zmabs(mxy(1:2, 1), mxy(1, 2))
      call fmovun_xe(mxy(1, 2), xe)
      if (xe <= -ndig/2) then
          call fmpi(mxy(1, 3))
          call fmsqrt(mxy(1, 3), mxy(1, 4))
          call fmi2m(2, mxy(1, 5))
          call fmdiv(mxy(1, 5), mxy(1, 4), mxy(1, 6))
          call fmmpy(mxy(1, 1), mxy(1, 6), mxy(1, 5))
          call fmmpy(mxy(2, 1), mxy(1, 6), mxy(2, 5))
          call zmi2m(1, mxy(1:2, 4))
          call zmsub(mxy(1:2, 4), mxy(1:2, 5), mresult)
          return
      endif

!             x is a double precision approximation to the size of input argument to this function.

      call zmabs(mxy(1:2, 1), mxy(1, 4))
      call fmm2dp(mxy(1, 4), x)
      kflagx = kflag
      call fmovun_xe(mxy(1, 4), xe)
      if (kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax**0.33d0
          kflagx = 0
      else if (kflag == 0 .and. x < 1.0d0/dpmax**0.33d0) then
          x = 1.0d0/dpmax**0.33d0
      endif
      if (kflag /= 0 .and. xe > 0) then
          x = dpmax**0.33d0
          kflagx = 0
      else if (kflag == 0 .and. x > dpmax**0.33d0) then
          x = dpmax**0.33d0
      endif

!             Determine which method to use.

!             nmethd = 1 use the convergent series,
!                    = 2 use a 2nd convergent series,
!                    = 3 use a continued fraction expansion,
!                    = 4 use an asymptotic series.

      xk = max(3.0d0, (2*x**2 + 1)/2)
      xk = -xk + log(2*xk-1)*(2*xk-0.5d0) + log(xk-1)*(-xk+0.5d0) - log(2.0d0)*(2*xk-1) -  &
           log(x)*(2*xk+1)
      if (-xk/dlogmb > ndig+(3+ndig/20)*ngrd52) then
          nmethd = 4
      else
          c4 = 5.0
          xk = 0.0
          do while (-xk/dlogmb <= ndig+(3+ndig/20)*ngrd52)
             c4 = 2 * c4
             xk = max(3.0d0, (2*c4**2 + 1)/2)
             xk = -xk + log(2*xk-1)*(2*xk-0.5d0) + log(xk-1)*(-xk+0.5d0) - log(2.0d0)*(2*xk-1) -  &
                  log(c4)*(2*xk+1)
          enddo
          c1 = c4/2
          do while (c4-c1 > 0.1)
             c2 = (c1 + c4) / 2
             xk = max(3.0d0, (2*c2**2 + 1)/2)
             xk = -xk + log(2*xk-1)*(2*xk-0.5d0) + log(xk-1)*(-xk+0.5d0) - log(2.0d0)*(2*xk-1) -  &
                  log(c2)*(2*xk+1)
             if (-xk/dlogmb > ndig+(3+ndig/20)*ngrd52) then
                 c4 = c2
             else
                 c1 = c2
             endif
          enddo
          call fmdiv(mxy(2, 1), mxy(1, 1), mxy(1, 15))
          call fmabs(mxy(1, 15), mxy(2, 15))
          call fmdp2m(1.5d0, mxy(1, 15))
          if (fmcomp(mxy(2, 15), '>', mxy(1, 15)) .or. mxy(1, 1)%mp(3) == 0) then
              if (x > 0.8*c4) then
                  nmethd = 3
              else
                  nmethd = 1
              endif
          else
              if (x > 0.6*c4) then
                  nmethd = 3
              else if (x > 6.0) then
                  nmethd = 2
              else
                  nmethd = 1
              endif
          endif
      endif

      if (nmethd == 1) then
          call zmerfc_m1(mxy, mresult, ndsave, numtry, kflagx, x)
      else if (nmethd == 2) then
          call zmerfc_m2(mxy, mresult, ndsave, numtry, kflagx, x)
      else if (nmethd == 3) then
          call zmerfc_m3(mxy, mresult, ndsave, numtry, kflagx, x)
      else if (nmethd == 4) then
          call zmerfc_m4(mxy, mresult, ndsave, numtry, kflagx, x)
      endif

      if (ma(1)%mp(3) == 0) then
          if (mresult(2)%mp(2) /= munkno) then
              call fmi2m(1, mresult(1))
          endif
      endif

      return
      end subroutine zmerfc_m

      subroutine zmerfc_m1(mxy, mresult, ndsave, numtry, kflagx, x)

!  Method 1 for computing erfc(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult

      double precision :: xe
      integer :: iextra, j, j2, kl, nd, nd1, ndsav1, nterm
      type(multi), save :: mjsums(2, ljsums)
      double precision, external :: fmnterms

!             Method 1.  Use the 1 - (-1)**n x**(2n+1) / n! / (2n+1) series.

!                        = 1 - ( 2 / sqrt(pi) ) * ( x - x**3/1! + x**5/2! - x**7/3! + ... )

      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig+ngrd52)
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, ndig)

!             If ma is large in magnitude or close to the real line, use more guard digits.

      call fmsqr(mxy(1, 1), mxy(1, 15))
      call fmsqr(mxy(2, 1), mxy(2, 15))
      call fmmpy(mxy(1, 1), mxy(2, 1), mxy(1, 14))
      call fmst2m('-4.408443', mxy(1, 13))

      call fmst2m(' 0.000832', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(1, 1))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m(' 0.002632', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(2, 1))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m(' 0.124034', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(1, 15))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m('-0.000291', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(1, 14))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m(' 0.001637', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(2, 15))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmm2i(mxy(1, 13), iextra)
      iextra = max(0, nint((iextra+3) * 16.11809565d0 / dlogmb)+1)
      if (iextra > 0) then
          call zmequ_r1(mxy(1:2, 1), ndig, ndig+iextra)
      endif
      ndig = ndig + iextra
      if (kflagx == 0) then
          j2 = int(0.66*sqrt(fmnterms(x**2, 1, 0, 0, 1)) - 0.8)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call zmi2m(1, mxy(1:2, 6))
      call zmi2m(1, mjsums(1:2, 1))

      do j = 2, j2
         if (nterm > 1) then
             call zmdivi_r1(mxy(1:2, 6), nterm)
         endif
         call zmdivi(mxy(1:2, 6), 2*nterm+1, mjsums(1:2, j))
         nterm = nterm + 1
      enddo
      call zmabs(mxy(1:2, 1), mxy(1, 15))
      call fmovun_xe(mxy(1, 15), xe)
      if (xe < -ndig) then
          kl = 0
      else
          kl = 1
          call zmipwr(mxy(1:2, 1), 2*j2, mxy(1:2, 5))
      endif

      do while (kl == 1)
         call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 5))
         do j = 1, j2
            call zmdivi_r1(mxy(1:2, 6), nterm)
            call zmdivi(mxy(1:2, 6), 2*nterm+1, mxy(1:2, 4))
            ndig = ndsav1
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 4))
            if (kflag == 1 .or. kflag == -4) then
                kl = 0
                exit
            endif
            nd = mjsums(1, j)%mp(2)-mxy(1, 4)%mp(2)
            nd1 = mjsums(2, j)%mp(2)-mxy(2, 4)%mp(2)
            nd = ndsav1 - int(min(nd, nd1))
            ndig = min(ndsav1, nd)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
            nterm = nterm + 1
         enddo
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call zmsqr(mxy(1:2, 1), mxy(1:2, 4))
      call zmnegate(mxy(1:2, 4))
      call zmeq(mjsums(1:2, j2), mxy(1:2, 5))

      do j = 2, j2
         call zmmpy(mxy(1:2, 5), mxy(1:2, 4), mxy(1:2, 15))
         call zmadd(mxy(1:2, 15), mjsums(1:2, j2-j+1), mxy(1:2, 5))
      enddo

      call zmmpy_r1(mxy(1:2, 5), mxy(1:2, 1))

      call fmpi(mxy(1, 4))
      call fmi2m(0, mxy(2, 4))
      call zmsqrt(mxy(1:2, 4), mxy(1:2, 3))
      call zmmpyi(mxy(1:2, 5), 2, mxy(1:2, 4))
      call zmdiv_r2(mxy(1:2, 4), mxy(1:2, 3))

      call zmi2m(1, mxy(1:2, 15))
      call zmsub_r2(mxy(1:2, 15), mxy(1:2, 3))

      call zmeq(mxy(1:2, 3), mresult)

      return
      end subroutine zmerfc_m1

      subroutine zmerfc_m2(mxy, mresult, ndsave, numtry, kflagx, x)

!  Method 2 for computing erfc(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult

      double precision :: xe
      integer :: iextra, j, j2, kl, nd, nd1, ndsav1, nterm
      type(multi), save :: mjsums(2, ljsums)
      double precision, external :: fmnterms

!             Method 2.  Use the 1 - x**(2n+1) * 2**(n+1) / (1*3*5*...*(2n+1)) series.

      call fmsqr(mxy(1, 1), mxy(1, 15))
      call fmsqr(mxy(2, 1), mxy(2, 15))
      call fmmpy(mxy(1, 1), mxy(2, 1), mxy(1, 14))
      call fmst2m('-1.966130', mxy(1, 13))

      call fmst2m(' 0.002853', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(1, 1))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m('-0.001447', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(2, 1))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m(' 0.062040', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(1, 15))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m('-0.000063', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(1, 14))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m(' 0.061968', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(2, 15))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmm2i(mxy(1, 13), iextra)
      iextra = max(0, nint((iextra+3) * 16.11809565d0 / dlogmb)+1)
      ndig = ndig + iextra
      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig) + 1
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, ndig)
      if (kflagx == 0) then
          j2 = int(0.51*sqrt(fmnterms(2*x, 2, -1, 0, 1)))
      else
          j2 = 1
      endif
      j2 = max(1, min(ljsums, j2))
      ndsav1 = ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call zmmpyi(mxy(1:2, 1), 2, mxy(1:2, 6))
      call zmeq(mxy(1:2, 6), mjsums(1:2, 1))
      do j = 2, j2
         call zmmpyi_r1(mxy(1:2, 6), 2)
         call zmdivi_r1(mxy(1:2, 6), 2*nterm+1)
         call zmeq(mxy(1:2, 6), mjsums(1:2, j))
         nterm = nterm + 1
      enddo
      call zmabs(mxy(1:2, 1), mxy(1, 15))
      call fmovun_xe(mxy(1, 15), xe)
      if (xe < -ndig) then
          kl = 0
      else
          kl = 1
          call zmipwr(mxy(1:2, 1), 2*j2, mxy(1:2, 5))
      endif

      do while (kl == 1)
         call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 5))
         do j = 1, j2
            call zmmpyi(mxy(1:2, 6), 2, mxy(1:2, 15))
            call zmdivi(mxy(1:2, 15), 2*nterm+1, mxy(1:2, 6))
            ndig = ndsav1
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 6))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            nd = mjsums(1, j)%mp(2)-mxy(1, 6)%mp(2)
            nd1 = mjsums(2, j)%mp(2)-mxy(2, 6)%mp(2)
            nd = ndsav1 - int(min(nd, nd1))
            ndig = min(ndsav1, nd)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
            nterm = nterm + 1
         enddo
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call zmsqr(mxy(1:2, 1), mxy(1:2, 6))
      call zmeq(mjsums(1:2, j2), mxy(1:2, 5))
      do j = 2, j2
         call zmmpy(mxy(1:2, 5), mxy(1:2, 6), mxy(1:2, 15))
         call zmadd(mxy(1:2, 15), mjsums(1:2, j2-j+1), mxy(1:2, 5))
      enddo

      call fmpi(mxy(1, 4))
      call fmi2m(0, mxy(2, 4))
      call zmsqrt(mxy(1:2, 4), mxy(1:2, 3))
      call zmdiv_r2(mxy(1:2, 5), mxy(1:2, 3))
      call zmexp(mxy(1:2, 6), mxy(1:2, 4))
      call zmdiv_r1(mxy(1:2, 3), mxy(1:2, 4))

      call zmi2m(1, mxy(1:2, 15))
      call zmsub_r2(mxy(1:2, 15), mxy(1:2, 3))

      call zmeq(mxy(1:2, 3), mresult)

      return
      end subroutine zmerfc_m2

      subroutine zmerfc_m3(mxy, mresult, ndsave, numtry, kflagx, x)

!  Method 3 for computing erfc(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult

      integer :: k, ksma, kt, nd, nd1, ndsav1, ndsav2, nterms
      logical, external :: fmcomp

!             Method 3.  Continued fraction expansion (asymptotic).
!                        Used for Re(x) > 0.
!                        For Re(x) < 0, use   erfc(x) = 1 - erf(x) = 1 + erf(-x) = 2 - erfc(-x).

!                                  erfc(x) = 0 + exp(-x**2)/sqrt(pi) /
!                                                                 x + 1 /
!                                                                   2*x + 2 /
!                                                                         x + 3 /
!                                                                           2*x + 4 /
!                                                                                 x + 5 ...

      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig) + 1
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, ndig)
      ndsav1 = ndig
      ksma = mxy(1, 1)%mp(1)
      if (ksma < 0) then
          call zmnegate(mxy(1:2, 1))
      endif

      call zmeq(mxy(1:2, 1), mxy(1:2, 2))

      call zmsqr(mxy(1:2, 2), mxy(1:2, 4))
      call zmmpyi(mxy(1:2, 4), -1, mxy(1:2, 15))
      call zmexp(mxy(1:2, 15), mxy(1:2, 10))
      call zmeq(mxy(1:2, 10), mxy(1:2, 15))
      call fmpi(mxy(1, 10))
      call fmsqrt_r1(mxy(1, 10))
      call fmi2m(0, mxy(2, 10))
      call zmdiv_r2(mxy(1:2, 15), mxy(1:2, 10))
      call zmdiv_r1(mxy(1:2, 10), mxy(1:2, 2))
      call zmi2m(-31, mxy(1:2, 13))

      call zmeq(mxy(1:2, 10), mxy(1:2, 14))
      call zmi2m(1, mxy(1:2, 8))
      call zmeq(mxy(1:2, 2), mxy(1:2, 9))
      nterms = int(intmax/10)

!             Continued fraction loop.

      ndsav2 = ndig
      do k = 3, nterms
         call zmmpyi(mxy(1:2, 2), 1+mod(k, 2), mxy(1:2, 11))
         call zmmpy_r1(mxy(1:2, 11), mxy(1:2, 9))
         call zmmpyi(mxy(1:2, 8), k-2, mxy(1:2, 12))
         call zmadd(mxy(1:2, 11), mxy(1:2, 12), mxy(1:2, 7))
         call zmmpy_r1(mxy(1:2, 10), mxy(1:2, 12))
         call zmdiv_r1(mxy(1:2, 10), mxy(1:2, 7))
         call zmnegate(mxy(1:2, 10))
         call zmeq(mxy(1:2, 9), mxy(1:2, 8))
         call zmeq(mxy(1:2, 7), mxy(1:2, 9))
         ndig = ndsav2
         call zmadd_r1(mxy(1:2, 14), mxy(1:2, 10))

!             Check for convergence.

         if (kflag == 1 .and. k > 2) then
             exit
         endif
         kt = max(1000, int(5*alogmt*ndsave))
         if (k > kt) then
             call zmerfc_m2(mxy, mresult, ndsave, numtry, kflagx, x)
             return
         endif
         call zmeq(mxy(1:2, 10), mxy(1:2, 13))
         nd = mxy(1, 14)%mp(2)-mxy(1, 10)%mp(2)
         nd1 = mxy(2, 14)%mp(2)-mxy(2, 10)%mp(2)
         nd = min(ndsav2, max(ngrd22, ndsav2-int(min(nd, nd1))))
         ndig = nd
         if (k == nterms) then
             call zmunknown(mresult)
             kflag = -4
             return
         endif
      enddo

      call fmi2m(1, mxy(1, 15))
      call fmulp(mxy(1, 15), mxy(2, 15))
      call fmdiv(mxy(1, 1), mxy(2, 1), mxy(1, 15))
      call fmsqr_r1(mxy(1, 15))
      if (fmcomp(mxy(1, 15), '<', mxy(2, 15))) then
          call fmi2m(1, mxy(1, 15))
          call fmadd_r2(mxy(1, 15), mxy(1, 14))
      endif
      call zmeq(mxy(1:2, 14), mxy(1:2, 3))
      if (ksma < 0) then
          call zmi2m(2, mxy(1:2, 15))
          call zmsub_r2(mxy(1:2, 15), mxy(1:2, 3))
      endif
      ndig = ndsav1

      call zmeq(mxy(1:2, 3), mresult)

      return
      end subroutine zmerfc_m3

      subroutine zmerfc_m4(mxy, mresult, ndsave, numtry, kflagx, x)

!  Method 4 for computing erfc(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult

      double precision :: xe
      integer :: j, j2, kl, ksma, kt, nd, nd1, ndsav1, nterm
      type(multi), save :: mjsums(2, ljsums)
      double precision, external :: fmnterms
      logical, external :: fmcomp

!             Method 4.  Asymptotic series
!
!                        For Re(x) >= 0,
!                        erfc(x) = ( Exp(-x**2) / Sqrt(Pi) ) *
!                                  Sum_{k=0}**Infinity (  (-1)**k * poch(1/2,k) / x**(2*k+1) )

!                        For Re(x) < 0, use   erfc(x) = 1 - erf(x) = 1 + erf(-x) = 2 - erfc(-x).

!             The series is  1/x - (1/2) / x**3  +  ( 1*3 )/(2**2) / x**5 - ( 1*3*5 )/(2**3) / x**7
!                            + ...

      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig-1)
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, ndig)
      ksma = mxy(1, 1)%mp(1)
      if (ksma < 0) then
          call zmnegate(mxy(1:2, 1))
      endif
      if (kflagx == 0) then
          j2 = int(0.66*sqrt(fmnterms(x**2, 1, 0, 0, 0)) - 0.8)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call zmsqr(mxy(1:2, 1), mxy(1:2, 15))
      call zmmpyi(mxy(1:2, 15), 2, mxy(1:2, 7))
      call zmi2m(1, mxy(1:2, 8))
      call zmdiv(mxy(1:2, 8), mxy(1:2, 7), mxy(1:2, 6))
      call zmi2m(1, mjsums(1:2, 1))
      do j = 2, j2
         nterm = nterm + 1
         call zmmpyi_r1(mxy(1:2, 8), 2*nterm-3)
         call zmeq(mxy(1:2, 8), mjsums(1:2, j))
      enddo
      call zmabs(mxy(1:2, 1), mxy(1, 15))
      call fmovun_xe(mxy(1, 15), xe)
      if (xe < -ndig) then
          kl = 0
      else
          kl = 1
          call zmipwr(mxy(1:2, 6), j2, mxy(1:2, 7))
          call zmi2m(-31, mxy(1:2, 13))
      endif

      do while (kl == 1)
         call zmmpy_r2(mxy(1:2, 7), mxy(1:2, 8))
         do j = 1, j2
            nterm = nterm + 1
            call zmmpyi_r1(mxy(1:2, 8), 2*nterm-3)
            ndig = ndsav1
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 8))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            kt = max(19000, int(6*alogmt*ndsave))
            if (nterm > kt) then
                call zmabs(mxy(1:2, 8), mxy(1, 15))
                call zmabs(mxy(1:2, 13), mxy(2, 15))
                if (fmcomp(mxy(1, 15), '>', mxy(2, 15))) then
                    call zmerfc_m2(mxy, mresult, ndsave, numtry, kflagx, x)
                    return
                endif
            endif
            call zmeq(mxy(1:2, 8), mxy(1:2, 13))
            nd = mjsums(1, j)%mp(2)-mxy(1, 8)%mp(2)
            nd1 = mjsums(2, j)%mp(2)-mxy(2, 8)%mp(2)
            nd = ndsav1 - int(min(nd, nd1))
            ndig = min(ndsav1, nd)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         enddo
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call zmmpyi(mxy(1:2, 6), -1, mxy(1:2, 4))
      call zmi2m(1, mxy(1:2, 5))
      do j = 2, j2
         call zmmpy_r1(mxy(1:2, 5), mxy(1:2, 4))
         call zmmpy(mxy(1:2, 5), mjsums(1:2, j), mxy(1:2, 15))
         call zmadd(mxy(1:2, 15), mjsums(1:2, 1), mxy(1:2, 8))
         call zmeq(mxy(1:2, 8), mjsums(1:2, 1))
      enddo
      call fmmpy(mxy(1, 1), mxy(2, 1), mxy(2, 15))
      call fmmpyi_r1(mxy(2, 15), -2)
      call fmi2m(0, mxy(1, 15))
      call zmexp(mxy(1:2, 15), mxy(1:2, 14))
      call zmmpy(mjsums(1:2, 1), mxy(1:2, 14), mxy(1:2, 15))
      call fmpi(mxy(1, 4))
      call fmsqrt(mxy(1, 4), mxy(1, 8))
      call fmi2m(0, mxy(2, 8))
      call zmmpy(mxy(1:2, 8), mxy(1:2, 1), mxy(1:2, 14))
      call zmdiv(mxy(1:2, 15), mxy(1:2, 14), mxy(1:2, 13))
      call fmadd(mxy(2, 1), mxy(1, 1), mxy(1, 12))
      call fmsub(mxy(2, 1), mxy(1, 1), mxy(1, 11))
      call fmmpy(mxy(1, 12), mxy(1, 11), mxy(1, 10))
      call fmexp(mxy(1, 10), mxy(1, 12))
      call fmmpy(mxy(1, 13), mxy(1, 12), mxy(1, 4))
      call fmmpy(mxy(2, 13), mxy(1, 12), mxy(2, 4))
      if (mxy(1, 4)%mp(2) == munkno .and. mxy(1, 4)%mp(5) >= 0) then
          call fmabs(mxy(1, 13), mxy(1, 14))
          call fmln(mxy(1, 14), mxy(1, 15))
          call fmadd(mxy(1, 10), mxy(1, 15), mxy(1, 14))
          call fmexp(mxy(1, 14), mxy(1, 4))
          mxy(1, 4)%mp(1) = mxy(1, 13)%mp(1)
      endif
      if (mxy(2, 4)%mp(2) == munkno .and. mxy(2, 4)%mp(5) >= 0) then
          call fmabs(mxy(2, 13), mxy(1, 14))
          call fmln(mxy(1, 14), mxy(1, 15))
          call fmadd(mxy(1, 10), mxy(1, 15), mxy(1, 14))
          call fmexp(mxy(1, 14), mxy(2, 4))
          mxy(2, 4)%mp(1) = mxy(2, 13)%mp(1)
      endif

      call fmi2m(1, mxy(1, 15))
      call fmulp(mxy(1, 15), mxy(2, 15))
      call fmdiv(mxy(1, 1), mxy(2, 1), mxy(1, 15))
      call fmsqr_r1(mxy(1, 15))
      if (fmcomp(mxy(1, 15), '<', mxy(2, 15))) then
          call fmi2m(1, mxy(1, 15))
          call fmadd_r2(mxy(1, 15), mxy(1, 4))
      endif

      if (ksma < 0) then
          call zmi2m(2, mxy(1:2, 15))
          call zmsub(mxy(1:2, 15), mxy(1:2, 4), mxy(1:2, 3))
      else
          call zmeq(mxy(1:2, 4), mxy(1:2, 3))
      endif

      call zmeq(mxy(1:2, 3), mresult)

      return
      end subroutine zmerfc_m4

      subroutine zmerfc_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = erfc(ma).

!  kresult = 1 is returned if a special case gives the value of erfc(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMERFC   '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

!             If ma is real, use fmerfc.

      if (malocal(2)%mp(3) == 0) then
          call fmerfc(malocal(1), mresult(1))
          call fmi2m(0, mresult(2))
          kresult = 1
          return
      endif

      return
      end subroutine zmerfc_sc

      subroutine zmerfcs(ma, mb)

!  mb = exp(ma**2) * erfc(ma)    Scaled complimentary error function.

!  erfc(z) underflows for relatively small magnitude |z| in the right half-plane (re(z) >= 0).
!  Multiplying by exp(z**2) allows the scaled complimentary error function to be computed even
!  when |z| is large and re(z) >= 0.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(2, 15), mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmerfcs_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call zmerfcs_m(ma, mxy, mresult, ndsave, numtry, retry)
         if (ma(1)%mp(3) == 0) then
             if (mresult(2)%mp(2) /= munkno) then
                 call fmsqr(mxy(2, 1), mxy(1, 4))
                 call fmnegate(mxy(1, 4))
                 call fmexp(mxy(1, 4), mresult(1))
             endif
         endif
         if (retry) then
             retry = .false.
             call zmcheck_accuracy(mresult, ndsave, retry)
         endif
         numtry = numtry + 1
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmerfcs

      subroutine zmerfcs_m(ma, mxy, mresult, ndsave, numtry, retry)

!  Method selection for computing erfcs(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(2, 15), mresult(2)
      integer :: ndsave, numtry
      logical :: retry
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, numtry, retry

      double precision :: c1, c2, c4, x, xe, xk
      integer :: kflagx, nmethd
      logical, external :: fmcomp

      retry = .true.

      call zmequ(ma, mxy(1:2, 1), ndsave, ndig)

!             Check for special cases.

      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
          call zmi2m(1, mresult)
          retry = .false.
          return
      endif
      call zmabs(mxy(1:2, 1), mxy(1, 2))
      call fmovun_xe(mxy(1, 2), xe)
      if (xe <= -ndig/2) then
          call fmpi(mxy(1, 3))
          call fmsqrt(mxy(1, 3), mxy(1, 4))
          call fmi2m(2, mxy(1, 5))
          call fmdiv(mxy(1, 5), mxy(1, 4), mxy(1, 6))
          call fmmpy(mxy(1, 1), mxy(1, 6), mxy(1, 5))
          call fmmpy(mxy(2, 1), mxy(1, 6), mxy(2, 5))
          call zmi2m(1, mxy(1:2, 4))
          call zmsub(mxy(1:2, 4), mxy(1:2, 5), mresult)
          return
      else if (xe >= ndig/2) then
          if (mxy(1, 1)%mp(1) > 0) then
              call zmeq(mxy(1:2, 1), mxy(1:2, 6))
          else
              call zmmpyi(mxy(1:2, 1), -1, mxy(1:2, 6))
          endif
          call fmpi(mxy(1, 3))
          call fmsqrt(mxy(1, 3), mxy(1, 4))
          call fmmpy(mxy(1, 6), mxy(1, 4), mxy(1, 5))
          call fmmpy(mxy(2, 6), mxy(1, 4), mxy(2, 5))
          call zmi2m(1, mxy(1:2, 4))
          call zmdiv(mxy(1:2, 4), mxy(1:2, 5), mxy(1:2, 3))
          if (mxy(1, 1)%mp(1) < 0) then
              call zmsqr(mxy(1:2, 1), mxy(1:2, 5))
              call zmexp(mxy(1:2, 5), mxy(1:2, 4))
              call zmmpyi(mxy(1:2, 4), 2, mxy(1:2, 5))
              call zmsub(mxy(1:2, 5), mxy(1:2, 3), mxy(1:2, 4))
              call zmeq(mxy(1:2, 4), mxy(1:2, 3))
          endif
          call zmeq(mxy(1:2, 3), mresult)
          return
      endif

!             x is a double precision approximation to the size of input argument to this function.

      call zmabs(mxy(1:2, 1), mxy(1, 4))
      call fmm2dp(mxy(1, 4), x)
      kflagx = kflag
      call fmovun_xe(mxy(1, 4), xe)
      if (kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax**0.33d0
          kflagx = 0
      else if (kflag == 0 .and. x < 1.0d0/dpmax**0.33d0) then
          x = 1.0d0/dpmax**0.33d0
      endif
      if (kflag /= 0 .and. xe > 0) then
          x = dpmax**0.33d0
          kflagx = 0
      else if (kflag == 0 .and. x > dpmax**0.33d0) then
          x = dpmax**0.33d0
      endif

!             Determine which method to use.

!             nmethd = 1 use the convergent series,
!                    = 2 use a 2nd convergent series,
!                    = 3 use a continued fraction expansion,
!                    = 4 use an asymptotic series.

      xk = max(3.0d0, (2*x**2 + 1)/2)
      xk = -xk + log(2*xk-1)*(2*xk-0.5d0) + log(xk-1)*(-xk+0.5d0) - log(2.0d0)*(2*xk-1) -  &
           log(x)*(2*xk+1)
      if (-xk/dlogmb > ndig+(3+ndig/20)*ngrd52) then
          nmethd = 4
      else
          c4 = 5.0
          xk = 0.0
          do while (-xk/dlogmb <= ndig+(3+ndig/20)*ngrd52)
             c4 = 2 * c4
             xk = max(3.0d0, (2*c4**2 + 1)/2)
             xk = -xk + log(2*xk-1)*(2*xk-0.5d0) + log(xk-1)*(-xk+0.5d0) - log(2.0d0)*(2*xk-1) -  &
                  log(c4)*(2*xk+1)
          enddo
          c1 = c4/2
          do while (c4-c1 > 0.1)
             c2 = (c1 + c4) / 2
             xk = max(3.0d0, (2*c2**2 + 1)/2)
             xk = -xk + log(2*xk-1)*(2*xk-0.5d0) + log(xk-1)*(-xk+0.5d0) - log(2.0d0)*(2*xk-1) -  &
                  log(c2)*(2*xk+1)
             if (-xk/dlogmb > ndig+(3+ndig/20)*ngrd52) then
                 c4 = c2
             else
                 c1 = c2
             endif
          enddo
          call fmdiv(mxy(2, 1), mxy(1, 1), mxy(1, 15))
          call fmabs(mxy(1, 15), mxy(2, 15))
          call fmdp2m(1.5d0, mxy(1, 15))
          if (fmcomp(mxy(2, 15), '>', mxy(1, 15)) .or. mxy(1, 1)%mp(3) == 0) then
              if (x > 0.8*c4) then
                  nmethd = 3
              else
                  nmethd = 1
              endif
          else
              if (x > 0.6*c4) then
                  nmethd = 3
              else if (x > 6.0) then
                  nmethd = 2
              else
                  nmethd = 1
              endif
          endif
      endif

      if (nmethd == 1) then
          call zmerfcs_m1(mxy, mresult, ndsave, numtry, kflagx, x)
      else if (nmethd == 2) then
          call zmerfcs_m2(mxy, mresult, ndsave, numtry, kflagx, x)
      else if (nmethd == 3) then
          call zmerfcs_m3(mxy, mresult, ndsave, numtry, kflagx, x)
      else if (nmethd == 4) then
          call zmerfcs_m4(mxy, mresult, ndsave, numtry, kflagx, x)
      endif

      return
      end subroutine zmerfcs_m

      subroutine zmerfcs_m1(mxy, mresult, ndsave, numtry, kflagx, x)

!  Method 1 for computing erfcs(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult

      double precision :: xe
      integer :: iextra, j, j2, kl, nd, nd1, ndsav1, nterm
      type(multi), save :: mjsums(2, ljsums)
      double precision, external :: fmnterms


!             Method 1.  Use the 1 - (-1)**n x**(2n+1) / n! / (2n+1) series.

!                        exp(x**2) * ( 1 - (2/sqrt(pi))*( x - x**3/1! + x**5/2! - x**7/3! + ... ) )

      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig+ngrd52)
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, ndig)

!             If ma is large in magnitude or close to the real line, use more guard digits.

      call fmsqr(mxy(1, 1), mxy(1, 15))
      call fmsqr(mxy(2, 1), mxy(2, 15))
      call fmmpy(mxy(1, 1), mxy(2, 1), mxy(1, 14))
      call fmst2m('-4.408443', mxy(1, 13))

      call fmst2m(' 0.000832', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(1, 1))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m(' 0.002632', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(2, 1))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m(' 0.124034', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(1, 15))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m('-0.000291', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(1, 14))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m(' 0.001637', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(2, 15))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmm2i(mxy(1, 13), iextra)
      iextra = max(0, nint((iextra+3) * 16.11809565d0 / dlogmb)+1)
      if (iextra > 0) then
          call zmequ_r1(mxy(1:2, 1), ndig, ndig+iextra)
      endif
      ndig = ndig + iextra
      if (kflagx == 0) then
          j2 = int(0.66*sqrt(fmnterms(x**2, 1, 0, 0, 1)) - 0.8)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call zmi2m(1, mxy(1:2, 6))
      call zmi2m(1, mjsums(1:2, 1))

      do j = 2, j2
         if (nterm > 1) then
             call zmdivi_r1(mxy(1:2, 6), nterm)
         endif
         call zmdivi(mxy(1:2, 6), 2*nterm+1, mjsums(1:2, j))
         nterm = nterm + 1
      enddo
      call zmabs(mxy(1:2, 1), mxy(1, 15))
      call fmovun_xe(mxy(1, 15), xe)
      if (xe < -ndig) then
          kl = 0
      else
          kl = 1
          call zmipwr(mxy(1:2, 1), 2*j2, mxy(1:2, 5))
      endif

      do while (kl == 1)
         call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 5))
         do j = 1, j2
            call zmdivi_r1(mxy(1:2, 6), nterm)
            call zmdivi(mxy(1:2, 6), 2*nterm+1, mxy(1:2, 4))
            ndig = ndsav1
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 4))
            if (kflag == 1 .or. kflag == -4) then
                kl = 0
                exit
            endif
            nd = mjsums(1, j)%mp(2)-mxy(1, 4)%mp(2)
            nd1 = mjsums(2, j)%mp(2)-mxy(2, 4)%mp(2)
            nd = ndsav1 - int(min(nd, nd1))
            ndig = min(ndsav1, nd)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
            nterm = nterm + 1
         enddo
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call zmsqr(mxy(1:2, 1), mxy(1:2, 4))
      call zmnegate(mxy(1:2, 4))
      call zmeq(mjsums(1:2, j2), mxy(1:2, 5))

      do j = 2, j2
         call zmmpy(mxy(1:2, 5), mxy(1:2, 4), mxy(1:2, 15))
         call zmadd(mxy(1:2, 15), mjsums(1:2, j2-j+1), mxy(1:2, 5))
      enddo

      call zmmpy_r1(mxy(1:2, 5), mxy(1:2, 1))

      call fmpi(mxy(1, 4))
      call fmi2m(0, mxy(2, 4))
      call zmsqrt(mxy(1:2, 4), mxy(1:2, 3))
      call zmmpyi(mxy(1:2, 5), 2, mxy(1:2, 4))
      call zmdiv_r2(mxy(1:2, 4), mxy(1:2, 3))

      call zmi2m(1, mxy(1:2, 15))
      call zmsub_r2(mxy(1:2, 15), mxy(1:2, 3))
      call zmsqr(mxy(1:2, 1), mxy(1:2, 15))
      call zmexp(mxy(1:2, 15), mxy(1:2, 14))
      call zmmpy_r1(mxy(1:2, 3), mxy(1:2, 14))

      call zmeq(mxy(1:2, 3), mresult)

      return
      end subroutine zmerfcs_m1

      subroutine zmerfcs_m2(mxy, mresult, ndsave, numtry, kflagx, x)

!  Method 2 for computing erfcs(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult

      double precision :: xe
      integer :: iextra, j, j2, kl, nd, nd1, ndsav1, nterm
      type(multi), save :: mjsums(2, ljsums)
      double precision, external :: fmnterms


!             Method 2.  Use the 1 - x**(2n+1) * 2**(n+1) / (1*3*5*...*(2n+1)) series.

!                        exp(x**2) * ( 1 - x**(2n+1) * 2**(n+1) / (1*3*5*...*(2n+1)) )

      call fmsqr(mxy(1, 1), mxy(1, 15))
      call fmsqr(mxy(2, 1), mxy(2, 15))
      call fmmpy(mxy(1, 1), mxy(2, 1), mxy(1, 14))
      call fmst2m('-1.966130', mxy(1, 13))

      call fmst2m(' 0.002853', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(1, 1))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m('-0.001447', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(2, 1))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m(' 0.062040', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(1, 15))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m('-0.000063', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(1, 14))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmst2m(' 0.061968', mxy(2, 13))
      call fmmpy_r1(mxy(2, 13), mxy(2, 15))
      call fmadd_r1(mxy(1, 13), mxy(2, 13))

      call fmm2i(mxy(1, 13), iextra)
      iextra = max(0, nint((iextra+3) * 16.11809565d0 / dlogmb)+1)
      ndig = ndig + iextra
      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig) + 1
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, ndig)
      if (kflagx == 0) then
          j2 = int(0.51*sqrt(fmnterms(2*x, 2, -1, 0, 1)))
      else
          j2 = 1
      endif
      j2 = max(1, min(ljsums, j2))
      ndsav1 = ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call zmmpyi(mxy(1:2, 1), 2, mxy(1:2, 6))
      call zmeq(mxy(1:2, 6), mjsums(1:2, 1))
      do j = 2, j2
         call zmmpyi_r1(mxy(1:2, 6), 2)
         call zmdivi_r1(mxy(1:2, 6), 2*nterm+1)
         call zmeq(mxy(1:2, 6), mjsums(1:2, j))
         nterm = nterm + 1
      enddo
      call zmabs(mxy(1:2, 1), mxy(1, 15))
      call fmovun_xe(mxy(1, 15), xe)
      if (xe < -ndig) then
          kl = 0
      else
          kl = 1
          call zmipwr(mxy(1:2, 1), 2*j2, mxy(1:2, 5))
      endif

      do while (kl == 1)
         call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 5))
         do j = 1, j2
            call zmmpyi(mxy(1:2, 6), 2, mxy(1:2, 15))
            call zmdivi(mxy(1:2, 15), 2*nterm+1, mxy(1:2, 6))
            ndig = ndsav1
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 6))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            nd = mjsums(1, j)%mp(2)-mxy(1, 6)%mp(2)
            nd1 = mjsums(2, j)%mp(2)-mxy(2, 6)%mp(2)
            nd = ndsav1 - int(min(nd, nd1))
            ndig = min(ndsav1, nd)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
            nterm = nterm + 1
         enddo
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call zmsqr(mxy(1:2, 1), mxy(1:2, 6))
      call zmeq(mjsums(1:2, j2), mxy(1:2, 5))
      do j = 2, j2
         call zmmpy(mxy(1:2, 5), mxy(1:2, 6), mxy(1:2, 15))
         call zmadd(mxy(1:2, 15), mjsums(1:2, j2-j+1), mxy(1:2, 5))
      enddo

      call fmpi(mxy(1, 4))
      call fmi2m(0, mxy(2, 4))
      call zmsqrt(mxy(1:2, 4), mxy(1:2, 3))
      call zmdiv_r2(mxy(1:2, 5), mxy(1:2, 3))
      call zmexp(mxy(1:2, 6), mxy(1:2, 4))
      call zmdiv_r1(mxy(1:2, 3), mxy(1:2, 4))

      call zmi2m(1, mxy(1:2, 15))
      call zmsub_r2(mxy(1:2, 15), mxy(1:2, 3))

      call zmsqr(mxy(1:2, 1), mxy(1:2, 15))
      call zmexp(mxy(1:2, 15), mxy(1:2, 14))
      call zmmpy_r1(mxy(1:2, 3), mxy(1:2, 14))

      call zmeq(mxy(1:2, 3), mresult)

      return
      end subroutine zmerfcs_m2

      subroutine zmerfcs_m3(mxy, mresult, ndsave, numtry, kflagx, x)

!  Method 3 for computing erfcs(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult

      integer :: k, ksma, kt, nd, nd1, ndsav1, ndsav2, nterms
      logical, external :: fmcomp

!             Method 3.  Continued fraction expansion (asymptotic).
!                        Used for Re(x) > 0.

!                               erfc_sc(x) = 0 + 1/sqrt(pi) /
!                                                         x + 1 /
!                                                           2*x + 2 /
!                                                                 x + 3 /
!                                                                   2*x + 4 /
!                                                                         x + 5 ...
!
!                        For Re(x) < 0, use   erfc_sc(x) = exp(x**2) * (1 - erf(x))
!                                                        = exp(x**2) * (1 + erf(-x))
!                                                        = exp(x**2) * (2 - erfc(-x))
!                                                        = 2*exp(x**2) - erfc_sc(-x)

      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig) + 1
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, ndig)
      ndsav1 = ndig
      ksma = mxy(1, 1)%mp(1)
      if (ksma < 0) then
          call zmnegate(mxy(1:2, 1))
      endif

      call zmeq(mxy(1:2, 1), mxy(1:2, 2))

      call zmi2m(1, mxy(1:2, 15))
      call fmpi(mxy(1, 10))
      call fmsqrt_r1(mxy(1, 10))
      call fmi2m(0, mxy(2, 10))
      call zmdiv_r2(mxy(1:2, 15), mxy(1:2, 10))
      call zmdiv_r1(mxy(1:2, 10), mxy(1:2, 2))
      call zmi2m(-31, mxy(1:2, 13))

      call zmeq(mxy(1:2, 10), mxy(1:2, 14))
      call zmi2m(1, mxy(1:2, 8))
      call zmeq(mxy(1:2, 2), mxy(1:2, 9))
      nterms = int(intmax/10)

!             Continued fraction loop.

      ndsav2 = ndig
      do k = 3, nterms
         call zmmpyi(mxy(1:2, 2), 1+mod(k, 2), mxy(1:2, 11))
         call zmmpy_r1(mxy(1:2, 11), mxy(1:2, 9))
         call zmmpyi(mxy(1:2, 8), k-2, mxy(1:2, 12))
         call zmadd(mxy(1:2, 11), mxy(1:2, 12), mxy(1:2, 7))
         call zmmpy_r1(mxy(1:2, 10), mxy(1:2, 12))
         call zmdiv_r1(mxy(1:2, 10), mxy(1:2, 7))
         call zmnegate(mxy(1:2, 10))
         call zmeq(mxy(1:2, 9), mxy(1:2, 8))
         call zmeq(mxy(1:2, 7), mxy(1:2, 9))
         ndig = ndsav2
         call zmadd_r1(mxy(1:2, 14), mxy(1:2, 10))

!             Check for convergence.

         if (kflag == 1 .and. k > 2) then
             exit
         endif
         kt = max(1000, int(5*alogmt*ndsave))
         if (k > kt) then
             call zmerfcs_m2(mxy, mresult, ndsave, numtry, kflagx, x)
         endif
         call zmeq(mxy(1:2, 10), mxy(1:2, 13))
         nd = mxy(1, 14)%mp(2)-mxy(1, 10)%mp(2)
         nd1 = mxy(2, 14)%mp(2)-mxy(2, 10)%mp(2)
         nd = min(ndsav2, max(ngrd22, ndsav2-int(min(nd, nd1))))
         ndig = nd
         if (k == nterms) then
             call zmunknown(mresult)
             kflag = -4
             return
         endif
      enddo

      call fmi2m(1, mxy(1, 15))
      call fmulp(mxy(1, 15), mxy(2, 15))
      call fmdiv(mxy(1, 1), mxy(2, 1), mxy(1, 15))
      call fmsqr_r1(mxy(1, 15))
      if (fmcomp(mxy(1, 15), '<', mxy(2, 15))) then
          call zmsqr(mxy(1:2, 1), mxy(1:2, 13))
          call zmexp(mxy(1:2, 13), mxy(1:2, 15))
          call zmadd_r2(mxy(1:2, 15), mxy(1, 14))
      endif
      call zmeq(mxy(1:2, 14), mxy(1:2, 3))
      if (ksma < 0) then
          call zmsqr(mxy(1:2, 1), mxy(1:2, 15))
          call zmexp(mxy(1:2, 15), mxy(1:2, 14))
          call zmmpyi(mxy(1:2, 14), 2, mxy(1:2, 15))
          call zmsub_r2(mxy(1:2, 15), mxy(1:2, 3))
      endif
      ndig = ndsav1

      call zmeq(mxy(1:2, 3), mresult)

      return
      end subroutine zmerfcs_m3

      subroutine zmerfcs_m4(mxy, mresult, ndsave, numtry, kflagx, x)

!  Method 4 for computing erfcs(ma).

      use fmvals
      implicit none

      type(multi) :: mxy(2, 15), mresult(2)
      integer :: ndsave, numtry, kflagx
      double precision :: x
      intent (in) :: ndsave, numtry, kflagx, x
      intent (inout) :: mxy, mresult

      double precision :: xe
      integer :: j, j2, kl, ksma, kt, nd, nd1, ndsav1, nterm
      type(multi), save :: mjsums(2, ljsums)
      double precision, external :: fmnterms
      logical, external :: fmcomp

!             Method 4.  Asymptotic series
!
!                        For Re(x) >= 0,
!                        erfc_sc(x) = ( 1 / Sqrt(Pi) ) *
!                                  Sum_{k=0}^Infinity (  (-1)**k * poch(1/2,k) / x**(2*k+1) )

!                        The series is  1/x - (1/2) / x**3  +  ( 1*3 )/(2**2) / x**5 -
!                                       ( 1*3*5 )/(2**3) / x**7 + ...

!                        For Re(x) < 0, use   erfc(x) = 1 - erf(x) = 1 + erf(-x) = 2 - erfc(-x).
!                                       erfc_sc(x) = Exp(x**2) * (2 - erfc(-x))
!                                                  = 2*Exp(x**2) - erfc_sc(-x)

      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig-1)
      endif
      call zmequ_r1(mxy(1:2, 1), ndsave, ndig)
      ksma = mxy(1, 1)%mp(1)
      if (ksma < 0) then
          call zmnegate(mxy(1:2, 1))
      endif
      if (kflagx == 0) then
          j2 = int(0.66*sqrt(fmnterms(x**2, 1, 0, 0, 0)) - 0.8)
          j2 = max(2, min(j2+mod(j2, 2), ljsums))
      else
          j2 = 2
      endif
      ndsav1 = ndig

!             Split into j2 concurrent sums.

      nterm = 1
      call zmsqr(mxy(1:2, 1), mxy(1:2, 15))
      call zmmpyi(mxy(1:2, 15), 2, mxy(1:2, 7))
      call zmi2m(1, mxy(1:2, 8))
      call zmdiv(mxy(1:2, 8), mxy(1:2, 7), mxy(1:2, 6))
      call zmi2m(1, mjsums(1:2, 1))
      do j = 2, j2
         nterm = nterm + 1
         call zmmpyi_r1(mxy(1:2, 8), 2*nterm-3)
         call zmeq(mxy(1:2, 8), mjsums(1:2, j))
      enddo
      call zmabs(mxy(1:2, 1), mxy(1, 15))
      call fmovun_xe(mxy(1, 15), xe)
      if (xe < -ndig) then
          kl = 0
      else
          kl = 1
          call zmipwr(mxy(1:2, 6), j2, mxy(1:2, 7))
          call zmi2m(-31, mxy(1:2, 13))
      endif

      do while (kl == 1)
         call zmmpy_r2(mxy(1:2, 7), mxy(1:2, 8))
         do j = 1, j2
            nterm = nterm + 1
            call zmmpyi_r1(mxy(1:2, 8), 2*nterm-3)
            ndig = ndsav1
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 8))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            kt = max(19000, int(6*alogmt*ndsave))
            if (nterm > kt) then
                call zmabs(mxy(1:2, 8), mxy(1, 15))
                call zmabs(mxy(1:2, 13), mxy(2, 15))
                if (fmcomp(mxy(1, 15), '>', mxy(2, 15))) then
                    call zmerfcs_m2(mxy, mresult, ndsave, numtry, kflagx, x)
                endif
            endif
            call zmeq(mxy(1:2, 8), mxy(1:2, 13))
            nd = mjsums(1, j)%mp(2)-mxy(1, 8)%mp(2)
            nd1 = mjsums(2, j)%mp(2)-mxy(2, 8)%mp(2)
            nd = ndsav1 - int(min(nd, nd1))
            ndig = min(ndsav1, nd)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         enddo
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call zmmpyi(mxy(1:2, 6), -1, mxy(1:2, 4))
      call zmi2m(1, mxy(1:2, 5))
      do j = 2, j2
         call zmmpy_r1(mxy(1:2, 5), mxy(1:2, 4))
         call zmmpy(mxy(1:2, 5), mjsums(1:2, j), mxy(1:2, 15))
         call zmadd(mxy(1:2, 15), mjsums(1:2, 1), mxy(1:2, 8))
         call zmeq(mxy(1:2, 8), mjsums(1:2, 1))
      enddo

      call fmpi(mxy(1, 4))
      call fmsqrt(mxy(1, 4), mxy(1, 8))
      call fmi2m(0, mxy(2, 8))
      call zmdiv(mjsums(1:2, 1), mxy(1:2, 8), mxy(1:2, 4))
      call zmdiv_r1(mxy(1:2, 4), mxy(1:2, 1))

      call fmi2m(1, mxy(1, 15))
      call fmulp(mxy(1, 15), mxy(2, 15))
      call fmdiv(mxy(1, 1), mxy(2, 1), mxy(1, 15))
      call fmsqr_r1(mxy(1, 15))
      if (fmcomp(mxy(1, 15), '<', mxy(2, 15))) then
          call zmsqr(mxy(1:2, 1), mxy(1:2, 13))
          call zmexp(mxy(1:2, 13), mxy(1:2, 15))
          call zmadd_r2(mxy(1:2, 15), mxy(1:2, 4))
      endif
      if (ksma < 0) then
          call zmsqr(mxy(1:2, 1), mxy(1:2, 15))
          call fmi2m(2, mxy(1, 14))
          call fmln(mxy(1, 14), mxy(1, 13))
          call fmadd_r1(mxy(1, 15), mxy(1, 13))
          call zmexp(mxy(1:2, 15), mxy(1:2, 14))
          call zmsub(mxy(1:2, 14), mxy(1:2, 4), mxy(1:2, 3))
      else
          call zmeq(mxy(1:2, 4), mxy(1:2, 3))
      endif

      call zmeq(mxy(1:2, 3), mresult)

      return
      end subroutine zmerfcs_m4

      subroutine zmerfcs_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = erfcs(ma).

!  kresult = 1 is returned if a special case gives the value of erfcs(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMERFCS  '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      return
      end subroutine zmerfcs_sc

      subroutine zmexit1(ma, mb, kovun, mxsave, ndsave)

!  At the end of a function this routine checks for tracing the output argument,
!  rounds ma from precision ndig to precision ndsave as the returned function value mb,
!  and resets precision, and the overflow/underflow threshold to the values from the
!  start of that function.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (in) :: ma
      intent (inout) :: mb, kovun, mxsave, ndsave

      integer :: kfsave, kwrnsv

      kwrnsv = kwarn
      kwarn = 0
      mxexp = mxsave
      kfsave = kflag
      call zmequ(ma, mb, ndig, ndsave)
      if (kflag /= -5 .and. kflag /= -6) kflag = kfsave
      ndig = ndsave
      kwarn = kwrnsv
      if (kflag == 1) kflag = 0
      if (mb(1)%mp(2) == mexpun .or. mb(2)%mp(2) == mexpun) kflag = -6
      if (mb(1)%mp(2) == mexpov .or. mb(2)%mp(2) == mexpov) kflag = -5
      if (mb(1)%mp(2) == munkno .or. mb(2)%mp(2) == munkno) then
          if (kflag /= -9) kflag = -4
      endif
      if ((mb(1)%mp(2) == munkno .and. kflag /= -9 .and. kovun /= 2) .or.  &
          (mb(2)%mp(2) == munkno .and. kflag /= -9 .and. kovun /= 2) .or.  &
          (mb(1)%mp(2) == mexpun .and. kovun == 0)  .or.                   &
          (mb(2)%mp(2) == mexpun .and. kovun == 0)  .or.                   &
          (mb(1)%mp(2) == mexpov .and. kovun == 0)  .or.                   &
          (mb(2)%mp(2) == mexpov .and. kovun == 0)) then
          call fmwarn
      endif
      if (ntrace /= 0) call zmntr_out1(mb)
      ncall = ncall - 1

      return
      end subroutine zmexit1

      subroutine zmexit2(ma, mb, mc, md, kovun, mxsave, ndsave)

!  At the end of a function this routine checks for tracing the output argument,
!  rounds ma,mb from precision ndig to precision ndsave as the returned function value mc,md,
!  and resets precision, and the overflow/underflow threshold to the values from the
!  start of that function.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2), mc(2), md(2)
      real (kind(1.0d0)) :: mxsave
      integer :: kovun, ndsave
      intent (in) :: ma, mb
      intent (inout) :: mc, md, kovun, mxsave, ndsave

      integer :: kfsave, kwrnsv

      kwrnsv = kwarn
      kwarn = 0
      mxexp = mxsave
      kfsave = kflag
      call zmequ(ma, mc, ndig, ndsave)
      call zmequ(mb, md, ndig, ndsave)
      if (kflag /= -5 .and. kflag /= -6) kflag = kfsave
      ndig = ndsave
      kwarn = kwrnsv
      if (kflag == 1) kflag = 0
      if (mc(1)%mp(2) == mexpun .or. mc(2)%mp(2) == mexpun) kflag = -6
      if (md(1)%mp(2) == mexpun .or. md(2)%mp(2) == mexpun) kflag = -6
      if (mc(1)%mp(2) == mexpov .or. mc(2)%mp(2) == mexpov) kflag = -5
      if (md(1)%mp(2) == mexpov .or. md(2)%mp(2) == mexpov) kflag = -5
      if (mc(1)%mp(2) == munkno .or. mc(2)%mp(2) == munkno .or.  &
          md(1)%mp(2) == munkno .or. md(2)%mp(2) == munkno) then
          if (kflag /= -9) kflag = -4
      endif
      if ((mc(1)%mp(2) == munkno .and. kflag /= -9 .and. kovun /= 2) .or.  &
          (mc(2)%mp(2) == munkno .and. kflag /= -9 .and. kovun /= 2) .or.  &
          (md(1)%mp(2) == munkno .and. kflag /= -9 .and. kovun /= 2) .or.  &
          (md(2)%mp(2) == munkno .and. kflag /= -9 .and. kovun /= 2) .or.  &
          (mc(1)%mp(2) == mexpun .and. kovun == 0)  .or.                   &
          (mc(2)%mp(2) == mexpun .and. kovun == 0)  .or.                   &
          (md(1)%mp(2) == mexpun .and. kovun == 0)  .or.                   &
          (md(2)%mp(2) == mexpun .and. kovun == 0)  .or.                   &
          (mc(1)%mp(2) == mexpov .and. kovun == 0)  .or.                   &
          (mc(2)%mp(2) == mexpov .and. kovun == 0)  .or.                   &
          (md(1)%mp(2) == mexpov .and. kovun == 0)  .or.                   &
          (md(2)%mp(2) == mexpov .and. kovun == 0)) then
          call fmwarn
      endif
      if (ntrace /= 0) call zmntr_out2(mc, md)
      ncall = ncall - 1

      return
      end subroutine zmexit2

      subroutine zmexp(ma, mb)

!  mb = exp(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy, mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmexp_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmexp_m1(ma, mxy, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmexp

      subroutine zmexp_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing exp(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy, mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      integer :: kwrnsv
      type(multi), save :: mz01(2), mz02(2)

      call zmequ(ma, mz02, ndsave, ndig)

      if (ma(1)%mp(3) == 0) then
          call fmi2m(1, mxy)
      else
          call fmexp(mz02(1), mxy)
          if (ma(2)%mp(3) == 0) then
              call fmeq(mxy, mresult(1))
              call fmi2m(0, mresult(2))
              return
          endif
      endif

      call fmcssn(mz02(2), mz01(1), mz01(2))

      kwrnsv = kwarn
      kwarn = 0
      call fmmpyd(mxy, mz01(1), mz01(2), mz02(1), mz02(2))
      kwarn = kwrnsv

      call zmeq(mz02, mresult)

      return
      end subroutine zmexp_m1

      subroutine zmexp_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = exp(ma).

!  kresult = 1 is returned if a special case gives the value of exp(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMEXP    '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call zmi2m(1, mresult)
          kresult = 1
          return
      endif

      return
      end subroutine zmexp_sc

      subroutine zmfact(ma, mb)

!  mb = ma!     Factorial for complex input.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(2, 3), mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmfact_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmfact_m1(ma, mxy, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmfact

      subroutine zmfact_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing ma!.

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(2, 3), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      logical, external :: fmcomp

      call zmequ(ma, mxy(1:2, 1), ndsave, ndig)

!             Check for special cases.

      if (ma(2)%mp(3) == 0) then
          call fmint(mxy(1, 1), mxy(1, 3))
          if (fmcomp(mxy(1, 1), '==', mxy(1, 3))) then
              call zmunknown(mresult)
              kflag = -4
              return
          endif
      endif

!             Use  x! = gamma(x+1).

      call zmi2m(1, mxy(1:2, 2))
      call zmadd_r2(mxy(1:2, 1), mxy(1:2, 2))
      call zmgam(mxy(1:2, 2), mresult)

      return
      end subroutine zmfact_m1

      subroutine zmfact_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = ma!.

!  kresult = 1 is returned if a special case gives the value of ma!.

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMFACT   '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

!             If ma is real, use fmfact.

      if (ma(2)%mp(3) == 0) then
          call fmfact(malocal(1), mresult(1))
          call fmi2m(0, mresult(2))
          kresult = 1
          return
      endif

      return
      end subroutine zmfact_sc

      subroutine zmform(form1, form2, ma, string)

!  Convert ma to string using form1 format for the real part and form2 format for the
!  imaginary part.

      use fmvals
      implicit none

      character(*) :: form1, form2, string
      type(multi) :: ma(2)
      intent (in) :: ma, form1, form2
      intent (inout) :: string

      integer :: j, kwidim, kwidre, last, lsign
      type(multi), save :: mxy(1)

      ncall = ncall + 1
      namest(ncall) = 'ZMFORM'
      string = ' '
      call zmfpcz(form1, ma(1), kwidre)
      call fmeq(ma(2), mxy(1))
      if (mxy(1)%mp(1) > 0) then
          lsign = 1
      else
          lsign = -1
          call fmnegate(mxy(1))
      endif
      call zmfpcm(form2, mxy(1), kwidim)

      if (kwidre+kwidim+50 > lmbufz) then
          if (lmbufz > 0) deallocate(cmbufz)
          allocate(cmbufz(kwidre+kwidim+50), stat=j)
          if (j /= 0) then
              call fmdefine_error
          endif
          lmbufz = kwidre + kwidim + 50
          call zmfpcz(form1, ma(1), kwidre)
      endif

      cmbufz(kwidre+1) = ' '
      if (lsign == 1) then
          cmbufz(kwidre+2) = '+'
      else
          cmbufz(kwidre+2) = '-'
      endif
      cmbufz(kwidre+3) = ' '
      do j = 1, kwidim
         cmbufz(kwidre+3+j) = cmbuff(j)
      enddo
      cmbufz(kwidre+4+kwidim) = ' '
      cmbufz(kwidre+5+kwidim) = 'i'
      if (jformz == 2) cmbufz(kwidre+5+kwidim) = 'I'
      last = kwidre + kwidim + 5

      if (mxy(1)%mp(2) == mexpov .or. mxy(1)%mp(2) == mexpun) then
          do j = kwidre+3, last
             if (cmbufz(j) == 'O' .or. cmbufz(j) == 'U') then
                 cmbufz(j-2) = ' '
                 exit
             endif
          enddo
      endif

      if (last <= len(string)) then
          do j = 1, last
             string(j:j) = cmbufz(j)
          enddo
      else
          do j = 1, last
             string(j:j) = '*'
          enddo
      endif
      ncall = ncall - 1

      return
      end subroutine zmform

      subroutine zmfpcm(form, ma, kwi)

!  Internal routine to convert ma to base 10 using form format.
!  The result is returned in cmbuff and the field width is kwi.

      use fmvals
      implicit none

      character(*) :: form
      type(multi) :: ma
      integer :: kwi
      intent (in) :: ma, form
      intent (inout) :: kwi
      double precision :: val
      integer :: j, jf1sav, jf2sav, jpt, k1, k2, k3, kd, kwd, ksave, last, lb, lengfm,  &
                 lfirst, nd, nexp
      type(multi), save :: mxy(1)


      ksave = kflag
      jf1sav = jform1
      jf2sav = jform2
      lengfm = len(form)
      kwi = 75
      kwd = 40
      if (index(form, 'I') > 0 .or. index(form, 'i') > 0) then
          k1 = max(index(form, 'I'), index(form, 'i')) + 1
          k2 = lengfm
          if (k2 >= k1) then
              call fmst2d(form(k1:k2), val)
              kwi = nint(val)
          else
              kwi = 50
          endif
          kwi = max(1, kwi)
          jform1 = 2
          jform2 = 0
          kwd = kwi + 11
          if (kwd+50 > lmbuff) then
              if (lmbuff > 0) deallocate(cmbuff)
              allocate(cmbuff(kwd+50), stat=j)
              if (j /= 0) then
                  call fmdefine_error
              endif
              lmbuff = kwd + 50
          endif
          call fmnint(ma, mxy(1))
          if (mxy(1)%mp(3) /= 0) then
              call fmout(mxy(1), cmbuff, kwd)
          else
              do j = 1, kwd
                 cmbuff(j) = ' '
              enddo
              cmbuff(2) = '0'
          endif
          lfirst = 1
          last = 1
          do j = 1, kwd
             if (cmbuff(kwd+1-j) /= ' ') lfirst = kwd+1-j
             if (cmbuff(j) /= ' ') last = j
          enddo
          jpt = 1
          if (last-lfirst+1 > kwi) then
              call zmfpcm2(kwi, jf1sav, jf2sav)
              return
          endif
          if (last <= kwi) then
              do j = last, lfirst, -1
                 jpt = kwi - last + j
                 cmbuff(jpt) = cmbuff(j)
              enddo
              do j = 1, jpt-1
                 cmbuff(j) = ' '
              enddo
          else
              do j = lfirst, last
                 jpt = kwi - last + j
                 cmbuff(jpt) = cmbuff(j)
              enddo
          endif
      else if (index(form, 'F') > 0 .or. index(form, 'f') > 0) then
          k1 = max(index(form, 'F'), index(form, 'f')) + 1
          k2 = index(form(1:lengfm), '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val)
              kd = nint(val)
          else
              kd = 0
          endif
          kwi = max(1, kwi)
          kd = max(0, min(kd, kwi-2))
          jform1 = 2
          jform2 = kd
          nd = int(real(ndig)*log10(real(mbase))) + 1
          if (nd < 2) nd = 2
          nexp = int(2.0*log10(real(mxbase))) + 16
          lb = max(jform2+nexp, nd+nexp)
          kwd = lb
          if (kwd+50 > lmbuff) then
              if (lmbuff > 0) deallocate(cmbuff)
              allocate(cmbuff(kwd+50), stat=j)
              if (j /= 0) then
                  call fmdefine_error
              endif
              lmbuff = kwd + 50
          endif
          call fmout(ma, cmbuff, kwd)
          lfirst = 1
          last = 1
          do j = 1, kwd
             if (cmbuff(kwd+1-j) /= ' ') lfirst = kwd+1-j
             if (cmbuff(j) /= ' ') last = j
          enddo
          if (last-lfirst+1 > kwi) then

!             Not enough room for this f format, or fmout converted it to e format to avoid
!             showing no significant digits.  See if a shortened form will fit in e format.

              nexp = int(log10((abs(ma%mp(2))+1)*log10(dble(mbase))+1)+1)
              nd = kwi - nexp - 5
              if (nd < 1) then
                  call zmfpcm2(kwi, jf1sav, jf2sav)
                  return
              else
                  jform1 = 0
                  jform2 = nd
                  if (kwi+50 > lmbuff) then
                      if (lmbuff > 0) deallocate(cmbuff)
                      allocate(cmbuff(kwi+50), stat=j)
                      if (j /= 0) then
                          call fmdefine_error
                      endif
                      lmbuff = kwi + 50
                  endif
                  call fmout(ma, cmbuff, kwi)
                  lfirst = 1
                  last = 1
                  do j = 1, kwi
                     if (cmbuff(kwi+1-j) /= ' ') lfirst = kwi+1-j
                     if (cmbuff(j) /= ' ') last = j
                  enddo
              endif
          endif
          jpt = 1
          if (last <= kwi) then
              do j = last, lfirst, -1
                 jpt = kwi - last + j
                 cmbuff(jpt) = cmbuff(j)
              enddo
              do j = 1, jpt-1
                 cmbuff(j) = ' '
              enddo
          else
              do j = lfirst, last
                 jpt = kwi - last + j
                 cmbuff(jpt) = cmbuff(j)
              enddo
          endif
      else if (index(form, '1PE') > 0 .or. index(form, '1pe') > 0 .or. index(form, 'ES') > 0 .or.  &
               index(form, 'es') > 0) then
          if (index(form, '1PE') > 0 .or. index(form, '1pe') > 0) then
              k1 = max(index(form, 'E'), index(form, 'e')) + 1
          else
              k1 = max(index(form, 'S'), index(form, 's')) + 1
          endif
          k2 = index(form(1:lengfm), '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val)
              kd = nint(val)
          else
              kd = 0
          endif
          kwi = max(1, kwi)
          kd = max(0, min(kd, kwi-2))
          jform1 = 1
          jform2 = kd + 1
          if (kwi+50 > lmbuff) then
              if (lmbuff > 0) deallocate(cmbuff)
              allocate(cmbuff(kwi+50), stat=j)
              if (j /= 0) then
                  call fmdefine_error
              endif
              lmbuff = kwi + 50
          endif
          call fmout(ma, cmbuff, kwi)
      else if (index(form, 'E') > 0 .or. index(form, 'e') > 0) then
          k1 = max(index(form, 'E'), index(form, 'e')) + 1
          k2 = index(form(1:lengfm), '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val)
              kd = nint(val)
          else
              kd = 0
          endif
          kwi = max(1, kwi)
          kd = max(0, min(kd, kwi-2))
          jform1 = 0
          jform2 = kd
          if (kwi+50 > lmbuff) then
              if (lmbuff > 0) deallocate(cmbuff)
              allocate(cmbuff(kwi+50), stat=j)
              if (j /= 0) then
                  call fmdefine_error
              endif
              lmbuff = kwi + 50
          endif
          call fmout(ma, cmbuff, kwi)
      else
          call zmfpcm2(kwi, jf1sav, jf2sav)
          return
      endif

      jform1 = jf1sav
      jform2 = jf2sav
      kflag = ksave

      return
      end subroutine zmfpcm

      subroutine zmfpcm2(kwi, jf1sav, jf2sav)

!  Handle error conditions for zmfpcm.

      use fmvals
      implicit none

      integer :: kwi, jf1sav, jf2sav
      intent (in) :: kwi, jf1sav, jf2sav

      integer :: j

      kflag = -8
      do j = 1, kwi
         cmbuff(j) = '*'
      enddo
      jform1 = jf1sav
      jform2 = jf2sav

      return
      end subroutine zmfpcm2

      subroutine zmfpcz(form, ma, kwi)

!  Internal routine to convert ma to base 10 using form format.
!  The result is returned in cmbufz and the field width is kwi.

      use fmvals
      implicit none

      character(*) :: form
      type(multi) :: ma
      integer :: kwi
      intent (in) :: ma, form
      intent (inout) :: kwi
      double precision :: val
      integer :: j, jf1sav, jf2sav, jpt, k1, k2, k3, kd, kwd, ksave, last, lb,  &
                 lengfm, lfirst, nd, nexp
      type(multi), save :: mxy(1)


      ksave = kflag
      jf1sav = jform1
      jf2sav = jform2
      lengfm = len(form)
      kwi = 75
      kwd = 40
      if (index(form, 'I') > 0 .or. index(form, 'i') > 0) then
          k1 = max(index(form, 'I'), index(form, 'i')) + 1
          k2 = lengfm
          if (k2 >= k1) then
              call fmst2d(form(k1:k2), val)
              kwi = nint(val)
          else
              kwi = 50
          endif
          kwi = max(1, kwi)
          jform1 = 2
          jform2 = 0
          kwd = kwi + 11
          if (kwd+50 > lmbufz) then
              if (lmbufz > 0) deallocate(cmbufz)
              allocate(cmbufz(kwd+50), stat=j)
              if (j /= 0) then
                  call fmdefine_error
              endif
              lmbufz = kwd + 50
          endif
          call fmnint(ma, mxy(1))
          if (mxy(1)%mp(3) /= 0) then
              call fmout(mxy(1), cmbufz, kwd)
          else
              do j = 1, kwd
                 cmbufz(j) = ' '
              enddo
              cmbufz(2) = '0'
          endif
          lfirst = 1
          last = 1
          do j = 1, kwd
             if (cmbufz(kwd+1-j) /= ' ') lfirst = kwd+1-j
             if (cmbufz(j) /= ' ') last = j
          enddo
          jpt = 1
          if (last-lfirst+1 > kwi) then
              call zmfpcz2(kwi, jf1sav, jf2sav)
              return
          endif
          if (last <= kwi) then
              do j = last, lfirst, -1
                 jpt = kwi - last + j
                 cmbufz(jpt) = cmbufz(j)
              enddo
              do j = 1, jpt-1
                 cmbufz(j) = ' '
              enddo
          else
              do j = lfirst, last
                 jpt = kwi - last + j
                 cmbufz(jpt) = cmbufz(j)
              enddo
          endif
      else if (index(form, 'F') > 0 .or. index(form, 'f') > 0) then
          k1 = max(index(form, 'F'), index(form, 'f')) + 1
          k2 = index(form(1:lengfm), '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val)
              kd = nint(val)
          else
              kd = 0
          endif
          kwi = max(1, kwi)
          kd = max(0, min(kd, kwi-2))
          jform1 = 2
          jform2 = kd
          nd = int(real(ndig)*log10(real(mbase))) + 1
          if (nd < 2) nd = 2
          nexp = int(2.0*log10(real(mxbase))) + 16
          lb = max(jform2+nexp, nd+nexp)
          kwd = lb
          if (kwd+50 > lmbufz) then
              if (lmbufz > 0) deallocate(cmbufz)
              allocate(cmbufz(kwd+50), stat=j)
              if (j /= 0) then
                  call fmdefine_error
              endif
              lmbufz = kwd + 50
          endif
          call fmout(ma, cmbufz, kwd)
          lfirst = 1
          last = 1
          do j = 1, kwd
             if (cmbufz(kwd+1-j) /= ' ') lfirst = kwd+1-j
             if (cmbufz(j) /= ' ') last = j
          enddo
          if (last-lfirst+1 > kwi) then

!             Not enough room for this f format, or fmout converted it to e format to avoid
!             showing no significant digits.  See if a shortened form will fit in e format.

              nexp = int(log10((abs(ma%mp(2))+1)*log10(dble(mbase))+1)+1)
              nd = kwi - nexp - 5
              if (nd < 1) then
                  call zmfpcz2(kwi, jf1sav, jf2sav)
                  return
              else
                  jform1 = 0
                  jform2 = nd
                  if (kwi+50 > lmbufz) then
                      if (lmbufz > 0) deallocate(cmbufz)
                      allocate(cmbufz(kwi+50), stat=j)
                      if (j /= 0) then
                          call fmdefine_error
                      endif
                      lmbufz = kwi + 50
                  endif
                  call fmout(ma, cmbufz, kwi)
                  lfirst = 1
                  last = 1
                  do j = 1, kwi
                     if (cmbufz(kwi+1-j) /= ' ') lfirst = kwi+1-j
                     if (cmbufz(j) /= ' ') last = j
                  enddo
              endif
          endif
          jpt = 1
          if (last <= kwi) then
              do j = last, lfirst, -1
                 jpt = kwi - last + j
                 cmbufz(jpt) = cmbufz(j)
              enddo
              do j = 1, jpt-1
                 cmbufz(j) = ' '
              enddo
          else
              do j = lfirst, last
                 jpt = kwi - last + j
                 cmbufz(jpt) = cmbufz(j)
              enddo
          endif
      else if (index(form, '1PE') > 0 .or. index(form, '1pe') > 0 .or. index(form, 'ES') > 0 .or.  &
               index(form, 'es') > 0) then
          if (index(form, '1PE') > 0 .or. index(form, '1pe') > 0) then
              k1 = max(index(form, 'E'), index(form, 'e')) + 1
          else
              k1 = max(index(form, 'S'), index(form, 's')) + 1
          endif
          k2 = index(form(1:lengfm), '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val)
              kd = nint(val)
          else
              kd = 0
          endif
          kwi = max(1, kwi)
          kd = max(0, min(kd, kwi-2))
          jform1 = 1
          jform2 = kd + 1
          if (kwi+50 > lmbufz) then
              if (lmbufz > 0) deallocate(cmbufz)
              allocate(cmbufz(kwi+50), stat=j)
              if (j /= 0) then
                  call fmdefine_error
              endif
              lmbufz = kwi + 50
          endif
          call fmout(ma, cmbufz, kwi)
      else if (index(form, 'E') > 0 .or. index(form, 'e') > 0) then
          k1 = max(index(form, 'E'), index(form, 'e')) + 1
          k2 = index(form(1:lengfm), '.')
          k3 = lengfm
          if (k2 > k1) then
              call fmst2d(form(k1:k2-1), val)
              kwi = nint(val)
          else
              kwi = 50
          endif
          if (k3 > k2) then
              call fmst2d(form(k2+1:k3), val)
              kd = nint(val)
          else
              kd = 0
          endif
          kwi = max(1, kwi)
          kd = max(0, min(kd, kwi-2))
          jform1 = 0
          jform2 = kd
          if (kwi+50 > lmbufz) then
              if (lmbufz > 0) deallocate(cmbufz)
              allocate(cmbufz(kwi+50), stat=j)
              if (j /= 0) then
                  call fmdefine_error
              endif
              lmbufz = kwi + 50
          endif
          call fmout(ma, cmbufz, kwi)
      else
          call zmfpcz2(kwi, jf1sav, jf2sav)
          return
      endif

      jform1 = jf1sav
      jform2 = jf2sav
      kflag = ksave

      return
      end subroutine zmfpcz

      subroutine zmfpcz2(kwi, jf1sav, jf2sav)

!  Handle error conditions for zmfpcz.

      use fmvals
      implicit none

      integer :: kwi, jf1sav, jf2sav
      intent (in) :: kwi, jf1sav, jf2sav

      integer :: j

      kflag = -8
      do j = 1, kwi
         cmbufz(j) = '*'
      enddo
      jform1 = jf1sav
      jform2 = jf2sav

      return
      end subroutine zmfpcz2

      subroutine zmfprint(form1, form2, ma)

      use fmvals
      implicit none

      character(*) :: form1, form2
      type(multi) :: ma(2)
      intent (in) :: ma, form1, form2

      call zmfprt(form1, form2, ma)

      return
      end subroutine zmfprint

      subroutine zmfprt(form1, form2, ma)

!  Print ma in base 10 using form1 format for the real part and form2 format for the imaginary part.

      use fmvals
      implicit none

      character(*) :: form1, form2
      type(multi) :: ma(2)
      intent (in) :: ma, form1, form2

      character(20) :: form
      integer :: j, k, kwidim, kwidre, last, lsign
      type(multi), save :: mxy(1)


      ncall = ncall + 1
      namest(ncall) = 'ZMFPRT'

      call zmfpcz(form1, ma(1), kwidre)
      call fmeq(ma(2), mxy(1))
      if (mxy(1)%mp(1) >= 0) then
          lsign = 1
      else
          lsign = -1
          call fmnegate(mxy(1))
      endif
      call zmfpcm(form2, mxy(1), kwidim)

      if (kwidre+kwidim+50 > lmbufz) then
          if (lmbufz > 0) deallocate(cmbufz)
          allocate(cmbufz(kwidre+kwidim+50), stat=j)
          if (j /= 0) then
              call fmdefine_error
          endif
          lmbufz = kwidre + kwidim + 50
          call zmfpcz(form1, ma(1), kwidre)
      endif

      cmbufz(kwidre+1) = ' '
      if (lsign == 1) then
          cmbufz(kwidre+2) = '+'
      else
          cmbufz(kwidre+2) = '-'
      endif
      cmbufz(kwidre+3) = ' '
      do j = 1, kwidim
         cmbufz(kwidre+3+j) = cmbuff(j)
      enddo
      cmbufz(kwidre+4+kwidim) = ' '
      cmbufz(kwidre+5+kwidim) = 'i'
      if (jformz == 2) cmbufz(kwidre+5+kwidim) = 'I'
      last = kwidre + kwidim + 5

      if (mxy(1)%mp(2) == mexpov .or. mxy(1)%mp(2) == mexpun) then
          do j = kwidre+3, last
             if (cmbufz(j) == 'O' .or. cmbufz(j) == 'U') then
                 cmbufz(j-2) = ' '
                 exit
             endif
          enddo
      endif

      write (form, "(' (6X, ', I3, 'A1) ')") kswide-7
      write (kw, form) (cmbufz(k), k=1, last)
      ncall = ncall - 1

      return
      end subroutine zmfprt

      subroutine zmgam(ma, mb)

!  mb = gamma(ma)

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(2, 15), mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmgam_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmgam_m1(ma, mxy, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmgam

      subroutine zmgam_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing gam(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(2, 15), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      double precision :: xe
      integer :: j, km, krnd, n
      logical, external :: fmcomp

      call zmequ(ma, mxy(1:2, 1), ndsave, ndig)

!             Check for special cases.

      if (ma(2)%mp(3) == 0) then
          call fmint(mxy(1, 1), mxy(1, 15))
          if (fmcomp(mxy(1, 1), '==', mxy(1, 15))) then
              call zmunknown(mresult)
              kflag = -4
              return
          endif
      endif
      km = 0
      call fmi2m(1, mxy(1, 7))
      call fmovun_xe(mxy(2, 1), xe)
      if (xe <= -ndig/2) then
          krnd = kround
          kround = 1
          call fmpsi(mxy(1, 1), mxy(1, 8))
          if (mxy(1, 8)%mp(2) == munkno .and. mxy(1, 8)%mp(5) >= 0 .and.  &
              mxy(1, 1)%mp(2) /= mexpov) then
              km = 2
          else
              call fmpgam(1, mxy(1, 1), mxy(1, 9))
              call fmsqr(mxy(2, 1), mxy(1, 11))
              call fmsqr(mxy(1, 8), mxy(1, 12))
              call fmadd(mxy(1, 12), mxy(1, 9), mxy(1, 13))
              call fmmpy_r1(mxy(1, 13), mxy(1, 11))
              call fmdivi_r1(mxy(1, 13), 2)
              call fmsub(mxy(1, 7), mxy(1, 13), mxy(1, 14))
              if (fmcomp(mxy(1, 7), '==', mxy(1, 14))) then
                  call fmpgam(2, mxy(1, 1), mxy(1, 10))
                  call fmipwr(mxy(1, 8), 3, mxy(1, 12))
                  call fmmpy(mxy(1, 8), mxy(1, 9), mxy(1, 13))
                  call fmmpyi_r1(mxy(1, 13), 3)
                  call fmadd_r1(mxy(1, 12), mxy(1, 13))
                  call fmadd(mxy(1, 12), mxy(1, 10), mxy(1, 13))
                  call fmmpy_r1(mxy(1, 13), mxy(1, 11))
                  call fmdivi_r1(mxy(1, 13), 6)
                  call fmsub(mxy(1, 8), mxy(1, 13), mxy(1, 14))
                  if (fmcomp(mxy(1, 8), '==', mxy(1, 14))) km = 1
              endif
              kround = krnd
          endif
      endif
      call zmabs(mxy(1:2, 1), mxy(1, 2))
      call fmipwr(mxy(1, 2), 3, mxy(1, 3))
      call fmi2m(1, mxy(1, 4))
      call fmulp(mxy(1, 4), mxy(1, 5))
      if (fmcomp(mxy(1, 3), '<=', mxy(1, 5))) then
          call fmi2m(0, mxy(2, 4))
          call zmdiv(mxy(1:2, 4), mxy(1:2, 1), mxy(1:2, 5))
          call fmeuler(mxy(1, 4))
          call fmsub_r1(mxy(1, 5), mxy(1, 4))
          call fmsqr_r1(mxy(1, 4))
          call fmmpyi_r1(mxy(1, 4), 6)
          call fmpi(mxy(1, 3))
          call fmsqr_r1(mxy(1, 3))
          call fmadd_r1(mxy(1, 4), mxy(1, 3))
          call fmdivi_r1(mxy(1, 4), 12)
          call zmmpy(mxy(1:2, 1), mxy(1:2, 4), mxy(1:2, 3))
          call zmadd_r2(mxy(1:2, 5), mxy(1:2, 3))
      else if (km == 1) then
          call fmgam(mxy(1, 1), mxy(1, 3))
          call fmmpy(mxy(1, 3), mxy(1, 8), mxy(1, 5))
          call fmmpy(mxy(1, 5), mxy(2, 1), mxy(2, 3))
      else if (km == 2) then
          call fmm2i(mxy(1, 1), n)
          if (kflag == 0) then
              n = -n
          else
              n = -99
          endif
          if (n > 0 .and. n <= max(100, 10*ndig)) then
              call fmi2m(1, mxy(1, 4))
              call fmi2m(1, mxy(1, 5))
              do j = 2, n
                 call fmmpyi(mxy(1, 4), j, mxy(1, 6))
                 call fmmpyi_r1(mxy(1, 5), j-1)
                 call fmadd(mxy(1, 5), mxy(1, 6), mxy(1, 4))
              enddo
              call fmmpyi_r1(mxy(1, 5), n)
              call fmdiv(mxy(1, 4), mxy(1, 5), mxy(1, 6))
          else
              call fmi2m(1, mxy(1, 8))
              call fmmpyi(mxy(1, 1), -1, mxy(1, 4))
              call fmi2m(1, mxy(1, 7))
              call fmsqr(mxy(1, 4), mxy(1, 9))
              call fmln(mxy(1, 4), mxy(1, 6))
              call fmeulr(mxy(1, 2))
              call fmadd_r1(mxy(1, 6), mxy(1, 2))
              call fmmpyi(mxy(1, 4), 2, mxy(1, 2))
              call fmdiv_r2(mxy(1, 8), mxy(1, 2))
              call fmadd_r1(mxy(1, 6), mxy(1, 2))
              do j = 2, 10**9, 2
                 call fmmpy_r1(mxy(1, 7), mxy(1, 9))
                 call fmmpyi(mxy(1, 7), j, mxy(1, 2))
                 call fmdiv_r2(mxy(1, 8), mxy(1, 2))
                 call fmbern(j, mxy(1, 2), mxy(1, 10))
                 call fmsub_r1(mxy(1, 6), mxy(1, 10))
                 if (kflag == 1) exit
              enddo
          endif
          call fmeulr(mxy(1, 2))
          call fmsub(mxy(1, 6), mxy(1, 2), mxy(1, 3))
          call fmmpyi(mxy(1, 1), -1, mxy(1, 4))
          call fmfact(mxy(1, 4), mxy(1, 5))
          call fmdiv_r1(mxy(1, 3), mxy(1, 5))
          call fmmpyi(mxy(1, 1), -1, mxy(1, 4))
          call fmfact(mxy(1, 4), mxy(1, 2))
          call fmmpy_r1(mxy(1, 2), mxy(2, 1))
          call fmi2m(-1, mxy(1, 8))
          call fmdiv(mxy(1, 8), mxy(1, 2), mxy(2, 3))
          call fmi2m(2, mxy(1, 5))
          call fmmod(mxy(1, 4), mxy(1, 5), mxy(1, 7))
          if (mxy(1, 7)%mp(3) /= 0) then
              call zmmpyi(mxy(1:2, 3), -1, mxy(1:2, 4))
              call zmeq(mxy(1:2, 4), mxy(1:2, 3))
          endif
      else if (mxy(1, 1)%mp(2) == mexpun) then
          call zmeq(mxy(1:2, 1), mxy(1:2, 2))
          call fmi2m(0, mxy(1, 2))
          call zmlngm(mxy(1:2, 2), mxy(1:2, 4))
          call zmexp(mxy(1:2, 4), mxy(1:2, 3))
      else
          call zmlngm(mxy(1:2, 1), mxy(1:2, 2))
          call zmexp(mxy(1:2, 2), mxy(1:2, 3))
      endif

      call zmeq(mxy(1:2, 3), mresult)

      return
      end subroutine zmgam_m1

      subroutine zmgam_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = gam(ma).

!  kresult = 1 is returned if a special case gives the value of gam(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMGAM    '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

!             If ma is real and positive, use fmgam.

      if (malocal(2)%mp(3) == 0) then
          if (malocal(1)%mp(1) > 0 .and. malocal(1)%mp(3) > 0) then
              call fmgam(malocal(1), mresult(1))
              call fmi2m(0, mresult(2))
              kresult = 1
              return
          endif
      endif

      return
      end subroutine zmgam_sc

      subroutine zmi2m(integ, ma)

!  ma = integ

!  The real part of ma is set to the one word integer value integ.
!  The imaginary part is set to zero.

      use fmvals
      implicit none

      integer :: integ
      type(multi) :: ma(2)
      intent (in) :: integ
      intent (inout) :: ma

      ncall = ncall + 1
      namest(ncall) = 'ZMI2M'
      if (ntrace /= 0) call fmntr_inpi(integ)

      call fmi2m(integ, ma(1))
      call fmi2m(0, ma(2))

      if (ntrace /= 0) call zmntr_out1(ma)
      ncall = ncall - 1

      return
      end subroutine zmi2m

      subroutine zmimag(ma, mbfm)

!  mbfm = imag(ma)        imaginary part of ma

!  ma is a complex zm number, mbfm is a real fm number.

      use fmvals
      implicit none

      type(multi) :: ma(2), mbfm
      intent (in) :: ma
      intent (inout) :: mbfm

      kflag = 0
      ncall = ncall + 1
      namest(ncall) = 'ZMIMAG'
      if (ntrace /= 0) call zmntr_inp1(ma)

      call fmeq(ma(2), mbfm)

      if (ntrace /= 0) call fmntr_out1(mbfm)
      ncall = ncall - 1

      return
      end subroutine zmimag

      subroutine zminp(line, ma, la, lb)

!  Convert an a1 character string to floating point multiple precision complex format.

!  line is an a1 character array of length lb to be converted to zm format and returned in ma.
!  Convert the section line(la:lb).

!  The input numbers may be in integer or any real format.
!  In exponential format the 'e' may also be 'd', 'q', or 'm'.

!  The following are all valid input strings:

!  1.23 + 4.56 i
!  1.23 + 4.56*i
!  2 + i
!  -i
!  1.23
!  4.56i
!  ( 1.23 , 4.56 )

!  So that zminp will convert any output from zmout, line is tested to see if the input contains any
!  of the special symbols +overflow, -overflow, +underflow, -underflow, or unknown.
!  For user input the abbreviations ovfl, unfl, unkn may be used.

      use fmvals
      implicit none

      integer :: la, lb
      character :: line(lb)
      type(multi) :: ma(2)
      intent (in) :: line, la, lb
      intent (inout) :: ma
      integer :: j, jstate, k, kdigfl, kflag1, kiflag, kpt, krsave, ksign, kstart, kstop,  &
                 kstopi, kstopr, kstrti, kstrtr, ktype, kval, ndsave, ntrsav

!  Simulate a finite-state automaton to scan the input line and build the number.
!  States 2-8 refer to the real part, states 10-16 refer to the imaginary part.
!  States of the machine:

!   1.  Initial entry to the subroutine
!   2.  Sign of the number
!   3.  Scanning digits before a decimal point
!   4.  Decimal point
!   5.  Scanning digits after a decimal point
!   6.  e, d, q, or m - precision indicator before the exponent
!   7.  Sign of the exponent
!   8.  Scanning exponent
!   9.  Comma between the real and imaginary part
!  10.  Sign of the number
!  11.  Scanning digits before a decimal point
!  12.  Decimal point
!  13.  Scanning digits after a decimal point
!  14.  e, d, q, or m - precision indicator before the exponent
!  15.  Sign of the exponent
!  16.  Scanning exponent
!  17.  Syntax error

!  Character types recognized by the machine:

!  1.  Sign (+,-)
!  2.  Numeral (0,1,...,9)
!  3.  Decimal point (.)
!  4.  Precision indicator (e,d,q,m)
!  5.  Illegal character for number
!  6.  Comma (,)
!  7.  Character to be ignored   ' '    '('    ')'    '*'

!  All blanks are ignored.  The analysis of the number proceeds as follows:  If the simulated
!  machine is in state jstate and a character of type jtype is encountered the new state of the
!  machine is given by jtrans_zm(jstate,jtype).

!  State  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16

      integer :: jtrans_zm(16, 4) = reshape(  (/                              &
          2, 17, 10, 10, 10,  7, 17, 10, 10, 17, 17, 17, 17, 15, 17, 17,      &
          3,  3,  3,  5,  5,  8,  8,  8, 11, 11, 11, 13, 13, 16, 16, 16,      &
          4,  4,  4, 17, 17, 17, 17, 17, 12, 12, 12, 17, 17, 17, 17, 17,      &
          6,  6,  6,  6,  6,  8, 17, 17, 14, 14, 14, 14, 14, 16, 17, 17   /)  &
        , (/ 16, 4 /) )
      type(multi), save :: mxy(2)

      call zmalloc(ma, ndig+2)

      if (mblogs /= mbase) call fmcons
      ncall = ncall + 1
      namest(ncall) = 'ZMINP'
      ndsave = ndig
      krsave = kround
      kround = 1
      kflag = 0

!             Initialize two hash tables that are used for character look-up during
!             input conversion.

      if (lhash == 0) call fmhtbl

!             Since arithmetic tracing is not usually desired during i/o conversion, disable
!             tracing during this routine.

      ntrsav = ntrace
      ntrace = 0

!             Increase the working precision.

      if (ncall <= 2) then
          k = ngrd52
          ndig = max(ndig+k, 3)
      endif
      kstart = la
      kstop = lb
      jstate = 1
      kstrtr = 0
      kstopr = 0
      kstrti = 0
      kstopi = 0
      kdigfl = 0
      kiflag = 0
      ksign = 1

!             Scan the number.

      do j = kstart, kstop
         if (line(j) == ' ' .or. line(j) == '(' .or. line(j) == ')' .or. line(j) == '*') cycle
         if (line(j) == 'I' .or. line(j) == 'i') then
             kiflag = 1
             if (kstrti == 0) then
                 kstrti = kstrtr
                 kstopi = kstopr
                 kstrtr = 0
                 kstopr = 0
             endif
             cycle
         endif

         kpt = ichar(line(j))
         if (kpt < lhash1 .or. kpt > lhash2) then
             write (kw,                                                         &
                "(/' Error in input conversion.'/"                          //  &
                "' ICHAR function was out of range for the current', "      //  &
                "' dimensions.'/' ICHAR(''', A, ''') gave the value ', "    //  &
                "I12, ', which is outside the currently'/' dimensioned', "  //  &
                "' bounds of (', I5, ':', I5, ') for variables KHASHT ', "  //  &
                "'and KHASHV.'/' Re-define the two parameters ', "          //  &
                "'LHASH1 and LHASH2 so the dimensions will'/' contain', "   //  &
                "' all possible output values from ICHAR.'//)"                  &
                   ) line(j), kpt, lhash1, lhash2
             ktype = 5
             kval  = 0
         else
             ktype = khasht(kpt)
             kval  = khashv(kpt)
         endif
         if (ktype == 2 .or. ktype == 5) kdigfl = 1
         if (line(j) == ',') then
             if (jstate < 9) then
                 jstate = 9
             else
                 call zminp2(ma, ndsave, ntrsav, krsave)
                 return
             endif
         else
             if (ktype >= 5) ktype = 2
             if (jstate < 17) jstate = jtrans_zm(jstate, ktype)
         endif
         if (jstate == 9 .or. jstate == 10) kdigfl = 0
         if (jstate == 2 .or. jstate == 10) ksign = kval

         if (jstate >= 2 .and. jstate <= 8) then
             if (kstrtr == 0) kstrtr = j
             kstopr = j
         endif
         if (jstate >= 10 .and. jstate <= 16) then
             if (kstrti == 0) kstrti = j
             kstopi = j
         endif

      enddo

!             Form the number and return.

      if (kstrtr > 0) then
          ncall = ncall - 1
          call fminp(line, mxy(1), kstrtr, kstopr)
          ncall = ncall + 1
      else
          call fmi2m2(0, mxy(1))
      endif
      kflag1 = kflag

      if (kstrti > 0) then
          if (kiflag == 1 .and. kdigfl == 0) then
              call fmi2m2(ksign, mxy(2))
          else
              ncall = ncall - 1
              call fminp(line, mxy(2), kstrti, kstopi)
              ncall = ncall + 1
          endif
      else if (kiflag == 1) then
          call fmi2m2(1, mxy(2))
      else
          call fmi2m2(0, mxy(2))
      endif

      if (kflag1 /= 0 .or. kflag /= 0 .or. jstate == 17) then
          call zminp2(ma, ndsave, ntrsav, krsave)
          return
      endif
      call fmequ(mxy(1), ma(1), ndig, ndsave)
      call fmequ(mxy(2), ma(2), ndig, ndsave)

      ndig = ndsave
      ntrace = ntrsav
      kround = krsave
      kflag = 0
      ncall = ncall - 1

      return
      end subroutine zminp

      subroutine zminp2(ma, ndsave, ntrsav, krsave)

!  Handle error conditions for zminp.

      use fmvals
      implicit none

      integer :: ndsave, ntrsav, krsave
      type(multi) :: ma(2)
      intent (in) :: ndsave, ntrsav, krsave
      intent (inout) :: ma

      kflag = -7
      call fmwarn
      call zmunknown(ma)

      ndig = ndsave
      ntrace = ntrsav
      kround = krsave
      ncall = ncall - 1

      return
      end subroutine zminp2

      subroutine zmint(ma, mb)

!  mb = int(ma)

!  The integer parts of both real and imaginary values are returned.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      ncall = ncall + 1
      namest(ncall) = 'ZMINT'
      if (ntrace /= 0) call zmntr_inp1(ma)

      call fmint(ma(1), mb(1))
      call fmint(ma(2), mb(2))

      if (ntrace /= 0) call zmntr_out1(mb)
      ncall = ncall - 1

      return
      end subroutine zmint

      subroutine zmipower(ma, ival, mb)

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb

      call zmipwr(ma, ival, mb)

      return
      end subroutine zmipower

      subroutine zmipwr(ma, ival, mb)

!  mb = ma**ival

!  Raise a zm number to an integer power.
!  The binary multiplication method used requires an average of 1.5 * log2(ival) multiplications.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmipwr_sc(ma, ival, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmipwr_m1(ma, ival, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmipwr

      subroutine zmipwr_m1(ma, ival, mresult, ndsave)

!  Method 1 for computing ma**ival.

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: ival, ndsave
      intent (in) :: ma, ival, ndsave
      intent (inout) :: mresult

      integer :: i2n, k, kwrnsv
      real :: xval
      type(multi), save :: mz01(2), mz02(2), mz03(2), mz04(2), mz05(2)

      call zmequ(ma, mz01, ndsave, ndig)

      if (mz01(2)%mp(3) == 0) then
          call fmipwr(mz01(1), ival, mresult(1))
          call fmi2m2(0, mresult(2))
          return
      endif

      if (mz01(1)%mp(3) == 0) then
          if (ival >= 0) then
              i2n = mod(ival, 4)
          else
              i2n = mod(4 - mod(abs(ival), 4), 4)
          endif
          if (i2n == 0) then
              call fmipwr(mz01(2), ival, mresult(1))
              call fmi2m2(0, mresult(2))
          else if (i2n == 1) then
              call fmipwr(mz01(2), ival, mresult(2))
              call fmi2m2(0, mresult(1))
          else if (i2n == 2) then
              call fmipwr(mz01(2), ival, mresult(1))
              call fmi2m2(0, mresult(2))
              call fmnegate(mresult(1))
          else if (i2n == 3) then
              call fmipwr(mz01(2), ival, mresult(2))
              call fmi2m2(0, mresult(1))
              call fmnegate(mresult(2))
          endif
          return
      endif

      if (ival == -1) then
          kwrnsv = kwarn
          kwarn = 0
          k = int((5.0d0*dlogtn)/dlogmb + 2.0d0)
          ndig = max(ndig+k, 3)
          call zmi2m(1, mz02)
          call zmequ(ma, mz03, ndsave, ndig)
          call zmdiv(mz02, mz03, mresult)
          kwarn = kwrnsv
          return
      endif

!             Increase the working precision.

      if (ncall == 1) then
          xval = abs(ival) + 1
          k = int((5.0*real(dlogtn) + 2.5*log(xval))/alogmb + 3.0)
          if (mbase <= 1000) k = 2*k
          ndig = max(ndig+k, 3)
      else
          xval = abs(ival) + 1
          k = int(log(xval)/alogmb + 1.0)
          ndig = ndig + k
      endif
      call zmequ(ma, mz02, ndsave, ndig)

!             Initialize.

      kwrnsv = kwarn
      kwarn = 0
      k = abs(ival)
      if (mod(k, 2) == 0) then
          call zmi2m(1, mz05)
      else
          call zmeq(mz02, mz05)
      endif

!             This is the multiplication loop.

      do while (k > 1)
         k = k/2
         call zmsqr(mz02, mz04)
         call zmeq(mz04, mz02)
         if (mod(k, 2) == 1) then
             call zmmpy_r2(mz02, mz05)
         endif
      enddo

!             Invert if the exponent is negative.

      if (ival < 0) then
          call zmi2m(1, mz02)
          call zmdiv_r2(mz02, mz05)
      endif
      kwarn = kwrnsv

      call zmeq(mz05, mresult)

      return
      end subroutine zmipwr_m1

      subroutine zmipwr_sc(ma, ival, ndsave, mresult, kresult)

!  Check for special cases for mresult = ma**ival.

!  kresult = 1 is returned if a special case gives the value of ma**ival.

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: ival, kresult, ndsave
      intent (in) :: ma, ival, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMIPWR   '
      j = ndig
      ndig = ndsave
      call zmntr_inp1i(ma, ival)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
          if (ival == 0) then
              call zmunknown(mresult)
          else
              call zmi2m(0, mresult)
          endif
          kresult = 1
          return
      endif

      if (ival == 1) then
          call zmeq(malocal, mresult)
          kresult = 1
          return
      else if (ival == 2) then
          call zmsqr(malocal, mresult)
          kresult = 1
          return
      else if (ival == 0) then
          call zmi2m(1, mresult)
          kresult = 1
          return
      endif

      return
      end subroutine zmipwr_sc

      subroutine zmlg10(ma, mb)

!  mb = log10(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy, mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmlg10_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmlg10_m1(ma, mxy, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmlg10

      subroutine zmlg10_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing log10(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy, mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      type(multi), save :: mz01(2), mz02(2)

      call zmequ(ma, mz01, ndsave, ndig)
      call zmln(mz01, mz02)
      call fmlni(10, mxy)
      call fmdivd(mz02(1), mz02(2), mxy, mresult(1), mresult(2))

      return
      end subroutine zmlg10_m1

      subroutine zmlg10_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = log10(ma).

!  kresult = 1 is returned if a special case gives the value of log10(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMLG10   '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      return
      end subroutine zmlg10_sc

      subroutine zmln(ma, mb)

!  mb = ln(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(4), mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmln_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmln_m1(ma, mxy, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmln

      subroutine zmln_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing ln(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(4), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      integer :: kf1, krsave
      type(multi), save :: mz01(2), mz02(2)
      logical, external :: fmcomp

      call zmequ(ma, mz02, ndsave, ndig)

      krsave = krad
      krad = 1
      if (ma(2)%mp(3) == 0) then
          if (ma(1)%mp(1) < 0) then
              call fmeq(mz02(1), mz01(1))
              call fmnegate(mz01(1))
              call fmln(mz01(1), mxy(4))
              call fmeq(mxy(4), mz01(1))
              call fmpi(mz01(2))
          else
              call fmln(mz02(1), mz01(1))
              call fmi2m(0, mz01(2))
          endif
          krad = krsave
          call zmeq(mz01, mresult)
          return
      else if (ma(1)%mp(3) == 0) then
          if (ma(2)%mp(1) < 0) then
              call fmeq(mz02(2), mz01(1))
              call fmnegate(mz01(1))
              call fmln(mz01(1), mxy(4))
              call fmeq(mxy(4), mz01(1))
              call fmpi(mz01(2))
              call fmdivi_r1(mz01(2), -2)
          else
              call fmln(mz02(2), mz01(1))
              call fmpi(mz01(2))
              call fmdivi_r1(mz01(2), 2)
          endif
          krad = krsave
          call zmeq(mz01, mresult)
          return
      endif

!             ln(a + b i) = ln(abs(a + b i)) + arg(a + b i) i.

      call fmabs(mz02(1), mxy(1))
      call fmabs(mz02(2), mxy(2))

!             Check for cancellation in ln(x).

      call fmi2m(1, mxy(3))
      kf1 = 0
      if (fmcomp(mxy(1), '==', mxy(3)) .and. mxy(2)%mp(2) <= -ndsave) kf1 = 1
      if (fmcomp(mxy(2), '==', mxy(3)) .and. mxy(1)%mp(2) <= -ndsave) kf1 = 1

      if (fmcomp(mxy(1), '>=', mxy(2))) then
          call fmsub(mz02(1), mxy(3), mxy(1))
          call fmadd(mz02(1), mxy(3), mxy(2))
          call fmmpy_r1(mxy(1), mxy(2))
          call fmsqr(mz02(2), mxy(2))
          call fmadd_r2(mxy(1), mxy(2))
      else
          call fmsub(mz02(2), mxy(3), mxy(1))
          call fmadd(mz02(2), mxy(3), mxy(2))
          call fmmpy_r1(mxy(1), mxy(2))
          call fmsqr(mz02(1), mxy(2))
          call fmadd_r2(mxy(1), mxy(2))
      endif
      call zmabs(mz02, mz01(1))
      call fmadd(mz01(1), mxy(3), mxy(1))
      call fmdiv_r2(mxy(2), mxy(1))
      if (kf1 == 1) then
          call fmeq(mxy(1), mz01(1))
          call fmatn2(mz02(2), mz02(1), mz01(2))
          krad = krsave
          call zmeq(mz01, mresult)
          return
      else if (mxy(1)%mp(2) < 0) then
          ndig = ndig - int(mxy(1)%mp(2))
          if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
          call zmequ_r1(mz02, ndsave, ndig)
          call zmabs(mz02, mz01(1))
      endif

      call fmln(mz01(1), mxy(4))
      call fmeq(mxy(4), mz01(1))
      call fmatn2(mz02(2), mz02(1), mz01(2))
      krad = krsave

      call zmeq(mz01, mresult)

      return
      end subroutine zmln_m1

      subroutine zmln_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = ln(ma).

!  kresult = 1 is returned if a special case gives the value of ln(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMLN     '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          kflag = -4
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      return
      end subroutine zmln_sc

      subroutine zmlngm(ma, mb)

!  mb = LogGamma(ma)

!  In the complex plane this Log Gamma function is not identical to ln(gamma(ma)), because of
!  branch points in the complex log function.

!  This function returns the function value of the principal branch of the log gamma function.
!  It is the same as ln(gamma(ma)) when ma is a positive real number, but it can differ from
!  ln(gamma(ma)) by an integer multiple of 2*pi*i elsewhere.  Note that we still have
!  gamma(z) = exp(loggamma(z)) = exp(ln(gamma(z))) even when they differ.

!     Ref:  d.e.g. Hare, "Computing the Principal Branch of log-Gamma"
!           Journal of Algorithms, Volume 25, Issue 2, November 1997, Pages 221-236

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(2, 15), mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmlngm_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call zmlngm_m1(ma, mxy, mresult, ndsave, numtry)
         call zmcheck_accuracy(mresult, ndsave, retry)
         numtry = numtry + 1
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmlngm

      subroutine zmlngm_m1(ma, mxy, mresult, ndsave, numtry)

!  Method 1 for computing lngm(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(2, 15), mresult(2)
      integer :: ndsave, numtry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult

      double precision :: x, xe, xk, xs
      integer :: j, j1, j2, jc, js, kl, ks, kt, kz, large, nd, nd1, ndsav1, nterm
      type(multi), save :: mjsums(2, ljsums)
      logical, external :: fmcomp

      call zmequ(ma, mxy(1:2, 1), ndsave, ndig)

!             Check for special cases.

      if (ma(2)%mp(3) == 0) then
          call fmint(mxy(1, 1), mxy(1, 15))
          if (fmcomp(mxy(1, 1), '==', mxy(1, 15))) then
              call zmunknown(mresult)
              kflag = -4
              return
          endif
      endif
      call zmabs(mxy(1:2, 1), mxy(1, 2))
      call fmi2m(1, mxy(1, 4))
      if (fmcomp(mxy(1, 2), '<', mxy(1, 4))) then
          call zmln(mxy(1:2, 1), mxy(1:2, 4))
          call zmnegate(mxy(1:2, 4))
          call fmeuler(mxy(1, 5))
          call fmi2m(0, mxy(2, 5))
          call zmmpy_r1(mxy(1:2, 5), mxy(1:2, 1))
          call zmsub_r1(mxy(1:2, 4), mxy(1:2, 5))
          call fmpi(mxy(1, 3))
          call fmsqr_r1(mxy(1, 3))
          call fmdivi_r1(mxy(1, 3), 12)
          call fmi2m(0, mxy(2, 3))
          call zmsqr(mxy(1:2, 1), mxy(1:2, 5))
          call zmmpy(mxy(1:2, 3), mxy(1:2, 5), mxy(1:2, 6))
          call zmadd_r1(mxy(1:2, 4), mxy(1:2, 6))
          call zmmpy_r1(mxy(1:2, 5), mxy(1:2, 1))
          call zmmpyi(mxy(1:2, 5), 4, mxy(1:2, 6))
          call zmdivi_r1(mxy(1:2, 6), 10)
          call zmsub(mxy(1:2, 4), mxy(1:2, 6), mresult)
          if (kflag == 1) then
              return
          endif
      endif
      if (mxy(2, 1)%mp(2) == mexpun) then
          call fmlngm(mxy(1, 1), mxy(1, 3))
          call fmpsi(mxy(1, 1), mxy(1, 4))
          call fmmpy(mxy(2, 1), mxy(1, 4), mxy(2, 3))
          call zmeq(mxy(1:2, 3), mresult)
          return
      endif

!             x is a double precision approximation to the size of input argument to this function.

      call zmabs(mxy(1:2, 1), mxy(1, 4))
      call fmm2dp(mxy(1, 4), x)
      call fmovun_xe(mxy(1, 4), xe)
      if (kflag /= 0 .and. xe < 0) then
          x = 1.0d0/dpmax**0.33d0
      else if (kflag == 0 .and. x < 1.0d0/dpmax**0.33d0) then
          x = 1.0d0/dpmax**0.33d0
      endif
      if (kflag /= 0 .and. xe > 0) then
          x = dpmax**0.33d0
      else if (kflag == 0 .and. x > dpmax**0.33d0) then
          x = dpmax**0.33d0
      endif

!             Determine the smallest shift js for which the asymptotic series for ln(gamma(x+js))
!             converges for the current precison.

      call zmeq(mxy(1:2, 1), mxy(1:2, 2))
      mxy(1, 2)%mp(1) = 1
      xk = 1.5d0*log(abs(x)) - 2*3.14159*abs(x)
      if (abs(x) < 2) xk = 0
      if (-xk/dlogmb > ndig+(3+ndig/20)*ngrd52) then
          js = 0
      else
          j1 = 1
          j2 = j1
          do while (-xk/dlogmb <= ndig+(3+ndig/20)*ngrd52)
             j2 = 2*j2
             call zmi2m(j2, mxy(1:2, 5))
             call zmadd(mxy(1:2, 2), mxy(1:2, 5), mxy(1:2, 6))
             call zmabs(mxy(1:2, 6), mxy(1, 4))
             call fmm2dp(mxy(1, 4), xs)
             xk = 1.5d0*log(xs) - 2*3.14159*xs
          enddo
          js = j2
          do while (abs(j2-j1) > 1)
             js = (j1 + j2) / 2
             call zmi2m(js, mxy(1:2, 5))
             call zmadd(mxy(1:2, 2), mxy(1:2, 5), mxy(1:2, 6))
             call zmabs(mxy(1:2, 6), mxy(1, 4))
             call fmm2dp(mxy(1, 4), xs)
             xk = 1.5d0*log(xs) - 2*3.14159*xs
             if (-xk/dlogmb > ndig+(3+ndig/20)*ngrd52) then
                 j2 = js
             else
                 j1 = js
             endif
          enddo
      endif

!             Use the asymptotic series after replacing input z by 1-z via the reflection formula
!             if re(z) < 0, by conjugate(z) if im(z) < 0, and by z+js if needed for enough accuracy.

      call zmeq(mxy(1:2, 1), mxy(1:2, 2))
      if (ma(1)%mp(1) < 0) then
          call zmi2m(1, mxy(1:2, 15))
          call zmsub_r2(mxy(1:2, 15), mxy(1:2, 2))
      endif
      jc = 0
      if (mxy(2, 2)%mp(1) < 0) then
          jc = 1
          call fmnegate(mxy(2, 2))
      endif
      call zmi2m(js, mxy(1:2, 5))
      call zmadd_r1(mxy(1:2, 2), mxy(1:2, 5))
      if (numtry <= 0 .and. ncall <= 1) then
          ndig = max(ndsave+ngrd52, ndig-1)
      endif
      j2 = int(0.3*alogmb + 0.2*sqrt(real(ndig)))
      j2 = max(1, min(ljsums, j2))

      ndsav1 = ndig

!             Split into j2 concurrent sums.

      call zmsqr(mxy(1:2, 2), mxy(1:2, 6))
      call zmi2m(1, mxy(1:2, 15))
      call zmdiv_r2(mxy(1:2, 15), mxy(1:2, 6))
      call zmipwr(mxy(1:2, 6), j2, mxy(1:2, 7))
      call zmeq(mxy(1:2, 2), mxy(1:2, 8))

      nterm = 0
      call zmln(mxy(1:2, 2), mxy(1:2, 10))
      call zmi2m(1, mxy(1:2, 11))
      call zmdivi_r1(mxy(1:2, 11), 2)
      call zmsub(mxy(1:2, 2), mxy(1:2, 11), mxy(1:2, 12))
      call zmmpy(mxy(1:2, 10), mxy(1:2, 12), mxy(1:2, 11))
      call zmsub(mxy(1:2, 11), mxy(1:2, 2), mxy(1:2, 10))
      call fmpi(mxy(1, 11))
      call fmmpyi_r1(mxy(1, 11), 2)
      call fmln(mxy(1, 11), mxy(1, 12))
      call fmdivi_r1(mxy(1, 12), 2)
      call fmi2m(0, mxy(2, 12))
      call zmadd(mxy(1:2, 10), mxy(1:2, 12), mjsums(1:2, 1))
      do j = 2, j2
         nterm = nterm + 1
         call fmbern(2*nterm, mxy(1, 8), mxy(1, 15))
         call fmbern(2*nterm, mxy(2, 8), mxy(2, 15))
         call zmdivi(mxy(1:2, 15), (2*nterm-1)*2*nterm, mjsums(1:2, j))
      enddo

      call zmi2m(0, mxy(1:2, 9))
      call zmi2m(0, mxy(1:2, 13))
      call zmeq(mjsums(1:2, j2), mxy(1:2, 13))

      kl = 1
      do while (kl == 1)
         call zmmpy_r2(mxy(1:2, 7), mxy(1:2, 8))
         do j = 1, j2
            nterm = nterm + 1
            large = int(intmax/(2*nterm))/(2*nterm)
            call fmbern(2*nterm, mxy(1, 8), mxy(1, 15))
            call fmbern(2*nterm, mxy(2, 8), mxy(2, 15))
            if (nterm < large) then
                call zmdivi_r1(mxy(1:2, 15), (2*nterm-1)*2*nterm)
            else
                call zmdivi_r1(mxy(1:2, 15), 2*nterm-1)
                call zmdivi_r1(mxy(1:2, 15), 2*nterm)
            endif
            ndig = ndsav1
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 15))
            if (kflag /= 0) then
                kl = 0
                exit
            endif
            if (j == j2) then
                call zmeq(mxy(1:2, 9), mxy(1:2, 13))
                call zmeq(mxy(1:2, 15), mxy(1:2, 9))
            endif
            kt = max(19000, int(6*alogmt*ndsave))
            if (nterm > kt) then
                call zmabs(mxy(1:2, 9), mxy(1, 15))
                call zmabs(mxy(1:2, 13), mxy(2, 15))
                if (fmcomp(mxy(1, 15), '>', mxy(2, 15))) then
                    call zmunknown(mresult)
                    return
                endif
            endif
            nd = mjsums(1, j)%mp(2)-mxy(1, 15)%mp(2)
            nd1 = mjsums(2, j)%mp(2)-mxy(2, 15)%mp(2)
            nd = ndsav1 - int(min(nd, nd1))
            ndig = min(ndsav1, nd)
            if (ndig < max(3, ngrd22)) ndig = max(3, ngrd22)
         enddo
      enddo

!             Put the j2 separate sums back together.

      kflag = 0
      call zmi2m(1, mxy(1:2, 5))
      do j = 2, j2
         call zmmpy_r1(mxy(1:2, 5), mxy(1:2, 6))
         call zmmpy(mxy(1:2, 5), mjsums(1:2, j), mxy(1:2, 15))
         call zmadd_r2(mxy(1:2, 15), mjsums(1:2, 1))
      enddo
      call zmeq(mjsums(1:2, 1), mxy(1:2, 3))

!             Reverse the effects of modifying the original argument.

!             Reverse any shifting.

      kz = 0
      ks = 1
      if (js /= 0) then
          call zmeq(mxy(1:2, 1), mxy(1:2, 14))
          if (ma(1)%mp(1) < 0) then
              call zmi2m(1, mxy(1:2, 15))
              call zmsub_r2(mxy(1:2, 15), mxy(1:2, 14))
          endif
          if (mxy(2, 14)%mp(1) < 0) then
              call fmnegate(mxy(2, 14))
          endif
          call zmi2m(1, mxy(1:2, 15))
          do j = 1, js
             call zmmpy_r1(mxy(1:2, 15), mxy(1:2, 14))
             if (mxy(2, 15)%mp(1) < 0 .and. ks == 1) kz = kz + 1
             ks = mxy(2, 15)%mp(1)
             call fmaddi(mxy(1, 14), 1)
          enddo
          call zmln(mxy(1:2, 15), mxy(1:2, 14))
          call zmsub_r1(mxy(1:2, 3), mxy(1:2, 14))
          call fmpi(mxy(2, 14))
          call fmmpyi_r1(mxy(2, 14), 2*kz)
          call fmsub_r1(mxy(2, 3), mxy(2, 14))
      endif

!             Reverse any conjugate.

      if (jc == 1) then
          call fmnegate(mxy(2, 3))
      endif

!             Reverse any reflection.

      if (ma(1)%mp(1) < 0) then
          call fmpi(mxy(1, 14))
          call fmi2m(0, mxy(2, 14))
          call zmmpy(mxy(1:2, 14), mxy(1:2, 1), mxy(1:2, 15))
          call zmsin(mxy(1:2, 15), mxy(1:2, 13))
          if (abs(mxy(1, 13)%mp(2)) >= mexpov .or.  &
              abs(mxy(2, 13)%mp(2)) >= mexpov) then
              call fmcos_sin(mxy(1, 15), mxy(2, 10), mxy(1, 10))
              if (mxy(2, 15)%mp(1) < 0) call fmnegate(mxy(2, 10))
              call zmarg(mxy(1:2, 10), mxy(2, 13))
              call fmnegate(mxy(2, 13))
              call fmmpyi(mxy(1, 14), 2, mxy(1, 12))
              call fmln(mxy(1, 12), mxy(1, 13))
              call fmabs(mxy(2, 15), mxy(1, 12))
              call fmsub_r1(mxy(1, 13), mxy(1, 12))
          else
              call zmdiv(mxy(1:2, 14), mxy(1:2, 13), mxy(1:2, 15))
              call zmln(mxy(1:2, 15), mxy(1:2, 13))
          endif
          call zmsub_r2(mxy(1:2, 13), mxy(1:2, 3))
          call fmdivi(mxy(1, 1), 2, mxy(1, 15))
          if (ma(2)%mp(3) == 0) then
              call fmi2m(4, mxy(1, 13))
          else
              call fmi2m(3, mxy(1, 13))
          endif
          call fmdivi_r1(mxy(1, 13), 4)
          call fmsub_r1(mxy(1, 15), mxy(1, 13))
          call fmint(mxy(1, 15), mxy(1, 11))
          call fmsub(mxy(1, 15), mxy(1, 11), mxy(1, 12))
          if (mxy(1, 12)%mp(3) == 0) then
              call fmeq(mxy(1, 15), mxy(1, 13))
          else if (mxy(1, 15)%mp(1) > 0) then
              call fmaddi(mxy(1, 11), 1)
              call fmeq(mxy(1, 11), mxy(1, 13))
          else
              call fmeq(mxy(1, 11), mxy(1, 13))
          endif
          call fmmpy(mxy(1, 13), mxy(1, 14), mxy(1, 11))
          if (ma(2)%mp(1) < 0) then
              call fmmpyi_r1(mxy(1, 11), -2)
          else
              call fmmpyi_r1(mxy(1, 11), 2)
          endif
          call fmadd_r1(mxy(2, 3), mxy(1, 11))
      endif

      call zmeq(mxy(1:2, 3), mresult)

      return
      end subroutine zmlngm_m1

      subroutine zmlngm_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = lngm(ma).

!  kresult = 1 is returned if a special case gives the value of lngm(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMLNGM   '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

!             If ma is real and positive, use fmlngm.

      if (malocal(2)%mp(3) == 0) then
          if (malocal(1)%mp(1) > 0 .and. malocal(1)%mp(3) > 0) then
              call fmlngm(malocal(1), mresult(1))
              call fmi2m(0, mresult(2))
              kresult = 1
              return
          endif
      endif

      return
      end subroutine zmlngm_sc

      subroutine zmlog10(ma, mb)

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      call zmlg10(ma, mb)

      return
      end subroutine zmlog10

      subroutine zmm2i(ma, integ)

!  integ = ma

!  integ is set to the integer value of the real part of ma

      use fmvals
      implicit none

      type(multi) :: ma(2)
      integer :: integ
      intent (in) :: ma
      intent (inout) :: integ

      ncall = ncall + 1
      namest(ncall) = 'ZMM2I'
      if (ntrace /= 0) call zmntr_inp1(ma)

      call fmm2i(ma(1), integ)

      if (ntrace /= 0) call fmntr_outi(integ)
      ncall = ncall - 1

      return
      end subroutine zmm2i

      subroutine zmm2z(ma, zval)

!  zval = ma

!  Complex variable zval is set to ma.

      use fmvals
      implicit none

      type(multi) :: ma(2)
      complex :: zval
      intent (in) :: ma
      intent (inout) :: zval

      real :: di, dr

      ncall = ncall + 1
      namest(ncall) = 'ZMM2Z'
      if (ntrace /= 0) call zmntr_inp1(ma)

      call fmm2sp(ma(1), dr)
      call fmm2sp(ma(2), di)
      zval = cmplx(dr, di)

      if (ntrace /= 0) call fmntr_outz(zval)
      ncall = ncall - 1

      return
      end subroutine zmm2z

      subroutine zmmpy(ma, mb, mc)

!  mc = ma * mb

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma, mb
      intent (inout) :: mc

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kr_retry, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(7), mresult(2)

      call zmalloc(mc, ndig+2)
      call zmenter2(ma, mb, kovun, mxsave, ndsave)
      call zmmpy_sc(ma, mb, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mc, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      kr_retry = 0
      retry = .true.
      do while (retry)
         retry = .false.
         call zmmpy_m1(ma, mb, mxy, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
         kr_retry = kr_retry + 1
         if (kr_retry > 1) exit
      enddo

      call zmexit1(mresult, mc, kovun, mxsave, ndsave)

      return
      end subroutine zmmpy

      subroutine zmmpy_m1(ma, mb, mxy, mresult, ndsave)

!  Method 1 for computing  mc = ma / mb

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2), mxy(7), mresult(2)
      integer :: ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult

      integer :: kl, nds, nmethd, ntrsav
      real (kind(1.0d0)) :: maxexp
      type(multi), save :: mz01(2)

      call fmequ(ma(1), mxy(4), ndsave, ndig)
      call fmequ(ma(2), mxy(5), ndsave, ndig)
      call fmequ(mb(1), mxy(6), ndsave, ndig)
      call fmequ(mb(2), mxy(7), ndsave, ndig)
      ntrsav = ntrace
      ntrace = 0

!             Check for special cases.

      nmethd = 1

!             If precision is low, use a slower but more stable form of the multiplication formula.

      if (ndig >= 35) nmethd = 2

      kl = 1
      do while (kl == 1)
         kl = 0
         if (abs(mxy(4)%mp(2)) >= mexpov .or. abs(mxy(5)%mp(2)) >= mexpov .or.  &
             abs(mxy(6)%mp(2)) >= mexpov .or. abs(mxy(7)%mp(2)) >= mexpov ) then
             call zmi2m(0, mz01)
             call zmmpy_unov(mxy(4), mxy(5), mxy(6), mxy(7), mresult)
             ntrace = ntrsav
             return
         else if (nmethd == 1) then

!             Method 1 for  ( a + b i ) * ( c + d i )

!             result = a*c - b*d + ( a*d + b*c ) i

             call fmmpyd(mxy(4), mxy(6), mxy(7), mz01(1), mz01(2))
             call fmmpyd(mxy(5), mxy(7), mxy(6), mxy(1), mxy(2))
             maxexp = max(mz01(1)%mp(2), mxy(1)%mp(2))
             call fmsub_r1(mz01(1), mxy(1))
             if (mz01(1)%mp(2) < maxexp) exit
             maxexp = max(mz01(2)%mp(2), mxy(2)%mp(2))
             call fmadd_r1(mz01(2), mxy(2))
             if (mz01(2)%mp(2) < maxexp) exit
             kl = 2
             exit
         else

!             Method 2 for  ( a + b i ) * ( c + d i )

!             p = ( a + b )*( c + d )
!             result = a*c - b*d + ( p - a*c - b*d ) i

             call fmadd(mxy(4), mxy(5), mxy(1))
             call fmadd(mxy(6), mxy(7), mxy(2))
             call fmmpy_r1(mxy(1), mxy(2))

             call fmmpy(mxy(4), mxy(6), mxy(2))
             call fmmpy(mxy(5), mxy(7), mxy(3))

             maxexp = max(mxy(2)%mp(2), mxy(3)%mp(2))
             call fmsub(mxy(2), mxy(3), mz01(1))
             if (mz01(1)%mp(2) < maxexp) exit
             maxexp = max(mxy(1)%mp(2), mxy(2)%mp(2))
             maxexp = max(maxexp, mxy(3)%mp(2))
             call fmsub(mxy(1), mxy(2), mz01(2))
             call fmsub_r1(mz01(2), mxy(3))
             if (mz01(2)%mp(2) < maxexp) exit
             kl = 2
             exit
         endif
      enddo

      if (kl == 0) then
          nds = ndig
          ndig = 2*ndig
          call fmequ(ma(1), mxy(4), ndsave, ndig)
          call fmequ(ma(2), mxy(5), ndsave, ndig)
          call fmequ(mb(1), mxy(6), ndsave, ndig)
          call fmequ(mb(2), mxy(7), ndsave, ndig)
          call fmmpyd(mxy(4), mxy(6), mxy(7), mz01(1), mz01(2))
          call fmmpyd(mxy(5), mxy(7), mxy(6), mxy(1), mxy(2))
          call fmsub_r1(mz01(1), mxy(1))
          call fmadd_r1(mz01(2), mxy(2))
          ndig = nds
      endif

      call zmeq(mz01, mresult)
      ntrace = ntrsav

      return
      end subroutine zmmpy_m1

      subroutine zmmpy_r1(ma, mb)

!  ma = ma * mb

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (inout) :: ma
      intent (in) :: mb

      type(multi), save :: mxy(2)

      call zmmpy(ma, mb, mxy)
      call zmeq(mxy, ma)

      end subroutine zmmpy_r1

      subroutine zmmpy_r2(ma, mb)

!  mb = ma * mb

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      type(multi), save :: mxy(2)

      call zmmpy(ma, mb, mxy)
      call zmeq(mxy, mb)

      end subroutine zmmpy_r2

      subroutine zmmpy_sc(ma, mb, ndsave, mresult, kresult)

!  Check for special cases for  mc = ma * mb

!  kresult = 1 is returned if a special case gives the value of the result.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2), mblocal(2)

      kresult = 0

      namest(ncall) = 'ZMMPY    '
      j = ndig
      ndig = ndsave
      call zmntr_inp2(ma, mb)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)
      call zmequ(mb, mblocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0) .or.  &
          (mblocal(1)%mp(2) == munkno .and. mblocal(1)%mp(5) >= 0) .or.  &
          (mblocal(2)%mp(2) == munkno .and. mblocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      if ((malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) .or.  &
          (mblocal(1)%mp(3) == 0 .and. mblocal(2)%mp(3) == 0)) then
          call zmi2m(0, mresult)
          kresult = 1
          return
      endif

      return
      end subroutine zmmpy_sc

      subroutine zmmpy_unov(ma, mb, mc, md, mz)

!  Check special cases where at least one of ma, mb, mc, md is underflow or overflow.

!  Return mz as the result.

      use fmvals
      implicit none

      type(multi) :: ma, mb, mc, md, mz(2)
      intent (inout) :: mz
      intent (in) :: ma, mb, mc, md

      type(multi), save :: mxy(8)
      double precision :: a_xe, a_xf, b_xe, b_xf, c_xe, c_xf, d, d_xe, d_xf, t1, t2, t3, t4


      call fmmpy(ma, mc, mxy(1))
      call fmmpy(mb, md, mxy(2))
      call fmmpy(ma, md, mxy(3))
      call fmmpy(mb, mc, mxy(4))
      call fmsub(mxy(1), mxy(2), mz(1))
      call fmadd(mxy(3), mxy(4), mz(2))
      if (mz(1)%mp(2) /= munkno .and. mz(2)%mp(2) /= munkno) return
      if (.not. ( (mz(1)%mp(2) == munkno .and. mz(1)%mp(5) >= 0) .or.  &
                  (mz(2)%mp(2) == munkno .and. mz(2)%mp(5) >= 0) )) return

      call fmsqr(ma, mxy(8))
      call fmsqr(mb, mxy(5))
      call fmadd(mxy(8), mxy(5), mxy(7))
      call fmsqr(mc, mxy(8))
      call fmsqr(md, mxy(5))
      call fmadd(mxy(8), mxy(5), mxy(6))
      call fmmpy(mxy(7), mxy(6), mxy(5))
      call fmovun_xexf(ma, a_xe, a_xf)
      call fmovun_xexf(mb, b_xe, b_xf)
      call fmovun_xexf(mc, c_xe, c_xf)
      call fmovun_xexf(md, d_xe, d_xf)
      if (huge(mbase)/mexpov > 1.0d+20) then
          d = 1.0d+10
      else
          d = 4
      endif
      t1 = max(a_xe, b_xe) + max(c_xe, d_xe)
      if (t1 >= (huge(mbase)/d)/2 .or. t1 <= -(huge(mbase)/d)/2) then
          mxy(5)%mp(4) = t1
          call fmeq(mxy(5), mxy(8))
      else
          call fmsqrt(mxy(5), mxy(8))
      endif
      if (mxy(8)%mp(2) /= munkno .and. abs(mxy(8)%mp(2)) == mexpov) then
          call fmovun_xexf(ma, a_xe, a_xf)
          call fmovun_xexf(mb, b_xe, b_xf)
          call fmovun_xexf(mc, c_xe, c_xf)
          call fmovun_xexf(md, d_xe, d_xf)
          t3 = dlogmb*(a_xe - b_xe)/2 + log(a_xf)
          t4 = dlogmb*(b_xe - a_xe)/2 + log(b_xf)
          if (log(tiny(t3)) <= t3 .and. t3 <= log(huge(t3))) then
              t3 = ma%mp(1) * dble(mbase)**( (a_xe - b_xe)/2 ) * a_xf
              t4 = mb%mp(1) * dble(mbase)**( (b_xe - a_xe)/2 ) * b_xf
              t1 = atan2(t4, t3)
          else
              if (ma%mp(1) > 0 .and. a_xe > b_xe) then
                  t1 = 0
              else if (mb%mp(1) > 0 .and. b_xe > a_xe) then
                  t1 = asin(1.0d0)
              else if (mb%mp(1) < 0 .and. b_xe > a_xe) then
                  t1 = asin(-1.0d0)
              else if (ma%mp(1) < 0 .and. mb%mp(1) > 0 .and. a_xe > b_xe) then
                  t1 = acos(-1.0d0)
              else
                  t1 = -acos(-1.0)
              endif
          endif

          t3 = dlogmb*(c_xe - d_xe)/2 + log(c_xf)
          t4 = dlogmb*(d_xe - c_xe)/2 + log(d_xf)
          if (log(tiny(t3)) <= t3 .and. t3 <= log(huge(t3))) then
              t3 = mc%mp(1) * dble(mbase)**( (c_xe - d_xe)/2 ) * c_xf
              t4 = md%mp(1) * dble(mbase)**( (d_xe - c_xe)/2 ) * d_xf
              t2 = atan2(t4, t3)
          else
              if (mc%mp(1) > 0 .and. c_xe > d_xe) then
                  t2 = 0
              else if (md%mp(1) > 0 .and. d_xe > c_xe) then
                  t2 = asin(1.0d0)
              else if (md%mp(1) < 0 .and. d_xe > c_xe) then
                  t2 = asin(-1.0d0)
              else if (mc%mp(1) < 0 .and. md%mp(1) > 0 .and. c_xe > d_xe) then
                  t2 = acos(-1.0d0)
              else
                  t2 = -acos(-1.0)
              endif
          endif

          call fmdp2m(cos(t1+t2), mxy(6))
          call fmmpy(mxy(6), mxy(8), mz(1))
          call fmdp2m(sin(t1+t2), mxy(6))
          call fmmpy(mxy(6), mxy(8), mz(2))
          if (mz(1)%mp(2) /= munkno .and. mz(2)%mp(2) /= munkno) return
      else if (abs(mxy(8)%mp(2)) < mexpov) then
          call fmovun_xexf(ma, a_xe, a_xf)
          call fmovun_xexf(mb, b_xe, b_xf)
          call fmovun_xexf(mc, c_xe, c_xf)
          call fmovun_xexf(md, d_xe, d_xf)
          call fmsub(mxy(1), mxy(2), mz(1))
          call fmadd(mxy(3), mxy(4), mz(2))
          if (a_xe+c_xe > b_xe+d_xe + ndig) call fmeq(mxy(1), mz(1))
          if (b_xe+d_xe > a_xe+c_xe + ndig) call fmmpyi(mxy(2), -1, mz(1))
          if (a_xe+d_xe > b_xe+c_xe + ndig) call fmeq(mxy(3), mz(2))
          if (b_xe+c_xe > a_xe+d_xe + ndig) call fmeq(mxy(4), mz(2))
          if (mz(1)%mp(2) /= munkno .and. mz(2)%mp(2) /= munkno) return
      endif
      call zmunknown(mz)

      return
      end subroutine zmmpy_unov

      subroutine zmmpyi(ma, integ, mb)

!  mb = ma * integ        Multiply by one-word (real) integer.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      integer :: integ
      intent (in) :: ma, integ
      intent (inout) :: mb

      integer :: kovun, kwrnsv, ntrsav

      ncall = ncall + 1
      if (ntrace /= 0) then
          namest(ncall) = 'ZMMPYI'
          call zmntr_inp1i(ma, integ)
      endif
      kovun = 0
      if (ma(1)%mp(2) == mexpov .or. ma(1)%mp(2) == mexpun) kovun = 1
      if (ma(2)%mp(2) == mexpov .or. ma(2)%mp(2) == mexpun) kovun = 1
      if (ma(1)%mp(2) == munkno .or. ma(2)%mp(2) == munkno) kovun = 2

!             Force fmmpyi to use more guard digits for user calls.

      ncall = ncall - 1
      ntrsav = ntrace
      ntrace = 0
      kwrnsv = kwarn
      kwarn = 0

      call fmmpyi(ma(1), integ, mb(1))
      call fmmpyi(ma(2), integ, mb(2))

      ntrace = ntrsav
      kwarn = kwrnsv
      ncall = ncall + 1
      if (ntrace /= 0) namest(ncall) = 'ZMMPYI'
      if (mb(1)%mp(2) == munkno .or. mb(2)%mp(2) == munkno) then
          kflag = -4
      else if (mb(1)%mp(2) == mexpov .or. mb(2)%mp(2) == mexpov) then
          kflag = -5
      else if (mb(1)%mp(2) == mexpun .or. mb(2)%mp(2) == mexpun) then
          kflag = -6
      endif
      if ((mb(1)%mp(2) == munkno .and. kovun /= 2) .or.  &
          (mb(2)%mp(2) == munkno .and. kovun /= 2) .or.  &
          (mb(1)%mp(2) == mexpun .and. kovun == 0) .or.  &
          (mb(2)%mp(2) == mexpun .and. kovun == 0) .or.  &
          (mb(1)%mp(2) == mexpov .and. kovun == 0) .or.  &
          (mb(2)%mp(2) == mexpov .and. kovun == 0)) then
          namest(ncall) = 'ZMMPYI'
          call fmwarn
      endif
      if (ntrace /= 0) call zmntr_out1(mb)
      ncall = ncall - 1

      return
      end subroutine zmmpyi

      subroutine zmmpyi_r1(ma, ival)

!  ma = ma / ival

      use fmvals
      implicit none

      type(multi) :: ma(2)
      integer :: ival
      intent (inout) :: ma
      intent (in) :: ival

      type(multi), save :: mt(2)


      call zmmpyi(ma, ival, mt)
      call zmeq(mt, ma)


      end subroutine zmmpyi_r1

      subroutine zmnegate(ma)

!  Change the sign of ma.

      use fmvals
      implicit none

      type(multi) :: ma(2)
      intent (inout) :: ma

      ma(1)%mp(1) = -ma(1)%mp(1)
      if (ma(1)%mp(3) == 0) ma(1)%mp(1) = 1
      if (ma(1)%mp(2) == munkno .and. ma(1)%mp(5) >= 0) ma(1)%mp(1) = 1
      ma(2)%mp(1) = -ma(2)%mp(1)
      if (ma(2)%mp(3) == 0) ma(2)%mp(1) = 1
      if (ma(2)%mp(2) == munkno .and. ma(2)%mp(5) >= 0) ma(2)%mp(1) = 1

      end subroutine zmnegate

      subroutine zmnint(ma, mb)

!  mb = nint(ma)

!  The nearest integers to both real and imaginary parts are returned.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      ncall = ncall + 1
      namest(ncall) = 'ZMNINT'
      if (ntrace /= 0) call zmntr_inp1(ma)

      call fmnint(ma(1), mb(1))
      call fmnint(ma(2), mb(2))

      if (ntrace /= 0) call zmntr_out1(mb)
      ncall = ncall - 1

      return
      end subroutine zmnint

      subroutine zmntr_inp1(ma)

!  Print ZM numbers in base 10 format using zmout for conversion.
!  This is used for trace output from the ZM routines.

!  ma  -  the ZM number to be printed.

!  ntrace and lvltrc (in module fmvals) control trace printout.

!  ntrace = 0        No printout except warnings and errors.

!  ntrace = 1        The result of each call to one of the routines
!                    is printed in base 10, using zmout.

!  ntrace = -1       The result of each call to one of the routines
!                    is printed in internal base mbase format.

!  ntrace = 2        The input arguments and result of each call to one
!                    of the routines is printed in base 10, using zmout.

!  ntrace = -2       The input arguments and result of each call to one
!                    of the routines is printed in base mbase format.

!  lvltrc defines the call level to which the trace is done.  lvltrc = 1 means only FM routines
!         called directly by the user are traced, lvltrc = k prints traces for ZM or FM routines
!         with call levels up to and including level k.

      use fmvals
      implicit none

      type(multi) :: ma(2)
      intent (in) :: ma

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return
      if (abs(ntrace) == 1) return

      name = namest(ncall)
      if (kround == 1) then
          write (kw, "(' Input to ', A)") trim(name)
      else if (kround == 2) then
          write (kw, "(' Input to ', A, A)") name, '      (round toward +infinity)'
      else if (kround == 0) then
          write (kw, "(' Input to ', A, A)") name, '      (round toward zero)'
      else if (kround == -1) then
          write (kw, "(' Input to ', A, A)") name, '      (round toward -infinity)'
      else
          write (kw, "(' Input to ', A)") trim(name)
      endif

!             Check for base mbase internal format trace.

      if (ntrace < 0) then
          call zmntrj(ma, ndig)
      else
          call zmprnt(ma)
      endif

      return
      end subroutine zmntr_inp1

      subroutine zmntr_inp1i(ma, ival)

!  This is used for trace output from the ZM routines.

      use fmvals
      implicit none

      type(multi) :: ma(2)
      integer :: ival
      intent (in) :: ma, ival

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return
      if (abs(ntrace) == 1) return

      name = namest(ncall)
      if (kround == 1) then
          write (kw, "(' Input to ', A)") trim(name)
      else if (kround == 2) then
          write (kw, "(' Input to ', A, A)") name, '      (round toward +infinity)'
      else if (kround == 0) then
          write (kw, "(' Input to ', A, A)") name, '      (round toward zero)'
      else if (kround == -1) then
          write (kw, "(' Input to ', A, A)") name, '      (round toward -infinity)'
      else
          write (kw, "(' Input to ', A)") trim(name)
      endif

!             Check for base mbase internal format trace.

      if (ntrace < 0) then
          call zmntrj(ma, ndig)
      else
          call zmprnt(ma)
      endif
      write (kw, "(1x, i20)") ival

      return
      end subroutine zmntr_inp1i

      subroutine zmntr_inp1ii(ma, ival, jval)

!  This is used for trace output from the ZM routines.

      use fmvals
      implicit none

      type(multi) :: ma(2)
      integer :: ival, jval
      intent (in) :: ma, ival, jval

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return
      if (abs(ntrace) == 1) return

      name = namest(ncall)
      if (kround == 1) then
          write (kw, "(' Input to ', A)") trim(name)
      else if (kround == 2) then
          write (kw, "(' Input to ', A, A)") name, '      (round toward +infinity)'
      else if (kround == 0) then
          write (kw, "(' Input to ', A, A)") name, '      (round toward zero)'
      else if (kround == -1) then
          write (kw, "(' Input to ', A, A)") name, '      (round toward -infinity)'
      else
          write (kw, "(' Input to ', A)") trim(name)
      endif

!             Check for base mbase internal format trace.

      if (ntrace < 0) then
          call zmntrj(ma, ndig)
      else
          call zmprnt(ma)
      endif
      write (kw, "(1x, i20)") ival
      write (kw, "(1x, i20)") jval

      return
      end subroutine zmntr_inp1ii

      subroutine zmntr_inp2(ma, mb)

!  Print ZM numbers in base 10 format using zmout for conversion.
!  This is used for trace output from the ZM routines.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma, mb

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return
      if (abs(ntrace) == 1) return

      name = namest(ncall)
      if (kround == 1) then
          write (kw, "(' Input to ', A)") trim(name)
      else if (kround == 2) then
          write (kw, "(' Input to ', A, A)") name, '      (round toward +infinity)'
      else if (kround == 0) then
          write (kw, "(' Input to ', A, A)") name, '      (round toward zero)'
      else if (kround == -1) then
          write (kw, "(' Input to ', A, A)") name, '      (round toward -infinity)'
      else
          write (kw, "(' Input to ', A)") trim(name)
      endif

!             Check for base mbase internal format trace.

      if (ntrace < 0) then
          call zmntrj(ma, ndig)
          call zmntrj(mb, ndig)
      else
          call zmprnt(ma)
          call zmprnt(mb)
      endif

      return
      end subroutine zmntr_inp2

      subroutine zmntr_inpi1(ival, ma)

!  This is used for trace output from the ZM routines.

      use fmvals
      implicit none

      type(multi) :: ma(2)
      integer :: ival
      intent (in) :: ma, ival

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return
      if (abs(ntrace) == 1) return

      name = namest(ncall)
      if (kround == 1) then
          write (kw, "(' Input to ', A)") trim(name)
      else if (kround == 2) then
          write (kw, "(' Input to ', A, A)") name, '      (round toward +infinity)'
      else if (kround == 0) then
          write (kw, "(' Input to ', A, A)") name, '      (round toward zero)'
      else if (kround == -1) then
          write (kw, "(' Input to ', A, A)") name, '      (round toward -infinity)'
      else
          write (kw, "(' Input to ', A)") trim(name)
      endif

!             Check for base mbase internal format trace.

      write (kw, "(1x, i20)") ival
      if (ntrace < 0) then
          call zmntrj(ma, ndig)
      else
          call zmprnt(ma)
      endif

      return
      end subroutine zmntr_inpi1

      subroutine zmntr_out1(ma)

!  Print ZM numbers in base 10 format using zmout for conversion.
!  This is used for trace output from the ZM routines.

!  ma  -  the ZM number to be printed.

!  ntrace and lvltrc (in module fmvals) control trace printout.

!  ntrace = 0        No printout except warnings and errors.

!  ntrace = 1        The result of each call to one of the routines
!                    is printed in base 10, using zmout.

!  ntrace = -1       The result of each call to one of the routines
!                    is printed in internal base mbase format.

!  ntrace = 2        The input arguments and result of each call to one
!                    of the routines is printed in base 10, using zmout.

!  ntrace = -2       The input arguments and result of each call to one
!                    of the routines is printed in base mbase format.

!  lvltrc defines the call level to which the trace is done.  lvltrc = 1 means only FM routines
!         called directly by the user are traced, lvltrc = k prints traces for ZM or FM routines
!         with call levels up to and including level k.

      use fmvals
      implicit none

      type(multi) :: ma(2)
      intent (in) :: ma

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return

      name = namest(ncall)
      if (kflag == 0) then
          write (kw,                                                      &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10, 5X, 'NDIG =', I10)"                                &
                ) name, ncall, int(mbase), ndig
      else
          write (kw,                                                     &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"            &
                ) name, ncall, int(mbase), ndig, kflag
      endif

!             Check for base mbase internal format trace.

      if (ntrace < 0) then
          call zmntrj(ma, ndig)
      else
          call zmprnt(ma)
      endif

      return
      end subroutine zmntr_out1

      subroutine zmntr_out2(ma, mb)

!  Print ZM numbers in base 10 format using zmout for conversion.
!  This is used for trace output from the ZM routines.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma, mb

      character(9) :: name

      if (ntrace == 0) return
      if (ncall > lvltrc) return

      name = namest(ncall)
      if (kflag == 0) then
          write (kw,                                                      &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10, 5X, 'NDIG =', I10)"                                &
                ) name, ncall, int(mbase), ndig
      else
          write (kw,                                                     &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"            &
                ) name, ncall, int(mbase), ndig, kflag
      endif

!             Check for base mbase internal format trace.

      if (ntrace < 0) then
          call zmntrj(ma, ndig)
          call zmntrj(mb, ndig)
      else
          call zmprnt(ma)
          call zmprnt(mb)
      endif

      return
      end subroutine zmntr_out2

      subroutine zmntr_outz(z)

!  Internal routine for trace output of complex variables.

      use fmvals
      implicit none

      complex :: z
      intent (in) :: z

      character(9) :: name
      double precision :: xreal, ximag

      if (ntrace == 0) return
      if (ncall > lvltrc) return

      name = namest(ncall)
      if (kflag == 0) then
          write (kw,                                                      &
                 "(' ', A, 12X, 'Call level =', I2, 5X, 'MBASE =', "  //  &
                 "I10, 5X, 'NDIG =', I10)"                                &
                ) name, ncall, int(mbase), ndig
      else
          write (kw,                                                     &
                 "(' ', A, 3X, 'Call level =', I2, 4X, 'MBASE =', "  //  &
                 "I10, 4X, 'NDIG =', I10, 4X, 'KFLAG =', I3)"            &
                ) name, ncall, int(mbase), ndig, kflag
      endif

      xreal = dble(z)
      ximag = dble(aimag(z))
      if (ximag >= 0.0d0) then
          write (kw, "(1x, es20.10, ' +', es20.10, ' i')") xreal, ximag
      else
          write (kw, "(1x, es20.10, ' -', es20.10, ' i')") xreal, abs(ximag)
      endif

      return
      end subroutine zmntr_outz

      subroutine zmntrj(ma, nd)

!  Print trace output in internal base mbase format.  The number to be printed is in ma.

!  nd is the number of base mbase digits to be printed.

      use fmvals
      implicit none

      type(multi) :: ma(2)
      integer :: nd
      intent (in) :: ma, nd

      character(99) :: form
      character(40) :: st1, st2
      integer :: j, l, n
      character(40), external :: fmfi

      l = int(log10(dble(mbase-1))) + 2
      n = (kswide-23)/l
      if (n > 10) n = 5*(n/5)
      if (nd <= n) then
          write (form, "(' (1X, I19, I', I2, ', ', I3, 'I', I2, ') ')") l+2, n-1, l
      else
          write (form,                                           &
                 "(' (1X, I19, I', I2, ', ', I3, 'I', I2, "  //  &
                 "'/(22X, ', I3, 'I', I2, ')) ')"                &
                ) l+2, n-1, l, n, l
      endif
      st1 = fmfi(int(ma(1)%mp(1)))
      st2 = fmfi(int(ma(1)%mp(2)))
      write (kw, "(A, A, A, A, A)") '            Sign = ', trim(st1),  &
                                   '   Exponent = ', trim(st2), '   Digits of real part:'
      write (form,*) '(13X, ', n, 'I', l, ')'
      if (ma(1)%mp(5) < 0) then
          if (nd+2 >= 6) then
              write (kw, form) int(ma(1)%mp(3)), 0, 0,(int(ma(1)%mp(j)), j=6, nd+2)
          else if (nd+2 == 5) then
              write (kw, form) int(ma(1)%mp(3)), 0, 0
          else
              write (kw, form) int(ma(1)%mp(3)), 0
          endif
      else
          write (kw, form) (int(ma(1)%mp(j)), j=3, nd+2)
      endif

      st1 = fmfi(int(ma(2)%mp(1)))
      st2 = fmfi(int(ma(2)%mp(2)))
      write (kw, "(A, A, A, A, A, A, A)") '            Sign = ', trim(st1),  &
                                   '   Exponent = ', trim(st2), '   Digits of imaginary part:'
      if (ma(2)%mp(5) < 0) then
          if (nd+2 >= 6) then
              write (kw, form) int(ma(2)%mp(3)), 0, 0,(int(ma(2)%mp(j)), j=6, nd+2)
          else if (nd+2 == 5) then
              write (kw, form) int(ma(2)%mp(3)), 0, 0
          else
              write (kw, form) int(ma(2)%mp(3)), 0
          endif
      else
          write (kw, form) (int(ma(2)%mp(j)), j=3, nd+2)
      endif

      return
      end subroutine zmntrj

      subroutine zmout(ma, line, lb, last1, last2)

!  Convert a floating multiple precision number to a character array for output.

!  ma    is an zm number to be converted to an a1 character array in base 10 format
!  line  is the character(1) array in which the result is returned.
!  lb    is the length of line.
!  last1 is returned as the position of the last nonblank character of the real part of the
!        number in line.
!  last2 is returned as the position of the last nonblank character of the imaginary part of
!        the number in line.

!  jform1 and jform2 determine the format of the two fm numbers making up the complex value ma.
!  See fmout for details.

!  jformz determines the format of the real and imaginary parts.

!  jformz = 1  normal setting :       1.23 - 4.56 i
!         = 2  use capital I  :       1.23 - 4.56 I
!         = 3  parenthesis format   ( 1.23 , -4.56 )

!  line should be dimensioned at least 4*(log10(mbase)*ndig + 15) on a 32-bit machine to allow
!  for up to 10 digit exponents.  Replace 15 by 20 if 48-bit integers are used, 25 for 64-bit
!  integers, etc.

      use fmvals
      implicit none

      type(multi) :: ma(2)
      integer :: lb, last1, last2
      character :: line(lb)
      intent (in) :: ma, lb
      intent (inout) :: line, last1, last2

      real (kind(1.0d0)) :: maims
      integer :: j, kpt, lb2, nd, nexp
      type(multi), save :: mxy(1)


      ncall = ncall + 1
      namest(ncall) = 'ZMOUT'
      do j = 1, lb
         line(j) = ' '
      enddo
      nd = int(real(ndig)*log10(real(mbase))) + 1
      if (nd < 2) nd = 2
      nexp = int(2.0*log10(real(mxbase))) + 16
      kpt = 1
      if (jformz == 3) kpt = 3
      lb2 = max(jform2+nexp, nd+nexp)
      lb2 = min(lb+1-kpt, lb2)
      call fmout(ma(1), line(kpt), lb2)

      if (jformz == 3) line(1) = '('
      last1 = 1
      do j = lb2, 1, -1
         if (line(j) /= ' ') then
             last1 = j
             exit
         endif
      enddo

      maims = ma(2)%mp(1)
      if (ma(2)%mp(2) == munkno) maims = 1
      call fmi2m2(0, mxy(1))
      do j = 1, ndig+2
         mxy(1)%mp(j) = ma(2)%mp(j)
      enddo
      line(last1+1) = ' '
      if (jformz == 3) then
          line(last1+2) = ','
      else
          if (maims < 0) then
              mxy(1)%mp(1) = 1
              line(last1+2) = '-'
          else
              line(last1+2) = '+'
          endif
      endif

      kpt = last1 + 3
      lb2 = max(jform2+nexp, nd+nexp)
      lb2 = min(lb+1-kpt, lb2+2)
      call fmout(mxy(1), line(kpt), lb2)
      last1 = kpt
      do j = lb2+kpt-1, kpt, -1
         if (line(j) /= ' ') then
             last2 = j
             exit
         endif
      enddo

      last2 = last2 + 2
      line(last2) = 'i'
      if (jformz == 2) line(last2) = 'I'
      if (jformz == 3) line(last2) = ')'

      if (line(kpt) == ' ' .and. line(kpt+1) == '+') then
          do j = kpt+2, last2
             line(j-2) = line(j)
          enddo
          line(last2-1) = ' '
          line(last2) = ' '
          last2 = last2 - 2
      endif

      ncall = ncall - 1

      return
      end subroutine zmout

      subroutine zmpack(ma, mp)

!  ma is packed two base mbase digits per word and returned in mp.

      use fmvals
      implicit none

      type(multi) :: ma(2), mp(2)
      intent (in) :: ma
      intent (inout) :: mp

      call fmpack(ma(1), mp(1))
      call fmpack(ma(2), mp(2))

      return
      end subroutine zmpack

      subroutine zmpgam(n, ma, mb)

!  mb = polygamma(n,ma)      (nth derivative of psi)

      use fmvals
      implicit none

      integer :: n
      type(multi) :: ma(2), mb(2)
      intent (in) :: n, ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, numtry, n_acc
      logical :: retry
      type(multi), save :: mxy(2, 13), mresult(2), mretry(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmpgam_sc(n, ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons
      numtry = 0
      n_acc = nint(ndig*alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call zmpgam_m1(n, ma, mxy, mresult, ndsave, retry, numtry, n_acc)
         if (retry) then
             retry = .false.
             call zmcheck_accuracy(mresult, ndsave, retry)
             if (.not. retry) then
                 call zmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)
             endif
         endif
         numtry = numtry + 1
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmpgam

      subroutine zmpgam_m1(n, ma, mxy, mresult, ndsave, retry, numtry, n_acc)

!  Method 1 for computing polygamma(n,ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(2, 13), mresult(2)
      integer :: n, ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: n, ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc

      double precision :: xe
      integer :: iextra, inta, j, j2, jn, jnc, jstart, k, k1, k2, kl,       &
                 krflct, krsave, kwrnsv, lshift, n1, nbot, nc, nd1, ndig2,  &
                 ndsav1, ndsv2, nmxdif, nterm, ntop

!             Set the coefficients used in computing various derivatives of cot(pi*x)
!             for the reflection formula.

      integer :: kgcd(14) = (/ 1, 2, 2, 8, 8, 16, 16, 128, 128, 256, 256, 1024, 1024, 2048 /)
      integer :: kcoeff(56) = (/                                                            &
                           1,        1,                     3, 1,               3, 2,       &
                          15,  15,   2,                    45,  60, 17,                     &
                         315, 525, 231, 17,               315, 630, 378, 62,                &
                        2835,      6615,      5040,      1320,       62,                    &
                       14175,     37800,     34965,     12720,     1382,                    &
                      155925,    467775,    509355,    238425,    42306,     1382,          &
                      467775,   1559250,   1954260,   1121670,   280731,    21844,          &
                     6081075,  22297275,  31621590,  21531510,  7012005,   907725,  21844,  &
                    42567525, 170270100, 269594325, 212612400, 85630545, 15839460, 929569 /)
      type(multi), save :: mjsums(2, ljsums)
      logical, external :: fmcomp

      retry = .true.

      if (numtry >= 1) then
          if (ncall == 1) ndig = max(ndig, 2*ndsave+10)
      endif
      ndig = ndig + n/4
      n_acc = nint(ndig*alogm2)
      call zmequ(ma, mxy(1:2, 1), ndsave, ndig)
      lshift = 0
      call zmeq(mxy(1:2, 1), mxy(1:2, 13))

!             Check for special cases.

      if (n == 0) then
          call zmpsi(mxy(1:2, 1), mresult)
          return
      endif

!             Near zero polygamma(n,x) =
!                       for odd n:       n!/x**(n+1) + c(n)*pi**(n+1) + polygamma(n+1,1.0)*x + ...
!                       for even n:     -n!/x**(n+1) + polygamma(n,1.0) + c(n+1)*pi**(n+2)*x + ...

!                       c(n) = abs(Bernoulli(n+1)) * 4**((n-1)/2) / ((n+1)/2)

      call zmabs(mxy(1:2, 1), mxy(1, 2))
      call fmovun_xe(mxy(1, 2), xe)
      if (xe < (-ndig-1)) then
          call fmfcti(n, mxy(1, 12))
          call fmi2m(0, mxy(2, 12))
          call zmipwr(mxy(1:2, 13), n+1, mxy(1:2, 11))
          call zmdiv(mxy(1:2, 12), mxy(1:2, 11), mxy(1:2, 10))
          if (mod(n, 2) == 1) then
              call fmpi(mxy(1, 2))
              call fmipwr(mxy(1, 2), n+1, mxy(1, 3))

              call fmbernoulli(n+1, mxy(2, 4))
              call fmabs(mxy(2, 4), mxy(1, 4))
              call fmi2m(4, mxy(1, 5))
              call fmipwr(mxy(1, 5), (n-1)/2, mxy(1, 6))
              call fmmpy(mxy(1, 4), mxy(1, 6), mxy(1, 5))
              call fmdivi(mxy(1, 5), (n+1)/2, mxy(1, 6))
              call fmmpy(mxy(1, 6), mxy(1, 3), mxy(1, 9))
              call fmadd_r1(mxy(1, 10), mxy(1, 9))

              call fmi2m(1, mxy(1, 3))
              call fmpgam(n+1, mxy(1, 3), mxy(1, 4))
              call fmi2m(0, mxy(2, 4))
              call zmmpy(mxy(1:2, 4), mxy(1:2, 13), mxy(1:2, 9))
              call zmadd_r1(mxy(1:2, 10), mxy(1:2, 9))
          else
              call fmi2m(1, mxy(1, 3))
              call fmpgam(n, mxy(1, 3), mxy(1, 9))
              call fmadd_r1(mxy(1, 10), mxy(1, 9))

              call fmpi(mxy(1, 2))
              call fmipwr(mxy(1, 2), n+2, mxy(1, 3))

              call fmbernoulli(n+2, mxy(2, 4))
              call fmabs(mxy(2, 4), mxy(1, 4))
              call fmi2m(4, mxy(1, 5))
              call fmipwr(mxy(1, 5), n/2, mxy(1, 6))
              call fmmpy(mxy(1, 4), mxy(1, 6), mxy(1, 5))
              call fmdivi(mxy(1, 5), (n+2)/2, mxy(1, 6))
              call fmmpy(mxy(1, 6), mxy(1, 3), mxy(1, 9))
              call fmi2m(0, mxy(2, 9))
              call zmmpy_r1(mxy(1:2, 9), mxy(1:2, 13))
              call zmadd_r1(mxy(1:2, 10), mxy(1:2, 9))
          endif
          call zmeq(mxy(1:2, 10), mresult)
          return
      endif

      krflct = 0
      call fmdp2m(-0.5d0, mxy(1, 5))
      if (fmcomp(mxy(1, 13), '<=', mxy(1, 5))) then
          krflct = 1
          call zmi2m(1, mxy(1:2, 4))
          call zmsub_r2(mxy(1:2, 4), mxy(1:2, 13))
      endif

!             For large abs(ma), polygamma(n,x) = (-1)**(n-1)*( (n-1)!/x**n + n!/(2*x**(n+1)) + ...)

      call zmabs(mxy(1:2, 13), mxy(1, 2))
      call fmovun_xe(mxy(1, 2), xe)
      if (xe > ndig+3) then
          call zmipwr(mxy(1:2, 13), -n, mxy(1:2, 2))
          call fmfcti(n-1, mxy(1, 9))
          call fmi2m(0, mxy(2, 9))
          call zmmpy(mxy(1:2, 2), mxy(1:2, 9), mxy(1:2, 3))
          call zmdiv_r1(mxy(1:2, 2), mxy(1:2, 13))
          call zmmpyi_r1(mxy(1:2, 9), n)
          call zmmpy(mxy(1:2, 2), mxy(1:2, 9), mxy(1:2, 10))
          call zmdivi_r1(mxy(1:2, 10), 2)
          call zmadd_r1(mxy(1:2, 10), mxy(1:2, 3))

          if (mod(n-1, 2) == 1) then
              call zmnegate(mxy(1:2, 10))
          endif
          if (kround /= 1) then
              call zmmpyi(mxy(1:2, 10), n, mxy(1:2, 4))
              call zmdivi_r1(mxy(1:2, 4), 2)
              call zmdiv_r1(mxy(1:2, 4), mxy(1:2, 13))
              call zmadd_r1(mxy(1:2, 10), mxy(1:2, 4))
          endif
      else

!             To speed the asymptotic series calculation, increase the argument by lshift.

          iextra = 0
          kwrnsv = kwarn
          kwarn = 0
          call fmm2i(mxy(1, 13), inta)
          kwarn = kwrnsv

          if (kflag == -4) then
              lshift = 0
          else
              lshift = max(0, int(real(ndig)*alogmb/4.46-real(inta)))
              lshift = lshift + (7*n)/20
          endif
          if (lshift > 0) lshift = 4*(lshift/4 + 1)

          if (lshift /= 0) then
              call zmi2m(lshift, mxy(1:2, 4))
              call zmadd(mxy(1:2, 13), mxy(1:2, 4), mxy(1:2, 12))
          else
              call zmeq(mxy(1:2, 13), mxy(1:2, 12))
          endif

!             Sum the asymptotic series.

          j2 = int(0.3*alogmb + 0.2*sqrt(real(ndig)))
          j2 = max(1, min(ljsums, j2))

!             mxy(13) is z
!             mxy(12) is z + lshift
!             mxy(9) is x**j2 = (1/(z+lshift)**2)**j2
!             mxy(10) is the current power of x times the quotient of factorials in each term
!             mxy(11) is the current term in the sum
!             mxy(8) is (n+1)!
!             mjsums holds the partial sums

          ndsav1 = ndig
          call fmfcti(n+1, mxy(1, 8))
          call fmi2m(0, mxy(2, 8))
          call zmdivi(mxy(1:2, 8), 2, mxy(1:2, 10))
          j = -2*j2
          call zmipwr(mxy(1:2, 12), j, mxy(1:2, 9))
          call zmabs(mxy(1:2, 9), mxy(1, 2))
          if (abs(mxy(1, 2)%mp(2)) >= mexpab) then
              j2 = 1
              call zmipwr(mxy(1:2, 12), -2, mxy(1:2, 9))
          endif
          nterm = 2
          do j = 1, j2
             nterm = 2*j
             call fmbern(nterm, mxy(1, 10), mjsums(1, j))
             call fmbern(nterm, mxy(2, 10), mjsums(2, j))
             if (kflag == -11) then
                 call zmunknown(mresult)
                 kflag = -4
                 retry = .false.
                 return
             endif
             ntop = (n+nterm)*(n+nterm+1)
             call zmmpyi_r1(mxy(1:2, 10), ntop)
             nbot = (nterm+1)*(nterm+2)
             call zmdivi_r1(mxy(1:2, 10), nbot)
          enddo

          ndig2 = ndig
          kl = 1
          do while (kl == 1)
             call zmmpy_r1(mxy(1:2, 10), mxy(1:2, 9))
             nmxdif = min(ndsav1, ngrd22)
             do j = 1, j2
                nterm = nterm + 2
                call fmbern(nterm, mxy(1, 10), mxy(1, 11))
                call fmbern(nterm, mxy(2, 10), mxy(2, 11))
                if (kflag == -11) then
                    call zmunknown(mresult)
                    kflag = -4
                    retry = .false.
                    return
                endif
                ndig = ndsav1
                call zmadd_r1(mjsums(1:2, j), mxy(1:2, 11))
                if (kflag /= 0) then
                    kl = 0
                    exit
                else
                    call zmabs(mjsums(1:2, j), mxy(1, 2))
                    call zmabs(mxy(1:2, 11), mxy(2, 2))
                    nmxdif = max(nmxdif, ndsav1-int(mxy(1, 2)%mp(2)-mxy(2, 2)%mp(2)))
                    ndig = ndig2
                    if (n+nterm > intmax/(n+nterm+1) .or. n+nterm > mxbase/(n+nterm+1)) then
                        call zmmpyi_r1(mxy(1:2, 10), n+nterm)
                        call zmmpyi_r1(mxy(1:2, 10), n+nterm+1)
                        call zmdivi_r1(mxy(1:2, 10), nterm+1)
                        call zmdivi_r1(mxy(1:2, 10), nterm+2)
                    else
                        ntop = (n+nterm)*(n+nterm+1)
                        call zmmpyi_r1(mxy(1:2, 10), ntop)
                        nbot = (nterm+1)*(nterm+2)
                        call zmdivi_r1(mxy(1:2, 10), nbot)
                    endif
                endif
             enddo
             ndig2 = nmxdif
             ndig = ndig2
          enddo

!             Put the j2 concurrent sums back together.

          ndig = ndsav1
          if (j2 > 1) then
              call zmi2m(1, mxy(1:2, 9))
              call zmsqr(mxy(1:2, 12), mxy(1:2, 11))
              call zmdiv_r2(mxy(1:2, 9), mxy(1:2, 11))
              call zmeq(mjsums(1:2, j2), mxy(1:2, 9))
              do j = j2-1, 1, -1
                 call zmmpy_r1(mxy(1:2, 9), mxy(1:2, 11))
                 call zmadd_r1(mxy(1:2, 9), mjsums(1:2, j))
              enddo
              call zmeq(mxy(1:2, 9), mjsums(1:2, 1))
          endif
          call zmipwr(mxy(1:2, 12), n+2, mxy(1:2, 6))
          call zmdiv_r1(mjsums(1:2, 1), mxy(1:2, 6))

!             Add the initial terms to the asymptotic series.

          call zmdivi(mxy(1:2, 8), n+1, mxy(1:2, 9))
          call zmdivi(mxy(1:2, 9), n, mxy(1:2, 8))
          call zmmpyi(mxy(1:2, 12), 2, mxy(1:2, 7))
          call zmi2m(n, mxy(1:2, 10))
          call zmadd(mxy(1:2, 7), mxy(1:2, 10), mxy(1:2, 3))
          call fmcancel(mxy(1, 7), mxy(1, 10), mxy(1, 3), k1)
          call fmcancel(mxy(2, 7), mxy(2, 10), mxy(2, 3), k2)
          n_acc = n_acc - max(k1, k2)
          call zmeq(mxy(1:2, 3), mxy(1:2, 7))
          call zmmpy_r1(mxy(1:2, 7), mxy(1:2, 8))
          call zmmpyi_r1(mxy(1:2, 6), 2)
          call zmdiv_r1(mxy(1:2, 6), mxy(1:2, 12))
          call zmdiv(mxy(1:2, 7), mxy(1:2, 6), mxy(1:2, 10))
          call zmadd(mjsums(1:2, 1), mxy(1:2, 10), mxy(1:2, 3))
          call fmcancel(mjsums(1, 1), mxy(1, 10), mxy(1, 3), k1)
          call fmcancel(mjsums(2, 1), mxy(2, 10), mxy(2, 3), k2)
          n_acc = n_acc - max(k1, k2)
          call zmeq(mxy(1:2, 3), mxy(1:2, 10))
          if (mod(n-1, 2) == 1) then
              call zmnegate(mxy(1:2, 10))
          endif

!             Now pgam of the shifted argument has been computed.  Reverse the shifting.
!             The sum 1/(ma)**(n+1) + ... + 1/(ma+lshift-1)**(n+1) is computed.

!             mxy(13) is z
!             mxy(9) is n!
!             mxy(10) is the sum of the asymptotic series
!             mxy(11) is the sum 1/(ma)**(n+1) + ... + 1/(ma+lshift-1)**(n+1)
      endif

      if (lshift > 0) then

          call zmi2m(1, mxy(1:2, 6))
          call zmeq(mxy(1:2, 13), mxy(1:2, 7))
          n1 = -(n + 1)
          call zmipwr(mxy(1:2, 7), n1, mxy(1:2, 11))
          do k = 1, lshift-1
             call zmadd_r1(mxy(1:2, 7), mxy(1:2, 6))
             call zmipwr(mxy(1:2, 7), n1, mxy(1:2, 12))
             call zmadd_r1(mxy(1:2, 11), mxy(1:2, 12))
          enddo
          call zmmpy_r2(mxy(1:2, 9), mxy(1:2, 11))
          if (mod(n+1, 2) == 1) then
              call zmnegate(mxy(1:2, 11))
          endif
          call zmadd(mxy(1:2, 10), mxy(1:2, 11), mxy(1:2, 3))
          call fmcancel(mxy(1, 10), mxy(1, 11), mxy(1, 3), k1)
          call fmcancel(mxy(2, 10), mxy(2, 11), mxy(2, 3), k2)
          n_acc = n_acc - max(k1, k2)
          call zmeq(mxy(1:2, 3), mxy(1:2, 10))
      endif

!             Use the reflection formula if Real(ma) was less than -1/2.

      if (krflct == 1) then

!             mxy(11) is cot(Pi*z)
!             mxy(9) is mxy(11)**2

!             Reduce the argument before multiplying by Pi.

          call fmnint(mxy(1, 13), mxy(1, 5))
          call fmsub(mxy(1, 13), mxy(1, 5), mxy(1, 9))
          call fmeq(mxy(2, 13), mxy(2, 9))
          if (mxy(1, 9)%mp(3) /= 0) then
              call fmcancel(mxy(1, 13), mxy(1, 5), mxy(1, 9), k1)
              n_acc = n_acc - k1
          endif
          ndsv2 = ndig

          kl = 1
          do while (kl == 1)
             kl = 0
             call fmpi(mxy(1, 11))
             call fmi2m(0, mxy(2, 11))
             call zmmpy_r1(mxy(1:2, 11), mxy(1:2, 9))
             krsave = krad
             krad = 1
             call zmtan(mxy(1:2, 11), mxy(1:2, 2))
             call zmeq(mxy(1:2, 2), mxy(1:2, 11))
             krad = krsave

             call zmabs(mxy(1:2, 11), mxy(1, 5))
             call fmovun_xe(mxy(1, 5), xe)
             if ((xe < 0 .or. xe > 1) .and. ndsv2 == ndig) then
                 nd1 = max(-mxy(1, 5)%mp(2), mxy(1, 5)%mp(2))
                 iextra = int(min(2*ndig, nd1))
                 if (abs(mxy(1, 5)%mp(2)) >= mexpov) iextra = 0
                 if (iextra > 0) then
                     call zmequ_r1(mxy(1:2, 9), ndig, ndig+iextra)
                 endif
                 ndig = ndig + iextra
                 if (iextra > 0) then
                     kl = 1
                 endif
             endif
          enddo

          ndig = ndsv2
          call zmi2m(1, mxy(1:2, 5))
          call zmdiv_r2(mxy(1:2, 5), mxy(1:2, 11))
          call zmsqr(mxy(1:2, 11), mxy(1:2, 9))
          nc = (n+1)/2

!             For n up to 14, use the stored coefficients to compute the Nth derivative
!             of Cot(Pi*z).  For larger n, the coefficients are generated from a recurrence
!             relation and stored as FM numbers.

          if (n <= 14) then
              jstart = (n*n + 4 - mod(n, 2))/4
              if (n <= 2) then
                  call zmi2m(1, mxy(1:2, 6))
              else
                  call zmmpyi(mxy(1:2, 9), kcoeff(jstart), mxy(1:2, 6))
              endif
              do j = 2, nc
                 call zmi2m(kcoeff(jstart+j-1), mxy(1:2, 7))
                 call zmadd_r1(mxy(1:2, 6), mxy(1:2, 7))
                 if (j < nc) call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 9))
              enddo
              if (mod(n, 2) == 0) call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 11))
              if (n > 1) call zmmpyi_r1(mxy(1:2, 6), kgcd(n))
          else
              if (nc > ljsums) then
                  kflag = -12
                  write (kw,                                                           &
                         "(' For ZMPGAM(', I5, ',*) with NDIG =', I5, ', ', I7, "  //  &
                         "' words are needed'/' in array MJSUMS.', "               //  &
                         "'  The current dimension of MJSUMS IS', I7/)"                &
                        ) n, ndig, nc*(ndig+3), ljsums
                  call zmunknown(mresult)
                  return
              endif

              do j = 1, 7
                 call zmi2m(kcoeff(j+49), mjsums(1:2, j))
                 call zmmpyi_r1(mjsums(1:2, j), kgcd(14))
              enddo
              do jn = 15, n
                 jnc = (jn+1)/2
                 do k = jnc, 2, -1
                    if (k == jnc .and. mod(jn, 2) == 1) then
                        call zmeq(mjsums(1:2, k-1), mjsums(1:2, k))
                    else
                        call zmadd_r2(mjsums(1:2, k-1), mjsums(1:2, k))
                        call zmmpyi_r1(mjsums(1:2, k), jn-2*(k-1))
                    endif
                 enddo
                 call zmmpyi_r1(mjsums(1:2, 1), jn)
              enddo

!             mjsums now has the coefficients needed for the polynomial in Cot**2 that defines
!             the Nth derivative of Cot.

              call zmeq(mjsums(1:2, 1), mxy(1:2, 6))
              do j = 2, nc
                 call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 9))
                 call zmadd_r1(mxy(1:2, 6), mjsums(1:2, j))
              enddo
              if (mod(n, 2) == 0) call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 11))
          endif

!             To complete the calculation of the Nth derivative of Cot, multiply the polynomial
!             in Cot**2 by Csc**2.

          call zmadd(mxy(1:2, 9), mxy(1:2, 5), mxy(1:2, 7))
          call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 7))

          call fmpi(mxy(2, 7))
          call fmipwr(mxy(2, 7), n+1, mxy(1, 7))
          call fmi2m(0, mxy(2, 7))
          call zmmpy_r1(mxy(1:2, 6), mxy(1:2, 7))
          if (mod(n, 2) == 1) then
              call zmnegate(mxy(1:2, 10))
          endif
          call zmadd(mxy(1:2, 10), mxy(1:2, 6), mxy(1:2, 3))
          call fmcancel(mxy(1, 10), mxy(1, 6), mxy(1, 3), k1)
          call fmcancel(mxy(2, 10), mxy(2, 6), mxy(2, 3), k2)
          n_acc = n_acc - max(k1, k2)
          call zmeq(mxy(1:2, 3), mxy(1:2, 10))
      endif

      call zmeq(mxy(1:2, 10), mresult)

      return
      end subroutine zmpgam_m1

      subroutine zmpgam_sc(n, ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = polygamma(n,ma).

!  kresult = 1 is returned if a special case gives the value of polygamma(n,ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: n, kresult, ndsave
      intent (in) :: n, ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMPGAM   '
      j = ndig
      ndig = ndsave
      call zmntr_inpi1(n, ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

!             If ma is real, use fmpgam.

      if (ma(2)%mp(3) == 0) then
          call fmpgam(n, malocal(1), mresult(1))
          call fmi2m(0, mresult(2))
          kresult = 1
          return
      endif

      return
      end subroutine zmpgam_sc

      subroutine zmpower(ma, mb, mc)

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma, mb
      intent (inout) :: mc

      call zmpwr(ma, mb, mc)

      return
      end subroutine zmpower

      subroutine zmprint(ma)

      use fmvals
      implicit none

      type(multi) :: ma(2)
      intent (in) :: ma

      call zmprnt(ma)

      return
      end subroutine zmprint

      subroutine zmprnt(ma)

!  Print ma in base 10 format.

!  zmprnt can be called directly by the user for easy output in m format.
!  ma is converted using zmout and printed.

      use fmvals
      implicit none

      type(multi) :: ma(2)
      intent (in) :: ma

      character(20) :: form
      integer :: j, k, ksave, last1, last2, lb, lbz, nd, nexp

      ksave = kflag
      nd = int(real(ndig)*log10(real(mbase))) + 1
      if (nd < 2) nd = 2
      nexp = int(2.0*log10(real(mxbase))) + 16
      lb = max(jform2+nexp, nd+nexp)

      if (jprntz == 1) then
          lbz = 2*lb + 7
          if (lbz > lmbufz) then
              if (lmbufz > 0) deallocate(cmbufz)
              allocate(cmbufz(lbz), stat=j)
              if (j /= 0) then
                  call fmdefine_error
              endif
              lmbufz = lbz
          endif
          call zmout(ma, cmbufz, lbz, last1, last2)
          write (form, "(' (6X, ', I3, 'A1) ')") kswide-7
          write (kw, form) (cmbufz(k), k=1, last2)
      else
          call fmprnt(ma(1))
          call fmprnt(ma(2))
      endif
      kflag = ksave

      return
      end subroutine zmprnt

      subroutine zmpsi(ma, mb)

!  mb = psi(ma)      (derivative of ln(gamma(ma))

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, n_acc, numtry
      logical :: retry
      type(multi), save :: mxy(2, 12), mresult(2), mretry(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmpsi_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons
      numtry = 0
      n_acc = nint(ndig*alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call zmpsi_m1(ma, mxy, mresult, ndsave, retry, numtry, n_acc)
         if (retry) then
             retry = .false.
             call zmcheck_accuracy(mresult, ndsave, retry)
             if (.not. retry) then
                 call zmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)
             endif
         endif
         numtry = numtry + 1
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmpsi

      subroutine zmpsi_m1(ma, mxy, mresult, ndsave, retry, numtry, n_acc)

!  Method 1 for computing psi(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(2, 12), mresult(2)
      integer :: ndsave, numtry, n_acc
      logical :: retry
      intent (in) :: ma, ndsave, numtry
      intent (inout) :: mxy, mresult, retry, n_acc

      double precision :: xe
      integer :: inta, j, j2, k, k0, k0b, k1, k1b, k2, kl, krflct, krsave, kwrnsv,  &
                 lshift, nd1, ndenom, ndig2, ndsav1, nmxdif, nterm
      type(multi), save :: mjsums(2, ljsums)
      logical, external :: fmcomp
      retry = .true.
      if (numtry >= 1) then
          if (ncall == 1) ndig = max(ndig, 2*ndsave+10)
      endif
      n_acc = nint(ndig*alogm2)
      call zmequ(ma, mxy(1:2, 1), ndsave, ndig)
      call zmeq(mxy(1:2, 1), mxy(1:2, 11))

!             Near zero Psi(x) is about -1/x - EulerGamma.

      call zmabs(mxy(1:2, 1), mxy(1, 2))
      call fmovun_xe(mxy(1, 2), xe)
      if (xe < (-ndig-1)) then
          call zmi2m(-1, mxy(1:2, 3))
          call zmdiv(mxy(1:2, 3), mxy(1:2, 11), mxy(1:2, 8))
          call fmeuler(mxy(1, 3))
          call fmsub_r1(mxy(1, 8), mxy(1, 3))
          call zmeq(mxy(1:2, 8), mresult)
          return
      endif

      if (ma(1)%mp(2) == mexpun) then
          call fmi2m(0, mxy(1, 11))
      endif

      krflct = 0
      call fmdpm(dble(-0.5), mxy(1, 4))
      if (fmcomp(mxy(1, 1), '<=', mxy(1, 4))) then
          krflct = 1
          call zmi2m(1, mxy(1:2, 3))
          call zmsub_r2(mxy(1:2, 3), mxy(1:2, 11))
      endif

!             Use the b(2n)/(2n*x**(2n) asymptotic series.
!             To speed the asymptotic series calculation,
!             increase the argument by lshift.

      n_acc = nint(ndig*alogm2)
      kwrnsv = kwarn
      kwarn = 0
      call fmm2i(mxy(1, 11), inta)
      kwarn = kwrnsv

      if (kflag == -4) then
          lshift = 0
      else
          lshift = max(0, int(real(ndig)*alogmb/4.46-real(inta)))
      endif
      if (lshift > 0) lshift = 4*(lshift/4 + 1)

      if (lshift /= 0) then
          call zmi2m(lshift, mxy(1:2, 3))
          call zmadd(mxy(1:2, 11), mxy(1:2, 3), mxy(1:2, 10))
      else
          call zmeq(mxy(1:2, 11), mxy(1:2, 10))
      endif

!             Sum the asymptotic series.

      j2 = int(0.3*alogmb + 0.2*sqrt(real(ndig)))
      j2 = max(1, min(ljsums, j2))

!             mxy(1:2,11) is z
!             mxy(1:2,10) is z + lshift
!             mxy(1:2, 7) is x**j2 = (1/(z+lshift)**2)**j2
!             mxy(1:2, 8) is the current power of x
!             mxy(1:2, 9) is the current term in the sum
!             mjsums is the partial sum

      ndsav1 = ndig
      call zmi2m(1, mxy(1:2, 8))
      j = -2*j2
      call zmipwr(mxy(1:2, 10), j, mxy(1:2, 7))
      call zmabs(mxy(1:2, 7), mxy(1, 12))
      if (abs(mxy(1, 12)%mp(2)) >= mexpab) then
          j2 = 1
          call zmipwr(mxy(1:2, 10), -2, mxy(1:2, 7))
      endif
      nterm = 2
      do j = 1, j2
         nterm = 2*j
         call fmbern(nterm, mxy(1, 8), mxy(1, 9))
         call fmbern(nterm, mxy(2, 8), mxy(2, 9))
         if (kflag == -11) then
             call zmunknown(mresult)
             kflag = -4
             retry = .false.
             return
         endif
         ndenom = nterm
         call zmdivi(mxy(1:2, 9), ndenom, mjsums(1:2, j))
      enddo

      ndig2 = ndig
      kl = 1
      do while (kl == 1)
         call zmmpy_r1(mxy(1:2, 8), mxy(1:2, 7))
         nmxdif = min(ndsav1, ngrd22)
         do j = 1, j2
            nterm = nterm + 2
            call fmbern(nterm, mxy(1, 8), mxy(1, 9))
            call fmbern(nterm, mxy(2, 8), mxy(2, 9))
            if (kflag == -11) then
                call zmunknown(mresult)
                kflag = -4
                retry = .false.
                return
            endif
            ndenom = nterm
            call zmdivi_r1(mxy(1:2, 9), ndenom)
            ndig = ndsav1
            call zmadd_r1(mjsums(1:2, j), mxy(1:2, 9))
            nd1 = mjsums(1, j)%mp(2) - mxy(1, 9)%mp(2)
            nmxdif = max(nmxdif, ndsav1-nd1)
            nd1 = mjsums(2, j)%mp(2) - mxy(2, 9)%mp(2)
            nmxdif = max(nmxdif, ndsav1-nd1)
            ndig = ndig2
            if (kflag /= 0 .and. kflag /= -6) then
                kl = 0
                exit
            endif
         enddo
         ndig2 = nmxdif
         ndig = ndig2
      enddo

!             Put the j2 concurrent sums back together.

      ndig = ndsav1
      call zmi2m(1, mxy(1:2, 7))
      call zmsqr(mxy(1:2, 10), mxy(1:2, 9))
      call zmdiv_r2(mxy(1:2, 7), mxy(1:2, 9))
      if (j2 > 1) then
          call zmeq(mjsums(1:2, j2), mxy(1:2, 7))
          do j = j2-1, 1, -1
             call zmmpy_r1(mxy(1:2, 7), mxy(1:2, 9))
             call zmadd_r1(mxy(1:2, 7), mjsums(1:2, j))
          enddo
          call zmeq(mxy(1:2, 7), mjsums(1:2, 1))
      endif

!             Add the log term to the asymptotic series.

      call zmmpy(mjsums(1:2, 1), mxy(1:2, 9), mxy(1:2, 8))
      call zmln(mxy(1:2, 10), mxy(1:2, 9))
      call zmi2m(1, mxy(1:2, 4))
      call zmdiv(mxy(1:2, 4), mxy(1:2, 10), mxy(1:2, 5))
      call zmdivi_r1(mxy(1:2, 5), 2)
      call zmsub(mxy(1:2, 9), mxy(1:2, 5), mxy(1:2, 3))
      call fmcancel(mxy(1, 9), mxy(1, 5), mxy(1, 3), k1)
      call fmcancel(mxy(2, 9), mxy(2, 5), mxy(2, 3), k2)
      n_acc = n_acc - max(k1, k2)
      call zmeq(mxy(1:2, 3), mxy(1:2, 5))
      call zmsub(mxy(1:2, 5), mxy(1:2, 8), mxy(1:2, 3))
      call fmcancel(mxy(1, 5), mxy(1, 8), mxy(1, 3), k1)
      call fmcancel(mxy(2, 5), mxy(2, 8), mxy(2, 3), k2)
      n_acc = n_acc - max(k1, k2)
      call zmeq(mxy(1:2, 3), mxy(1:2, 8))

!             Now Psi of the shifted argument has been computed.  Reverse the shifting.
!             The sum 1/(ma) + ... + 1/(ma+lshift-1) is computed.

      if (lshift > 0) then
          call zmsqr(mxy(1:2, 11), mxy(1:2, 4))
          call zmmpy(mxy(1:2, 11), mxy(1:2, 4), mxy(1:2, 5))
          call zmsqr(mxy(1:2, 4), mxy(1:2, 6))
          call zmmpyi(mxy(1:2, 5), 6, mxy(1:2, 10))
          call zmadd_r1(mxy(1:2, 6), mxy(1:2, 10))
          call zmmpyi(mxy(1:2, 4), 11, mxy(1:2, 10))
          call zmadd_r1(mxy(1:2, 6), mxy(1:2, 10))
          call zmmpyi(mxy(1:2, 11), 6, mxy(1:2, 10))
          call zmadd(mxy(1:2, 6), mxy(1:2, 10), mxy(1:2, 7))
          call zmmpyi(mxy(1:2, 5), 4, mxy(1:2, 6))
          call zmmpyi(mxy(1:2, 4), 18, mxy(1:2, 10))
          call zmadd_r1(mxy(1:2, 6), mxy(1:2, 10))
          call zmmpyi(mxy(1:2, 11), 22, mxy(1:2, 10))
          call zmadd_r1(mxy(1:2, 6), mxy(1:2, 10))
          call zmi2m(6, mxy(1:2, 10))
          call zmadd_r1(mxy(1:2, 6), mxy(1:2, 10))
          call zmdiv(mxy(1:2, 6), mxy(1:2, 7), mxy(1:2, 9))
          call zmmpyi_r1(mxy(1:2, 5), 16)
          do k = 4, lshift-4, 4
             call zmadd_r1(mxy(1:2, 7), mxy(1:2, 5))

             call zmmpyi(mxy(1:2, 4), 48, mxy(1:2, 10))
             call zmadd_r1(mxy(1:2, 6), mxy(1:2, 10))

             k2 = 8*(6*k - 3)
             call zmmpyi(mxy(1:2, 4), k2, mxy(1:2, 10))
             call zmadd_r1(mxy(1:2, 7), mxy(1:2, 10))

             k1 = 16*(6*k - 3)
             call zmmpyi(mxy(1:2, 11), k1, mxy(1:2, 10))
             call zmadd_r1(mxy(1:2, 6), mxy(1:2, 10))

             if (k <= sqrt(real(intmax)/49.0)) then
                 k1 = 8*(6*k*k - 6*k + 7)
                 call zmmpyi(mxy(1:2, 11), k1, mxy(1:2, 10))
                 call zmadd_r1(mxy(1:2, 7), mxy(1:2, 10))

                 call zmi2m(k1, mxy(1:2, 10))
                 call zmadd_r1(mxy(1:2, 6), mxy(1:2, 10))
             else
                 k1 = 48*k
                 call zmmpyi(mxy(1:2, 11), k1, mxy(1:2, 10))
                 call zmmpyi_r1(mxy(1:2, 10), k)
                 call zmadd_r1(mxy(1:2, 7), mxy(1:2, 10))
                 k1b = 8*(-6*k + 7)
                 call zmmpyi(mxy(1:2, 11), k1b, mxy(1:2, 10))
                 call zmadd_r1(mxy(1:2, 7), mxy(1:2, 10))

                 call zmi2m(k1, mxy(1:2, 10))
                 call zmmpyi_r1(mxy(1:2, 10), k)
                 call zmadd_r1(mxy(1:2, 6), mxy(1:2, 10))
                 call zmi2m(k1b, mxy(1:2, 10))
                 call zmadd_r1(mxy(1:2, 6), mxy(1:2, 10))
             endif
             if (k <= (real(intmax)/17.0)**0.3333) then
                 k0 = 8*(2*k - 1)*(k*k - k + 3)
                 call zmi2m(k0, mxy(1:2, 10))
                 call zmadd_r1(mxy(1:2, 7), mxy(1:2, 10))
             else if (k <= sqrt(real(intmax)*0.9)) then
                 k0 = 8*(2*k - 1)
                 call zmi2m(k0, mxy(1:2, 10))
                 k0b = k*k - k + 3
                 call zmmpyi_r1(mxy(1:2, 10), k0b)
                 call zmadd_r1(mxy(1:2, 7), mxy(1:2, 10))
             else
                 k0 = 8*(2*k - 1)
                 call zmi2m(k0, mxy(1:2, 10))
                 call zmmpyi_r1(mxy(1:2, 10), k)
                 call zmmpyi_r1(mxy(1:2, 10), k)
                 call zmadd_r1(mxy(1:2, 7), mxy(1:2, 10))
                 k0b = -k + 3
                 call zmi2m(k0, mxy(1:2, 10))
                 call zmmpyi_r1(mxy(1:2, 10), k0b)
                 call zmadd_r1(mxy(1:2, 7), mxy(1:2, 10))
             endif
             call zmdiv(mxy(1:2, 6), mxy(1:2, 7), mxy(1:2, 10))
             call zmadd_r1(mxy(1:2, 9), mxy(1:2, 10))
          enddo
          call zmsub(mxy(1:2, 8), mxy(1:2, 9), mxy(1:2, 3))
          call fmcancel(mxy(1, 8), mxy(1, 9), mxy(1, 3), k1)
          call fmcancel(mxy(2, 8), mxy(2, 9), mxy(2, 3), k2)
          n_acc = n_acc - max(k1, k2)
          call zmeq(mxy(1:2, 3), mxy(1:2, 8))
      endif

!             Use the reflection formula if Real(ma) was less than -1/2.

      if (krflct == 1) then

!             Reduce the argument before multiplying by Pi.

          call fmnint(mxy(1, 11), mxy(1, 4))
          call fmsub(mxy(1, 11), mxy(1, 4), mxy(1, 7))
          call fmeq(mxy(2, 11), mxy(2, 7))
          call fmcancel(mxy(1, 11), mxy(1, 4), mxy(1, 7), k1)
          n_acc = n_acc - k1
          call fmpi(mxy(1, 9))
          call fmi2m(0, mxy(2, 9))
          call zmmpy_r1(mxy(1:2, 9), mxy(1:2, 7))
          krsave = krad
          krad = 1
          call zmtan(mxy(1:2, 9), mxy(1:2, 2))
          krad = krsave
          call fmpi(mxy(1, 9))
          call fmi2m(0, mxy(2, 9))
          call zmdiv_r2(mxy(1:2, 9), mxy(1:2, 2))
          call zmadd(mxy(1:2, 8), mxy(1:2, 2), mxy(1:2, 3))
          call fmcancel(mxy(1, 8), mxy(1, 2), mxy(1, 3), k1)
          call fmcancel(mxy(2, 8), mxy(2, 2), mxy(2, 3), k2)
          n_acc = n_acc - max(k1, k2)
          call zmeq(mxy(1:2, 3), mxy(1:2, 8))
      endif

      call zmeq(mxy(1:2, 8), mresult)

      return
      end subroutine zmpsi_m1

      subroutine zmpsi_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = psi(ma).

!  kresult = 1 is returned if a special case gives the value of psi(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMPSI    '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

!             If ma is real, use fmpsi.

      if (ma(2)%mp(3) == 0) then
          call fmpsi(malocal(1), mresult(1))
          call fmi2m(0, mresult(2))
          kresult = 1
          return
      endif

      return
      end subroutine zmpsi_sc

      subroutine zmpwr(ma, mb, mc)

!  mc = ma**mb

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma, mb
      intent (inout) :: mc

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave, no_retry
      logical :: retry
      type(multi), save :: mxy(5), mresult(2)

      call zmalloc(mc, ndig+2)
      call zmenter2(ma, mb, kovun, mxsave, ndsave)
      call zmpwr_sc(ma, mb, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mc, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         no_retry = 0
         call zmpwr_m1(ma, mb, mxy, mresult, ndsave, no_retry)
         if (no_retry == 0) call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mc, kovun, mxsave, ndsave)

      return
      end subroutine zmpwr

      subroutine zmpwr_m1(ma, mb, mxy, mresult, ndsave, no_retry)

!  Method 1 for computing  mc = ma**mb

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2), mxy(5), mresult(2)
      integer :: ndsave, no_retry
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mxy, mresult, no_retry

      integer :: iextra, intmb, j, jsin, jcos, jswap, k, kradsv, kwrnsv
      real :: xval
      real (kind(1.0d0)) :: mtemp
      double precision :: xe
      type(multi), save :: mz01(2), mz02(2), mz03(2), mz04(2), mz05(2), mz06(2)
      logical, external :: fmcomp

      k = max(mb(1)%mp(2), mb(2)%mp(2))
      if (k < 25000) then
          ndig = ndig + max(k, 0) + 1
      else
          ndig = ndig + 1
      endif

      call zmequ(ma, mz04, ndsave, ndig)
      call zmequ(mb, mz05, ndsave, ndig)

!             Check for special cases.

      if (ma(1)%mp(3) == 0 .and. ma(2)%mp(3) == 0) then
          if (mb(1)%mp(1) > 0 .and. mb(2)%mp(3) == 0) then
              call zmi2m(0, mresult)
              no_retry = 1
              return
          else
              kflag = -4
              call zmunknown(mresult)
              no_retry = 1
              return
          endif
      endif
      if (ma(2)%mp(3) == 0 .and. mb(2)%mp(3) == 0) then
          call fmpwr(mz04(1), mz05(1), mz02(1))
          call fmi2m(0, mz02(2))
          call zmeq(mz02, mresult)
          return
      else if (mb(2)%mp(3) == 0) then
          kwrnsv = kwarn
          kwarn = 0
          call fmm2i2(mz05(1), intmb)
          kwarn = kwrnsv
          if (kflag == 0) then
              if (ncall == 1) then
                  xval = abs(intmb) + 1
                  k = int((1.5*log(xval))/alogmb + 2.0)
                  ndig = max(ndig+k, 3)
                  if (mbase >= 100*abs(ma(1)%mp(3)) .or.  &
                      mbase >= 100*abs(ma(2)%mp(3))) then
                      ndig = ndig + 1
                  endif
              endif
              call zmequ_r1(mz04, ndsave, ndig)
              call zmipwr(mz04, intmb, mz03)
              call zmeq(mz03, mresult)
              return
          endif
      endif

!             Check for cases where abs(ma) is very close to 1, and avoid cancellation.

      call fmabs(mz04(1), mxy(1))
      call fmabs(mz04(2), mxy(2))
      call fmi2m(1, mxy(3))
      call fmovun_xe(mxy(2), xe)
      if (fmcomp(mxy(1), '==', mxy(3)) .and. (xe <= -ndig .or. mxy(2)%mp(3) == 0)) then
          if (ma(1)%mp(1) > 0) then

!                 (1+c)**b = 1 + b*c + ...

              call zmi2m(1, mz02)
              call zmsub(mz04, mz02, mz06)
              call zmmpy(mz05, mz06, mz02)
              call fmadd_r1(mz02(1), mxy(3))
          else

!                 (-1+c)**b = (-1)**b * (1 - b*c + ... )

              call zmi2m(-1, mz02)
              call zmsub(mz04, mz02, mz01)
              call zmmpy(mz05, mz01, mz06)
              call zmmpyi(mz06, -1, mz02)
              call fmadd_r1(mz02(1), mxy(3))
              kradsv = krad
              krad = 0
              if (ma(2)%mp(1) >= 0) then
                  call fmmpyi(mz05(1), 180, mxy(4))
              else
                  call fmmpyi(mz05(1), -180, mxy(4))
              endif
              call fmcssn(mxy(4), mz03(1), mz03(2))
              krad = kradsv
              call fmpi(mxy(3))
              call fmmpy_r1(mxy(3), mz05(2))
              if (ma(2)%mp(1) >= 0) call fmnegate(mxy(3))
              call fmexp(mxy(3), mxy(5))
              call fmeq(mxy(5), mxy(3))
              call fmmpyd(mxy(3), mz03(1), mz03(2), mz06(1), mz06(2))
              call zmmpy(mz02, mz06, mz01)
              call zmeq(mz01, mz02)
          endif
          call zmeq(mz02, mresult)
          return
      endif
      call fmovun_xe(mxy(1), xe)
      if (fmcomp(mxy(2), '==', mxy(3)) .and. (xe <= -ndig .or. mxy(1)%mp(3) == 0)) then
          if (ma(2)%mp(1) > 0) then

!                 (i+c)**b = i**b * (1 - b*c*i - ... )

              call zm2i2m(0, 1, mz02)
              call zmsub(mz04, mz02, mz06)
              call zmmpy(mz05, mz06, mz02)
              do j = 1, ndig+2
                 mtemp = mz02(1)%mp(j)
                 mz02(1)%mp(j) = mz02(2)%mp(j)
                 mz02(2)%mp(j) = mtemp
              enddo
              call fmnegate(mz02(2))
              call fmadd_r1(mz02(1), mxy(3))
              kradsv = krad
              krad = 0
              call fmmpyi(mz05(1), 90, mxy(4))
              call fmcssn(mxy(4), mz03(1), mz03(2))
              krad = kradsv
              call fmpi(mxy(3))
              call fmmpy_r1(mxy(3), mz05(2))
              call fmdivi_r1(mxy(3), -2)
              call fmexp(mxy(3), mxy(5))
              call fmeq(mxy(5), mxy(3))
              call fmmpyd(mxy(3), mz03(1), mz03(2), mz06(1), mz06(2))
              call zmmpy(mz02, mz06, mz01)
              call zmeq(mz01, mz02)
          else

!                 (-i+c)**b = (-i)**b * (1 + b*c*i - ... )

              call zm2i2m(0, -1, mz02)
              call zmsub(mz04, mz02, mz06)
              call zmmpy(mz05, mz06, mz02)
              do j = 1, ndig+2
                 mtemp = mz02(1)%mp(j)
                 mz02(1)%mp(j) = mz02(2)%mp(j)
                 mz02(2)%mp(j) = mtemp
              enddo
              call fmnegate(mz02(1))
              call fmadd_r1(mz02(1), mxy(3))
              kradsv = krad
              krad = 0
              call fmmpyi(mz05(1), -90, mxy(4))
              call fmcssn(mxy(4), mz03(1), mz03(2))
              krad = kradsv
              call fmpi(mxy(3))
              call fmmpy_r1(mxy(3), mz05(2))
              call fmdivi_r1(mxy(3), 2)
              call fmexp(mxy(3), mxy(5))
              call fmeq(mxy(5), mxy(3))
              call fmmpyd(mxy(3), mz03(1), mz03(2), mz06(1), mz06(2))
              call zmmpy(mz02, mz06, mz01)
              call zmeq(mz01, mz02)
          endif
          call zmeq(mz02, mresult)
          return
      endif

      call zmln(mz04, mz06)
      call zmmpy(mz05, mz06, mz02)
      call fmeq(mz02(2), mz01(1))
      call fmovun_xe(mz01(1), xe)
      if (xe > 25000) then
          kflag = -4
          call zmunknown(mresult)
          no_retry = 1
          return
      endif
      kwrnsv = kwarn
      kwarn = 0
      call fmrdc(mz01(1), jsin, jcos, jswap)
      kwarn = kwrnsv
      iextra = int(mz02(2)%mp(2) - mz01(1)%mp(2))
      if (abs(mz02(2)%mp(2)) >= mexpov .or. abs(mz01(1)%mp(2)) >= mexpov) iextra = 0
      if (ndig >= ndsave+ngrd52+max(0, iextra)) iextra = 0
      if (iextra > 1) then
          ndig = ndig + iextra
          call zmequ_r1(mz04, ndsave, ndig)
          call zmequ_r1(mz05, ndsave, ndig)
          call zmln(mz04, mz06)
          call zmmpy(mz05, mz06, mz02)
      endif

      call zmexp(mz02, mz04)
      call zmeq(mz04, mz02)


      call zmeq(mz02, mresult)

      return
      end subroutine zmpwr_m1

      subroutine zmpwr_sc(ma, mb, ndsave, mresult, kresult)

!  Check for special cases for  mc = ma**mb

!  kresult = 1 is returned if a special case gives the value of the result.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, mb, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2), mblocal(2), mz01(2), mz02(2)

      kresult = 0

      namest(ncall) = 'ZMPWR    '
      j = ndig
      ndig = ndsave
      call zmntr_inp2(ma, mb)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)
      call zmequ(mb, mblocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0) .or.  &
          (mblocal(1)%mp(2) == munkno .and. mblocal(1)%mp(5) >= 0) .or.  &
          (mblocal(2)%mp(2) == munkno .and. mblocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      if (abs(malocal(1)%mp(2)) >= mexpov .or. abs(malocal(2)%mp(2)) >= mexpov .or.  &
          abs(mblocal(1)%mp(2)) >= mexpov .or. abs(mblocal(2)%mp(2)) >= mexpov ) then
          call zmequ(malocal, mz01, ndsave, ndig)
          call zmequ(mblocal, mz02, ndsave, ndig)
          call zmpwr_unov(mz01, mz02, mresult)
          if (abs(mresult(1)%mp(2)) >= mexpov .or.  &
              abs(mresult(2)%mp(2)) >= mexpov) then
              kresult = 1
              return
          endif
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          if (mblocal(1)%mp(1) > 0 .and. mblocal(2)%mp(3) == 0) then
              call zmi2m(0, mresult)
              kresult = 1
              return
          else
              kflag = -4
              call zmunknown(mresult)
              kresult = 1
              return
          endif
      endif

      return
      end subroutine zmpwr_sc

      subroutine zmpwr_unov(ma, mb, mz)

!  Check special cases where at least one part of ma, mb is underflow or overflow.

!  Return mz as the result.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2), mz(2)
      intent (inout) :: mz
      intent (in) :: ma, mb

      type(multi), save :: mxy(3), mz01(2), mz02(2)
      real (kind(1.0d0)) :: ms
      double precision :: xe, xf, t1

      call zmabs(ma, mxy(1))
      if (abs(mxy(1)%mp(2)) == mexpov) then
          call fmovun_xexf(mxy(1), xe, xf)
          t1 = xe * log(dble(mbase)) + log(xf)
          call fmdp2m(t1, mxy(2))
      else
          call fmln(mxy(1), mxy(2))
      endif
      call zmarg(ma, mxy(3))
      call fmeq(mxy(2), mz01(1))
      call fmeq(mxy(3), mz01(2))
      call zmmpy(mb, mz01, mz02)
      call zmexp(mz02, mz)
      ms = mz(1)%mp(1)
      call fmovun_xexf(mz(1), xe, xf)
      if (xe > mxexp0+1) then
          call fmoverflow(1, mz(1))
          kflag = -5
      else if (xe < -mxexp0) then
          call fmunderflow(1, mz(1))
          kflag = -6
      else
          call fmunknown(mz(1))
          kflag = -4
      endif
      mz(1)%mp(1) = ms
      mz(1)%mp(4) = xe
      mz(1)%mp(5) = -xf*maxint

      ms = mz(2)%mp(1)
      call fmovun_xexf(mz(2), xe, xf)
      if (xe > mxexp0+1) then
          call fmoverflow(1, mz(2))
          kflag = -5
      else if (xe < -mxexp0) then
          call fmunderflow(1, mz(2))
          kflag = -6
      else
          call fmunknown(mz(2))
          kflag = -4
      endif
      mz(2)%mp(1) = ms
      mz(2)%mp(4) = xe
      mz(2)%mp(5) = -xf*maxint

      return
      end subroutine zmpwr_unov

      subroutine zmrational_power(ma, ival, jval, mb)

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      integer :: ival, jval
      intent (in) :: ma, ival, jval
      intent (inout) :: mb

      call zmrpwr(ma, ival, jval, mb)

      return
      end subroutine zmrational_power

      subroutine zmread(kread, ma)

!  Read ma on unit kread.  Multi-line numbers will have '&' as the last nonblank character on all
!  but the last line.  Only one number is allowed on the line(s).

      use fmvals
      implicit none

      integer :: kread
      type(multi) :: ma(2)
      intent (in) :: kread
      intent (inout) :: ma

      character :: line(80)
      integer :: j, jstat, k, kamper, l2, lb

      ncall = ncall + 1
      namest(ncall) = 'ZMREAD'
      lb = 0

      do
         read (kread, "(132A1)", iostat=jstat) line
         if (jstat /= 0) then
             kflag = -4
             call fmwarn
             call zmunknown(ma)
             ncall = ncall - 1
             return
         endif

!             Scan the line and look for '&'

         kamper = 0
         do j = 1, 80
            if (line(j) == '&') then
                kamper = 1
                exit
            endif
            if (line(j) /= ' ') then
                lb = lb + 1
                if (lb > lmbufz) then

!                If cmbufz runs out of space, try to re-allocate it with a bigger size.

                    if (lmbufz > 0) then
                        allocate(move_cmbuff(lmbufz), stat=k)
                        if (k /= 0) then
                            call fmdefine_error
                        endif
                        do k = 1, lmbufz
                           move_cmbuff(k) = cmbufz(k)
                        enddo
                        deallocate(cmbufz)
                        l2 = max(10000, 2*lmbufz)
                        allocate(cmbufz(l2), stat=k)
                        if (k /= 0) then
                            call fmdefine_error
                        endif
                        do k = 1, l2
                           cmbufz(k) = ' '
                        enddo
                        do k = 1, lmbufz
                           cmbufz(k) = move_cmbuff(k)
                        enddo
                        deallocate(move_cmbuff)
                        lmbufz = l2
                    else
                        allocate(cmbufz(10000), stat=k)
                        if (k /= 0) then
                            call fmdefine_error
                        endif
                        lmbufz = 10000
                    endif
                endif
                cmbufz(lb) = line(j)
             endif
         enddo
         if (kamper == 0) exit
         kamper = 0
      enddo

      ncall = ncall - 1
      call zminp(cmbufz, ma, 1, lb)

      return
      end subroutine zmread

      subroutine zmreal(ma, mbfm)

!  mbfm = real(ma)

!  ma is a complex zm number, mbfm is a real fm number.

      use fmvals
      implicit none

      type(multi) :: ma(2), mbfm
      intent (in) :: ma
      intent (inout) :: mbfm

      kflag = 0
      ncall = ncall + 1
      namest(ncall) = 'ZMREAL'
      if (ntrace /= 0) call zmntr_inp1(ma)

      call fmeq(ma(1), mbfm)

      if (ntrace /= 0) call fmntr_out1(mbfm)
      ncall = ncall - 1

      return
      end subroutine zmreal

      subroutine zmrpwr(ma, ival, jval, mb)

!  mb = ma**(ival/jval)

!  Raise a zm number to a rational power.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      integer :: ival, jval
      intent (in) :: ma, ival, jval
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy, mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmrpwr_sc(ma, ival, jval, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmrpwr_m1(ma, ival, jval, mxy, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmrpwr

      subroutine zmrpwr_m1(ma, ival, jval, mxy, mresult, ndsave)

!  Method 1 for computing ma**(ival/jval).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy, mresult(2)
      integer :: ival, jval, ndsave
      intent (in) :: ma, ival, jval, ndsave
      intent (inout) :: mxy, mresult

      integer :: ijsign, invert, ival2, j, jval2, k, kst, l, lval
      real :: xval
      real (kind(1.0d0)) :: mr1
      double precision :: ar, br, f, theta, x
      integer :: nstack(49)
      type(multi), save :: mz01(2), mz02(2), mz03(2), mz04(2)

      call zmequ(ma, mz02, ndsave, ndig)

      if (abs(mz02(1)%mp(2)) >= mexpov .or. abs(mz02(2)%mp(2)) >= mexpov) then
          call zmi2m(ival, mz01)
          call zmi2m(jval, mz03)
          call zmdiv_r1(mz01, mz03)
          call zmpwr(mz02, mz01, mresult)
          return
      endif

      kflag = 0
      ijsign = 1
      ival2 = abs(ival)
      jval2 = abs(jval)
      if (ival > 0 .and. jval < 0) ijsign = -1
      if (ival < 0 .and. jval > 0) ijsign = -1
      if (ival2 > 0 .and. jval2 > 0) call fmgcdi(ival2, jval2)

!             Increase the working precision.

      if (ncall == 1) then
          xval = max(abs(ival), abs(jval)) + 1
          k = int((5.0*real(dlogtn) + log(xval))/alogmb + 2.0)
          ndig = max(ndig+k, 3)
      else
          xval = max(abs(ival), abs(jval)) + 1
          k = int(log(xval)/alogmb + 1.0)
          ndig = ndig + k
      endif
      if (mbase >= 100*abs(mz02(1)%mp(3)) .or.  &
          mbase >= 100*abs(mz02(2)%mp(3))) then
          ndig = ndig + 1
      endif

      call zmequ(ma, mz02, ndsave, ndig)
      if (ival2 == 1 .and. jval2 == 2) then
          call zmsqrt(mz02, mz04)
          if (ijsign < 0) then
              call zmi2m(1, mz01)
              call zmdiv(mz01, mz04, mz02)
              call zmeq(mz02, mz04)
          endif
          call zmeq(mz04, mresult)
          return
      endif

!             Generate the first approximation to ma**(1/jval2).

      call zmi2m(0, mz04)
      call fmdig(nstack, kst)
      ndig = nstack(1)
      call fmsqr(mz02(1), mz01(1))
      call fmsqr(mz02(2), mxy)
      call fmadd_r1(mz01(1), mxy)
      call fmsqrt_r1(mz01(1))
      if (mz01(1)%mp(2) >= mexpov) then
          call zmunknown(mresult)
          return
      endif

!             Invert ma if abs(ma) >= 1 and ival or jval is large.

      invert = 0
      if (ival > 5 .or. jval > 5) then
          if (mz01(1)%mp(2) > 0 .and. (mz02(2)%mp(3) /= 0 .or.  &
              mz02(1)%mp(1) > 0)) then
              invert = 1
              ndig = nstack(kst)
              call zmi2m(1, mz04)
              call zmdiv(mz04, mz02, mz03)
              call zmeq(mz03, mz02)
              ndig = nstack(1)
              call fmdiv_r2(mz04(1), mz01(1))
          endif
      endif

      call fmdiv(mz02(1), mz01(1), mxy)
      if (mxy%mp(2) == munkno) then
          call zmunknown(mresult)
          return
      endif
      call fmm2dp(mxy, ar)
      call fmdiv(mz02(2), mz01(1), mxy)
      if (mxy%mp(2) == munkno) then
          call zmunknown(mresult)
          return
      endif
      call fmm2dp(mxy, br)
      mr1 = mz01(1)%mp(2)
      mz01(1)%mp(2) = 0
      call fmm2dp(mz01(1), x)
      l = int(mr1/jval2)
      f = mr1/dble(jval2) - l
      x = x**(1.0d0/jval2) * dble(mbase)**f
      call fmdpm(x, mxy)
      mxy%mp(2) = mxy%mp(2) + l

      theta = atan2(br, ar)
      x = cos(theta/jval2)
      call fmdpm(x, mz04(1))
      x = sin(theta/jval2)
      call fmdpm(x, mz04(2))
      call fmmpy_r2(mxy, mz04(1))
      call fmmpy_r2(mxy, mz04(2))

!             Newton iteration.

      do j = 1, kst
         ndig = nstack(j)
         if (j < kst) ndig = ndig + 1
         lval = jval2 - 1
         call zmipwr(mz04, lval, mz01)
         call zmdiv(mz02, mz01, mz03)
         call zmmpyi(mz04, lval, mz01)
         call zmadd(mz01, mz03, mz04)
         call zmdivi(mz04, jval2, mz03)
         call zmeq(mz03, mz04)
      enddo

      call zmipwr(mz03, ijsign*ival2, mz04)
      if (invert == 1) then
          call zmi2m(1, mz01)
          call zmdiv(mz01, mz04, mz03)
          call zmeq(mz03, mz04)
      endif

      call zmeq(mz04, mresult)

      return
      end subroutine zmrpwr_m1

      subroutine zmrpwr_sc(ma, ival, jval, ndsave, mresult, kresult)

!  Check for special cases for mresult = ma**(ival/jval)

!  kresult = 1 is returned if a special case gives the value of ma**(ival/jval).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: ival, jval, kresult, ndsave
      intent (in) :: ma, ival, jval, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMRPWR   '
      j = ndig
      ndig = ndsave
      call zmntr_inp1ii(ma, ival, jval)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0) .or.  &
          jval == 0) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          if ((ival > 0 .and. jval > 0) .or. (ival < 0 .and. jval < 0)) then
              call zmi2m(1, mresult)
          else
              call zmunknown(mresult)
          endif
          kresult = 1
          return
      endif

      if (ival == 0) then
          call zmi2m(1, mresult)
          kresult = 1
          return
      endif

      return
      end subroutine zmrpwr_sc

      subroutine zmsin(ma, mb)

!  mb = sin(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(5), mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmsin_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmsin_m1(ma, mxy, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmsin

      subroutine zmsin_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing sin(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(5), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      double precision :: xe, ye
      type(multi), save :: mz01(2), mz02(2)

      call zmequ(ma, mz02, ndsave, ndig)

      call fmovun_xe(ma(1), xe)
      call fmovun_xe(ma(2), ye)
      if (xe < -ndig .and. ye < -ndig) then
          call zmeq(mz02, mresult)
          return
      else if (ma(2)%mp(3) == 0) then
          call fmsin(mz02(1), mresult(1))
          call fmi2m(0, mresult(2))
          return
      else if (ma(1)%mp(3) == 0) then
          call fmsinh(mz02(2), mresult(2))
          call fmi2m(0, mresult(1))
          return
      endif

!             Find cos(real(ma)) and sin(real(ma)).

      call fmcssn(mz02(1), mz01(2), mz01(1))

!             find cosh(imag(ma)) and sinh(imag(ma)).

      call fmchsh(mz02(2), mxy(1), mxy(2))

!             sin(ma) =  sin(real(ma))*cosh(imag(ma)) + cos(real(ma))*sinh(imag(ma)) i

      if (mxy(1)%mp(2) == mexpov) then
          call fmabs(mz01(1), mxy(1))
          call fmdivi_r1(mxy(1), 2)
          call fmln(mxy(1), mxy(2))
          call fmabs(mz02(2), mxy(3))
          call fmadd(mxy(2), mxy(3), mxy(5))
          call fmexp(mxy(5), mxy(4))
          if (mz01(1)%mp(1) < 0) call fmnegate(mxy(4))

          call fmabs(mz01(2), mxy(1))
          call fmdivi_r1(mxy(1), 2)
          call fmln(mxy(1), mxy(2))
          call fmadd(mxy(2), mxy(3), mxy(1))
          call fmexp(mxy(1), mxy(5))
          if (mz02(2)%mp(1) < 0) call fmnegate(mxy(5))
          if (mz01(2)%mp(1) < 0) call fmnegate(mxy(5))

          call fmeq(mxy(4), mz01(1))
          call fmeq(mxy(5), mz01(2))
      else
          call fmmpy_r1(mz01(1), mxy(1))
          call fmmpy_r1(mz01(2), mxy(2))
      endif

      call zmeq(mz01, mresult)

      return
      end subroutine zmsin_m1

      subroutine zmsin_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = sin(ma).

!  kresult = 1 is returned if a special case gives the value of sin(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMSIN    '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call zmi2m(0, mresult)
          kresult = 1
          return
      endif

      return
      end subroutine zmsin_sc

      subroutine zmsinh(ma, mb)

!  mb = sinh(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(5), mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmsinh_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmsinh_m1(ma, mxy, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmsinh

      subroutine zmsinh_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing sinh(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(5), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      double precision :: xe, ye
      type(multi), save :: mz01(2), mz02(2)

      call zmequ(ma, mz02, ndsave, ndig)

      call fmovun_xe(ma(1), xe)
      call fmovun_xe(ma(2), ye)
      if (xe < -ndig .and. ye < -ndig) then
          call zmeq(mz02, mresult)
          return
      else if (ma(1)%mp(3) == 0) then
          call fmsin(mz02(2), mresult(2))
          call fmi2m(0, mresult(1))
          return
      else if (ma(2)%mp(3) == 0) then
          call fmsinh(mz02(1), mresult(1))
          call fmi2m(0, mresult(2))
          return
      endif

!             Find sin(imag(ma)) and cos(imag(ma)).

      call fmcssn(mz02(2), mz01(1), mz01(2))

!             Find sinh(real(ma)) and cosh(real(ma)).

      call fmchsh(mz02(1), mxy(1), mxy(2))

!             sinh(ma) =  sinh(real(ma))*cos(imag(ma)) + cosh(real(ma))*sin(imag(ma)) i

      if (mxy(1)%mp(2) == mexpov) then
          call fmabs(mz01(1), mxy(1))
          call fmdivi_r1(mxy(1), 2)
          call fmln(mxy(1), mxy(2))
          call fmabs(mz02(1), mxy(3))
          call fmadd(mxy(2), mxy(3), mxy(5))
          call fmexp(mxy(5), mxy(4))
          if (mz01(1)%mp(1) < 0) call fmnegate(mxy(4))
          if (mz02(1)%mp(1) < 0) call fmnegate(mxy(4))

          call fmabs(mz01(2), mxy(1))
          call fmdivi_r1(mxy(1), 2)
          call fmln(mxy(1), mxy(2))
          call fmadd(mxy(2), mxy(3), mxy(1))
          call fmexp(mxy(1), mxy(5))
          if (mz01(2)%mp(1) < 0) call fmnegate(mxy(5))

          call fmeq(mxy(4), mz01(1))
          call fmeq(mxy(5), mz01(2))
      else
          call fmmpy_r1(mz01(1), mxy(2))
          call fmmpy_r1(mz01(2), mxy(1))
      endif

      call zmeq(mz01, mresult)

      return
      end subroutine zmsinh_m1

      subroutine zmsinh_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = sinh(ma).

!  kresult = 1 is returned if a special case gives the value of sinh(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMSINH   '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call zmi2m(0, mresult)
          kresult = 1
          return
      endif

      return
      end subroutine zmsinh_sc

      subroutine zmsqr(ma, mb)

!  mb = ma*ma.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(2), mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmsqr_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmsqr_m1(ma, mxy, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmsqr

      subroutine zmsqr_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing ma*ma.

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(2), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      type(multi), save :: mz01(2), mz02(2)

      call zmequ(ma, mz02, ndsave, ndig)

      call fmadd(mz02(1), mz02(2), mxy(1))
      call fmsub(mz02(1), mz02(2), mxy(2))
      call fmmpy(mxy(1), mxy(2), mz01(1))
      call fmmpy(mz02(1), mz02(2), mxy(2))
      call fmadd(mxy(2), mxy(2), mz01(2))

      call zmeq(mz01, mresult)

      return
      end subroutine zmsqr_m1

      subroutine zmsqr_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = ma*ma.

!  kresult = 1 is returned if a special case gives the value of ma*ma.

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMSQR    '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      if (malocal(2)%mp(3) == 0) then
          call fmsqr(malocal(1), mresult(1))
          call fmi2m(0, mresult(2))
          kresult = 1
      else if (malocal(1)%mp(3) == 0) then
          call fmsqr(malocal(2), mresult(1))
          call fmnegate(mresult(1))
          call fmi2m(0, mresult(2))
          kresult = 1
      endif

      return
      end subroutine zmsqr_sc

      subroutine zmsqrt(ma, mb)

!  mb = sqrt(ma).  Principal Square Root.

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, ndsave
      logical :: retry
      type(multi), save :: mxy(3), mresult(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmsqrt_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      retry = .true.
      do while (retry)
         retry = .false.
         call zmsqrt_m1(ma, mxy, mresult, ndsave)
         call zmcheck_accuracy(mresult, ndsave, retry)
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmsqrt

      subroutine zmsqrt_m1(ma, mxy, mresult, ndsave)

!  Method 1 for computing sqrt(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(3), mresult(2)
      integer :: ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult

      type(multi), save :: mz01(2), mz02(2)

      call zmequ(ma, mz02, ndsave, ndig)

      if (ma(1)%mp(3) == 0) then
          call fmabs(mz02(2), mxy(1))
          call fmdivi(mxy(1), 2, mxy(3))
          call fmsqrt_r1(mxy(3))
      else if (ma(2)%mp(3) == 0) then
          call fmabs(mz02(1), mxy(3))
          call fmsqrt_r1(mxy(3))
      else if (ma(2)%mp(2) == mexpun) then
          call fmsqr(mz02(1), mxy(1))
          call fmsqr(mz02(2), mxy(2))
          call fmadd(mxy(1), mxy(2), mxy(3))
          call fmsqrt_r1(mxy(3))
          if (mxy(3)%mp(2) == munkno) then
              call fmabs(mz02(1), mxy(1))
              call fmabs(mz02(2), mxy(2))
              call fmmax(mxy(1), mxy(2), mz01(1))
              call fmmin(mxy(1), mxy(2), mz01(2))
              call fmdiv(mz01(2), mz01(1), mxy(3))
              call fmi2m(1, mxy(1))
              call fmadd(mxy(1), mxy(3), mxy(2))
              call fmsqrt_r1(mxy(2))
              call fmmpy(mz01(1), mxy(2), mxy(3))
          endif
          call fmabs(mz02(1), mxy(2))
          call fmadd_r2(mxy(2), mxy(3))
          call fmdivi_r1(mxy(3), 2)
          call fmsqrt_r1(mxy(3))
      else
          call fmsqr(mz02(1), mxy(1))
          call fmsqr(mz02(2), mxy(2))
          call fmadd(mxy(1), mxy(2), mxy(3))
          call fmsqrt_r1(mxy(3))
          if (mxy(3)%mp(2) == munkno) then
              call fmabs(mz02(1), mxy(1))
              call fmabs(mz02(2), mxy(2))
              call fmmax(mxy(1), mxy(2), mz01(1))
              call fmmin(mxy(1), mxy(2), mz01(2))
              call fmdiv(mz01(2), mz01(1), mxy(3))
              call fmi2m(1, mxy(1))
              call fmadd(mxy(1), mxy(3), mxy(2))
              call fmsqrt_r1(mxy(2))
              call fmmpy(mz01(1), mxy(2), mxy(3))
          endif
          call fmabs(mz02(1), mxy(2))
          call fmadd_r2(mxy(2), mxy(3))
          call fmdivi_r1(mxy(3), 2)
          call fmsqrt_r1(mxy(3))
      endif

      call fmadd(mxy(3), mxy(3), mxy(2))
      if (ma(1)%mp(1) >= 0) then
          call fmdiv(mz02(2), mxy(2), mz01(2))
          call fmeq(mxy(3), mz01(1))
      else
          if (ma(2)%mp(1) >= 0) then
              call fmdiv(mz02(2), mxy(2), mz01(1))
              call fmeq(mxy(3), mz01(2))
          else
              call fmdiv(mz02(2), mxy(2), mz01(1))
              call fmeq(mxy(3), mz01(2))
              call fmnegate(mz01(1))
              call fmnegate(mz01(2))
          endif
      endif

      call zmeq(mz01, mresult)

      return
      end subroutine zmsqrt_m1

      subroutine zmsqrt_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = sqrt(ma).

!  kresult = 1 is returned if a special case gives the value of sqrt(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMSQRT   '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call zmi2m(0, mresult)
          kresult = 1
          return
      endif

      return
      end subroutine zmsqrt_sc

      subroutine zmst2m(string, ma)

!  ma = string

!  Convert a character string to fm format.
!  This is often more convenient than using zminp, which converts an array of character(1) values.

      use fmvals
      implicit none

      character(*) :: string
      type(multi) :: ma(2)
      intent (in) :: string
      intent (inout) :: ma

      integer :: j, lb, kfsave

      ncall = ncall + 1
      namest(ncall) = 'ZMST2M'
      lb = len(string)
      kfsave = kflag

      if (lb > lmbufz) then
          if (lmbufz > 0) deallocate(cmbufz)
          allocate(cmbufz(lb), stat=j)
          if (j /= 0) then
              call fmdefine_error
          endif
          lmbufz = lb
      endif
      do j = 1, lb
         cmbufz(j) = string(j:j)
      enddo

      ncall = ncall - 1
      call zminp(cmbufz, ma, 1, lb)

      if (kfsave /= 0) kflag = kfsave

      return
      end subroutine zmst2m

      subroutine zmsub(ma, mb, mc)

!  mc = ma - mb

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma, mb
      intent (inout) :: mc

      integer :: kovun
      double precision :: xe1, xe2, xe3, xe4
      type(multi), save :: mxy(2)

      ncall = ncall + 1
      if (ntrace /= 0) then
          namest(ncall) = 'ZMSUB'
          call zmntr_inp2(ma, mb)
      endif
      kovun = 0
      if (ma(1)%mp(2) == mexpov .or. ma(1)%mp(2) == mexpun) kovun = 1
      if (ma(2)%mp(2) == mexpov .or. ma(2)%mp(2) == mexpun) kovun = 1
      if (mb(1)%mp(2) == mexpov .or. mb(1)%mp(2) == mexpun) kovun = 1
      if (mb(2)%mp(2) == mexpov .or. mb(2)%mp(2) == mexpun) kovun = 1
      if (ma(1)%mp(2) == munkno .or. ma(2)%mp(2) == munkno) kovun = 2
      if (mb(1)%mp(2) == munkno .or. mb(2)%mp(2) == munkno) kovun = 2

      call zmeq(mb, mxy)
      call fmnegate(mxy(1))
      call fmnegate(mxy(2))
      call zmadd(ma, mxy, mc)
      if (kflag == 1) then
          call fmovun_xe(ma(1), xe1)
          call fmovun_xe(ma(2), xe2)
          call fmovun_xe(mb(1), xe3)
          call fmovun_xe(mb(2), xe4)
          if (max(xe1, xe2) <= max(xe3, xe4)) kflag = 0
      endif
      if (mc(1)%mp(2) == munkno .or. mc(2)%mp(2) == munkno) then
          if (kflag /= 1) kflag = -4
      else if (mc(1)%mp(2) == mexpov .or. mc(2)%mp(2) == mexpov) then
          if (kflag /= 1) kflag = -5
      else if (mc(1)%mp(2) == mexpun .or. mc(2)%mp(2) == mexpun) then
          if (kflag /= 1) kflag = -6
      endif
      if ((mc(1)%mp(2) == munkno .and. kovun /= 2) .or.  &
          (mc(2)%mp(2) == munkno .and. kovun /= 2) .or.  &
          (mc(1)%mp(2) == mexpun .and. kovun == 0) .or.  &
          (mc(2)%mp(2) == mexpun .and. kovun == 0) .or.  &
          (mc(1)%mp(2) == mexpov .and. kovun == 0) .or.  &
          (mc(2)%mp(2) == mexpov .and. kovun == 0)) then
          namest(ncall) = 'ZMSUB'
          call fmwarn
      endif
      if (ntrace /= 0) call zmntr_out1(mc)
      ncall = ncall - 1

      return
      end subroutine zmsub

      subroutine zmsub_r1(ma, mb)

!  ma = ma - mb

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (inout) :: ma
      intent (in) :: mb

      integer :: k
      type(multi), save :: mxy(2)

      call zmsub(ma, mb, mxy)
      k = kflag
      call zmeq(mxy, ma)
      kflag = k

      end subroutine zmsub_r1

      subroutine zmsub_r2(ma, mb)

!  mb = ma - mb

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      integer :: k
      type(multi), save :: mxy(2)

      call zmsub(ma, mb, mxy)
      k = kflag
      call zmeq(mxy, mb)
      kflag = k

      end subroutine zmsub_r2

      subroutine zmtan(ma, mb)

!  mb = tan(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(3), mresult(2), mretry(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmtan_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      n_acc = nint(ndig*alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call zmtan_m1(ma, mxy, mresult, ndsave, n_acc)
         call zmcheck_accuracy(mresult, ndsave, retry)
         if (.not. retry) then
             call zmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)
         endif
         numtry = numtry + 1
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmtan

      subroutine zmtan_m1(ma, mxy, mresult, ndsave, n_acc)

!  Method 1 for computing tan(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(3), mresult(2)
      integer :: ndsave, n_acc
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, n_acc

      integer :: k, krsave
      double precision :: xe, ye
      type(multi), save :: mz01(2), mz02(2), mz03(2)

      ndig = ndig + ngrd21
      call zmequ(ma, mz02, ndsave, ndig)
      n_acc = nint(ndig*alogm2)
      krsave = krad
      krad = 1

      call fmovun_xe(ma(1), xe)
      call fmovun_xe(ma(2), ye)
      if (xe < -ndig .and. ye < -ndig) then
          call zmeq(mz02, mresult)
          krad = krsave
          return
      else if (ma(2)%mp(3) == 0) then
          call fmtan(mz02(1), mresult(1))
          call fmi2m(0, mresult(2))
          krad = krsave
          return
      else if (ma(1)%mp(3) == 0) then
          call fmtanh(mz02(2), mresult(2))
          call fmi2m(0, mresult(1))
          krad = krsave
          return
      endif

!             Find sin(2*real(ma)) and cos(2*real(ma)).

      call fmadd(mz02(1), mz02(1), mz01(1))
      call fmcssn(mz01(1), mz01(2), mxy(2))
      call fmeq(mxy(2), mz01(1))

!             Find sinh(2*imag(ma)) and cosh(2*imag(ma)).

      call fmadd(mz02(2), mz02(2), mxy(2))
      call fmchsh(mxy(2), mxy(1), mxy(3))
      call fmeq(mxy(3), mxy(2))
      if (mz01(1)%mp(2) == munkno .and. mz01(1)%mp(5) >= 0) then
          if (kround == 1) then
              call fmovun_xe(mxy(1), xe)
              if (xe >= ndig) then
                  call fmi2m(0, mz01(2))
                  call fmi2m(1, mxy(1))
                  call fmi2m(1, mxy(2))
                  mxy(2)%mp(1) = ma(2)%mp(1)
              endif
          endif
      endif

!             tan(ma) =  sin(2*real(ma))  / (cos(2*real(ma))+cosh(2*imag(ma)) +
!                        sinh(2*imag(ma)) / (cos(2*real(ma))+cosh(2*imag(ma)) i

      call fmadd(mz01(2), mxy(1), mxy(3))
      call fmcancel(mz01(2), mxy(1), mxy(3), k)
      n_acc = n_acc - k
      call fmeq(mxy(3), mxy(1))
      if (mxy(1)%mp(2) == mexpov) then
          call fmdiv_r1(mz01(1), mxy(1))
          call fmi2m2(1, mz01(2))
          if (mxy(2)%mp(1) < 0) call fmnegate(mz01(2))
      else
          call fmdivd(mz01(1), mxy(2), mxy(1), mz03(1), mz03(2))
          call zmeq(mz03, mz01)
      endif

      call zmeq(mz01, mresult)
      krad = krsave

      return
      end subroutine zmtan_m1

      subroutine zmtan_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = tan(ma).

!  kresult = 1 is returned if a special case gives the value of tan(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMTAN    '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call zmi2m(0, mresult)
          kresult = 1
          return
      endif

      return
      end subroutine zmtan_sc

      subroutine zmtanh(ma, mb)

!  mb = tanh(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb

      real (kind(1.0d0)) :: mxsave
      integer :: kovun, kresult, n_acc, ndsave, numtry
      logical :: retry
      type(multi), save :: mxy(3), mresult(2), mretry(2)

      call zmalloc(mb, ndig+2)
      call zmenter1(ma, kovun, mxsave, ndsave)
      call zmtanh_sc(ma, ndsave, mresult, kresult)
      if (kresult > 0) then
          call zmexit1(mresult, mb, kovun, mxsave, ndsave)
          return
      endif

      if (mblogs /= mbase) call fmcons

      numtry = 0
      n_acc = nint(ndig*alogm2)
      retry = .true.
      do while (retry)
         retry = .false.
         call zmtanh_m1(ma, mxy, mresult, ndsave, n_acc)
         call zmcheck_accuracy(mresult, ndsave, retry)
         if (.not. retry) then
             call zmcheck_cancellation(mresult, ndsave, n_acc, numtry, mretry, retry)
         endif
         numtry = numtry + 1
      enddo

      call zmexit1(mresult, mb, kovun, mxsave, ndsave)

      return
      end subroutine zmtanh

      subroutine zmtanh_m1(ma, mxy, mresult, ndsave, n_acc)

!  Method 1 for computing tanh(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mxy(3), mresult(2)
      integer :: ndsave, n_acc
      intent (in) :: ma, ndsave
      intent (inout) :: mxy, mresult, n_acc

      integer :: k, krsave
      double precision :: xe, ye
      type(multi), save :: mz01(2), mz02(2), mz03(2)

      call zmequ(ma, mz02, ndsave, ndig)
      n_acc = nint(ndig*alogm2)
      krsave = krad
      krad = 1

      call fmovun_xe(mz02(1), xe)
      call fmovun_xe(mz02(2), ye)
      if (xe < -ndig .and. ye < -ndig) then
          call zmeq(mz02, mresult)
          krad = krsave
          return
      else if (ma(1)%mp(3) == 0) then
          call fmtan(mz02(2), mresult(2))
          call fmi2m(0, mresult(1))
          krad = krsave
          return
      else if (ma(2)%mp(3) == 0) then
          call fmtanh(mz02(1), mresult(1))
          call fmi2m(0, mresult(2))
          krad = krsave
          return
      endif

!             Find sin(2*imag(ma)) and cos(2*imag(ma)).

      call fmadd(mz02(2), mz02(2), mz01(1))
      call fmcssn(mz01(1), mz01(2), mxy(2))
      call fmeq(mxy(2), mz01(1))

!             Find sinh(2*real(ma)) and cosh(2*real(ma)).

      call fmadd(mz02(1), mz02(1), mxy(2))
      call fmchsh(mxy(2), mxy(1), mxy(3))
      call fmeq(mxy(3), mxy(2))
      if (mz01(1)%mp(2) == munkno .and. mz01(1)%mp(5) >= 0) then
          if (kround == 1) then
              call fmovun_xe(mxy(1), xe)
              if (xe >= ndig) then
                  call fmi2m(0, mz01(2))
                  call fmi2m(1, mxy(1))
                  call fmi2m(1, mxy(2))
                  mxy(2)%mp(1) = ma(1)%mp(1)
              endif
          endif
      endif

!             tanh(ma) =  sinh(2*real(ma)) / (cos(2*imag(ma))+cosh(2*real(ma)) +
!                         sin(2*imag(ma))  / (cos(2*imag(ma))+cosh(2*real(ma)) i

      call fmadd(mz01(2), mxy(1), mxy(3))
      call fmcancel(mz01(2), mxy(1), mxy(3), k)
      n_acc = n_acc - k
      call fmeq(mxy(3), mxy(1))
      if (mxy(1)%mp(2) == mexpov) then
          call fmdiv(mz01(1), mxy(1), mz01(2))
          call fmi2m2(1, mz01(1))
          if (mxy(2)%mp(1) < 0) mz01(1)%mp(1) = -1
      else
          call fmdivd(mz01(1), mxy(2), mxy(1), mz03(2), mz03(1))
          call zmeq(mz03, mz01)
      endif

      call zmeq(mz01, mresult)
      krad = krsave

      return
      end subroutine zmtanh_m1

      subroutine zmtanh_sc(ma, ndsave, mresult, kresult)

!  Check for special cases for mresult = tanh(ma).

!  kresult = 1 is returned if a special case gives the value of tanh(ma).

      use fmvals
      implicit none

      type(multi) :: ma(2), mresult(2)
      integer :: kresult, ndsave
      intent (in) :: ma, ndsave
      intent (inout) :: mresult, kresult

      integer :: j
      type(multi), save :: malocal(2)

      kresult = 0

      namest(ncall) = 'ZMTANH   '
      j = ndig
      ndig = ndsave
      call zmntr_inp1(ma)
      ndig = j

      call zmequ(ma, malocal, ndsave, ndig)

      if ((malocal(1)%mp(2) == munkno .and. malocal(1)%mp(5) >= 0) .or.  &
          (malocal(2)%mp(2) == munkno .and. malocal(2)%mp(5) >= 0)) then
          call zmunknown(mresult)
          kresult = 1
          return
      endif

      if (malocal(1)%mp(3) == 0 .and. malocal(2)%mp(3) == 0) then
          call zmi2m(0, mresult)
          kresult = 1
          return
      endif

      return
      end subroutine zmtanh_sc

      subroutine zmunknown(ma)

!  Set ma to fm's special value for unknown complex results.

      use fmvals
      implicit none

      type(multi) :: ma(2)
      intent (inout) :: ma

      call fmunknown(ma(1))
      call fmunknown(ma(2))

      return
      end subroutine zmunknown

      subroutine zmunpk(mp, ma)

!  mp is unpacked and the value returned in ma.

      use fmvals
      implicit none

      type(multi) :: ma(2), mp(2)
      intent (in) :: mp
      intent (inout) :: ma

      call fmunpk(mp(1), ma(1))
      call fmunpk(mp(2), ma(2))

      return
      end subroutine zmunpk

      subroutine zmwrit(kwrite, ma)

!  Write ma on unit kwrite under the current format.  Multi-line numbers will have '&' as the last
!  nonblank character on all but the last line of the real part and the imaginary part.
!  These numbers can then be read easily using zmread.

      use fmvals
      implicit none

      integer :: kwrite
      type(multi) :: ma(2)
      intent (in) :: ma, kwrite

      integer :: j, k, ksave, l, last, last1, last2, lb, nd, nexp

      ncall = ncall + 1
      namest(ncall) = 'ZMWRIT'
      ksave = kflag
      nd = int(real(ndig)*log10(real(mbase))) + 1
      if (nd < 2) nd = 2
      nexp = int(2.0*log10(real(mxbase))) + 16
      lb = 2*max(jform2+nexp, nd+nexp) + 3
      if (lb > lmbufz) then
          if (lmbufz > 0) deallocate(cmbufz)
          allocate(cmbufz(lb), stat=j)
          if (j /= 0) then
              call fmdefine_error
          endif
          lmbufz = lb
      endif
      call zmout(ma, cmbufz, lb, last1, last2)
      kflag = ksave
      last = last2 + 1
      do j = 1, last2
         if (cmbufz(last-j) /= ' ' .or. j == last2) then
             l = last - j
             if (mod(l, 73) /= 0) then
                 write (kwrite, "(4X, 73A1, ' &')") (cmbufz(k), k=1, l)
             else
                 write (kwrite, "(4X, 73A1, ' &')") (cmbufz(k), k=1, l-73)
                 write (kwrite, "(4X, 73A1)") (cmbufz(k), k=l-72, l)
             endif
             ncall = ncall - 1
             return
         endif
      enddo
      ncall = ncall - 1

      return
      end subroutine zmwrit

      subroutine zmwrite(kwrite, ma)

      use fmvals
      implicit none

      integer :: kwrite
      type(multi) :: ma(2)
      intent (in) :: kwrite, ma

      call zmwrit(kwrite, ma)

      return
      end subroutine zmwrite

      subroutine zmz2m(zval, ma)

!  ma = zval

!  zval is complex and is converted to zm form.

      use fmvals
      implicit none

      complex :: zval
      type(multi) :: ma(2)
      intent (in) :: zval
      intent (inout) :: ma

      ncall = ncall + 1
      namest(ncall) = 'ZMZ2M'
      if (ntrace /= 0) call fmntr_inpz(zval)

      call fmsp2m(real(zval), ma(1))
      call fmsp2m(aimag(zval), ma(2))

      if (ntrace /= 0) call zmntr_out1(ma)
      ncall = ncall - 1

      return
      end subroutine zmz2m

      subroutine zp2i2m(integ1, integ2, ma)
      use fmvals
      implicit none
      integer :: integ1, integ2
      type(multi) :: ma(2)
      intent (in) :: integ1, integ2
      intent (inout) :: ma
      call zm2i2m(integ1, integ2, mpx)
      call zmpack(mpx, ma)
      return
      end subroutine zp2i2m

      subroutine zpabs(ma, mbfm)
      use fmvals
      implicit none
      type(multi) :: ma(2), mbfm
      intent (in) :: ma
      intent (inout) :: mbfm
      call zmunpk(ma, mpx)
      call zmabs(mpx, mpa)
      call fmpack(mpa, mbfm)
      return
      end subroutine zpabs

      subroutine zpacos(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmacos(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpacos

      subroutine zpacosh(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmacosh(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpacosh

      subroutine zpadd(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma, mb
      intent (inout) :: mc
      call zmunpk(ma, mpx)
      call zmunpk(mb, mpy)
      call zmadd(mpx, mpy, mpz)
      call zmpack(mpz, mc)
      return
      end subroutine zpadd

      subroutine zpaddi(ma, integ)
      use fmvals
      implicit none
      type(multi) :: ma(2)
      integer :: integ
      intent (in) :: integ
      intent (inout) :: ma
      call zmunpk(ma, mpx)
      call zmaddi(mpx, integ)
      call zmpack(mpx, ma)
      return
      end subroutine zpaddi

      subroutine zparg(ma, mbfm)
      use fmvals
      implicit none
      type(multi) :: ma(2), mbfm
      intent (in) :: ma
      intent (inout) :: mbfm
      call zmunpk(ma, mpx)
      call zmarg(mpx, mpa)
      call fmpack(mpa, mbfm)
      return
      end subroutine zparg

      subroutine zpasin(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmasin(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpasin

      subroutine zpasinh(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmasinh(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpasinh

      subroutine zpatan(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmatan(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpatan

      subroutine zpatanh(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmatanh(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpatanh

      subroutine zpchsh(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma
      intent (inout) :: mb, mc
      call zmunpk(ma, mpx)
      call zmchsh(mpx, mpy, mpz)
      call zmpack(mpy, mb)
      call zmpack(mpz, mc)
      return
      end subroutine zpchsh

      subroutine zpcmpx(mafm, mbfm, mc)
      use fmvals
      implicit none
      type(multi) :: mafm, mbfm, mc(2)
      intent (in) :: mafm, mbfm
      intent (inout) :: mc
      call fmunpk(mafm, mpa)
      call fmunpk(mbfm, mpb)
      call zmcmpx(mpa, mpb, mpx)
      call zmpack(mpx, mc)
      return
      end subroutine zpcmpx

      subroutine zpcomb(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma, mb
      intent (inout) :: mc
      call zmunpk(ma, mpx)
      call zmunpk(mb, mpy)
      call zmcomb(mpx, mpy, mpz)
      call zmpack(mpz, mc)
      return
      end subroutine zpcomb

      subroutine zpcomplex(mafm, mbfm, mc)
      use fmvals
      implicit none
      type(multi) :: mafm, mbfm, mc(2)
      intent (in) :: mafm, mbfm
      intent (inout) :: mc
      call zpcmpx(mafm, mbfm, mc)
      return
      end subroutine zpcomplex

      subroutine zpconj(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmconj(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpconj

      subroutine zpconjugate(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zpconj(ma, mb)
      return
      end subroutine zpconjugate

      subroutine zpcos(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmcos(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpcos

      subroutine zpcos_sin(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma
      intent (inout) :: mb, mc
      call zpcssn(ma, mb, mc)
      return
      end subroutine zpcos_sin

      subroutine zpcosh(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmcosh(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpcosh

      subroutine zpcosh_sinh(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma
      intent (inout) :: mb, mc
      call zpchsh(ma, mb, mc)
      return
      end subroutine zpcosh_sinh

      subroutine zpcssn(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma
      intent (inout) :: mb, mc
      call zmunpk(ma, mpx)
      call zmcssn(mpx, mpy, mpz)
      call zmpack(mpy, mb)
      call zmpack(mpz, mc)
      return
      end subroutine zpcssn

      subroutine zpdiv(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma, mb
      intent (inout) :: mc
      call zmunpk(ma, mpx)
      call zmunpk(mb, mpy)
      call zmdiv(mpx, mpy, mpz)
      call zmpack(mpz, mc)
      return
      end subroutine zpdiv

      subroutine zpdivi(ma, integ, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      integer :: integ
      intent (in) :: ma, integ
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmdivi(mpx, integ, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpdivi

      subroutine zpeq(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call fpeq(ma(1), mb(1))
      call fpeq(ma(2), mb(2))
      return
      end subroutine zpeq

      subroutine zpequ(ma, mb, nda, ndb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      integer :: nda, ndb
      intent (in) :: ma, nda, ndb
      intent (inout) :: mb
      call fpequ(ma(1), mb(1), nda, ndb)
      call fpequ(ma(2), mb(2), nda, ndb)
      return
      end subroutine zpequ

      subroutine zpequ_r1(ma, nda, ndb)
      use fmvals
      implicit none
      type(multi) :: ma(2)
      integer :: nda, ndb
      intent (in) :: nda, ndb
      intent (inout) :: ma
      call fpequ_r1(ma(1), nda, ndb)
      call fpequ_r1(ma(2), nda, ndb)
      return
      end subroutine zpequ_r1

      subroutine zperf(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmerf(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zperf

      subroutine zperfc(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmerfc(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zperfc

      subroutine zperfc_sc(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmerfcs(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zperfc_sc

      subroutine zpexp(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmexp(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpexp

      subroutine zpfact(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmfact(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpfact

      subroutine zpform(form1, form2, ma, string)
      use fmvals
      implicit none
      type(multi) :: ma(2)
      character(*) :: form1, form2, string
      intent (in) :: ma, form1, form2
      intent (inout) :: string
      call zmunpk(ma, mpx)
      call zmform(form1, form2, mpx, string)
      return
      end subroutine zpform

      subroutine zpfprint(form1, form2, ma)
      use fmvals
      implicit none
      character(*) :: form1, form2
      type(multi) :: ma(2)
      intent (in) :: form1, form2, ma
      call zpfprt(form1, form2, ma)
      return
      end subroutine zpfprint

      subroutine zpfprt(form1, form2, ma)
      use fmvals
      implicit none
      type(multi) :: ma(2)
      character(*) :: form1, form2
      intent (in) :: ma, form1, form2
      call zmunpk(ma, mpx)
      call zmfprt(form1, form2, mpx)
      return
      end subroutine zpfprt

      subroutine zpgam(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmgam(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpgam

      subroutine zpi2m(integ, ma)
      use fmvals
      implicit none
      integer :: integ
      type(multi) :: ma(2)
      intent (in) :: integ
      intent (inout) :: ma
      call zmi2m(integ, mpx)
      call zmpack(mpx, ma)
      return
      end subroutine zpi2m

      subroutine zpimag(ma, mbfm)
      use fmvals
      implicit none
      type(multi) :: ma(2), mbfm
      intent (in) :: ma
      intent (inout) :: mbfm
      call zmunpk(ma, mpx)
      call zmimag(mpx, mpa)
      call fmpack(mpa, mbfm)
      return
      end subroutine zpimag

      subroutine zpinp(line, ma, la, lb)
      use fmvals
      implicit none
      integer :: la, lb
      character :: line(lb)
      type(multi) :: ma(2)
      intent (in) :: line, la, lb
      intent (inout) :: ma
      call zminp(line, mpx, la, lb)
      call zmpack(mpx, ma)
      return
      end subroutine zpinp

      subroutine zpint(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmint(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpint

      subroutine zpipower(ma, ival, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      call zpipwr(ma, ival, mb)
      return
      end subroutine zpipower

      subroutine zpipwr(ma, integ, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      integer :: integ
      intent (in) :: ma, integ
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmipwr(mpx, integ, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpipwr

      subroutine zplg10(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmlg10(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zplg10

      subroutine zpln(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmln(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpln

      subroutine zplngm(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmlngm(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zplngm

      subroutine zplog10(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zplg10(ma, mb)
      return
      end subroutine zplog10

      subroutine zpm2i(ma, integ)
      use fmvals
      implicit none
      type(multi) :: ma(2)
      integer :: integ
      intent (in) :: ma
      intent (inout) :: integ
      call zmunpk(ma, mpx)
      call zmm2i(mpx, integ)
      return
      end subroutine zpm2i

      subroutine zpm2z(ma, zval)
      use fmvals
      implicit none
      complex :: zval
      type(multi) :: ma(2)
      intent (in) :: ma
      intent (inout) :: zval
      call zmunpk(ma, mpx)
      call zmm2z(mpx, zval)
      return
      end subroutine zpm2z

      subroutine zpmpy(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma, mb
      intent (inout) :: mc
      call zmunpk(ma, mpx)
      call zmunpk(mb, mpy)
      call zmmpy(mpx, mpy, mpz)
      call zmpack(mpz, mc)
      return
      end subroutine zpmpy

      subroutine zpmpyi(ma, integ, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      integer :: integ
      intent (in) :: ma, integ
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmmpyi(mpx, integ, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpmpyi

      subroutine zpnint(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmnint(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpnint

      subroutine zpout(ma, line, lb, last1, last2)
      use fmvals
      implicit none
      type(multi) :: ma(2)
      integer :: lb, last1, last2
      character :: line(lb)
      intent (in) :: ma, lb
      intent (inout) :: line, last1, last2
      call zmunpk(ma, mpx)
      call zmout(mpx, line, lb, last1, last2)
      return
      end subroutine zpout

      subroutine zppgam(n, ma, mb)
      use fmvals
      implicit none
      integer :: n
      type(multi) :: ma(2), mb(2)
      intent (in) :: n, ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmpgam(n, mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zppgam

      subroutine zppower(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma, mb
      intent (inout) :: mc
      call zppwr(ma, mb, mc)
      return
      end subroutine zppower

      subroutine zpprint(ma)
      use fmvals
      implicit none
      type(multi) :: ma(2)
      intent (in) :: ma
      call zpprnt(ma)
      return
      end subroutine zpprint

      subroutine zpprnt(ma)
      use fmvals
      implicit none
      type(multi) :: ma(2)
      intent (in) :: ma
      call zmunpk(ma, mpx)
      call zmprnt(mpx)
      return
      end subroutine zpprnt

      subroutine zppsi(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmpsi(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zppsi

      subroutine zppwr(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma, mb
      intent (inout) :: mc
      call zmunpk(ma, mpx)
      call zmunpk(mb, mpy)
      call zmpwr(mpx, mpy, mpz)
      call zmpack(mpz, mc)
      return
      end subroutine zppwr

      subroutine zprational_power(ma, ival, jval, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      integer :: ival, jval
      intent (in) :: ma, ival, jval
      intent (inout) :: mb
      call zprpwr(ma, ival, jval, mb)
      return
      end subroutine zprational_power

      subroutine zpread(kread, ma)
      use fmvals
      implicit none
      integer :: kread
      type(multi) :: ma(2)
      intent (in) :: kread
      intent (inout) :: ma
      call zmread(kread, mpx)
      call zmpack(mpx, ma)
      return
      end subroutine zpread

      subroutine zpreal(ma, mbfm)
      use fmvals
      implicit none
      type(multi) :: ma(2), mbfm
      intent (in) :: ma
      intent (inout) :: mbfm
      call zmunpk(ma, mpx)
      call zmreal(mpx, mpa)
      call fmpack(mpa, mbfm)
      return
      end subroutine zpreal

      subroutine zprpwr(ma, ival, jval, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      integer :: ival, jval
      intent (in) :: ma, ival, jval
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmrpwr(mpx, ival, jval, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zprpwr

      subroutine zpset(nprec)
      use fmvals
      implicit none
      integer :: nprec
      intent (in) :: nprec
      call zmset(nprec)
      return
      end subroutine zpset

      subroutine zpsin(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmsin(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpsin

      subroutine zpsinh(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmsinh(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpsinh

      subroutine zpsqr(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmsqr(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpsqr

      subroutine zpsqrt(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmsqrt(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zpsqrt

      subroutine zpst2m(string, ma)
      use fmvals
      implicit none
      character(*) :: string
      type(multi) :: ma(2)
      intent (in) :: string
      intent (inout) :: ma
      call zmst2m(string, mpx)
      call zmpack(mpx, ma)
      return
      end subroutine zpst2m

      subroutine zpsub(ma, mb, mc)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2), mc(2)
      intent (in) :: ma, mb
      intent (inout) :: mc
      call zmunpk(ma, mpx)
      call zmunpk(mb, mpy)
      call zmsub(mpx, mpy, mpz)
      call zmpack(mpz, mc)
      return
      end subroutine zpsub

      subroutine zptan(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmtan(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zptan

      subroutine zptanh(ma, mb)
      use fmvals
      implicit none
      type(multi) :: ma(2), mb(2)
      intent (in) :: ma
      intent (inout) :: mb
      call zmunpk(ma, mpx)
      call zmtanh(mpx, mpy)
      call zmpack(mpy, mb)
      return
      end subroutine zptanh

      subroutine zpwrit(kwrite, ma)
      use fmvals
      implicit none
      integer :: kwrite
      type(multi) :: ma(2)
      intent (in) :: ma, kwrite
      call zmunpk(ma, mpx)
      call zmwrit(kwrite, mpx)
      return
      end subroutine zpwrit

      subroutine zpwrite(kwrite, ma)
      use fmvals
      implicit none
      integer :: kwrite
      type(multi) :: ma(2)
      intent (in) :: kwrite, ma
      call zpwrit(kwrite, ma)
      return
      end subroutine zpwrite

      subroutine zpz2m(zval, ma)
      use fmvals
      implicit none
      complex :: zval
      type(multi) :: ma(2)
      intent (in) :: zval
      intent (inout) :: ma
      call zmz2m(zval, mpx)
      call zmpack(mpx, ma)
      return
      end subroutine zpz2m
