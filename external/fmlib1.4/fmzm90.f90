
 module fmzm_1
      use fmvals, only : multi, fm, im, zm


!  FMZM 1.4                        David M. Smith

!  This module extends the definition of the basic Fortran arithmetic and function operations so
!  they also apply to multiple precision numbers, using version 1.4 of FM.
!  There are three multiple precision data types:
!     FM  (multiple precision real)
!     IM  (multiple precision integer)
!     ZM  (multiple precision complex)

!  For some examples and general advice about using these multiple-precision data types, see the
!  program SampleFM.f95.

!  Most of the functions defined in this module are multiple precision versions of standard Fortran
!  functions.  In addition, there are functions for direct conversion, formatting, and some
!  mathematical special functions.

!  to_fm is a function for converting other types of numbers to type FM.  Note that to_fm(3.12)
!  converts the real constant to FM, but it is accurate only to single precision, since the number
!  3.12 cannot be represented exactly in binary and has already been rounded to single precision.
!  Similarly, to_fm(3.12d0) agrees with 3.12 to double precision accuracy, and to_fm('3.12') or
!  to_fm(312)/to_fm(100) agrees to full FM accuracy.

!  to_im converts to type IM, and to_zm converts to type ZM.

!  Functions are also supplied for converting the three multiple precision types to the other
!  numeric data types:
!     to_int   converts to machine precision integer
!     to_sp    converts to single precision
!     to_dp    converts to double precision
!     to_spz   converts to single precision complex
!     to_dpz   converts to double precision complex

!  WARNING:   When multiple precision type declarations are inserted in an existing program, take
!             care in converting functions like dble(x), where x has been declared as a multiple
!             precision type.  If x was single precision in the original program, then replacing
!             the dble(x) by to_dp(x) in the new version could lose accuracy. For this reason, the
!             Fortran type-conversion functions defined in this module assume that results should
!             be multiple precision whenever inputs are.  Examples:
!             dble(to_fm('1.23e+123456'))         is type FM
!             real(to_fm('1.23e+123456'))         is type FM
!             real(to_zm('3.12+4.56i'))           is type FM   = to_fm('3.12')
!             int(to_fm('1.23'))                  is type IM   = to_im(1)
!             int(to_im('1e+23'))                 is type IM
!             cmplx(to_fm('1.23'),to_fm('4.56'))  is type ZM

!  is_overflow, is_underflow, and is_unknown are logical functions for checking whether a multiple
!  precision number is in one of the exception categories.  Testing to see if a type FM number is
!  in the +overflow category by directly using an if can be tricky.  When mafm is +overflow, the
!  statement
!             if (mafm == to_fm(' +overflow ')) then
!  will return false, since the comparison routine cannot be sure that two different overflowed
!  results would have been equal if the overflow threshold had been higher.  Instead, use
!             if (is_overflow(mafm)) then
!  which will be true if mafm is + or - overflow.

!  Programs using this module may sometimes need to call fm, im, or zm routines directly.  This
!  is normally the case when routines are needed that are not Fortran intrinsics, such as the
!  formatting subroutine fm_form.  In a program using this module, suppose mafm has been declared
!  with type (fm) :: mafm.  To convert the number to a character string with f65.60 format, use
!     call fm_form('f65.60',mafm,st1)

!  WARNING:   To be safe, all multiple precision variables in a user's program should be declared
!             as type (fm), (im), or (zm), and any direct calls to subroutines should be the kind
!             with the underscore.  To compute pi, use
!                 call fm_pi(pi)
!             Calling the low-level routine in fm.f95 ( call fmpi(pi%mfm) ) is not recommended.

!  In subroutine or function subprograms all multiple precision variables that are local to that
!  routine should be declared with the save attribute.  It is not an error to omit save, but if
!  the compiler creates new copies of the variables for each call to the routine, then the program
!  could leak memory.

!  Type (fm), (im), or (zm) variables cannot have their multiple precision values initialized in
!  the declaration statement, as can ordinary variables.  If the original program had
!      double precision :: x = 2.3d0
!  then the corresponding FM version would have
!      type (fm), save :: x
!      ... (other declarations) ...
!      x = to_fm( '2.3' )
!
!  An attempt to use a multiple precision variable that has not been defined will be detected by
!  the routines in this module and an error message printed.
!
!  For each of the operations =,  == ,  /= ,  < ,  <= ,  > ,  >= , +, -, *, /, and **, the interface
!  module defines all mixed mode variations involving one of the three multiple precision derived
!  types and another argument having one of the types: { integer, real, double, complex, complex
!  double, fm, im, zm }.  So mixed mode expressions such as
!        mafm = 12
!        mafm = mafm + 1
!        if (abs(mafm) > 1.0d-23) then
!  are handled correctly.

!  Not all the named functions are defined for all three multiple precision derived types, so the
!  list below shows which can be used.  The labels "real", "integer", and "complex" refer to types
!  fm, im, and zm respectively, "string" means the function accepts character strings (e.g.,
!  to_fm('3.45')), and "other" means the function can accept any of the machine precision data
!  types integer, real, double, complex, or complex double.  For functions that accept two or more
!  arguments, like atan2 or max, all the arguments must be of the same type.

!  Note that to_zm also has a 2-argument form:  to_zm(2,3) for getting 2 + 3*i.
!  cmplx can be used for that, as in cmplx( to_fm(2) , to_fm(3) ), but the 2-argument form is
!  more concise.  The 2-argument form is available for machine precision integer, single and
!  double precision real pairs.  For others, such as x and y being type(fm), just use cmplx(x,y).

!  Fortran's 2-argument version of atan(x,y) is also provided.  It is the same as the older atan2.
!  Functions in this list that are not provided by standard Fortran, such as special functions,
!  have more information about their arguments farther down.


!  AVAILABLE FUNCTIONS:

!     =
!     +
!     -
!     *
!     /
!     **
!     ==
!     /=
!     <
!     <=
!     >
!     >=
!     abs                  real    integer    complex
!     acos                 real               complex
!     acosh                real               complex
!     aimag                                   complex
!     aint                 real               complex
!     anint                real               complex
!     arg                                     complex
!     asin                 real               complex
!     asinh                real               complex
!     atan                 real               complex
!     atan2                real
!     atanh                real               complex
!     bernoulli            real
!     bessel_j             real
!     bessel_y             real
!     beta                 real
!     binomial             real    integer    complex
!     btest                        integer
!     ceiling              real    integer    complex
!     cmplx                real    integer
!     conjg                                   complex
!     cos                  real               complex
!     cosh                 real               complex
!     cos_integral         real
!     cosh_integral        real
!     dble                 real    integer    complex
!     digits               real    integer    complex
!     dim                  real    integer
!     dint                 real               complex
!     epsilon              real
!     erf                  real               complex
!     erfc                 real               complex
!     erfc_scaled          real               complex
!     exp                  real               complex
!     exponent             real
!     exp_integral_ei      real
!     exp_integral_en      real
!     factorial            real    integer    complex
!     floor                real    integer    complex
!     fraction             real               complex
!     fresnel_c            real
!     fresnel_s            real
!     gamma                real               complex
!     gcd                          integer
!     huge                 real    integer    complex
!     hypot                real
!     incomplete_beta      real
!     incomplete_gamma1    real
!     incomplete_gamma2    real
!     int                  real    integer    complex
!     log                  real               complex
!     log10                real               complex
!     log_erfc             real
!     log_gamma            real               complex
!     log_integral         real
!     max                  real    integer
!     maxexponent          real
!     min                  real    integer
!     minexponent          real
!     mod                  real    integer
!     modulo               real    integer
!     multiply_mod                 integer
!     nearest              real
!     nint                 real    integer    complex
!     norm2                real
!     pochhammer           real
!     polygamma            real               complex
!     power_mod                    integer
!     precision            real               complex
!     psi                  real               complex
!     radix                real    integer    complex
!     range                real    integer    complex
!     real                 real    integer    complex
!     rrspacing            real
!     scale                real               complex
!     setexponent          real
!     sign                 real    integer
!     sin                  real               complex
!     sinh                 real               complex
!     sin_integral         real
!     sinh_integral        real
!     spacing              real
!     sqrt                 real               complex
!     tan                  real               complex
!     tanh                 real               complex
!     tiny                 real    integer    complex
!     to_fm                real    integer    complex    string    other
!     to_im                real    integer    complex    string    other
!     to_zm                real    integer    complex    string    other
!     to_int               real    integer    complex
!     to_sp                real    integer    complex
!     to_dp                real    integer    complex
!     to_spz               real    integer    complex
!     to_dpz               real    integer    complex
!     is_overflow          real    integer    complex
!     is_underflow         real    integer    complex
!     is_unknown           real    integer    complex


!  SUBROUTINES THAT DO NOT CORRESPOND TO ANY FUNCTION ABOVE:

!  1. Type (fm).  ma, mb, mc refer to type (fm) numbers.

!     fm_cosh_sinh(ma,mb,mc)     mb = cosh(ma),  mc = sinh(ma)
!                                Faster than making two separate calls.

!     fm_cos_sin(ma,mb,mc)       mb = cos(ma),  mc = sin(ma)
!                                Faster than making two separate calls.

!     fm_euler(ma)               ma = Euler's constant ( 0.5772156649... )

!     fm_flag(k)                 k = kflag  get the value of the FM condition flag -- stored in
!                                           the internal FM variable kflag in module fmvals.

!     fm_form(form,ma,string)    ma is converted to a character string using format form and
!                                   returned in string.  form can represent i, f, e, or es formats.
!                                   Example:
!                                   call fmform('f60.40',ma,string)

!     fm_fprint(form,ma)         Print ma on unit kw using form format.

!     fm_pi(ma)                  ma = pi

!     fm_print(ma)               Print ma on unit kw using current format.

!     fm_random_number(x)        x is returned as a double precision random number, uniformly
!                                distributed on the open interval (0,1).  It is a high-quality,
!                                long-period generator based on 49-digit prime numbers.
!                                Note that x is double precision, unlike the similar Fortran
!                                intrinsic random number routine, which can return a single
!                                or double precision result.
!                                A default initial seed is used if fm_random_number is called
!                                without calling fm_random_seed_put first.

!     fm_random_seed_get(seed)   returns the seven integers seed(1) through seed(7) as the current
!                                seed for the fm_random_number generator.

!     fm_random_seed_put(seed)   initializes the fm_random_number generator using the seven integers
!                                seed(1) through seed(7). These get and put functions are slower
!                                than fm_random_number, so fm_random_number should be called many
!                                times between fm_random_seed_put calls.  Also, some generators that
!                                used a 9-digit modulus have failed randomness tests when used with
!                                only a few numbers being generated between calls to re-start with
!                                a new seed.

!     fm_random_seed_size(size)  returns integer size as the size of the seed array used by the
!                                fm_random_number generator.  Currently, size = 7.

!     fm_rational_power(ma,k,j,mb)
!                                mb = ma**(k/j)  Rational power.
!                                Faster than mb = ma**(to_fm(k)/j) for functions like the cube root.

!     fm_read(kread,ma)          ma is returned after reading one (possibly multi-line) FM number
!                                   on unit kread.  This routine reads numbers written by fm_write.

!     fm_set(nprec)              Set the internal FM variables so that the precision is at least
!                                nprec base 10 digits plus three base 10 guard digits.

!     fm_setvar(string)          Define a new value for one of the internal FM variables in module
!                                fmvals that controls one of the FM options.  string has the form
!                                      variable = value.
!                                Example:  To change the screen width for FM output:
!                                      call fm_setvar(' kswide = 120 ')
!                                The variables that can be changed and the options they control are
!                                listed in sections 2 through 6 of the comments at the top of the
!                                fm.f95 file.  Only one variable can be set per call.  The variable
!                                name in string must have no embedded blanks.  The value part of
!                                string can be in any numerical format, except in the case of
!                                variable cmchar, which is character type.  To set cmchar to 'e',
!                                don't use any quotes in string:
!                                      call fm_setvar(' cmchar = e ')

!     fm_ulp(ma,mb)              mb = One Unit in the Last Place of ma.  For positive ma this is the
!                                     same as the Fortran function spacing, but mb < 0 if ma < 0.
!                                     Examples:  If mbase = 10 and ndig = 30, then ulp(1.0) =
!                                                1.0e-29,  ulp(-4.5e+67) = -1.0e+38.
!

!     fm_vars                    Write the current values of the internal FM variables on unit kw.

!     fm_write(kwrite,ma)        Write ma on unit kwrite.
!                                Multi-line numbers will have '&' as the last nonblank character
!                                on all but the last line.  These numbers can then be read easily
!                                using fm_read.


!  2. Type (im).    ma, mb, mc refer to type (im) numbers.

!     im_divr(ma,mb,mc,md)       mc = int(ma/mb),   md = ma mod mb
!                                     When both the quotient and remainder are needed, this routine
!                                     is twice as fast as doing mc = ma/mb and md = mod(ma,mb)
!                                     separately.

!     im_dvir(ma,ival,mb,irem)   mb = int(ma/ival),   irem = ma mod ival
!                                ival and irem are one word integers.  Faster than doing separately.

!     im_form(form,ma,string)    ma is converted to a character string using format form and
!                                   returned in string.  form can represent i, f, e, or es formats.
!                                   Example: call imform('i70',ma,string)

!     im_fprint(form,ma)         Print ma on unit kw using form format.

!     im_print(ma)               Print ma on unit kw.

!     im_read(kread,ma)          ma is returned after reading one (possibly multi-line) IM number
!                                   on unit kread.  This routine reads numbers written by im_write.

!     im_write(kwrite,ma)        Write ma on unit kwrite.  Multi-line numbers will have '&' as the
!                                last nonblank character on all but the last line.
!                                These numbers can then be read easily using im_read.


!  3. Type (zm).    ma, mb, mc refer to type (zm) numbers.  mbfm is type (fm).

!     zm_arg(ma,mbfm)            mbfm = complex argument of ma.  mbfm is the (real) angle in the
!                                       interval ( -pi , pi ] from the positive real axis to the
!                                       point (x,y) when ma = x + y*i.

!     zm_cosh_sinh(ma,mb,mc)     mb = cosh(ma),  mc = sinh(ma).
!                                     Faster than 2 calls.

!     zm_cos_sin(ma,mb,mc)       mb = cos(ma),  mc = sin(ma).
!                                     Faster than 2 calls.

!     zm_form(form1,form2,ma,string)
!                                string = ma
!                                ma is converted to a character string using format form1 for the
!                                real part and form2 for the imaginary part.  The result is returned
!                                in string.  form1 and form2 can represent i, f, e, or es formats.
!                                Example:
!                                      call zmform('f20.10', 'f15.10',ma,string)

!     zm_fprint(form1,form2,ma)  Print ma on unit kw using formats form1 and form2.

!     zm_print(ma)               Print ma on unit kw using current format.

!     zm_read(kread,ma)          ma is returned after reading one (possibly multi-line) ZM number
!                                   on unit kread.  This routine reads numbers written by zmwrite.

!     zm_rational_power(ma,ival,jval,mb)
!                                mb = ma ** (ival/jval)
!                                Faster than mb = ma**(to_fm(k)/j) for functions like the cube root.

!     zm_write(kwrite,ma)        Write ma on unit kwrite.  Multi-line numbers are formatted for
!                                automatic reading with zmread.


!  Some other functions are defined that do not correspond to machine precision intrinsic
!  functions. These include formatting functions, integer modular functions and gcd, and some
!  mathematical special functions.
!  n, k below are machine precision integers, j1, j2, j3 are type (im), fmt, fmtr, fmti are
!  character strings, a, b, x are type (fm), and z is type (zm).
!  The three formatting functions return a character string containing the formatted number, the
!  three type (im) functions return a type (im) result, and the 12 special functions return
!  type (fm) results.

!  Formatting functions:

!     fm_format(fmt,a)        Put a into fmt (real) format
!     im_format(fmt,j1)       Put j1 into fmt (integer) format
!     zm_format(fmtr,fmti,z)  Put z into (complex) format, fmtr for the real
!                             part and fmti for the imaginary part

!     Examples:
!        st = fm_format('f65.60',a)
!        write (*,*) ' a = ',trim(st)
!        st = fm_format('e75.60',b)
!        write (*,*) ' b = ',st(1:75)
!        st = im_format('i50',j1)
!        write (*,*) ' j1 = ',st(1:50)
!        st = zm_format('f35.30', 'f30.25',z)
!        write (*,*) ' z = ',st(1:70)

!     These functions are used for one-line output.  The returned character strings are of
!     length 200.

!     For higher precision numbers, the output can be broken onto multiple lines automatically by
!     calling subroutines fm_print, im_print, zm_print, or the line breaks can be done by hand after
!     calling one of the subroutines fm_form, im_form, zm_form.

!     For zm_format the length of the output is 5 more than the sum of the two field widths.

!  Integer functions:

!     binomial(n,k)           Binomial coefficient n choose k.  Returns the exact result as a
!                                  type IM value.
!     binomial(j1,j2)         Binomial coefficient j1 choose j2.  Like factorial below, the result
!                                  might be too large unless min(j2,j1-j2) is fairly small,
!     factorial(n)            n!   Returns the exact result as a type IM value.
!     factorial(j1)           j1!  Note that the factorial function grows so rapidly that if type IM
!                                  variable j1 is larger than the largest machine precision integer,
!                                  then j1! has over 10 billion digits and the calculation would
!                                  likely fail due to memory or time constraints.  This version is
!                                  provided for convenience, and will return unknown if j1 cannot
!                                  be represented as a machine precision integer.
!     gcd(j1,j2)              Greatest Common Divisor of j1 and j2.
!     multiply_mod(j1,j2,j3)  j1 * j2 mod j3
!     power_mod(j1,j2,j3)     j1 ** j2 mod j3

!  Special functions:

!     bernoulli(n)            Nth Bernoulli number
!     bessel_j(n,x)           Bessel function of the first kind J_n(x)
!     bessel_j0(x)            Fortran-08 name for j_0(x)
!     bessel_j1(x)            Fortran-08 name for j_1(x)
!     bessel_jn(n,x)          Fortran-08 name for J_n(x)
!     bessel_jn(n1,n2,x)      Returns array (/ J_n1(x) , ... , J_n2(x) /)
!     bessel_y(n,x)           Bessel function of the second kind Y_n(x)
!     bessel_y0(x)            Fortran-08 name for y_0(x)
!     bessel_y1(x)            Fortran-08 name for y_1(x)
!     bessel_yn(n,x)          Fortran-08 name for Y_n(x)
!     bessel_yn(n1,n2,x)      Returns array (/ Y_n1(x) , ... , Y_n2(x) /)
!     beta(a,b)               Integral (0 to 1)  t**(a-1) * (1-t)**(b-1)  dt
!     binomial(a,b)           Binomial Coefficient  a! / ( b! (a-b)! )
!     cos_integral(x)         Cosine Integral Ci(x)
!     cosh_integral(x)        Hyperbolic Cosine Integral Chi(x)
!     erf(x)                  Error function Erf(x)
!     erfc(x)                 Complimentary error function Erfc(x)
!     erfc_scaled(x)          Exp(x^2) * Erfc(x)
!     exp_integral_ei(x)      Exponential Integral Ei(x)
!     exp_integral_en(n,x)    Exponential Integral E_n(x)
!     factorial(x)            x!   = Gamma(x+1)
!     fresnel_c(x)            Fresnel Cosine Integral c(x)
!     fresnel_s(x)            Fresnel Sine Integral s(x)
!     gamma(x)                Integral (0 to infinity)  t**(x-1) * exp(-t)  dt
!     incomplete_beta(x,a,b)  Integral (0 to x)  t**(a-1) * (1-t)**(b-1)  dt
!     incomplete_gamma1(a,x)  Integral (0 to x)  t**(a-1) * exp(-t)  dt
!     incomplete_gamma2(a,x)  Integral (x to infinity)  t**(a-1) * exp(-t)  dt
!     log_erfc(x)             Ln( Erfc(x) )
!     log_gamma(x)            Analytic continuation of real Ln( Gamma(x) ).  May differ from complex
!                             Ln( Gamma(x) ) by an integer multiple of 2*pi*i.
!     log_integral(x)         Logarithmic Integral Li(x)
!     pochhammer(x,n)         x*(x+1)*(x+2)*...*(x+n-1)
!     polygamma(n,x)          Nth derivative of Psi(x)
!     psi(x)                  Derivative of Ln(Gamma(x))
!     sin_integral(x)         Sine Integral Si(x)
!     sinh_integral(x)        Hyperbolic Sine Integral Shi(x)


!  Array operations:

!  Arithmetic operations and functions on arrays of dimension (rank) one or two are supported for
!  each of the three multiple-precision types.  Binary operations (+-*/) require both arguments to
!  have the same rank and shape.

!     Examples:
!        type (fm), save, dimension(10)  :: a, b
!        type (fm), save, dimension(3,3) :: c
!        type (im), save, dimension(10)  :: j, k
!        type (im), save, dimension(3,3) :: l
!        ...
!        a = 0                           ! Set the whole array to zero
!        j = j * k                       ! Set j(i) = j(i) * k(i) for i = 1, ..., 10
!        b = a - k                       ! Mixed-mode operations are ok
!        c = 7.3d0 * c - ( c + 2*l )/3

!     Array functions:

!        dot_product(x,y)     Dot product of rank 1 vectors of the same type.
!                             Note that when x and y are complex, the result is not just the sum
!                             of the products of the corresponding array elements, as it is for
!                             types FM and IM.  For ZM the formula is the sum of
!                             conjg(x(j)) * y(j).
!        is_overflow(x)       Returns true if any element is + or - overflow.
!        is_underflow(x)      Returns true if any element is + or - underflow.
!        is_unknown(x)        Returns true if any element is unknown.
!        matmul(x,y)          Matrix multiplication of arrays of the same type
!                             Cases for valid argument shapes:
!                             (1)  (n,m) * (m,k) --> (n,k)
!                             (2)    (m) * (m,k) --> (k)
!                             (3)  (n,m) * (m)   --> (n)
!        maxloc(x)            Location of the maximum value in the array
!        maxval(x)            Maximum value in the array
!        minloc(x)            Location of the minimum value in the array
!        minval(x)            Minimum value in the array
!        product(x)           Product of all values in the array
!        sum(x)               Sum of all values in the array
!        transpose(x)         Matrix transposition.  If x is a rank 2 array with shape (n,m), then
!                             y = transpose(x) has shape (m,n) with y(i,j) = x(j,i).
!        to_fm(x)             Rank 1 or 2 arrays are converted to similar type (fm) arrays.
!        to_im(x)             Rank 1 or 2 arrays are converted to similar type (im) arrays.
!        to_zm(x)             Rank 1 or 2 arrays are converted to similar type (zm) arrays.
!        to_int(x)            Rank 1 or 2 arrays are converted to similar integer arrays.
!        to_sp(x)             Rank 1 or 2 arrays are converted to similar single precision arrays.
!        to_dp(x)             Rank 1 or 2 arrays are converted to similar double precision arrays.
!        to_spz(x)            Rank 1 or 2 arrays are converted to similar single complex arrays.
!        to_dpz(x)            Rank 1 or 2 arrays are converted to similar double complex arrays.

!     The arithmetic array functions dot_product, matmul, product, and sum work like the other
!     functions in the FM package in that they raise precision and compute the sums and/or products
!     at the higher precision, then round the final result back to the user's precision to provide
!     a more accurate result.

!     Fortran's optional [,mask] argument for these functions is not provided.

!     Many of the 1-argument functions can be used with array arguments, with the result being an
!     array of the same size and shape where the function has been applied to each element.

!     Examples:
!        type (fm), save, dimension(10) :: a, b, c
!        ...
!        a = abs(b)                ! Set a(i) = abs(b(i)) for i = 1, ..., 10
!        c = sqrt(a+4+b*b)         ! Set c(i) = sqrt(a(i)+4+b(i)*b(i)) for i = 1, ..., 10

!     Functions that can have array arguments.  As above, "real", "integer", and "complex" refer
!     to types FM, IM, and ZM respectively.

!     abs              real    integer    complex
!     acos             real               complex
!     acosh            real               complex
!     aimag                               complex
!     aint             real               complex
!     anint            real               complex
!     arg                                 complex
!     asin             real               complex
!     asinh            real               complex
!     atan             real               complex
!     atanh            real               complex
!     ceiling          real    integer    complex
!     conjg                               complex
!     cos              real               complex
!     cosh             real               complex
!     exp              real               complex
!     floor            real    integer    complex
!     fraction         real               complex
!     int              real    integer    complex
!     log              real               complex
!     log10            real               complex
!     nint             real    integer    complex
!     sin              real               complex
!     sinh             real               complex
!     sqrt             real               complex
!     tan              real               complex
!     tanh             real               complex
!     cos_integral     real
!     cosh_integral    real
!     erf              real               complex
!     erfc             real               complex
!     erfc_scaled      real               complex
!     exp_integral_ei  real
!     factorial        real    integer    complex    machine-precision integer
!     fresnel_c        real
!     fresnel_s        real
!     gamma            real               complex
!     log_erfc         real
!     log_gamma        real               complex
!     log_integral     real
!     psi              real               complex
!     sin_integral     real
!     sinh_integral    real


   interface to_fm
      module procedure fm_i
      module procedure fm_r
      module procedure fm_d
      module procedure fm_z
      module procedure fm_zd
      module procedure fm_fm
      module procedure fm_im
      module procedure fm_zm
      module procedure fm_st
      module procedure fm_i1
      module procedure fm_r1
      module procedure fm_d1
      module procedure fm_z1
      module procedure fm_zd1
      module procedure fm_fm1
      module procedure fm_im1
      module procedure fm_zm1
      module procedure fm_st1
      module procedure fm_i2
      module procedure fm_r2
      module procedure fm_d2
      module procedure fm_z2
      module procedure fm_zd2
      module procedure fm_fm2
      module procedure fm_im2
      module procedure fm_zm2
      module procedure fm_st2
   end interface

   interface to_im
      module procedure im_i
      module procedure im_r
      module procedure im_d
      module procedure im_z
      module procedure im_c
      module procedure im_fm
      module procedure im_im
      module procedure im_zm
      module procedure im_st
      module procedure im_i1
      module procedure im_r1
      module procedure im_d1
      module procedure im_z1
      module procedure im_c1
      module procedure im_fm1
      module procedure im_im1
      module procedure im_zm1
      module procedure im_st1
      module procedure im_i2
      module procedure im_r2
      module procedure im_d2
      module procedure im_z2
      module procedure im_c2
      module procedure im_fm2
      module procedure im_im2
      module procedure im_zm2
      module procedure im_st2
   end interface

   interface to_zm
      module procedure zm_i
      module procedure zm2_i
      module procedure zm_r
      module procedure zm2_r
      module procedure zm_d
      module procedure zm2_d
      module procedure zm_z
      module procedure zm_c
      module procedure zm_fm
      module procedure zm_im
      module procedure zm_zm
      module procedure zm_st
      module procedure zm_i1
      module procedure zm_r1
      module procedure zm_d1
      module procedure zm_z1
      module procedure zm_c1
      module procedure zm_fm1
      module procedure zm_im1
      module procedure zm_zm1
      module procedure zm_st1
      module procedure zm_i2
      module procedure zm_r2
      module procedure zm_d2
      module procedure zm_z2
      module procedure zm_c2
      module procedure zm_fm2
      module procedure zm_im2
      module procedure zm_zm2
      module procedure zm_st2
   end interface

   interface to_int
      module procedure fm_2int
      module procedure im_2int
      module procedure zm_2int
      module procedure fm_2int1
      module procedure im_2int1
      module procedure zm_2int1
      module procedure fm_2int2
      module procedure im_2int2
      module procedure zm_2int2
   end interface

   interface to_sp
      module procedure fm_2sp
      module procedure im_2sp
      module procedure zm_2sp
      module procedure fm_2sp1
      module procedure im_2sp1
      module procedure zm_2sp1
      module procedure fm_2sp2
      module procedure im_2sp2
      module procedure zm_2sp2
   end interface

   interface to_dp
      module procedure fm_2dp
      module procedure im_2dp
      module procedure zm_2dp
      module procedure fm_2dp1
      module procedure im_2dp1
      module procedure zm_2dp1
      module procedure fm_2dp2
      module procedure im_2dp2
      module procedure zm_2dp2
   end interface

   interface to_spz
      module procedure fm_2spz
      module procedure im_2spz
      module procedure zm_2spz
      module procedure fm_2spz1
      module procedure im_2spz1
      module procedure zm_2spz1
      module procedure fm_2spz2
      module procedure im_2spz2
      module procedure zm_2spz2
   end interface

   interface to_dpz
      module procedure fm_2dpz
      module procedure im_2dpz
      module procedure zm_2dpz
      module procedure fm_2dpz1
      module procedure im_2dpz1
      module procedure zm_2dpz1
      module procedure fm_2dpz2
      module procedure im_2dpz2
      module procedure zm_2dpz2
   end interface

   interface is_overflow
      module procedure fm_is_overflow
      module procedure im_is_overflow
      module procedure zm_is_overflow
      module procedure fm_is_overflow1
      module procedure im_is_overflow1
      module procedure zm_is_overflow1
      module procedure fm_is_overflow2
      module procedure im_is_overflow2
      module procedure zm_is_overflow2
   end interface

   interface is_underflow
      module procedure fm_is_underflow
      module procedure im_is_underflow
      module procedure zm_is_underflow
      module procedure fm_is_underflow1
      module procedure im_is_underflow1
      module procedure zm_is_underflow1
      module procedure fm_is_underflow2
      module procedure im_is_underflow2
      module procedure zm_is_underflow2
   end interface

   interface is_unknown
      module procedure fm_is_unknown
      module procedure im_is_unknown
      module procedure zm_is_unknown
      module procedure fm_is_unknown1
      module procedure im_is_unknown1
      module procedure zm_is_unknown1
      module procedure fm_is_unknown2
      module procedure im_is_unknown2
      module procedure zm_is_unknown2
   end interface

   interface fm_undef_inp
      module procedure fm_undef_inp_fm0
      module procedure fm_undef_inp_im0
      module procedure fm_undef_inp_zm0
      module procedure fm_undef_inp_fm1
      module procedure fm_undef_inp_im1
      module procedure fm_undef_inp_zm1
      module procedure fm_undef_inp_fm2
      module procedure fm_undef_inp_im2
      module procedure fm_undef_inp_zm2
   end interface

!  The next function is no longer needed in version 1.4.
!  Dummy versions of the individual procedures are included for compatibility with version 1.3.

   interface fm_deallocate
      module procedure fm_deallocate_fm1
      module procedure fm_deallocate_im1
      module procedure fm_deallocate_zm1
      module procedure fm_deallocate_fm2
      module procedure fm_deallocate_im2
      module procedure fm_deallocate_zm2
   end interface


 contains

!                                                               to_fm

   function fm_i(ival)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      integer :: ival
      intent (in) :: ival
      call fmi2m(ival, return_value%mfm)
   end function fm_i

   function fm_r(r)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      real :: r
      intent (in) :: r
      call fmsp2m(r, return_value%mfm)
   end function fm_r

   function fm_d(d)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      double precision :: d
      intent (in) :: d
      call fmdp2m(d, return_value%mfm)
   end function fm_d

   function fm_z(z)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      complex :: z
      intent (in) :: z
      call fmsp2m(real(z), return_value%mfm)
   end function fm_z

   function fm_zd(c)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: c
      call fmdp2m(real(c, kind(0.0d0)), return_value%mfm)
   end function fm_zd

   function fm_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value, ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmeq(ma%mfm, return_value%mfm)
   end function fm_fm

   function fm_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, return_value%mfm)
   end function fm_im

   function fm_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (zm) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmreal(ma%mzm, return_value%mfm)
   end function fm_zm

   function fm_st(st)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      character(*) :: st
      intent (in) :: st
      call fmst2m(st, return_value%mfm)
   end function fm_st

   function fm_i1(ival)     result (return_value)
      use fmvals
      implicit none
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ival
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), return_value(j)%mfm)
      enddo
   end function fm_i1

   function fm_r1(r)     result (return_value)
      use fmvals
      implicit none
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: r
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), return_value(j)%mfm)
      enddo
   end function fm_r1

   function fm_d1(d)     result (return_value)
      use fmvals
      implicit none
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: d
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), return_value(j)%mfm)
      enddo
   end function fm_d1

   function fm_z1(z)     result (return_value)
      use fmvals
      implicit none
      complex, dimension(:) :: z
      type (fm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: z
      n = size(z)
      do j = 1, n
         call fmsp2m(real(z(j)), return_value(j)%mfm)
      enddo
   end function fm_z1

   function fm_zd1(c)     result (return_value)
      use fmvals
      implicit none
      complex (kind(0.0d0)), dimension(:) :: c
      type (fm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: c
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), return_value(j)%mfm)
      enddo
   end function fm_zd1

   function fm_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmeq(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fm_fm1

   function fm_im1(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, return_value(j)%mfm)
      enddo
   end function fm_im1

   function fm_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmreal(ma(j)%mzm, return_value(j)%mfm)
      enddo
   end function fm_zm1

   function fm_st1(st)     result (return_value)
      use fmvals
      implicit none
      character(*), dimension(:) :: st
      type (fm), dimension(size(st)) :: return_value
      integer :: j, n
      intent (in) :: st
      n = size(st)
      do j = 1, n
         call fmst2m(st(j), return_value(j)%mfm)
      enddo
   end function fm_st1

   function fm_i2(ival)     result (return_value)
      use fmvals
      implicit none
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ival
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call fmi2m(ival(j, k), return_value(j, k)%mfm)
         enddo
      enddo
   end function fm_i2

   function fm_r2(r)     result (return_value)
      use fmvals
      implicit none
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: r
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), return_value(j, k)%mfm)
         enddo
      enddo
   end function fm_r2

   function fm_d2(d)     result (return_value)
      use fmvals
      implicit none
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: d
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), return_value(j, k)%mfm)
         enddo
      enddo
   end function fm_d2

   function fm_z2(z)     result (return_value)
      use fmvals
      implicit none
      complex, dimension(:,:) :: z
      type (fm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: z
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call fmsp2m(real(z(j, k)), return_value(j, k)%mfm)
         enddo
      enddo
   end function fm_z2

   function fm_zd2(c)     result (return_value)
      use fmvals
      implicit none
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (fm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: c
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), return_value(j, k)%mfm)
         enddo
      enddo
   end function fm_zd2

   function fm_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fm_fm2

   function fm_im2(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, return_value(j, k)%mfm)
         enddo
      enddo
   end function fm_im2

   function fm_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmreal(ma(j, k)%mzm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fm_zm2

   function fm_st2(st)     result (return_value)
      use fmvals
      implicit none
      character(*), dimension(:,:) :: st
      type (fm), dimension(size(st, dim=1), size(st, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: st
      do j = 1, size(st, dim=1)
         do k = 1, size(st, dim=2)
            call fmst2m(st(j, k), return_value(j, k)%mfm)
         enddo
      enddo
   end function fm_st2

!                                                               to_im

   function im_i(ival)     result (return_value)
      use fmvals
      implicit none
      type (im) :: return_value
      integer :: ival
      intent (in) :: ival
      call imi2m(ival, return_value%mim)
   end function im_i

   function im_r(r)     result (return_value)
      use fmvals
      implicit none
      type (im) :: return_value
      real :: r
      character(25) :: st
      integer :: ival
      intent (in) :: r
      if (abs(r) < huge(1)) then
          ival = int(r)
          call imi2m(ival, return_value%mim)
      else
          write (st, '(E25.16)') r
          call imst2m(st, return_value%mim)
      endif
   end function im_r

   function im_d(d)     result (return_value)
      use fmvals
      implicit none
      type (im) :: return_value
      double precision :: d
      character(25) :: st
      integer :: ival
      intent (in) :: d
      if (abs(d) < huge(1)) then
          ival = int(d)
          call imi2m(ival, return_value%mim)
      else
          write (st, '(E25.16)') d
          call imst2m(st, return_value%mim)
      endif
   end function im_d

   function im_z(z)     result (return_value)
      use fmvals
      implicit none
      type (im) :: return_value
      complex :: z
      real :: r
      character(25) :: st
      integer :: ival
      intent (in) :: z
      r = real(z)
      if (abs(r) < huge(1)) then
          ival = int(r)
          call imi2m(ival, return_value%mim)
      else
          write (st, '(E25.16)') r
          call imst2m(st, return_value%mim)
      endif
   end function im_z

   function im_c(c)     result (return_value)
      use fmvals
      implicit none
      type (im) :: return_value
      complex (kind(0.0d0)) :: c
      double precision :: d
      character(25) :: st
      integer :: ival
      intent (in) :: c
      d = real(c, kind(0.0d0))
      if (abs(d) < huge(1)) then
          ival = int(d)
          call imi2m(ival, return_value%mim)
      else
          write (st, '(E25.16)') d
          call imst2m(st, return_value%mim)
      endif
   end function im_c

   function im_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: return_value
      type (fm) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imfm2i(ma%mfm, return_value%mim)
   end function im_fm

   function im_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: return_value, ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imeq(ma%mim, return_value%mim)
   end function im_im

   function im_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: return_value
      type (zm) :: ma
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call zmreal(ma%mzm, mtlvfm)
      call imfm2i(mtlvfm, return_value%mim)
   end function im_zm

   function im_st(st)     result (return_value)
      use fmvals
      implicit none
      type (im) :: return_value
      character(*) :: st
      intent (in) :: st
      call imst2m(st, return_value%mim)
   end function im_st

   function im_i1(ival)     result (return_value)
      use fmvals
      implicit none
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ival
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), return_value(j)%mim)
      enddo
   end function im_i1

   function im_r1(r)     result (return_value)
      use fmvals
      implicit none
      real, dimension(:) :: r
      type (im), dimension(size(r)) :: return_value
      character(25) :: st
      integer :: ival, j, n
      intent (in) :: r
      n = size(r)
      do j = 1, n
         if (abs(r(j)) < huge(1)) then
             ival = int(r(j))
             call imi2m(ival, return_value(j)%mim)
         else
             write (st, '(E25.16)') r(j)
             call imst2m(st, return_value(j)%mim)
         endif
      enddo
   end function im_r1

   function im_d1(d)     result (return_value)
      use fmvals
      implicit none
      double precision, dimension(:) :: d
      type (im), dimension(size(d)) :: return_value
      character(25) :: st
      integer :: ival, j, n
      intent (in) :: d
      n = size(d)
      do j = 1, n
         if (abs(d(j)) < huge(1)) then
             ival = int(d(j))
             call imi2m(ival, return_value(j)%mim)
         else
             write (st, '(E25.16)') d(j)
             call imst2m(st, return_value(j)%mim)
         endif
      enddo
   end function im_d1

   function im_z1(z)     result (return_value)
      use fmvals
      implicit none
      complex, dimension(:) :: z
      type (im), dimension(size(z)) :: return_value
      real :: r
      character(25) :: st
      integer :: ival, j, n
      intent (in) :: z
      n = size(z)
      do j = 1, n
         r = real(z(j))
         if (abs(r) < huge(1)) then
             ival = int(r)
             call imi2m(ival, return_value(j)%mim)
         else
             write (st, '(E25.16)') r
             call imst2m(st, return_value(j)%mim)
         endif
      enddo
   end function im_z1

   function im_c1(c)     result (return_value)
      use fmvals
      implicit none
      complex (kind(0.0d0)), dimension(:) :: c
      type (im), dimension(size(c)) :: return_value
      double precision :: d
      character(25) :: st
      integer :: ival, j, n
      intent (in) :: c
      n = size(c)
      do j = 1, n
         d = real(c(j), kind(0.0d0))
         if (abs(d) < huge(1)) then
             ival = int(d)
             call imi2m(ival, return_value(j)%mim)
         else
             write (st, '(E25.16)') d
             call imst2m(st, return_value(j)%mim)
         endif
      enddo
   end function im_c1

   function im_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call imfm2i(ma(j)%mfm, return_value(j)%mim)
      enddo
   end function im_fm1

   function im_im1(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call imeq(ma(j)%mim, return_value(j)%mim)
      enddo
   end function im_im1

   function im_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmreal(ma(j)%mzm, mtlvfm)
         call imfm2i(mtlvfm, return_value(j)%mim)
      enddo
   end function im_zm1

   function im_st1(st)     result (return_value)
      use fmvals
      implicit none
      character(*), dimension(:) :: st
      type (im), dimension(size(st)) :: return_value
      integer :: j, n
      intent (in) :: st
      n = size(st)
      do j = 1, n
         call imst2m(st(j), return_value(j)%mim)
      enddo
   end function im_st1

   function im_i2(ival)     result (return_value)
      use fmvals
      implicit none
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ival
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call imi2m(ival(j, k), return_value(j, k)%mim)
         enddo
      enddo
   end function im_i2

   function im_r2(r)     result (return_value)
      use fmvals
      implicit none
      real, dimension(:,:) :: r
      type (im), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      character(25) :: st
      integer :: ival, j, k
      intent (in) :: r
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            if (abs(r(j, k)) < huge(1)) then
                ival = int(r(j, k))
                call imi2m(ival, return_value(j, k)%mim)
            else
                write (st, '(E25.16)') r(j, k)
                call imst2m(st, return_value(j, k)%mim)
            endif
         enddo
      enddo
   end function im_r2

   function im_d2(d)     result (return_value)
      use fmvals
      implicit none
      double precision, dimension(:,:) :: d
      type (im), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      character(25) :: st
      integer :: ival, j, k
      intent (in) :: d
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            if (abs(d(j, k)) < huge(1)) then
                ival = int(d(j, k))
                call imi2m(ival, return_value(j, k)%mim)
            else
                write (st, '(E25.16)') d(j, k)
                call imst2m(st, return_value(j, k)%mim)
            endif
         enddo
      enddo
   end function im_d2

   function im_z2(z)     result (return_value)
      use fmvals
      implicit none
      complex, dimension(:,:) :: z
      type (im), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      real :: r
      character(25) :: st
      integer :: ival, j, k
      intent (in) :: z
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            r = real(z(j, k))
            if (abs(r) < huge(1)) then
                ival = int(r)
                call imi2m(ival, return_value(j, k)%mim)
            else
                write (st, '(E25.16)') r
                call imst2m(st, return_value(j, k)%mim)
            endif
         enddo
      enddo
   end function im_z2

   function im_c2(c)     result (return_value)
      use fmvals
      implicit none
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (im), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      double precision :: d
      character(25) :: st
      integer :: ival, j, k
      intent (in) :: c
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            d = real(c(j, k), kind(0.0d0))
            if (abs(d) < huge(1)) then
                ival = int(d)
                call imi2m(ival, return_value(j, k)%mim)
            else
                write (st, '(E25.16)') d
                call imst2m(st, return_value(j, k)%mim)
            endif
         enddo
      enddo
   end function im_c2

   function im_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imfm2i(ma(j, k)%mfm, return_value(j, k)%mim)
         enddo
      enddo
   end function im_fm2

   function im_im2(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(ma(j, k)%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function im_im2

   function im_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmreal(ma(j, k)%mzm, mtlvfm)
            call imfm2i(mtlvfm, return_value(j, k)%mim)
         enddo
      enddo
   end function im_zm2

   function im_st2(st)     result (return_value)
      use fmvals
      implicit none
      character(*), dimension(:,:) :: st
      type (im), dimension(size(st, dim=1), size(st, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: st
      do j = 1, size(st, dim=1)
         do k = 1, size(st, dim=2)
            call imst2m(st(j, k), return_value(j, k)%mim)
         enddo
      enddo
   end function im_st2

!                                                               to_zm

   function zm_i(ival)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      integer :: ival
      intent (in) :: ival
      call zmi2m(ival, return_value%mzm)
   end function zm_i

   function zm2_i(i1, i2)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      integer :: i1, i2
      intent (in) :: i1, i2
      call zm2i2m(i1, i2, return_value%mzm)
   end function zm2_i

   function zm_r(r)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      real :: r
      intent (in) :: r
      type(multi), save :: mtlvfm, mulvfm
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, return_value%mzm)
   end function zm_r

   function zm2_r(r1, r2)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      real :: r1, r2
      intent (in) :: r1, r2
      type(multi), save :: mtlvfm, mulvfm
      call fmsp2m(r1, mtlvfm)
      call fmsp2m(r2, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, return_value%mzm)
   end function zm2_r

   function zm_d(d)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      double precision :: d
      intent (in) :: d
      type(multi), save :: mtlvfm, mulvfm
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, return_value%mzm)
   end function zm_d

   function zm2_d(d1, d2)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      double precision :: d1, d2
      intent (in) :: d1, d2
      type(multi), save :: mtlvfm, mulvfm
      call fmdp2m(d1, mtlvfm)
      call fmdp2m(d2, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, return_value%mzm)
   end function zm2_d

   function zm_z(z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      complex :: z
      intent (in) :: z
      call zmz2m(z, return_value%mzm)
   end function zm_z

   function zm_c(c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: c
      type(multi), save :: mtlvfm, mulvfm
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, return_value%mzm)
   end function zm_c

   function zm_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      intent (in) :: ma
      type(multi), save :: mulvfm
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      call zmcmpx(ma%mfm, mulvfm, return_value%mzm)
   end function zm_fm

   function zm_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      intent (in) :: ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, return_value%mzm)
   end function zm_im

   function zm_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value, ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmeq(ma%mzm, return_value%mzm)
   end function zm_zm

   function zm_st(st)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      character(*) :: st
      intent (in) :: st
      call zmst2m(st, return_value%mzm)
   end function zm_st

   function zm_i1(ival)     result (return_value)
      use fmvals
      implicit none
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ival
      n = size(ival)
      do j = 1, n
         call zmi2m(ival(j), return_value(j)%mzm)
      enddo
   end function zm_i1

   function zm_r1(r)     result (return_value)
      use fmvals
      implicit none
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: r
      type(multi), save :: mtlvfm, mulvfm
      n = size(r)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, return_value(j)%mzm)
      enddo
   end function zm_r1

   function zm_d1(d)     result (return_value)
      use fmvals
      implicit none
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: d
      type(multi), save :: mtlvfm, mulvfm
      n = size(d)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, return_value(j)%mzm)
      enddo
   end function zm_d1

   function zm_z1(z)     result (return_value)
      use fmvals
      implicit none
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: z
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), return_value(j)%mzm)
      enddo
   end function zm_z1

   function zm_c1(c)     result (return_value)
      use fmvals
      implicit none
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: c
      type(multi), save :: mtlvfm, mulvfm
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, return_value(j)%mzm)
      enddo
   end function zm_c1

   function zm_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(multi), save :: mulvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, return_value(j)%mzm)
      enddo
   end function zm_fm1

   function zm_im1(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, return_value(j)%mzm)
      enddo
   end function zm_im1

   function zm_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmeq(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function zm_zm1

   function zm_st1(st)     result (return_value)
      use fmvals
      implicit none
      character(*), dimension(:) :: st
      type (zm), dimension(size(st)) :: return_value
      integer :: j, n
      intent (in) :: st
      n = size(st)
      do j = 1, n
         call zmst2m(st(j), return_value(j)%mzm)
      enddo
   end function zm_st1

   function zm_i2(ival)     result (return_value)
      use fmvals
      implicit none
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ival
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call zmi2m(ival(j, k), return_value(j, k)%mzm)
         enddo
      enddo
   end function zm_i2

   function zm_r2(r)     result (return_value)
      use fmvals
      implicit none
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: r
      type(multi), save :: mtlvfm, mulvfm
      call fmi2m(0, mulvfm)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, return_value(j, k)%mzm)
         enddo
      enddo
   end function zm_r2

   function zm_d2(d)     result (return_value)
      use fmvals
      implicit none
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: d
      type(multi), save :: mtlvfm, mulvfm
      call fmi2m(0, mulvfm)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, return_value(j, k)%mzm)
         enddo
      enddo
   end function zm_d2

   function zm_z2(z)     result (return_value)
      use fmvals
      implicit none
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: z
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), return_value(j, k)%mzm)
         enddo
      enddo
   end function zm_z2

   function zm_c2(c)     result (return_value)
      use fmvals
      implicit none
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: c
      type(multi), save :: mtlvfm, mulvfm
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, return_value(j, k)%mzm)
         enddo
      enddo
   end function zm_c2

   function zm_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(multi), save :: mulvfm
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, return_value(j, k)%mzm)
         enddo
      enddo
   end function zm_fm2

   function zm_im2(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, return_value(j, k)%mzm)
         enddo
      enddo
   end function zm_im2

   function zm_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function zm_zm2

   function zm_st2(st)     result (return_value)
      use fmvals
      implicit none
      character(*), dimension(:,:) :: st
      type (zm), dimension(size(st, dim=1), size(st, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: st
      do j = 1, size(st, dim=1)
         do k = 1, size(st, dim=2)
            call zmst2m(st(j, k), return_value(j, k)%mzm)
         enddo
      enddo
   end function zm_st2

!                                                              to_int

   function fm_2int(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer :: return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmm2i(ma%mfm, return_value)
   end function fm_2int

   function im_2int(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      integer :: return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imm2i(ma%mim, return_value)
   end function im_2int

   function zm_2int(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      integer :: return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmm2i(ma%mzm, return_value)
   end function zm_2int

   function fm_2int1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      integer, dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmm2i(ma(j)%mfm, return_value(j))
      enddo
   end function fm_2int1

   function im_2int1(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      integer, dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call imm2i(ma(j)%mim, return_value(j))
      enddo
   end function im_2int1

   function zm_2int1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      integer, dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmm2i(ma(j)%mzm(1), return_value(j))
      enddo
   end function zm_2int1

   function fm_2int2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      integer, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2i(ma(j, k)%mfm, return_value(j, k))
         enddo
      enddo
   end function fm_2int2

   function im_2int2(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      integer, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imm2i(ma(j, k)%mim, return_value(j, k))
         enddo
      enddo
   end function im_2int2

   function zm_2int2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      integer, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2i(ma(j, k)%mzm(1), return_value(j, k))
         enddo
      enddo
   end function zm_2int2

!                                                               to_sp

   function fm_2sp(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      real :: return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmm2sp(ma%mfm, return_value)
   end function fm_2sp

   function im_2sp(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      real :: return_value
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mtlvfm)
      call fmm2sp(mtlvfm, return_value)
   end function im_2sp

   function zm_2sp(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      real :: return_value
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call zmreal(ma%mzm, mtlvfm)
      call fmm2sp(mtlvfm, return_value)
   end function zm_2sp

   function fm_2sp1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      real, dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmm2sp(ma(j)%mfm, return_value(j))
      enddo
   end function fm_2sp1

   function im_2sp1(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      real, dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call imm2sp(ma(j)%mim, return_value(j))
      enddo
   end function im_2sp1

   function zm_2sp1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      real, dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmm2sp(ma(j)%mzm(1), return_value(j))
      enddo
   end function zm_2sp1

   function fm_2sp2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      real, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2sp(ma(j, k)%mfm, return_value(j, k))
         enddo
      enddo
   end function fm_2sp2

   function im_2sp2(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      real, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imm2sp(ma(j, k)%mim, return_value(j, k))
         enddo
      enddo
   end function im_2sp2

   function zm_2sp2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      real, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2sp(ma(j, k)%mzm(1), return_value(j, k))
         enddo
      enddo
   end function zm_2sp2

!                                                               to_dp

   function fm_2dp(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      double precision :: return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmm2dp(ma%mfm, return_value)
   end function fm_2dp

   function im_2dp(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      double precision :: return_value
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mtlvfm)
      call fmm2dp(mtlvfm, return_value)
   end function im_2dp

   function zm_2dp(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      double precision :: return_value
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call zmreal(ma%mzm, mtlvfm)
      call fmm2dp(mtlvfm, return_value)
   end function zm_2dp

   function fm_2dp1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      double precision, dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmm2dp(ma(j)%mfm, return_value(j))
      enddo
   end function fm_2dp1

   function im_2dp1(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      double precision, dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call imm2dp(ma(j)%mim, return_value(j))
      enddo
   end function im_2dp1

   function zm_2dp1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      double precision, dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmm2dp(ma(j)%mzm(1), return_value(j))
      enddo
   end function zm_2dp1

   function fm_2dp2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      double precision, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2dp(ma(j, k)%mfm, return_value(j, k))
         enddo
      enddo
   end function fm_2dp2

   function im_2dp2(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      double precision, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imm2dp(ma(j, k)%mim, return_value(j, k))
         enddo
      enddo
   end function im_2dp2

   function zm_2dp2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      double precision, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2dp(ma(j, k)%mzm(1), return_value(j, k))
         enddo
      enddo
   end function zm_2dp2

!                                                              to_spz

   function fm_2spz(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex :: return_value
      real :: r
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmm2sp(ma%mfm, r)
      return_value = cmplx( r , 0.0 )
   end function fm_2spz

   function im_2spz(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex :: return_value
      real :: r
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mtlvfm)
      call fmm2sp(mtlvfm, r)
      return_value = cmplx( r , 0.0 )
   end function im_2spz

   function zm_2spz(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex :: return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmm2z(ma%mzm, return_value)
   end function zm_2spz

   function fm_2spz1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      complex, dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmm2sp(ma(j)%mfm, r)
         return_value(j) = cmplx( r , 0.0 )
      enddo
   end function fm_2spz1

   function im_2spz1(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      complex, dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call fmm2sp(mtlvfm, r)
         return_value(j) = cmplx( r , 0.0 )
      enddo
   end function im_2spz1

   function zm_2spz1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      complex, dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmm2z(ma(j)%mzm, return_value(j))
      enddo
   end function zm_2spz1

   function fm_2spz2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      complex, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2sp(ma(j, k)%mfm, r)
            return_value(j, k) = cmplx( r , 0.0 )
         enddo
      enddo
   end function fm_2spz2

   function im_2spz2(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      complex, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call fmm2sp(mtlvfm, r)
            return_value(j, k) = cmplx( r , 0.0 )
         enddo
      enddo
   end function im_2spz2

   function zm_2spz2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      complex, dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmm2z(ma(j, k)%mzm, return_value(j, k))
         enddo
      enddo
   end function zm_2spz2

!                                                              to_dpz

   function fm_2dpz(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)) :: return_value
      double precision :: d
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmm2dp(ma%mfm, d)
      return_value = cmplx( d , 0.0d0 , kind(0.0d0) )
   end function fm_2dpz

   function im_2dpz(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)) :: return_value
      double precision :: d
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imm2dp(ma%mim, d)
      return_value = cmplx( d , 0.0d0 , kind(0.0d0) )
   end function im_2dpz

   function zm_2dpz(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)) :: return_value
      double precision :: d1, d2
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call zmreal(ma%mzm, mtlvfm)
      call fmm2dp(mtlvfm, d1)
      call zmimag(ma%mzm, mtlvfm)
      call fmm2dp(mtlvfm, d2)
      return_value = cmplx( d1 , d2 , kind(0.0d0) )
   end function zm_2dpz

   function fm_2dpz1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmm2dp(ma(j)%mfm, d)
         return_value(j) = cmplx( d , 0.0d0 , kind(0.0d0) )
      enddo
   end function fm_2dpz1

   function im_2dpz1(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call fmm2dp(mtlvfm, d)
         return_value(j) = cmplx( d , 0.0d0 , kind(0.0d0) )
      enddo
   end function im_2dpz1

   function zm_2dpz1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d1, d2
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmreal(ma(j)%mzm, mtlvfm)
         call fmm2dp(mtlvfm, d1)
         call zmimag(ma(j)%mzm, mtlvfm)
         call fmm2dp(mtlvfm, d2)
         return_value(j) = cmplx( d1 , d2 , kind(0.0d0) )
      enddo
   end function zm_2dpz1

   function fm_2dpz2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2dp(ma(j, k)%mfm, d)
            return_value(j, k) = cmplx( d , 0.0d0 , kind(0.0d0) )
         enddo
      enddo
   end function fm_2dpz2

   function im_2dpz2(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call fmm2dp(mtlvfm, d)
            return_value(j, k) = cmplx( d , 0.0d0 , kind(0.0d0) )
         enddo
      enddo
   end function im_2dpz2

   function zm_2dpz2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d1, d2
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmreal(ma(j, k)%mzm, mtlvfm)
            call fmm2dp(mtlvfm, d1)
            call zmimag(ma(j, k)%mzm, mtlvfm)
            call fmm2dp(mtlvfm, d2)
            return_value(j, k) = cmplx( d1 , d2 , kind(0.0d0) )
         enddo
      enddo
   end function zm_2dpz2

   subroutine fm_eq(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmeq(ma%mfm, mb%mfm)
   end subroutine fm_eq

   subroutine im_eq(ma, mb)
      use fmvals
      implicit none
      type (im) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call imeq(ma%mim, mb%mim)
   end subroutine im_eq

   subroutine zm_eq(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmeq(ma%mzm, mb%mzm)
   end subroutine zm_eq

!                                                         is_overflow

   function fm_is_overflow(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      logical :: return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      return_value = .false.
      if (ma%mfm%mp(2) == mexpov) return_value = .true.
   end function fm_is_overflow

   function im_is_overflow(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      logical :: return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      return_value = .false.
      if (ma%mim%mp(2) == mexpov) return_value = .true.
   end function im_is_overflow

   function zm_is_overflow(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      logical :: return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      return_value = .false.
      if (ma%mzm(1)%mp(2) == mexpov) return_value = .true.
      if (ma%mzm(2)%mp(2) == mexpov) return_value = .true.
   end function zm_is_overflow

   function fm_is_overflow1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      logical :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      return_value = .false.
      do j = 1, n
         if (ma(j)%mfm%mp(2) == mexpov) return_value = .true.
      enddo
   end function fm_is_overflow1

   function im_is_overflow1(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      logical :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      return_value = .false.
      do j = 1, n
         if (ma(j)%mim%mp(2) == mexpov) return_value = .true.
      enddo
   end function im_is_overflow1

   function zm_is_overflow1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      logical :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      return_value = .false.
      do j = 1, n
         if (ma(j)%mzm(1)%mp(2) == mexpov) return_value = .true.
         if (ma(j)%mzm(2)%mp(2) == mexpov) return_value = .true.
      enddo
   end function zm_is_overflow1

   function fm_is_overflow2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      logical :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      return_value = .false.
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (ma(j, k)%mfm%mp(2) == mexpov) return_value = .true.
         enddo
      enddo
   end function fm_is_overflow2

   function im_is_overflow2(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      logical :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      return_value = .false.
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (ma(j, k)%mim%mp(2) == mexpov) return_value = .true.
         enddo
      enddo
   end function im_is_overflow2

   function zm_is_overflow2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      logical :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      return_value = .false.
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (ma(j, k)%mzm(1)%mp(2) == mexpov) return_value = .true.
            if (ma(j, k)%mzm(2)%mp(2) == mexpov) return_value = .true.
         enddo
      enddo
   end function zm_is_overflow2

!                                                        is_underflow

   function fm_is_underflow(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      logical :: return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      return_value = .false.
      if (ma%mfm%mp(2) == mexpun) return_value = .true.
   end function fm_is_underflow

!  The integer versions are included for completeness, but type (im) numbers can't underflow.

   function im_is_underflow(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      logical :: return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      return_value = .false.
      if (ma%mim%mp(2) == mexpun) return_value = .true.
   end function im_is_underflow

   function zm_is_underflow(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      logical :: return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      return_value = .false.
      if (ma%mzm(1)%mp(2) == mexpun) return_value = .true.
      if (ma%mzm(2)%mp(2) == mexpun) return_value = .true.
   end function zm_is_underflow

   function fm_is_underflow1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      logical :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      return_value = .false.
      do j = 1, n
         if (ma(j)%mfm%mp(2) == mexpun) return_value = .true.
      enddo
   end function fm_is_underflow1

   function im_is_underflow1(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      logical :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      return_value = .false.
      do j = 1, n
         if (ma(j)%mim%mp(2) == mexpun) return_value = .true.
      enddo
   end function im_is_underflow1

   function zm_is_underflow1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      logical :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      return_value = .false.
      do j = 1, n
         if (ma(j)%mzm(1)%mp(2) == mexpun) return_value = .true.
         if (ma(j)%mzm(2)%mp(2) == mexpun) return_value = .true.
      enddo
   end function zm_is_underflow1

   function fm_is_underflow2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      logical :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      return_value = .false.
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (ma(j, k)%mfm%mp(2) == mexpun) return_value = .true.
         enddo
      enddo
   end function fm_is_underflow2

   function im_is_underflow2(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      logical :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      return_value = .false.
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (ma(j, k)%mim%mp(2) == mexpun) return_value = .true.
         enddo
      enddo
   end function im_is_underflow2

   function zm_is_underflow2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      logical :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      return_value = .false.
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (ma(j, k)%mzm(1)%mp(2) == mexpun) return_value = .true.
            if (ma(j, k)%mzm(2)%mp(2) == mexpun) return_value = .true.
         enddo
      enddo
   end function zm_is_underflow2

!                                                          is_unknown

   function fm_is_unknown(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      logical :: return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      return_value = .false.
      if (ma%mfm%mp(2) == munkno) return_value = .true.
   end function fm_is_unknown

   function im_is_unknown(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      logical :: return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      return_value = .false.
      if (ma%mim%mp(2) == munkno) return_value = .true.
   end function im_is_unknown

   function zm_is_unknown(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      logical :: return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      return_value = .false.
      if (ma%mzm(1)%mp(2) == munkno) return_value = .true.
      if (ma%mzm(2)%mp(2) == munkno) return_value = .true.
   end function zm_is_unknown

   function fm_is_unknown1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      logical :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      return_value = .false.
      do j = 1, n
         if (ma(j)%mfm%mp(2) == munkno) return_value = .true.
      enddo
   end function fm_is_unknown1

   function im_is_unknown1(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      logical :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      return_value = .false.
      do j = 1, n
         if (ma(j)%mim%mp(2) == munkno) return_value = .true.
      enddo
   end function im_is_unknown1

   function zm_is_unknown1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      logical :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      return_value = .false.
      do j = 1, n
         if (ma(j)%mzm(1)%mp(2) == munkno) return_value = .true.
         if (ma(j)%mzm(2)%mp(2) == munkno) return_value = .true.
      enddo
   end function zm_is_unknown1

   function fm_is_unknown2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      logical :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      return_value = .false.
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (ma(j, k)%mfm%mp(2) == munkno) return_value = .true.
         enddo
      enddo
   end function fm_is_unknown2

   function im_is_unknown2(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      logical :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      return_value = .false.
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (ma(j, k)%mim%mp(2) == munkno) return_value = .true.
         enddo
      enddo
   end function im_is_unknown2

   function zm_is_unknown2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      logical :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      return_value = .false.
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (ma(j, k)%mzm(1)%mp(2) == munkno) return_value = .true.
            if (ma(j, k)%mzm(2)%mp(2) == munkno) return_value = .true.
         enddo
      enddo
   end function zm_is_unknown2

   subroutine fm_undef_inp_fm0(ma)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (in) :: ma
      if (.not. allocated(ma%mfm%mp)) call fm_input_error
   end subroutine fm_undef_inp_fm0

   subroutine fm_undef_inp_im0(ma)
      use fmvals
      implicit none
      type (im) :: ma
      intent (in) :: ma
      if (.not. allocated(ma%mim%mp)) call fm_input_error
   end subroutine fm_undef_inp_im0

   subroutine fm_undef_inp_zm0(ma)
      use fmvals
      implicit none
      type (zm) :: ma
      intent (in) :: ma
      if (.not. allocated(ma%mzm(1)%mp)) call fm_input_error
      if (.not. allocated(ma%mzm(2)%mp)) call fm_input_error
   end subroutine fm_undef_inp_zm0

   subroutine fm_undef_inp_fm1(ma)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      integer :: j
      intent (in) :: ma
      do j = 1, size(ma)
         if (.not. allocated(ma(j)%mfm%mp)) call fm_input_error1(j)
      enddo
   end subroutine fm_undef_inp_fm1

   subroutine fm_undef_inp_im1(ma)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      integer :: j
      intent (in) :: ma
      do j = 1, size(ma)
         if (.not. allocated(ma(j)%mim%mp)) call fm_input_error1(j)
      enddo
   end subroutine fm_undef_inp_im1

   subroutine fm_undef_inp_zm1(ma)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      integer :: j
      intent (in) :: ma
      do j = 1, size(ma)
         if (.not. allocated(ma(j)%mzm(1)%mp)) call fm_input_error1(j)
         if (.not. allocated(ma(j)%mzm(2)%mp)) call fm_input_error1(j)
      enddo
   end subroutine fm_undef_inp_zm1

   subroutine fm_undef_inp_fm2(ma)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      integer :: j, k
      intent (in) :: ma
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (.not. allocated(ma(j, k)%mfm%mp)) call fm_input_error2(j, k)
         enddo
      enddo
   end subroutine fm_undef_inp_fm2

   subroutine fm_undef_inp_im2(ma)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      integer :: j, k
      intent (in) :: ma
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (.not. allocated(ma(j, k)%mim%mp)) call fm_input_error2(j, k)
         enddo
      enddo
   end subroutine fm_undef_inp_im2

   subroutine fm_undef_inp_zm2(ma)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      integer :: j, k
      intent (in) :: ma
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            if (.not. allocated(ma(j, k)%mzm(1)%mp)) call fm_input_error2(j, k)
            if (.not. allocated(ma(j, k)%mzm(2)%mp)) call fm_input_error2(j, k)
         enddo
      enddo
   end subroutine fm_undef_inp_zm2

   subroutine fm_deallocate_fm1(ma)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      intent (inout) :: ma
      if (size(ma) < 0 .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_deallocate_fm1

   subroutine fm_deallocate_im1(ma)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      intent (inout) :: ma
      if (size(ma) < 0 .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_deallocate_im1

   subroutine fm_deallocate_zm1(ma)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      intent (inout) :: ma
      if (size(ma) < 0 .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_deallocate_zm1

   subroutine fm_deallocate_fm2(ma)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      intent (inout) :: ma
      if (size(ma) < 0 .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_deallocate_fm2

   subroutine fm_deallocate_im2(ma)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      intent (inout) :: ma
      if (size(ma) < 0 .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_deallocate_im2

   subroutine fm_deallocate_zm2(ma)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      intent (inout) :: ma
      if (size(ma) < 0 .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_deallocate_zm2

   subroutine fm_input_error
      use fmvals
      implicit none
      integer :: err(2) = (/ 22, 23 /)
      write (*,*) ' '
      write (*,*) ' '
      write (*,*) ' ***  Error in a program using the FM package  ***'
      write (*,*) ' '
      write (*,*) ' A multiple precision number is undefined in an expression or as an input'
      write (*,*) ' argument to a subprogram.'
      write (*,*) ' '
      write (*,*) ' The most common causes of this error are:'
      write (*,*) "     1. A multiple-precision variable (type(fm), (im), (zm), etc.) appears in an"
      write (*,*) "        expression in the user's program before it has been given a value."
      write (*,*) "     2. The user's program raises precision (ndig) and later tries to use a"
      write (*,*) "        variable previously defined at a lower precision."
      write (*,*) "        Call fm_equ or fm_equ_r1 to increase the size of type(fm) variables"
      write (*,*) "        after increasing precision, zm_equ for type(zm) variables, etc."
      write (*,*) ' '
      write (*,*) ' To help isolate the code that caused this error, this error message is followed'
      write (*,*) ' by an illegal out-of-range array reference.  Some compilers have an option for'
      write (*,*) ' checking array bounds and will give a traceback with the line number in the'
      write (*,*) ' calling program where the error originated.'
      write (*,*) ' '
      write (*,*) ' The program has been stopped.'
      write (*,*) ' '
      if (err(-ndig) > 22) write (*,*) ' Negative array subscript.'
      stop
   end subroutine fm_input_error

   subroutine fm_input_error1(j)
      use fmvals
      implicit none
      integer :: j
      integer :: err(2) = (/ 22, 23 /)
      intent (in) :: j
      write (*,*) ' '
      write (*,*) ' '
      write (*,*) ' ***  Error in a program using the FM package  ***'
      write (*,*) ' '
      write (*,*) ' Element (', j, ') of a multiple precision one-dimensional array'
      write (*,*) ' is undefined in an expression.'
      write (*,*) ' '
      write (*,*) ' Note that if an array section is being used, like A(6:10), then if A(7) is'
      write (*,*) ' undefined it will be listed as element (2) here.'
      write (*,*) ' '
      write (*,*) ' The most common causes of this error are:'
      write (*,*) "     1. A multiple-precision variable (type(fm), (im), (zm), etc.) appears in an"
      write (*,*) "        expression in the user's program before it has been given a value."
      write (*,*) "     2. The user's program raises precision (ndig) and later tries to use a"
      write (*,*) "        variable previously defined at a lower precision."
      write (*,*) "        Call fm_equ or fm_equ_r1 to increase the size of type(fm) variables"
      write (*,*) "        after increasing precision, zm_equ for type(zm) variables, etc."
      write (*,*) ' '
      write (*,*) ' To help isolate the code that caused this error, this error message is followed'
      write (*,*) ' by an illegal out-of-range array reference.  Some compilers have an option for'
      write (*,*) ' checking array bounds and will give a traceback with the line number in the'
      write (*,*) ' calling program where the error originated.'
      write (*,*) ' '
      write (*,*) ' The program has been stopped.'
      write (*,*) ' '
      if (err(-ndig) > 22) write (*,*) ' Negative array subscript.'
      stop
   end subroutine fm_input_error1

   subroutine fm_input_error2(j, k)
      use fmvals
      implicit none
      integer :: j, k
      integer :: err(2) = (/ 22, 23 /)
      intent (in) :: j, k
      write (*,*) ' '
      write (*,*) ' '
      write (*,*) ' ***  Error in a program using the FM package  ***'
      write (*,*) ' '
      write (*,*) ' Element (', j, ', ', k, ') of a multiple precision two-dimensional array'
      write (*,*) ' is undefined in an expression.'
      write (*,*) ' '
      write (*,*) ' Note that if an array section is being used, like A(6:10), then if A(7) is'
      write (*,*) ' undefined it will be listed as element (2) here.'
      write (*,*) ' '
      write (*,*) ' The most common causes of this error are:'
      write (*,*) "     1. A multiple-precision variable (type(fm), (im), (zm), etc.) appears in an"
      write (*,*) "        expression in the user's program before it has been given a value."
      write (*,*) "     2. The user's program raises precision (ndig) and later tries to use a"
      write (*,*) "        variable previously defined at a lower precision."
      write (*,*) "        Call fm_equ or fm_equ_r1 to increase the size of type(fm) variables"
      write (*,*) "        after increasing precision, zm_equ for type(zm) variables, etc."
      write (*,*) ' '
      write (*,*) ' To help isolate the code that caused this error, this error message is followed'
      write (*,*) ' by an illegal out-of-range array reference.  Some compilers have an option for'
      write (*,*) ' checking array bounds and will give a traceback with the line number in the'
      write (*,*) ' calling program where the error originated.'
      write (*,*) ' '
      write (*,*) ' The program has been stopped.'
      write (*,*) ' '
      if (err(-ndig) > 22) write (*,*) ' Negative array subscript.'
      stop
   end subroutine fm_input_error2

 end module fmzm_1

 module fmzm_2
    use fmzm_1

!   These abbreviations are used for operations on the various data types.

!   i    Integer
!   r    Real
!   d    Double Precision
!   z    Complex
!   c    Complex Double Precision
!   fm   Multiple precision real
!   im   Multiple precision integer
!   zm   Multiple precision complex

!   For example, the "=" procedure fmeq_fmd is for statements like x = a, where x is type FM
!   and a is type Double Precision.

!   Digits refer to the number of dimensions (rank) for an array.
!   fmeq_fm1r handles statements like a = 1.0, where a is a 1-dimensional array of type FM and the
!   right side (1.0) is real.  Like the ordinary Fortran array syntax, this sets all the elements
!   of array a to 1.0.

    interface assignment (=)
       module procedure fmeq_ifm
       module procedure fmeq_iim
       module procedure fmeq_izm
       module procedure fmeq_rfm
       module procedure fmeq_rim
       module procedure fmeq_rzm
       module procedure fmeq_dfm
       module procedure fmeq_dim
       module procedure fmeq_dzm
       module procedure fmeq_zfm
       module procedure fmeq_zim
       module procedure fmeq_zzm
       module procedure fmeq_cfm
       module procedure fmeq_cim
       module procedure fmeq_czm
       module procedure fmeq_fmi
       module procedure fmeq_fmr
       module procedure fmeq_fmd
       module procedure fmeq_fmz
       module procedure fmeq_fmc
       module procedure fmeq_fmfm
       module procedure fmeq_fmim
       module procedure fmeq_fmzm
       module procedure fmeq_imi
       module procedure fmeq_imr
       module procedure fmeq_imd
       module procedure fmeq_imz
       module procedure fmeq_imc
       module procedure fmeq_imfm
       module procedure fmeq_imim
       module procedure fmeq_imzm
       module procedure fmeq_zmi
       module procedure fmeq_zmr
       module procedure fmeq_zmd
       module procedure fmeq_zmz
       module procedure fmeq_zmc
       module procedure fmeq_zmfm
       module procedure fmeq_zmim
       module procedure fmeq_zmzm
       module procedure fmeq_fm1i
       module procedure fmeq_fm1r
       module procedure fmeq_fm1d
       module procedure fmeq_fm1z
       module procedure fmeq_fm1c
       module procedure fmeq_i1fm
       module procedure fmeq_r1fm
       module procedure fmeq_d1fm
       module procedure fmeq_z1fm
       module procedure fmeq_c1fm
       module procedure fmeq_fm1fm
       module procedure fmeq_fm1im
       module procedure fmeq_fm1zm
       module procedure fmeq_im1fm
       module procedure fmeq_zm1fm
       module procedure fmeq_fm1i1
       module procedure fmeq_fm1r1
       module procedure fmeq_fm1d1
       module procedure fmeq_fm1z1
       module procedure fmeq_fm1c1
       module procedure fmeq_i1fm1
       module procedure fmeq_r1fm1
       module procedure fmeq_d1fm1
       module procedure fmeq_z1fm1
       module procedure fmeq_c1fm1
       module procedure fmeq_fm1fm1
       module procedure fmeq_fm1im1
       module procedure fmeq_fm1zm1
       module procedure fmeq_im1fm1
       module procedure fmeq_zm1fm1
       module procedure fmeq_im1i
       module procedure fmeq_im1r
       module procedure fmeq_im1d
       module procedure fmeq_im1z
       module procedure fmeq_im1c
       module procedure fmeq_i1im
       module procedure fmeq_r1im
       module procedure fmeq_d1im
       module procedure fmeq_z1im
       module procedure fmeq_c1im
       module procedure fmeq_im1im
       module procedure fmeq_im1zm
       module procedure fmeq_zm1im
       module procedure fmeq_im1i1
       module procedure fmeq_im1r1
       module procedure fmeq_im1d1
       module procedure fmeq_im1z1
       module procedure fmeq_im1c1
       module procedure fmeq_i1im1
       module procedure fmeq_r1im1
       module procedure fmeq_d1im1
       module procedure fmeq_z1im1
       module procedure fmeq_c1im1
       module procedure fmeq_im1im1
       module procedure fmeq_im1zm1
       module procedure fmeq_zm1im1
       module procedure fmeq_zm1i
       module procedure fmeq_zm1r
       module procedure fmeq_zm1d
       module procedure fmeq_zm1z
       module procedure fmeq_zm1c
       module procedure fmeq_i1zm
       module procedure fmeq_r1zm
       module procedure fmeq_d1zm
       module procedure fmeq_z1zm
       module procedure fmeq_c1zm
       module procedure fmeq_zm1zm
       module procedure fmeq_zm1i1
       module procedure fmeq_zm1r1
       module procedure fmeq_zm1d1
       module procedure fmeq_zm1z1
       module procedure fmeq_zm1c1
       module procedure fmeq_i1zm1
       module procedure fmeq_r1zm1
       module procedure fmeq_d1zm1
       module procedure fmeq_z1zm1
       module procedure fmeq_c1zm1
       module procedure fmeq_zm1zm1
       module procedure fmeq_fm2i
       module procedure fmeq_fm2r
       module procedure fmeq_fm2d
       module procedure fmeq_fm2z
       module procedure fmeq_fm2c
       module procedure fmeq_i2fm
       module procedure fmeq_r2fm
       module procedure fmeq_d2fm
       module procedure fmeq_z2fm
       module procedure fmeq_c2fm
       module procedure fmeq_fm2fm
       module procedure fmeq_fm2im
       module procedure fmeq_fm2zm
       module procedure fmeq_im2fm
       module procedure fmeq_zm2fm
       module procedure fmeq_fm2i2
       module procedure fmeq_fm2r2
       module procedure fmeq_fm2d2
       module procedure fmeq_fm2z2
       module procedure fmeq_fm2c2
       module procedure fmeq_i2fm2
       module procedure fmeq_r2fm2
       module procedure fmeq_d2fm2
       module procedure fmeq_z2fm2
       module procedure fmeq_c2fm2
       module procedure fmeq_fm2fm2
       module procedure fmeq_fm2im2
       module procedure fmeq_fm2zm2
       module procedure fmeq_im2fm2
       module procedure fmeq_zm2fm2
       module procedure fmeq_im2i
       module procedure fmeq_im2r
       module procedure fmeq_im2d
       module procedure fmeq_im2z
       module procedure fmeq_im2c
       module procedure fmeq_i2im
       module procedure fmeq_r2im
       module procedure fmeq_d2im
       module procedure fmeq_z2im
       module procedure fmeq_c2im
       module procedure fmeq_im2im
       module procedure fmeq_im2zm
       module procedure fmeq_zm2im
       module procedure fmeq_im2i2
       module procedure fmeq_im2r2
       module procedure fmeq_im2d2
       module procedure fmeq_im2z2
       module procedure fmeq_im2c2
       module procedure fmeq_i2im2
       module procedure fmeq_r2im2
       module procedure fmeq_d2im2
       module procedure fmeq_z2im2
       module procedure fmeq_c2im2
       module procedure fmeq_im2im2
       module procedure fmeq_im2zm2
       module procedure fmeq_zm2im2
       module procedure fmeq_zm2i
       module procedure fmeq_zm2r
       module procedure fmeq_zm2d
       module procedure fmeq_zm2z
       module procedure fmeq_zm2c
       module procedure fmeq_i2zm
       module procedure fmeq_r2zm
       module procedure fmeq_d2zm
       module procedure fmeq_z2zm
       module procedure fmeq_c2zm
       module procedure fmeq_zm2zm
       module procedure fmeq_zm2i2
       module procedure fmeq_zm2r2
       module procedure fmeq_zm2d2
       module procedure fmeq_zm2z2
       module procedure fmeq_zm2c2
       module procedure fmeq_i2zm2
       module procedure fmeq_r2zm2
       module procedure fmeq_d2zm2
       module procedure fmeq_z2zm2
       module procedure fmeq_c2zm2
       module procedure fmeq_zm2zm2
    end interface

    interface operator (==)
       module procedure fmleq_ifm
       module procedure fmleq_iim
       module procedure fmleq_izm
       module procedure fmleq_rfm
       module procedure fmleq_rim
       module procedure fmleq_rzm
       module procedure fmleq_dfm
       module procedure fmleq_dim
       module procedure fmleq_dzm
       module procedure fmleq_zfm
       module procedure fmleq_zim
       module procedure fmleq_zzm
       module procedure fmleq_cfm
       module procedure fmleq_cim
       module procedure fmleq_czm
       module procedure fmleq_fmi
       module procedure fmleq_fmr
       module procedure fmleq_fmd
       module procedure fmleq_fmz
       module procedure fmleq_fmc
       module procedure fmleq_fmfm
       module procedure fmleq_fmim
       module procedure fmleq_fmzm
       module procedure fmleq_imi
       module procedure fmleq_imr
       module procedure fmleq_imd
       module procedure fmleq_imz
       module procedure fmleq_imc
       module procedure fmleq_imfm
       module procedure fmleq_imim
       module procedure fmleq_imzm
       module procedure fmleq_zmi
       module procedure fmleq_zmr
       module procedure fmleq_zmd
       module procedure fmleq_zmz
       module procedure fmleq_zmc
       module procedure fmleq_zmfm
       module procedure fmleq_zmim
       module procedure fmleq_zmzm
    end interface

!  The next two functions are no longer needed in version 1.4.
!  Dummy versions of the individual procedures are included for compatibility with version 1.3.

    interface fm_enter_user_function
       module procedure fm_enter_user_function_fm
       module procedure fm_enter_user_function_fm1
       module procedure fm_enter_user_function_fm2
       module procedure fm_enter_user_function_im
       module procedure fm_enter_user_function_im1
       module procedure fm_enter_user_function_im2
       module procedure fm_enter_user_function_zm
       module procedure fm_enter_user_function_zm1
       module procedure fm_enter_user_function_zm2
    end interface

    interface fm_exit_user_function
       module procedure fm_exit_user_function_fm
       module procedure fm_exit_user_function_fm1
       module procedure fm_exit_user_function_fm2
       module procedure fm_exit_user_function_im
       module procedure fm_exit_user_function_im1
       module procedure fm_exit_user_function_im2
       module procedure fm_exit_user_function_zm
       module procedure fm_exit_user_function_zm1
       module procedure fm_exit_user_function_zm2
    end interface


 contains

   subroutine fm_enter_user_function_fm(f_name)
      use fmvals
      implicit none
      type (fm) :: f_name
      intent (in) :: f_name
      if (.not. allocated(f_name%mfm%mp) .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_enter_user_function_fm

   subroutine fm_enter_user_function_fm1(f_name)
      use fmvals
      implicit none
      type (fm), dimension(:) :: f_name
      intent (in) :: f_name
      if (size(f_name) < 0 .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_enter_user_function_fm1

   subroutine fm_enter_user_function_fm2(f_name)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: f_name
      intent (in) :: f_name
      if (size(f_name) < 0 .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_enter_user_function_fm2

   subroutine fm_enter_user_function_im(f_name)
      use fmvals
      implicit none
      type (im) :: f_name
      intent (in) :: f_name
      if (.not. allocated(f_name%mim%mp) .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_enter_user_function_im

   subroutine fm_enter_user_function_im1(f_name)
      use fmvals
      implicit none
      type (im), dimension(:) :: f_name
      intent (in) :: f_name
      if (size(f_name) < 0 .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_enter_user_function_im1

   subroutine fm_enter_user_function_im2(f_name)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: f_name
      intent (in) :: f_name
      if (size(f_name) < 0 .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_enter_user_function_im2

   subroutine fm_enter_user_function_zm(f_name)
      use fmvals
      implicit none
      type (zm) :: f_name
      intent (in) :: f_name
      if (.not. allocated(f_name%mzm(1)%mp) .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_enter_user_function_zm

   subroutine fm_enter_user_function_zm1(f_name)
      use fmvals
      implicit none
      type (zm), dimension(:) :: f_name
      intent (in) :: f_name
      if (size(f_name) < 0 .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_enter_user_function_zm1

   subroutine fm_enter_user_function_zm2(f_name)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: f_name
      intent (in) :: f_name
      if (size(f_name) < 0 .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_enter_user_function_zm2

   subroutine fm_exit_user_function_fm(f_name)
      use fmvals
      implicit none
      type (fm) :: f_name
      intent (in) :: f_name
      if (.not. allocated(f_name%mfm%mp) .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_exit_user_function_fm

   subroutine fm_exit_user_function_fm1(f_name)
      use fmvals
      implicit none
      type (fm), dimension(:) :: f_name
      intent (in) :: f_name
      if (size(f_name) < 0 .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_exit_user_function_fm1

   subroutine fm_exit_user_function_fm2(f_name)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: f_name
      intent (in) :: f_name
      if (size(f_name) < 0 .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_exit_user_function_fm2

   subroutine fm_exit_user_function_im(f_name)
      use fmvals
      implicit none
      type (im) :: f_name
      intent (in) :: f_name
      if (.not. allocated(f_name%mim%mp) .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_exit_user_function_im

   subroutine fm_exit_user_function_im1(f_name)
      use fmvals
      implicit none
      type (im), dimension(:) :: f_name
      intent (in) :: f_name
      if (size(f_name) < 0 .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_exit_user_function_im1

   subroutine fm_exit_user_function_im2(f_name)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: f_name
      intent (in) :: f_name
      if (size(f_name) < 0 .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_exit_user_function_im2

   subroutine fm_exit_user_function_zm(f_name)
      use fmvals
      implicit none
      type (zm) :: f_name
      intent (in) :: f_name
      if (.not. allocated(f_name%mzm(1)%mp) .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_exit_user_function_zm

   subroutine fm_exit_user_function_zm1(f_name)
      use fmvals
      implicit none
      type (zm), dimension(:) :: f_name
      intent (in) :: f_name
      if (size(f_name) < 0 .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_exit_user_function_zm1

   subroutine fm_exit_user_function_zm2(f_name)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: f_name
      intent (in) :: f_name
      if (size(f_name) < 0 .and. ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_exit_user_function_zm2

   subroutine fm_enter_user_routine
      use fmvals
      implicit none
      if (ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_enter_user_routine

   subroutine fm_exit_user_routine
      use fmvals
      implicit none
      if (ndig < 0) write (*,*) ' Invalid NDIG = ', ndig
   end subroutine fm_exit_user_routine


!                                                                   =

   subroutine fmeq_ifm(ival, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      integer :: ival
      intent (inout) :: ival
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmm2i(ma%mfm, ival)
   end subroutine fmeq_ifm

   subroutine fmeq_iim(ival, ma)
      use fmvals
      implicit none
      type (im) :: ma
      integer :: ival
      intent (inout) :: ival
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imm2i(ma%mim, ival)
   end subroutine fmeq_iim

   subroutine fmeq_izm(ival, ma)
      use fmvals
      implicit none
      type (zm) :: ma
      integer :: ival
      intent (inout) :: ival
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmm2i(ma%mzm, ival)
   end subroutine fmeq_izm

   subroutine fmeq_rfm(r, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      real :: r
      intent (inout) :: r
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmm2sp(ma%mfm, r)
   end subroutine fmeq_rfm

   subroutine fmeq_rim(r, ma)
      use fmvals
      implicit none
      type (im) :: ma
      real :: r
      intent (inout) :: r
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mtlvfm)
      call fmm2sp(mtlvfm, r)
   end subroutine fmeq_rim

   subroutine fmeq_rzm(r, ma)
      use fmvals
      implicit none
      type (zm) :: ma
      real :: r
      intent (inout) :: r
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call zmreal(ma%mzm, mtlvfm)
      call fmm2sp(mtlvfm, r)
   end subroutine fmeq_rzm

   subroutine fmeq_dfm(d, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      double precision :: d
      intent (inout) :: d
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmm2dp(ma%mfm, d)
   end subroutine fmeq_dfm

   subroutine fmeq_dim(d, ma)
      use fmvals
      implicit none
      type (im) :: ma
      double precision :: d
      intent (inout) :: d
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imm2dp(ma%mim, d)
   end subroutine fmeq_dim

   subroutine fmeq_dzm(d, ma)
      use fmvals
      implicit none
      type (zm) :: ma
      double precision :: d
      intent (inout) :: d
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call zmreal(ma%mzm, mtlvfm)
      call fmm2dp(mtlvfm, d)
   end subroutine fmeq_dzm

   subroutine fmeq_zfm(z, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      complex :: z
      real :: r
      intent (inout) :: z
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmm2sp(ma%mfm, r)
      z = cmplx( r , 0.0 )
   end subroutine fmeq_zfm

   subroutine fmeq_zim(z, ma)
      use fmvals
      implicit none
      type (im) :: ma
      complex :: z
      double precision :: d
      intent (inout) :: z
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imm2dp(ma%mim, d)
      z = cmplx( real(d) , 0.0 )
   end subroutine fmeq_zim

   subroutine fmeq_zzm(z, ma)
      use fmvals
      implicit none
      type (zm) :: ma
      complex :: z
      intent (inout) :: z
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmm2z(ma%mzm, z)
   end subroutine fmeq_zzm

   subroutine fmeq_cfm(c, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      double precision :: d
      intent (inout) :: c
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmm2dp(ma%mfm, d)
      c = cmplx( d , 0.0d0 , kind(0.0d0) )
   end subroutine fmeq_cfm

   subroutine fmeq_cim(c, ma)
      use fmvals
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      double precision :: d
      intent (inout) :: c
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imm2dp(ma%mim, d)
      c = cmplx( d , 0.0d0 , kind(0.0d0) )
   end subroutine fmeq_cim

   subroutine fmeq_czm(c, ma)
      use fmvals
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)) :: c
      double precision :: d1, d2
      intent (inout) :: c
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call zmreal(ma%mzm, mtlvfm)
      call fmm2dp(mtlvfm, d1)
      call zmimag(ma%mzm, mtlvfm)
      call fmm2dp(mtlvfm, d2)
      c = cmplx( d1 , d2 , kind(0.0d0) )
   end subroutine fmeq_czm

   subroutine fmeq_fmi(ma, ival)
      use fmvals
      implicit none
      type (fm) :: ma
      integer :: ival
      intent (inout) :: ma
      intent (in) :: ival
      call fmi2m(ival, ma%mfm)
   end subroutine fmeq_fmi

   subroutine fmeq_fmr(ma, r)
      use fmvals
      implicit none
      type (fm) :: ma
      real :: r
      intent (inout) :: ma
      intent (in) :: r
      call fmsp2m(r, ma%mfm)
   end subroutine fmeq_fmr

   subroutine fmeq_fmd(ma, d)
      use fmvals
      implicit none
      type (fm) :: ma
      double precision :: d
      intent (inout) :: ma
      intent (in) :: d
      call fmdp2m(d, ma%mfm)
   end subroutine fmeq_fmd

   subroutine fmeq_fmz(ma, z)
      use fmvals
      implicit none
      type (fm) :: ma
      complex :: z
      real :: r
      intent (inout) :: ma
      intent (in) :: z
      r = real(z)
      call fmsp2m(r, ma%mfm)
   end subroutine fmeq_fmz

   subroutine fmeq_fmc(ma, c)
      use fmvals
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      double precision :: d
      intent (inout) :: ma
      intent (in) :: c
      d = real(c, kind(0.0d0))
      call fmdp2m(d, ma%mfm)
   end subroutine fmeq_fmc

   subroutine fmeq_fmfm(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb
      call fm_undef_inp(mb)
      call fmeq(mb%mfm, ma%mfm)
   end subroutine fmeq_fmfm

   subroutine fmeq_fmim(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma
      type (im) :: mb
      intent (inout) :: ma
      intent (in) :: mb
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, ma%mfm)
   end subroutine fmeq_fmim

   subroutine fmeq_fmzm(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma
      type (zm) :: mb
      intent (inout) :: ma
      intent (in) :: mb
      call fm_undef_inp(mb)
      call zmreal(mb%mzm, ma%mfm)
   end subroutine fmeq_fmzm

   subroutine fmeq_imi(ma, ival)
      use fmvals
      implicit none
      type (im) :: ma
      integer :: ival
      intent (inout) :: ma
      intent (in) :: ival
      call imi2m(ival, ma%mim)
   end subroutine fmeq_imi

   subroutine fmeq_imr(ma, r)
      use fmvals
      implicit none
      type (im) :: ma
      integer :: ival
      real :: r
      character(25) :: st
      intent (inout) :: ma
      intent (in) :: r
      if (abs(r) < huge(1)) then
          ival = int(r)
          call imi2m(ival, ma%mim)
      else
          write (st, '(E25.16)') r
          call imst2m(st, ma%mim)
      endif
   end subroutine fmeq_imr

   subroutine fmeq_imd(ma, d)
      use fmvals
      implicit none
      type (im) :: ma
      integer :: ival
      double precision :: d
      character(25) :: st
      intent (inout) :: ma
      intent (in) :: d
      if (abs(d) < huge(1)) then
          ival = int(d)
          call imi2m(ival, ma%mim)
      else
          write (st, '(E25.16)') d
          call imst2m(st, ma%mim)
      endif
   end subroutine fmeq_imd

   subroutine fmeq_imz(ma, z)
      use fmvals
      implicit none
      type (im) :: ma
      complex :: z
      real :: r
      character(25) :: st
      integer :: ival
      intent (inout) :: ma
      intent (in) :: z
      r = real(z)
      if (abs(r) < huge(1)) then
          ival = int(r)
          call imi2m(ival, ma%mim)
      else
          write (st, '(E25.16)') r
          call imst2m(st, ma%mim)
      endif
   end subroutine fmeq_imz

   subroutine fmeq_imc(ma, c)
      use fmvals
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      double precision :: d
      character(25) :: st
      integer :: ival
      intent (inout) :: ma
      intent (in) :: c
      d = real(c, kind(0.0d0))
      if (abs(d) < huge(1)) then
          ival = int(d)
          call imi2m(ival, ma%mim)
      else
          write (st, '(E25.16)') d
          call imst2m(st, ma%mim)
      endif
   end subroutine fmeq_imc

   subroutine fmeq_imfm(ma, mb)
      use fmvals
      implicit none
      type (im) :: ma
      type (fm) :: mb
      intent (inout) :: ma
      intent (in) :: mb
      call fm_undef_inp(mb)
      call imfm2i(mb%mfm, ma%mim)
   end subroutine fmeq_imfm

   subroutine fmeq_imim(ma, mb)
      use fmvals
      implicit none
      type (im) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb
      call fm_undef_inp(mb)
      call imeq(mb%mim, ma%mim)
   end subroutine fmeq_imim

   subroutine fmeq_imzm(ma, mb)
      use fmvals
      implicit none
      type (im) :: ma
      type (zm) :: mb
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(mb)
      call zmreal(mb%mzm, mtlvfm)
      call imfm2i(mtlvfm, ma%mim)
   end subroutine fmeq_imzm

   subroutine fmeq_zmi(ma, ival)
      use fmvals
      implicit none
      type (zm) :: ma
      integer :: ival
      intent (inout) :: ma
      intent (in) :: ival
      call zmi2m(ival, ma%mzm)
   end subroutine fmeq_zmi

   subroutine fmeq_zmr(ma, r)
      use fmvals
      implicit none
      type (zm) :: ma
      real :: r
      complex :: z
      intent (inout) :: ma
      intent (in) :: r
      z = cmplx(r, 0.0)
      call zmz2m(z, ma%mzm)
   end subroutine fmeq_zmr

   subroutine fmeq_zmd(ma, d)
      use fmvals
      implicit none
      type (zm) :: ma
      double precision :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi), save :: mtlvfm, mulvfm
      call fmdp2m(d, mtlvfm)
      call fmdp2m(0.0d0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, ma%mzm)
   end subroutine fmeq_zmd

   subroutine fmeq_zmz(ma, z)
      use fmvals
      implicit none
      type (zm) :: ma
      complex :: z
      intent (inout) :: ma
      intent (in) :: z
      call zmz2m(z, ma%mzm)
   end subroutine fmeq_zmz

   subroutine fmeq_zmc(ma, c)
      use fmvals
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)) :: c
      double precision :: d
      intent (inout) :: ma
      intent (in) :: c
      type(multi), save :: mtlvfm, mulvfm
      d = real(c, kind(0.0d0))
      call fmdp2m(d, mtlvfm)
      d = aimag(c)
      call fmdp2m(d, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, ma%mzm)
   end subroutine fmeq_zmc

   subroutine fmeq_zmfm(ma, mb)
      use fmvals
      implicit none
      type (fm) :: mb
      type (zm) :: ma
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(mb)
      call fmeq(mb%mfm, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, ma%mzm)
   end subroutine fmeq_zmfm

   subroutine fmeq_zmim(ma, mb)
      use fmvals
      implicit none
      type (im) :: mb
      type (zm) :: ma
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, ma%mzm)
   end subroutine fmeq_zmim

   subroutine fmeq_zmzm(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(mb)
      call zmeq(mb%mzm, mtlvzm)
      call zmeq(mtlvzm, ma%mzm)
   end subroutine fmeq_zmzm

!             Array equal assignments for FM.

!             (1) rank 1  =  rank 0

   subroutine fmeq_fm1i(ma, ival)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      integer :: ival, j, n
      intent (inout) :: ma
      intent (in) :: ival
      type(multi), save :: mtlvfm
      n = size(ma)
      call fmi2m(ival, mtlvfm)
      do j = 1, n
         call fmeq(mtlvfm, ma(j)%mfm)
      enddo
   end subroutine fmeq_fm1i

   subroutine fmeq_fm1r(ma, r)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      integer :: j, n
      real :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi), save :: mtlvfm
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, n
         call fmeq(mtlvfm, ma(j)%mfm)
      enddo
   end subroutine fmeq_fm1r

   subroutine fmeq_fm1d(ma, d)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      integer :: j, n
      double precision :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi), save :: mtlvfm
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, n
         call fmeq(mtlvfm, ma(j)%mfm)
      enddo
   end subroutine fmeq_fm1d

   subroutine fmeq_fm1z(ma, z)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      integer :: j, n
      complex :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi), save :: mtlvfm
      n = size(ma)
      call fmsp2m(real(z), mtlvfm)
      do j = 1, n
         call fmeq(mtlvfm, ma(j)%mfm)
      enddo
   end subroutine fmeq_fm1z

   subroutine fmeq_fm1c(ma, c)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (inout) :: ma
      intent (in) :: c
      type(multi), save :: mtlvfm
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      do j = 1, n
         call fmeq(mtlvfm, ma(j)%mfm)
      enddo
   end subroutine fmeq_fm1c

   subroutine fmeq_i1fm(ival, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      integer, dimension(:) :: ival
      integer :: j, k, n
      intent (inout) :: ival
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ival)
      call fmm2i(ma%mfm, k)
      do j = 1, n
         ival(j) = k
      enddo
   end subroutine fmeq_i1fm

   subroutine fmeq_r1fm(r, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      real, dimension(:) :: r
      real :: r2
      integer :: j, n
      intent (inout) :: r
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(r)
      call fmm2sp(ma%mfm, r2)
      do j = 1, n
         r(j) = r2
      enddo
   end subroutine fmeq_r1fm

   subroutine fmeq_d1fm(d, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      double precision, dimension(:) :: d
      double precision :: d2
      integer :: j, n
      intent (inout) :: d
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(d)
      call fmm2dp(ma%mfm, d2)
      do j = 1, n
         d(j) = d2
      enddo
   end subroutine fmeq_d1fm

   subroutine fmeq_z1fm(z, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      complex, dimension(:) :: z
      real :: r2
      integer :: j, n
      intent (inout) :: z
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(z)
      call fmm2sp(ma%mfm, r2)
      do j = 1, n
         z(j) = r2
      enddo
   end subroutine fmeq_z1fm

   subroutine fmeq_c1fm(c, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      double precision :: d2
      integer :: j, n
      intent (inout) :: c
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(c)
      call fmm2dp(ma%mfm, d2)
      do j = 1, n
         c(j) = d2
      enddo
   end subroutine fmeq_c1fm

   subroutine fmeq_fm1fm(ma, mb)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(mb)
      n = size(ma)
      call fmeq(mb%mfm, mtlvfm)
      do j = 1, n
         call fmeq(mtlvfm, ma(j)%mfm)
      enddo
   end subroutine fmeq_fm1fm

   subroutine fmeq_fm1im(ma, mb)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (im) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(mb)
      n = size(ma)
      call imi2fm(mb%mim, mtlvfm)
      do j = 1, n
         call fmeq(mtlvfm, ma(j)%mfm)
      enddo
   end subroutine fmeq_fm1im

   subroutine fmeq_fm1zm(ma, mb)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(mb)
      n = size(ma)
      call zmreal(mb%mzm, mtlvfm)
      do j = 1, n
         call fmeq(mtlvfm, ma(j)%mfm)
      enddo
   end subroutine fmeq_fm1zm

   subroutine fmeq_im1fm(ma, mb)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvim
      call fm_undef_inp(mb)
      n = size(ma)
      call imfm2i(mb%mfm, mtlvim)
      do j = 1, n
         call imeq(mtlvim, ma(j)%mim)
      enddo
   end subroutine fmeq_im1fm

   subroutine fmeq_zm1fm(ma, mb)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (fm) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(mb)
      n = size(ma)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm)
      do j = 1, n
         call zmeq(mtlvzm, ma(j)%mzm)
      enddo
   end subroutine fmeq_zm1fm

!             (2) rank 1  =  rank 1

   subroutine fmeq_fm1i1(ma, ival)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      integer, dimension(:) :: ival
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: ival
      type(multi), save :: mtlvfm
      if (size(ma) /= size(ival)) then
          call fmunknown(mtlvfm)
          do j = 1, size(ma)
             call fmeq(mtlvfm, ma(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmi2m(ival(j), ma(j)%mfm)
      enddo
   end subroutine fmeq_fm1i1

   subroutine fmeq_fm1r1(ma, r)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      integer :: j, n
      real, dimension(:) :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi), save :: mtlvfm
      if (size(ma) /= size(r)) then
          call fmunknown(mtlvfm)
          do j = 1, size(ma)
             call fmeq(mtlvfm, ma(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(r(j), ma(j)%mfm)
      enddo
   end subroutine fmeq_fm1r1

   subroutine fmeq_fm1d1(ma, d)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      integer :: j, n
      double precision, dimension(:) :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi), save :: mtlvfm
      if (size(ma) /= size(d)) then
          call fmunknown(mtlvfm)
          do j = 1, size(ma)
             call fmeq(mtlvfm, ma(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(d(j), ma(j)%mfm)
      enddo
   end subroutine fmeq_fm1d1

   subroutine fmeq_fm1z1(ma, z)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      integer :: j, n
      complex, dimension(:) :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi), save :: mtlvfm
      if (size(ma) /= size(z)) then
          call fmunknown(mtlvfm)
          do j = 1, size(ma)
             call fmeq(mtlvfm, ma(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(real(z(j)), ma(j)%mfm)
      enddo
   end subroutine fmeq_fm1z1

   subroutine fmeq_fm1c1(ma, c)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (inout) :: ma
      intent (in) :: c
      type(multi), save :: mtlvfm
      if (size(ma) /= size(c)) then
          call fmunknown(mtlvfm)
          do j = 1, size(ma)
             call fmeq(mtlvfm, ma(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), ma(j)%mfm)
      enddo
   end subroutine fmeq_fm1c1

   subroutine fmeq_i1fm1(ival, ma)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      integer, dimension(:) :: ival
      integer :: j, n
      intent (inout) :: ival
      intent (in) :: ma
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ival)
             ival(j) = iunkno
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call fmm2i(ma(j)%mfm, ival(j))
      enddo
   end subroutine fmeq_i1fm1

   subroutine fmeq_r1fm1(r, ma)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      real, dimension(:) :: r
      integer :: j, n
      intent (inout) :: r
      intent (in) :: ma
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(r)
             r(j) = runkno
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call fmm2sp(ma(j)%mfm, r(j))
      enddo
   end subroutine fmeq_r1fm1

   subroutine fmeq_d1fm1(d, ma)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      double precision, dimension(:) :: d
      integer :: j, n
      intent (inout) :: d
      intent (in) :: ma
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(d)
             d(j) = runkno
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call fmm2dp(ma(j)%mfm, d(j))
      enddo
   end subroutine fmeq_d1fm1

   subroutine fmeq_z1fm1(z, ma)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      complex, dimension(:) :: z
      real :: r
      integer :: j, n
      intent (inout) :: z
      intent (in) :: ma
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(z)
             z(j) = cmplx(runkno, runkno)
          enddo
          return
      endif
      n = size(z)
      do j = 1, n
         call fmm2sp(ma(j)%mfm, r)
         z(j) = cmplx(r, 0.0)
      enddo
   end subroutine fmeq_z1fm1

   subroutine fmeq_c1fm1(c, ma)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      real (kind(0.0d0)) :: d
      integer :: j, n
      intent (inout) :: c
      intent (in) :: ma
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(c)
             d = runkno
             c(j) = cmplx(d, d , kind(0.0d0))
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call fmm2dp(ma(j)%mfm, d)
         c(j) = cmplx(d, 0.0d0 , kind(0.0d0))
      enddo
   end subroutine fmeq_c1fm1

   subroutine fmeq_fm1fm1(ma, mb)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (fm), allocatable, dimension(:) :: temp
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          call fmunknown(mtlvfm)
          do j = 1, size(ma)
             call fmeq(mtlvfm, ma(j)%mfm)
          enddo
          return
      endif
      n = size(ma)

!             To avoid problems when lhs and rhs are overlapping parts of the same array, move mb
!             to a temporary array before re-defining any of ma.

      allocate(temp(n))
      do j = 1, n
         call fmeq(mb(j)%mfm, temp(j)%mfm)
      enddo
      do j = 1, n
         call fmeq(temp(j)%mfm, ma(j)%mfm)
      enddo
      deallocate(temp)
   end subroutine fmeq_fm1fm1

   subroutine fmeq_fm1im1(ma, mb)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (im), dimension(:) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          call fmunknown(mtlvfm)
          do j = 1, size(ma)
             call fmeq(mtlvfm, ma(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2fm(mb(j)%mim, ma(j)%mfm)
      enddo
   end subroutine fmeq_fm1im1

   subroutine fmeq_fm1zm1(ma, mb)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          call fmunknown(mtlvfm)
          do j = 1, size(ma)
             call fmeq(mtlvfm, ma(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmreal(mb(j)%mzm, ma(j)%mfm)
      enddo
   end subroutine fmeq_fm1zm1

   subroutine fmeq_im1fm1(ma, mb)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvim
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          call imunknown(mtlvim)
          do j = 1, size(ma)
             call imeq(mtlvim, ma(j)%mim)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imfm2i(mb(j)%mfm, ma(j)%mim)
      enddo
   end subroutine fmeq_im1fm1

   subroutine fmeq_zm1fm1(ma, mb)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          call zmunknown(mtlvzm)
          do j = 1, size(ma)
             call zmeq(mtlvzm, ma(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call zmcmpx(mb(j)%mfm, mtlvfm, ma(j)%mzm)
      enddo
   end subroutine fmeq_zm1fm1

!             (3) rank 2  =  rank 0

   subroutine fmeq_fm2i(ma, ival)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      integer :: ival, j, k
      intent (inout) :: ma
      intent (in) :: ival
      type(multi), save :: mtlvfm
      call fmi2m(ival, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(mtlvfm, ma(j, k)%mfm)
         enddo
      enddo
   end subroutine fmeq_fm2i

   subroutine fmeq_fm2r(ma, r)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      integer :: j, k
      real :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi), save :: mtlvfm
      call fmsp2m(r, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(mtlvfm, ma(j, k)%mfm)
         enddo
      enddo
   end subroutine fmeq_fm2r

   subroutine fmeq_fm2d(ma, d)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      integer :: j, k
      double precision :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi), save :: mtlvfm
      call fmdp2m(d, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(mtlvfm, ma(j, k)%mfm)
         enddo
      enddo
   end subroutine fmeq_fm2d

   subroutine fmeq_fm2z(ma, z)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      integer :: j, k
      complex :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi), save :: mtlvfm
      call fmsp2m(real(z), mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(mtlvfm, ma(j, k)%mfm)
         enddo
      enddo
   end subroutine fmeq_fm2z

   subroutine fmeq_fm2c(ma, c)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (inout) :: ma
      intent (in) :: c
      type(multi), save :: mtlvfm
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(mtlvfm, ma(j, k)%mfm)
         enddo
      enddo
   end subroutine fmeq_fm2c

   subroutine fmeq_i2fm(ival, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      integer, dimension(:,:) :: ival
      integer :: j, k, l
      intent (inout) :: ival
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmm2i(ma%mfm, l)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            ival(j, k) = l
         enddo
      enddo
   end subroutine fmeq_i2fm

   subroutine fmeq_r2fm(r, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      real, dimension(:,:) :: r
      real :: r2
      integer :: j, k
      intent (inout) :: r
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmm2sp(ma%mfm, r2)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            r(j, k) = r2
         enddo
      enddo
   end subroutine fmeq_r2fm

   subroutine fmeq_d2fm(d, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      double precision, dimension(:,:) :: d
      double precision :: d2
      integer :: j, k
      intent (inout) :: d
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmm2dp(ma%mfm, d2)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            d(j, k) = d2
         enddo
      enddo
   end subroutine fmeq_d2fm

   subroutine fmeq_z2fm(z, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      complex, dimension(:,:) :: z
      real :: r2
      integer :: j, k
      intent (inout) :: z
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmm2sp(ma%mfm, r2)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            z(j, k) = r2
         enddo
      enddo
   end subroutine fmeq_z2fm

   subroutine fmeq_c2fm(c, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      double precision :: d2
      integer :: j, k
      intent (inout) :: c
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmm2dp(ma%mfm, d2)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            c(j, k) = d2
         enddo
      enddo
   end subroutine fmeq_c2fm

   subroutine fmeq_fm2fm(ma, mb)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(mb)
      call fmeq(mb%mfm, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(mtlvfm, ma(j, k)%mfm)
         enddo
      enddo
   end subroutine fmeq_fm2fm

   subroutine fmeq_fm2im(ma, mb)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(mtlvfm, ma(j, k)%mfm)
         enddo
      enddo
   end subroutine fmeq_fm2im

   subroutine fmeq_fm2zm(ma, mb)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(mb)
      call zmreal(mb%mzm, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(mtlvfm, ma(j, k)%mfm)
         enddo
      enddo
   end subroutine fmeq_fm2zm

   subroutine fmeq_im2fm(ma, mb)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvim
      call fm_undef_inp(mb)
      call imfm2i(mb%mfm, mtlvim)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(mtlvim, ma(j, k)%mim)
         enddo
      enddo
   end subroutine fmeq_im2fm

   subroutine fmeq_zm2fm(ma, mb)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(mtlvzm, ma(j, k)%mzm)
         enddo
      enddo
   end subroutine fmeq_zm2fm

!             (4) rank 2  =  rank 2

   subroutine fmeq_fm2i2(ma, ival)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: ival
      type(multi), save :: mtlvfm
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          call fmunknown(mtlvfm)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmeq(mtlvfm, ma(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), ma(j, k)%mfm)
         enddo
      enddo
   end subroutine fmeq_fm2i2

   subroutine fmeq_fm2r2(ma, r)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      integer :: j, k
      real, dimension(:,:) :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi), save :: mtlvfm
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          call fmunknown(mtlvfm)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmeq(mtlvfm, ma(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), ma(j, k)%mfm)
         enddo
      enddo
   end subroutine fmeq_fm2r2

   subroutine fmeq_fm2d2(ma, d)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi), save :: mtlvfm
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          call fmunknown(mtlvfm)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmeq(mtlvfm, ma(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), ma(j, k)%mfm)
         enddo
      enddo
   end subroutine fmeq_fm2d2

   subroutine fmeq_fm2z2(ma, z)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi), save :: mtlvfm
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          call fmunknown(mtlvfm)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmeq(mtlvfm, ma(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(real(z(j, k)), ma(j, k)%mfm)
         enddo
      enddo
   end subroutine fmeq_fm2z2

   subroutine fmeq_fm2c2(ma, c)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (inout) :: ma
      intent (in) :: c
      type(multi), save :: mtlvfm
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          call fmunknown(mtlvfm)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmeq(mtlvfm, ma(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), ma(j, k)%mfm)
         enddo
      enddo
   end subroutine fmeq_fm2c2

   subroutine fmeq_i2fm2(ival, ma)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (inout) :: ival
      intent (in) :: ma
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ival, dim=1)
             do k = 1, size(ival, dim=2)
                ival(j, k) = iunkno
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2i(ma(j, k)%mfm, ival(j, k))
         enddo
      enddo
   end subroutine fmeq_i2fm2

   subroutine fmeq_r2fm2(r, ma)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      integer :: j, k
      intent (inout) :: r
      intent (in) :: ma
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(r, dim=1)
             do k = 1, size(r, dim=2)
                r(j, k) = runkno
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2sp(ma(j, k)%mfm, r(j, k))
         enddo
      enddo
   end subroutine fmeq_r2fm2

   subroutine fmeq_d2fm2(d, ma)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      integer :: j, k
      intent (inout) :: d
      intent (in) :: ma
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(d, dim=1)
             do k = 1, size(d, dim=2)
                d(j, k) = runkno
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2dp(ma(j, k)%mfm, d(j, k))
         enddo
      enddo
   end subroutine fmeq_d2fm2

   subroutine fmeq_z2fm2(z, ma)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      real :: r
      integer :: j, k
      intent (inout) :: z
      intent (in) :: ma
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(z, dim=1)
             do k = 1, size(z, dim=2)
                z(j, k) = cmplx(runkno, runkno)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2sp(ma(j, k)%mfm, r)
            z(j, k) = cmplx(r, 0.0)
         enddo
      enddo
   end subroutine fmeq_z2fm2

   subroutine fmeq_c2fm2(c, ma)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      real (kind(0.0d0)) :: d
      integer :: j, k
      intent (inout) :: c
      intent (in) :: ma
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(c, dim=1)
             do k = 1, size(c, dim=2)
                d = runkno
                c(j, k) = cmplx(d, d , kind(0.0d0))
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmm2dp(ma(j, k)%mfm, d)
            c(j, k) = cmplx(d, 0.0d0 , kind(0.0d0))
         enddo
      enddo
   end subroutine fmeq_c2fm2

   subroutine fmeq_fm2fm2(ma, mb)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), allocatable, dimension(:,:) :: temp
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          call fmunknown(mtlvfm)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmeq(mtlvfm, ma(j, k)%mfm)
             enddo
          enddo
          return
      endif

!             To avoid problems when lhs and rhs are overlapping parts of the same array, move mb
!             to a temporary array before re-defining any of ma.

      allocate(temp(size(ma, dim=1), size(ma, dim=2)))
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(mb(j, k)%mfm, temp(j, k)%mfm)
         enddo
      enddo
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(temp(j, k)%mfm, ma(j, k)%mfm)
         enddo
      enddo
      deallocate(temp)
   end subroutine fmeq_fm2fm2

   subroutine fmeq_fm2im2(ma, mb)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          call fmunknown(mtlvfm)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmeq(mtlvfm, ma(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(mb(j, k)%mim, ma(j, k)%mfm)
         enddo
      enddo
   end subroutine fmeq_fm2im2

   subroutine fmeq_fm2zm2(ma, mb)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          call fmunknown(mtlvfm)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmeq(mtlvfm, ma(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmreal(mb(j, k)%mzm, ma(j, k)%mfm)
         enddo
      enddo
   end subroutine fmeq_fm2zm2

   subroutine fmeq_im2fm2(ma, mb)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvim
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          call imunknown(mtlvim)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imeq(mtlvim, ma(j, k)%mim)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imfm2i(mb(j, k)%mfm, ma(j, k)%mim)
         enddo
      enddo
   end subroutine fmeq_im2fm2

   subroutine fmeq_zm2fm2(ma, mb)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          call zmunknown(mtlvzm)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmeq(mtlvzm, ma(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(mb(j, k)%mfm, mtlvfm, ma(j, k)%mzm)
         enddo
      enddo
   end subroutine fmeq_zm2fm2

!             Array equal assignments for IM.

!             (1) rank 1  =  rank 0

   subroutine fmeq_im1i(ma, ival)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      integer :: ival, j, n
      intent (inout) :: ma
      intent (in) :: ival
      type(multi), save :: mtlvim
      n = size(ma)
      call imi2m(ival, mtlvim)
      do j = 1, n
         call imeq(mtlvim, ma(j)%mim)
      enddo
   end subroutine fmeq_im1i

   subroutine fmeq_im1r(ma, r)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      integer :: j, n
      real :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi), save :: mtlvfm, mtlvim
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      call imfm2i(mtlvfm, mtlvim)
      do j = 1, n
         call imeq(mtlvim, ma(j)%mim)
      enddo
   end subroutine fmeq_im1r

   subroutine fmeq_im1d(ma, d)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      integer :: j, n
      double precision :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi), save :: mtlvfm, mtlvim
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      call imfm2i(mtlvfm, mtlvim)
      do j = 1, n
         call imeq(mtlvim, ma(j)%mim)
      enddo
   end subroutine fmeq_im1d

   subroutine fmeq_im1z(ma, z)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      integer :: j, n
      complex :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi), save :: mtlvfm, mtlvim
      n = size(ma)
      call fmsp2m(real(z), mtlvfm)
      call imfm2i(mtlvfm, mtlvim)
      do j = 1, n
         call imeq(mtlvim, ma(j)%mim)
      enddo
   end subroutine fmeq_im1z

   subroutine fmeq_im1c(ma, c)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (inout) :: ma
      intent (in) :: c
      type(multi), save :: mtlvfm, mtlvim
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call imfm2i(mtlvfm, mtlvim)
      do j = 1, n
         call imeq(mtlvim, ma(j)%mim)
      enddo
   end subroutine fmeq_im1c

   subroutine fmeq_i1im(ival, ma)
      use fmvals
      implicit none
      type (im) :: ma
      integer, dimension(:) :: ival
      integer :: j, k, n
      intent (inout) :: ival
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ival)
      call imm2i(ma%mim, k)
      do j = 1, n
         ival(j) = k
      enddo
   end subroutine fmeq_i1im

   subroutine fmeq_r1im(r, ma)
      use fmvals
      implicit none
      type (im) :: ma
      real, dimension(:) :: r
      real :: r2
      integer :: j, n
      intent (inout) :: r
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(r)
      call imi2fm(ma%mim, mtlvfm)
      call fmm2sp(mtlvfm, r2)
      do j = 1, n
         r(j) = r2
      enddo
   end subroutine fmeq_r1im

   subroutine fmeq_d1im(d, ma)
      use fmvals
      implicit none
      type (im) :: ma
      double precision, dimension(:) :: d
      double precision :: d2
      integer :: j, n
      intent (inout) :: d
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(d)
      call imi2fm(ma%mim, mtlvfm)
      call fmm2dp(mtlvfm, d2)
      do j = 1, n
         d(j) = d2
      enddo
   end subroutine fmeq_d1im

   subroutine fmeq_z1im(z, ma)
      use fmvals
      implicit none
      type (im) :: ma
      complex, dimension(:) :: z
      real :: r2
      integer :: j, n
      intent (inout) :: z
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(z)
      call imi2fm(ma%mim, mtlvfm)
      call fmm2sp(mtlvfm, r2)
      do j = 1, n
         z(j) = r2
      enddo
   end subroutine fmeq_z1im

   subroutine fmeq_c1im(c, ma)
      use fmvals
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      double precision :: d2
      integer :: j, n
      intent (inout) :: c
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(c)
      call imi2fm(ma%mim, mtlvfm)
      call fmm2dp(mtlvfm, d2)
      do j = 1, n
         c(j) = d2
      enddo
   end subroutine fmeq_c1im

   subroutine fmeq_im1im(ma, mb)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvim
      call fm_undef_inp(mb)
      n = size(ma)
      call imeq(mb%mim, mtlvim)
      do j = 1, n
         call imeq(mtlvim, ma(j)%mim)
      enddo
   end subroutine fmeq_im1im

   subroutine fmeq_im1zm(ma, mb)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm, mtlvim
      call fm_undef_inp(mb)
      n = size(ma)
      call zmreal(mb%mzm, mtlvfm)
      call imfm2i(mtlvfm, mtlvim)
      do j = 1, n
         call imeq(mtlvim, ma(j)%mim)
      enddo
   end subroutine fmeq_im1zm

   subroutine fmeq_zm1im(ma, mb)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (im) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(mb)
      n = size(ma)
      call imi2fm(mb%mim, mulvfm)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mulvfm, mtlvfm, mtlvzm)
      do j = 1, n
         call zmeq(mtlvzm, ma(j)%mzm)
      enddo
   end subroutine fmeq_zm1im

!             (2) rank 1  =  rank 1

   subroutine fmeq_im1i1(ma, ival)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      integer, dimension(:) :: ival
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: ival
      type(multi), save :: mtlvim
      if (size(ma) /= size(ival)) then
          call imunknown(mtlvim)
          do j = 1, size(ma)
             call imeq(mtlvim, ma(j)%mim)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2m(ival(j), ma(j)%mim)
      enddo
   end subroutine fmeq_im1i1

   subroutine fmeq_im1r1(ma, r)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      integer :: j, n
      real, dimension(:) :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi), save :: mtlvfm, mtlvim
      if (size(ma) /= size(r)) then
          call imunknown(mtlvim)
          do j = 1, size(ma)
             call imeq(mtlvim, ma(j)%mim)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call imfm2i(mtlvfm, ma(j)%mim)
      enddo
   end subroutine fmeq_im1r1

   subroutine fmeq_im1d1(ma, d)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      integer :: j, n
      double precision, dimension(:) :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi), save :: mtlvfm, mtlvim
      if (size(ma) /= size(d)) then
          call imunknown(mtlvim)
          do j = 1, size(ma)
             call imeq(mtlvim, ma(j)%mim)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call imfm2i(mtlvfm, ma(j)%mim)
      enddo
   end subroutine fmeq_im1d1

   subroutine fmeq_im1z1(ma, z)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      integer :: j, n
      complex, dimension(:) :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi), save :: mtlvfm, mtlvim
      if (size(ma) /= size(z)) then
          call imunknown(mtlvim)
          do j = 1, size(ma)
             call imeq(mtlvim, ma(j)%mim)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(real(z(j)), mtlvfm)
         call imfm2i(mtlvfm, ma(j)%mim)
      enddo
   end subroutine fmeq_im1z1

   subroutine fmeq_im1c1(ma, c)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (inout) :: ma
      intent (in) :: c
      type(multi), save :: mtlvfm, mtlvim
      if (size(ma) /= size(c)) then
          call imunknown(mtlvim)
          do j = 1, size(ma)
             call imeq(mtlvim, ma(j)%mim)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call imfm2i(mtlvfm, ma(j)%mim)
      enddo
   end subroutine fmeq_im1c1

   subroutine fmeq_i1im1(ival, ma)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      integer, dimension(:) :: ival
      integer :: j, n
      intent (inout) :: ival
      intent (in) :: ma
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             ival(j) = iunkno
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call imm2i(ma(j)%mim, ival(j))
      enddo
   end subroutine fmeq_i1im1

   subroutine fmeq_r1im1(r, ma)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      real, dimension(:) :: r
      integer :: j, n
      intent (inout) :: r
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             r(j) = runkno
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call fmm2sp(mtlvfm, r(j))
      enddo
   end subroutine fmeq_r1im1

   subroutine fmeq_d1im1(d, ma)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      double precision, dimension(:) :: d
      integer :: j, n
      intent (inout) :: d
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             d(j) = runkno
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call fmm2dp(mtlvfm, d(j))
      enddo
   end subroutine fmeq_d1im1

   subroutine fmeq_z1im1(z, ma)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      complex, dimension(:) :: z
      real :: r
      integer :: j, n
      intent (inout) :: z
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             z(j) = cmplx(runkno, runkno)
          enddo
          return
      endif
      n = size(z)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call fmm2sp(mtlvfm, r)
         z(j) = cmplx(r, 0.0)
      enddo
   end subroutine fmeq_z1im1

   subroutine fmeq_c1im1(c, ma)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      real (kind(0.0d0)) :: d
      integer :: j, n
      intent (inout) :: c
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             d = runkno
             c(j) = cmplx(d, d , kind(0.0d0))
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call fmm2dp(mtlvfm, d)
         c(j) = cmplx(d, 0.0d0 , kind(0.0d0))
      enddo
   end subroutine fmeq_c1im1

   subroutine fmeq_im1im1(ma, mb)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (im), allocatable, dimension(:) :: temp
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvim
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          call imunknown(mtlvim)
          do j = 1, size(ma)
             call imeq(mtlvim, ma(j)%mim)
          enddo
          return
      endif
      n = size(ma)

!             To avoid problems when lhs and rhs are overlapping parts of the same array, move mb
!             to a temporary array before re-defining any of ma.

      allocate(temp(n))
      do j = 1, n
         call imeq(mb(j)%mim, temp(j)%mim)
      enddo
      do j = 1, n
         call imeq(temp(j)%mim, ma(j)%mim)
      enddo
      deallocate(temp)
   end subroutine fmeq_im1im1

   subroutine fmeq_im1zm1(ma, mb)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm, mtlvim
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          call imunknown(mtlvim)
          do j = 1, size(ma)
             call imeq(mtlvim, ma(j)%mim)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmreal(mb(j)%mzm, mtlvfm)
         call imfm2i(mtlvfm, ma(j)%mim)
      enddo
   end subroutine fmeq_im1zm1

   subroutine fmeq_zm1im1(ma, mb)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (im), dimension(:) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          call zmunknown(mtlvzm)
          do j = 1, size(ma)
             call zmeq(mtlvzm, ma(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call imi2fm(mb(j)%mim, mulvfm)
         call zmcmpx(mulvfm, mtlvfm, ma(j)%mzm)
      enddo
   end subroutine fmeq_zm1im1

!             (3) rank 2  =  rank 0

   subroutine fmeq_im2i(ma, ival)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      integer :: ival, j, k
      intent (inout) :: ma
      intent (in) :: ival
      type(multi), save :: mtlvim
      call imi2m(ival, mtlvim)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(mtlvim, ma(j, k)%mim)
         enddo
      enddo
   end subroutine fmeq_im2i

   subroutine fmeq_im2r(ma, r)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      integer :: j, k
      real :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi), save :: mtlvfm, mtlvim
      call fmsp2m(r, mtlvfm)
      call imfm2i(mtlvfm, mtlvim)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(mtlvim, ma(j, k)%mim)
         enddo
      enddo
   end subroutine fmeq_im2r

   subroutine fmeq_im2d(ma, d)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      integer :: j, k
      double precision :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi), save :: mtlvfm, mtlvim
      call fmdp2m(d, mtlvfm)
      call imfm2i(mtlvfm, mtlvim)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(mtlvim, ma(j, k)%mim)
         enddo
      enddo
   end subroutine fmeq_im2d

   subroutine fmeq_im2z(ma, z)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      integer :: j, k
      complex :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi), save :: mtlvfm, mtlvim
      call fmsp2m(real(z), mtlvfm)
      call imfm2i(mtlvfm, mtlvim)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(mtlvim, ma(j, k)%mim)
         enddo
      enddo
   end subroutine fmeq_im2z

   subroutine fmeq_im2c(ma, c)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (inout) :: ma
      intent (in) :: c
      type(multi), save :: mtlvfm, mtlvim
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call imfm2i(mtlvfm, mtlvim)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(mtlvim, ma(j, k)%mim)
         enddo
      enddo
   end subroutine fmeq_im2c

   subroutine fmeq_i2im(ival, ma)
      use fmvals
      implicit none
      type (im) :: ma
      integer, dimension(:,:) :: ival
      integer :: j, k, l
      intent (inout) :: ival
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imm2i(ma%mim, l)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            ival(j, k) = l
         enddo
      enddo
   end subroutine fmeq_i2im

   subroutine fmeq_r2im(r, ma)
      use fmvals
      implicit none
      type (im) :: ma
      real, dimension(:,:) :: r
      real :: r2
      integer :: j, k
      intent (inout) :: r
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mtlvfm)
      call fmm2sp(mtlvfm, r2)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            r(j, k) = r2
         enddo
      enddo
   end subroutine fmeq_r2im

   subroutine fmeq_d2im(d, ma)
      use fmvals
      implicit none
      type (im) :: ma
      double precision, dimension(:,:) :: d
      double precision :: d2
      integer :: j, k
      intent (inout) :: d
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mtlvfm)
      call fmm2dp(mtlvfm, d2)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            d(j, k) = d2
         enddo
      enddo
   end subroutine fmeq_d2im

   subroutine fmeq_z2im(z, ma)
      use fmvals
      implicit none
      type (im) :: ma
      complex, dimension(:,:) :: z
      real :: r2
      integer :: j, k
      intent (inout) :: z
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mtlvfm)
      call fmm2sp(mtlvfm, r2)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            z(j, k) = r2
         enddo
      enddo
   end subroutine fmeq_z2im

   subroutine fmeq_c2im(c, ma)
      use fmvals
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      double precision :: d2
      integer :: j, k
      intent (inout) :: c
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mtlvfm)
      call fmm2dp(mtlvfm, d2)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            c(j, k) = d2
         enddo
      enddo
   end subroutine fmeq_c2im

   subroutine fmeq_im2im(ma, mb)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvim
      call fm_undef_inp(mb)
      call imeq(mb%mim, mtlvim)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(mtlvim, ma(j, k)%mim)
         enddo
      enddo
   end subroutine fmeq_im2im

   subroutine fmeq_im2zm(ma, mb)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm, mtlvim
      call fm_undef_inp(mb)
      call zmreal(mb%mzm, mtlvfm)
      call imfm2i(mtlvfm, mtlvim)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(mtlvim, ma(j, k)%mim)
         enddo
      enddo
   end subroutine fmeq_im2zm

   subroutine fmeq_zm2im(ma, mb)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, mulvfm)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mulvfm, mtlvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(mtlvzm, ma(j, k)%mzm)
         enddo
      enddo
   end subroutine fmeq_zm2im

!             (4) rank 2  =  rank 2

   subroutine fmeq_im2i2(ma, ival)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: ival
      type(multi), save :: mtlvim
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          call imunknown(mtlvim)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imeq(mtlvim, ma(j, k)%mim)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2m(ival(j, k), ma(j, k)%mim)
         enddo
      enddo
   end subroutine fmeq_im2i2

   subroutine fmeq_im2r2(ma, r)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      integer :: j, k
      real, dimension(:,:) :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi), save :: mtlvfm, mtlvim
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          call imunknown(mtlvim)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imeq(mtlvim, ma(j, k)%mim)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call imfm2i(mtlvfm, ma(j, k)%mim)
         enddo
      enddo
   end subroutine fmeq_im2r2

   subroutine fmeq_im2d2(ma, d)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi), save :: mtlvfm, mtlvim
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          call imunknown(mtlvim)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imeq(mtlvim, ma(j, k)%mim)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call imfm2i(mtlvfm, ma(j, k)%mim)
         enddo
      enddo
   end subroutine fmeq_im2d2

   subroutine fmeq_im2z2(ma, z)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi), save :: mtlvfm, mtlvim
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          call imunknown(mtlvim)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imeq(mtlvim, ma(j, k)%mim)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(real(z(j, k)), mtlvfm)
            call imfm2i(mtlvfm, ma(j, k)%mim)
         enddo
      enddo
   end subroutine fmeq_im2z2

   subroutine fmeq_im2c2(ma, c)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (inout) :: ma
      intent (in) :: c
      type(multi), save :: mtlvfm, mtlvim
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          call imunknown(mtlvim)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imeq(mtlvim, ma(j, k)%mim)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call imfm2i(mtlvfm, ma(j, k)%mim)
         enddo
      enddo
   end subroutine fmeq_im2c2

   subroutine fmeq_i2im2(ival, ma)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (inout) :: ival
      intent (in) :: ma
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                ival(j, k) = iunkno
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imm2i(ma(j, k)%mim, ival(j, k))
         enddo
      enddo
   end subroutine fmeq_i2im2

   subroutine fmeq_r2im2(r, ma)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      integer :: j, k
      intent (inout) :: r
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                r(j, k) = runkno
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call fmm2sp(mtlvfm, r(j, k))
         enddo
      enddo
   end subroutine fmeq_r2im2

   subroutine fmeq_d2im2(d, ma)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      integer :: j, k
      intent (inout) :: d
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                d(j, k) = runkno
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call fmm2dp(mtlvfm, d(j, k))
         enddo
      enddo
   end subroutine fmeq_d2im2

   subroutine fmeq_z2im2(z, ma)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      real :: r
      integer :: j, k
      intent (inout) :: z
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                z(j, k) = cmplx(runkno, runkno)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call fmm2sp(mtlvfm, r)
            z(j, k) = cmplx(r, 0.0)
         enddo
      enddo
   end subroutine fmeq_z2im2

   subroutine fmeq_c2im2(c, ma)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      real (kind(0.0d0)) :: d
      integer :: j, k
      intent (inout) :: c
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                d = runkno
                c(j, k) = cmplx(d, d , kind(0.0d0))
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call fmm2dp(mtlvfm, d)
            c(j, k) = cmplx(d, 0.0d0 , kind(0.0d0))
         enddo
      enddo
   end subroutine fmeq_c2im2

   subroutine fmeq_im2im2(ma, mb)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (im), allocatable, dimension(:,:) :: temp
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvim
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          call imunknown(mtlvim)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imeq(mtlvim, ma(j, k)%mim)
             enddo
          enddo
          return
      endif

!             To avoid problems when lhs and rhs are overlapping parts of the same array, move mb
!             to a temporary array before re-defining any of ma.

      allocate(temp(size(ma, dim=1), size(ma, dim=2)))
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(mb(j, k)%mim, temp(j, k)%mim)
         enddo
      enddo
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(temp(j, k)%mim, ma(j, k)%mim)
         enddo
      enddo
      deallocate(temp)
   end subroutine fmeq_im2im2

   subroutine fmeq_im2zm2(ma, mb)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm, mtlvim
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          call imunknown(mtlvim)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imeq(mtlvim, ma(j, k)%mim)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmreal(mb(j, k)%mzm, mtlvfm)
            call imfm2i(mtlvfm, ma(j, k)%mim)
         enddo
      enddo
   end subroutine fmeq_im2zm2

   subroutine fmeq_zm2im2(ma, mb)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          call zmunknown(mtlvzm)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmeq(mtlvzm, ma(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(mb(j, k)%mim, mulvfm)
            call zmcmpx(mulvfm, mtlvfm, ma(j, k)%mzm)
         enddo
      enddo
   end subroutine fmeq_zm2im2

!             Array equal assignments for ZM.

!             (1) rank 1  =  rank 0

   subroutine fmeq_zm1i(ma, ival)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      integer :: ival, j, n
      intent (inout) :: ma
      intent (in) :: ival
      type(multi), save :: mtlvzm(2)
      n = size(ma)
      call zmi2m(ival, mtlvzm)
      do j = 1, n
         call zmeq(mtlvzm, ma(j)%mzm)
      enddo
   end subroutine fmeq_zm1i

   subroutine fmeq_zm1r(ma, r)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      integer :: j, n
      real :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmeq(mtlvzm, ma(j)%mzm)
      enddo
   end subroutine fmeq_zm1r

   subroutine fmeq_zm1d(ma, d)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      integer :: j, n
      double precision :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmeq(mtlvzm, ma(j)%mzm)
      enddo
   end subroutine fmeq_zm1d

   subroutine fmeq_zm1z(ma, z)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      integer :: j, n
      complex :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi), save :: mtlvzm(2)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      do j = 1, n
         call zmeq(mtlvzm, ma(j)%mzm)
      enddo
   end subroutine fmeq_zm1z

   subroutine fmeq_zm1c(ma, c)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      integer :: j, n
      complex (kind(0.0d0)) :: c
      double precision :: d
      intent (inout) :: ma
      intent (in) :: c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      d = aimag(c)
      call fmdp2m(d, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmeq(mtlvzm, ma(j)%mzm)
      enddo
   end subroutine fmeq_zm1c

   subroutine fmeq_i1zm(ival, ma)
      use fmvals
      implicit none
      type (zm) :: ma
      integer, dimension(:) :: ival
      integer :: j, k, n
      intent (inout) :: ival
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ival)
      call zmm2i(ma%mzm, k)
      do j = 1, n
         ival(j) = k
      enddo
   end subroutine fmeq_i1zm

   subroutine fmeq_r1zm(r, ma)
      use fmvals
      implicit none
      type (zm) :: ma
      real, dimension(:) :: r
      real :: r2
      integer :: j, n
      intent (inout) :: r
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(r)
      call zmreal(ma%mzm, mtlvfm)
      call fmm2sp(mtlvfm, r2)
      do j = 1, n
         r(j) = r2
      enddo
   end subroutine fmeq_r1zm

   subroutine fmeq_d1zm(d, ma)
      use fmvals
      implicit none
      type (zm) :: ma
      double precision, dimension(:) :: d
      double precision :: d2
      integer :: j, n
      intent (inout) :: d
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(d)
      call zmreal(ma%mzm, mtlvfm)
      call fmm2dp(mtlvfm, d2)
      do j = 1, n
         d(j) = d2
      enddo
   end subroutine fmeq_d1zm

   subroutine fmeq_z1zm(z, ma)
      use fmvals
      implicit none
      type (zm) :: ma
      complex, dimension(:) :: z
      complex :: z2
      integer :: j, n
      intent (inout) :: z
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(z)
      call zmm2z(ma%mzm, z2)
      do j = 1, n
         z(j) = z2
      enddo
   end subroutine fmeq_z1zm

   subroutine fmeq_c1zm(c, ma)
      use fmvals
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      double precision :: d2, d3
      integer :: j, n
      intent (inout) :: c
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(c)
      call zmreal(ma%mzm, mtlvfm)
      call fmm2dp(mtlvfm, d2)
      call zmimag(ma%mzm, mtlvfm)
      call fmm2dp(mtlvfm, d3)
      do j = 1, n
         c(j) = cmplx(d2, d3, kind(0.0d0))
      enddo
   end subroutine fmeq_c1zm

   subroutine fmeq_zm1zm(ma, mb)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm) :: mb
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(mb)
      n = size(ma)
      call zmeq(mb%mzm, mtlvzm)
      do j = 1, n
         call zmeq(mtlvzm, ma(j)%mzm)
      enddo
   end subroutine fmeq_zm1zm

!             (2) rank 1  =  rank 1

   subroutine fmeq_zm1i1(ma, ival)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      integer, dimension(:) :: ival
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: ival
      type(multi), save :: mtlvzm(2)
      if (size(ma) /= size(ival)) then
          call zmunknown(mtlvzm)
          do j = 1, size(ma)
             call zmeq(mtlvzm, ma(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmi2m(ival(j), ma(j)%mzm)
      enddo
   end subroutine fmeq_zm1i1

   subroutine fmeq_zm1r1(ma, r)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      integer :: j, n
      real, dimension(:) :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      if (size(ma) /= size(r)) then
          call zmunknown(mtlvzm)
          do j = 1, size(ma)
             call zmeq(mtlvzm, ma(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, ma(j)%mzm)
      enddo
   end subroutine fmeq_zm1r1

   subroutine fmeq_zm1d1(ma, d)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      integer :: j, n
      double precision, dimension(:) :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      if (size(ma) /= size(d)) then
          call zmunknown(mtlvzm)
          do j = 1, size(ma)
             call zmeq(mtlvzm, ma(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, ma(j)%mzm)
      enddo
   end subroutine fmeq_zm1d1

   subroutine fmeq_zm1z1(ma, z)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      integer :: j, n
      complex, dimension(:) :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi), save :: mtlvzm(2)
      if (size(ma) /= size(z)) then
          call zmunknown(mtlvzm)
          do j = 1, size(ma)
             call zmeq(mtlvzm, ma(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmz2m(z(j), ma(j)%mzm)
      enddo
   end subroutine fmeq_zm1z1

   subroutine fmeq_zm1c1(ma, c)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      double precision :: d
      intent (inout) :: ma
      intent (in) :: c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      if (size(ma) /= size(c)) then
          call zmunknown(mtlvzm)
          do j = 1, size(ma)
             call zmeq(mtlvzm, ma(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         d = aimag(c(j))
         call fmdp2m(d, mulvfm)
         call zmcmpx(mtlvfm, mulvfm, ma(j)%mzm)
      enddo
   end subroutine fmeq_zm1c1

   subroutine fmeq_i1zm1(ival, ma)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      integer, dimension(:) :: ival
      integer :: j, n
      intent (inout) :: ival
      intent (in) :: ma
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             ival(j) = iunkno
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call zmm2i(ma(j)%mzm, ival(j))
      enddo
   end subroutine fmeq_i1zm1

   subroutine fmeq_r1zm1(r, ma)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      real, dimension(:) :: r
      integer :: j, n
      intent (inout) :: r
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             r(j) = runkno
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call zmreal(ma(j)%mzm, mtlvfm)
         call fmm2sp(mtlvfm, r(j))
      enddo
   end subroutine fmeq_r1zm1

   subroutine fmeq_d1zm1(d, ma)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      double precision, dimension(:) :: d
      integer :: j, n
      intent (inout) :: d
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             d(j) = runkno
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call zmreal(ma(j)%mzm, mtlvfm)
         call fmm2dp(mtlvfm, d(j))
      enddo
   end subroutine fmeq_d1zm1

   subroutine fmeq_z1zm1(z, ma)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      complex, dimension(:) :: z
      integer :: j, n
      intent (inout) :: z
      intent (in) :: ma
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             z(j) = cmplx(runkno, runkno)
          enddo
          return
      endif
      n = size(z)
      do j = 1, n
         call zmm2z(ma(j)%mzm, z(j))
      enddo
   end subroutine fmeq_z1zm1

   subroutine fmeq_c1zm1(c, ma)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      real (kind(0.0d0)) :: d, d1, d2
      integer :: j, n
      intent (inout) :: c
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             d = runkno
             c(j) = cmplx(d, d , kind(0.0d0))
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call zmreal(ma(j)%mzm, mtlvfm)
         call fmm2dp(mtlvfm, d1)
         call zmimag(ma(j)%mzm, mtlvfm)
         call fmm2dp(mtlvfm, d2)
         c(j) = cmplx(d1, d2 , kind(0.0d0))
      enddo
   end subroutine fmeq_c1zm1

   subroutine fmeq_zm1zm1(ma, mb)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), allocatable, dimension(:) :: temp
      integer :: j, n
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          call zmunknown(mtlvzm)
          do j = 1, size(ma)
             call zmeq(mtlvzm, ma(j)%mzm)
          enddo
          return
      endif
      n = size(ma)

!             To avoid problems when lhs and rhs are overlapping parts of the same array, move mb
!             to a temporary array before re-defining any of ma.

      allocate(temp(n))
      do j = 1, n
         call zmeq(mb(j)%mzm, temp(j)%mzm)
      enddo
      do j = 1, n
         call zmeq(temp(j)%mzm, ma(j)%mzm)
      enddo
      deallocate(temp)
   end subroutine fmeq_zm1zm1

!             (3) rank 2  =  rank 0

   subroutine fmeq_zm2i(ma, ival)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      integer :: ival, j, k
      intent (inout) :: ma
      intent (in) :: ival
      type(multi), save :: mtlvzm(2)
      call zmi2m(ival, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(mtlvzm, ma(j, k)%mzm)
         enddo
      enddo
   end subroutine fmeq_zm2i

   subroutine fmeq_zm2r(ma, r)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      integer :: j, k
      real :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(mtlvzm, ma(j, k)%mzm)
         enddo
      enddo
   end subroutine fmeq_zm2r

   subroutine fmeq_zm2d(ma, d)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      integer :: j, k
      double precision :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(mtlvzm, ma(j, k)%mzm)
         enddo
      enddo
   end subroutine fmeq_zm2d

   subroutine fmeq_zm2z(ma, z)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      integer :: j, k
      complex :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi), save :: mtlvzm(2)
      call zmz2m(z, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(mtlvzm, ma(j, k)%mzm)
         enddo
      enddo
   end subroutine fmeq_zm2z

   subroutine fmeq_zm2c(ma, c)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      integer :: j, k
      complex (kind(0.0d0)) :: c
      double precision :: d
      intent (inout) :: ma
      intent (in) :: c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      d = aimag(c)
      call fmdp2m(d, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(mtlvzm, ma(j, k)%mzm)
         enddo
      enddo
   end subroutine fmeq_zm2c

   subroutine fmeq_i2zm(ival, ma)
      use fmvals
      implicit none
      type (zm) :: ma
      integer, dimension(:,:) :: ival
      integer :: j, k, l
      intent (inout) :: ival
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmm2i(ma%mzm, l)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            ival(j, k) = l
         enddo
      enddo
   end subroutine fmeq_i2zm

   subroutine fmeq_r2zm(r, ma)
      use fmvals
      implicit none
      type (zm) :: ma
      real, dimension(:,:) :: r
      real :: r2
      integer :: j, k
      intent (inout) :: r
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call zmreal(ma%mzm, mtlvfm)
      call fmm2sp(mtlvfm, r2)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            r(j, k) = r2
         enddo
      enddo
   end subroutine fmeq_r2zm

   subroutine fmeq_d2zm(d, ma)
      use fmvals
      implicit none
      type (zm) :: ma
      double precision, dimension(:,:) :: d
      double precision :: d2
      integer :: j, k
      intent (inout) :: d
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call zmreal(ma%mzm, mtlvfm)
      call fmm2dp(mtlvfm, d2)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            d(j, k) = d2
         enddo
      enddo
   end subroutine fmeq_d2zm

   subroutine fmeq_z2zm(z, ma)
      use fmvals
      implicit none
      type (zm) :: ma
      complex, dimension(:,:) :: z
      complex :: z2
      integer :: j, k
      intent (inout) :: z
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmm2z(ma%mzm, z2)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            z(j, k) = z2
         enddo
      enddo
   end subroutine fmeq_z2zm

   subroutine fmeq_c2zm(c, ma)
      use fmvals
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      double precision :: d2, d3
      integer :: j, k
      intent (inout) :: c
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call zmreal(ma%mzm, mtlvfm)
      call fmm2dp(mtlvfm, d2)
      call zmimag(ma%mzm, mtlvfm)
      call fmm2dp(mtlvfm, d3)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            c(j, k) = cmplx(d2, d3, kind(0.0d0))
         enddo
      enddo
   end subroutine fmeq_c2zm

   subroutine fmeq_zm2zm(ma, mb)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm) :: mb
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(mb)
      call zmeq(mb%mzm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(mtlvzm, ma(j, k)%mzm)
         enddo
      enddo
   end subroutine fmeq_zm2zm

!             (4) rank 2  =  rank 2

   subroutine fmeq_zm2i2(ma, ival)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: ival
      type(multi), save :: mtlvzm(2)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          call zmunknown(mtlvzm)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmeq(mtlvzm, ma(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmi2m(ival(j, k), ma(j, k)%mzm)
         enddo
      enddo
   end subroutine fmeq_zm2i2

   subroutine fmeq_zm2r2(ma, r)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      integer :: j, k
      real, dimension(:,:) :: r
      intent (inout) :: ma
      intent (in) :: r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          call zmunknown(mtlvzm)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmeq(mtlvzm, ma(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, ma(j, k)%mzm)
         enddo
      enddo
   end subroutine fmeq_zm2r2

   subroutine fmeq_zm2d2(ma, d)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (inout) :: ma
      intent (in) :: d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          call zmunknown(mtlvzm)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmeq(mtlvzm, ma(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, ma(j, k)%mzm)
         enddo
      enddo
   end subroutine fmeq_zm2d2

   subroutine fmeq_zm2z2(ma, z)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (inout) :: ma
      intent (in) :: z
      type(multi), save :: mtlvzm(2)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          call zmunknown(mtlvzm)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmeq(mtlvzm, ma(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), ma(j, k)%mzm)
         enddo
      enddo
   end subroutine fmeq_zm2z2

   subroutine fmeq_zm2c2(ma, c)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      double precision :: d
      intent (inout) :: ma
      intent (in) :: c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          call zmunknown(mtlvzm)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmeq(mtlvzm, ma(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            d = aimag(c(j, k))
            call fmdp2m(d, mulvfm)
            call zmcmpx(mtlvfm, mulvfm, ma(j, k)%mzm)
         enddo
      enddo
   end subroutine fmeq_zm2c2

   subroutine fmeq_i2zm2(ival, ma)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (inout) :: ival
      intent (in) :: ma
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                ival(j, k) = iunkno
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmm2i(ma(j, k)%mzm, ival(j, k))
         enddo
      enddo
   end subroutine fmeq_i2zm2

   subroutine fmeq_r2zm2(r, ma)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      integer :: j, k
      intent (inout) :: r
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                r(j, k) = runkno
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmreal(ma(j, k)%mzm, mtlvfm)
            call fmm2sp(mtlvfm, r(j, k))
         enddo
      enddo
   end subroutine fmeq_r2zm2

   subroutine fmeq_d2zm2(d, ma)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      integer :: j, k
      intent (inout) :: d
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                d(j, k) = runkno
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmreal(ma(j, k)%mzm, mtlvfm)
            call fmm2dp(mtlvfm, d(j, k))
         enddo
      enddo
   end subroutine fmeq_d2zm2

   subroutine fmeq_z2zm2(z, ma)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      integer :: j, k
      intent (inout) :: z
      intent (in) :: ma
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                z(j, k) = cmplx(runkno, runkno)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmm2z(ma(j, k)%mzm, z(j, k))
         enddo
      enddo
   end subroutine fmeq_z2zm2

   subroutine fmeq_c2zm2(c, ma)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      real (kind(0.0d0)) :: d, d1, d2
      integer :: j, k
      intent (inout) :: c
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                d = runkno
                c(j, k) = cmplx(d, d , kind(0.0d0))
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmreal(ma(j, k)%mzm, mtlvfm)
            call fmm2dp(mtlvfm, d1)
            call zmimag(ma(j, k)%mzm, mtlvfm)
            call fmm2dp(mtlvfm, d2)
            c(j, k) = cmplx(d1, d2 , kind(0.0d0))
         enddo
      enddo
   end subroutine fmeq_c2zm2

   subroutine fmeq_zm2zm2(ma, mb)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), allocatable, dimension(:,:) :: temp
      integer :: j, k
      intent (inout) :: ma
      intent (in) :: mb
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          call zmunknown(mtlvzm)
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmeq(mtlvzm, ma(j, k)%mzm)
             enddo
          enddo
          return
      endif

!             To avoid problems when lhs and rhs are overlapping parts of the same array, move mb
!             to a temporary array before re-defining any of ma.

      allocate(temp(size(ma, dim=1), size(ma, dim=2)))
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(mb(j, k)%mzm, temp(j, k)%mzm)
         enddo
      enddo
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(temp(j, k)%mzm, ma(j, k)%mzm)
         enddo
      enddo
      deallocate(temp)
   end subroutine fmeq_zm2zm2

!                                                                  ==

   function fmleq_ifm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      return_value = fmcomp(mtlvfm, 'EQ', ma%mfm)
   end function fmleq_ifm

   function fmleq_iim(ival, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      return_value = imcomp(mtlvim, 'EQ', ma%mim)
   end function fmleq_iim

   function fmleq_izm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      call zmreal(ma%mzm, mulvfm)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm)
      call fmi2m(0, mtlvfm)
      call zmimag(ma%mzm, mulvfm)
      l2 = fmcomp(mtlvfm, 'EQ', mulvfm)
      return_value = l1.and.l2
   end function fmleq_izm

   function fmleq_rfm(r, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      return_value = fmcomp(mtlvfm, 'EQ', ma%mfm)
   end function fmleq_rfm

   function fmleq_rim(r, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mtlvfm, 'EQ', mulvfm)
      ndig = ndsave
   end function fmleq_rim

   function fmleq_rzm(r, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call zmreal(ma%mzm, mulvfm)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm)
      call fmi2m(0, mtlvfm)
      call zmimag(ma%mzm, mulvfm)
      l2 = fmcomp(mtlvfm, 'EQ', mulvfm)
      return_value = l1.and.l2
   end function fmleq_rzm

   function fmleq_dfm(d, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      return_value = fmcomp(mtlvfm, 'EQ', ma%mfm)
   end function fmleq_dfm

   function fmleq_dim(d, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: d, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mtlvfm, 'EQ', mulvfm)
      ndig = ndsave
   end function fmleq_dim

   function fmleq_dzm(d, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call zmreal(ma%mzm, mulvfm)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm)
      call fmi2m(0, mtlvfm)
      call zmimag(ma%mzm, mulvfm)
      l2 = fmcomp(mtlvfm, 'EQ', mulvfm)
      return_value = l1.and.l2
   end function fmleq_dzm

   function fmleq_zfm(z, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(real(z), mtlvfm)
      l1 = fmcomp(mtlvfm, 'EQ', ma%mfm)
      l2 = .true.
      if (aimag(z) /= 0.0) l2 = .false.
      return_value = l1.and.l2
   end function fmleq_zfm

   function fmleq_zim(z, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (im) :: ma
      complex :: z
      integer :: ka, ndsave
      intent (in) :: z, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmsp2m(real(z), mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm)
      ndig = ndsave
      l2 = .true.
      if (aimag(z) /= 0.0) l2 = .false.
      return_value = l1.and.l2
   end function fmleq_zim

   function fmleq_zzm(z, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call zmreal(mtlvzm, mtlvfm)
      call zmreal(ma%mzm, mulvfm)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm)
      call zmimag(mtlvzm, mtlvfm)
      call zmimag(ma%mzm, mulvfm)
      l2 = fmcomp(mtlvfm, 'EQ', mulvfm)
      return_value = l1.and.l2
   end function fmleq_zzm

   function fmleq_cfm(c, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      l1 = fmcomp(mtlvfm, 'EQ', ma%mfm)
      l2 = .true.
      if (aimag(c) /= 0.0) l2 = .false.
      return_value = l1.and.l2
   end function fmleq_cfm

   function fmleq_cim(c, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      integer :: ka, ndsave
      intent (in) :: c, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm)
      ndig = ndsave
      l2 = .true.
      if (aimag(c) /= 0.0) l2 = .false.
      return_value = l1.and.l2
   end function fmleq_cim

   function fmleq_czm(c, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call zmreal(ma%mzm, mulvfm)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm)
      call fmdp2m(aimag(c), mtlvfm)
      call zmimag(ma%mzm, mulvfm)
      l2 = fmcomp(mtlvfm, 'EQ', mulvfm)
      return_value = l1.and.l2
   end function fmleq_czm

   function fmleq_fmi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      return_value = fmcomp(ma%mfm, 'EQ', mtlvfm)
   end function fmleq_fmi

   function fmleq_fmr(ma, r)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      return_value = fmcomp(ma%mfm, 'EQ', mtlvfm)
   end function fmleq_fmr

   function fmleq_fmd(ma, d)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      return_value = fmcomp(ma%mfm, 'EQ', mtlvfm)
   end function fmleq_fmd

   function fmleq_fmz(ma, z)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(real(z), mtlvfm)
      l1 = fmcomp(ma%mfm, 'EQ', mtlvfm)
      l2 = .true.
      if (aimag(z) /= 0.0) l2 = .false.
      return_value = l1.and.l2
   end function fmleq_fmz

   function fmleq_fmc(ma, c)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      l1 = fmcomp(ma%mfm, 'EQ', mtlvfm)
      l2 = .true.
      if (aimag(c) /= 0.0) l2 = .false.
      return_value = l1.and.l2
   end function fmleq_fmc

   function fmleq_fmfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma, mb
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      return_value = fmcomp(ma%mfm, 'EQ', mb%mfm)
   end function fmleq_fmfm

   function fmleq_fmim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      type (im) :: mb
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmint(ma%mfm, mtlvfm)
      if (fmcomp(ma%mfm, 'EQ', mtlvfm)) then
          call imi2fm(mb%mim, mtlvfm)
          return_value = fmcomp(ma%mfm, 'EQ', mtlvfm)
      else
          return_value = .false.
      endif
   end function fmleq_fmim

   function fmleq_fmzm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: ma
      type (zm) :: mb
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmreal(mb%mzm, mtlvfm)
      l1 = fmcomp(ma%mfm, 'EQ', mtlvfm)
      l2 = .true.
      if (mb%mzm(2)%mp(3) /= 0) l2 = .false.
      return_value = l1.and.l2
   end function fmleq_fmzm

   function fmleq_imi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      return_value = imcomp(ma%mim, 'EQ', mtlvim)
   end function fmleq_imi

   function fmleq_imr(ma, r)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mulvfm, 'EQ', mtlvfm)
      ndig = ndsave
   end function fmleq_imr

   function fmleq_imd(ma, d)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mulvfm, 'EQ', mtlvfm)
      ndig = ndsave
   end function fmleq_imd

   function fmleq_imz(ma, z)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (im) :: ma
      complex :: z
      integer :: ka, ndsave
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmsp2m(real(z), mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      l1 = fmcomp(mulvfm, 'EQ', mtlvfm)
      ndig = ndsave
      l2 = .true.
      if (aimag(z) /= 0.0) l2 = .false.
      return_value = l1.and.l2
   end function fmleq_imz

   function fmleq_imc(ma, c)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      integer :: ka, ndsave
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      l1 = fmcomp(mulvfm, 'EQ', mtlvfm)
      ndig = ndsave
      l2 = .true.
      if (aimag(c) /= 0.0) l2 = .false.
      return_value = l1.and.l2
   end function fmleq_imc

   function fmleq_imfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      type (fm) :: mb
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmint(mb%mfm, mtlvfm)
      if (fmcomp(mb%mfm, 'EQ', mtlvfm)) then
          call imi2fm(ma%mim, mtlvfm)
          return_value = fmcomp(mb%mfm, 'EQ', mtlvfm)
      else
          return_value = .false.
      endif
   end function fmleq_imfm

   function fmleq_imim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma, mb
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      return_value = imcomp(ma%mim, 'EQ', mb%mim)
   end function fmleq_imim

   function fmleq_imzm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      type (zm) :: mb
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmreal(mb%mzm, mtlvfm)
      call fmint(mtlvfm, mulvfm)
      if (fmcomp(mulvfm, 'EQ', mtlvfm).and.mb%mzm(2)%mp(3) == 0) then
          call imi2fm(ma%mim, mulvfm)
          return_value = fmcomp(mulvfm, 'EQ', mtlvfm)
      else
          return_value = .false.
      endif
   end function fmleq_imzm

   function fmleq_zmi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (zm) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call zmreal(ma%mzm, mtlvfm)
      call fmint(mtlvfm, mulvfm)
      if (fmcomp(mulvfm, 'EQ', mtlvfm).and.ma%mzm(2)%mp(3) == 0) then
          call fmi2m(ival, mulvfm)
          return_value = fmcomp(mtlvfm, 'EQ', mulvfm)
      else
          return_value = .false.
      endif
   end function fmleq_zmi

   function fmleq_zmr(ma, r)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call zmreal(ma%mzm, mulvfm)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm)
      call fmi2m(0, mtlvfm)
      call zmimag(ma%mzm, mulvfm)
      l2 = fmcomp(mtlvfm, 'EQ', mulvfm)
      return_value = l1.and.l2
   end function fmleq_zmr

   function fmleq_zmd(ma, d)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call zmreal(ma%mzm, mulvfm)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm)
      call fmi2m(0, mtlvfm)
      call zmimag(ma%mzm, mulvfm)
      l2 = fmcomp(mtlvfm, 'EQ', mulvfm)
      return_value = l1.and.l2
   end function fmleq_zmd

   function fmleq_zmz(ma, z)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call zmreal(mtlvzm, mtlvfm)
      call zmreal(ma%mzm, mulvfm)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm)
      call zmimag(mtlvzm, mtlvfm)
      call zmimag(ma%mzm, mulvfm)
      l2 = fmcomp(mtlvfm, 'EQ', mulvfm)
      return_value = l1.and.l2
   end function fmleq_zmz

   function fmleq_zmc(ma, c)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call zmreal(ma%mzm, mulvfm)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm)
      call fmdp2m(aimag(c), mtlvfm)
      call zmimag(ma%mzm, mulvfm)
      l2 = fmcomp(mtlvfm, 'EQ', mulvfm)
      return_value = l1.and.l2
   end function fmleq_zmc

   function fmleq_zmfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: mb
      type (zm) :: ma
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmreal(ma%mzm, mtlvfm)
      l1 = fmcomp(mb%mfm, 'EQ', mtlvfm)
      l2 = .true.
      if (ma%mzm(2)%mp(3) /= 0) l2 = .false.
      return_value = l1.and.l2
   end function fmleq_zmfm

   function fmleq_zmim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: mb
      type (zm) :: ma
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmreal(ma%mzm, mtlvfm)
      call fmint(mtlvfm, mulvfm)
      if (fmcomp(mulvfm, 'EQ', mtlvfm).and.ma%mzm(2)%mp(3) == 0) then
          call imi2fm(mb%mim, mulvfm)
          return_value = fmcomp(mulvfm, 'EQ', mtlvfm)
      else
          return_value = .false.
      endif
   end function fmleq_zmim

   function fmleq_zmzm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma, mb
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmreal(ma%mzm, mtlvfm)
      call zmreal(mb%mzm, mulvfm)
      l1 = fmcomp(mtlvfm, 'EQ', mulvfm)
      call zmimag(ma%mzm, mtlvfm)
      call zmimag(mb%mzm, mulvfm)
      l2 = fmcomp(mtlvfm, 'EQ', mulvfm)
      return_value = l1.and.l2
   end function fmleq_zmzm

 end module fmzm_2

 module fmzm_3
    use fmzm_1

    interface operator (/=)
       module procedure fmlne_ifm
       module procedure fmlne_iim
       module procedure fmlne_izm
       module procedure fmlne_rfm
       module procedure fmlne_rim
       module procedure fmlne_rzm
       module procedure fmlne_dfm
       module procedure fmlne_dim
       module procedure fmlne_dzm
       module procedure fmlne_zfm
       module procedure fmlne_zim
       module procedure fmlne_zzm
       module procedure fmlne_cfm
       module procedure fmlne_cim
       module procedure fmlne_czm
       module procedure fmlne_fmi
       module procedure fmlne_fmr
       module procedure fmlne_fmd
       module procedure fmlne_fmz
       module procedure fmlne_fmc
       module procedure fmlne_fmfm
       module procedure fmlne_fmim
       module procedure fmlne_fmzm
       module procedure fmlne_imi
       module procedure fmlne_imr
       module procedure fmlne_imd
       module procedure fmlne_imz
       module procedure fmlne_imc
       module procedure fmlne_imfm
       module procedure fmlne_imim
       module procedure fmlne_imzm
       module procedure fmlne_zmi
       module procedure fmlne_zmr
       module procedure fmlne_zmd
       module procedure fmlne_zmz
       module procedure fmlne_zmc
       module procedure fmlne_zmfm
       module procedure fmlne_zmim
       module procedure fmlne_zmzm
    end interface

    interface operator (>)
       module procedure fmlgt_ifm
       module procedure fmlgt_iim
       module procedure fmlgt_rfm
       module procedure fmlgt_rim
       module procedure fmlgt_dfm
       module procedure fmlgt_dim
       module procedure fmlgt_fmi
       module procedure fmlgt_fmr
       module procedure fmlgt_fmd
       module procedure fmlgt_fmfm
       module procedure fmlgt_fmim
       module procedure fmlgt_imi
       module procedure fmlgt_imr
       module procedure fmlgt_imd
       module procedure fmlgt_imfm
       module procedure fmlgt_imim
    end interface

    interface operator (>=)
       module procedure fmlge_ifm
       module procedure fmlge_iim
       module procedure fmlge_rfm
       module procedure fmlge_rim
       module procedure fmlge_dfm
       module procedure fmlge_dim
       module procedure fmlge_fmi
       module procedure fmlge_fmr
       module procedure fmlge_fmd
       module procedure fmlge_fmfm
       module procedure fmlge_fmim
       module procedure fmlge_imi
       module procedure fmlge_imr
       module procedure fmlge_imd
       module procedure fmlge_imfm
       module procedure fmlge_imim
    end interface

    interface operator (<)
       module procedure fmllt_ifm
       module procedure fmllt_iim
       module procedure fmllt_rfm
       module procedure fmllt_rim
       module procedure fmllt_dfm
       module procedure fmllt_dim
       module procedure fmllt_fmi
       module procedure fmllt_fmr
       module procedure fmllt_fmd
       module procedure fmllt_fmfm
       module procedure fmllt_fmim
       module procedure fmllt_imi
       module procedure fmllt_imr
       module procedure fmllt_imd
       module procedure fmllt_imfm
       module procedure fmllt_imim
    end interface

    interface operator (<=)
       module procedure fmlle_ifm
       module procedure fmlle_iim
       module procedure fmlle_rfm
       module procedure fmlle_rim
       module procedure fmlle_dfm
       module procedure fmlle_dim
       module procedure fmlle_fmi
       module procedure fmlle_fmr
       module procedure fmlle_fmd
       module procedure fmlle_fmfm
       module procedure fmlle_fmim
       module procedure fmlle_imi
       module procedure fmlle_imr
       module procedure fmlle_imd
       module procedure fmlle_imfm
       module procedure fmlle_imim
    end interface

 contains

!                                                                  /=

   function fmlne_ifm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      return_value = fmcomp(mtlvfm, 'NE', ma%mfm)
   end function fmlne_ifm

   function fmlne_iim(ival, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      return_value = imcomp(mtlvim, 'NE', ma%mim)
   end function fmlne_iim

   function fmlne_izm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      call zmreal(ma%mzm, mulvfm)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm)
      call fmi2m(0, mtlvfm)
      call zmimag(ma%mzm, mulvfm)
      l2 = fmcomp(mtlvfm, 'NE', mulvfm)
      return_value = l1.or.l2
   end function fmlne_izm

   function fmlne_rfm(r, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      return_value = fmcomp(mtlvfm, 'NE', ma%mfm)
   end function fmlne_rfm

   function fmlne_rim(r, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      real :: r
      integer :: ka, ndsave
      intent (in) :: r, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mtlvfm, 'NE', mulvfm)
      ndig = ndsave
   end function fmlne_rim

   function fmlne_rzm(r, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call zmreal(ma%mzm, mulvfm)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm)
      call fmi2m(0, mtlvfm)
      call zmimag(ma%mzm, mulvfm)
      l2 = fmcomp(mtlvfm, 'NE', mulvfm)
      return_value = l1.or.l2
   end function fmlne_rzm

   function fmlne_dfm(d, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      return_value = fmcomp(mtlvfm, 'NE', ma%mfm)
   end function fmlne_dfm

   function fmlne_dim(d, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: d, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mtlvfm, 'NE', mulvfm)
      ndig = ndsave
   end function fmlne_dim

   function fmlne_dzm(d, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call zmreal(ma%mzm, mulvfm)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm)
      call fmi2m(0, mtlvfm)
      call zmimag(ma%mzm, mulvfm)
      l2 = fmcomp(mtlvfm, 'NE', mulvfm)
      return_value = l1.or.l2
   end function fmlne_dzm

   function fmlne_zfm(z, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(real(z), mtlvfm)
      l1 = fmcomp(mtlvfm, 'NE', ma%mfm)
      l2 = .false.
      if (aimag(z) /= 0.0) l2 = .true.
      return_value = l1.or.l2
   end function fmlne_zfm

   function fmlne_zim(z, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      complex :: z
      intent (in) :: z, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmsp2m(real(z), mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm)
      ndig = ndsave
      l2 = .false.
      if (aimag(z) /= 0.0) l2 = .true.
      return_value = l1.or.l2
   end function fmlne_zim

   function fmlne_zzm(z, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call zmreal(mtlvzm, mtlvfm)
      call zmreal(ma%mzm, mulvfm)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm)
      call zmimag(mtlvzm, mtlvfm)
      call zmimag(ma%mzm, mulvfm)
      l2 = fmcomp(mtlvfm, 'NE', mulvfm)
      return_value = l1.or.l2
   end function fmlne_zzm

   function fmlne_cfm(c, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      l1 = fmcomp(mtlvfm, 'NE', ma%mfm)
      l2 = .false.
      if (aimag(c) /= 0.0) l2 = .true.
      return_value = l1.or.l2
   end function fmlne_cfm

   function fmlne_cim(c, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      integer :: ka, ndsave
      intent (in) :: c, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm)
      ndig = ndsave
      l2 = .false.
      if (aimag(c) /= 0.0) l2 = .true.
      return_value = l1.or.l2
   end function fmlne_cim

   function fmlne_czm(c, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call zmreal(ma%mzm, mulvfm)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm)
      call fmdp2m(aimag(c), mtlvfm)
      call zmimag(ma%mzm, mulvfm)
      l2 = fmcomp(mtlvfm, 'NE', mulvfm)
      return_value = l1.or.l2
   end function fmlne_czm

   function fmlne_fmi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      return_value = fmcomp(ma%mfm, 'NE', mtlvfm)
   end function fmlne_fmi

   function fmlne_fmr(ma, r)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      return_value = fmcomp(ma%mfm, 'NE', mtlvfm)
   end function fmlne_fmr

   function fmlne_fmd(ma, d)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      return_value = fmcomp(ma%mfm, 'NE', mtlvfm)
   end function fmlne_fmd

   function fmlne_fmz(ma, z)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(real(z), mtlvfm)
      l1 = fmcomp(ma%mfm, 'NE', mtlvfm)
      l2 = .false.
      if (aimag(z) /= 0.0) l2 = .true.
      return_value = l1.or.l2
   end function fmlne_fmz

   function fmlne_fmc(ma, c)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      l1 = fmcomp(ma%mfm, 'NE', mtlvfm)
      l2 = .false.
      if (aimag(c) /= 0.0) l2 = .true.
      return_value = l1.or.l2
   end function fmlne_fmc

   function fmlne_fmfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma, mb
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      return_value = fmcomp(ma%mfm, 'NE', mb%mfm)
   end function fmlne_fmfm

   function fmlne_fmim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      type (im) :: mb
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmint(ma%mfm, mtlvfm)
      if (fmcomp(ma%mfm, 'EQ', mtlvfm)) then
          call imi2fm(mb%mim, mtlvfm)
          return_value = fmcomp(ma%mfm, 'NE', mtlvfm)
      else
          return_value = .true.
      endif
   end function fmlne_fmim

   function fmlne_fmzm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: ma
      type (zm) :: mb
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmreal(mb%mzm, mtlvfm)
      l1 = fmcomp(ma%mfm, 'NE', mtlvfm)
      l2 = .false.
      if (mb%mzm(2)%mp(3) /= 0) l2 = .true.
      return_value = l1.or.l2
   end function fmlne_fmzm

   function fmlne_imi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      return_value = imcomp(ma%mim, 'NE', mtlvim)
   end function fmlne_imi

   function fmlne_imr(ma, r)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mulvfm, 'NE', mtlvfm)
      ndig = ndsave
   end function fmlne_imr

   function fmlne_imd(ma, d)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mulvfm, 'NE', mtlvfm)
      ndig = ndsave
   end function fmlne_imd

   function fmlne_imz(ma, z)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmsp2m(real(z), mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      l1 = fmcomp(mulvfm, 'NE', mtlvfm)
      ndig = ndsave
      l2 = .false.
      if (aimag(z) /= 0.0) l2 = .true.
      return_value = l1.or.l2
   end function fmlne_imz

   function fmlne_imc(ma, c)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      integer :: ka, ndsave
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      l1 = fmcomp(mulvfm, 'NE', mtlvfm)
      ndig = ndsave
      l2 = .false.
      if (aimag(c) /= 0.0) l2 = .true.
      return_value = l1.or.l2
   end function fmlne_imc

   function fmlne_imfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      type (fm) :: mb
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmint(mb%mfm, mtlvfm)
      if (fmcomp(mb%mfm, 'EQ', mtlvfm)) then
          call imi2fm(ma%mim, mtlvfm)
          return_value = fmcomp(mb%mfm, 'NE', mtlvfm)
      else
          return_value = .true.
      endif
   end function fmlne_imfm

   function fmlne_imim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma, mb
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      return_value = imcomp(ma%mim, 'NE', mb%mim)
   end function fmlne_imim

   function fmlne_imzm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      type (zm) :: mb
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmreal(mb%mzm, mtlvfm)
      call fmint(mtlvfm, mulvfm)
      if (fmcomp(mulvfm, 'EQ', mtlvfm).and.mb%mzm(2)%mp(3) == 0) then
          call imi2fm(ma%mim, mulvfm)
          return_value = fmcomp(mulvfm, 'NE', mtlvfm)
      else
          return_value = .true.
      endif
   end function fmlne_imzm

   function fmlne_zmi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (zm) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call zmreal(ma%mzm, mtlvfm)
      call fmint(mtlvfm, mulvfm)
      if (fmcomp(mulvfm, 'EQ', mtlvfm).and.ma%mzm(2)%mp(3) == 0) then
          call fmi2m(ival, mulvfm)
          return_value = fmcomp(mtlvfm, 'NE', mulvfm)
      else
          return_value = .true.
      endif
   end function fmlne_zmi

   function fmlne_zmr(ma, r)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call zmreal(ma%mzm, mulvfm)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm)
      call fmi2m(0, mtlvfm)
      call zmimag(ma%mzm, mulvfm)
      l2 = fmcomp(mtlvfm, 'NE', mulvfm)
      return_value = l1.or.l2
   end function fmlne_zmr

   function fmlne_zmd(ma, d)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call zmreal(ma%mzm, mulvfm)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm)
      call fmi2m(0, mtlvfm)
      call zmimag(ma%mzm, mulvfm)
      l2 = fmcomp(mtlvfm, 'NE', mulvfm)
      return_value = l1.or.l2
   end function fmlne_zmd

   function fmlne_zmz(ma, z)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call zmreal(mtlvzm, mtlvfm)
      call zmreal(ma%mzm, mulvfm)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm)
      call zmimag(mtlvzm, mtlvfm)
      call zmimag(ma%mzm, mulvfm)
      l2 = fmcomp(mtlvfm, 'NE', mulvfm)
      return_value = l1.or.l2
   end function fmlne_zmz

   function fmlne_zmc(ma, c)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call zmreal(ma%mzm, mulvfm)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm)
      call fmdp2m(aimag(c), mtlvfm)
      call zmimag(ma%mzm, mulvfm)
      l2 = fmcomp(mtlvfm, 'NE', mulvfm)
      return_value = l1.or.l2
   end function fmlne_zmc

   function fmlne_zmfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (fm) :: mb
      type (zm) :: ma
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmreal(ma%mzm, mtlvfm)
      l1 = fmcomp(mb%mfm, 'NE', mtlvfm)
      l2 = .false.
      if (ma%mzm(2)%mp(3) /= 0) l2 = .true.
      return_value = l1.or.l2
   end function fmlne_zmfm

   function fmlne_zmim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: mb
      type (zm) :: ma
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmreal(ma%mzm, mtlvfm)
      call fmint(mtlvfm, mulvfm)
      if (fmcomp(mulvfm, 'EQ', mtlvfm).and.ma%mzm(2)%mp(3) == 0) then
          call imi2fm(mb%mim, mulvfm)
          return_value = fmcomp(mulvfm, 'NE', mtlvfm)
      else
          return_value = .true.
      endif
   end function fmlne_zmim

   function fmlne_zmzm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value, l1, l2
      logical, external :: fmcomp
      type (zm) :: ma, mb
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmreal(ma%mzm, mtlvfm)
      call zmreal(mb%mzm, mulvfm)
      l1 = fmcomp(mtlvfm, 'NE', mulvfm)
      call zmimag(ma%mzm, mtlvfm)
      call zmimag(mb%mzm, mulvfm)
      l2 = fmcomp(mtlvfm, 'NE', mulvfm)
      return_value = l1.or.l2
   end function fmlne_zmzm

!                                                                   >

   function fmlgt_ifm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      return_value = fmcomp(mtlvfm, 'GT', ma%mfm)
   end function fmlgt_ifm

   function fmlgt_iim(ival, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      return_value = imcomp(mtlvim, 'GT', ma%mim)
   end function fmlgt_iim

   function fmlgt_rfm(r, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      return_value = fmcomp(mtlvfm, 'GT', ma%mfm)
   end function fmlgt_rfm

   function fmlgt_rim(r, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mtlvfm, 'GT', mulvfm)
      ndig = ndsave
   end function fmlgt_rim

   function fmlgt_dfm(d, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      return_value = fmcomp(mtlvfm, 'GT', ma%mfm)
   end function fmlgt_dfm

   function fmlgt_dim(d, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: d, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mtlvfm, 'GT', mulvfm)
      ndig = ndsave
   end function fmlgt_dim

   function fmlgt_fmi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      return_value = fmcomp(ma%mfm, 'GT', mtlvfm)
   end function fmlgt_fmi

   function fmlgt_fmr(ma, r)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      return_value = fmcomp(ma%mfm, 'GT', mtlvfm)
   end function fmlgt_fmr

   function fmlgt_fmd(ma, d)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      return_value = fmcomp(ma%mfm, 'GT', mtlvfm)
   end function fmlgt_fmd

   function fmlgt_fmfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma, mb
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      return_value = fmcomp(ma%mfm, 'GT', mb%mfm)
   end function fmlgt_fmfm

   function fmlgt_fmim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      type (im) :: mb
      integer :: ka, ndsave
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      ndsave = ndig
      ka = mb%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call imi2fm(mb%mim, mtlvfm)
      return_value = fmcomp(ma%mfm, 'GT', mtlvfm)
      ndig = ndsave
   end function fmlgt_fmim

   function fmlgt_imi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      return_value = imcomp(ma%mim, 'GT', mtlvim)
   end function fmlgt_imi

   function fmlgt_imr(ma, r)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mulvfm, 'GT', mtlvfm)
      ndig = ndsave
   end function fmlgt_imr

   function fmlgt_imd(ma, d)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mulvfm, 'GT', mtlvfm)
      ndig = ndsave
   end function fmlgt_imd

   function fmlgt_imfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      type (fm) :: mb
      integer :: ka, ndsave
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call imi2fm(ma%mim, mtlvfm)
      return_value = fmcomp(mtlvfm, 'GT', mb%mfm)
      ndig = ndsave
   end function fmlgt_imfm

   function fmlgt_imim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma, mb
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      return_value = imcomp(ma%mim, 'GT', mb%mim)
   end function fmlgt_imim

!                                                                  >=

   function fmlge_ifm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      return_value = fmcomp(mtlvfm, 'GE', ma%mfm)
   end function fmlge_ifm

   function fmlge_iim(ival, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      return_value = imcomp(mtlvim, 'GE', ma%mim)
   end function fmlge_iim

   function fmlge_rfm(r, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      return_value = fmcomp(mtlvfm, 'GE', ma%mfm)
   end function fmlge_rfm

   function fmlge_rim(r, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mtlvfm, 'GE', mulvfm)
      ndig = ndsave
   end function fmlge_rim

   function fmlge_dfm(d, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      return_value = fmcomp(mtlvfm, 'GE', ma%mfm)
   end function fmlge_dfm

   function fmlge_dim(d, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: d, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mtlvfm, 'GE', mulvfm)
      ndig = ndsave
   end function fmlge_dim

   function fmlge_fmi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      return_value = fmcomp(ma%mfm, 'GE', mtlvfm)
   end function fmlge_fmi

   function fmlge_fmr(ma, r)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      return_value = fmcomp(ma%mfm, 'GE', mtlvfm)
   end function fmlge_fmr

   function fmlge_fmd(ma, d)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      return_value = fmcomp(ma%mfm, 'GE', mtlvfm)
   end function fmlge_fmd

   function fmlge_fmfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma, mb
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      return_value = fmcomp(ma%mfm, 'GE', mb%mfm)
   end function fmlge_fmfm

   function fmlge_fmim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      type (im) :: mb
      integer :: ka, ndsave
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      ndsave = ndig
      ka = mb%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call imi2fm(mb%mim, mtlvfm)
      return_value = fmcomp(ma%mfm, 'GE', mtlvfm)
      ndig = ndsave
   end function fmlge_fmim

   function fmlge_imi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      return_value = imcomp(ma%mim, 'GE', mtlvim)
   end function fmlge_imi

   function fmlge_imr(ma, r)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mulvfm, 'GE', mtlvfm)
      ndig = ndsave
   end function fmlge_imr

   function fmlge_imd(ma, d)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mulvfm, 'GE', mtlvfm)
      ndig = ndsave
   end function fmlge_imd

   function fmlge_imfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      type (fm) :: mb
      integer :: ka, ndsave
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call imi2fm(ma%mim, mtlvfm)
      return_value = fmcomp(mtlvfm, 'GE', mb%mfm)
      ndig = ndsave
   end function fmlge_imfm

   function fmlge_imim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma, mb
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      return_value = imcomp(ma%mim, 'GE', mb%mim)
   end function fmlge_imim

!                                                                   <

   function fmllt_ifm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      return_value = fmcomp(mtlvfm, 'LT', ma%mfm)
   end function fmllt_ifm

   function fmllt_iim(ival, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      return_value = imcomp(mtlvim, 'LT', ma%mim)
   end function fmllt_iim

   function fmllt_rfm(r, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      return_value = fmcomp(mtlvfm, 'LT', ma%mfm)
   end function fmllt_rfm

   function fmllt_rim(r, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mtlvfm, 'LT', mulvfm)
      ndig = ndsave
   end function fmllt_rim

   function fmllt_dfm(d, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      return_value = fmcomp(mtlvfm, 'LT', ma%mfm)
   end function fmllt_dfm

   function fmllt_dim(d, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: d, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mtlvfm, 'LT', mulvfm)
      ndig = ndsave
   end function fmllt_dim

   function fmllt_fmi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      return_value = fmcomp(ma%mfm, 'LT', mtlvfm)
   end function fmllt_fmi

   function fmllt_fmr(ma, r)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      return_value = fmcomp(ma%mfm, 'LT', mtlvfm)
   end function fmllt_fmr

   function fmllt_fmd(ma, d)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      return_value = fmcomp(ma%mfm, 'LT', mtlvfm)
   end function fmllt_fmd

   function fmllt_fmfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma, mb
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      return_value = fmcomp(ma%mfm, 'LT', mb%mfm)
   end function fmllt_fmfm

   function fmllt_fmim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      type (im) :: mb
      integer :: ka, ndsave
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      ndsave = ndig
      ka = mb%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call imi2fm(mb%mim, mtlvfm)
      return_value = fmcomp(ma%mfm, 'LT', mtlvfm)
      ndig = ndsave
   end function fmllt_fmim

   function fmllt_imi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      return_value = imcomp(ma%mim, 'LT', mtlvim)
   end function fmllt_imi

   function fmllt_imr(ma, r)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mulvfm, 'LT', mtlvfm)
      ndig = ndsave
   end function fmllt_imr

   function fmllt_imd(ma, d)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mulvfm, 'LT', mtlvfm)
      ndig = ndsave
   end function fmllt_imd

   function fmllt_imfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      type (fm) :: mb
      integer :: ka, ndsave
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call imi2fm(ma%mim, mtlvfm)
      return_value = fmcomp(mtlvfm, 'LT', mb%mfm)
      ndig = ndsave
   end function fmllt_imfm

   function fmllt_imim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma, mb
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      return_value = imcomp(ma%mim, 'LT', mb%mim)
   end function fmllt_imim

!                                                                  <=

   function fmlle_ifm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      return_value = fmcomp(mtlvfm, 'LE', ma%mfm)
   end function fmlle_ifm

   function fmlle_iim(ival, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      return_value = imcomp(mtlvim, 'LE', ma%mim)
   end function fmlle_iim

   function fmlle_rfm(r, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      return_value = fmcomp(mtlvfm, 'LE', ma%mfm)
   end function fmlle_rfm

   function fmlle_rim(r, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mtlvfm, 'LE', mulvfm)
      ndig = ndsave
   end function fmlle_rim

   function fmlle_dfm(d, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      return_value = fmcomp(mtlvfm, 'LE', ma%mfm)
   end function fmlle_dfm

   function fmlle_dim(d, ma)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: d, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mtlvfm, 'LE', mulvfm)
      ndig = ndsave
   end function fmlle_dim

   function fmlle_fmi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      return_value = fmcomp(ma%mfm, 'LE', mtlvfm)
   end function fmlle_fmi

   function fmlle_fmr(ma, r)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      return_value = fmcomp(ma%mfm, 'LE', mtlvfm)
   end function fmlle_fmr

   function fmlle_fmd(ma, d)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      return_value = fmcomp(ma%mfm, 'LE', mtlvfm)
   end function fmlle_fmd

   function fmlle_fmfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma, mb
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      return_value = fmcomp(ma%mfm, 'LE', mb%mfm)
   end function fmlle_fmfm

   function fmlle_fmim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma
      type (im) :: mb
      integer :: ka, ndsave
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      ndsave = ndig
      ka = mb%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call imi2fm(mb%mim, mtlvfm)
      return_value = fmcomp(ma%mfm, 'LE', mtlvfm)
      ndig = ndsave
   end function fmlle_fmim

   function fmlle_imi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma
      integer :: ival
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      return_value = imcomp(ma%mim, 'LE', mtlvim)
   end function fmlle_imi

   function fmlle_imr(ma, r)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      integer :: ka, ndsave
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mulvfm, 'LE', mtlvfm)
      ndig = ndsave
   end function fmlle_imr

   function fmlle_imd(ma, d)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      double precision :: d
      integer :: ka, ndsave
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      return_value = fmcomp(mulvfm, 'LE', mtlvfm)
      ndig = ndsave
   end function fmlle_imd

   function fmlle_imfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (im) :: ma
      type (fm) :: mb
      integer :: ka, ndsave
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      ndsave = ndig
      ka = ma%mim%mp(2)
      ndig = max(ka+ngrd52, ndig)
      call imi2fm(ma%mim, mtlvfm)
      return_value = fmcomp(mtlvfm, 'LE', mb%mfm)
      ndig = ndsave
   end function fmlle_imfm

   function fmlle_imim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma, mb
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      return_value = imcomp(ma%mim, 'LE', mb%mim)
   end function fmlle_imim

 end module fmzm_3

 module fmzm_4
    use fmzm_1

    interface operator (+)
       module procedure fmadd_ifm
       module procedure fmadd_iim
       module procedure fmadd_izm
       module procedure fmadd_rfm
       module procedure fmadd_rim
       module procedure fmadd_rzm
       module procedure fmadd_dfm
       module procedure fmadd_dim
       module procedure fmadd_dzm
       module procedure fmadd_zfm
       module procedure fmadd_zim
       module procedure fmadd_zzm
       module procedure fmadd_cfm
       module procedure fmadd_cim
       module procedure fmadd_czm
       module procedure fmadd_fmi
       module procedure fmadd_fmr
       module procedure fmadd_fmd
       module procedure fmadd_fmz
       module procedure fmadd_fmc
       module procedure fmadd_fmfm
       module procedure fmadd_fmim
       module procedure fmadd_fmzm
       module procedure fmadd_imi
       module procedure fmadd_imr
       module procedure fmadd_imd
       module procedure fmadd_imz
       module procedure fmadd_imc
       module procedure fmadd_imfm
       module procedure fmadd_imim
       module procedure fmadd_imzm
       module procedure fmadd_zmi
       module procedure fmadd_zmr
       module procedure fmadd_zmd
       module procedure fmadd_zmz
       module procedure fmadd_zmc
       module procedure fmadd_zmfm
       module procedure fmadd_zmim
       module procedure fmadd_zmzm
       module procedure fmadd_fm
       module procedure fmadd_im
       module procedure fmadd_zm
       module procedure fmadd_ifm1
       module procedure fmadd_rfm1
       module procedure fmadd_dfm1
       module procedure fmadd_zfm1
       module procedure fmadd_cfm1
       module procedure fmadd_fmi1
       module procedure fmadd_fmr1
       module procedure fmadd_fmd1
       module procedure fmadd_fmz1
       module procedure fmadd_fmc1
       module procedure fmadd_fmfm1
       module procedure fmadd_imfm1
       module procedure fmadd_zmfm1
       module procedure fmadd_fmim1
       module procedure fmadd_fmzm1
       module procedure fmadd_fm1i
       module procedure fmadd_fm1r
       module procedure fmadd_fm1d
       module procedure fmadd_fm1z
       module procedure fmadd_fm1c
       module procedure fmadd_i1fm
       module procedure fmadd_r1fm
       module procedure fmadd_d1fm
       module procedure fmadd_z1fm
       module procedure fmadd_c1fm
       module procedure fmadd_fm1fm
       module procedure fmadd_fm1im
       module procedure fmadd_fm1zm
       module procedure fmadd_im1fm
       module procedure fmadd_zm1fm
       module procedure fmadd_i1fm1
       module procedure fmadd_r1fm1
       module procedure fmadd_d1fm1
       module procedure fmadd_z1fm1
       module procedure fmadd_c1fm1
       module procedure fmadd_fm1i1
       module procedure fmadd_fm1r1
       module procedure fmadd_fm1d1
       module procedure fmadd_fm1z1
       module procedure fmadd_fm1c1
       module procedure fmadd_fm1fm1
       module procedure fmadd_im1fm1
       module procedure fmadd_zm1fm1
       module procedure fmadd_fm1im1
       module procedure fmadd_fm1zm1
       module procedure fmadd_iim1
       module procedure fmadd_rim1
       module procedure fmadd_dim1
       module procedure fmadd_zim1
       module procedure fmadd_cim1
       module procedure fmadd_imi1
       module procedure fmadd_imr1
       module procedure fmadd_imd1
       module procedure fmadd_imz1
       module procedure fmadd_imc1
       module procedure fmadd_imim1
       module procedure fmadd_zmim1
       module procedure fmadd_imzm1
       module procedure fmadd_im1i
       module procedure fmadd_im1r
       module procedure fmadd_im1d
       module procedure fmadd_im1z
       module procedure fmadd_im1c
       module procedure fmadd_i1im
       module procedure fmadd_r1im
       module procedure fmadd_d1im
       module procedure fmadd_z1im
       module procedure fmadd_c1im
       module procedure fmadd_im1im
       module procedure fmadd_im1zm
       module procedure fmadd_zm1im
       module procedure fmadd_i1im1
       module procedure fmadd_r1im1
       module procedure fmadd_d1im1
       module procedure fmadd_z1im1
       module procedure fmadd_c1im1
       module procedure fmadd_im1i1
       module procedure fmadd_im1r1
       module procedure fmadd_im1d1
       module procedure fmadd_im1z1
       module procedure fmadd_im1c1
       module procedure fmadd_im1im1
       module procedure fmadd_zm1im1
       module procedure fmadd_im1zm1
       module procedure fmadd_izm1
       module procedure fmadd_rzm1
       module procedure fmadd_dzm1
       module procedure fmadd_zzm1
       module procedure fmadd_czm1
       module procedure fmadd_zmi1
       module procedure fmadd_zmr1
       module procedure fmadd_zmd1
       module procedure fmadd_zmz1
       module procedure fmadd_zmc1
       module procedure fmadd_zmzm1
       module procedure fmadd_zm1i
       module procedure fmadd_zm1r
       module procedure fmadd_zm1d
       module procedure fmadd_zm1z
       module procedure fmadd_zm1c
       module procedure fmadd_i1zm
       module procedure fmadd_r1zm
       module procedure fmadd_d1zm
       module procedure fmadd_z1zm
       module procedure fmadd_c1zm
       module procedure fmadd_zm1zm
       module procedure fmadd_i1zm1
       module procedure fmadd_r1zm1
       module procedure fmadd_d1zm1
       module procedure fmadd_z1zm1
       module procedure fmadd_c1zm1
       module procedure fmadd_zm1i1
       module procedure fmadd_zm1r1
       module procedure fmadd_zm1d1
       module procedure fmadd_zm1z1
       module procedure fmadd_zm1c1
       module procedure fmadd_zm1zm1
       module procedure fmadd_ifm2
       module procedure fmadd_rfm2
       module procedure fmadd_dfm2
       module procedure fmadd_zfm2
       module procedure fmadd_cfm2
       module procedure fmadd_fmi2
       module procedure fmadd_fmr2
       module procedure fmadd_fmd2
       module procedure fmadd_fmz2
       module procedure fmadd_fmc2
       module procedure fmadd_fmfm2
       module procedure fmadd_imfm2
       module procedure fmadd_zmfm2
       module procedure fmadd_fmim2
       module procedure fmadd_fmzm2
       module procedure fmadd_fm2i
       module procedure fmadd_fm2r
       module procedure fmadd_fm2d
       module procedure fmadd_fm2z
       module procedure fmadd_fm2c
       module procedure fmadd_i2fm
       module procedure fmadd_r2fm
       module procedure fmadd_d2fm
       module procedure fmadd_z2fm
       module procedure fmadd_c2fm
       module procedure fmadd_fm2fm
       module procedure fmadd_fm2im
       module procedure fmadd_fm2zm
       module procedure fmadd_im2fm
       module procedure fmadd_zm2fm
       module procedure fmadd_i2fm2
       module procedure fmadd_r2fm2
       module procedure fmadd_d2fm2
       module procedure fmadd_z2fm2
       module procedure fmadd_c2fm2
       module procedure fmadd_fm2i2
       module procedure fmadd_fm2r2
       module procedure fmadd_fm2d2
       module procedure fmadd_fm2z2
       module procedure fmadd_fm2c2
       module procedure fmadd_fm2fm2
       module procedure fmadd_im2fm2
       module procedure fmadd_zm2fm2
       module procedure fmadd_fm2im2
       module procedure fmadd_fm2zm2
       module procedure fmadd_iim2
       module procedure fmadd_rim2
       module procedure fmadd_dim2
       module procedure fmadd_zim2
       module procedure fmadd_cim2
       module procedure fmadd_imi2
       module procedure fmadd_imr2
       module procedure fmadd_imd2
       module procedure fmadd_imz2
       module procedure fmadd_imc2
       module procedure fmadd_imim2
       module procedure fmadd_zmim2
       module procedure fmadd_imzm2
       module procedure fmadd_im2i
       module procedure fmadd_im2r
       module procedure fmadd_im2d
       module procedure fmadd_im2z
       module procedure fmadd_im2c
       module procedure fmadd_i2im
       module procedure fmadd_r2im
       module procedure fmadd_d2im
       module procedure fmadd_z2im
       module procedure fmadd_c2im
       module procedure fmadd_im2im
       module procedure fmadd_im2zm
       module procedure fmadd_zm2im
       module procedure fmadd_i2im2
       module procedure fmadd_r2im2
       module procedure fmadd_d2im2
       module procedure fmadd_z2im2
       module procedure fmadd_c2im2
       module procedure fmadd_im2i2
       module procedure fmadd_im2r2
       module procedure fmadd_im2d2
       module procedure fmadd_im2z2
       module procedure fmadd_im2c2
       module procedure fmadd_im2im2
       module procedure fmadd_zm2im2
       module procedure fmadd_im2zm2
       module procedure fmadd_izm2
       module procedure fmadd_rzm2
       module procedure fmadd_dzm2
       module procedure fmadd_zzm2
       module procedure fmadd_czm2
       module procedure fmadd_zmi2
       module procedure fmadd_zmr2
       module procedure fmadd_zmd2
       module procedure fmadd_zmz2
       module procedure fmadd_zmc2
       module procedure fmadd_zmzm2
       module procedure fmadd_zm2i
       module procedure fmadd_zm2r
       module procedure fmadd_zm2d
       module procedure fmadd_zm2z
       module procedure fmadd_zm2c
       module procedure fmadd_i2zm
       module procedure fmadd_r2zm
       module procedure fmadd_d2zm
       module procedure fmadd_z2zm
       module procedure fmadd_c2zm
       module procedure fmadd_zm2zm
       module procedure fmadd_i2zm2
       module procedure fmadd_r2zm2
       module procedure fmadd_d2zm2
       module procedure fmadd_z2zm2
       module procedure fmadd_c2zm2
       module procedure fmadd_zm2i2
       module procedure fmadd_zm2r2
       module procedure fmadd_zm2d2
       module procedure fmadd_zm2z2
       module procedure fmadd_zm2c2
       module procedure fmadd_zm2zm2
       module procedure fmadd_fm1
       module procedure fmadd_im1
       module procedure fmadd_zm1
       module procedure fmadd_fm2
       module procedure fmadd_im2
       module procedure fmadd_zm2
    end interface

 contains

!                                                                   +

   function fmadd_ifm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      call fmadd(mtlvfm, ma%mfm, return_value%mfm)
   end function fmadd_ifm

   function fmadd_iim(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      call imadd(mtlvim, ma%mim, return_value%mim)
   end function fmadd_iim

   function fmadd_izm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmadd(mtlvzm, ma%mzm, return_value%mzm)
   end function fmadd_izm

   function fmadd_rfm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmadd(mtlvfm, ma%mfm, return_value%mfm)
   end function fmadd_rfm

   function fmadd_rim(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      call fmadd(mtlvfm, mulvfm, return_value%mfm)
   end function fmadd_rim

   function fmadd_rzm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmadd(mtlvzm, ma%mzm, return_value%mzm)
   end function fmadd_rzm

   function fmadd_dfm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmadd(mtlvfm, ma%mfm, return_value%mfm)
   end function fmadd_dfm

   function fmadd_dim(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      call fmadd(mtlvfm, mulvfm, return_value%mfm)
   end function fmadd_dim

   function fmadd_dzm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmadd(mtlvzm, ma%mzm, return_value%mzm)
   end function fmadd_dzm

   function fmadd_zfm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      call zmcmpx(ma%mfm, mulvfm, mulvzm)
      call zmadd(mtlvzm, mulvzm, return_value%mzm)
   end function fmadd_zfm

   function fmadd_zim(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmadd(mtlvzm, mulvzm, return_value%mzm)
   end function fmadd_zim

   function fmadd_zzm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      complex :: z
      intent (in) :: z, ma
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call zmadd(mtlvzm, ma%mzm, return_value%mzm)
   end function fmadd_zzm

   function fmadd_cfm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      call zmcmpx(ma%mfm, mulvfm, mulvzm)
      call zmadd(mtlvzm, mulvzm, return_value%mzm)
   end function fmadd_cfm

   function fmadd_cim(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmadd(mtlvzm, mulvzm, return_value%mzm)
   end function fmadd_cim

   function fmadd_czm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmadd(mtlvzm, ma%mzm, return_value%mzm)
   end function fmadd_czm

   function fmadd_fmi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      call fmadd(ma%mfm, mtlvfm, return_value%mfm)
   end function fmadd_fmi

   function fmadd_fmr(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmadd(ma%mfm, mtlvfm, return_value%mfm)
   end function fmadd_fmr

   function fmadd_fmd(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmadd(ma%mfm, mtlvfm, return_value%mfm)
   end function fmadd_fmd

   function fmadd_fmz(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      call zmcmpx(ma%mfm, mulvfm, mulvzm)
      call zmadd(mulvzm, mtlvzm, return_value%mzm)
   end function fmadd_fmz

   function fmadd_fmc(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      call zmcmpx(ma%mfm, mulvfm, mulvzm)
      call zmadd(mulvzm, mtlvzm, return_value%mzm)
   end function fmadd_fmc

   function fmadd_fmfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmadd(ma%mfm, mb%mfm, return_value%mfm)
   end function fmadd_fmfm

   function fmadd_fmim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      type (im) :: mb
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, mtlvfm)
      call fmadd(ma%mfm, mtlvfm, return_value%mfm)
   end function fmadd_fmim

   function fmadd_fmzm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (zm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm)
      call zmadd(mtlvzm, mb%mzm, return_value%mzm)
   end function fmadd_fmzm

   function fmadd_imi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      call imadd(ma%mim, mtlvim, return_value%mim)
   end function fmadd_imi

   function fmadd_imr(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      call fmadd(mulvfm, mtlvfm, return_value%mfm)
   end function fmadd_imr

   function fmadd_imd(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      call fmadd(mulvfm, mtlvfm, return_value%mfm)
   end function fmadd_imd

   function fmadd_imz(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmadd(mulvzm, mtlvzm, return_value%mzm)
   end function fmadd_imz

   function fmadd_imc(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmadd(mulvzm, mtlvzm, return_value%mzm)
   end function fmadd_imc

   function fmadd_imfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (fm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(ma%mim, mtlvfm)
      call fmadd(mtlvfm, mb%mfm, return_value%mfm)
   end function fmadd_imfm

   function fmadd_imim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imadd(ma%mim, mb%mim, return_value%mim)
   end function fmadd_imim

   function fmadd_imzm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (zm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mulvfm, mulvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmadd(mulvzm, mb%mzm, return_value%mzm)
   end function fmadd_imzm

   function fmadd_zmi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmadd(ma%mzm, mtlvzm, return_value%mzm)
   end function fmadd_zmi

   function fmadd_zmr(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmadd(ma%mzm, mtlvzm, return_value%mzm)
   end function fmadd_zmr

   function fmadd_zmd(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmadd(ma%mzm, mtlvzm, return_value%mzm)
   end function fmadd_zmd

   function fmadd_zmz(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call zmadd(ma%mzm, mtlvzm, return_value%mzm)
   end function fmadd_zmz

   function fmadd_zmc(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmadd(ma%mzm, mtlvzm, return_value%mzm)
   end function fmadd_zmc

   function fmadd_zmfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: mb
      type (zm) :: ma, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm)
      call zmadd(ma%mzm, mtlvzm, return_value%mzm)
   end function fmadd_zmfm

   function fmadd_zmim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: mb
      type (zm) :: ma, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mulvfm, mulvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmadd(ma%mzm, mulvzm, return_value%mzm)
   end function fmadd_zmim

   function fmadd_zmzm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmadd(ma%mzm, mb%mzm, return_value%mzm)
   end function fmadd_zmzm

   function fmadd_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmeq(ma%mfm, return_value%mfm)
   end function fmadd_fm

   function fmadd_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imeq(ma%mim, return_value%mim)
   end function fmadd_im

   function fmadd_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmeq(ma%mzm, return_value%mzm)
   end function fmadd_zm

!             Array addition operations for FM.

!             (1) rank 0  +  rank 1

   function fmadd_ifm1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmi2m(ival, mtlvfm)
      do j = 1, n
         call fmadd(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmadd_ifm1

   function fmadd_rfm1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, n
         call fmadd(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmadd_rfm1

   function fmadd_dfm1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, n
         call fmadd(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmadd_dfm1

   function fmadd_zfm1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zfm1

   function fmadd_cfm1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmadd_cfm1

   function fmadd_fmi1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm)
         call fmadd(ma%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmadd_fmi1

   function fmadd_fmr1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmadd(ma%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmadd_fmr1

   function fmadd_fmd1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmadd(ma%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmadd_fmd1

   function fmadd_fmz1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(ma%mfm, mulvfm, mulvzm)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_fmz1

   function fmadd_fmc1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(ma%mfm, mulvfm, mulvzm)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_fmc1

   function fmadd_fmfm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      do j = 1, n
         call fmadd(ma%mfm, mb(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmadd_fmfm1

   function fmadd_imfm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      call imi2fm(ma%mim, mtlvfm)
      do j = 1, n
         call fmadd(mtlvfm, mb(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmadd_imfm1

   function fmadd_zmfm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (fm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, n	
         call zmcmpx(mb(j)%mfm, mtlvfm, mtlvzm)
         call zmadd(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zmfm1

   function fmadd_fmim1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (im), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      do j = 1, n
         call imi2fm(mb(j)%mim, mtlvfm)
         call fmadd(ma%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmadd_fmim1

   function fmadd_fmzm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm)
      do j = 1, n
         call zmadd(mtlvzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_fmzm1

!             (2) rank 1  +  rank 0

   function fmadd_fm1i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmi2m(ival, mtlvfm)
      do j = 1, n
         call fmadd(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmadd_fm1i

   function fmadd_fm1r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, n
         call fmadd(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmadd_fm1r

   function fmadd_fm1d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, n
         call fmadd(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmadd_fm1d

   function fmadd_fm1z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_fm1z

   function fmadd_fm1c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_fm1c

   function fmadd_i1fm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm)
         call fmadd(mtlvfm, ma%mfm, return_value(j)%mfm)
      enddo
   end function fmadd_i1fm

   function fmadd_r1fm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmadd(mtlvfm, ma%mfm, return_value(j)%mfm)
      enddo
   end function fmadd_r1fm

   function fmadd_d1fm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmadd(mtlvfm, ma%mfm, return_value(j)%mfm)
      enddo
   end function fmadd_d1fm

   function fmadd_z1fm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(ma%mfm, mulvfm, mulvzm)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmadd_z1fm

   function fmadd_c1fm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(ma%mfm, mulvfm, mulvzm)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmadd_c1fm

   function fmadd_fm1fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      do j = 1, n
         call fmadd(ma(j)%mfm, mb%mfm, return_value(j)%mfm)
      enddo
   end function fmadd_fm1fm

   function fmadd_fm1im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (im) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      call imi2fm(mb%mim, mtlvfm)
      do j = 1, n
         call fmadd(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmadd_fm1im

   function fmadd_fm1zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mtlvfm, mtlvzm)
         call zmadd(mtlvzm, mb%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_fm1zm

   function fmadd_im1fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call fmadd(mtlvfm, mb%mfm, return_value(j)%mfm)
      enddo
   end function fmadd_im1fm

   function fmadd_zm1fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (fm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm)
      do j = 1, n
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zm1fm

!             (3) rank 1  +  rank 1

   function fmadd_fm1i1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm)
         call fmadd(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmadd_fm1i1

   function fmadd_fm1r1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmadd(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmadd_fm1r1

   function fmadd_fm1d1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmadd(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmadd_fm1d1

   function fmadd_fm1z1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_fm1z1

   function fmadd_fm1c1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_fm1c1

   function fmadd_i1fm1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm)
         call fmadd(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmadd_i1fm1

   function fmadd_r1fm1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmadd(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmadd_r1fm1

   function fmadd_d1fm1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmadd(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmadd_d1fm1

   function fmadd_z1fm1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(z)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmadd_z1fm1

   function fmadd_c1fm1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmadd_c1fm1

   function fmadd_fm1fm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmadd(ma(j)%mfm, mb(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmadd_fm1fm1

   function fmadd_fm1im1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2fm(mb(j)%mim, mtlvfm)
         call fmadd(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmadd_fm1im1

   function fmadd_fm1zm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mtlvfm, mtlvzm)
         call zmadd(mtlvzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_fm1zm1

   function fmadd_im1fm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call fmadd(mtlvfm, mb(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmadd_im1fm1

   function fmadd_zm1fm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call zmcmpx(mb(j)%mfm, mtlvfm, mtlvzm)
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zm1fm1

!             (4) rank 0  +  rank 2

   function fmadd_ifm2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmadd(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_ifm2

   function fmadd_rfm2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmadd(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_rfm2

   function fmadd_dfm2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmadd(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_dfm2

   function fmadd_zfm2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zfm2

   function fmadd_cfm2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_cfm2

   function fmadd_fmi2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call fmi2m(ival(j, k), mtlvfm)
            call fmadd(ma%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_fmi2

   function fmadd_fmr2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmadd(ma%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_fmr2

   function fmadd_fmd2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmadd(ma%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_fmd2

   function fmadd_fmz2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(ma%mfm, mulvfm, mulvzm)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_fmz2

   function fmadd_fmc2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(ma%mfm, mulvfm, mulvzm)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_fmc2

   function fmadd_fmfm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call fmadd(ma%mfm, mb(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_fmfm2

   function fmadd_imfm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(ma%mim, mtlvfm)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call fmadd(mtlvfm, mb(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_imfm2

   function fmadd_zmfm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (fm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmcmpx(mb(j, k)%mfm, mtlvfm, mtlvzm)
            call zmadd(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zmfm2

   function fmadd_fmim2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (im), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imi2fm(mb(j, k)%mim, mtlvfm)
            call fmadd(ma%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_fmim2

   function fmadd_fmzm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmadd(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_fmzm2

!             (5) rank 2  +  rank 0

   function fmadd_fm2i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmadd(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_fm2i

   function fmadd_fm2r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmadd(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_fm2r

   function fmadd_fm2d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmadd(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_fm2d

   function fmadd_fm2z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_fm2z

   function fmadd_fm2c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_fm2c

   function fmadd_i2fm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call fmi2m(ival(j, k), mtlvfm)
            call fmadd(mtlvfm, ma%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_i2fm

   function fmadd_r2fm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmadd(mtlvfm, ma%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_r2fm

   function fmadd_d2fm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmadd(mtlvfm, ma%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_d2fm

   function fmadd_z2fm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(ma%mfm, mulvfm, mulvzm)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_z2fm

   function fmadd_c2fm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(ma%mfm, mulvfm, mulvzm)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_c2fm

   function fmadd_fm2fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmadd(ma(j, k)%mfm, mb%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_fm2fm

   function fmadd_fm2im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmadd(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_fm2im

   function fmadd_fm2zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mtlvfm, mtlvzm)
            call zmadd(mtlvzm, mb%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_fm2zm

   function fmadd_im2fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call fmadd(mtlvfm, mb%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_im2fm

   function fmadd_zm2fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zm2fm

!             (6) rank 2  +  rank 2

   function fmadd_fm2i2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm)
            call fmadd(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_fm2i2

   function fmadd_fm2r2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmadd(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_fm2r2

   function fmadd_fm2d2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmadd(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_fm2d2

   function fmadd_fm2z2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_fm2z2

   function fmadd_fm2c2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_fm2c2

   function fmadd_i2fm2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm)
            call fmadd(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_i2fm2

   function fmadd_r2fm2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmadd(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_r2fm2

   function fmadd_d2fm2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmadd(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_d2fm2

   function fmadd_z2fm2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_z2fm2

   function fmadd_c2fm2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_c2fm2

   function fmadd_fm2fm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmadd(ma(j, k)%mfm, mb(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_fm2fm2

   function fmadd_fm2im2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(mb(j, k)%mim, mtlvfm)
            call fmadd(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_fm2im2

   function fmadd_fm2zm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mtlvfm, mtlvzm)
            call zmadd(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_fm2zm2

   function fmadd_im2fm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call fmadd(mtlvfm, mb(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_im2fm2

   function fmadd_zm2fm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(mb(j, k)%mfm, mtlvfm, mtlvzm)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zm2fm2

!             Array addition operations for IM.

!             (1) rank 0  +  rank 1

   function fmadd_iim1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      n = size(ma)
      call imi2m(ival, mtlvim)
      do j = 1, n
         call imadd(mtlvim, ma(j)%mim, return_value(j)%mim)
      enddo
   end function fmadd_iim1

   function fmadd_rim1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mulvfm)
         call fmadd(mtlvfm, mulvfm, return_value(j)%mfm)
      enddo
   end function fmadd_rim1

   function fmadd_dim1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mulvfm)
         call fmadd(mtlvfm, mulvfm, return_value(j)%mfm)
      enddo
   end function fmadd_dim1

   function fmadd_zim1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mulvzm)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zim1

   function fmadd_cim1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mulvzm)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmadd_cim1

   function fmadd_imi1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim)
         call imadd(ma%mim, mtlvim, return_value(j)%mim)
      enddo
   end function fmadd_imi1

   function fmadd_imr1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      n = size(r)
      call imi2fm(ma%mim, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmadd(mulvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmadd_imr1

   function fmadd_imd1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      n = size(d)
      call imi2fm(ma%mim, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmadd(mulvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmadd_imd1

   function fmadd_imz1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(mtlvfm, mulvfm, mulvzm)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_imz1

   function fmadd_imc1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(mvlvfm, mulvfm, mulvzm)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_imc1

   function fmadd_imim1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (im), dimension(:) :: mb
      type (im), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      do j = 1, n
         call imadd(ma%mim, mb(j)%mim, return_value(j)%mim)
      enddo
   end function fmadd_imim1

   function fmadd_zmim1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (im), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mvlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call imi2fm(mb(j)%mim, mvlvfm)
         call zmcmpx(mvlvfm, mtlvfm, mtlvzm)
         call zmadd(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zmim1

   function fmadd_imzm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mvlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      call imi2fm(ma%mim, mvlvfm)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mvlvfm, mtlvfm, mtlvzm)
      do j = 1, n
         call zmadd(mtlvzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_imzm1

!             (2) rank 1  +  rank 0

   function fmadd_im1i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      n = size(ma)
      call imi2m(ival, mtlvim)
      do j = 1, n
         call imadd(ma(j)%mim, mtlvim, return_value(j)%mim)
      enddo
   end function fmadd_im1i

   function fmadd_im1r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm)
         call fmadd(mvlvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmadd_im1r

   function fmadd_im1d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm)
         call fmadd(mvlvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmadd_im1d

   function fmadd_im1z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm)
         call zmcmpx(mvlvfm, mulvfm, mulvzm)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_im1z

   function fmadd_im1c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm)
         call zmcmpx(mvlvfm, mulvfm, mulvzm)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_im1c

   function fmadd_i1im(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim)
         call imadd(mtlvim, ma%mim, return_value(j)%mim)
      enddo
   end function fmadd_i1im

   function fmadd_r1im(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      n = size(r)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmadd(mtlvfm, mvlvfm, return_value(j)%mfm)
      enddo
   end function fmadd_r1im

   function fmadd_d1im(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      n = size(d)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmadd(mtlvfm, mvlvfm, return_value(j)%mfm)
      enddo
   end function fmadd_d1im

   function fmadd_z1im(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      call imi2fm(ma%mim, mvlvfm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(mvlvfm, mulvfm, mulvzm)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmadd_z1im

   function fmadd_c1im(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      call imi2fm(ma%mim, m1lvfm)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(m1lvfm, mulvfm, mulvzm)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmadd_c1im

   function fmadd_im1im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im) :: mb
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      do j = 1, n
         call imadd(ma(j)%mim, mb%mim, return_value(j)%mim)
      enddo
   end function fmadd_im1im

   function fmadd_im1zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
         call zmadd(m1lvzm, mb%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_im1zm

   function fmadd_zm1im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (im) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      call imi2fm(mb%mim, m1lvfm)
      call fmi2m(0, mtlvfm)
      call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
      do j = 1, n
         call zmadd(ma(j)%mzm, m1lvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zm1im

!             (3) rank 1  +  rank 1

   function fmadd_im1i1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2m(ival(j), mtlvim)
         call imadd(ma(j)%mim, mtlvim, return_value(j)%mim)
      enddo
   end function fmadd_im1i1

   function fmadd_im1r1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmadd(m1lvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmadd_im1r1

   function fmadd_im1d1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmadd(m1lvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmadd_im1d1

   function fmadd_im1z1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call imi2fm(ma(j)%mim, m1lvfm)
         call zmcmpx(m1lvfm, mulvfm, mulvzm)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_im1z1

   function fmadd_im1c1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmi2m(0, mulvfm)
         call zmcmpx(m1lvfm, mulvfm, mulvzm)
         call zmadd(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_im1c1

   function fmadd_i1im1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim)
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim)
         call imadd(mtlvim, ma(j)%mim, return_value(j)%mim)
      enddo
   end function fmadd_i1im1

   function fmadd_r1im1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmsp2m(r(j), mtlvfm)
         call fmadd(mtlvfm, m1lvfm, return_value(j)%mfm)
      enddo
   end function fmadd_r1im1

   function fmadd_d1im1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmdp2m(d(j), mtlvfm)
         call fmadd(mtlvfm, m1lvfm, return_value(j)%mfm)
      enddo
   end function fmadd_d1im1

   function fmadd_z1im1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(z)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call imi2fm(ma(j)%mim, m1lvfm)
         call zmcmpx(m1lvfm, mulvfm, mulvzm)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmadd_z1im1

   function fmadd_c1im1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(m1lvfm, mulvfm, mulvzm)
         call zmadd(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmadd_c1im1

   function fmadd_im1im1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imadd(ma(j)%mim, mb(j)%mim, return_value(j)%mim)
      enddo
   end function fmadd_im1im1

   function fmadd_im1zm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
         call zmadd(m1lvzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_im1zm1

   function fmadd_zm1im1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call imi2fm(mb(j)%mim, m1lvfm)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
         call zmadd(ma(j)%mzm, m1lvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zm1im1

!             (4) rank 0  +  rank 2

   function fmadd_iim2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imadd(mtlvim, ma(j, k)%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmadd_iim2

   function fmadd_rim2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mulvfm)
            call fmadd(mtlvfm, mulvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_rim2

   function fmadd_dim2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mulvfm)
            call fmadd(mtlvfm, mulvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_dim2

   function fmadd_zim2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mulvzm)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zim2

   function fmadd_cim2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mulvzm)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_cim2

   function fmadd_imi2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call imi2m(ival(j, k), mtlvim)
            call imadd(ma%mim, mtlvim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmadd_imi2

   function fmadd_imr2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mulvfm)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmadd(mulvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_imr2

   function fmadd_imd2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mulvfm)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmadd(mulvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_imd2

   function fmadd_imz2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(mtlvfm, mulvfm, mulvzm)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_imz2

   function fmadd_imc2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(mvlvfm, mulvfm, mulvzm)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_imc2

   function fmadd_imim2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (im), dimension(:,:) :: mb
      type (im), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imadd(ma%mim, mb(j, k)%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmadd_imim2

   function fmadd_zmim2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (im), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mvlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imi2fm(mb(j, k)%mim, mvlvfm)
            call zmcmpx(mvlvfm, mtlvfm, mtlvzm)
            call zmadd(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zmim2

   function fmadd_imzm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mvlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(ma%mim, mvlvfm)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mvlvfm, mtlvfm, mtlvzm)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmadd(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_imzm2

!             (5) rank 2  +  rank 0

   function fmadd_im2i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imadd(ma(j, k)%mim, mtlvim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmadd_im2i

   function fmadd_im2r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm)
            call fmadd(mvlvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_im2r

   function fmadd_im2d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm)
            call fmadd(mvlvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_im2d

   function fmadd_im2z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm)
            call zmcmpx(mvlvfm, mulvfm, mulvzm)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_im2z

   function fmadd_im2c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm)
            call zmcmpx(mvlvfm, mulvfm, mulvzm)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_im2c

   function fmadd_i2im(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call imi2m(ival(j, k), mtlvim)
            call imadd(mtlvim, ma%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmadd_i2im

   function fmadd_r2im(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmadd(mtlvfm, mvlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_r2im

   function fmadd_d2im(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmadd(mtlvfm, mvlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_d2im

   function fmadd_z2im(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mvlvfm)
      call fmi2m(0, mulvfm)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(mvlvfm, mulvfm, mulvzm)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_z2im

   function fmadd_c2im(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, m1lvfm)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(m1lvfm, mulvfm, mulvzm)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_c2im

   function fmadd_im2im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im) :: mb
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imadd(ma(j, k)%mim, mb%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmadd_im2im

   function fmadd_im2zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
            call zmadd(m1lvzm, mb%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_im2zm

   function fmadd_zm2im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, m1lvfm)
      call fmi2m(0, mtlvfm)
      call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(ma(j, k)%mzm, m1lvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zm2im

!             (6) rank 2  +  rank 2

   function fmadd_im2i2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2m(ival(j, k), mtlvim)
            call imadd(ma(j, k)%mim, mtlvim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmadd_im2i2

   function fmadd_im2r2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmadd(m1lvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_im2r2

   function fmadd_im2d2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmadd(m1lvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_im2d2

   function fmadd_im2z2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call zmcmpx(m1lvfm, mulvfm, mulvzm)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_im2z2

   function fmadd_im2c2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmi2m(0, mulvfm)
            call zmcmpx(m1lvfm, mulvfm, mulvzm)
            call zmadd(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_im2c2

   function fmadd_i2im2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2m(ival(j, k), mtlvim)
            call imadd(mtlvim, ma(j, k)%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmadd_i2im2

   function fmadd_r2im2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmsp2m(r(j, k), mtlvfm)
            call fmadd(mtlvfm, m1lvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_r2im2

   function fmadd_d2im2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmdp2m(d(j, k), mtlvfm)
            call fmadd(mtlvfm, m1lvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_d2im2

   function fmadd_z2im2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call zmcmpx(m1lvfm, mulvfm, mulvzm)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_z2im2

   function fmadd_c2im2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(m1lvfm, mulvfm, mulvzm)
            call zmadd(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_c2im2

   function fmadd_im2im2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imadd(ma(j, k)%mim, mb(j, k)%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmadd_im2im2

   function fmadd_im2zm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
            call zmadd(m1lvzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_im2zm2

   function fmadd_zm2im2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(mb(j, k)%mim, m1lvfm)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
            call zmadd(ma(j, k)%mzm, m1lvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zm2im2

!             Array addition operations for ZM.

!             (1) rank 0  +  rank 1

   function fmadd_izm1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmi2m(ival, mtlvzm)
      do j = 1, n
         call zmadd(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_izm1

   function fmadd_rzm1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmadd(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_rzm1

   function fmadd_dzm1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmadd(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_dzm1

   function fmadd_zzm1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      do j = 1, n
         call zmadd(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_zzm1

   function fmadd_czm1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmadd(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_czm1

   function fmadd_zmi1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm)
         call zmadd(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zmi1

   function fmadd_zmr1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(r)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmadd(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zmr1

   function fmadd_zmd1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(d)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmadd(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zmd1

   function fmadd_zmz1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmadd(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zmz1

   function fmadd_zmc1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmadd(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zmc1

   function fmadd_zmzm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      do j = 1, n
         call zmadd(ma%mzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_zmzm1

!             (2) rank 1  +  rank 0

   function fmadd_zm1i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmi2m(ival, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zm1i

   function fmadd_zm1r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zm1r

   function fmadd_zm1d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zm1d

   function fmadd_zm1z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      do j = 1, n
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zm1z

   function fmadd_zm1c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zm1c

   function fmadd_i1zm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm)
         call zmadd(mtlvzm, ma%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_i1zm

   function fmadd_r1zm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(r)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmadd(mtlvzm, ma%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_r1zm

   function fmadd_d1zm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(d)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmadd(mtlvzm, ma%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_d1zm

   function fmadd_z1zm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmadd(mtlvzm, ma%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_z1zm

   function fmadd_c1zm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmadd(mtlvzm, ma%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_c1zm

   function fmadd_zm1zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      do j = 1, n
         call zmadd(ma(j)%mzm, mb%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_zm1zm

!             (3) rank 1  +  rank 1

   function fmadd_zm1i1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm)
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zm1i1

   function fmadd_zm1r1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zm1r1

   function fmadd_zm1d1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zm1d1

   function fmadd_zm1z1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zm1z1

   function fmadd_zm1c1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmadd(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmadd_zm1c1

   function fmadd_i1zm1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ival)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmadd(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_i1zm1

   function fmadd_r1zm1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(r)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmadd(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_r1zm1

   function fmadd_d1zm1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(d)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmadd(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_d1zm1

   function fmadd_z1zm1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmadd(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_z1zm1

   function fmadd_c1zm1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmadd(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_c1zm1

   function fmadd_zm1zm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmadd(ma(j)%mzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_zm1zm1

!             (4) rank 0  +  rank 2

   function fmadd_izm2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmi2m(ival, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_izm2

   function fmadd_rzm2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_rzm2

   function fmadd_dzm2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_dzm2

   function fmadd_zzm2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zzm2

   function fmadd_czm2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_czm2

   function fmadd_zmi2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call zmi2m(ival(j, k), mtlvzm)
            call zmadd(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zmi2

   function fmadd_zmr2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmadd(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zmr2

   function fmadd_zmd2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmadd(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zmd2

   function fmadd_zmz2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmadd(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zmz2

   function fmadd_zmc2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmadd(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zmc2

   function fmadd_zmzm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmadd(ma%mzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zmzm2

!             (5) rank 2  +  rank 0

   function fmadd_zm2i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zm2i

   function fmadd_zm2r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zm2r

   function fmadd_zm2d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zm2d

   function fmadd_zm2z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zm2z

   function fmadd_zm2c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zm2c

   function fmadd_i2zm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call zmi2m(ival(j, k), mtlvzm)
            call zmadd(mtlvzm, ma%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_i2zm

   function fmadd_r2zm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmadd(mtlvzm, ma%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_r2zm

   function fmadd_d2zm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmadd(mtlvzm, ma%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_d2zm

   function fmadd_z2zm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmadd(mtlvzm, ma%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_z2zm

   function fmadd_c2zm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmadd(mtlvzm, ma%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_c2zm

   function fmadd_zm2zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(ma(j, k)%mzm, mb%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zm2zm

!             (6) rank 2  +  rank 2

   function fmadd_zm2i2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmi2m(ival(j, k), mtlvzm)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zm2i2

   function fmadd_zm2r2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zm2r2

   function fmadd_zm2d2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zm2d2

   function fmadd_zm2z2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zm2z2

   function fmadd_zm2c2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmadd(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zm2c2

   function fmadd_i2zm2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmadd(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_i2zm2

   function fmadd_r2zm2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmadd(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_r2zm2

   function fmadd_d2zm2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmadd(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_d2zm2

   function fmadd_z2zm2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmadd(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_z2zm2

   function fmadd_c2zm2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmadd(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_c2zm2

   function fmadd_zm2zm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmadd(ma(j, k)%mzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zm2zm2

   function fmadd_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmeq(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmadd_fm1

   function fmadd_im1(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call imeq(ma(j)%mim, return_value(j)%mim)
      enddo
   end function fmadd_im1

   function fmadd_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmeq(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmadd_zm1

   function fmadd_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmeq(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmadd_fm2

   function fmadd_im2(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imeq(ma(j, k)%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmadd_im2

   function fmadd_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmeq(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmadd_zm2

 end module fmzm_4

 module fmzm_5
    use fmzm_1

    interface operator (-)
       module procedure fmsub_ifm
       module procedure fmsub_iim
       module procedure fmsub_izm
       module procedure fmsub_rfm
       module procedure fmsub_rim
       module procedure fmsub_rzm
       module procedure fmsub_dfm
       module procedure fmsub_dim
       module procedure fmsub_dzm
       module procedure fmsub_zfm
       module procedure fmsub_zim
       module procedure fmsub_zzm
       module procedure fmsub_cfm
       module procedure fmsub_cim
       module procedure fmsub_czm
       module procedure fmsub_fmi
       module procedure fmsub_fmr
       module procedure fmsub_fmd
       module procedure fmsub_fmz
       module procedure fmsub_fmc
       module procedure fmsub_fmfm
       module procedure fmsub_fmim
       module procedure fmsub_fmzm
       module procedure fmsub_imi
       module procedure fmsub_imr
       module procedure fmsub_imd
       module procedure fmsub_imz
       module procedure fmsub_imc
       module procedure fmsub_imfm
       module procedure fmsub_imim
       module procedure fmsub_imzm
       module procedure fmsub_zmi
       module procedure fmsub_zmr
       module procedure fmsub_zmd
       module procedure fmsub_zmz
       module procedure fmsub_zmc
       module procedure fmsub_zmfm
       module procedure fmsub_zmim
       module procedure fmsub_zmzm
       module procedure fmsub_fm
       module procedure fmsub_im
       module procedure fmsub_zm
       module procedure fmsub_ifm1
       module procedure fmsub_rfm1
       module procedure fmsub_dfm1
       module procedure fmsub_zfm1
       module procedure fmsub_cfm1
       module procedure fmsub_fmi1
       module procedure fmsub_fmr1
       module procedure fmsub_fmd1
       module procedure fmsub_fmz1
       module procedure fmsub_fmc1
       module procedure fmsub_fmfm1
       module procedure fmsub_imfm1
       module procedure fmsub_zmfm1
       module procedure fmsub_fmim1
       module procedure fmsub_fmzm1
       module procedure fmsub_fm1i
       module procedure fmsub_fm1r
       module procedure fmsub_fm1d
       module procedure fmsub_fm1z
       module procedure fmsub_fm1c
       module procedure fmsub_i1fm
       module procedure fmsub_r1fm
       module procedure fmsub_d1fm
       module procedure fmsub_z1fm
       module procedure fmsub_c1fm
       module procedure fmsub_fm1fm
       module procedure fmsub_fm1im
       module procedure fmsub_fm1zm
       module procedure fmsub_im1fm
       module procedure fmsub_zm1fm
       module procedure fmsub_i1fm1
       module procedure fmsub_r1fm1
       module procedure fmsub_d1fm1
       module procedure fmsub_z1fm1
       module procedure fmsub_c1fm1
       module procedure fmsub_fm1i1
       module procedure fmsub_fm1r1
       module procedure fmsub_fm1d1
       module procedure fmsub_fm1z1
       module procedure fmsub_fm1c1
       module procedure fmsub_fm1fm1
       module procedure fmsub_im1fm1
       module procedure fmsub_zm1fm1
       module procedure fmsub_fm1im1
       module procedure fmsub_fm1zm1
       module procedure fmsub_iim1
       module procedure fmsub_rim1
       module procedure fmsub_dim1
       module procedure fmsub_zim1
       module procedure fmsub_cim1
       module procedure fmsub_imi1
       module procedure fmsub_imr1
       module procedure fmsub_imd1
       module procedure fmsub_imz1
       module procedure fmsub_imc1
       module procedure fmsub_imim1
       module procedure fmsub_zmim1
       module procedure fmsub_imzm1
       module procedure fmsub_im1i
       module procedure fmsub_im1r
       module procedure fmsub_im1d
       module procedure fmsub_im1z
       module procedure fmsub_im1c
       module procedure fmsub_i1im
       module procedure fmsub_r1im
       module procedure fmsub_d1im
       module procedure fmsub_z1im
       module procedure fmsub_c1im
       module procedure fmsub_im1im
       module procedure fmsub_im1zm
       module procedure fmsub_zm1im
       module procedure fmsub_i1im1
       module procedure fmsub_r1im1
       module procedure fmsub_d1im1
       module procedure fmsub_z1im1
       module procedure fmsub_c1im1
       module procedure fmsub_im1i1
       module procedure fmsub_im1r1
       module procedure fmsub_im1d1
       module procedure fmsub_im1z1
       module procedure fmsub_im1c1
       module procedure fmsub_im1im1
       module procedure fmsub_zm1im1
       module procedure fmsub_im1zm1
       module procedure fmsub_izm1
       module procedure fmsub_rzm1
       module procedure fmsub_dzm1
       module procedure fmsub_zzm1
       module procedure fmsub_czm1
       module procedure fmsub_zmi1
       module procedure fmsub_zmr1
       module procedure fmsub_zmd1
       module procedure fmsub_zmz1
       module procedure fmsub_zmc1
       module procedure fmsub_zmzm1
       module procedure fmsub_zm1i
       module procedure fmsub_zm1r
       module procedure fmsub_zm1d
       module procedure fmsub_zm1z
       module procedure fmsub_zm1c
       module procedure fmsub_i1zm
       module procedure fmsub_r1zm
       module procedure fmsub_d1zm
       module procedure fmsub_z1zm
       module procedure fmsub_c1zm
       module procedure fmsub_zm1zm
       module procedure fmsub_i1zm1
       module procedure fmsub_r1zm1
       module procedure fmsub_d1zm1
       module procedure fmsub_z1zm1
       module procedure fmsub_c1zm1
       module procedure fmsub_zm1i1
       module procedure fmsub_zm1r1
       module procedure fmsub_zm1d1
       module procedure fmsub_zm1z1
       module procedure fmsub_zm1c1
       module procedure fmsub_zm1zm1
       module procedure fmsub_ifm2
       module procedure fmsub_rfm2
       module procedure fmsub_dfm2
       module procedure fmsub_zfm2
       module procedure fmsub_cfm2
       module procedure fmsub_fmi2
       module procedure fmsub_fmr2
       module procedure fmsub_fmd2
       module procedure fmsub_fmz2
       module procedure fmsub_fmc2
       module procedure fmsub_fmfm2
       module procedure fmsub_imfm2
       module procedure fmsub_zmfm2
       module procedure fmsub_fmim2
       module procedure fmsub_fmzm2
       module procedure fmsub_fm2i
       module procedure fmsub_fm2r
       module procedure fmsub_fm2d
       module procedure fmsub_fm2z
       module procedure fmsub_fm2c
       module procedure fmsub_i2fm
       module procedure fmsub_r2fm
       module procedure fmsub_d2fm
       module procedure fmsub_z2fm
       module procedure fmsub_c2fm
       module procedure fmsub_fm2fm
       module procedure fmsub_fm2im
       module procedure fmsub_fm2zm
       module procedure fmsub_im2fm
       module procedure fmsub_zm2fm
       module procedure fmsub_i2fm2
       module procedure fmsub_r2fm2
       module procedure fmsub_d2fm2
       module procedure fmsub_z2fm2
       module procedure fmsub_c2fm2
       module procedure fmsub_fm2i2
       module procedure fmsub_fm2r2
       module procedure fmsub_fm2d2
       module procedure fmsub_fm2z2
       module procedure fmsub_fm2c2
       module procedure fmsub_fm2fm2
       module procedure fmsub_im2fm2
       module procedure fmsub_zm2fm2
       module procedure fmsub_fm2im2
       module procedure fmsub_fm2zm2
       module procedure fmsub_iim2
       module procedure fmsub_rim2
       module procedure fmsub_dim2
       module procedure fmsub_zim2
       module procedure fmsub_cim2
       module procedure fmsub_imi2
       module procedure fmsub_imr2
       module procedure fmsub_imd2
       module procedure fmsub_imz2
       module procedure fmsub_imc2
       module procedure fmsub_imim2
       module procedure fmsub_zmim2
       module procedure fmsub_imzm2
       module procedure fmsub_im2i
       module procedure fmsub_im2r
       module procedure fmsub_im2d
       module procedure fmsub_im2z
       module procedure fmsub_im2c
       module procedure fmsub_i2im
       module procedure fmsub_r2im
       module procedure fmsub_d2im
       module procedure fmsub_z2im
       module procedure fmsub_c2im
       module procedure fmsub_im2im
       module procedure fmsub_im2zm
       module procedure fmsub_zm2im
       module procedure fmsub_i2im2
       module procedure fmsub_r2im2
       module procedure fmsub_d2im2
       module procedure fmsub_z2im2
       module procedure fmsub_c2im2
       module procedure fmsub_im2i2
       module procedure fmsub_im2r2
       module procedure fmsub_im2d2
       module procedure fmsub_im2z2
       module procedure fmsub_im2c2
       module procedure fmsub_im2im2
       module procedure fmsub_zm2im2
       module procedure fmsub_im2zm2
       module procedure fmsub_izm2
       module procedure fmsub_rzm2
       module procedure fmsub_dzm2
       module procedure fmsub_zzm2
       module procedure fmsub_czm2
       module procedure fmsub_zmi2
       module procedure fmsub_zmr2
       module procedure fmsub_zmd2
       module procedure fmsub_zmz2
       module procedure fmsub_zmc2
       module procedure fmsub_zmzm2
       module procedure fmsub_zm2i
       module procedure fmsub_zm2r
       module procedure fmsub_zm2d
       module procedure fmsub_zm2z
       module procedure fmsub_zm2c
       module procedure fmsub_i2zm
       module procedure fmsub_r2zm
       module procedure fmsub_d2zm
       module procedure fmsub_z2zm
       module procedure fmsub_c2zm
       module procedure fmsub_zm2zm
       module procedure fmsub_i2zm2
       module procedure fmsub_r2zm2
       module procedure fmsub_d2zm2
       module procedure fmsub_z2zm2
       module procedure fmsub_c2zm2
       module procedure fmsub_zm2i2
       module procedure fmsub_zm2r2
       module procedure fmsub_zm2d2
       module procedure fmsub_zm2z2
       module procedure fmsub_zm2c2
       module procedure fmsub_zm2zm2
       module procedure fmsub_fm1
       module procedure fmsub_im1
       module procedure fmsub_zm1
       module procedure fmsub_fm2
       module procedure fmsub_im2
       module procedure fmsub_zm2
    end interface

 contains

!                                                                   -

   function fmsub_ifm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      call fmsub(mtlvfm, ma%mfm, return_value%mfm)
   end function fmsub_ifm

   function fmsub_iim(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      call imsub(mtlvim, ma%mim, return_value%mim)
   end function fmsub_iim

   function fmsub_izm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmsub(mtlvzm, ma%mzm, return_value%mzm)
   end function fmsub_izm

   function fmsub_rfm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmsub(mtlvfm, ma%mfm, return_value%mfm)
   end function fmsub_rfm

   function fmsub_rim(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      call fmsub(mtlvfm, mulvfm, return_value%mfm)
   end function fmsub_rim

   function fmsub_rzm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmsub(mtlvzm, ma%mzm, return_value%mzm)
   end function fmsub_rzm

   function fmsub_dfm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmsub(mtlvfm, ma%mfm, return_value%mfm)
   end function fmsub_dfm

   function fmsub_dim(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      call fmsub(mtlvfm, mulvfm, return_value%mfm)
   end function fmsub_dim

   function fmsub_dzm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmsub(mtlvzm, ma%mzm, return_value%mzm)
   end function fmsub_dzm

   function fmsub_zfm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      call zmcmpx(ma%mfm, mulvfm, mulvzm)
      call zmsub(mtlvzm, mulvzm, return_value%mzm)
   end function fmsub_zfm

   function fmsub_zim(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmsub(mtlvzm, mulvzm, return_value%mzm)
   end function fmsub_zim

   function fmsub_zzm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      complex :: z
      intent (in) :: z, ma
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call zmsub(mtlvzm, ma%mzm, return_value%mzm)
   end function fmsub_zzm

   function fmsub_cfm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      call zmcmpx(ma%mfm, mulvfm, mulvzm)
      call zmsub(mtlvzm, mulvzm, return_value%mzm)
   end function fmsub_cfm

   function fmsub_cim(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmsub(mtlvzm, mulvzm, return_value%mzm)
   end function fmsub_cim

   function fmsub_czm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmsub(mtlvzm, ma%mzm, return_value%mzm)
   end function fmsub_czm

   function fmsub_fmi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      call fmsub(ma%mfm, mtlvfm, return_value%mfm)
   end function fmsub_fmi

   function fmsub_fmr(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmsub(ma%mfm, mtlvfm, return_value%mfm)
   end function fmsub_fmr

   function fmsub_fmd(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmsub(ma%mfm, mtlvfm, return_value%mfm)
   end function fmsub_fmd

   function fmsub_fmz(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      call zmcmpx(ma%mfm, mulvfm, mulvzm)
      call zmsub(mulvzm, mtlvzm, return_value%mzm)
   end function fmsub_fmz

   function fmsub_fmc(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      call zmcmpx(ma%mfm, mulvfm, mulvzm)
      call zmsub(mulvzm, mtlvzm, return_value%mzm)
   end function fmsub_fmc

   function fmsub_fmfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmsub(ma%mfm, mb%mfm, return_value%mfm)
   end function fmsub_fmfm

   function fmsub_fmim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      type (im) :: mb
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, mtlvfm)
      call fmsub(ma%mfm, mtlvfm, return_value%mfm)
   end function fmsub_fmim

   function fmsub_fmzm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (zm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm)
      call zmsub(mtlvzm, mb%mzm, return_value%mzm)
   end function fmsub_fmzm

   function fmsub_imi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      call imsub(ma%mim, mtlvim, return_value%mim)
   end function fmsub_imi

   function fmsub_imr(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      call fmsub(mulvfm, mtlvfm, return_value%mfm)
   end function fmsub_imr

   function fmsub_imd(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      call fmsub(mulvfm, mtlvfm, return_value%mfm)
   end function fmsub_imd

   function fmsub_imz(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmsub(mulvzm, mtlvzm, return_value%mzm)
   end function fmsub_imz

   function fmsub_imc(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmsub(mulvzm, mtlvzm, return_value%mzm)
   end function fmsub_imc

   function fmsub_imfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (fm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(ma%mim, mtlvfm)
      call fmsub(mtlvfm, mb%mfm, return_value%mfm)
   end function fmsub_imfm

   function fmsub_imim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imsub(ma%mim, mb%mim, return_value%mim)
   end function fmsub_imim

   function fmsub_imzm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (zm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mulvfm, mulvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmsub(mulvzm, mb%mzm, return_value%mzm)
   end function fmsub_imzm

   function fmsub_zmi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmsub(ma%mzm, mtlvzm, return_value%mzm)
   end function fmsub_zmi

   function fmsub_zmr(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmsub(ma%mzm, mtlvzm, return_value%mzm)
   end function fmsub_zmr

   function fmsub_zmd(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmsub(ma%mzm, mtlvzm, return_value%mzm)
   end function fmsub_zmd

   function fmsub_zmz(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call zmsub(ma%mzm, mtlvzm, return_value%mzm)
   end function fmsub_zmz

   function fmsub_zmc(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmsub(ma%mzm, mtlvzm, return_value%mzm)
   end function fmsub_zmc

   function fmsub_zmfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: mb
      type (zm) :: ma, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm)
      call zmsub(ma%mzm, mtlvzm, return_value%mzm)
   end function fmsub_zmfm

   function fmsub_zmim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: mb
      type (zm) :: ma, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mulvfm, mulvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmsub(ma%mzm, mulvzm, return_value%mzm)
   end function fmsub_zmim

   function fmsub_zmzm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmsub(ma%mzm, mb%mzm, return_value%mzm)
   end function fmsub_zmzm

   function fmsub_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmeq(ma%mfm, mtlvfm)
      call fmnegate(mtlvfm)
      call fmeq(mtlvfm, return_value%mfm)
   end function fmsub_fm

   function fmsub_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, return_value
      intent (in) :: ma
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imeq(ma%mim, mtlvim)
      call fmnegate(mtlvim)
      call imeq(mtlvim, return_value%mim)
   end function fmsub_im

   function fmsub_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmeq(ma%mzm, mtlvzm)
      call fmnegate(mtlvzm(1))
      call fmnegate(mtlvzm(2))
      call zmeq(mtlvzm, return_value%mzm)
   end function fmsub_zm

!             Array subtraction operations for FM.

!             (1) rank 0  -  rank 1

   function fmsub_ifm1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmi2m(ival, mtlvfm)
      do j = 1, n
         call fmsub(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmsub_ifm1

   function fmsub_rfm1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, n
         call fmsub(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmsub_rfm1

   function fmsub_dfm1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, n
         call fmsub(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmsub_dfm1

   function fmsub_zfm1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zfm1

   function fmsub_cfm1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmsub_cfm1

   function fmsub_fmi1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm)
         call fmsub(ma%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmsub_fmi1

   function fmsub_fmr1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmsub(ma%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmsub_fmr1

   function fmsub_fmd1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmsub(ma%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmsub_fmd1

   function fmsub_fmz1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(ma%mfm, mulvfm, mulvzm)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_fmz1

   function fmsub_fmc1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(ma%mfm, mulvfm, mulvzm)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_fmc1

   function fmsub_fmfm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      do j = 1, n
         call fmsub(ma%mfm, mb(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmsub_fmfm1

   function fmsub_imfm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      call imi2fm(ma%mim, mtlvfm)
      do j = 1, n
         call fmsub(mtlvfm, mb(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmsub_imfm1

   function fmsub_zmfm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (fm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, n	
         call zmcmpx(mb(j)%mfm, mtlvfm, mtlvzm)
         call zmsub(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zmfm1

   function fmsub_fmim1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (im), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      do j = 1, n
         call imi2fm(mb(j)%mim, mtlvfm)
         call fmsub(ma%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmsub_fmim1

   function fmsub_fmzm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm)
      do j = 1, n
         call zmsub(mtlvzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_fmzm1

!             (2) rank 1  -  rank 0

   function fmsub_fm1i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmi2m(ival, mtlvfm)
      do j = 1, n
         call fmsub(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmsub_fm1i

   function fmsub_fm1r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, n
         call fmsub(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmsub_fm1r

   function fmsub_fm1d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, n
         call fmsub(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmsub_fm1d

   function fmsub_fm1z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_fm1z

   function fmsub_fm1c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_fm1c

   function fmsub_i1fm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm)
         call fmsub(mtlvfm, ma%mfm, return_value(j)%mfm)
      enddo
   end function fmsub_i1fm

   function fmsub_r1fm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmsub(mtlvfm, ma%mfm, return_value(j)%mfm)
      enddo
   end function fmsub_r1fm

   function fmsub_d1fm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmsub(mtlvfm, ma%mfm, return_value(j)%mfm)
      enddo
   end function fmsub_d1fm

   function fmsub_z1fm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(ma%mfm, mulvfm, mulvzm)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmsub_z1fm

   function fmsub_c1fm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(ma%mfm, mulvfm, mulvzm)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmsub_c1fm

   function fmsub_fm1fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      do j = 1, n
         call fmsub(ma(j)%mfm, mb%mfm, return_value(j)%mfm)
      enddo
   end function fmsub_fm1fm

   function fmsub_fm1im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (im) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      call imi2fm(mb%mim, mtlvfm)
      do j = 1, n
         call fmsub(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmsub_fm1im

   function fmsub_fm1zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mtlvfm, mtlvzm)
         call zmsub(mtlvzm, mb%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_fm1zm

   function fmsub_im1fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call fmsub(mtlvfm, mb%mfm, return_value(j)%mfm)
      enddo
   end function fmsub_im1fm

   function fmsub_zm1fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (fm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm)
      do j = 1, n
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zm1fm

!             (3) rank 1  -  rank 1

   function fmsub_fm1i1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm)
         call fmsub(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmsub_fm1i1

   function fmsub_fm1r1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmsub(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmsub_fm1r1

   function fmsub_fm1d1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmsub(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmsub_fm1d1

   function fmsub_fm1z1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_fm1z1

   function fmsub_fm1c1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_fm1c1

   function fmsub_i1fm1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm)
         call fmsub(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmsub_i1fm1

   function fmsub_r1fm1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmsub(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmsub_r1fm1

   function fmsub_d1fm1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmsub(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmsub_d1fm1

   function fmsub_z1fm1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(z)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmsub_z1fm1

   function fmsub_c1fm1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmsub_c1fm1

   function fmsub_fm1fm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsub(ma(j)%mfm, mb(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmsub_fm1fm1

   function fmsub_fm1im1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2fm(mb(j)%mim, mtlvfm)
         call fmsub(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmsub_fm1im1

   function fmsub_fm1zm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mtlvfm, mtlvzm)
         call zmsub(mtlvzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_fm1zm1

   function fmsub_im1fm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call fmsub(mtlvfm, mb(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmsub_im1fm1

   function fmsub_zm1fm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call zmcmpx(mb(j)%mfm, mtlvfm, mtlvzm)
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zm1fm1

!             (4) rank 0  -  rank 2

   function fmsub_ifm2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsub(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_ifm2

   function fmsub_rfm2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsub(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_rfm2

   function fmsub_dfm2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsub(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_dfm2

   function fmsub_zfm2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zfm2

   function fmsub_cfm2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_cfm2

   function fmsub_fmi2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call fmi2m(ival(j, k), mtlvfm)
            call fmsub(ma%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_fmi2

   function fmsub_fmr2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmsub(ma%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_fmr2

   function fmsub_fmd2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmsub(ma%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_fmd2

   function fmsub_fmz2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(ma%mfm, mulvfm, mulvzm)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_fmz2

   function fmsub_fmc2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(ma%mfm, mulvfm, mulvzm)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_fmc2

   function fmsub_fmfm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call fmsub(ma%mfm, mb(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_fmfm2

   function fmsub_imfm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(ma%mim, mtlvfm)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call fmsub(mtlvfm, mb(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_imfm2

   function fmsub_zmfm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (fm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmcmpx(mb(j, k)%mfm, mtlvfm, mtlvzm)
            call zmsub(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zmfm2

   function fmsub_fmim2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (im), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imi2fm(mb(j, k)%mim, mtlvfm)
            call fmsub(ma%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_fmim2

   function fmsub_fmzm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmsub(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_fmzm2

!             (5) rank 2  -  rank 0

   function fmsub_fm2i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsub(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_fm2i

   function fmsub_fm2r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsub(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_fm2r

   function fmsub_fm2d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsub(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_fm2d

   function fmsub_fm2z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_fm2z

   function fmsub_fm2c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_fm2c

   function fmsub_i2fm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call fmi2m(ival(j, k), mtlvfm)
            call fmsub(mtlvfm, ma%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_i2fm

   function fmsub_r2fm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmsub(mtlvfm, ma%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_r2fm

   function fmsub_d2fm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmsub(mtlvfm, ma%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_d2fm

   function fmsub_z2fm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(ma%mfm, mulvfm, mulvzm)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_z2fm

   function fmsub_c2fm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(ma%mfm, mulvfm, mulvzm)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_c2fm

   function fmsub_fm2fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsub(ma(j, k)%mfm, mb%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_fm2fm

   function fmsub_fm2im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsub(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_fm2im

   function fmsub_fm2zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mtlvfm, mtlvzm)
            call zmsub(mtlvzm, mb%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_fm2zm

   function fmsub_im2fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call fmsub(mtlvfm, mb%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_im2fm

   function fmsub_zm2fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zm2fm

!             (6) rank 2  -  rank 2

   function fmsub_fm2i2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm)
            call fmsub(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_fm2i2

   function fmsub_fm2r2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmsub(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_fm2r2

   function fmsub_fm2d2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmsub(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_fm2d2

   function fmsub_fm2z2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_fm2z2

   function fmsub_fm2c2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_fm2c2

   function fmsub_i2fm2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm)
            call fmsub(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_i2fm2

   function fmsub_r2fm2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmsub(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_r2fm2

   function fmsub_d2fm2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmsub(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_d2fm2

   function fmsub_z2fm2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_z2fm2

   function fmsub_c2fm2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_c2fm2

   function fmsub_fm2fm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsub(ma(j, k)%mfm, mb(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_fm2fm2

   function fmsub_fm2im2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(mb(j, k)%mim, mtlvfm)
            call fmsub(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_fm2im2

   function fmsub_fm2zm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mtlvfm, mtlvzm)
            call zmsub(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_fm2zm2

   function fmsub_im2fm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call fmsub(mtlvfm, mb(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_im2fm2

   function fmsub_zm2fm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(mb(j, k)%mfm, mtlvfm, mtlvzm)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zm2fm2

!             Array subtraction operations for IM.

!             (1) rank 0  -  rank 1

   function fmsub_iim1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      n = size(ma)
      call imi2m(ival, mtlvim)
      do j = 1, n
         call imsub(mtlvim, ma(j)%mim, return_value(j)%mim)
      enddo
   end function fmsub_iim1

   function fmsub_rim1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mulvfm)
         call fmsub(mtlvfm, mulvfm, return_value(j)%mfm)
      enddo
   end function fmsub_rim1

   function fmsub_dim1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mulvfm)
         call fmsub(mtlvfm, mulvfm, return_value(j)%mfm)
      enddo
   end function fmsub_dim1

   function fmsub_zim1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mulvzm)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zim1

   function fmsub_cim1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mulvzm)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmsub_cim1

   function fmsub_imi1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim)
         call imsub(ma%mim, mtlvim, return_value(j)%mim)
      enddo
   end function fmsub_imi1

   function fmsub_imr1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      n = size(r)
      call imi2fm(ma%mim, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmsub(mulvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmsub_imr1

   function fmsub_imd1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      n = size(d)
      call imi2fm(ma%mim, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmsub(mulvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmsub_imd1

   function fmsub_imz1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(mtlvfm, mulvfm, mulvzm)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_imz1

   function fmsub_imc1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(mvlvfm, mulvfm, mulvzm)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_imc1

   function fmsub_imim1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (im), dimension(:) :: mb
      type (im), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      do j = 1, n
         call imsub(ma%mim, mb(j)%mim, return_value(j)%mim)
      enddo
   end function fmsub_imim1

   function fmsub_zmim1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (im), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mvlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call imi2fm(mb(j)%mim, mvlvfm)
         call zmcmpx(mvlvfm, mtlvfm, mtlvzm)
         call zmsub(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zmim1

   function fmsub_imzm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mvlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      call imi2fm(ma%mim, mvlvfm)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mvlvfm, mtlvfm, mtlvzm)
      do j = 1, n
         call zmsub(mtlvzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_imzm1

!             (2) rank 1  -  rank 0

   function fmsub_im1i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      n = size(ma)
      call imi2m(ival, mtlvim)
      do j = 1, n
         call imsub(ma(j)%mim, mtlvim, return_value(j)%mim)
      enddo
   end function fmsub_im1i

   function fmsub_im1r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm)
         call fmsub(mvlvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmsub_im1r

   function fmsub_im1d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm)
         call fmsub(mvlvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmsub_im1d

   function fmsub_im1z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm)
         call zmcmpx(mvlvfm, mulvfm, mulvzm)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_im1z

   function fmsub_im1c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm)
         call zmcmpx(mvlvfm, mulvfm, mulvzm)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_im1c

   function fmsub_i1im(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim)
         call imsub(mtlvim, ma%mim, return_value(j)%mim)
      enddo
   end function fmsub_i1im

   function fmsub_r1im(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      n = size(r)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmsub(mtlvfm, mvlvfm, return_value(j)%mfm)
      enddo
   end function fmsub_r1im

   function fmsub_d1im(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      n = size(d)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmsub(mtlvfm, mvlvfm, return_value(j)%mfm)
      enddo
   end function fmsub_d1im

   function fmsub_z1im(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      call imi2fm(ma%mim, mvlvfm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(mvlvfm, mulvfm, mulvzm)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmsub_z1im

   function fmsub_c1im(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      call imi2fm(ma%mim, m1lvfm)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(m1lvfm, mulvfm, mulvzm)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmsub_c1im

   function fmsub_im1im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im) :: mb
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      do j = 1, n
         call imsub(ma(j)%mim, mb%mim, return_value(j)%mim)
      enddo
   end function fmsub_im1im

   function fmsub_im1zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
         call zmsub(m1lvzm, mb%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_im1zm

   function fmsub_zm1im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (im) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      call imi2fm(mb%mim, m1lvfm)
      call fmi2m(0, mtlvfm)
      call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
      do j = 1, n
         call zmsub(ma(j)%mzm, m1lvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zm1im

!             (3) rank 1  -  rank 1

   function fmsub_im1i1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2m(ival(j), mtlvim)
         call imsub(ma(j)%mim, mtlvim, return_value(j)%mim)
      enddo
   end function fmsub_im1i1

   function fmsub_im1r1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmsub(m1lvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmsub_im1r1

   function fmsub_im1d1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmsub(m1lvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmsub_im1d1

   function fmsub_im1z1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call imi2fm(ma(j)%mim, m1lvfm)
         call zmcmpx(m1lvfm, mulvfm, mulvzm)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_im1z1

   function fmsub_im1c1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmi2m(0, mulvfm)
         call zmcmpx(m1lvfm, mulvfm, mulvzm)
         call zmsub(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_im1c1

   function fmsub_i1im1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim)
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim)
         call imsub(mtlvim, ma(j)%mim, return_value(j)%mim)
      enddo
   end function fmsub_i1im1

   function fmsub_r1im1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmsp2m(r(j), mtlvfm)
         call fmsub(mtlvfm, m1lvfm, return_value(j)%mfm)
      enddo
   end function fmsub_r1im1

   function fmsub_d1im1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmdp2m(d(j), mtlvfm)
         call fmsub(mtlvfm, m1lvfm, return_value(j)%mfm)
      enddo
   end function fmsub_d1im1

   function fmsub_z1im1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(z)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call imi2fm(ma(j)%mim, m1lvfm)
         call zmcmpx(m1lvfm, mulvfm, mulvzm)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmsub_z1im1

   function fmsub_c1im1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(m1lvfm, mulvfm, mulvzm)
         call zmsub(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmsub_c1im1

   function fmsub_im1im1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imsub(ma(j)%mim, mb(j)%mim, return_value(j)%mim)
      enddo
   end function fmsub_im1im1

   function fmsub_im1zm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
         call zmsub(m1lvzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_im1zm1

   function fmsub_zm1im1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call imi2fm(mb(j)%mim, m1lvfm)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
         call zmsub(ma(j)%mzm, m1lvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zm1im1

!             (4) rank 0  -  rank 2

   function fmsub_iim2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imsub(mtlvim, ma(j, k)%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmsub_iim2

   function fmsub_rim2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mulvfm)
            call fmsub(mtlvfm, mulvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_rim2

   function fmsub_dim2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mulvfm)
            call fmsub(mtlvfm, mulvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_dim2

   function fmsub_zim2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mulvzm)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zim2

   function fmsub_cim2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mulvzm)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_cim2

   function fmsub_imi2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call imi2m(ival(j, k), mtlvim)
            call imsub(ma%mim, mtlvim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmsub_imi2

   function fmsub_imr2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mulvfm)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmsub(mulvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_imr2

   function fmsub_imd2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mulvfm)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmsub(mulvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_imd2

   function fmsub_imz2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(mtlvfm, mulvfm, mulvzm)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_imz2

   function fmsub_imc2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(mvlvfm, mulvfm, mulvzm)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_imc2

   function fmsub_imim2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (im), dimension(:,:) :: mb
      type (im), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imsub(ma%mim, mb(j, k)%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmsub_imim2

   function fmsub_zmim2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (im), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mvlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imi2fm(mb(j, k)%mim, mvlvfm)
            call zmcmpx(mvlvfm, mtlvfm, mtlvzm)
            call zmsub(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zmim2

   function fmsub_imzm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mvlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(ma%mim, mvlvfm)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mvlvfm, mtlvfm, mtlvzm)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmsub(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_imzm2

!             (5) rank 2  -  rank 0

   function fmsub_im2i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imsub(ma(j, k)%mim, mtlvim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmsub_im2i

   function fmsub_im2r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm)
            call fmsub(mvlvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_im2r

   function fmsub_im2d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm)
            call fmsub(mvlvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_im2d

   function fmsub_im2z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm)
            call zmcmpx(mvlvfm, mulvfm, mulvzm)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_im2z

   function fmsub_im2c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm)
            call zmcmpx(mvlvfm, mulvfm, mulvzm)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_im2c

   function fmsub_i2im(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call imi2m(ival(j, k), mtlvim)
            call imsub(mtlvim, ma%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmsub_i2im

   function fmsub_r2im(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmsub(mtlvfm, mvlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_r2im

   function fmsub_d2im(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmsub(mtlvfm, mvlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_d2im

   function fmsub_z2im(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mvlvfm)
      call fmi2m(0, mulvfm)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(mvlvfm, mulvfm, mulvzm)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_z2im

   function fmsub_c2im(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, m1lvfm)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(m1lvfm, mulvfm, mulvzm)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_c2im

   function fmsub_im2im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im) :: mb
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imsub(ma(j, k)%mim, mb%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmsub_im2im

   function fmsub_im2zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
            call zmsub(m1lvzm, mb%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_im2zm

   function fmsub_zm2im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, m1lvfm)
      call fmi2m(0, mtlvfm)
      call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(ma(j, k)%mzm, m1lvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zm2im

!             (6) rank 2  -  rank 2

   function fmsub_im2i2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2m(ival(j, k), mtlvim)
            call imsub(ma(j, k)%mim, mtlvim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmsub_im2i2

   function fmsub_im2r2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmsub(m1lvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_im2r2

   function fmsub_im2d2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmsub(m1lvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_im2d2

   function fmsub_im2z2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call zmcmpx(m1lvfm, mulvfm, mulvzm)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_im2z2

   function fmsub_im2c2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmi2m(0, mulvfm)
            call zmcmpx(m1lvfm, mulvfm, mulvzm)
            call zmsub(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_im2c2

   function fmsub_i2im2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2m(ival(j, k), mtlvim)
            call imsub(mtlvim, ma(j, k)%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmsub_i2im2

   function fmsub_r2im2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmsp2m(r(j, k), mtlvfm)
            call fmsub(mtlvfm, m1lvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_r2im2

   function fmsub_d2im2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmdp2m(d(j, k), mtlvfm)
            call fmsub(mtlvfm, m1lvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_d2im2

   function fmsub_z2im2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call zmcmpx(m1lvfm, mulvfm, mulvzm)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_z2im2

   function fmsub_c2im2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(m1lvfm, mulvfm, mulvzm)
            call zmsub(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_c2im2

   function fmsub_im2im2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imsub(ma(j, k)%mim, mb(j, k)%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmsub_im2im2

   function fmsub_im2zm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
            call zmsub(m1lvzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_im2zm2

   function fmsub_zm2im2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(mb(j, k)%mim, m1lvfm)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
            call zmsub(ma(j, k)%mzm, m1lvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zm2im2

!             Array subtraction operations for ZM.

!             (1) rank 0  -  rank 1

   function fmsub_izm1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmi2m(ival, mtlvzm)
      do j = 1, n
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_izm1

   function fmsub_rzm1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_rzm1

   function fmsub_dzm1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_dzm1

   function fmsub_zzm1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      do j = 1, n
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_zzm1

   function fmsub_czm1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_czm1

   function fmsub_zmi1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm)
         call zmsub(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zmi1

   function fmsub_zmr1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(r)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmsub(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zmr1

   function fmsub_zmd1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(d)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmsub(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zmd1

   function fmsub_zmz1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmsub(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zmz1

   function fmsub_zmc1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmsub(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zmc1

   function fmsub_zmzm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      do j = 1, n
         call zmsub(ma%mzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_zmzm1

!             (2) rank 1  -  rank 0

   function fmsub_zm1i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmi2m(ival, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zm1i

   function fmsub_zm1r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zm1r

   function fmsub_zm1d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zm1d

   function fmsub_zm1z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      do j = 1, n
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zm1z

   function fmsub_zm1c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zm1c

   function fmsub_i1zm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm)
         call zmsub(mtlvzm, ma%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_i1zm

   function fmsub_r1zm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(r)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmsub(mtlvzm, ma%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_r1zm

   function fmsub_d1zm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(d)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmsub(mtlvzm, ma%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_d1zm

   function fmsub_z1zm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmsub(mtlvzm, ma%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_z1zm

   function fmsub_c1zm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmsub(mtlvzm, ma%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_c1zm

   function fmsub_zm1zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      do j = 1, n
         call zmsub(ma(j)%mzm, mb%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_zm1zm

!             (3) rank 1  -  rank 1

   function fmsub_zm1i1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm)
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zm1i1

   function fmsub_zm1r1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zm1r1

   function fmsub_zm1d1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zm1d1

   function fmsub_zm1z1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zm1z1

   function fmsub_zm1c1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmsub(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmsub_zm1c1

   function fmsub_i1zm1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ival)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_i1zm1

   function fmsub_r1zm1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(r)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_r1zm1

   function fmsub_d1zm1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(d)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_d1zm1

   function fmsub_z1zm1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_z1zm1

   function fmsub_c1zm1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_c1zm1

   function fmsub_zm1zm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmsub(ma(j)%mzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_zm1zm1

!             (4) rank 0  -  rank 2

   function fmsub_izm2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmi2m(ival, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_izm2

   function fmsub_rzm2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_rzm2

   function fmsub_dzm2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_dzm2

   function fmsub_zzm2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zzm2

   function fmsub_czm2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_czm2

   function fmsub_zmi2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call zmi2m(ival(j, k), mtlvzm)
            call zmsub(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zmi2

   function fmsub_zmr2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmsub(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zmr2

   function fmsub_zmd2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmsub(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zmd2

   function fmsub_zmz2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmsub(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zmz2

   function fmsub_zmc2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmsub(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zmc2

   function fmsub_zmzm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmsub(ma%mzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zmzm2

!             (5) rank 2  -  rank 0

   function fmsub_zm2i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zm2i

   function fmsub_zm2r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zm2r

   function fmsub_zm2d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zm2d

   function fmsub_zm2z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zm2z

   function fmsub_zm2c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zm2c

   function fmsub_i2zm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call zmi2m(ival(j, k), mtlvzm)
            call zmsub(mtlvzm, ma%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_i2zm

   function fmsub_r2zm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmsub(mtlvzm, ma%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_r2zm

   function fmsub_d2zm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmsub(mtlvzm, ma%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_d2zm

   function fmsub_z2zm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmsub(mtlvzm, ma%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_z2zm

   function fmsub_c2zm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmsub(mtlvzm, ma%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_c2zm

   function fmsub_zm2zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(ma(j, k)%mzm, mb%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zm2zm

!             (6) rank 2  -  rank 2

   function fmsub_zm2i2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmi2m(ival(j, k), mtlvzm)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zm2i2

   function fmsub_zm2r2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zm2r2

   function fmsub_zm2d2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zm2d2

   function fmsub_zm2z2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zm2z2

   function fmsub_zm2c2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmsub(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zm2c2

   function fmsub_i2zm2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_i2zm2

   function fmsub_r2zm2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_r2zm2

   function fmsub_d2zm2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_d2zm2

   function fmsub_z2zm2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_z2zm2

   function fmsub_c2zm2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_c2zm2

   function fmsub_zm2zm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(ma(j, k)%mzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zm2zm2

   function fmsub_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call fmsub(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmsub_fm1

   function fmsub_im1(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      n = size(ma)
      call imi2m(0, mtlvim)
      do j = 1, n
         call imsub(mtlvim, ma(j)%mim, return_value(j)%mim)
      enddo
   end function fmsub_im1

   function fmsub_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmi2m(0, mtlvzm)
      do j = 1, n
         call zmsub(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmsub_zm1

   function fmsub_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsub(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsub_fm2

   function fmsub_im2(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(0, mtlvim)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imsub(mtlvim, ma(j, k)%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmsub_im2

   function fmsub_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmi2m(0, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsub(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsub_zm2

 end module fmzm_5

 module fmzm_6
    use fmzm_1

    interface operator (*)
       module procedure fmmpy_ifm
       module procedure fmmpy_iim
       module procedure fmmpy_izm
       module procedure fmmpy_rfm
       module procedure fmmpy_rim
       module procedure fmmpy_rzm
       module procedure fmmpy_dfm
       module procedure fmmpy_dim
       module procedure fmmpy_dzm
       module procedure fmmpy_zfm
       module procedure fmmpy_zim
       module procedure fmmpy_zzm
       module procedure fmmpy_cfm
       module procedure fmmpy_cim
       module procedure fmmpy_czm
       module procedure fmmpy_fmi
       module procedure fmmpy_fmr
       module procedure fmmpy_fmd
       module procedure fmmpy_fmz
       module procedure fmmpy_fmc
       module procedure fmmpy_fmfm
       module procedure fmmpy_fmim
       module procedure fmmpy_fmzm
       module procedure fmmpy_imi
       module procedure fmmpy_imr
       module procedure fmmpy_imd
       module procedure fmmpy_imz
       module procedure fmmpy_imc
       module procedure fmmpy_imfm
       module procedure fmmpy_imim
       module procedure fmmpy_imzm
       module procedure fmmpy_zmi
       module procedure fmmpy_zmr
       module procedure fmmpy_zmd
       module procedure fmmpy_zmz
       module procedure fmmpy_zmc
       module procedure fmmpy_zmfm
       module procedure fmmpy_zmim
       module procedure fmmpy_zmzm
       module procedure fmmpy_ifm1
       module procedure fmmpy_rfm1
       module procedure fmmpy_dfm1
       module procedure fmmpy_zfm1
       module procedure fmmpy_cfm1
       module procedure fmmpy_fmi1
       module procedure fmmpy_fmr1
       module procedure fmmpy_fmd1
       module procedure fmmpy_fmz1
       module procedure fmmpy_fmc1
       module procedure fmmpy_fmfm1
       module procedure fmmpy_imfm1
       module procedure fmmpy_zmfm1
       module procedure fmmpy_fmim1
       module procedure fmmpy_fmzm1
       module procedure fmmpy_fm1i
       module procedure fmmpy_fm1r
       module procedure fmmpy_fm1d
       module procedure fmmpy_fm1z
       module procedure fmmpy_fm1c
       module procedure fmmpy_i1fm
       module procedure fmmpy_r1fm
       module procedure fmmpy_d1fm
       module procedure fmmpy_z1fm
       module procedure fmmpy_c1fm
       module procedure fmmpy_fm1fm
       module procedure fmmpy_fm1im
       module procedure fmmpy_fm1zm
       module procedure fmmpy_im1fm
       module procedure fmmpy_zm1fm
       module procedure fmmpy_i1fm1
       module procedure fmmpy_r1fm1
       module procedure fmmpy_d1fm1
       module procedure fmmpy_z1fm1
       module procedure fmmpy_c1fm1
       module procedure fmmpy_fm1i1
       module procedure fmmpy_fm1r1
       module procedure fmmpy_fm1d1
       module procedure fmmpy_fm1z1
       module procedure fmmpy_fm1c1
       module procedure fmmpy_fm1fm1
       module procedure fmmpy_im1fm1
       module procedure fmmpy_zm1fm1
       module procedure fmmpy_fm1im1
       module procedure fmmpy_fm1zm1
       module procedure fmmpy_iim1
       module procedure fmmpy_rim1
       module procedure fmmpy_dim1
       module procedure fmmpy_zim1
       module procedure fmmpy_cim1
       module procedure fmmpy_imi1
       module procedure fmmpy_imr1
       module procedure fmmpy_imd1
       module procedure fmmpy_imz1
       module procedure fmmpy_imc1
       module procedure fmmpy_imim1
       module procedure fmmpy_zmim1
       module procedure fmmpy_imzm1
       module procedure fmmpy_im1i
       module procedure fmmpy_im1r
       module procedure fmmpy_im1d
       module procedure fmmpy_im1z
       module procedure fmmpy_im1c
       module procedure fmmpy_i1im
       module procedure fmmpy_r1im
       module procedure fmmpy_d1im
       module procedure fmmpy_z1im
       module procedure fmmpy_c1im
       module procedure fmmpy_im1im
       module procedure fmmpy_im1zm
       module procedure fmmpy_zm1im
       module procedure fmmpy_i1im1
       module procedure fmmpy_r1im1
       module procedure fmmpy_d1im1
       module procedure fmmpy_z1im1
       module procedure fmmpy_c1im1
       module procedure fmmpy_im1i1
       module procedure fmmpy_im1r1
       module procedure fmmpy_im1d1
       module procedure fmmpy_im1z1
       module procedure fmmpy_im1c1
       module procedure fmmpy_im1im1
       module procedure fmmpy_zm1im1
       module procedure fmmpy_im1zm1
       module procedure fmmpy_izm1
       module procedure fmmpy_rzm1
       module procedure fmmpy_dzm1
       module procedure fmmpy_zzm1
       module procedure fmmpy_czm1
       module procedure fmmpy_zmi1
       module procedure fmmpy_zmr1
       module procedure fmmpy_zmd1
       module procedure fmmpy_zmz1
       module procedure fmmpy_zmc1
       module procedure fmmpy_zmzm1
       module procedure fmmpy_zm1i
       module procedure fmmpy_zm1r
       module procedure fmmpy_zm1d
       module procedure fmmpy_zm1z
       module procedure fmmpy_zm1c
       module procedure fmmpy_i1zm
       module procedure fmmpy_r1zm
       module procedure fmmpy_d1zm
       module procedure fmmpy_z1zm
       module procedure fmmpy_c1zm
       module procedure fmmpy_zm1zm
       module procedure fmmpy_i1zm1
       module procedure fmmpy_r1zm1
       module procedure fmmpy_d1zm1
       module procedure fmmpy_z1zm1
       module procedure fmmpy_c1zm1
       module procedure fmmpy_zm1i1
       module procedure fmmpy_zm1r1
       module procedure fmmpy_zm1d1
       module procedure fmmpy_zm1z1
       module procedure fmmpy_zm1c1
       module procedure fmmpy_zm1zm1
       module procedure fmmpy_ifm2
       module procedure fmmpy_rfm2
       module procedure fmmpy_dfm2
       module procedure fmmpy_zfm2
       module procedure fmmpy_cfm2
       module procedure fmmpy_fmi2
       module procedure fmmpy_fmr2
       module procedure fmmpy_fmd2
       module procedure fmmpy_fmz2
       module procedure fmmpy_fmc2
       module procedure fmmpy_fmfm2
       module procedure fmmpy_imfm2
       module procedure fmmpy_zmfm2
       module procedure fmmpy_fmim2
       module procedure fmmpy_fmzm2
       module procedure fmmpy_fm2i
       module procedure fmmpy_fm2r
       module procedure fmmpy_fm2d
       module procedure fmmpy_fm2z
       module procedure fmmpy_fm2c
       module procedure fmmpy_i2fm
       module procedure fmmpy_r2fm
       module procedure fmmpy_d2fm
       module procedure fmmpy_z2fm
       module procedure fmmpy_c2fm
       module procedure fmmpy_fm2fm
       module procedure fmmpy_fm2im
       module procedure fmmpy_fm2zm
       module procedure fmmpy_im2fm
       module procedure fmmpy_zm2fm
       module procedure fmmpy_i2fm2
       module procedure fmmpy_r2fm2
       module procedure fmmpy_d2fm2
       module procedure fmmpy_z2fm2
       module procedure fmmpy_c2fm2
       module procedure fmmpy_fm2i2
       module procedure fmmpy_fm2r2
       module procedure fmmpy_fm2d2
       module procedure fmmpy_fm2z2
       module procedure fmmpy_fm2c2
       module procedure fmmpy_fm2fm2
       module procedure fmmpy_im2fm2
       module procedure fmmpy_zm2fm2
       module procedure fmmpy_fm2im2
       module procedure fmmpy_fm2zm2
       module procedure fmmpy_iim2
       module procedure fmmpy_rim2
       module procedure fmmpy_dim2
       module procedure fmmpy_zim2
       module procedure fmmpy_cim2
       module procedure fmmpy_imi2
       module procedure fmmpy_imr2
       module procedure fmmpy_imd2
       module procedure fmmpy_imz2
       module procedure fmmpy_imc2
       module procedure fmmpy_imim2
       module procedure fmmpy_zmim2
       module procedure fmmpy_imzm2
       module procedure fmmpy_im2i
       module procedure fmmpy_im2r
       module procedure fmmpy_im2d
       module procedure fmmpy_im2z
       module procedure fmmpy_im2c
       module procedure fmmpy_i2im
       module procedure fmmpy_r2im
       module procedure fmmpy_d2im
       module procedure fmmpy_z2im
       module procedure fmmpy_c2im
       module procedure fmmpy_im2im
       module procedure fmmpy_im2zm
       module procedure fmmpy_zm2im
       module procedure fmmpy_i2im2
       module procedure fmmpy_r2im2
       module procedure fmmpy_d2im2
       module procedure fmmpy_z2im2
       module procedure fmmpy_c2im2
       module procedure fmmpy_im2i2
       module procedure fmmpy_im2r2
       module procedure fmmpy_im2d2
       module procedure fmmpy_im2z2
       module procedure fmmpy_im2c2
       module procedure fmmpy_im2im2
       module procedure fmmpy_zm2im2
       module procedure fmmpy_im2zm2
       module procedure fmmpy_izm2
       module procedure fmmpy_rzm2
       module procedure fmmpy_dzm2
       module procedure fmmpy_zzm2
       module procedure fmmpy_czm2
       module procedure fmmpy_zmi2
       module procedure fmmpy_zmr2
       module procedure fmmpy_zmd2
       module procedure fmmpy_zmz2
       module procedure fmmpy_zmc2
       module procedure fmmpy_zmzm2
       module procedure fmmpy_zm2i
       module procedure fmmpy_zm2r
       module procedure fmmpy_zm2d
       module procedure fmmpy_zm2z
       module procedure fmmpy_zm2c
       module procedure fmmpy_i2zm
       module procedure fmmpy_r2zm
       module procedure fmmpy_d2zm
       module procedure fmmpy_z2zm
       module procedure fmmpy_c2zm
       module procedure fmmpy_zm2zm
       module procedure fmmpy_i2zm2
       module procedure fmmpy_r2zm2
       module procedure fmmpy_d2zm2
       module procedure fmmpy_z2zm2
       module procedure fmmpy_c2zm2
       module procedure fmmpy_zm2i2
       module procedure fmmpy_zm2r2
       module procedure fmmpy_zm2d2
       module procedure fmmpy_zm2z2
       module procedure fmmpy_zm2c2
       module procedure fmmpy_zm2zm2
    end interface

 contains

!                                                                   *

   function fmmpy_ifm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      call fm_undef_inp(ma)
      call fmmpyi(ma%mfm, ival, return_value%mfm)
   end function fmmpy_ifm

   function fmmpy_iim(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      call fm_undef_inp(ma)
      call immpyi(ma%mim, ival, return_value%mim)
   end function fmmpy_iim

   function fmmpy_izm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      call fm_undef_inp(ma)
      call zmmpyi(ma%mzm, ival, return_value%mzm)
   end function fmmpy_izm

   function fmmpy_rfm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmmpy(mtlvfm, ma%mfm, return_value%mfm)
   end function fmmpy_rfm

   function fmmpy_rim(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      call fmmpy(mtlvfm, mulvfm, return_value%mfm)
   end function fmmpy_rim

   function fmmpy_rzm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmmpy(mtlvzm, ma%mzm, return_value%mzm)
   end function fmmpy_rzm

   function fmmpy_dfm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmmpy(mtlvfm, ma%mfm, return_value%mfm)
   end function fmmpy_dfm

   function fmmpy_dim(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      call fmmpy(mtlvfm, mulvfm, return_value%mfm)
   end function fmmpy_dim

   function fmmpy_dzm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmmpy(mtlvzm, ma%mzm, return_value%mzm)
   end function fmmpy_dzm

   function fmmpy_zfm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      call zmcmpx(ma%mfm, mulvfm, mulvzm)
      call zmmpy(mtlvzm, mulvzm, return_value%mzm)
   end function fmmpy_zfm

   function fmmpy_zim(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmmpy(mtlvzm, mulvzm, return_value%mzm)
   end function fmmpy_zim

   function fmmpy_zzm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      complex :: z
      intent (in) :: z, ma
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call zmmpy(mtlvzm, ma%mzm, return_value%mzm)
   end function fmmpy_zzm

   function fmmpy_cfm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      call zmcmpx(ma%mfm, mulvfm, mulvzm)
      call zmmpy(mtlvzm, mulvzm, return_value%mzm)
   end function fmmpy_cfm

   function fmmpy_cim(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmmpy(mtlvzm, mulvzm, return_value%mzm)
   end function fmmpy_cim

   function fmmpy_czm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmmpy(mtlvzm, ma%mzm, return_value%mzm)
   end function fmmpy_czm

   function fmmpy_fmi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      call fm_undef_inp(ma)
      call fmmpyi(ma%mfm, ival, return_value%mfm)
   end function fmmpy_fmi

   function fmmpy_fmr(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmmpy(ma%mfm, mtlvfm, return_value%mfm)
   end function fmmpy_fmr

   function fmmpy_fmd(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmmpy(ma%mfm, mtlvfm, return_value%mfm)
   end function fmmpy_fmd

   function fmmpy_fmz(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      call zmcmpx(ma%mfm, mulvfm, mulvzm)
      call zmmpy(mulvzm, mtlvzm, return_value%mzm)
   end function fmmpy_fmz

   function fmmpy_fmc(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      call zmcmpx(ma%mfm, mulvfm, mulvzm)
      call zmmpy(mulvzm, mtlvzm, return_value%mzm)
   end function fmmpy_fmc

   function fmmpy_fmfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmmpy(ma%mfm, mb%mfm, return_value%mfm)
   end function fmmpy_fmfm

   function fmmpy_fmim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      type (im) :: mb
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, mtlvfm)
      call fmmpy(ma%mfm, mtlvfm, return_value%mfm)
   end function fmmpy_fmim

   function fmmpy_fmzm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (zm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm)
      call zmmpy(mtlvzm, mb%mzm, return_value%mzm)
   end function fmmpy_fmzm

   function fmmpy_imi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      call fm_undef_inp(ma)
      call immpyi(ma%mim, ival, return_value%mim)
   end function fmmpy_imi

   function fmmpy_imr(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      call fmmpy(mulvfm, mtlvfm, return_value%mfm)
   end function fmmpy_imr

   function fmmpy_imd(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      call fmmpy(mulvfm, mtlvfm, return_value%mfm)
   end function fmmpy_imd

   function fmmpy_imz(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmmpy(mulvzm, mtlvzm, return_value%mzm)
   end function fmmpy_imz

   function fmmpy_imc(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmmpy(mulvzm, mtlvzm, return_value%mzm)
   end function fmmpy_imc

   function fmmpy_imfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (fm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(ma%mim, mtlvfm)
      call fmmpy(mtlvfm, mb%mfm, return_value%mfm)
   end function fmmpy_imfm

   function fmmpy_imim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call immpy(ma%mim, mb%mim, return_value%mim)
   end function fmmpy_imim

   function fmmpy_imzm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (zm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mulvfm, mulvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmmpy(mulvzm, mb%mzm, return_value%mzm)
   end function fmmpy_imzm

   function fmmpy_zmi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      call fm_undef_inp(ma)
      call zmmpyi(ma%mzm, ival, return_value%mzm)
   end function fmmpy_zmi

   function fmmpy_zmr(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmmpy(ma%mzm, mtlvzm, return_value%mzm)
   end function fmmpy_zmr

   function fmmpy_zmd(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmmpy(ma%mzm, mtlvzm, return_value%mzm)
   end function fmmpy_zmd

   function fmmpy_zmz(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call zmmpy(ma%mzm, mtlvzm, return_value%mzm)
   end function fmmpy_zmz

   function fmmpy_zmc(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmmpy(ma%mzm, mtlvzm, return_value%mzm)
   end function fmmpy_zmc

   function fmmpy_zmfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: mb
      type (zm) :: ma, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm)
      call zmmpy(ma%mzm, mtlvzm, return_value%mzm)
   end function fmmpy_zmfm

   function fmmpy_zmim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: mb
      type (zm) :: ma, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mulvfm, mulvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmmpy(ma%mzm, mulvzm, return_value%mzm)
   end function fmmpy_zmim

   function fmmpy_zmzm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmmpy(ma%mzm, mb%mzm, return_value%mzm)
   end function fmmpy_zmzm

!             Array multiplication operations for FM.

!             (1) rank 0  *  rank 1

   function fmmpy_ifm1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmi2m(ival, mtlvfm)
      do j = 1, n
         call fmmpy(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmmpy_ifm1

   function fmmpy_rfm1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, n
         call fmmpy(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmmpy_rfm1

   function fmmpy_dfm1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, n
         call fmmpy(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmmpy_dfm1

   function fmmpy_zfm1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zfm1

   function fmmpy_cfm1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_cfm1

   function fmmpy_fmi1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm)
         call fmmpy(ma%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_fmi1

   function fmmpy_fmr1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmmpy(ma%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_fmr1

   function fmmpy_fmd1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmmpy(ma%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_fmd1

   function fmmpy_fmz1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(ma%mfm, mulvfm, mulvzm)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_fmz1

   function fmmpy_fmc1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(ma%mfm, mulvfm, mulvzm)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_fmc1

   function fmmpy_fmfm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      do j = 1, n
         call fmmpy(ma%mfm, mb(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmmpy_fmfm1

   function fmmpy_imfm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      call imi2fm(ma%mim, mtlvfm)
      do j = 1, n
         call fmmpy(mtlvfm, mb(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmmpy_imfm1

   function fmmpy_zmfm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (fm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, n	
         call zmcmpx(mb(j)%mfm, mtlvfm, mtlvzm)
         call zmmpy(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zmfm1

   function fmmpy_fmim1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (im), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      do j = 1, n
         call imi2fm(mb(j)%mim, mtlvfm)
         call fmmpy(ma%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_fmim1

   function fmmpy_fmzm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm)
      do j = 1, n
         call zmmpy(mtlvzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_fmzm1

!             (2) rank 1  *  rank 0

   function fmmpy_fm1i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmi2m(ival, mtlvfm)
      do j = 1, n
         call fmmpy(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_fm1i

   function fmmpy_fm1r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, n
         call fmmpy(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_fm1r

   function fmmpy_fm1d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, n
         call fmmpy(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_fm1d

   function fmmpy_fm1z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_fm1z

   function fmmpy_fm1c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_fm1c

   function fmmpy_i1fm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm)
         call fmmpy(mtlvfm, ma%mfm, return_value(j)%mfm)
      enddo
   end function fmmpy_i1fm

   function fmmpy_r1fm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmmpy(mtlvfm, ma%mfm, return_value(j)%mfm)
      enddo
   end function fmmpy_r1fm

   function fmmpy_d1fm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmmpy(mtlvfm, ma%mfm, return_value(j)%mfm)
      enddo
   end function fmmpy_d1fm

   function fmmpy_z1fm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(ma%mfm, mulvfm, mulvzm)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_z1fm

   function fmmpy_c1fm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(ma%mfm, mulvfm, mulvzm)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_c1fm

   function fmmpy_fm1fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      do j = 1, n
         call fmmpy(ma(j)%mfm, mb%mfm, return_value(j)%mfm)
      enddo
   end function fmmpy_fm1fm

   function fmmpy_fm1im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (im) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      call imi2fm(mb%mim, mtlvfm)
      do j = 1, n
         call fmmpy(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_fm1im

   function fmmpy_fm1zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mtlvfm, mtlvzm)
         call zmmpy(mtlvzm, mb%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_fm1zm

   function fmmpy_im1fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call fmmpy(mtlvfm, mb%mfm, return_value(j)%mfm)
      enddo
   end function fmmpy_im1fm

   function fmmpy_zm1fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (fm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm)
      do j = 1, n
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zm1fm

!             (3) rank 1  *  rank 1

   function fmmpy_fm1i1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm)
         call fmmpy(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_fm1i1

   function fmmpy_fm1r1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmmpy(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_fm1r1

   function fmmpy_fm1d1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmmpy(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_fm1d1

   function fmmpy_fm1z1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_fm1z1

   function fmmpy_fm1c1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_fm1c1

   function fmmpy_i1fm1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm)
         call fmmpy(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmmpy_i1fm1

   function fmmpy_r1fm1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmmpy(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmmpy_r1fm1

   function fmmpy_d1fm1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmmpy(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmmpy_d1fm1

   function fmmpy_z1fm1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(z)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_z1fm1

   function fmmpy_c1fm1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_c1fm1

   function fmmpy_fm1fm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmmpy(ma(j)%mfm, mb(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmmpy_fm1fm1

   function fmmpy_fm1im1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2fm(mb(j)%mim, mtlvfm)
         call fmmpy(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_fm1im1

   function fmmpy_fm1zm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mtlvfm, mtlvzm)
         call zmmpy(mtlvzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_fm1zm1

   function fmmpy_im1fm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call fmmpy(mtlvfm, mb(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmmpy_im1fm1

   function fmmpy_zm1fm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call zmcmpx(mb(j)%mfm, mtlvfm, mtlvzm)
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zm1fm1

!             (4) rank 0  *  rank 2

   function fmmpy_ifm2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmmpy(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_ifm2

   function fmmpy_rfm2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmmpy(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_rfm2

   function fmmpy_dfm2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmmpy(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_dfm2

   function fmmpy_zfm2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zfm2

   function fmmpy_cfm2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_cfm2

   function fmmpy_fmi2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call fmi2m(ival(j, k), mtlvfm)
            call fmmpy(ma%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_fmi2

   function fmmpy_fmr2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmmpy(ma%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_fmr2

   function fmmpy_fmd2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmmpy(ma%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_fmd2

   function fmmpy_fmz2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(ma%mfm, mulvfm, mulvzm)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_fmz2

   function fmmpy_fmc2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(ma%mfm, mulvfm, mulvzm)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_fmc2

   function fmmpy_fmfm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call fmmpy(ma%mfm, mb(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_fmfm2

   function fmmpy_imfm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(ma%mim, mtlvfm)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call fmmpy(mtlvfm, mb(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_imfm2

   function fmmpy_zmfm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (fm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmcmpx(mb(j, k)%mfm, mtlvfm, mtlvzm)
            call zmmpy(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zmfm2

   function fmmpy_fmim2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (im), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imi2fm(mb(j, k)%mim, mtlvfm)
            call fmmpy(ma%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_fmim2

   function fmmpy_fmzm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmmpy(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_fmzm2

!             (5) rank 2  *  rank 0

   function fmmpy_fm2i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmmpy(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_fm2i

   function fmmpy_fm2r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmmpy(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_fm2r

   function fmmpy_fm2d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmmpy(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_fm2d

   function fmmpy_fm2z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_fm2z

   function fmmpy_fm2c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_fm2c

   function fmmpy_i2fm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call fmi2m(ival(j, k), mtlvfm)
            call fmmpy(mtlvfm, ma%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_i2fm

   function fmmpy_r2fm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmmpy(mtlvfm, ma%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_r2fm

   function fmmpy_d2fm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmmpy(mtlvfm, ma%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_d2fm

   function fmmpy_z2fm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(ma%mfm, mulvfm, mulvzm)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_z2fm

   function fmmpy_c2fm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(ma%mfm, mulvfm, mulvzm)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_c2fm

   function fmmpy_fm2fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmmpy(ma(j, k)%mfm, mb%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_fm2fm

   function fmmpy_fm2im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmmpy(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_fm2im

   function fmmpy_fm2zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mtlvfm, mtlvzm)
            call zmmpy(mtlvzm, mb%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_fm2zm

   function fmmpy_im2fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call fmmpy(mtlvfm, mb%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_im2fm

   function fmmpy_zm2fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zm2fm

!             (6) rank 2  *  rank 2

   function fmmpy_fm2i2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm)
            call fmmpy(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_fm2i2

   function fmmpy_fm2r2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmmpy(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_fm2r2

   function fmmpy_fm2d2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmmpy(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_fm2d2

   function fmmpy_fm2z2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_fm2z2

   function fmmpy_fm2c2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_fm2c2

   function fmmpy_i2fm2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm)
            call fmmpy(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_i2fm2

   function fmmpy_r2fm2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmmpy(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_r2fm2

   function fmmpy_d2fm2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmmpy(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_d2fm2

   function fmmpy_z2fm2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_z2fm2

   function fmmpy_c2fm2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_c2fm2

   function fmmpy_fm2fm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmmpy(ma(j, k)%mfm, mb(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_fm2fm2

   function fmmpy_fm2im2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(mb(j, k)%mim, mtlvfm)
            call fmmpy(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_fm2im2

   function fmmpy_fm2zm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mtlvfm, mtlvzm)
            call zmmpy(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_fm2zm2

   function fmmpy_im2fm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call fmmpy(mtlvfm, mb(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_im2fm2

   function fmmpy_zm2fm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(mb(j, k)%mfm, mtlvfm, mtlvzm)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zm2fm2

!             Array multiplication operations for IM.

!             (1) rank 0  *  rank 1

   function fmmpy_iim1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      n = size(ma)
      call imi2m(ival, mtlvim)
      do j = 1, n
         call immpy(mtlvim, ma(j)%mim, return_value(j)%mim)
      enddo
   end function fmmpy_iim1

   function fmmpy_rim1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mulvfm)
         call fmmpy(mtlvfm, mulvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_rim1

   function fmmpy_dim1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mulvfm)
         call fmmpy(mtlvfm, mulvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_dim1

   function fmmpy_zim1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mulvzm)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zim1

   function fmmpy_cim1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mulvzm)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_cim1

   function fmmpy_imi1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim)
         call immpy(ma%mim, mtlvim, return_value(j)%mim)
      enddo
   end function fmmpy_imi1

   function fmmpy_imr1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      n = size(r)
      call imi2fm(ma%mim, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmmpy(mulvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_imr1

   function fmmpy_imd1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      n = size(d)
      call imi2fm(ma%mim, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmmpy(mulvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_imd1

   function fmmpy_imz1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(mtlvfm, mulvfm, mulvzm)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_imz1

   function fmmpy_imc1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(mvlvfm, mulvfm, mulvzm)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_imc1

   function fmmpy_imim1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (im), dimension(:) :: mb
      type (im), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      do j = 1, n
         call immpy(ma%mim, mb(j)%mim, return_value(j)%mim)
      enddo
   end function fmmpy_imim1

   function fmmpy_zmim1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (im), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mvlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call imi2fm(mb(j)%mim, mvlvfm)
         call zmcmpx(mvlvfm, mtlvfm, mtlvzm)
         call zmmpy(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zmim1

   function fmmpy_imzm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mvlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      call imi2fm(ma%mim, mvlvfm)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mvlvfm, mtlvfm, mtlvzm)
      do j = 1, n
         call zmmpy(mtlvzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_imzm1

!             (2) rank 1  *  rank 0

   function fmmpy_im1i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      n = size(ma)
      call imi2m(ival, mtlvim)
      do j = 1, n
         call immpy(ma(j)%mim, mtlvim, return_value(j)%mim)
      enddo
   end function fmmpy_im1i

   function fmmpy_im1r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm)
         call fmmpy(mvlvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_im1r

   function fmmpy_im1d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm)
         call fmmpy(mvlvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_im1d

   function fmmpy_im1z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm)
         call zmcmpx(mvlvfm, mulvfm, mulvzm)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_im1z

   function fmmpy_im1c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm)
         call zmcmpx(mvlvfm, mulvfm, mulvzm)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_im1c

   function fmmpy_i1im(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim)
         call immpy(mtlvim, ma%mim, return_value(j)%mim)
      enddo
   end function fmmpy_i1im

   function fmmpy_r1im(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      n = size(r)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmmpy(mtlvfm, mvlvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_r1im

   function fmmpy_d1im(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      n = size(d)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmmpy(mtlvfm, mvlvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_d1im

   function fmmpy_z1im(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      call imi2fm(ma%mim, mvlvfm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(mvlvfm, mulvfm, mulvzm)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_z1im

   function fmmpy_c1im(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      call imi2fm(ma%mim, m1lvfm)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(m1lvfm, mulvfm, mulvzm)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_c1im

   function fmmpy_im1im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im) :: mb
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      do j = 1, n
         call immpy(ma(j)%mim, mb%mim, return_value(j)%mim)
      enddo
   end function fmmpy_im1im

   function fmmpy_im1zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
         call zmmpy(m1lvzm, mb%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_im1zm

   function fmmpy_zm1im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (im) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      call imi2fm(mb%mim, m1lvfm)
      call fmi2m(0, mtlvfm)
      call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
      do j = 1, n
         call zmmpy(ma(j)%mzm, m1lvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zm1im

!             (3) rank 1  *  rank 1

   function fmmpy_im1i1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2m(ival(j), mtlvim)
         call immpy(ma(j)%mim, mtlvim, return_value(j)%mim)
      enddo
   end function fmmpy_im1i1

   function fmmpy_im1r1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmmpy(m1lvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_im1r1

   function fmmpy_im1d1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmmpy(m1lvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_im1d1

   function fmmpy_im1z1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call imi2fm(ma(j)%mim, m1lvfm)
         call zmcmpx(m1lvfm, mulvfm, mulvzm)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_im1z1

   function fmmpy_im1c1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmi2m(0, mulvfm)
         call zmcmpx(m1lvfm, mulvfm, mulvzm)
         call zmmpy(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_im1c1

   function fmmpy_i1im1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim)
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim)
         call immpy(mtlvim, ma(j)%mim, return_value(j)%mim)
      enddo
   end function fmmpy_i1im1

   function fmmpy_r1im1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmsp2m(r(j), mtlvfm)
         call fmmpy(mtlvfm, m1lvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_r1im1

   function fmmpy_d1im1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmdp2m(d(j), mtlvfm)
         call fmmpy(mtlvfm, m1lvfm, return_value(j)%mfm)
      enddo
   end function fmmpy_d1im1

   function fmmpy_z1im1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(z)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call imi2fm(ma(j)%mim, m1lvfm)
         call zmcmpx(m1lvfm, mulvfm, mulvzm)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_z1im1

   function fmmpy_c1im1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(m1lvfm, mulvfm, mulvzm)
         call zmmpy(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_c1im1

   function fmmpy_im1im1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call immpy(ma(j)%mim, mb(j)%mim, return_value(j)%mim)
      enddo
   end function fmmpy_im1im1

   function fmmpy_im1zm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
         call zmmpy(m1lvzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_im1zm1

   function fmmpy_zm1im1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call imi2fm(mb(j)%mim, m1lvfm)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
         call zmmpy(ma(j)%mzm, m1lvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zm1im1

!             (4) rank 0  *  rank 2

   function fmmpy_iim2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call immpy(mtlvim, ma(j, k)%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmmpy_iim2

   function fmmpy_rim2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mulvfm)
            call fmmpy(mtlvfm, mulvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_rim2

   function fmmpy_dim2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mulvfm)
            call fmmpy(mtlvfm, mulvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_dim2

   function fmmpy_zim2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mulvzm)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zim2

   function fmmpy_cim2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mulvzm)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_cim2

   function fmmpy_imi2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call imi2m(ival(j, k), mtlvim)
            call immpy(ma%mim, mtlvim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmmpy_imi2

   function fmmpy_imr2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mulvfm)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmmpy(mulvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_imr2

   function fmmpy_imd2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mulvfm)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmmpy(mulvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_imd2

   function fmmpy_imz2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(mtlvfm, mulvfm, mulvzm)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_imz2

   function fmmpy_imc2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(mvlvfm, mulvfm, mulvzm)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_imc2

   function fmmpy_imim2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (im), dimension(:,:) :: mb
      type (im), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call immpy(ma%mim, mb(j, k)%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmmpy_imim2

   function fmmpy_zmim2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (im), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mvlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imi2fm(mb(j, k)%mim, mvlvfm)
            call zmcmpx(mvlvfm, mtlvfm, mtlvzm)
            call zmmpy(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zmim2

   function fmmpy_imzm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mvlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(ma%mim, mvlvfm)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mvlvfm, mtlvfm, mtlvzm)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmmpy(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_imzm2

!             (5) rank 2  *  rank 0

   function fmmpy_im2i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call immpy(ma(j, k)%mim, mtlvim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmmpy_im2i

   function fmmpy_im2r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm)
            call fmmpy(mvlvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_im2r

   function fmmpy_im2d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm)
            call fmmpy(mvlvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_im2d

   function fmmpy_im2z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm)
            call zmcmpx(mvlvfm, mulvfm, mulvzm)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_im2z

   function fmmpy_im2c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm)
            call zmcmpx(mvlvfm, mulvfm, mulvzm)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_im2c

   function fmmpy_i2im(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call imi2m(ival(j, k), mtlvim)
            call immpy(mtlvim, ma%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmmpy_i2im

   function fmmpy_r2im(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmmpy(mtlvfm, mvlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_r2im

   function fmmpy_d2im(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmmpy(mtlvfm, mvlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_d2im

   function fmmpy_z2im(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mvlvfm)
      call fmi2m(0, mulvfm)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(mvlvfm, mulvfm, mulvzm)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_z2im

   function fmmpy_c2im(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, m1lvfm)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(m1lvfm, mulvfm, mulvzm)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_c2im

   function fmmpy_im2im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im) :: mb
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call immpy(ma(j, k)%mim, mb%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmmpy_im2im

   function fmmpy_im2zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
            call zmmpy(m1lvzm, mb%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_im2zm

   function fmmpy_zm2im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, m1lvfm)
      call fmi2m(0, mtlvfm)
      call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(ma(j, k)%mzm, m1lvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zm2im

!             (6) rank 2  *  rank 2

   function fmmpy_im2i2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2m(ival(j, k), mtlvim)
            call immpy(ma(j, k)%mim, mtlvim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmmpy_im2i2

   function fmmpy_im2r2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmmpy(m1lvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_im2r2

   function fmmpy_im2d2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmmpy(m1lvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_im2d2

   function fmmpy_im2z2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call zmcmpx(m1lvfm, mulvfm, mulvzm)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_im2z2

   function fmmpy_im2c2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmi2m(0, mulvfm)
            call zmcmpx(m1lvfm, mulvfm, mulvzm)
            call zmmpy(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_im2c2

   function fmmpy_i2im2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2m(ival(j, k), mtlvim)
            call immpy(mtlvim, ma(j, k)%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmmpy_i2im2

   function fmmpy_r2im2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmsp2m(r(j, k), mtlvfm)
            call fmmpy(mtlvfm, m1lvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_r2im2

   function fmmpy_d2im2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmdp2m(d(j, k), mtlvfm)
            call fmmpy(mtlvfm, m1lvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmmpy_d2im2

   function fmmpy_z2im2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call zmcmpx(m1lvfm, mulvfm, mulvzm)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_z2im2

   function fmmpy_c2im2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(m1lvfm, mulvfm, mulvzm)
            call zmmpy(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_c2im2

   function fmmpy_im2im2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call immpy(ma(j, k)%mim, mb(j, k)%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmmpy_im2im2

   function fmmpy_im2zm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
            call zmmpy(m1lvzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_im2zm2

   function fmmpy_zm2im2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(mb(j, k)%mim, m1lvfm)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
            call zmmpy(ma(j, k)%mzm, m1lvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zm2im2

!             Array multiplication operations for ZM.

!             (1) rank 0  *  rank 1

   function fmmpy_izm1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmi2m(ival, mtlvzm)
      do j = 1, n
         call zmmpy(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_izm1

   function fmmpy_rzm1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmmpy(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_rzm1

   function fmmpy_dzm1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmmpy(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_dzm1

   function fmmpy_zzm1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      do j = 1, n
         call zmmpy(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zzm1

   function fmmpy_czm1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmmpy(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_czm1

   function fmmpy_zmi1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm)
         call zmmpy(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zmi1

   function fmmpy_zmr1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(r)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmmpy(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zmr1

   function fmmpy_zmd1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(d)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmmpy(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zmd1

   function fmmpy_zmz1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmmpy(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zmz1

   function fmmpy_zmc1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmmpy(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zmc1

   function fmmpy_zmzm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      do j = 1, n
         call zmmpy(ma%mzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zmzm1

!             (2) rank 1  *  rank 0

   function fmmpy_zm1i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmi2m(ival, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zm1i

   function fmmpy_zm1r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zm1r

   function fmmpy_zm1d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zm1d

   function fmmpy_zm1z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      do j = 1, n
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zm1z

   function fmmpy_zm1c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zm1c

   function fmmpy_i1zm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm)
         call zmmpy(mtlvzm, ma%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_i1zm

   function fmmpy_r1zm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(r)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmmpy(mtlvzm, ma%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_r1zm

   function fmmpy_d1zm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(d)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmmpy(mtlvzm, ma%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_d1zm

   function fmmpy_z1zm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmmpy(mtlvzm, ma%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_z1zm

   function fmmpy_c1zm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmmpy(mtlvzm, ma%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_c1zm

   function fmmpy_zm1zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      do j = 1, n
         call zmmpy(ma(j)%mzm, mb%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zm1zm

!             (3) rank 1  *  rank 1

   function fmmpy_zm1i1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm)
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zm1i1

   function fmmpy_zm1r1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zm1r1

   function fmmpy_zm1d1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zm1d1

   function fmmpy_zm1z1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zm1z1

   function fmmpy_zm1c1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmmpy(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zm1c1

   function fmmpy_i1zm1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ival)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmmpy(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_i1zm1

   function fmmpy_r1zm1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(r)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmmpy(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_r1zm1

   function fmmpy_d1zm1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(d)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmmpy(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_d1zm1

   function fmmpy_z1zm1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmmpy(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_z1zm1

   function fmmpy_c1zm1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmmpy(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_c1zm1

   function fmmpy_zm1zm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmmpy(ma(j)%mzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmmpy_zm1zm1

!             (4) rank 0  *  rank 2

   function fmmpy_izm2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmi2m(ival, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_izm2

   function fmmpy_rzm2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_rzm2

   function fmmpy_dzm2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_dzm2

   function fmmpy_zzm2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zzm2

   function fmmpy_czm2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_czm2

   function fmmpy_zmi2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call zmi2m(ival(j, k), mtlvzm)
            call zmmpy(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zmi2

   function fmmpy_zmr2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmmpy(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zmr2

   function fmmpy_zmd2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmmpy(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zmd2

   function fmmpy_zmz2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmmpy(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zmz2

   function fmmpy_zmc2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmmpy(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zmc2

   function fmmpy_zmzm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmmpy(ma%mzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zmzm2

!             (5) rank 2  *  rank 0

   function fmmpy_zm2i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zm2i

   function fmmpy_zm2r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zm2r

   function fmmpy_zm2d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zm2d

   function fmmpy_zm2z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zm2z

   function fmmpy_zm2c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zm2c

   function fmmpy_i2zm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call zmi2m(ival(j, k), mtlvzm)
            call zmmpy(mtlvzm, ma%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_i2zm

   function fmmpy_r2zm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmmpy(mtlvzm, ma%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_r2zm

   function fmmpy_d2zm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmmpy(mtlvzm, ma%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_d2zm

   function fmmpy_z2zm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmmpy(mtlvzm, ma%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_z2zm

   function fmmpy_c2zm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmmpy(mtlvzm, ma%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_c2zm

   function fmmpy_zm2zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(ma(j, k)%mzm, mb%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zm2zm

!             (6) rank 2  *  rank 2

   function fmmpy_zm2i2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmi2m(ival(j, k), mtlvzm)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zm2i2

   function fmmpy_zm2r2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zm2r2

   function fmmpy_zm2d2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zm2d2

   function fmmpy_zm2z2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zm2z2

   function fmmpy_zm2c2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmmpy(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zm2c2

   function fmmpy_i2zm2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmmpy(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_i2zm2

   function fmmpy_r2zm2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmmpy(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_r2zm2

   function fmmpy_d2zm2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmmpy(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_d2zm2

   function fmmpy_z2zm2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmmpy(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_z2zm2

   function fmmpy_c2zm2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmmpy(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_c2zm2

   function fmmpy_zm2zm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmmpy(ma(j, k)%mzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmmpy_zm2zm2

 end module fmzm_6

 module fmzm_7
    use fmzm_1

    interface operator (/)
       module procedure fmdiv_ifm
       module procedure fmdiv_iim
       module procedure fmdiv_izm
       module procedure fmdiv_rfm
       module procedure fmdiv_rim
       module procedure fmdiv_rzm
       module procedure fmdiv_dfm
       module procedure fmdiv_dim
       module procedure fmdiv_dzm
       module procedure fmdiv_zfm
       module procedure fmdiv_zim
       module procedure fmdiv_zzm
       module procedure fmdiv_cfm
       module procedure fmdiv_cim
       module procedure fmdiv_czm
       module procedure fmdiv_fmi
       module procedure fmdiv_fmr
       module procedure fmdiv_fmd
       module procedure fmdiv_fmz
       module procedure fmdiv_fmc
       module procedure fmdiv_fmfm
       module procedure fmdiv_fmim
       module procedure fmdiv_fmzm
       module procedure fmdiv_imi
       module procedure fmdiv_imr
       module procedure fmdiv_imd
       module procedure fmdiv_imz
       module procedure fmdiv_imc
       module procedure fmdiv_imfm
       module procedure fmdiv_imim
       module procedure fmdiv_imzm
       module procedure fmdiv_zmi
       module procedure fmdiv_zmr
       module procedure fmdiv_zmd
       module procedure fmdiv_zmz
       module procedure fmdiv_zmc
       module procedure fmdiv_zmfm
       module procedure fmdiv_zmim
       module procedure fmdiv_zmzm
       module procedure fmdiv_ifm1
       module procedure fmdiv_rfm1
       module procedure fmdiv_dfm1
       module procedure fmdiv_zfm1
       module procedure fmdiv_cfm1
       module procedure fmdiv_fmi1
       module procedure fmdiv_fmr1
       module procedure fmdiv_fmd1
       module procedure fmdiv_fmz1
       module procedure fmdiv_fmc1
       module procedure fmdiv_fmfm1
       module procedure fmdiv_imfm1
       module procedure fmdiv_zmfm1
       module procedure fmdiv_fmim1
       module procedure fmdiv_fmzm1
       module procedure fmdiv_fm1i
       module procedure fmdiv_fm1r
       module procedure fmdiv_fm1d
       module procedure fmdiv_fm1z
       module procedure fmdiv_fm1c
       module procedure fmdiv_i1fm
       module procedure fmdiv_r1fm
       module procedure fmdiv_d1fm
       module procedure fmdiv_z1fm
       module procedure fmdiv_c1fm
       module procedure fmdiv_fm1fm
       module procedure fmdiv_fm1im
       module procedure fmdiv_fm1zm
       module procedure fmdiv_im1fm
       module procedure fmdiv_zm1fm
       module procedure fmdiv_i1fm1
       module procedure fmdiv_r1fm1
       module procedure fmdiv_d1fm1
       module procedure fmdiv_z1fm1
       module procedure fmdiv_c1fm1
       module procedure fmdiv_fm1i1
       module procedure fmdiv_fm1r1
       module procedure fmdiv_fm1d1
       module procedure fmdiv_fm1z1
       module procedure fmdiv_fm1c1
       module procedure fmdiv_fm1fm1
       module procedure fmdiv_im1fm1
       module procedure fmdiv_zm1fm1
       module procedure fmdiv_fm1im1
       module procedure fmdiv_fm1zm1
       module procedure fmdiv_iim1
       module procedure fmdiv_rim1
       module procedure fmdiv_dim1
       module procedure fmdiv_zim1
       module procedure fmdiv_cim1
       module procedure fmdiv_imi1
       module procedure fmdiv_imr1
       module procedure fmdiv_imd1
       module procedure fmdiv_imz1
       module procedure fmdiv_imc1
       module procedure fmdiv_imim1
       module procedure fmdiv_zmim1
       module procedure fmdiv_imzm1
       module procedure fmdiv_im1i
       module procedure fmdiv_im1r
       module procedure fmdiv_im1d
       module procedure fmdiv_im1z
       module procedure fmdiv_im1c
       module procedure fmdiv_i1im
       module procedure fmdiv_r1im
       module procedure fmdiv_d1im
       module procedure fmdiv_z1im
       module procedure fmdiv_c1im
       module procedure fmdiv_im1im
       module procedure fmdiv_im1zm
       module procedure fmdiv_zm1im
       module procedure fmdiv_i1im1
       module procedure fmdiv_r1im1
       module procedure fmdiv_d1im1
       module procedure fmdiv_z1im1
       module procedure fmdiv_c1im1
       module procedure fmdiv_im1i1
       module procedure fmdiv_im1r1
       module procedure fmdiv_im1d1
       module procedure fmdiv_im1z1
       module procedure fmdiv_im1c1
       module procedure fmdiv_im1im1
       module procedure fmdiv_zm1im1
       module procedure fmdiv_im1zm1
       module procedure fmdiv_izm1
       module procedure fmdiv_rzm1
       module procedure fmdiv_dzm1
       module procedure fmdiv_zzm1
       module procedure fmdiv_czm1
       module procedure fmdiv_zmi1
       module procedure fmdiv_zmr1
       module procedure fmdiv_zmd1
       module procedure fmdiv_zmz1
       module procedure fmdiv_zmc1
       module procedure fmdiv_zmzm1
       module procedure fmdiv_zm1i
       module procedure fmdiv_zm1r
       module procedure fmdiv_zm1d
       module procedure fmdiv_zm1z
       module procedure fmdiv_zm1c
       module procedure fmdiv_i1zm
       module procedure fmdiv_r1zm
       module procedure fmdiv_d1zm
       module procedure fmdiv_z1zm
       module procedure fmdiv_c1zm
       module procedure fmdiv_zm1zm
       module procedure fmdiv_i1zm1
       module procedure fmdiv_r1zm1
       module procedure fmdiv_d1zm1
       module procedure fmdiv_z1zm1
       module procedure fmdiv_c1zm1
       module procedure fmdiv_zm1i1
       module procedure fmdiv_zm1r1
       module procedure fmdiv_zm1d1
       module procedure fmdiv_zm1z1
       module procedure fmdiv_zm1c1
       module procedure fmdiv_zm1zm1
       module procedure fmdiv_ifm2
       module procedure fmdiv_rfm2
       module procedure fmdiv_dfm2
       module procedure fmdiv_zfm2
       module procedure fmdiv_cfm2
       module procedure fmdiv_fmi2
       module procedure fmdiv_fmr2
       module procedure fmdiv_fmd2
       module procedure fmdiv_fmz2
       module procedure fmdiv_fmc2
       module procedure fmdiv_fmfm2
       module procedure fmdiv_imfm2
       module procedure fmdiv_zmfm2
       module procedure fmdiv_fmim2
       module procedure fmdiv_fmzm2
       module procedure fmdiv_fm2i
       module procedure fmdiv_fm2r
       module procedure fmdiv_fm2d
       module procedure fmdiv_fm2z
       module procedure fmdiv_fm2c
       module procedure fmdiv_i2fm
       module procedure fmdiv_r2fm
       module procedure fmdiv_d2fm
       module procedure fmdiv_z2fm
       module procedure fmdiv_c2fm
       module procedure fmdiv_fm2fm
       module procedure fmdiv_fm2im
       module procedure fmdiv_fm2zm
       module procedure fmdiv_im2fm
       module procedure fmdiv_zm2fm
       module procedure fmdiv_i2fm2
       module procedure fmdiv_r2fm2
       module procedure fmdiv_d2fm2
       module procedure fmdiv_z2fm2
       module procedure fmdiv_c2fm2
       module procedure fmdiv_fm2i2
       module procedure fmdiv_fm2r2
       module procedure fmdiv_fm2d2
       module procedure fmdiv_fm2z2
       module procedure fmdiv_fm2c2
       module procedure fmdiv_fm2fm2
       module procedure fmdiv_im2fm2
       module procedure fmdiv_zm2fm2
       module procedure fmdiv_fm2im2
       module procedure fmdiv_fm2zm2
       module procedure fmdiv_iim2
       module procedure fmdiv_rim2
       module procedure fmdiv_dim2
       module procedure fmdiv_zim2
       module procedure fmdiv_cim2
       module procedure fmdiv_imi2
       module procedure fmdiv_imr2
       module procedure fmdiv_imd2
       module procedure fmdiv_imz2
       module procedure fmdiv_imc2
       module procedure fmdiv_imim2
       module procedure fmdiv_zmim2
       module procedure fmdiv_imzm2
       module procedure fmdiv_im2i
       module procedure fmdiv_im2r
       module procedure fmdiv_im2d
       module procedure fmdiv_im2z
       module procedure fmdiv_im2c
       module procedure fmdiv_i2im
       module procedure fmdiv_r2im
       module procedure fmdiv_d2im
       module procedure fmdiv_z2im
       module procedure fmdiv_c2im
       module procedure fmdiv_im2im
       module procedure fmdiv_im2zm
       module procedure fmdiv_zm2im
       module procedure fmdiv_i2im2
       module procedure fmdiv_r2im2
       module procedure fmdiv_d2im2
       module procedure fmdiv_z2im2
       module procedure fmdiv_c2im2
       module procedure fmdiv_im2i2
       module procedure fmdiv_im2r2
       module procedure fmdiv_im2d2
       module procedure fmdiv_im2z2
       module procedure fmdiv_im2c2
       module procedure fmdiv_im2im2
       module procedure fmdiv_zm2im2
       module procedure fmdiv_im2zm2
       module procedure fmdiv_izm2
       module procedure fmdiv_rzm2
       module procedure fmdiv_dzm2
       module procedure fmdiv_zzm2
       module procedure fmdiv_czm2
       module procedure fmdiv_zmi2
       module procedure fmdiv_zmr2
       module procedure fmdiv_zmd2
       module procedure fmdiv_zmz2
       module procedure fmdiv_zmc2
       module procedure fmdiv_zmzm2
       module procedure fmdiv_zm2i
       module procedure fmdiv_zm2r
       module procedure fmdiv_zm2d
       module procedure fmdiv_zm2z
       module procedure fmdiv_zm2c
       module procedure fmdiv_i2zm
       module procedure fmdiv_r2zm
       module procedure fmdiv_d2zm
       module procedure fmdiv_z2zm
       module procedure fmdiv_c2zm
       module procedure fmdiv_zm2zm
       module procedure fmdiv_i2zm2
       module procedure fmdiv_r2zm2
       module procedure fmdiv_d2zm2
       module procedure fmdiv_z2zm2
       module procedure fmdiv_c2zm2
       module procedure fmdiv_zm2i2
       module procedure fmdiv_zm2r2
       module procedure fmdiv_zm2d2
       module procedure fmdiv_zm2z2
       module procedure fmdiv_zm2c2
       module procedure fmdiv_zm2zm2
    end interface

 contains

!                                                                   /

   function fmdiv_ifm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      call fmdiv(mtlvfm, ma%mfm, return_value%mfm)
   end function fmdiv_ifm

   function fmdiv_iim(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      call imdiv(mtlvim, ma%mim, return_value%mim)
   end function fmdiv_iim

   function fmdiv_izm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmdiv(mtlvzm, ma%mzm, return_value%mzm)
   end function fmdiv_izm

   function fmdiv_rfm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmdiv(mtlvfm, ma%mfm, return_value%mfm)
   end function fmdiv_rfm

   function fmdiv_rim(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      call fmdiv(mtlvfm, mulvfm, return_value%mfm)
   end function fmdiv_rim

   function fmdiv_rzm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmdiv(mtlvzm, ma%mzm, return_value%mzm)
   end function fmdiv_rzm

   function fmdiv_dfm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmdiv(mtlvfm, ma%mfm, return_value%mfm)
   end function fmdiv_dfm

   function fmdiv_dim(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      call fmdiv(mtlvfm, mulvfm, return_value%mfm)
   end function fmdiv_dim

   function fmdiv_dzm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmdiv(mtlvzm, ma%mzm, return_value%mzm)
   end function fmdiv_dzm

   function fmdiv_zfm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      call zmcmpx(ma%mfm, mulvfm, mulvzm)
      call zmdiv(mtlvzm, mulvzm, return_value%mzm)
   end function fmdiv_zfm

   function fmdiv_zim(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmdiv(mtlvzm, mulvzm, return_value%mzm)
   end function fmdiv_zim

   function fmdiv_zzm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      complex :: z
      intent (in) :: z, ma
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call zmdiv(mtlvzm, ma%mzm, return_value%mzm)
   end function fmdiv_zzm

   function fmdiv_cfm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      call zmcmpx(ma%mfm, mulvfm, mulvzm)
      call zmdiv(mtlvzm, mulvzm, return_value%mzm)
   end function fmdiv_cfm

   function fmdiv_cim(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmdiv(mtlvzm, mulvzm, return_value%mzm)
   end function fmdiv_cim

   function fmdiv_czm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmdiv(mtlvzm, ma%mzm, return_value%mzm)
   end function fmdiv_czm

   function fmdiv_fmi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      call fm_undef_inp(ma)
      call fmdivi(ma%mfm, ival, return_value%mfm)
   end function fmdiv_fmi

   function fmdiv_fmr(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmdiv(ma%mfm, mtlvfm, return_value%mfm)
   end function fmdiv_fmr

   function fmdiv_fmd(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmdiv(ma%mfm, mtlvfm, return_value%mfm)
   end function fmdiv_fmd

   function fmdiv_fmz(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      call zmcmpx(ma%mfm, mulvfm, mulvzm)
      call zmdiv(mulvzm, mtlvzm, return_value%mzm)
   end function fmdiv_fmz

   function fmdiv_fmc(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      call zmcmpx(ma%mfm, mulvfm, mulvzm)
      call zmdiv(mulvzm, mtlvzm, return_value%mzm)
   end function fmdiv_fmc

   function fmdiv_fmfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmdiv(ma%mfm, mb%mfm, return_value%mfm)
   end function fmdiv_fmfm

   function fmdiv_fmim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      type (im) :: mb
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, mtlvfm)
      call fmdiv(ma%mfm, mtlvfm, return_value%mfm)
   end function fmdiv_fmim

   function fmdiv_fmzm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (zm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm)
      call zmdiv(mtlvzm, mb%mzm, return_value%mzm)
   end function fmdiv_fmzm

   function fmdiv_imi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      call fm_undef_inp(ma)
      call imdivi(ma%mim, ival, return_value%mim)
   end function fmdiv_imi

   function fmdiv_imr(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      call fmdiv(mulvfm, mtlvfm, return_value%mfm)
   end function fmdiv_imr

   function fmdiv_imd(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      call fmdiv(mulvfm, mtlvfm, return_value%mfm)
   end function fmdiv_imd

   function fmdiv_imz(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmdiv(mulvzm, mtlvzm, return_value%mzm)
   end function fmdiv_imz

   function fmdiv_imc(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmdiv(mulvzm, mtlvzm, return_value%mzm)
   end function fmdiv_imc

   function fmdiv_imfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (fm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(ma%mim, mtlvfm)
      call fmdiv(mtlvfm, mb%mfm, return_value%mfm)
   end function fmdiv_imfm

   function fmdiv_imim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imdiv(ma%mim, mb%mim, return_value%mim)
   end function fmdiv_imim

   function fmdiv_imzm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (zm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mulvfm, mulvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmdiv(mulvzm, mb%mzm, return_value%mzm)
   end function fmdiv_imzm

   function fmdiv_zmi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      call fm_undef_inp(ma)
      call zmdivi(ma%mzm, ival, return_value%mzm)
   end function fmdiv_zmi

   function fmdiv_zmr(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmdiv(ma%mzm, mtlvzm, return_value%mzm)
   end function fmdiv_zmr

   function fmdiv_zmd(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmdiv(ma%mzm, mtlvzm, return_value%mzm)
   end function fmdiv_zmd

   function fmdiv_zmz(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call zmdiv(ma%mzm, mtlvzm, return_value%mzm)
   end function fmdiv_zmz

   function fmdiv_zmc(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmdiv(ma%mzm, mtlvzm, return_value%mzm)
   end function fmdiv_zmc

   function fmdiv_zmfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: mb
      type (zm) :: ma, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm)
      call zmdiv(ma%mzm, mtlvzm, return_value%mzm)
   end function fmdiv_zmfm

   function fmdiv_zmim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: mb
      type (zm) :: ma, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mulvfm, mulvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmdiv(ma%mzm, mulvzm, return_value%mzm)
   end function fmdiv_zmim

   function fmdiv_zmzm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmdiv(ma%mzm, mb%mzm, return_value%mzm)
   end function fmdiv_zmzm

!             Array division operations for FM.

!             (1) rank 0  /  rank 1

   function fmdiv_ifm1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmi2m(ival, mtlvfm)
      do j = 1, n
         call fmdiv(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmdiv_ifm1

   function fmdiv_rfm1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, n
         call fmdiv(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmdiv_rfm1

   function fmdiv_dfm1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, n
         call fmdiv(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmdiv_dfm1

   function fmdiv_zfm1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zfm1

   function fmdiv_cfm1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_cfm1

   function fmdiv_fmi1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm)
         call fmdiv(ma%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_fmi1

   function fmdiv_fmr1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmdiv(ma%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_fmr1

   function fmdiv_fmd1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmdiv(ma%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_fmd1

   function fmdiv_fmz1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(ma%mfm, mulvfm, mulvzm)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_fmz1

   function fmdiv_fmc1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(ma%mfm, mulvfm, mulvzm)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_fmc1

   function fmdiv_fmfm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      do j = 1, n
         call fmdiv(ma%mfm, mb(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmdiv_fmfm1

   function fmdiv_imfm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      call imi2fm(ma%mim, mtlvfm)
      do j = 1, n
         call fmdiv(mtlvfm, mb(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmdiv_imfm1

   function fmdiv_zmfm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (fm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, n	
         call zmcmpx(mb(j)%mfm, mtlvfm, mtlvzm)
         call zmdiv(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zmfm1

   function fmdiv_fmim1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (im), dimension(:) :: mb
      type (fm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      do j = 1, n
         call imi2fm(mb(j)%mim, mtlvfm)
         call fmdiv(ma%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_fmim1

   function fmdiv_fmzm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm)
      do j = 1, n
         call zmdiv(mtlvzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_fmzm1

!             (2) rank 1  /  rank 0

   function fmdiv_fm1i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmi2m(ival, mtlvfm)
      do j = 1, n
         call fmdiv(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_fm1i

   function fmdiv_fm1r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, n
         call fmdiv(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_fm1r

   function fmdiv_fm1d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, n
         call fmdiv(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_fm1d

   function fmdiv_fm1z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_fm1z

   function fmdiv_fm1c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_fm1c

   function fmdiv_i1fm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm)
         call fmdiv(mtlvfm, ma%mfm, return_value(j)%mfm)
      enddo
   end function fmdiv_i1fm

   function fmdiv_r1fm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmdiv(mtlvfm, ma%mfm, return_value(j)%mfm)
      enddo
   end function fmdiv_r1fm

   function fmdiv_d1fm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmdiv(mtlvfm, ma%mfm, return_value(j)%mfm)
      enddo
   end function fmdiv_d1fm

   function fmdiv_z1fm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(ma%mfm, mulvfm, mulvzm)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_z1fm

   function fmdiv_c1fm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(ma%mfm, mulvfm, mulvzm)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_c1fm

   function fmdiv_fm1fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      do j = 1, n
         call fmdiv(ma(j)%mfm, mb%mfm, return_value(j)%mfm)
      enddo
   end function fmdiv_fm1fm

   function fmdiv_fm1im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (im) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      call imi2fm(mb%mim, mtlvfm)
      do j = 1, n
         call fmdiv(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_fm1im

   function fmdiv_fm1zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mtlvfm, mtlvzm)
         call zmdiv(mtlvzm, mb%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_fm1zm

   function fmdiv_im1fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call fmdiv(mtlvfm, mb%mfm, return_value(j)%mfm)
      enddo
   end function fmdiv_im1fm

   function fmdiv_zm1fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (fm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm)
      do j = 1, n
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zm1fm

!             (3) rank 1  /  rank 1

   function fmdiv_fm1i1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm)
         call fmdiv(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_fm1i1

   function fmdiv_fm1r1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmdiv(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_fm1r1

   function fmdiv_fm1d1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmdiv(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_fm1d1

   function fmdiv_fm1z1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_fm1z1

   function fmdiv_fm1c1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_fm1c1

   function fmdiv_i1fm1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (fm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm)
         call fmdiv(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmdiv_i1fm1

   function fmdiv_r1fm1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmdiv(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmdiv_r1fm1

   function fmdiv_d1fm1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmdiv(mtlvfm, ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmdiv_d1fm1

   function fmdiv_z1fm1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(z)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_z1fm1

   function fmdiv_c1fm1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(ma(j)%mfm, mulvfm, mulvzm)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_c1fm1

   function fmdiv_fm1fm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdiv(ma(j)%mfm, mb(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmdiv_fm1fm1

   function fmdiv_fm1im1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2fm(mb(j)%mim, mtlvfm)
         call fmdiv(ma(j)%mfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_fm1im1

   function fmdiv_fm1zm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call zmcmpx(ma(j)%mfm, mtlvfm, mtlvzm)
         call zmdiv(mtlvzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_fm1zm1

   function fmdiv_im1fm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call fmdiv(mtlvfm, mb(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmdiv_im1fm1

   function fmdiv_zm1fm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (fm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call zmcmpx(mb(j)%mfm, mtlvfm, mtlvzm)
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zm1fm1

!             (4) rank 0  /  rank 2

   function fmdiv_ifm2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdiv(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_ifm2

   function fmdiv_rfm2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdiv(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_rfm2

   function fmdiv_dfm2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdiv(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_dfm2

   function fmdiv_zfm2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zfm2

   function fmdiv_cfm2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_cfm2

   function fmdiv_fmi2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call fmi2m(ival(j, k), mtlvfm)
            call fmdiv(ma%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_fmi2

   function fmdiv_fmr2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmdiv(ma%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_fmr2

   function fmdiv_fmd2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmdiv(ma%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_fmd2

   function fmdiv_fmz2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(ma%mfm, mulvfm, mulvzm)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_fmz2

   function fmdiv_fmc2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(ma%mfm, mulvfm, mulvzm)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_fmc2

   function fmdiv_fmfm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call fmdiv(ma%mfm, mb(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_fmfm2

   function fmdiv_imfm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(ma%mim, mtlvfm)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call fmdiv(mtlvfm, mb(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_imfm2

   function fmdiv_zmfm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (fm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmcmpx(mb(j, k)%mfm, mtlvfm, mtlvzm)
            call zmdiv(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zmfm2

   function fmdiv_fmim2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (im), dimension(:,:) :: mb
      type (fm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imi2fm(mb(j, k)%mim, mtlvfm)
            call fmdiv(ma%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_fmim2

   function fmdiv_fmzm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmdiv(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_fmzm2

!             (5) rank 2  /  rank 0

   function fmdiv_fm2i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdiv(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_fm2i

   function fmdiv_fm2r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdiv(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_fm2r

   function fmdiv_fm2d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdiv(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_fm2d

   function fmdiv_fm2z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_fm2z

   function fmdiv_fm2c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_fm2c

   function fmdiv_i2fm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call fmi2m(ival(j, k), mtlvfm)
            call fmdiv(mtlvfm, ma%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_i2fm

   function fmdiv_r2fm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmdiv(mtlvfm, ma%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_r2fm

   function fmdiv_d2fm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmdiv(mtlvfm, ma%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_d2fm

   function fmdiv_z2fm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(ma%mfm, mulvfm, mulvzm)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_z2fm

   function fmdiv_c2fm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(ma%mfm, mulvfm, mulvzm)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_c2fm

   function fmdiv_fm2fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdiv(ma(j, k)%mfm, mb%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_fm2fm

   function fmdiv_fm2im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdiv(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_fm2im

   function fmdiv_fm2zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mtlvfm, mtlvzm)
            call zmdiv(mtlvzm, mb%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_fm2zm

   function fmdiv_im2fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call fmdiv(mtlvfm, mb%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_im2fm

   function fmdiv_zm2fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zm2fm

!             (6) rank 2  /  rank 2

   function fmdiv_fm2i2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm)
            call fmdiv(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_fm2i2

   function fmdiv_fm2r2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmdiv(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_fm2r2

   function fmdiv_fm2d2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmdiv(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_fm2d2

   function fmdiv_fm2z2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_fm2z2

   function fmdiv_fm2c2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_fm2c2

   function fmdiv_i2fm2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (fm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm)
            call fmdiv(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_i2fm2

   function fmdiv_r2fm2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmdiv(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_r2fm2

   function fmdiv_d2fm2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmdiv(mtlvfm, ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_d2fm2

   function fmdiv_z2fm2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_z2fm2

   function fmdiv_c2fm2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(ma(j, k)%mfm, mulvfm, mulvzm)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_c2fm2

   function fmdiv_fm2fm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdiv(ma(j, k)%mfm, mb(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_fm2fm2

   function fmdiv_fm2im2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(mb(j, k)%mim, mtlvfm)
            call fmdiv(ma(j, k)%mfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_fm2im2

   function fmdiv_fm2zm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(ma(j, k)%mfm, mtlvfm, mtlvzm)
            call zmdiv(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_fm2zm2

   function fmdiv_im2fm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call fmdiv(mtlvfm, mb(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_im2fm2

   function fmdiv_zm2fm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcmpx(mb(j, k)%mfm, mtlvfm, mtlvzm)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zm2fm2

!             Array division operations for IM.

!             (1) rank 0  /  rank 1

   function fmdiv_iim1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      n = size(ma)
      call imi2m(ival, mtlvim)
      do j = 1, n
         call imdiv(mtlvim, ma(j)%mim, return_value(j)%mim)
      enddo
   end function fmdiv_iim1

   function fmdiv_rim1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mulvfm)
         call fmdiv(mtlvfm, mulvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_rim1

   function fmdiv_dim1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mulvfm)
         call fmdiv(mtlvfm, mulvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_dim1

   function fmdiv_zim1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mulvzm)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zim1

   function fmdiv_cim1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mulvzm)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_cim1

   function fmdiv_imi1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim)
         call imdiv(ma%mim, mtlvim, return_value(j)%mim)
      enddo
   end function fmdiv_imi1

   function fmdiv_imr1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      n = size(r)
      call imi2fm(ma%mim, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmdiv(mulvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_imr1

   function fmdiv_imd1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      n = size(d)
      call imi2fm(ma%mim, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmdiv(mulvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_imd1

   function fmdiv_imz1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(mtlvfm, mulvfm, mulvzm)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_imz1

   function fmdiv_imc1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(mvlvfm, mulvfm, mulvzm)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_imc1

   function fmdiv_imim1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (im), dimension(:) :: mb
      type (im), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      do j = 1, n
         call imdiv(ma%mim, mb(j)%mim, return_value(j)%mim)
      enddo
   end function fmdiv_imim1

   function fmdiv_zmim1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (im), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mvlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call imi2fm(mb(j)%mim, mvlvfm)
         call zmcmpx(mvlvfm, mtlvfm, mtlvzm)
         call zmdiv(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zmim1

   function fmdiv_imzm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mvlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      call imi2fm(ma%mim, mvlvfm)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mvlvfm, mtlvfm, mtlvzm)
      do j = 1, n
         call zmdiv(mtlvzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_imzm1

!             (2) rank 1  /  rank 0

   function fmdiv_im1i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      n = size(ma)
      call imi2m(ival, mtlvim)
      do j = 1, n
         call imdiv(ma(j)%mim, mtlvim, return_value(j)%mim)
      enddo
   end function fmdiv_im1i

   function fmdiv_im1r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm)
         call fmdiv(mvlvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_im1r

   function fmdiv_im1d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm)
         call fmdiv(mvlvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_im1d

   function fmdiv_im1z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm)
         call zmcmpx(mvlvfm, mulvfm, mulvzm)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_im1z

   function fmdiv_im1c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, mvlvfm)
         call zmcmpx(mvlvfm, mulvfm, mulvzm)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_im1c

   function fmdiv_i1im(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim)
         call imdiv(mtlvim, ma%mim, return_value(j)%mim)
      enddo
   end function fmdiv_i1im

   function fmdiv_r1im(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      n = size(r)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call fmdiv(mtlvfm, mvlvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_r1im

   function fmdiv_d1im(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      n = size(d)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call fmdiv(mtlvfm, mvlvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_d1im

   function fmdiv_z1im(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      call imi2fm(ma%mim, mvlvfm)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmcmpx(mvlvfm, mulvfm, mulvzm)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_z1im

   function fmdiv_c1im(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      call imi2fm(ma%mim, m1lvfm)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(m1lvfm, mulvfm, mulvzm)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_c1im

   function fmdiv_im1im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im) :: mb
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      do j = 1, n
         call imdiv(ma(j)%mim, mb%mim, return_value(j)%mim)
      enddo
   end function fmdiv_im1im

   function fmdiv_im1zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
         call zmdiv(m1lvzm, mb%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_im1zm

   function fmdiv_zm1im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (im) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      call imi2fm(mb%mim, m1lvfm)
      call fmi2m(0, mtlvfm)
      call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
      do j = 1, n
         call zmdiv(ma(j)%mzm, m1lvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zm1im

!             (3) rank 1  /  rank 1

   function fmdiv_im1i1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imi2m(ival(j), mtlvim)
         call imdiv(ma(j)%mim, mtlvim, return_value(j)%mim)
      enddo
   end function fmdiv_im1i1

   function fmdiv_im1r1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmdiv(m1lvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_im1r1

   function fmdiv_im1d1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmdiv(m1lvfm, mtlvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_im1d1

   function fmdiv_im1z1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call imi2fm(ma(j)%mim, m1lvfm)
         call zmcmpx(m1lvfm, mulvfm, mulvzm)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_im1z1

   function fmdiv_im1c1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmi2m(0, mulvfm)
         call zmcmpx(m1lvfm, mulvfm, mulvzm)
         call zmdiv(mulvzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_im1c1

   function fmdiv_i1im1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim)
          enddo
          return
      endif
      n = size(ival)
      do j = 1, n
         call imi2m(ival(j), mtlvim)
         call imdiv(mtlvim, ma(j)%mim, return_value(j)%mim)
      enddo
   end function fmdiv_i1im1

   function fmdiv_r1im1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      real, dimension(:) :: r
      type (fm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(r)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmsp2m(r(j), mtlvfm)
         call fmdiv(mtlvfm, m1lvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_r1im1

   function fmdiv_d1im1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (fm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call fmunknown(return_value(j)%mfm)
          enddo
          return
      endif
      n = size(d)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmdp2m(d(j), mtlvfm)
         call fmdiv(mtlvfm, m1lvfm, return_value(j)%mfm)
      enddo
   end function fmdiv_d1im1

   function fmdiv_z1im1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(z)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call imi2fm(ma(j)%mim, m1lvfm)
         call zmcmpx(m1lvfm, mulvfm, mulvzm)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_z1im1

   function fmdiv_c1im1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm)
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call fmi2m(0, mulvfm)
         call zmcmpx(m1lvfm, mulvfm, mulvzm)
         call zmdiv(mtlvzm, mulvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_c1im1

   function fmdiv_im1im1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call imunknown(return_value(j)%mim)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call imdiv(ma(j)%mim, mb(j)%mim, return_value(j)%mim)
      enddo
   end function fmdiv_im1im1

   function fmdiv_im1zm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call imi2fm(ma(j)%mim, m1lvfm)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
         call zmdiv(m1lvzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_im1zm1

   function fmdiv_zm1im1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (im), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mtlvfm)
      do j = 1, n
         call imi2fm(mb(j)%mim, m1lvfm)
         call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
         call zmdiv(ma(j)%mzm, m1lvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zm1im1

!             (4) rank 0  /  rank 2

   function fmdiv_iim2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imdiv(mtlvim, ma(j, k)%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmdiv_iim2

   function fmdiv_rim2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mulvfm)
            call fmdiv(mtlvfm, mulvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_rim2

   function fmdiv_dim2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mulvfm)
            call fmdiv(mtlvfm, mulvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_dim2

   function fmdiv_zim2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mulvzm)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zim2

   function fmdiv_cim2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mulvzm)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_cim2

   function fmdiv_imi2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call imi2m(ival(j, k), mtlvim)
            call imdiv(ma%mim, mtlvim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmdiv_imi2

   function fmdiv_imr2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mulvfm)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmdiv(mulvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_imr2

   function fmdiv_imd2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mulvfm)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmdiv(mulvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_imd2

   function fmdiv_imz2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(mtlvfm, mulvfm, mulvzm)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_imz2

   function fmdiv_imc2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(mvlvfm, mulvfm, mulvzm)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_imc2

   function fmdiv_imim2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (im), dimension(:,:) :: mb
      type (im), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imdiv(ma%mim, mb(j, k)%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmdiv_imim2

   function fmdiv_zmim2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (im), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mvlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call imi2fm(mb(j, k)%mim, mvlvfm)
            call zmcmpx(mvlvfm, mtlvfm, mtlvzm)
            call zmdiv(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zmim2

   function fmdiv_imzm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mvlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(ma%mim, mvlvfm)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mvlvfm, mtlvfm, mtlvzm)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmdiv(mtlvzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_imzm2

!             (5) rank 2  /  rank 0

   function fmdiv_im2i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imdiv(ma(j, k)%mim, mtlvim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmdiv_im2i

   function fmdiv_im2r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm)
            call fmdiv(mvlvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_im2r

   function fmdiv_im2d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm)
            call fmdiv(mvlvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_im2d

   function fmdiv_im2z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm)
            call zmcmpx(mvlvfm, mulvfm, mulvzm)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_im2z

   function fmdiv_im2c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, mvlvfm)
            call zmcmpx(mvlvfm, mulvfm, mulvzm)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_im2c

   function fmdiv_i2im(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call imi2m(ival(j, k), mtlvim)
            call imdiv(mtlvim, ma%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmdiv_i2im

   function fmdiv_r2im(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call fmdiv(mtlvfm, mvlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_r2im

   function fmdiv_d2im(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mvlvfm
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mvlvfm)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call fmdiv(mtlvfm, mvlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_d2im

   function fmdiv_z2im(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mvlvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mvlvfm)
      call fmi2m(0, mulvfm)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmcmpx(mvlvfm, mulvfm, mulvzm)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_z2im

   function fmdiv_c2im(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, m1lvfm)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(m1lvfm, mulvfm, mulvzm)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_c2im

   function fmdiv_im2im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im) :: mb
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imdiv(ma(j, k)%mim, mb%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmdiv_im2im

   function fmdiv_im2zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
            call zmdiv(m1lvzm, mb%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_im2zm

   function fmdiv_zm2im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, m1lvfm)
      call fmi2m(0, mtlvfm)
      call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(ma(j, k)%mzm, m1lvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zm2im

!             (6) rank 2  /  rank 2

   function fmdiv_im2i2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2m(ival(j, k), mtlvim)
            call imdiv(ma(j, k)%mim, mtlvim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmdiv_im2i2

   function fmdiv_im2r2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmdiv(m1lvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_im2r2

   function fmdiv_im2d2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmdiv(m1lvfm, mtlvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_im2d2

   function fmdiv_im2z2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call zmcmpx(m1lvfm, mulvfm, mulvzm)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_im2z2

   function fmdiv_im2c2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmi2m(0, mulvfm)
            call zmcmpx(m1lvfm, mulvfm, mulvzm)
            call zmdiv(mulvzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_im2c2

   function fmdiv_i2im2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2m(ival(j, k), mtlvim)
            call imdiv(mtlvim, ma(j, k)%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmdiv_i2im2

   function fmdiv_r2im2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (fm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmsp2m(r(j, k), mtlvfm)
            call fmdiv(mtlvfm, m1lvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_r2im2

   function fmdiv_d2im2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (fm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, m1lvfm
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call fmst2m(' UNKNOWN ', return_value(j, k)%mfm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmdp2m(d(j, k), mtlvfm)
            call fmdiv(mtlvfm, m1lvfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmdiv_d2im2

   function fmdiv_z2im2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call zmcmpx(m1lvfm, mulvfm, mulvzm)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_z2im2

   function fmdiv_c2im2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, m1lvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call fmi2m(0, mulvfm)
            call zmcmpx(m1lvfm, mulvfm, mulvzm)
            call zmdiv(mtlvzm, mulvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_c2im2

   function fmdiv_im2im2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call imst2m(' UNKNOWN ', return_value(j, k)%mim)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imdiv(ma(j, k)%mim, mb(j, k)%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmdiv_im2im2

   function fmdiv_im2zm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(ma(j, k)%mim, m1lvfm)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
            call zmdiv(m1lvzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_im2zm2

   function fmdiv_zm2im2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, m1lvfm, m1lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mtlvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imi2fm(mb(j, k)%mim, m1lvfm)
            call zmcmpx(m1lvfm, mtlvfm, m1lvzm)
            call zmdiv(ma(j, k)%mzm, m1lvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zm2im2

!             Array division operations for ZM.

!             (1) rank 0  /  rank 1

   function fmdiv_izm1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmi2m(ival, mtlvzm)
      do j = 1, n
         call zmdiv(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_izm1

   function fmdiv_rzm1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmdiv(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_rzm1

   function fmdiv_dzm1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmdiv(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_dzm1

   function fmdiv_zzm1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      do j = 1, n
         call zmdiv(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zzm1

   function fmdiv_czm1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmdiv(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_czm1

   function fmdiv_zmi1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm)
         call zmdiv(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zmi1

   function fmdiv_zmr1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(r)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmdiv(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zmr1

   function fmdiv_zmd1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(d)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmdiv(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zmd1

   function fmdiv_zmz1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmdiv(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zmz1

   function fmdiv_zmc1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmdiv(ma%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zmc1

   function fmdiv_zmzm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(mb)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(mb)
      do j = 1, n
         call zmdiv(ma%mzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zmzm1

!             (2) rank 1  /  rank 0

   function fmdiv_zm1i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmi2m(ival, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zm1i

   function fmdiv_zm1r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zm1r

   function fmdiv_zm1d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zm1d

   function fmdiv_zm1z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call zmz2m(z, mtlvzm)
      do j = 1, n
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zm1z

   function fmdiv_zm1c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, n
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zm1c

   function fmdiv_i1zm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(ival)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm)
         call zmdiv(mtlvzm, ma%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_i1zm

   function fmdiv_r1zm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(r)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmdiv(mtlvzm, ma%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_r1zm

   function fmdiv_d1zm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(d)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmdiv(mtlvzm, ma%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_d1zm

   function fmdiv_z1zm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmdiv(mtlvzm, ma%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_z1zm

   function fmdiv_c1zm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmdiv(mtlvzm, ma%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_c1zm

   function fmdiv_zm1zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      n = size(ma)
      do j = 1, n
         call zmdiv(ma(j)%mzm, mb%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zm1zm

!             (3) rank 1  /  rank 1

   function fmdiv_zm1i1(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer, dimension(:) :: ival
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmi2m(ival(j), mtlvzm)
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zm1i1

   function fmdiv_zm1r1(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      real, dimension(:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zm1r1

   function fmdiv_zm1d1(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      double precision, dimension(:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zm1d1

   function fmdiv_zm1z1(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex, dimension(:) :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zm1z1

   function fmdiv_zm1c1(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      complex (kind(0.0d0)), dimension(:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmdiv(ma(j)%mzm, mtlvzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zm1c1

   function fmdiv_i1zm1(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      integer, dimension(:) :: ival
      type (zm), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(ival)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ival)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmi2m(ival(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmdiv(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_i1zm1

   function fmdiv_r1zm1(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      real, dimension(:) :: r
      type (zm), dimension(size(r)) :: return_value
      integer :: j, n
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(r)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(r)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmsp2m(r(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmdiv(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_r1zm1

   function fmdiv_d1zm1(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      double precision, dimension(:) :: d
      type (zm), dimension(size(d)) :: return_value
      integer :: j, n
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(d)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(d)
      call fmi2m(0, mulvfm)
      do j = 1, n
         call fmdp2m(d(j), mtlvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmdiv(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_d1zm1

   function fmdiv_z1zm1(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      complex, dimension(:) :: z
      type (zm), dimension(size(z)) :: return_value
      integer :: j, n
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(z)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(z)
      do j = 1, n
         call zmz2m(z(j), mtlvzm)
         call zmdiv(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_z1zm1

   function fmdiv_c1zm1(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      complex (kind(0.0d0)), dimension(:) :: c
      type (zm), dimension(size(c)) :: return_value
      integer :: j, n
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma) /= size(c)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(c)
      do j = 1, n
         call fmdp2m(real(c(j), kind(0.0d0)), mtlvfm)
         call fmdp2m(aimag(c(j)), mulvfm)
         call zmcmpx(mtlvfm, mulvfm, mtlvzm)
         call zmdiv(mtlvzm, ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_c1zm1

   function fmdiv_zm1zm1(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(:) :: mb
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) /= size(mb)) then
          do j = 1, size(ma)
             call zmunknown(return_value(j)%mzm)
          enddo
          return
      endif
      n = size(ma)
      do j = 1, n
         call zmdiv(ma(j)%mzm, mb(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmdiv_zm1zm1

!             (4) rank 0  /  rank 2

   function fmdiv_izm2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmi2m(ival, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_izm2

   function fmdiv_rzm2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_rzm2

   function fmdiv_dzm2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_dzm2

   function fmdiv_zzm2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zzm2

   function fmdiv_czm2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_czm2

   function fmdiv_zmi2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call zmi2m(ival(j, k), mtlvzm)
            call zmdiv(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zmi2

   function fmdiv_zmr2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmdiv(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zmr2

   function fmdiv_zmd2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmdiv(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zmd2

   function fmdiv_zmz2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmdiv(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zmz2

   function fmdiv_zmc2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmdiv(ma%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zmc2

   function fmdiv_zmzm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(mb, dim=1), size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(mb, dim=1)
         do k = 1, size(mb, dim=2)
            call zmdiv(ma%mzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zmzm2

!             (5) rank 2  /  rank 0

   function fmdiv_zm2i(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zm2i

   function fmdiv_zm2r(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zm2r

   function fmdiv_zm2d(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zm2d

   function fmdiv_zm2z(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zm2z

   function fmdiv_zm2c(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zm2c

   function fmdiv_i2zm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call zmi2m(ival(j, k), mtlvzm)
            call zmdiv(mtlvzm, ma%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_i2zm

   function fmdiv_r2zm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(r, dim=1)
         do k = 1, size(r, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmdiv(mtlvzm, ma%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_r2zm

   function fmdiv_d2zm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(0, mulvfm)
      do j = 1, size(d, dim=1)
         do k = 1, size(d, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmdiv(mtlvzm, ma%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_d2zm

   function fmdiv_z2zm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(z, dim=1)
         do k = 1, size(z, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmdiv(mtlvzm, ma%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_z2zm

   function fmdiv_c2zm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      do j = 1, size(c, dim=1)
         do k = 1, size(c, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmdiv(mtlvzm, ma%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_c2zm

   function fmdiv_zm2zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(ma(j, k)%mzm, mb%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zm2zm

!             (6) rank 2  /  rank 2

   function fmdiv_zm2i2(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer, dimension(:,:) :: ival
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmi2m(ival(j, k), mtlvzm)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zm2i2

   function fmdiv_zm2r2(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      real, dimension(:,:) :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zm2r2

   function fmdiv_zm2d2(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      double precision, dimension(:,:) :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zm2d2

   function fmdiv_zm2z2(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex, dimension(:,:) :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zm2z2

   function fmdiv_zm2c2(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      complex (kind(0.0d0)), dimension(:,:) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmdiv(ma(j, k)%mzm, mtlvzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zm2c2

   function fmdiv_i2zm2(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      integer, dimension(:,:) :: ival
      type (zm), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, ival
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(ival, dim=1) .or. size(ma, dim=2) /= size(ival, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmi2m(ival(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmdiv(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_i2zm2

   function fmdiv_r2zm2(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      real, dimension(:,:) :: r
      type (zm), dimension(size(r, dim=1), size(r, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(r, dim=1) .or. size(ma, dim=2) /= size(r, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsp2m(r(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmdiv(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_r2zm2

   function fmdiv_d2zm2(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      double precision, dimension(:,:) :: d
      type (zm), dimension(size(d, dim=1), size(d, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(d, dim=1) .or. size(ma, dim=2) /= size(d, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      call fmi2m(0, mulvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(d(j, k), mtlvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmdiv(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_d2zm2

   function fmdiv_z2zm2(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      complex, dimension(:,:) :: z
      type (zm), dimension(size(z, dim=1), size(z, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(z, dim=1) .or. size(ma, dim=2) /= size(z, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmz2m(z(j, k), mtlvzm)
            call zmdiv(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_z2zm2

   function fmdiv_c2zm2(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      complex (kind(0.0d0)), dimension(:,:) :: c
      type (zm), dimension(size(c, dim=1), size(c, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      if (size(ma, dim=1) /= size(c, dim=1) .or. size(ma, dim=2) /= size(c, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmdp2m(real(c(j, k), kind(0.0d0)), mtlvfm)
            call fmdp2m(aimag(c(j, k)), mulvfm)
            call zmcmpx(mtlvfm, mulvfm, mtlvzm)
            call zmdiv(mtlvzm, ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_c2zm2

   function fmdiv_zm2zm2(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(:,:) :: mb
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=1) /= size(mb, dim=1) .or. size(ma, dim=2) /= size(mb, dim=2)) then
          do j = 1, size(ma, dim=1)
             do k = 1, size(ma, dim=2)
                call zmst2m(' UNKNOWN + UNKNOWN i ', return_value(j, k)%mzm)
             enddo
          enddo
          return
      endif
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmdiv(ma(j, k)%mzm, mb(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmdiv_zm2zm2

 end module fmzm_7

 module fmzm_8
    use fmzm_1

    interface operator (**)
       module procedure fmpwr_ifm
       module procedure fmpwr_iim
       module procedure fmpwr_izm
       module procedure fmpwr_rfm
       module procedure fmpwr_rim
       module procedure fmpwr_rzm
       module procedure fmpwr_dfm
       module procedure fmpwr_dim
       module procedure fmpwr_dzm
       module procedure fmpwr_zfm
       module procedure fmpwr_zim
       module procedure fmpwr_zzm
       module procedure fmpwr_cfm
       module procedure fmpwr_cim
       module procedure fmpwr_czm
       module procedure fmpwr_fmi
       module procedure fmpwr_fmr
       module procedure fmpwr_fmd
       module procedure fmpwr_fmz
       module procedure fmpwr_fmc
       module procedure fmpwr_fmfm
       module procedure fmpwr_fmim
       module procedure fmpwr_fmzm
       module procedure fmpwr_imi
       module procedure fmpwr_imr
       module procedure fmpwr_imd
       module procedure fmpwr_imz
       module procedure fmpwr_imc
       module procedure fmpwr_imfm
       module procedure fmpwr_imim
       module procedure fmpwr_imzm
       module procedure fmpwr_zmi
       module procedure fmpwr_zmr
       module procedure fmpwr_zmd
       module procedure fmpwr_zmz
       module procedure fmpwr_zmc
       module procedure fmpwr_zmfm
       module procedure fmpwr_zmim
       module procedure fmpwr_zmzm
    end interface

   interface abs
      module procedure fmabs_fm
      module procedure fmabs_im
      module procedure fmabs_zm
      module procedure fmabs_fm1
      module procedure fmabs_im1
      module procedure fmabs_zm1
      module procedure fmabs_fm2
      module procedure fmabs_im2
      module procedure fmabs_zm2
   end interface

   interface acos
      module procedure fmacos_fm
      module procedure fmacos_zm
      module procedure fmacos_fm1
      module procedure fmacos_zm1
      module procedure fmacos_fm2
      module procedure fmacos_zm2
   end interface

   interface acosh
      module procedure fmacosh_fm
      module procedure fmacosh_zm
      module procedure fmacosh_fm1
      module procedure fmacosh_zm1
      module procedure fmacosh_fm2
      module procedure fmacosh_zm2
   end interface

   interface aimag
      module procedure fmaimag_zm
      module procedure fmaimag_zm1
      module procedure fmaimag_zm2
   end interface

   interface aint
      module procedure fmaint_fm
      module procedure fmaint_zm
      module procedure fmaint_fm1
      module procedure fmaint_zm1
      module procedure fmaint_fm2
      module procedure fmaint_zm2
   end interface

   interface anint
      module procedure fmanint_fm
      module procedure fmanint_zm
      module procedure fmanint_fm1
      module procedure fmanint_zm1
      module procedure fmanint_fm2
      module procedure fmanint_zm2
   end interface

   interface arg
      module procedure fmarg_zm
      module procedure fmarg_zm1
      module procedure fmarg_zm2
   end interface

   interface asin
      module procedure fmasin_fm
      module procedure fmasin_zm
      module procedure fmasin_fm1
      module procedure fmasin_zm1
      module procedure fmasin_fm2
      module procedure fmasin_zm2
   end interface

   interface asinh
      module procedure fmasinh_fm
      module procedure fmasinh_zm
      module procedure fmasinh_fm1
      module procedure fmasinh_zm1
      module procedure fmasinh_fm2
      module procedure fmasinh_zm2
   end interface

   interface atan
      module procedure fmatan_fm
      module procedure fmatan2_fm
      module procedure fmatan_zm
      module procedure fmatan_fm1
      module procedure fmatan_zm1
      module procedure fmatan_fm2
      module procedure fmatan_zm2
   end interface

   interface atanh
      module procedure fmatanh_fm
      module procedure fmatanh_zm
      module procedure fmatanh_fm1
      module procedure fmatanh_zm1
      module procedure fmatanh_fm2
      module procedure fmatanh_zm2
   end interface

   interface atan2
      module procedure fmatan2_fm
   end interface

   interface btest
      module procedure fmbtest_im
   end interface

   interface ceiling
      module procedure fmceiling_fm
      module procedure fmceiling_im
      module procedure fmceiling_zm
      module procedure fmceiling_fm1
      module procedure fmceiling_im1
      module procedure fmceiling_zm1
      module procedure fmceiling_fm2
      module procedure fmceiling_im2
      module procedure fmceiling_zm2
   end interface

   interface cmplx
      module procedure fmcmplx_fm
      module procedure fmcmplx_im
   end interface

   interface conjg
      module procedure fmconjg_zm
      module procedure fmconjg_zm1
      module procedure fmconjg_zm2
   end interface

   interface cos
      module procedure fmcos_fm
      module procedure fmcos_zm
      module procedure fmcos_fm1
      module procedure fmcos_zm1
      module procedure fmcos_fm2
      module procedure fmcos_zm2
   end interface

   interface cosh
      module procedure fmcosh_fm
      module procedure fmcosh_zm
      module procedure fmcosh_fm1
      module procedure fmcosh_zm1
      module procedure fmcosh_fm2
      module procedure fmcosh_zm2
   end interface

   interface dble
      module procedure fmdble_fm
      module procedure fmdble_im
      module procedure fmdble_zm
   end interface

   interface digits
      module procedure fmdigits_fm
      module procedure fmdigits_im
      module procedure fmdigits_zm
   end interface

   interface dim
      module procedure fmdim_fm
      module procedure fmdim_im
   end interface

   interface dint
      module procedure fmdint_fm
      module procedure fmdint_zm
   end interface

   interface dot_product
      module procedure fmdotproduct_fm
      module procedure fmdotproduct_im
      module procedure fmdotproduct_zm
   end interface

   interface epsilon
      module procedure fmepsilon_fm
   end interface

   interface exp
      module procedure fmexp_fm
      module procedure fmexp_zm
      module procedure fmexp_fm1
      module procedure fmexp_zm1
      module procedure fmexp_fm2
      module procedure fmexp_zm2
   end interface

   interface exponent
      module procedure fmexponent_fm
   end interface

   interface floor
      module procedure fmfloor_fm
      module procedure fmfloor_im
      module procedure fmfloor_zm
      module procedure fmfloor_fm1
      module procedure fmfloor_im1
      module procedure fmfloor_zm1
      module procedure fmfloor_fm2
      module procedure fmfloor_im2
      module procedure fmfloor_zm2
   end interface

   interface fraction
      module procedure fmfraction_fm
      module procedure fmfraction_zm
      module procedure fmfraction_fm1
      module procedure fmfraction_zm1
      module procedure fmfraction_fm2
      module procedure fmfraction_zm2
   end interface

   interface huge
      module procedure fmhuge_fm
      module procedure fmhuge_im
      module procedure fmhuge_zm
   end interface

   interface hypot
      module procedure fmhypot_fm
   end interface

   interface int
      module procedure fmint_fm
      module procedure fmint_im
      module procedure fmint_zm
      module procedure fmint_fm1
      module procedure fmint_im1
      module procedure fmint_zm1
      module procedure fmint_fm2
      module procedure fmint_im2
      module procedure fmint_zm2
   end interface

   interface log
      module procedure fmlog_fm
      module procedure fmlog_zm
      module procedure fmlog_fm1
      module procedure fmlog_zm1
      module procedure fmlog_fm2
      module procedure fmlog_zm2
   end interface

   interface log10
      module procedure fmlog10_fm
      module procedure fmlog10_zm
      module procedure fmlog10_fm1
      module procedure fmlog10_zm1
      module procedure fmlog10_fm2
      module procedure fmlog10_zm2
   end interface

   interface matmul
      module procedure fmmatmul22_fm
      module procedure fmmatmul12_fm
      module procedure fmmatmul21_fm
      module procedure fmmatmul22_im
      module procedure fmmatmul12_im
      module procedure fmmatmul21_im
      module procedure fmmatmul22_zm
      module procedure fmmatmul12_zm
      module procedure fmmatmul21_zm
   end interface

   interface max
      module procedure fmmax_fm
      module procedure fmmax_im
   end interface

   interface maxexponent
      module procedure fmmaxexponent_fm
   end interface

   interface maxloc
      module procedure fmmaxloc1_fm
      module procedure fmmaxloc2_fm
      module procedure fmmaxloc1_im
      module procedure fmmaxloc2_im
   end interface

   interface maxval
      module procedure fmmaxval1_fm
      module procedure fmmaxval2_fm
      module procedure fmmaxval1_im
      module procedure fmmaxval2_im
   end interface

   interface min
      module procedure fmmin_fm
      module procedure fmmin_im
   end interface

   interface minexponent
      module procedure fmminexponent_fm
   end interface

   interface minloc
      module procedure fmminloc1_fm
      module procedure fmminloc2_fm
      module procedure fmminloc1_im
      module procedure fmminloc2_im
   end interface

   interface minval
      module procedure fmminval1_fm
      module procedure fmminval2_fm
      module procedure fmminval1_im
      module procedure fmminval2_im
   end interface

   interface mod
      module procedure fmmod_fm
      module procedure fmmod_im
   end interface

   interface modulo
      module procedure fmmodulo_fm
      module procedure fmmodulo_im
   end interface

   interface nearest
      module procedure fmnearest_fm
   end interface

   interface nint
      module procedure fmnint_fm
      module procedure fmnint_im
      module procedure fmnint_zm
      module procedure fmnint_fm1
      module procedure fmnint_im1
      module procedure fmnint_zm1
      module procedure fmnint_fm2
      module procedure fmnint_im2
      module procedure fmnint_zm2
   end interface

   interface norm2
      module procedure fmnorm21_fm
   end interface

   interface precision
      module procedure fmprecision_fm
      module procedure fmprecision_zm
   end interface

   interface product
      module procedure fmproduct1_fm
      module procedure fmproduct2_fm
      module procedure fmproduct1_im
      module procedure fmproduct2_im
      module procedure fmproduct1_zm
      module procedure fmproduct2_zm
   end interface

   interface radix
      module procedure fmradix_fm
      module procedure fmradix_im
      module procedure fmradix_zm
   end interface

   interface range
      module procedure fmrange_fm
      module procedure fmrange_im
      module procedure fmrange_zm
   end interface

   interface real
      module procedure fmreal_fm
      module procedure fmreal_im
      module procedure fmreal_zm
   end interface

   interface rrspacing
      module procedure fmrrspacing_fm
   end interface

   interface scale
      module procedure fmscale_fm
      module procedure fmscale_zm
   end interface

   interface setexponent
      module procedure fmsetexponent_fm
   end interface

   interface sign
      module procedure fmsign_fm
      module procedure fmsign_im
   end interface

 contains

!                                                                  **

   function fmpwr_ifm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      call fmpwr(mtlvfm, ma%mfm, return_value%mfm)
   end function fmpwr_ifm

   function fmpwr_iim(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      call impwr(mtlvim, ma%mim, return_value%mim)
   end function fmpwr_iim

   function fmpwr_izm(ival, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      integer :: ival
      intent (in) :: ival, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmi2m(ival, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmpwr(mtlvzm, ma%mzm, return_value%mzm)
   end function fmpwr_izm

   function fmpwr_rfm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmpwr(mtlvfm, ma%mfm, return_value%mfm)
   end function fmpwr_rfm

   function fmpwr_rim(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      call fmpwr(mtlvfm, mulvfm, return_value%mfm)
   end function fmpwr_rim

   function fmpwr_rzm(r, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      real :: r
      intent (in) :: r, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmpwr(mtlvzm, ma%mzm, return_value%mzm)
   end function fmpwr_rzm

   function fmpwr_dfm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmpwr(mtlvfm, ma%mfm, return_value%mfm)
   end function fmpwr_dfm

   function fmpwr_dim(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      call fmpwr(mtlvfm, mulvfm, return_value%mfm)
   end function fmpwr_dim

   function fmpwr_dzm(d, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      double precision :: d
      intent (in) :: d, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmpwr(mtlvzm, ma%mzm, return_value%mzm)
   end function fmpwr_dzm

   function fmpwr_zfm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      call zmcmpx(ma%mfm, mulvfm, mulvzm)
      call zmpwr(mtlvzm, mulvzm, return_value%mzm)
   end function fmpwr_zfm

   function fmpwr_zim(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex :: z
      intent (in) :: z, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmpwr(mtlvzm, mulvzm, return_value%mzm)
   end function fmpwr_zim

   function fmpwr_zzm(z, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      complex :: z
      intent (in) :: z, ma
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call zmpwr(mtlvzm, ma%mzm, return_value%mzm)
   end function fmpwr_zzm

   function fmpwr_cfm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      call zmcmpx(ma%mfm, mulvfm, mulvzm)
      call zmpwr(mtlvzm, mulvzm, return_value%mzm)
   end function fmpwr_cfm

   function fmpwr_cim(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmpwr(mtlvzm, mulvzm, return_value%mzm)
   end function fmpwr_cim

   function fmpwr_czm(c, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: c, ma
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmpwr(mtlvzm, ma%mzm, return_value%mzm)
   end function fmpwr_czm

   function fmpwr_fmi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      call fm_undef_inp(ma)
      call fmipwr(ma%mfm, ival, return_value%mfm)
   end function fmpwr_fmi

   function fmpwr_fmr(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmpwr(ma%mfm, mtlvfm, return_value%mfm)
   end function fmpwr_fmr

   function fmpwr_fmd(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmpwr(ma%mfm, mtlvfm, return_value%mfm)
   end function fmpwr_fmd

   function fmpwr_fmz(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call fmi2m(0, mulvfm)
      call zmcmpx(ma%mfm, mulvfm, mulvzm)
      call zmpwr(mulvzm, mtlvzm, return_value%mzm)
   end function fmpwr_fmz

   function fmpwr_fmc(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call fmi2m(0, mulvfm)
      call zmcmpx(ma%mfm, mulvfm, mulvzm)
      call zmpwr(mulvzm, mtlvzm, return_value%mzm)
   end function fmpwr_fmc

   function fmpwr_fmfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmpwr(ma%mfm, mb%mfm, return_value%mfm)
   end function fmpwr_fmfm

   function fmpwr_fmim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      type (im) :: mb
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, mtlvfm)
      call fmpwr(ma%mfm, mtlvfm, return_value%mfm)
   end function fmpwr_fmim

   function fmpwr_fmzm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (zm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(ma%mfm, mtlvfm, mtlvzm)
      call zmpwr(mtlvzm, mb%mzm, return_value%mzm)
   end function fmpwr_fmzm

   function fmpwr_imi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      type(multi), save :: mtlvim
      call fm_undef_inp(ma)
      call imi2m(ival, mtlvim)
      call impwr(ma%mim, mtlvim, return_value%mim)
   end function fmpwr_imi

   function fmpwr_imr(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      call fmpwr(mulvfm, mtlvfm, return_value%mfm)
   end function fmpwr_imr

   function fmpwr_imd(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call imi2fm(ma%mim, mulvfm)
      call fmpwr(mulvfm, mtlvfm, return_value%mfm)
   end function fmpwr_imd

   function fmpwr_imz(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmpwr(mulvzm, mtlvzm, return_value%mzm)
   end function fmpwr_imz

   function fmpwr_imc(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2), mulvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmpwr(mulvzm, mtlvzm, return_value%mzm)
   end function fmpwr_imc

   function fmpwr_imfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (fm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(ma%mim, mtlvfm)
      call fmpwr(mtlvfm, mb%mfm, return_value%mfm)
   end function fmpwr_imfm

   function fmpwr_imim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call impwr(ma%mim, mb%mim, return_value%mim)
   end function fmpwr_imim

   function fmpwr_imzm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      type (zm) :: mb, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mulvfm, mulvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(ma%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmpwr(mulvzm, mb%mzm, return_value%mzm)
   end function fmpwr_imzm

   function fmpwr_zmi(ma, ival)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      integer :: ival
      intent (in) :: ma, ival
      call fm_undef_inp(ma)
      call zmipwr(ma%mzm, ival, return_value%mzm)
   end function fmpwr_zmi

   function fmpwr_zmr(ma, r)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      real :: r
      intent (in) :: ma, r
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmsp2m(r, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmpwr(ma%mzm, mtlvzm, return_value%mzm)
   end function fmpwr_zmr

   function fmpwr_zmd(ma, d)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      double precision :: d
      intent (in) :: ma, d
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(d, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmpwr(ma%mzm, mtlvzm, return_value%mzm)
   end function fmpwr_zmd

   function fmpwr_zmz(ma, z)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      complex :: z
      intent (in) :: ma, z
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmz2m(z, mtlvzm)
      call zmpwr(ma%mzm, mtlvzm, return_value%mzm)
   end function fmpwr_zmz

   function fmpwr_zmc(ma, c)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      complex (kind(0.0d0)) :: c
      intent (in) :: ma, c
      type(multi), save :: mtlvfm, mulvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fmdp2m(real(c, kind(0.0d0)), mtlvfm)
      call fmdp2m(aimag(c), mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mtlvzm)
      call zmpwr(ma%mzm, mtlvzm, return_value%mzm)
   end function fmpwr_zmc

   function fmpwr_zmfm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: mb
      type (zm) :: ma, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmi2m(0, mtlvfm)
      call zmcmpx(mb%mfm, mtlvfm, mtlvzm)
      call zmpwr(ma%mzm, mtlvzm, return_value%mzm)
   end function fmpwr_zmfm

   function fmpwr_zmim(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: mb
      type (zm) :: ma, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mulvfm, mulvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imi2fm(mb%mim, mtlvfm)
      call fmi2m(0, mulvfm)
      call zmcmpx(mtlvfm, mulvfm, mulvzm)
      call zmpwr(ma%mzm, mulvzm, return_value%mzm)
   end function fmpwr_zmim

   function fmpwr_zmzm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmpwr(ma%mzm, mb%mzm, return_value%mzm)
   end function fmpwr_zmzm

!                                                                 abs

   function fmabs_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmabs(ma%mfm, return_value%mfm)
   end function fmabs_fm

   function fmabs_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imabs(ma%mim, return_value%mim)
   end function fmabs_im

   function fmabs_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (zm) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmabs(ma%mzm, return_value%mfm)
   end function fmabs_zm

   function fmabs_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmabs(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmabs_fm1

   function fmabs_im1(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call imabs(ma(j)%mim, return_value(j)%mim)
      enddo
   end function fmabs_im1

   function fmabs_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmabs(ma(j)%mzm, return_value(j)%mfm)
      enddo
   end function fmabs_zm1

   function fmabs_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmabs(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmabs_fm2

   function fmabs_im2(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imabs(ma(j, k)%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmabs_im2

   function fmabs_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmabs(ma(j, k)%mzm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmabs_zm2

!                                                                acos

   function fmacos_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmacos(ma%mfm, return_value%mfm)
   end function fmacos_fm

   function fmacos_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmacos(ma%mzm, return_value%mzm)
   end function fmacos_zm

   function fmacos_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmacos(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmacos_fm1

   function fmacos_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmacos(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmacos_zm1

   function fmacos_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmacos(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmacos_fm2

   function fmacos_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmacos(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmacos_zm2

!                                                                acosh

   function fmacosh_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmacosh(ma%mfm, return_value%mfm)
   end function fmacosh_fm

   function fmacosh_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmacosh(ma%mzm, return_value%mzm)
   end function fmacosh_zm

   function fmacosh_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmacosh(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmacosh_fm1

   function fmacosh_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmacosh(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmacosh_zm1

   function fmacosh_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmacosh(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmacosh_fm2

   function fmacosh_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmacosh(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmacosh_zm2

!                                                               aimag

   function fmaimag_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (zm) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmimag(ma%mzm, return_value%mfm)
   end function fmaimag_zm

   function fmaimag_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmimag(ma(j)%mzm, return_value(j)%mfm)
      enddo
   end function fmaimag_zm1

   function fmaimag_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmimag(ma(j, k)%mzm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmaimag_zm2

!                                                                aint

   function fmaint_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmint(ma%mfm, return_value%mfm)
   end function fmaint_fm

   function fmaint_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmint(ma%mzm, return_value%mzm)
   end function fmaint_zm

   function fmaint_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmint(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmaint_fm1

   function fmaint_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmint(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmaint_zm1

   function fmaint_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmint(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmaint_fm2

   function fmaint_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmint(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmaint_zm2

!                                                               anint

   function fmanint_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmnint(ma%mfm, return_value%mfm)
   end function fmanint_fm

   function fmanint_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmnint(ma%mzm, return_value%mzm)
   end function fmanint_zm

   function fmanint_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmnint(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmanint_fm1

   function fmanint_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmnint(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmanint_zm1

   function fmanint_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmnint(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmanint_fm2

   function fmanint_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmnint(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmanint_zm2

!                                                                arg

   function fmarg_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (zm) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmarg(ma%mzm, return_value%mfm)
   end function fmarg_zm

   function fmarg_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmarg(ma(j)%mzm, return_value(j)%mfm)
      enddo
   end function fmarg_zm1

   function fmarg_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmarg(ma(j, k)%mzm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmarg_zm2

!                                                                asin

   function fmasin_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmasin(ma%mfm, return_value%mfm)
   end function fmasin_fm

   function fmasin_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmasin(ma%mzm, return_value%mzm)
   end function fmasin_zm

   function fmasin_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmasin(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmasin_fm1

   function fmasin_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmasin(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmasin_zm1

   function fmasin_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmasin(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmasin_fm2

   function fmasin_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmasin(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmasin_zm2

!                                                                asinh

   function fmasinh_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmasinh(ma%mfm, return_value%mfm)
   end function fmasinh_fm

   function fmasinh_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmasinh(ma%mzm, return_value%mzm)
   end function fmasinh_zm

   function fmasinh_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmasinh(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmasinh_fm1

   function fmasinh_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmasinh(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmasinh_zm1

   function fmasinh_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmasinh(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmasinh_fm2

   function fmasinh_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmasinh(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmasinh_zm2

!                                                                atan

   function fmatan_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmatan(ma%mfm, return_value%mfm)
   end function fmatan_fm

   function fmatan_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmatan(ma%mzm, return_value%mzm)
   end function fmatan_zm

   function fmatan_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmatan(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmatan_fm1

   function fmatan_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmatan(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmatan_zm1

   function fmatan_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmatan(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmatan_fm2

   function fmatan_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmatan(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmatan_zm2

!                                                                atanh

   function fmatanh_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmatanh(ma%mfm, return_value%mfm)
   end function fmatanh_fm

   function fmatanh_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmatanh(ma%mzm, return_value%mzm)
   end function fmatanh_zm

   function fmatanh_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmatanh(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmatanh_fm1

   function fmatanh_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmatanh(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmatanh_zm1

   function fmatanh_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmatanh(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmatanh_fm2

   function fmatanh_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmatanh(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmatanh_zm2

!                                                               atan2

   function fmatan2_fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmatn2(ma%mfm, mb%mfm, return_value%mfm)
   end function fmatan2_fm

!                                                               btest

   function fmbtest_im(ma, pos)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      integer :: pos
      logical :: return_value
      intent (in) :: ma, pos
      type(multi), save :: mtlvim, mulvim, mvlvim
      call fm_undef_inp(ma)
      call imi2m(2, mtlvim)
      call imi2m(pos, mulvim)
      call impwr(mtlvim, mulvim, mvlvim)
      call imdiv(ma%mim, mvlvim, mulvim)
      mulvim%mp(1) = 1
      call immod(mulvim, mtlvim, mvlvim)
      if (mvlvim%mp(3) == 0) then
          return_value = .false.
      else
          return_value = .true.
      endif
   end function fmbtest_im

!                                                             ceiling

   function fmceiling_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmint(ma%mfm, mtlvfm)
      call fmsub(ma%mfm, mtlvfm, mulvfm)
      if (mulvfm%mp(3) == 0) then
          call fmeq(ma%mfm, return_value%mfm)
      else if (ma%mfm%mp(1) > 0) then
          call fmaddi(mtlvfm, 1)
          call fmeq(mtlvfm, return_value%mfm)
      else
          call fmeq(mtlvfm, return_value%mfm)
      endif
   end function fmceiling_fm

   function fmceiling_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imeq(ma%mim, return_value%mim)
   end function fmceiling_im

   function fmceiling_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(multi), save :: mtlvfm, mulvfm, mvlvfm
      call fm_undef_inp(ma)
      call fmint(ma%mzm(1), mtlvfm)
      call fmsub(ma%mzm(1), mtlvfm, mulvfm)
      if (mulvfm%mp(3) == 0) then
          call fmeq(ma%mzm(1), mvlvfm)
      else if (ma%mzm(1)%mp(1) > 0) then
          call fmaddi(mtlvfm, 1)
          call fmeq(mtlvfm, mvlvfm)
      else
          call fmeq(mtlvfm, mvlvfm)
      endif
      call fmint(ma%mzm(2), mtlvfm)
      call fmsub(ma%mzm(2), mtlvfm, mulvfm)
      if (mulvfm%mp(3) == 0) then
          call fmeq(ma%mzm(2), mulvfm)
      else if (ma%mzm(2)%mp(1) > 0) then
          call fmaddi(mtlvfm, 1)
          call fmeq(mtlvfm, mulvfm)
      else
          call fmeq(mtlvfm, mulvfm)
      endif
      call zmcmpx(mvlvfm, mulvfm, return_value%mzm)
   end function fmceiling_zm

   function fmceiling_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm), save :: mt_fm
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fm_eq(fmceiling_fm(ma(j)), mt_fm)
         call fmeq(mt_fm%mfm, return_value(j)%mfm)
      enddo
   end function fmceiling_fm1

   function fmceiling_im1(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(im), save :: mt_im
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call im_eq(fmceiling_im(ma(j)), mt_im)
         call imeq(mt_im%mim, return_value(j)%mim)
      enddo
   end function fmceiling_im1

   function fmceiling_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(zm), save :: mt_zm
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zm_eq(fmceiling_zm(ma(j)), mt_zm)
         call zmeq(mt_zm%mzm, return_value(j)%mzm)
      enddo
   end function fmceiling_zm1

   function fmceiling_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm), save :: mt_fm
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fm_eq(fmceiling_fm(ma(j, k)), mt_fm)
            call fmeq(mt_fm%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmceiling_fm2

   function fmceiling_im2(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(im), save :: mt_im
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call im_eq(fmceiling_im(ma(j, k)), mt_im)
            call imeq(mt_im%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmceiling_im2

   function fmceiling_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(zm), save :: mt_zm
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zm_eq(fmceiling_zm(ma(j, k)), mt_zm)
            call zmeq(mt_zm%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmceiling_zm2

!                                                               cmplx

   function fmcmplx_fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (fm) :: ma
      type (fm), optional :: mb
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      if (present(mb)) then
          call fm_undef_inp(mb)
          call zmcmpx(ma%mfm, mb%mfm, return_value%mzm)
      else
          call fmi2m(0, mtlvfm)
          call zmcmpx(ma%mfm, mtlvfm, return_value%mzm)
      endif
   end function fmcmplx_fm

   function fmcmplx_im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value
      type (im) :: ma
      type (im), optional :: mb
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      if (present(mb)) then
          call fm_undef_inp(mb)
          call imi2fm(ma%mim, mtlvfm)
          call imi2fm(mb%mim, mulvfm)
          call zmcmpx(mtlvfm, mulvfm, return_value%mzm)
      else
          call imi2fm(ma%mim, mtlvfm)
          call fmi2m(0, mulvfm)
          call zmcmpx(mtlvfm, mulvfm, return_value%mzm)
      endif
   end function fmcmplx_im

!                                                               conjg

   function fmconjg_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: return_value, ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmconj(ma%mzm, return_value%mzm)
   end function fmconjg_zm

   function fmconjg_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmconj(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmconjg_zm1

   function fmconjg_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmconj(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmconjg_zm2

!                                                                 cos

   function fmcos_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmcos(ma%mfm, return_value%mfm)
   end function fmcos_fm

   function fmcos_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmcos(ma%mzm, return_value%mzm)
   end function fmcos_zm

   function fmcos_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmcos(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmcos_fm1

   function fmcos_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmcos(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmcos_zm1

   function fmcos_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmcos(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmcos_fm2

   function fmcos_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcos(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmcos_zm2

!                                                                cosh

   function fmcosh_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmcosh(ma%mfm, return_value%mfm)
   end function fmcosh_fm

   function fmcosh_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmcosh(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmcosh_fm1

   function fmcosh_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmcosh(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmcosh_zm1

   function fmcosh_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmcosh(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmcosh_fm2

   function fmcosh_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmcosh(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmcosh_zm2

   function fmcosh_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmcosh(ma%mzm, return_value%mzm)
   end function fmcosh_zm

!                                                                dble

   function fmdble_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmeq(ma%mfm, return_value%mfm)
   end function fmdble_fm

   function fmdble_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, return_value%mfm)
   end function fmdble_im

   function fmdble_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (zm) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmreal(ma%mzm, return_value%mfm)
   end function fmdble_zm

!                                                              digits

   function fmdigits_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer :: return_value
      intent (in) :: ma
      return_value = ndig
      if (allocated(ma%mfm%mp)) then
          if (size(ma%mfm%mp) <= 2) return_value = return_value - 1
      endif
   end function fmdigits_fm

   function fmdigits_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      integer :: return_value
      intent (in) :: ma

!             The number of possible digits for type(im) integers is limited only by the amount
!             of memory that can be allocated.  Return 10**6 since there is no fixed limit.

      return_value = 10**6
      if (allocated(ma%mim%mp)) then
          if (size(ma%mim%mp) <= 2) return_value = return_value - 1
      endif
   end function fmdigits_im

   function fmdigits_zm(ma)     result (return_value)
      use fmvals
      implicit none
      integer :: return_value
      type (zm) :: ma
      intent (in) :: ma
      return_value = ndig
      if (allocated(ma%mzm(1)%mp)) then
          if (size(ma%mzm(1)%mp) <= 2) return_value = return_value - 1
      endif
   end function fmdigits_zm

!                                                                 dim

   function fmdim_fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmdim(ma%mfm, mb%mfm, return_value%mfm)
   end function fmdim_fm

   function fmdim_im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imdim(ma%mim, mb%mim, return_value%mim)
   end function fmdim_im

!                                                                dint

   function fmdint_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmint(ma%mfm, return_value%mfm)
   end function fmdint_fm

   function fmdint_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmint(ma%mzm, return_value%mzm)
   end function fmdint_zm

!                                                         dot_product

   function fmdotproduct_fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma(:), mb(:), return_value
      integer :: j, ja, jb, mxsave, nd2, ndsave
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mulvfm, mvlvfm, m3lvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) == size(mb)) then
          ndsave = ndig
          j = max(ngrd52, 2)
          nd2 = max(2*ndig+j, 3)
          ndig = nd2
          mxsave = mxexp
          mxexp = mxexp2
          call fmi2m(0, m3lvfm)
          do j = 1, size(ma)
             ja = lbound(ma, dim=1) + j - 1
             call fmequ(ma(ja)%mfm, mulvfm, ndsave, ndig)
             jb = lbound(mb, dim=1) + j - 1
             call fmequ(mb(jb)%mfm, mvlvfm, ndsave, ndig)
             call fmmpy(mulvfm, mvlvfm, mtlvfm)
             call fmadd_r1(m3lvfm, mtlvfm)
          enddo
          mxexp = mxsave
          call fmequ(m3lvfm, return_value%mfm, ndig, ndsave)
          ndig = ndsave
      else
          call fmi2m(1, mtlvfm)
          call fmi2m(0, mulvfm)
          call fmdiv(mtlvfm, mulvfm, return_value%mfm)
      endif
   end function fmdotproduct_fm

   function fmdotproduct_im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma(:), mb(:), return_value
      integer :: j, ja, jb
      intent (in) :: ma, mb
      type(multi), save :: mtlvim, mulvim, m3lvim
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) == size(mb)) then
          call imi2m(0, m3lvim)
          do j = 1, size(ma)
             ja = lbound(ma, dim=1) + j - 1
             jb = lbound(mb, dim=1) + j - 1
             call immpy(ma(ja)%mim, mb(jb)%mim, mtlvim)
             call imadd(m3lvim, mtlvim, mulvim)
             call imeq(mulvim, m3lvim)
          enddo
          call imeq(m3lvim, return_value%mim)
      else
          call imi2m(1, mtlvim)
          call imi2m(0, mulvim)
          call imdiv(mtlvim, mulvim, return_value%mim)
      endif
   end function fmdotproduct_im

   function fmdotproduct_zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma(:), mb(:), return_value
      integer :: j, ja, jb, mxsave, nd2, ndsave
      intent (in) :: ma, mb
      type(multi), save :: mtlvzm(2), mulvzm(2), mvlvzm(2), m3lvzm(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) == size(mb)) then
          ndsave = ndig
          j = max(ngrd52, 2)
          nd2 = max(2*ndig+j, 3)
          ndig = nd2
          mxsave = mxexp
          mxexp = mxexp2
          call zmi2m(0, m3lvzm)
          do j = 1, size(ma)
             ja = lbound(ma, dim=1) + j - 1
             call zmequ(ma(ja)%mzm, mulvzm, ndsave, ndig)
             call fmnegate(mulvzm(2))
             jb = lbound(mb, dim=1) + j - 1
             call zmequ(mb(jb)%mzm, mvlvzm, ndsave, ndig)
             call zmmpy(mulvzm, mvlvzm, mtlvzm)
             call zmadd(m3lvzm, mtlvzm, mulvzm)
             call zmeq(mulvzm, m3lvzm)
          enddo
          mxexp = mxsave
          call zmequ(m3lvzm, return_value%mzm, ndig, ndsave)
          ndig = ndsave
      else
          call zmi2m(1, mtlvzm)
          call zmi2m(0, mulvzm)
          call zmdiv(mtlvzm, mulvzm, return_value%mzm)
      endif
   end function fmdotproduct_zm

!                                                             epsilon

   function fmepsilon_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fmi2m(1, mtlvfm)
      if (allocated(ma%mfm%mp)) then
          if (size(ma%mfm%mp) <= 2) call fmi2m(2, mtlvfm)
      endif
      call fmulp(mtlvfm, return_value%mfm)
   end function fmepsilon_fm

!                                                                 exp

   function fmexp_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmexp(ma%mfm, return_value%mfm)
   end function fmexp_fm

   function fmexp_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmexp(ma%mzm, return_value%mzm)
   end function fmexp_zm

   function fmexp_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmexp(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmexp_fm1

   function fmexp_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmexp(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmexp_zm1

   function fmexp_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmexp(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmexp_fm2

   function fmexp_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmexp(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmexp_zm2

!                                                            exponent

   function fmexponent_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer :: return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      return_value = int(ma%mfm%mp(2))
   end function fmexponent_fm

!                                                               floor

   function fmfloor_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmint(ma%mfm, mtlvfm)
      call fmsub(ma%mfm, mtlvfm, mulvfm)
      if (mulvfm%mp(3) == 0) then
          call fmeq(ma%mfm, return_value%mfm)
      else if (ma%mfm%mp(1) < 0) then
          call fmaddi(mtlvfm, -1)
          call fmeq(mtlvfm, return_value%mfm)
      else
          call fmeq(mtlvfm, return_value%mfm)
      endif
   end function fmfloor_fm

   function fmfloor_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imeq(ma%mim, return_value%mim)
   end function fmfloor_im

   function fmfloor_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(multi), save :: mtlvfm, mulvfm, mvlvfm
      call fm_undef_inp(ma)
      call fmint(ma%mzm(1), mtlvfm)
      call fmsub(ma%mzm(1), mtlvfm, mulvfm)
      if (mulvfm%mp(3) == 0) then
          call fmeq(ma%mzm(1), mvlvfm)
      else if (ma%mzm(1)%mp(1) < 0) then
          call fmaddi(mtlvfm, -1)
          call fmeq(mtlvfm, mvlvfm)
      else
          call fmeq(mtlvfm, mvlvfm)
      endif
      call fmint(ma%mzm(2), mtlvfm)
      call fmsub(ma%mzm(2), mtlvfm, mulvfm)
      if (mulvfm%mp(3) == 0) then
          call fmeq(ma%mzm(2), mulvfm)
      else if (ma%mzm(2)%mp(1) < 0) then
          call fmaddi(mtlvfm, -1)
          call fmeq(mtlvfm, mulvfm)
      else
          call fmeq(mtlvfm, mulvfm)
      endif
      call zmcmpx(mvlvfm, mulvfm, return_value%mzm)
   end function fmfloor_zm

   function fmfloor_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm), save :: mt_fm
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fm_eq(fmfloor_fm(ma(j)), mt_fm)
         call fmeq(mt_fm%mfm, return_value(j)%mfm)
      enddo
   end function fmfloor_fm1

   function fmfloor_im1(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(im), save :: mt_im
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call im_eq(fmfloor_im(ma(j)), mt_im)
         call imeq(mt_im%mim, return_value(j)%mim)
      enddo
   end function fmfloor_im1

   function fmfloor_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(zm), save :: mt_zm
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zm_eq(fmfloor_zm(ma(j)), mt_zm)
         call zmeq(mt_zm%mzm, return_value(j)%mzm)
      enddo
   end function fmfloor_zm1

   function fmfloor_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm), save :: mt_fm
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fm_eq(fmfloor_fm(ma(j, k)), mt_fm)
            call fmeq(mt_fm%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmfloor_fm2

   function fmfloor_im2(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(im), save :: mt_im
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call im_eq(fmfloor_im(ma(j, k)), mt_im)
            call imeq(mt_im%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmfloor_im2

   function fmfloor_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(zm), save :: mt_zm
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zm_eq(fmfloor_zm(ma(j, k)), mt_zm)
            call zmeq(mt_zm%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmfloor_zm2

!                                                            fraction

   function fmfraction_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmeq(ma%mfm, mtlvfm)
      mtlvfm%mp(2) = 0
      call fmeq(mtlvfm, return_value%mfm)
   end function fmfraction_fm

   function fmfraction_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(multi), save :: mtlvzm(2)
      call fm_undef_inp(ma)
      call zmeq(ma%mzm, mtlvzm)
      mtlvzm(1)%mp(2) = 0
      mtlvzm(2)%mp(2) = 0
      call zmeq(mtlvzm, return_value%mzm)
   end function fmfraction_zm

   function fmfraction_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(fm), save :: mt_fm
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fm_eq(fmfraction_fm(ma(j)), mt_fm)
         call fmeq(mt_fm%mfm, return_value(j)%mfm)
      enddo
   end function fmfraction_fm1

   function fmfraction_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(zm), save :: mt_zm
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zm_eq(fmfraction_zm(ma(j)), mt_zm)
         call zmeq(mt_zm%mzm, return_value(j)%mzm)
      enddo
   end function fmfraction_zm1

   function fmfraction_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(fm), save :: mt_fm
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fm_eq(fmfraction_fm(ma(j, k)), mt_fm)
            call fmeq(mt_fm%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmfraction_fm2

   function fmfraction_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(zm), save :: mt_zm
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zm_eq(fmfraction_zm(ma(j, k)), mt_zm)
            call zmeq(mt_zm%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmfraction_zm2

!                                                                huge

   function fmhuge_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fmbig(return_value%mfm)
      if (allocated(ma%mfm%mp)) then
          if (size(ma%mfm%mp) <= 2) then
              call fmi2m(1, mtlvfm)
              call fmsub_r1(return_value%mfm, mtlvfm)
          endif
      endif
   end function fmhuge_fm

   function fmhuge_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, return_value
      intent (in) :: ma
      type(multi), save :: mtlvim, mulvim
      call imbig(return_value%mim)
      if (allocated(ma%mim%mp)) then
          if (size(ma%mim%mp) <= 2) then
              call imi2m(0, mtlvim)
              call imsub(return_value%mim, mtlvim, mulvim)
          endif
      endif
   end function fmhuge_im

   function fmhuge_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fmbig(mtlvfm)
      call zmcmpx(mtlvfm, mtlvfm, return_value%mzm)
      if (allocated(ma%mzm(1)%mp)) then
          if (size(ma%mzm(1)%mp) <= 2) then
              call zmi2m(1, mtlvzm)
              call zmsub_r1(return_value%mzm, mtlvzm)
          endif
      endif
   end function fmhuge_zm
!                                                               hypot

   function fmhypot_fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmhypot(ma%mfm, mb%mfm, return_value%mfm)
   end function fmhypot_fm

!                                                                 int

   function fmint_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (im) :: return_value
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmint(ma%mfm, mtlvfm)
      call imfm2i(mtlvfm, return_value%mim)
   end function fmint_fm

   function fmint_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imeq(ma%mim, return_value%mim)
   end function fmint_im

   function fmint_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (im) :: return_value
      intent (in) :: ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call zmreal(ma%mzm, mtlvfm)
      call fmint(mtlvfm, mulvfm)
      call imfm2i(mulvfm, return_value%mim)
   end function fmint_zm

   function fmint_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(im), save :: mt_im
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call im_eq(fmint_fm(ma(j)), mt_im)
         call imeq(mt_im%mim, return_value(j)%mim)
      enddo
   end function fmint_fm1

   function fmint_im1(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(im), save :: mt_im
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call im_eq(fmint_im(ma(j)), mt_im)
         call imeq(mt_im%mim, return_value(j)%mim)
      enddo
   end function fmint_im1

   function fmint_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(im), save :: mt_im
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call im_eq(fmint_zm(ma(j)), mt_im)
         call imeq(mt_im%mim, return_value(j)%mim)
      enddo
   end function fmint_zm1

   function fmint_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(im), save :: mt_im
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call im_eq(fmint_fm(ma(j, k)), mt_im)
            call imeq(mt_im%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmint_fm2

   function fmint_im2(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(im), save :: mt_im
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call im_eq(fmint_im(ma(j, k)), mt_im)
            call imeq(mt_im%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmint_im2

   function fmint_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(im), save :: mt_im
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call im_eq(fmint_zm(ma(j, k)), mt_im)
            call imeq(mt_im%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmint_zm2

!                                                                 log

   function fmlog_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmln(ma%mfm, return_value%mfm)
   end function fmlog_fm

   function fmlog_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmln(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmlog_fm1

   function fmlog_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmln(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmlog_zm1

   function fmlog_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmln(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmlog_fm2

   function fmlog_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmln(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmlog_zm2

   function fmlog_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmln(ma%mzm, return_value%mzm)
   end function fmlog_zm

!                                                               log10

   function fmlog10_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmlg10(ma%mfm, return_value%mfm)
   end function fmlog10_fm

   function fmlog10_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmlg10(ma%mzm, return_value%mzm)
   end function fmlog10_zm

   function fmlog10_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmlg10(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmlog10_fm1

   function fmlog10_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmlg10(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmlog10_zm1

   function fmlog10_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmlg10(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmlog10_fm2

   function fmlog10_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmlg10(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmlog10_zm2

!                                                              matmul

   function fmmatmul22_fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma(:,:), mb(:,:)
      type (fm), dimension(size(ma, dim=1), size(mb, dim=2)) :: return_value
      integer :: i, j, k, mxsave, nd2, ndsave
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mulvfm, mvlvfm, mtlv01
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=2) == size(mb, dim=1)) then
          ndsave = ndig
          j = max(ngrd52, 2)
          nd2 = max(2*ndig+j, 3)
          ndig = nd2
          mxsave = mxexp
          do i = 1, size(ma, dim=1)
             do j = 1, size(mb, dim=2)
                mxexp = mxexp2
                call fmi2m(0, mtlvfm)
                do k = 1, size(ma, dim=2)
                   call fmequ(ma(i, k)%mfm, mulvfm, ndsave, ndig)
                   call fmequ(mb(k, j)%mfm, mvlvfm, ndsave, ndig)
                   call fmmpy(mulvfm, mvlvfm, mtlv01)
                   call fmadd_r1(mtlvfm, mtlv01)
                enddo
                mxexp = mxsave
                call fmequ(mtlvfm, return_value(i, j)%mfm, ndig, ndsave)
             enddo
          enddo
          ndig = ndsave
      else
          call fmi2m(1, mtlvfm)
          call fmi2m(0, mulvfm)
          call fmdiv(mtlvfm, mulvfm, mvlvfm)
          do i = 1, size(ma, dim=1)
             do j = 1, size(mb, dim=2)
                call fmeq(mvlvfm, return_value(i, j)%mfm)
             enddo
          enddo
      endif
   end function fmmatmul22_fm

   function fmmatmul12_fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma(:), mb(:,:)
      type (fm), dimension(size(mb, dim=2)) :: return_value
      integer :: j, k, mxsave, nd2, ndsave
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mulvfm, mvlvfm, mtlv01
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) == size(mb, dim=1)) then
          ndsave = ndig
          j = max(ngrd52, 2)
          nd2 = max(2*ndig+j, 3)
          ndig = nd2
          mxsave = mxexp
          do j = 1, size(mb, dim=2)
             mxexp = mxexp2
             call fmi2m(0, mtlvfm)
             do k = 1, size(ma, dim=1)
                call fmequ(ma(k)%mfm, mulvfm, ndsave, ndig)
                call fmequ(mb(k, j)%mfm, mvlvfm, ndsave, ndig)
                call fmmpy(mulvfm, mvlvfm, mtlv01)
                call fmadd_r1(mtlvfm, mtlv01)
             enddo
             mxexp = mxsave
             call fmequ(mtlvfm, return_value(j)%mfm, ndig, ndsave)
          enddo
          ndig = ndsave
      else
          call fmunknown(mvlvfm)
          do j = 1, size(mb, dim=2)
             call fmeq(mvlvfm, return_value(j)%mfm)
          enddo
      endif
   end function fmmatmul12_fm

   function fmmatmul21_fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma(:,:), mb(:)
      type (fm), dimension(size(ma, dim=1)) :: return_value
      integer :: j, k, mxsave, nd2, ndsave
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm, mulvfm, mvlvfm, mtlv01
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(mb) == size(ma, dim=2)) then
          ndsave = ndig
          j = max(ngrd52, 2)
          nd2 = max(2*ndig+j, 3)
          ndig = nd2
          mxsave = mxexp
          do j = 1, size(ma, dim=1)
             mxexp = mxexp2
             call fmi2m(0, mtlvfm)
             do k = 1, size(mb, dim=1)
                call fmequ(ma(j, k)%mfm, mulvfm, ndsave, ndig)
                call fmequ(mb(k)%mfm, mvlvfm, ndsave, ndig)
                call fmmpy(mulvfm, mvlvfm, mtlv01)
                call fmadd_r1(mtlvfm, mtlv01)
             enddo
             mxexp = mxsave
             call fmequ(mtlvfm, return_value(j)%mfm, ndig, ndsave)
          enddo
          ndig = ndsave
      else
          call fmunknown(mvlvfm)
          do j = 1, size(ma, dim=1)
             call fmeq(mvlvfm, return_value(j)%mfm)
          enddo
      endif
   end function fmmatmul21_fm

   function fmmatmul22_im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma(:,:), mb(:,:)
      type (im), dimension(size(ma, dim=1), size(mb, dim=2)) :: return_value
      integer :: i, j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvim, mulvim, m3lvim, mtlv01
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=2) == size(mb, dim=1)) then
          do i = 1, size(ma, dim=1)
             do j = 1, size(mb, dim=2)
                call imi2m(0, mtlvim)
                do k = 1, size(ma, dim=2)
                   call immpy(ma(i, k)%mim, mb(k, j)%mim, mtlv01)
                   call imadd(mtlvim, mtlv01, mulvim)
                   call imeq(mulvim, mtlvim)
                enddo
                call imeq(mtlvim, return_value(i, j)%mim)
             enddo
          enddo
      else
          call imi2m(1, mtlvim)
          call imi2m(0, mulvim)
          call imdiv(mtlvim, mulvim, m3lvim)
          do i = 1, size(ma, dim=1)
             do j = 1, size(mb, dim=2)
                call imeq(m3lvim, return_value(i, j)%mim)
             enddo
          enddo
      endif
   end function fmmatmul22_im

   function fmmatmul12_im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma(:), mb(:,:)
      type (im), dimension(size(mb, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvim, mulvim, mtlv01
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) == size(mb, dim=1)) then
          do j = 1, size(mb, dim=2)
             call imi2m(0, mtlvim)
             do k = 1, size(ma, dim=1)
                call immpy(ma(k)%mim, mb(k, j)%mim, mtlv01)
                call imadd(mtlvim, mtlv01, mulvim)
                call imeq(mulvim, mtlvim)
             enddo
             call imeq(mtlvim, return_value(j)%mim)
          enddo
      else
          call imunknown(mulvim)
          do j = 1, size(mb, dim=2)
             call imeq(mulvim, return_value(j)%mim)
          enddo
      endif
   end function fmmatmul12_im

   function fmmatmul21_im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma(:,:), mb(:)
      type (im), dimension(size(ma, dim=1)) :: return_value
      integer :: j, k
      intent (in) :: ma, mb
      type(multi), save :: mtlvim, mulvim, mtlv01
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(mb) == size(ma, dim=2)) then
          do j = 1, size(ma, dim=1)
             call imi2m(0, mtlvim)
             do k = 1, size(mb, dim=1)
                call immpy(ma(j, k)%mim, mb(k)%mim, mtlv01)
                call imadd(mtlvim, mtlv01, mulvim)
                call imeq(mulvim, mtlvim)
             enddo
             call imeq(mtlvim, return_value(j)%mim)
          enddo
      else
          call imunknown(mulvim)
          do j = 1, size(ma, dim=1)
             call imeq(mulvim, return_value(j)%mim)
          enddo
      endif
   end function fmmatmul21_im

   function fmmatmul22_zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma(:,:), mb(:,:)
      type (zm), dimension(size(ma, dim=1), size(mb, dim=2)) :: return_value
      integer :: i, j, k, mxsave, nd2, ndsave
      intent (in) :: ma, mb
      type(multi), save :: mtlvzm(2), mulvzm(2), mvlvzm(2), mzlv02(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma, dim=2) == size(mb, dim=1)) then
          ndsave = ndig
          j = max(ngrd52, 2)
          nd2 = max(2*ndig+j, 3)
          ndig = nd2
          mxsave = mxexp
          do i = 1, size(ma, dim=1)
             do j = 1, size(mb, dim=2)
                mxexp = mxexp2
                call zmi2m(0, mtlvzm)
                do k = 1, size(ma, dim=2)
                   call zmequ(ma(i, k)%mzm, mulvzm, ndsave, ndig)
                   call zmequ(mb(k, j)%mzm, mvlvzm, ndsave, ndig)
                   call zmmpy(mulvzm, mvlvzm, mzlv02)
                   call zmadd(mtlvzm, mzlv02, mulvzm)
                   call zmeq(mulvzm, mtlvzm)
                enddo
                mxexp = mxsave
                call zmequ(mtlvzm, return_value(i, j)%mzm, ndig, ndsave)
             enddo
          enddo
          ndig = ndsave
      else
          call zmi2m(1, mtlvzm)
          call zmi2m(0, mulvzm)
          call zmdiv(mtlvzm, mulvzm, mvlvzm)
          do i = 1, size(ma, dim=1)
             do j = 1, size(mb, dim=2)
                call zmeq(mvlvzm, return_value(i, j)%mzm)
             enddo
          enddo
      endif
   end function fmmatmul22_zm

   function fmmatmul12_zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma(:), mb(:,:)
      type (zm), dimension(size(mb, dim=2)) :: return_value
      integer :: j, k, mxsave, nd2, ndsave
      intent (in) :: ma, mb
      type(multi), save :: mtlvzm(2), mulvzm(2), mvlvzm(2), mzlv01(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(ma) == size(mb, dim=1)) then
          ndsave = ndig
          j = max(ngrd52, 2)
          nd2 = max(2*ndig+j, 3)
          ndig = nd2
          mxsave = mxexp
          do j = 1, size(mb, dim=2)
             mxexp = mxexp2
             call zmi2m(0, mtlvzm)
             do k = 1, size(ma, dim=1)
                call zmequ(ma(k)%mzm, mulvzm, ndsave, ndig)
                call zmequ(mb(k, j)%mzm, mvlvzm, ndsave, ndig)
                call zmmpy(mulvzm, mvlvzm, mzlv01)
                call zmadd(mtlvzm, mzlv01, mulvzm)
                call zmeq(mulvzm, mtlvzm)
             enddo
             mxexp = mxsave
             call zmequ(mtlvzm, return_value(j)%mzm, ndig, ndsave)
          enddo
          ndig = ndsave
      else
          call zmst2m('UNKNOWN+UNKNOWN*i', mvlvzm)
          do j = 1, size(mb, dim=2)
             call zmeq(mvlvzm, return_value(j)%mzm)
          enddo
      endif
   end function fmmatmul12_zm

   function fmmatmul21_zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma(:,:), mb(:)
      type (zm), dimension(size(ma, dim=1)) :: return_value
      integer :: j, k, mxsave, nd2, ndsave
      intent (in) :: ma, mb
      type(multi), save :: mtlvzm(2), mulvzm(2), mvlvzm(2), mzlv01(2)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      if (size(mb) == size(ma, dim=2)) then
          ndsave = ndig
          j = max(ngrd52, 2)
          nd2 = max(2*ndig+j, 3)
          ndig = nd2
          mxsave = mxexp
          do j = 1, size(ma, dim=1)
             mxexp = mxexp2
             call zmi2m(0, mtlvzm)
             do k = 1, size(mb, dim=1)
                call zmequ(ma(j, k)%mzm, mulvzm, ndsave, ndig)
                call zmequ(mb(k)%mzm, mvlvzm, ndsave, ndig)
                call zmmpy(mulvzm, mvlvzm, mzlv01)
                call zmadd(mtlvzm, mzlv01, mulvzm)
                call zmeq(mulvzm, mtlvzm)
             enddo
             mxexp = mxsave
             call zmequ(mtlvzm, return_value(j)%mzm, ndig, ndsave)
          enddo
          ndig = ndsave
      else
          call zmst2m('UNKNOWN+UNKNOWN*i', mvlvzm)
          do j = 1, size(ma, dim=1)
             call zmeq(mvlvzm, return_value(j)%mzm)
          enddo
      endif
   end function fmmatmul21_zm

!                                                                 max

   function fmmax_fm(ma, mb, mc, md, me, mf, mg, mh, mi, mj)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, mb, return_value
      type (fm), optional :: mc, md, me, mf, mg, mh, mi, mj
      intent (in) :: ma, mb, mc, md, me, mf, mg, mh, mi, mj
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmmax(ma%mfm, mb%mfm, mtlvfm)
      if (present(mc)) then
          call fm_undef_inp(mc)
          call fmmax(mtlvfm, mc%mfm, mulvfm)
          call fmeq(mulvfm, mtlvfm)
      endif
      if (present(md)) then
          call fm_undef_inp(md)
          call fmmax(mtlvfm, md%mfm, mulvfm)
          call fmeq(mulvfm, mtlvfm)
      endif
      if (present(me)) then
          call fm_undef_inp(me)
          call fmmax(mtlvfm, me%mfm, mulvfm)
          call fmeq(mulvfm, mtlvfm)
      endif
      if (present(mf)) then
          call fm_undef_inp(mf)
          call fmmax(mtlvfm, mf%mfm, mulvfm)
          call fmeq(mulvfm, mtlvfm)
      endif
      if (present(mg)) then
          call fm_undef_inp(mg)
          call fmmax(mtlvfm, mg%mfm, mulvfm)
          call fmeq(mulvfm, mtlvfm)
      endif
      if (present(mh)) then
          call fm_undef_inp(mh)
          call fmmax(mtlvfm, mh%mfm, mulvfm)
          call fmeq(mulvfm, mtlvfm)
      endif
      if (present(mi)) then
          call fm_undef_inp(mi)
          call fmmax(mtlvfm, mi%mfm, mulvfm)
          call fmeq(mulvfm, mtlvfm)
      endif
      if (present(mj)) then
          call fm_undef_inp(mj)
          call fmmax(mtlvfm, mj%mfm, mulvfm)
          call fmeq(mulvfm, mtlvfm)
      endif
      call fmeq(mtlvfm, return_value%mfm)
   end function fmmax_fm

   function fmmax_im(ma, mb, mc, md, me, mf, mg, mh, mi, mj)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, mb, return_value
      type (im), optional :: mc, md, me, mf, mg, mh, mi, mj
      intent (in) :: ma, mb, mc, md, me, mf, mg, mh, mi, mj
      type(multi), save :: mtlvim, mulvim
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call immax(ma%mim, mb%mim, mtlvim)
      if (present(mc)) then
          call fm_undef_inp(mc)
          call immax(mtlvim, mc%mim, mulvim)
          call imeq(mulvim, mtlvim)
      endif
      if (present(md)) then
          call fm_undef_inp(md)
          call immax(mtlvim, md%mim, mulvim)
          call imeq(mulvim, mtlvim)
      endif
      if (present(me)) then
          call fm_undef_inp(me)
          call immax(mtlvim, me%mim, mulvim)
          call imeq(mulvim, mtlvim)
      endif
      if (present(mf)) then
          call fm_undef_inp(mf)
          call immax(mtlvim, mf%mim, mulvim)
          call imeq(mulvim, mtlvim)
      endif
      if (present(mg)) then
          call fm_undef_inp(mg)
          call immax(mtlvim, mg%mim, mulvim)
          call imeq(mulvim, mtlvim)
      endif
      if (present(mh)) then
          call fm_undef_inp(mh)
          call immax(mtlvim, mh%mim, mulvim)
          call imeq(mulvim, mtlvim)
      endif
      if (present(mi)) then
          call fm_undef_inp(mi)
          call immax(mtlvim, mi%mim, mulvim)
          call imeq(mulvim, mtlvim)
      endif
      if (present(mj)) then
          call fm_undef_inp(mj)
          call immax(mtlvim, mj%mim, mulvim)
          call imeq(mulvim, mtlvim)
      endif
      call imeq(mtlvim, return_value%mim)
   end function fmmax_im

!                                                         maxexponent

   function fmmaxexponent_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer :: return_value
      intent (in) :: ma
      return_value = int(mxexp) + 1
      if (allocated(ma%mfm%mp)) then
          if (size(ma%mfm%mp) <= 2) return_value = return_value - 1
      endif
   end function fmmaxexponent_fm

!                                                              maxloc

   function fmmaxloc1_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma(:)
      integer :: return_value
      integer :: j, ja
      logical, external :: fmcomp
      intent (in) :: ma
      type(multi), save :: m3lvfm
      call fm_undef_inp(ma)
      call fmst2m(' -OVERFLOW ', m3lvfm)
      return_value = lbound(ma, dim=1)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         if (fmcomp(ma(ja)%mfm, '>', m3lvfm)) then
             call fmeq(ma(ja)%mfm, m3lvfm)
             return_value = ja
         endif
      enddo
   end function fmmaxloc1_fm

   function fmmaxloc2_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma(:,:)
      integer :: return_value(2)
      integer :: j, k, ja, jb
      logical, external :: fmcomp
      intent (in) :: ma
      type(multi), save :: m3lvfm
      call fm_undef_inp(ma)
      call fmst2m(' -OVERFLOW ', m3lvfm)
      return_value = (/ lbound(ma, dim=1), lbound(ma, dim=2) /)
      do k = 1, size(ma, dim=2)
         do j = 1, size(ma, dim=1)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            if (fmcomp(ma(ja, jb)%mfm, '>', m3lvfm)) then
                call fmeq(ma(ja, jb)%mfm, m3lvfm)
                return_value = (/ ja, jb /)
            endif
         enddo
      enddo
   end function fmmaxloc2_fm

   function fmmaxloc1_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma(:)
      integer :: return_value
      integer :: j, ja
      logical, external :: imcomp
      intent (in) :: ma
      type(multi), save :: m3lvim
      call fm_undef_inp(ma)
      call imst2m(' -OVERFLOW ', m3lvim)
      return_value = lbound(ma, dim=1)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         if (imcomp(ma(ja)%mim, '>', m3lvim)) then
             call imeq(ma(ja)%mim, m3lvim)
             return_value = ja
         endif
      enddo
   end function fmmaxloc1_im

   function fmmaxloc2_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma(:,:)
      integer :: return_value(2)
      integer :: j, k, ja, jb
      logical, external :: imcomp
      intent (in) :: ma
      type(multi), save :: m3lvim
      call fm_undef_inp(ma)
      call imst2m(' -OVERFLOW ', m3lvim)
      return_value = (/ lbound(ma, dim=1), lbound(ma, dim=2) /)
      do k = 1, size(ma, dim=2)
         do j = 1, size(ma, dim=1)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            if (imcomp(ma(ja, jb)%mim, '>', m3lvim)) then
                call imeq(ma(ja, jb)%mim, m3lvim)
                return_value = (/ ja, jb /)
            endif
         enddo
      enddo
   end function fmmaxloc2_im

!                                                              maxval

   function fmmaxval1_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma(:), return_value
      integer :: j, ja
      logical, external :: fmcomp
      intent (in) :: ma
      type(multi), save :: m3lvfm
      call fm_undef_inp(ma)
      call fmst2m(' -OVERFLOW ', m3lvfm)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         if (fmcomp(ma(ja)%mfm, '>', m3lvfm)) call fmeq(ma(ja)%mfm, m3lvfm)
      enddo
      call fmeq(m3lvfm, return_value%mfm)
   end function fmmaxval1_fm

   function fmmaxval2_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma(:,:), return_value
      integer :: j, k, ja, jb
      logical, external :: fmcomp
      intent (in) :: ma
      type(multi), save :: m3lvfm
      call fm_undef_inp(ma)
      call fmst2m(' -OVERFLOW ', m3lvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            if (fmcomp(ma(ja, jb)%mfm, '>', m3lvfm)) call fmeq(ma(ja, jb)%mfm, m3lvfm)
         enddo
      enddo
      call fmeq(m3lvfm, return_value%mfm)
   end function fmmaxval2_fm

   function fmmaxval1_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma(:), return_value
      integer :: j, ja
      logical, external :: imcomp
      intent (in) :: ma
      type(multi), save :: m3lvim
      call fm_undef_inp(ma)
      call imst2m(' -OVERFLOW ', m3lvim)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         if (imcomp(ma(ja)%mim, '>', m3lvim)) call imeq(ma(ja)%mim, m3lvim)
      enddo
      call imeq(m3lvim, return_value%mim)
   end function fmmaxval1_im

   function fmmaxval2_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma(:,:), return_value
      integer :: j, k, ja, jb
      logical, external :: imcomp
      intent (in) :: ma
      type(multi), save :: m3lvim
      call fm_undef_inp(ma)
      call imst2m(' -OVERFLOW ', m3lvim)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            if (imcomp(ma(ja, jb)%mim, '>', m3lvim)) call imeq(ma(ja, jb)%mim, m3lvim)
         enddo
      enddo
      call imeq(m3lvim, return_value%mim)
   end function fmmaxval2_im

!                                                                 min

   function fmmin_fm(ma, mb, mc, md, me, mf, mg, mh, mi, mj)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, mb, return_value
      type (fm), optional :: mc, md, me, mf, mg, mh, mi, mj
      intent (in) :: ma, mb, mc, md, me, mf, mg, mh, mi, mj
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmmin(ma%mfm, mb%mfm, mtlvfm)
      if (present(mc)) then
          call fm_undef_inp(mc)
          call fmmin(mtlvfm, mc%mfm, mulvfm)
          call fmeq(mulvfm, mtlvfm)
      endif
      if (present(md)) then
          call fm_undef_inp(md)
          call fmmin(mtlvfm, md%mfm, mulvfm)
          call fmeq(mulvfm, mtlvfm)
      endif
      if (present(me)) then
          call fm_undef_inp(me)
          call fmmin(mtlvfm, me%mfm, mulvfm)
          call fmeq(mulvfm, mtlvfm)
      endif
      if (present(mf)) then
          call fm_undef_inp(mf)
          call fmmin(mtlvfm, mf%mfm, mulvfm)
          call fmeq(mulvfm, mtlvfm)
      endif
      if (present(mg)) then
          call fm_undef_inp(mg)
          call fmmin(mtlvfm, mg%mfm, mulvfm)
          call fmeq(mulvfm, mtlvfm)
      endif
      if (present(mh)) then
          call fm_undef_inp(mh)
          call fmmin(mtlvfm, mh%mfm, mulvfm)
          call fmeq(mulvfm, mtlvfm)
      endif
      if (present(mi)) then
          call fm_undef_inp(mi)
          call fmmin(mtlvfm, mi%mfm, mulvfm)
          call fmeq(mulvfm, mtlvfm)
      endif
      if (present(mj)) then
          call fm_undef_inp(mj)
          call fmmin(mtlvfm, mj%mfm, mulvfm)
          call fmeq(mulvfm, mtlvfm)
      endif
      call fmeq(mtlvfm, return_value%mfm)
   end function fmmin_fm

   function fmmin_im(ma, mb, mc, md, me, mf, mg, mh, mi, mj)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, mb, return_value
      type (im), optional :: mc, md, me, mf, mg, mh, mi, mj
      intent (in) :: ma, mb, mc, md, me, mf, mg, mh, mi, mj
      type(multi), save :: mtlvim, mulvim
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call immin(ma%mim, mb%mim, mtlvim)
      if (present(mc)) then
          call fm_undef_inp(mc)
          call immin(mtlvim, mc%mim, mulvim)
          call imeq(mulvim, mtlvim)
      endif
      if (present(md)) then
          call fm_undef_inp(md)
          call immin(mtlvim, md%mim, mulvim)
          call imeq(mulvim, mtlvim)
      endif
      if (present(me)) then
          call fm_undef_inp(me)
          call immin(mtlvim, me%mim, mulvim)
          call imeq(mulvim, mtlvim)
      endif
      if (present(mf)) then
          call fm_undef_inp(mf)
          call immin(mtlvim, mf%mim, mulvim)
          call imeq(mulvim, mtlvim)
      endif
      if (present(mg)) then
          call fm_undef_inp(mg)
          call immin(mtlvim, mg%mim, mulvim)
          call imeq(mulvim, mtlvim)
      endif
      if (present(mh)) then
          call fm_undef_inp(mh)
          call immin(mtlvim, mh%mim, mulvim)
          call imeq(mulvim, mtlvim)
      endif
      if (present(mi)) then
          call fm_undef_inp(mi)
          call immin(mtlvim, mi%mim, mulvim)
          call imeq(mulvim, mtlvim)
      endif
      if (present(mj)) then
          call fm_undef_inp(mj)
          call immin(mtlvim, mj%mim, mulvim)
          call imeq(mulvim, mtlvim)
      endif
      call imeq(mtlvim, return_value%mim)
   end function fmmin_im

!                                                         minexponent

   function fmminexponent_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer :: return_value
      intent (in) :: ma
      return_value = -int(mxexp)
      if (allocated(ma%mfm%mp)) then
          if (size(ma%mfm%mp) <= 2) return_value = return_value - 1
      endif
   end function fmminexponent_fm

!                                                              minval

   function fmminval1_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma(:), return_value
      integer :: j, ja
      logical, external :: fmcomp
      intent (in) :: ma
      type(multi), save :: m3lvfm
      call fm_undef_inp(ma)
      call fmst2m(' OVERFLOW ', m3lvfm)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         if (fmcomp(ma(ja)%mfm, '<', m3lvfm)) call fmeq(ma(ja)%mfm, m3lvfm)
      enddo
      call fmeq(m3lvfm, return_value%mfm)
   end function fmminval1_fm

   function fmminval2_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma(:,:), return_value
      integer :: j, k, ja, jb
      logical, external :: fmcomp
      intent (in) :: ma
      type(multi), save :: m3lvfm
      call fm_undef_inp(ma)
      call fmst2m(' OVERFLOW ', m3lvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            if (fmcomp(ma(ja, jb)%mfm, '<', m3lvfm)) call fmeq(ma(ja, jb)%mfm, m3lvfm)
         enddo
      enddo
      call fmeq(m3lvfm, return_value%mfm)
   end function fmminval2_fm

   function fmminval1_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma(:), return_value
      integer :: j, ja
      logical, external :: imcomp
      intent (in) :: ma
      type(multi), save :: m3lvim
      call fm_undef_inp(ma)
      call imst2m(' OVERFLOW ', m3lvim)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         if (imcomp(ma(ja)%mim, '<', m3lvim)) call imeq(ma(ja)%mim, m3lvim)
      enddo
      call imeq(m3lvim, return_value%mim)
   end function fmminval1_im

   function fmminval2_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma(:,:), return_value
      integer :: j, k, ja, jb
      logical, external :: imcomp
      intent (in) :: ma
      type(multi), save :: m3lvim
      call fm_undef_inp(ma)
      call imst2m(' OVERFLOW ', m3lvim)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            if (imcomp(ma(ja, jb)%mim, '<', m3lvim)) call imeq(ma(ja, jb)%mim, m3lvim)
         enddo
      enddo
      call imeq(m3lvim, return_value%mim)
   end function fmminval2_im

!                                                              minloc

   function fmminloc1_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma(:)
      integer :: return_value
      integer :: j, ja
      logical, external :: fmcomp
      intent (in) :: ma
      type(multi), save :: m3lvfm
      call fm_undef_inp(ma)
      call fmst2m(' OVERFLOW ', m3lvfm)
      return_value = lbound(ma, dim=1)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         if (fmcomp(ma(ja)%mfm, '<', m3lvfm)) then
             call fmeq(ma(ja)%mfm, m3lvfm)
             return_value = ja
         endif
      enddo
   end function fmminloc1_fm

   function fmminloc2_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma(:,:)
      integer :: return_value(2)
      integer :: j, k, ja, jb
      logical, external :: fmcomp
      intent (in) :: ma
      type(multi), save :: m3lvfm
      call fm_undef_inp(ma)
      call fmst2m(' OVERFLOW ', m3lvfm)
      return_value = (/ lbound(ma, dim=1), lbound(ma, dim=2) /)
      do k = 1, size(ma, dim=2)
         do j = 1, size(ma, dim=1)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            if (fmcomp(ma(ja, jb)%mfm, '<', m3lvfm)) then
                call fmeq(ma(ja, jb)%mfm, m3lvfm)
                return_value = (/ ja, jb /)
            endif
         enddo
      enddo
   end function fmminloc2_fm

   function fmminloc1_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma(:)
      integer :: return_value
      integer :: j, ja
      logical, external :: imcomp
      intent (in) :: ma
      type(multi), save :: m3lvim
      call fm_undef_inp(ma)
      call imst2m(' OVERFLOW ', m3lvim)
      return_value = lbound(ma, dim=1)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         if (imcomp(ma(ja)%mim, '<', m3lvim)) then
             call imeq(ma(ja)%mim, m3lvim)
             return_value = ja
         endif
      enddo
   end function fmminloc1_im

   function fmminloc2_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma(:,:)
      integer :: return_value(2)
      integer :: j, k, ja, jb
      logical, external :: imcomp
      intent (in) :: ma
      type(multi), save :: m3lvim
      call fm_undef_inp(ma)
      call imst2m(' OVERFLOW ', m3lvim)
      return_value = (/ lbound(ma, dim=1), lbound(ma, dim=2) /)
      do k = 1, size(ma, dim=2)
         do j = 1, size(ma, dim=1)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            if (imcomp(ma(ja, jb)%mim, '<', m3lvim)) then
                call imeq(ma(ja, jb)%mim, m3lvim)
                return_value = (/ ja, jb /)
            endif
         enddo
      enddo
   end function fmminloc2_im

!                                                                 mod

   function fmmod_fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmmod(ma%mfm, mb%mfm, return_value%mfm)
   end function fmmod_fm

   function fmmod_im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call immod(ma%mim, mb%mim, return_value%mim)
   end function fmmod_im

!                                                              modulo

   function fmmodulo_fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmmod(ma%mfm, mb%mfm, mtlvfm)
      if (mtlvfm%mp(3) /= 0) then
          if ((ma%mfm%mp(3) > 0 .and. ma%mfm%mp(1) > 0 .and.  &
               mb%mfm%mp(3) > 0 .and. mb%mfm%mp(1) < 0) .or.  &
              (ma%mfm%mp(3) > 0 .and. ma%mfm%mp(1) < 0 .and.  &
               mb%mfm%mp(3) > 0 .and. mb%mfm%mp(1) > 0)) then
              call fmadd_r1(mtlvfm, mb%mfm)
          endif
      endif
      call fmeq(mtlvfm, return_value%mfm)
   end function fmmodulo_fm

   function fmmodulo_im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      type(multi), save :: mtlvim, mulvim
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call immod(ma%mim, mb%mim, mtlvim)
      if (mtlvim%mp(3) /= 0) then
          if ((ma%mim%mp(3) > 0 .and. ma%mim%mp(1) > 0 .and.  &
               mb%mim%mp(3) > 0 .and. mb%mim%mp(1) < 0) .or.  &
              (ma%mim%mp(3) > 0 .and. ma%mim%mp(1) < 0 .and.  &
               mb%mim%mp(3) > 0 .and. mb%mim%mp(1) > 0)) then
              call imadd(mtlvim, mb%mim, mulvim)
              call imeq(mulvim, mtlvim)
          endif
      endif
      call imeq(mtlvim, return_value%mim)
   end function fmmodulo_im

!                                                             nearest

   function fmnearest_fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, mb, return_value
      integer :: krsave
      intent (in) :: ma, mb
      type(multi), save :: m3lvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      krsave = kround
      call fmtiny(m3lvfm)
      if (ma%mfm%mp(2) /= mexpun) then
          if (mb%mfm%mp(1) > 0) then
              kround = 2
              call fmadd(ma%mfm, m3lvfm, return_value%mfm)
          else
              kround = -1
              call fmsub(ma%mfm, m3lvfm, return_value%mfm)
          endif
      else
          if (ma%mfm%mp(1) > 0 .and. mb%mfm%mp(1) > 0) then
              call fmeq(m3lvfm, return_value%mfm)
          else if (ma%mfm%mp(1) > 0 .and. mb%mfm%mp(1) < 0) then
              call fmi2m(0, return_value%mfm)
          else if (ma%mfm%mp(1) < 0 .and. mb%mfm%mp(1) > 0) then
              call fmi2m(0, return_value%mfm)
          else
              call fmmpyi_r1(m3lvfm, -1)
              call fmeq(m3lvfm, return_value%mfm)
          endif
      endif
      kround = krsave
   end function fmnearest_fm

!                                                                nint

   function fmnint_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      type (im) :: return_value
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmnint(ma%mfm, mtlvfm)
      call imfm2i(mtlvfm, return_value%mim)
   end function fmnint_fm

   function fmnint_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imeq(ma%mim, return_value%mim)
   end function fmnint_im

   function fmnint_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      type (im) :: return_value
      intent (in) :: ma
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call zmreal(ma%mzm, mtlvfm)
      call fmnint(mtlvfm, mulvfm)
      call imfm2i(mulvfm, return_value%mim)
   end function fmnint_zm

   function fmnint_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(im), save :: mt_im
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call im_eq(fmnint_fm(ma(j)), mt_im)
         call imeq(mt_im%mim, return_value(j)%mim)
      enddo
   end function fmnint_fm1

   function fmnint_im1(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(im), save :: mt_im
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call im_eq(fmnint_im(ma(j)), mt_im)
         call imeq(mt_im%mim, return_value(j)%mim)
      enddo
   end function fmnint_im1

   function fmnint_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      type(im), save :: mt_im
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call im_eq(fmnint_zm(ma(j)), mt_im)
         call imeq(mt_im%mim, return_value(j)%mim)
      enddo
   end function fmnint_zm1

   function fmnint_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(im), save :: mt_im
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call im_eq(fmnint_fm(ma(j, k)), mt_im)
            call imeq(mt_im%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmnint_fm2

   function fmnint_im2(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(im), save :: mt_im
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call im_eq(fmnint_im(ma(j, k)), mt_im)
            call imeq(mt_im%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmnint_im2

   function fmnint_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      type(im), save :: mt_im
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call im_eq(fmnint_zm(ma(j, k)), mt_im)
            call imeq(mt_im%mim, return_value(j, k)%mim)
         enddo
      enddo
   end function fmnint_zm2

!                                                             norm2

   function fmnorm21_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma(:), return_value
      type(multi), allocatable :: a(:)
      integer :: j, ja, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmi2m(0, return_value%mfm)
      n = size(ma)
      allocate(a(n))
      do j = 1, n
         ja = lbound(ma, dim=1) + j - 1
         call fmeq(ma(ja)%mfm, a(j))
      enddo
      call fmnorm2(a, n, return_value%mfm)
      deallocate(a)
   end function fmnorm21_fm

!                                                           precision

   function fmprecision_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer :: return_value
      intent (in) :: ma
      return_value = int(log10(real(mbase))*(ndig-1) + 1)
      if (allocated(ma%mfm%mp)) then
          if (size(ma%mfm%mp) <= 2) return_value = return_value - 1
      endif
   end function fmprecision_fm

   function fmprecision_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      integer :: return_value
      intent (in) :: ma
      return_value = int(log10(real(mbase))*(ndig-1) + 1)
      if (allocated(ma%mzm(1)%mp)) then
          if (size(ma%mzm(1)%mp) <= 2) return_value = return_value - 1
      endif
   end function fmprecision_zm

!                                                             product

   function fmproduct1_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma(:), return_value
      integer :: j, ja, mxsave, nd2, ndsave
      intent (in) :: ma
      type(multi), save :: mulvfm, m3lvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      j = max(ngrd52, 2)
      nd2 = max(2*ndig+j, 3)
      ndig = nd2
      mxsave = mxexp
      mxexp = mxexp2
      call fmi2m(1, m3lvfm)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         call fmequ(ma(ja)%mfm, mulvfm, ndsave, ndig)
         call fmmpy_r1(m3lvfm, mulvfm)
      enddo
      mxexp = mxsave
      call fmequ(m3lvfm, return_value%mfm, ndig, ndsave)
      ndig = ndsave
   end function fmproduct1_fm

   function fmproduct2_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma(:,:), return_value
      integer :: j, k, ja, jb, mxsave, nd2, ndsave
      intent (in) :: ma
      type(multi), save :: mulvfm, m3lvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      j = max(ngrd52, 2)
      nd2 = max(2*ndig+j, 3)
      ndig = nd2
      mxsave = mxexp
      mxexp = mxexp2
      call fmi2m(1, m3lvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            call fmequ(ma(ja, jb)%mfm, mulvfm, ndsave, ndig)
            call fmmpy_r1(m3lvfm, mulvfm)
         enddo
      enddo
      mxexp = mxsave
      call fmequ(m3lvfm, return_value%mfm, ndig, ndsave)
      ndig = ndsave
   end function fmproduct2_fm

   function fmproduct1_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma(:), return_value
      integer :: j, ja
      intent (in) :: ma
      type(multi), save :: mtlvim, m3lvim
      call fm_undef_inp(ma)
      call imi2m(1, m3lvim)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         call immpy(ma(ja)%mim, m3lvim, mtlvim)
         call imeq(mtlvim, m3lvim)
      enddo
      call imeq(m3lvim, return_value%mim)
   end function fmproduct1_im

   function fmproduct2_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma(:,:), return_value
      integer :: j, k, ja, jb
      intent (in) :: ma
      type(multi), save :: mtlvim, m3lvim
      call fm_undef_inp(ma)
      call imi2m(1, m3lvim)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            call immpy(ma(ja, jb)%mim, m3lvim, mtlvim)
            call imeq(mtlvim, m3lvim)
         enddo
      enddo
      call imeq(m3lvim, return_value%mim)
   end function fmproduct2_im

   function fmproduct1_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma(:), return_value
      integer :: j, ja, mxsave, nd2, ndsave
      intent (in) :: ma
      type(multi), save :: mtlvzm(2), mulvzm(2), m3lvzm(2)
      call fm_undef_inp(ma)
      ndsave = ndig
      j = max(ngrd52, 2)
      nd2 = max(2*ndig+j, 3)
      ndig = nd2
      mxsave = mxexp
      mxexp = mxexp2
      call zmi2m(1, m3lvzm)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         call zmequ(ma(ja)%mzm, mulvzm, ndsave, ndig)
         call zmmpy(mulvzm, m3lvzm, mtlvzm)
         call zmeq(mtlvzm, m3lvzm)
      enddo
      mxexp = mxsave
      call zmequ(m3lvzm, return_value%mzm, ndig, ndsave)
      ndig = ndsave
   end function fmproduct1_zm

   function fmproduct2_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma(:,:), return_value
      integer :: j, k, ja, jb, mxsave, nd2, ndsave
      intent (in) :: ma
      type(multi), save :: mtlvzm(2), mulvzm(2), m3lvzm(2)
      call fm_undef_inp(ma)
      ndsave = ndig
      j = max(ngrd52, 2)
      nd2 = max(2*ndig+j, 3)
      ndig = nd2
      mxsave = mxexp
      mxexp = mxexp2
      call zmi2m(1, m3lvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            call zmequ(ma(ja, jb)%mzm, mulvzm, ndsave, ndig)
            call zmmpy(mulvzm, m3lvzm, mtlvzm)
            call zmeq(mtlvzm, m3lvzm)
         enddo
      enddo
      mxexp = mxsave
      call zmequ(m3lvzm, return_value%mzm, ndig, ndsave)
      ndig = ndsave
   end function fmproduct2_zm

!                                                               radix

   function fmradix_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer :: return_value
      intent (in) :: ma
      return_value = int(mbase)
      if (allocated(ma%mfm%mp)) then
          if (size(ma%mfm%mp) <= 2) return_value = return_value - 1
      endif
   end function fmradix_fm

   function fmradix_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      integer :: return_value
      intent (in) :: ma
      return_value = int(mbase)
      if (allocated(ma%mim%mp)) then
          if (size(ma%mim%mp) <= 2) return_value = return_value - 1
      endif
   end function fmradix_im

   function fmradix_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      integer :: return_value
      intent (in) :: ma
      return_value = int(mbase)
      if (allocated(ma%mzm(1)%mp)) then
          if (size(ma%mzm(1)%mp) <= 2) return_value = return_value - 1
      endif
   end function fmradix_zm

!                                                               range

   function fmrange_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma
      integer :: return_value
      intent (in) :: ma
      return_value = nint((mxexp+1)*log10(dble(mbase))) - 1
      if (allocated(ma%mfm%mp)) then
          if (size(ma%mfm%mp) <= 2) return_value = return_value - 1
      endif
   end function fmrange_fm

   function fmrange_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma
      integer :: return_value
      intent (in) :: ma

!             The number of possible digits for type(im) integers is limited only by the amount
!             of memory that can be allocated.  Return 10**6 since there is no fixed limit.

      return_value = 10**6
      if (allocated(ma%mim%mp)) then
          if (size(ma%mim%mp) <= 2) return_value = return_value - 1
      endif
   end function fmrange_im

   function fmrange_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma
      integer :: return_value
      intent (in) :: ma
      return_value = nint((mxexp+1)*log10(dble(mbase))) - 1
      if (allocated(ma%mzm(1)%mp)) then
          if (size(ma%mzm(1)%mp) <= 2) return_value = return_value - 1
      endif
   end function fmrange_zm


!                                                                real

   function fmreal_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmeq(ma%mfm, return_value%mfm)
   end function fmreal_fm

   function fmreal_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (im) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, return_value%mfm)
   end function fmreal_im

   function fmreal_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      type (zm) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmreal(ma%mzm, return_value%mfm)
   end function fmreal_zm

!                                                           rrspacing

   function fmrrspacing_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmabs(ma%mfm, mtlvfm)
      mtlvfm%mp(2) = ndig
      call fmeq(mtlvfm, return_value%mfm)
   end function fmrrspacing_fm

!                                                               scale

   function fmscale_fm(ma, l)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      integer :: l
      intent (in) :: ma, l
      type(multi), save :: mtlvfm, mulvfm, mvlvfm, m3lvfm
      call fm_undef_inp(ma)
      call fmeq(ma%mfm, mtlvfm)
      if (abs(mtlvfm%mp(2)+l) < mxexp) then
          mtlvfm%mp(2) = mtlvfm%mp(2) + l
          call fmeq(mtlvfm, return_value%mfm)
      else
          call fmi2m(int(mbase), mulvfm)
          call fmipwr(mulvfm, l, mvlvfm)
          call fmmpy(ma%mfm, mvlvfm, m3lvfm)
          call fmeq(m3lvfm, return_value%mfm)
      endif
   end function fmscale_fm

   function fmscale_zm(ma, l)     result (return_value)
      use fmvals
      implicit none
      integer :: l
      type (zm) :: ma, return_value
      intent (in) :: ma, l
      type(multi), save :: mtlvzm(2), mulvzm(2), mvlvzm(2), m3lvzm(2)
      call fm_undef_inp(ma)
      call zmeq(ma%mzm, mtlvzm)
      if (abs(mtlvzm(1)%mp(2)+l) < mxexp .and. &
          abs(mtlvzm(2)%mp(2)+l) < mxexp) then
          mtlvzm(1)%mp(2) = mtlvzm(1)%mp(2) + l
          mtlvzm(2)%mp(2) = mtlvzm(2)%mp(2) + l
          call zmeq(mtlvzm, return_value%mzm)
      else
          call zmi2m(int(mbase), mulvzm)
          call zmipwr(mulvzm, l, mvlvzm)
          call zmmpy(ma%mzm, mvlvzm, m3lvzm)
          call zmeq(m3lvzm, return_value%mzm)
      endif
   end function fmscale_zm

!                                                         setexponent

   function fmsetexponent_fm(ma, l)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      integer :: l
      intent (in) :: ma, l
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmeq(ma%mfm, mtlvfm)
      mtlvfm%mp(2) = l
      call fmeq(mtlvfm, return_value%mfm)
   end function fmsetexponent_fm

!                                                                sign

   function fmsign_fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmsign(ma%mfm, mb%mfm, return_value%mfm)
   end function fmsign_fm

   function fmsign_im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imsign(ma%mim, mb%mim, return_value%mim)
   end function fmsign_im

 end module fmzm_8

 module fmzm_9
    use fmzm_1

   interface sin
      module procedure fmsin_fm
      module procedure fmsin_zm
      module procedure fmsin_fm1
      module procedure fmsin_zm1
      module procedure fmsin_fm2
      module procedure fmsin_zm2
   end interface

   interface sinh
      module procedure fmsinh_fm
      module procedure fmsinh_zm
      module procedure fmsinh_fm1
      module procedure fmsinh_zm1
      module procedure fmsinh_fm2
      module procedure fmsinh_zm2
   end interface

   interface spacing
      module procedure fmspacing_fm
   end interface

   interface sqrt
      module procedure fmsqrt_fm
      module procedure fmsqrt_zm
      module procedure fmsqrt_fm1
      module procedure fmsqrt_zm1
      module procedure fmsqrt_fm2
      module procedure fmsqrt_zm2
   end interface

   interface sum
      module procedure fmsum1_fm
      module procedure fmsum2_fm
      module procedure fmsum1_im
      module procedure fmsum2_im
      module procedure fmsum1_zm
      module procedure fmsum2_zm
   end interface

   interface tan
      module procedure fmtan_fm
      module procedure fmtan_zm
      module procedure fmtan_fm1
      module procedure fmtan_zm1
      module procedure fmtan_fm2
      module procedure fmtan_zm2
   end interface

   interface tanh
      module procedure fmtanh_fm
      module procedure fmtanh_zm
      module procedure fmtanh_fm1
      module procedure fmtanh_zm1
      module procedure fmtanh_fm2
      module procedure fmtanh_zm2
   end interface

   interface tiny
      module procedure fmtiny_fm
      module procedure fmtiny_im
      module procedure fmtiny_zm
   end interface

   interface transpose
      module procedure fmtranspose_fm
      module procedure fmtranspose_im
      module procedure fmtranspose_zm
   end interface

   interface fm_format
      module procedure fmformat_fm
   end interface

   interface im_format
      module procedure imformat_im
   end interface

   interface zm_format
      module procedure zmformat_zm
   end interface

   interface gcd
      module procedure gcd_im
   end interface

   interface multiply_mod
      module procedure multiplymod_im
   end interface

   interface power_mod
      module procedure powermod_im
   end interface

   interface bernoulli
      module procedure fmbernoulli_fm
   end interface

   interface beta
      module procedure fmbeta_fm
   end interface

   interface binomial
      module procedure fmbinomial_fm
      module procedure fmbinomial_im
      module procedure fmbinomial_i
      module procedure fmbinomial_zm
   end interface

   interface factorial
      module procedure fmfactorial_fm
      module procedure fmfactorial_fm1
      module procedure fmfactorial_fm2
      module procedure fmfactorial_im
      module procedure fmfactorial_im1
      module procedure fmfactorial_im2
      module procedure fmfactorial_zm
      module procedure fmfactorial_zm1
      module procedure fmfactorial_zm2
      module procedure fmfactorial_i
      module procedure fmfactorial_i1
      module procedure fmfactorial_i2
   end interface

   interface gamma
      module procedure fmgamma_fm
      module procedure fmgamma_fm1
      module procedure fmgamma_fm2
      module procedure fmgamma_zm
      module procedure fmgamma_zm1
      module procedure fmgamma_zm2
   end interface

   interface incomplete_beta
      module procedure fmincomplete_beta_fm
   end interface

   interface incomplete_gamma1
      module procedure fmincomplete_gamma1_fm
   end interface

   interface incomplete_gamma2
      module procedure fmincomplete_gamma2_fm
   end interface

   interface log_gamma
      module procedure fmlog_gamma_fm
      module procedure fmlog_gamma_fm1
      module procedure fmlog_gamma_fm2
      module procedure fmlog_gamma_zm
      module procedure fmlog_gamma_zm1
      module procedure fmlog_gamma_zm2
   end interface

   interface polygamma
      module procedure fmpolygamma_fm
      module procedure fmpolygamma_zm
   end interface

   interface pochhammer
      module procedure fmpochhammer_fm
   end interface

   interface psi
      module procedure fmpsi_fm
      module procedure fmpsi_fm1
      module procedure fmpsi_fm2
      module procedure fmpsi_zm
      module procedure fmpsi_zm1
      module procedure fmpsi_zm2
   end interface

   interface bessel_j
      module procedure fmbessel_j_fm
   end interface

   interface bessel_j0
      module procedure fmbessel_j0_fm
   end interface

   interface bessel_j1
      module procedure fmbessel_j1_fm
   end interface

   interface bessel_jn
      module procedure fmbessel_jn_fm
      module procedure fmbessel_jn2_fm
   end interface

   interface bessel_y
      module procedure fmbessel_y_fm
   end interface

   interface bessel_y0
      module procedure fmbessel_y0_fm
   end interface

   interface bessel_y1
      module procedure fmbessel_y1_fm
   end interface

   interface bessel_yn
      module procedure fmbessel_yn_fm
      module procedure fmbessel_yn2_fm
   end interface

   interface cos_integral
      module procedure fmcos_integral_fm
      module procedure fmcos_integral_fm1
      module procedure fmcos_integral_fm2
   end interface

   interface cosh_integral
      module procedure fmcosh_integral_fm
      module procedure fmcosh_integral_fm1
      module procedure fmcosh_integral_fm2
   end interface

   interface exp_integral_ei
      module procedure fmexp_integral_ei_fm
      module procedure fmexp_integral_ei_fm1
      module procedure fmexp_integral_ei_fm2
   end interface

   interface exp_integral_en
      module procedure fmexp_integral_en_fm
   end interface

   interface fresnel_c
      module procedure fmfresnel_c_fm
      module procedure fmfresnel_c_fm1
      module procedure fmfresnel_c_fm2
   end interface

   interface fresnel_s
      module procedure fmfresnel_s_fm
      module procedure fmfresnel_s_fm1
      module procedure fmfresnel_s_fm2
   end interface

   interface erf
      module procedure fmerf_fm
      module procedure fmerf_fm1
      module procedure fmerf_fm2
      module procedure fmerf_zm
      module procedure fmerf_zm1
      module procedure fmerf_zm2
   end interface

   interface erfc
      module procedure fmerfc_fm
      module procedure fmerfc_fm1
      module procedure fmerfc_fm2
      module procedure fmerfc_zm
      module procedure fmerfc_zm1
      module procedure fmerfc_zm2
   end interface

   interface erfc_scaled
      module procedure fmerfc_scaled_fm
      module procedure fmerfc_scaled_fm1
      module procedure fmerfc_scaled_fm2
      module procedure fmerfc_scaled_zm
      module procedure fmerfc_scaled_zm1
      module procedure fmerfc_scaled_zm2
   end interface

   interface log_erfc
      module procedure fmlog_erfc_fm
      module procedure fmlog_erfc_fm1
      module procedure fmlog_erfc_fm2
   end interface

   interface log_integral
      module procedure fmlog_integral_fm
      module procedure fmlog_integral_fm1
      module procedure fmlog_integral_fm2
   end interface

   interface sin_integral
      module procedure fmsin_integral_fm
      module procedure fmsin_integral_fm1
      module procedure fmsin_integral_fm2
   end interface

   interface sinh_integral
      module procedure fmsinh_integral_fm
      module procedure fmsinh_integral_fm1
      module procedure fmsinh_integral_fm2
   end interface

 contains

!                                                                 sin

   function fmsin_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmsin(ma%mfm, return_value%mfm)
   end function fmsin_fm

   function fmsin_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmsin(ma%mzm, return_value%mzm)
   end function fmsin_zm

   function fmsin_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmsin(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmsin_fm1

   function fmsin_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmsin(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmsin_zm1

   function fmsin_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsin(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsin_fm2

   function fmsin_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsin(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsin_zm2

!                                                                sinh

   function fmsinh_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmsinh(ma%mfm, return_value%mfm)
   end function fmsinh_fm

   function fmsinh_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmsinh(ma%mzm, return_value%mzm)
   end function fmsinh_zm

   function fmsinh_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmsinh(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmsinh_fm1

   function fmsinh_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmsinh(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmsinh_zm1

   function fmsinh_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsinh(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsinh_fm2

   function fmsinh_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsinh(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsinh_zm2

!                                                             spacing

   function fmspacing_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      integer :: kwrnsv
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmabs(ma%mfm, mtlvfm)
      if (mtlvfm%mp(3) /= 0) then
          kwrnsv = kwarn
          kwarn = 0
          call fmulp(mtlvfm, return_value%mfm)
          kwarn = kwrnsv
          if (mtlvfm%mp(2) <= -mxexp) then
              call fmtiny(return_value%mfm)
          endif
      else
          call fmtiny(return_value%mfm)
      endif
   end function fmspacing_fm

!                                                                sqrt

   function fmsqrt_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmsqrt(ma%mfm, return_value%mfm)
   end function fmsqrt_fm

   function fmsqrt_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmsqrt(ma%mzm, return_value%mzm)
   end function fmsqrt_zm

   function fmsqrt_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmsqrt(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmsqrt_fm1

   function fmsqrt_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmsqrt(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmsqrt_zm1

   function fmsqrt_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsqrt(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsqrt_fm2

   function fmsqrt_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmsqrt(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmsqrt_zm2

!                                                                 sum

   function fmsum1_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma(:), return_value
      integer :: j, ja, mxsave, nd2, ndsave
      intent (in) :: ma
      type(multi), save :: mulvfm, m3lvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      j = max(ngrd52, 2)
      nd2 = max(2*ndig+j, 3)
      ndig = nd2
      mxsave = mxexp
      mxexp = mxexp2
      call fmi2m(0, m3lvfm)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         call fmequ(ma(ja)%mfm, mulvfm, ndsave, ndig)
         call fmadd_r1(m3lvfm, mulvfm)
      enddo
      mxexp = mxsave
      call fmequ(m3lvfm, return_value%mfm, ndig, ndsave)
      ndig = ndsave
   end function fmsum1_fm

   function fmsum2_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma(:,:), return_value
      integer :: j, k, ja, jb, mxsave, nd2, ndsave
      intent (in) :: ma
      type(multi), save :: mulvfm, m3lvfm
      call fm_undef_inp(ma)
      ndsave = ndig
      j = max(ngrd52, 2)
      nd2 = max(2*ndig+j, 3)
      ndig = nd2
      mxsave = mxexp
      mxexp = mxexp2
      call fmi2m(0, m3lvfm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            call fmequ(ma(ja, jb)%mfm, mulvfm, ndsave, ndig)
            call fmadd_r1(m3lvfm, mulvfm)
         enddo
      enddo
      mxexp = mxsave
      call fmequ(m3lvfm, return_value%mfm, ndig, ndsave)
      ndig = ndsave
   end function fmsum2_fm

   function fmsum1_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma(:), return_value
      integer :: j, ja
      intent (in) :: ma
      type(multi), save :: mtlvim, m3lvim
      call fm_undef_inp(ma)
      call imi2m(0, m3lvim)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         call imadd(ma(ja)%mim, m3lvim, mtlvim)
         call imeq(mtlvim, m3lvim)
      enddo
      call imeq(m3lvim, return_value%mim)
   end function fmsum1_im

   function fmsum2_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma(:,:), return_value
      integer :: j, k, ja, jb
      intent (in) :: ma
      type(multi), save :: mtlvim, m3lvim
      call fm_undef_inp(ma)
      call imi2m(0, m3lvim)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            call imadd(ma(ja, jb)%mim, m3lvim, mtlvim)
            call imeq(mtlvim, m3lvim)
         enddo
      enddo
      call imeq(m3lvim, return_value%mim)
   end function fmsum2_im

   function fmsum1_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma(:), return_value
      integer :: j, ja, mxsave, nd2, ndsave
      intent (in) :: ma
      type(multi), save :: mtlvzm(2), mulvzm(2), m3lvzm(2)
      call fm_undef_inp(ma)
      ndsave = ndig
      j = max(ngrd52, 2)
      nd2 = max(2*ndig+j, 3)
      ndig = nd2
      mxsave = mxexp
      mxexp = mxexp2
      call zmi2m(0, m3lvzm)
      do j = 1, size(ma)
         ja = lbound(ma, dim=1) + j - 1
         call zmequ(ma(ja)%mzm, mulvzm, ndsave, ndig)
         call zmadd(mulvzm, m3lvzm, mtlvzm)
         call zmeq(mtlvzm, m3lvzm)
      enddo
      mxexp = mxsave
      call zmequ(m3lvzm, return_value%mzm, ndig, ndsave)
      ndig = ndsave
   end function fmsum1_zm

   function fmsum2_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma(:,:), return_value
      integer :: j, k, ja, jb, mxsave, nd2, ndsave
      intent (in) :: ma
      type(multi), save :: mtlvzm(2), mulvzm(2), m3lvzm(2)
      call fm_undef_inp(ma)
      ndsave = ndig
      j = max(ngrd52, 2)
      nd2 = max(2*ndig+j, 3)
      ndig = nd2
      mxsave = mxexp
      mxexp = mxexp2
      call zmi2m(0, m3lvzm)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            ja = lbound(ma, dim=1) + j - 1
            jb = lbound(ma, dim=2) + k - 1
            call zmequ(ma(ja, jb)%mzm, mulvzm, ndsave, ndig)
            call zmadd(mulvzm, m3lvzm, mtlvzm)
            call zmeq(mtlvzm, m3lvzm)
         enddo
      enddo
      mxexp = mxsave
      call zmequ(m3lvzm, return_value%mzm, ndig, ndsave)
      ndig = ndsave
   end function fmsum2_zm

!                                                                 tan

   function fmtan_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmtan(ma%mfm, return_value%mfm)
   end function fmtan_fm

   function fmtan_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmtan(ma%mzm, return_value%mzm)
   end function fmtan_zm

   function fmtan_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmtan(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmtan_fm1

   function fmtan_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmtan(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmtan_zm1

   function fmtan_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmtan(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmtan_fm2

   function fmtan_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmtan(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmtan_zm2

!                                                                tanh

   function fmtanh_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmtanh(ma%mfm, return_value%mfm)
   end function fmtanh_fm

   function fmtanh_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmtanh(ma%mzm, return_value%mzm)
   end function fmtanh_zm

   function fmtanh_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmtanh(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmtanh_fm1

   function fmtanh_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmtanh(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmtanh_zm1

   function fmtanh_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmtanh(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmtanh_fm2

   function fmtanh_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmtanh(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmtanh_zm2

!                                                                tiny

   function fmtiny_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fmtiny(return_value%mfm)
      if (allocated(ma%mfm%mp)) then
          if (size(ma%mfm%mp) <= 2) call fmmpyi_r1(return_value%mfm, 1)
      endif
   end function fmtiny_fm

   function fmtiny_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, return_value
      intent (in) :: ma
      type(multi), save :: mtlvim
      call imi2m(1, return_value%mim)
      if (allocated(ma%mim%mp)) then
          if (size(ma%mim%mp) <= 2) call immpyi(return_value%mim, 1, mtlvim)
      endif
   end function fmtiny_im

   function fmtiny_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      type(multi), save :: mtlvfm, mtlvzm(2)
      call fmtiny(mtlvfm)
      call zmcmpx(mtlvfm, mtlvfm, return_value%mzm)
      if (allocated(ma%mzm(1)%mp)) then
          if (size(ma%mzm(1)%mp) <= 2) call zmmpyi(return_value%mzm, 1, mtlvzm)
      endif
   end function fmtiny_zm

!                                                           transpose

   function fmtranspose_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma(:,:)
      type (fm), dimension(size(ma, dim=2), size(ma, dim=1)) :: return_value
      integer :: i, j
      intent (in) :: ma
      call fm_undef_inp(ma)
      do i = 1, size(ma, dim=1)
         do j = 1, size(ma, dim=2)
            call fmeq(ma(i, j)%mfm, return_value(j, i)%mfm)
         enddo
      enddo
   end function fmtranspose_fm

   function fmtranspose_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma(:,:)
      type (im), dimension(size(ma, dim=2), size(ma, dim=1)) :: return_value
      integer :: i, j
      intent (in) :: ma
      call fm_undef_inp(ma)
      do i = 1, size(ma, dim=1)
         do j = 1, size(ma, dim=2)
            call imeq(ma(i, j)%mim, return_value(j, i)%mim)
         enddo
      enddo
   end function fmtranspose_im

   function fmtranspose_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma(:,:)
      type (zm), dimension(size(ma, dim=2), size(ma, dim=1)) :: return_value
      integer :: i, j
      intent (in) :: ma
      call fm_undef_inp(ma)
      do i = 1, size(ma, dim=1)
         do j = 1, size(ma, dim=2)
            call zmeq(ma(i, j)%mzm, return_value(j, i)%mzm)
         enddo
      enddo
   end function fmtranspose_zm

!                                                           fm_format

   function fmformat_fm(fmt, ma)     result (return_value)
      use fmvals
      implicit none
      character(*) :: fmt
      type (fm) :: ma
      character(200) :: return_value
      intent (in) :: fmt, ma
      call fm_undef_inp(ma)
      call fmform(fmt, ma%mfm, return_value)
   end function fmformat_fm

!                                                           im_format

   function imformat_im(fmt, ma)     result (return_value)
      use fmvals
      implicit none
      character(*) :: fmt
      character(200) :: return_value
      type (im) :: ma
      intent (in) :: fmt, ma
      call fm_undef_inp(ma)
      call imform(fmt, ma%mim, return_value)
   end function imformat_im

!                                                           zm_format

   function zmformat_zm(fmtr, fmti, ma)     result (return_value)
      use fmvals
      implicit none
      character(*) :: fmtr, fmti
      character(200) :: return_value
      type (zm) :: ma
      intent (in) :: fmtr, fmti, ma
      call fm_undef_inp(ma)
      call zmform(fmtr, fmti, ma%mzm, return_value)
   end function zmformat_zm

!                                                                 gcd

   function gcd_im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imgcd(ma%mim, mb%mim, return_value%mim)
   end function gcd_im

!                                                        multiply_mod

   function multiplymod_im(ma, mb, mc)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, mb, mc, return_value
      intent (in) :: ma, mb, mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fm_undef_inp(mc)
      call immpym(ma%mim, mb%mim, mc%mim, return_value%mim)
   end function multiplymod_im

!                                                           power_mod

   function powermod_im(ma, mb, mc)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, mb, mc, return_value
      intent (in) :: ma, mb, mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fm_undef_inp(mc)
      call impmod(ma%mim, mb%mim, mc%mim, return_value%mim)
   end function powermod_im

!                                                           bernoulli

   function fmbernoulli_fm(n)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: return_value
      integer :: n
      intent (in) :: n
      call fmbernoulli(n, return_value%mfm)
   end function fmbernoulli_fm

!                                                                beta

   function fmbeta_fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmbeta(ma%mfm, mb%mfm, return_value%mfm)
   end function fmbeta_fm

!                                                            binomial

   function fmbinomial_fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmcomb(ma%mfm, mb%mfm, return_value%mfm)
   end function fmbinomial_fm

   function fmbinomial_im(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imcomb(ma%mim, mb%mim, return_value%mim)
   end function fmbinomial_im

   function fmbinomial_i(n, k)     result (return_value)
      use fmvals
      implicit none
      integer :: n, k
      type (im) :: return_value
      intent (in) :: n, k
      call imcombi(n, k, return_value%mim)
   end function fmbinomial_i

   function fmbinomial_zm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmcomb(ma%mzm, mb%mzm, return_value%mzm)
   end function fmbinomial_zm

!                                                           factorial

   function fmfactorial_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmfact(ma%mfm, return_value%mfm)
   end function fmfactorial_fm

   function fmfactorial_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmfact(ma%mzm, return_value%mzm)
   end function fmfactorial_zm

   function fmfactorial_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmfact(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmfactorial_fm1

   function fmfactorial_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmfact(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmfactorial_zm1

   function fmfactorial_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmfact(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmfactorial_fm2

   function fmfactorial_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmfact(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmfactorial_zm2

   function fmfactorial_im(ma)     result (return_value)
      use fmvals
      implicit none
      type (im) :: ma, return_value
      intent (in) :: ma
      integer :: ival
      call fm_undef_inp(ma)
      call imm2i(ma%mim, ival)
      if (kflag == 0) then
          call imfact(ival, return_value%mim)
      else
          call imunknown(return_value%mim)
          kflag = 0
      endif
   end function fmfactorial_im

   function fmfactorial_im1(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:) :: ma
      type (im), dimension(size(ma)) :: return_value
      integer :: ival, j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call imm2i(ma(j)%mim, ival)
         if (kflag == 0) then
             call imfact(ival, return_value(j)%mim)
         else
             call imunknown(return_value(j)%mim)
             kflag = 0
         endif
      enddo
   end function fmfactorial_im1

   function fmfactorial_im2(ma)     result (return_value)
      use fmvals
      implicit none
      type (im), dimension(:,:) :: ma
      type (im), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: ival, j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call imm2i(ma(j, k)%mim, ival)
            if (kflag == 0) then
                call imfact(ival, return_value(j, k)%mim)
            else
                call imst2m(' UNKNOWN ', return_value(j, k)%mim)
                kflag = 0
            endif
         enddo
      enddo
   end function fmfactorial_im2

   function fmfactorial_i(ival)     result (return_value)
      use fmvals
      implicit none
      type (im) :: return_value
      integer :: ival
      intent (in) :: ival
      call imfact(ival, return_value%mim)
   end function fmfactorial_i

   function fmfactorial_i1(ival)     result (return_value)
      use fmvals
      implicit none
      integer, dimension(:) :: ival
      type (im), dimension(size(ival)) :: return_value
      integer :: j, n
      intent (in) :: ival
      n = size(ival)
      do j = 1, n
         call imfact(ival(j), return_value(j)%mim)
      enddo
   end function fmfactorial_i1

   function fmfactorial_i2(ival)     result (return_value)
      use fmvals
      implicit none
      integer, dimension(:,:) :: ival
      type (im), dimension(size(ival, dim=1), size(ival, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ival
      do j = 1, size(ival, dim=1)
         do k = 1, size(ival, dim=2)
            call imfact(ival(j, k), return_value(j, k)%mim)
         enddo
      enddo
   end function fmfactorial_i2

!                                                               gamma

   function fmgamma_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmgam(ma%mfm, return_value%mfm)
   end function fmgamma_fm

   function fmgamma_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmgam(ma%mzm, return_value%mzm)
   end function fmgamma_zm

   function fmgamma_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmgam(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmgamma_fm1

   function fmgamma_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmgam(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmgamma_zm1

   function fmgamma_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmgam(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmgamma_fm2

   function fmgamma_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmgam(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmgamma_zm2

!                                                     incomplete_beta

   function fmincomplete_beta_fm(mx, ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: mx, ma, mb, return_value
      intent (in) :: mx, ma, mb
      call fm_undef_inp(mx)
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmibta(mx%mfm, ma%mfm, mb%mfm, return_value%mfm)
   end function fmincomplete_beta_fm

!                                                   incomplete_gamma1

   function fmincomplete_gamma1_fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmigm1(ma%mfm, mb%mfm, return_value%mfm)
   end function fmincomplete_gamma1_fm

!                                                   incomplete_gamma2

   function fmincomplete_gamma2_fm(ma, mb)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, mb, return_value
      intent (in) :: ma, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmigm2(ma%mfm, mb%mfm, return_value%mfm)
   end function fmincomplete_gamma2_fm

!                                                           log_gamma

   function fmlog_gamma_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmlngm(ma%mfm, return_value%mfm)
   end function fmlog_gamma_fm

   function fmlog_gamma_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmlngm(ma%mzm, return_value%mzm)
   end function fmlog_gamma_zm

   function fmlog_gamma_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmlngm(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmlog_gamma_fm1

   function fmlog_gamma_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmlngm(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmlog_gamma_zm1

   function fmlog_gamma_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmlngm(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmlog_gamma_fm2

   function fmlog_gamma_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmlngm(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmlog_gamma_zm2

!                                                           polygamma

   function fmpolygamma_fm(n, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      integer :: n
      intent (in) :: n, ma
      call fm_undef_inp(ma)
      call fmpgam(n, ma%mfm, return_value%mfm)
   end function fmpolygamma_fm

   function fmpolygamma_zm(n, ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      integer :: n
      intent (in) :: n, ma
      call fm_undef_inp(ma)
      call zmpgam(n, ma%mzm, return_value%mzm)
   end function fmpolygamma_zm

!                                                          pochhammer

   function fmpochhammer_fm(ma, n)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      integer :: n
      intent (in) :: n, ma
      call fm_undef_inp(ma)
      call fmpoch(ma%mfm, n, return_value%mfm)
   end function fmpochhammer_fm

!                                                                 psi

   function fmpsi_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmpsi(ma%mfm, return_value%mfm)
   end function fmpsi_fm

   function fmpsi_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmpsi(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmpsi_fm1

   function fmpsi_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmpsi(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmpsi_fm2

   function fmpsi_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmpsi(ma%mzm, return_value%mzm)
   end function fmpsi_zm

   function fmpsi_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmpsi(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmpsi_zm1

   function fmpsi_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmpsi(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmpsi_zm2

!                                                            bessel_j

   function fmbessel_j_fm(n, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      integer :: n
      intent (in) :: n, ma
      call fm_undef_inp(ma)
      call fmbesj(n, ma%mfm, return_value%mfm)
   end function fmbessel_j_fm

!                                                            bessel_j0

   function fmbessel_j0_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmbesj(0, ma%mfm, return_value%mfm)
   end function fmbessel_j0_fm

!                                                            bessel_j1

   function fmbessel_j1_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmbesj(1, ma%mfm, return_value%mfm)
   end function fmbessel_j1_fm

!                                                            bessel_jn

   function fmbessel_jn_fm(n, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      integer :: n
      intent (in) :: n, ma
      call fm_undef_inp(ma)
      call fmbesj(n, ma%mfm, return_value%mfm)
   end function fmbessel_jn_fm

!                                                            bessel_jn2

   function fmbessel_jn2_fm(n1, n2, ma)     result (return_value)
      use fmvals
      implicit none
      integer :: n1, n2, j
      type (fm) :: ma, return_value(abs(n2-n1)+1)
      type(multi), allocatable :: a(:)
      intent (in) :: n1, n2, ma
      call fm_undef_inp(ma)
      allocate(a(abs(n2-n1)+1))
      call fmbesj2(n1, n2, ma%mfm, a)
      do j = 1, abs(n2-n1)+1
         call fmeq(a(j), return_value(j)%mfm)
      enddo
      deallocate(a)
   end function fmbessel_jn2_fm

!                                                            bessel_y

   function fmbessel_y_fm(n, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      integer :: n
      intent (in) :: n, ma
      call fm_undef_inp(ma)
      call fmbesy(n, ma%mfm, return_value%mfm)
   end function fmbessel_y_fm

!                                                            bessel_y0

   function fmbessel_y0_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmbesy(0, ma%mfm, return_value%mfm)
   end function fmbessel_y0_fm

!                                                            bessel_y1

   function fmbessel_y1_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmbesy(1, ma%mfm, return_value%mfm)
   end function fmbessel_y1_fm

!                                                            bessel_yn

   function fmbessel_yn_fm(n, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      integer :: n
      intent (in) :: n, ma
      call fm_undef_inp(ma)
      call fmbesy(n, ma%mfm, return_value%mfm)
   end function fmbessel_yn_fm

!                                                            bessel_yn2

   function fmbessel_yn2_fm(n1, n2, ma)     result (return_value)
      use fmvals
      implicit none
      integer :: n1, n2, j
      type (fm) :: ma, return_value(abs(n2-n1)+1)
      type(multi), allocatable :: a(:)
      intent (in) :: n1, n2, ma
      call fm_undef_inp(ma)
      allocate(a(abs(n2-n1)+1))
      call fmbesy2(n1, n2, ma%mfm, a)
      do j = 1, abs(n2-n1)+1
         call fmeq(a(j), return_value(j)%mfm)
      enddo
      deallocate(a)
   end function fmbessel_yn2_fm

!                                                        cos_integral

   function fmcos_integral_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmci(ma%mfm, return_value%mfm)
   end function fmcos_integral_fm

   function fmcos_integral_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmci(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmcos_integral_fm1

   function fmcos_integral_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmci(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmcos_integral_fm2

!                                                       cosh_integral

   function fmcosh_integral_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmchi(ma%mfm, return_value%mfm)
   end function fmcosh_integral_fm

   function fmcosh_integral_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmchi(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmcosh_integral_fm1

   function fmcosh_integral_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmchi(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmcosh_integral_fm2

!                                                     exp_integral_ei

   function fmexp_integral_ei_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmei(ma%mfm, return_value%mfm)
   end function fmexp_integral_ei_fm

   function fmexp_integral_ei_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmei(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmexp_integral_ei_fm1

   function fmexp_integral_ei_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmei(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmexp_integral_ei_fm2

!                                                     exp_integral_en

   function fmexp_integral_en_fm(n, ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      integer :: n
      intent (in) :: n, ma
      call fm_undef_inp(ma)
      call fmen(n, ma%mfm, return_value%mfm)
   end function fmexp_integral_en_fm

!                                                           fresnel_c

   function fmfresnel_c_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmc(ma%mfm, return_value%mfm)
   end function fmfresnel_c_fm

   function fmfresnel_c_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmc(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmfresnel_c_fm1

   function fmfresnel_c_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmc(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmfresnel_c_fm2

!                                                           fresnel_s

   function fmfresnel_s_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fms(ma%mfm, return_value%mfm)
   end function fmfresnel_s_fm

   function fmfresnel_s_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fms(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmfresnel_s_fm1

   function fmfresnel_s_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fms(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmfresnel_s_fm2

!                                                                 erf

   function fmerf_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmerf(ma%mfm, return_value%mfm)
   end function fmerf_fm

   function fmerf_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmerf(ma%mzm, return_value%mzm)
   end function fmerf_zm

   function fmerf_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmerf(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmerf_fm1

   function fmerf_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmerf(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmerf_zm1

   function fmerf_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmerf(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmerf_fm2

   function fmerf_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmerf(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmerf_zm2

!                                                                erfc

   function fmerfc_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmerfc(ma%mfm, return_value%mfm)
   end function fmerfc_fm

   function fmerfc_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmerfc(ma%mzm, return_value%mzm)
   end function fmerfc_zm

   function fmerfc_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmerfc(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmerfc_fm1

   function fmerfc_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmerfc(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmerfc_zm1

   function fmerfc_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmerfc(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmerfc_fm2

   function fmerfc_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmerfc(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmerfc_zm2

!                                                                erfc_scaled

   function fmerfc_scaled_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmerfcs(ma%mfm, return_value%mfm)
   end function fmerfc_scaled_fm

   function fmerfc_scaled_zm(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmerfcs(ma%mzm, return_value%mzm)
   end function fmerfc_scaled_zm

   function fmerfc_scaled_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmerfcs(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmerfc_scaled_fm1

   function fmerfc_scaled_zm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:) :: ma
      type (zm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call zmerfcs(ma(j)%mzm, return_value(j)%mzm)
      enddo
   end function fmerfc_scaled_zm1

   function fmerfc_scaled_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmerfcs(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmerfc_scaled_fm2

   function fmerfc_scaled_zm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (zm), dimension(:,:) :: ma
      type (zm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call zmerfcs(ma(j, k)%mzm, return_value(j, k)%mzm)
         enddo
      enddo
   end function fmerfc_scaled_zm2

!                                                            log_erfc

   function fmlog_erfc_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmlerc(ma%mfm, return_value%mfm)
   end function fmlog_erfc_fm

   function fmlog_erfc_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmlerc(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmlog_erfc_fm1

   function fmlog_erfc_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmlerc(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmlog_erfc_fm2

!                                                        log_integral

   function fmlog_integral_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmli(ma%mfm, return_value%mfm)
   end function fmlog_integral_fm

   function fmlog_integral_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmli(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmlog_integral_fm1

   function fmlog_integral_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmli(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmlog_integral_fm2

!                                                        sin_integral

   function fmsin_integral_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmsi(ma%mfm, return_value%mfm)
   end function fmsin_integral_fm

   function fmsin_integral_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmsi(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmsin_integral_fm1

   function fmsin_integral_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmsi(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsin_integral_fm2

!                                                       sinh_integral

   function fmsinh_integral_fm(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm) :: ma, return_value
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmshi(ma%mfm, return_value%mfm)
   end function fmsinh_integral_fm

   function fmsinh_integral_fm1(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:) :: ma
      type (fm), dimension(size(ma)) :: return_value
      integer :: j, n
      intent (in) :: ma
      call fm_undef_inp(ma)
      n = size(ma)
      do j = 1, n
         call fmshi(ma(j)%mfm, return_value(j)%mfm)
      enddo
   end function fmsinh_integral_fm1

   function fmsinh_integral_fm2(ma)     result (return_value)
      use fmvals
      implicit none
      type (fm), dimension(:,:) :: ma
      type (fm), dimension(size(ma, dim=1), size(ma, dim=2)) :: return_value
      integer :: j, k
      intent (in) :: ma
      call fm_undef_inp(ma)
      do j = 1, size(ma, dim=1)
         do k = 1, size(ma, dim=2)
            call fmshi(ma(j, k)%mfm, return_value(j, k)%mfm)
         enddo
      enddo
   end function fmsinh_integral_fm2

 end module fmzm_9

 module fmzm_10
   use fmzm_1

   contains

! Interface routines for calling with the FM, IM, and ZM derived types.

   subroutine fm_abs(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmabs(ma%mfm, mb%mfm)
   end subroutine fm_abs

   subroutine fm_acos(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmacos(ma%mfm, mb%mfm)
   end subroutine fm_acos

   subroutine fm_acosh(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmacosh(ma%mfm, mb%mfm)
   end subroutine fm_acosh

   subroutine fm_add(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmadd(ma%mfm, mb%mfm, mc%mfm)
   end subroutine fm_add

   subroutine fm_add_r1(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: mb
      intent (inout) :: ma
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmadd_r1(ma%mfm, mb%mfm)
   end subroutine fm_add_r1

   subroutine fm_add_r2(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmadd_r2(ma%mfm, mb%mfm)
   end subroutine fm_add_r2

   subroutine fm_addi(ma, ival)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      integer :: ival
      intent (in) :: ival
      call fm_undef_inp(ma)
      call fmaddi(ma%mfm, ival)
   end subroutine fm_addi

   subroutine fm_asin(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmasin(ma%mfm, mb%mfm)
   end subroutine fm_asin

   subroutine fm_asinh(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmasinh(ma%mfm, mb%mfm)
   end subroutine fm_asinh

   subroutine fm_atan(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmatan(ma%mfm, mb%mfm)
   end subroutine fm_atan

   subroutine fm_atanh(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmatanh(ma%mfm, mb%mfm)
   end subroutine fm_atanh

   subroutine fm_atn2(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmatn2(ma%mfm, mb%mfm, mc%mfm)
   end subroutine fm_atn2

   subroutine fm_big(ma)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      call fmbig(ma%mfm)
   end subroutine fm_big

   subroutine fm_ceiling(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmint(ma%mfm, mtlvfm)
      call fmsub(ma%mfm, mtlvfm, mulvfm)
      if (mulvfm%mp(3) == 0) then
          call fmeq(ma%mfm, mb%mfm)
      else if (ma%mfm%mp(1) > 0) then
          call fmaddi(mtlvfm, 1)
          call fmeq(mtlvfm, mb%mfm)
      else
          call fmeq(mtlvfm, mb%mfm)
      endif
   end subroutine fm_ceiling

   subroutine fm_changebase(ma, mb, new_mbase, new_ndig)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      integer :: new_mbase, new_ndig
      intent (in) :: ma, new_mbase, new_ndig
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmchangebase(ma%mfm, mb%mfm, new_mbase, new_ndig)
   end subroutine fm_changebase

   subroutine fm_chsh(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      call fm_undef_inp(ma)
      call fmchsh(ma%mfm, mb%mfm, mc%mfm)
   end subroutine fm_chsh

   function fm_comp(ma, lrel, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      type (fm) :: ma, mb
      intent (in) :: ma, mb
      character(*) :: lrel
      intent (in) :: lrel
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      return_value = fmcomp(ma%mfm, lrel, mb%mfm)
   end function fm_comp

   subroutine fm_cos(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmcos(ma%mfm, mb%mfm)
   end subroutine fm_cos

   subroutine fm_cosh(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmcosh(ma%mfm, mb%mfm)
   end subroutine fm_cosh

   subroutine fm_cssn(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      call fm_undef_inp(ma)
      call fmcssn(ma%mfm, mb%mfm, mc%mfm)
   end subroutine fm_cssn

   subroutine fm_dim(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmdim(ma%mfm, mb%mfm, mc%mfm)
   end subroutine fm_dim

   subroutine fm_div(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmdiv(ma%mfm, mb%mfm, mc%mfm)
   end subroutine fm_div

   subroutine fm_div_r1(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: mb
      intent (inout) :: ma
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmdiv_r1(ma%mfm, mb%mfm)
   end subroutine fm_div_r1

   subroutine fm_div_r2(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmdiv_r2(ma%mfm, mb%mfm)
   end subroutine fm_div_r2

   subroutine fm_divi(ma, ival, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival
      intent (in) :: ival
      call fm_undef_inp(ma)
      call fmdivi(ma%mfm, ival, mb%mfm)
   end subroutine fm_divi

   subroutine fm_divi_r1(ma, ival)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      integer :: ival
      intent (in) :: ival
      call fm_undef_inp(ma)
      call fmdivi_r1(ma%mfm, ival)
   end subroutine fm_divi_r1

   subroutine fm_dp2m(x, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      double precision :: x
      intent (in) :: x
      call fmdp2m(x, ma%mfm)
   end subroutine fm_dp2m

   subroutine fm_dpm(x, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      double precision :: x
      intent (in) :: x
      call fmdpm(x, ma%mfm)
   end subroutine fm_dpm

   subroutine fm_epsilon(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(multi), save :: mtlvfm
      call fmi2m(1, mtlvfm)
      call fmulp(mtlvfm, mb%mfm)
      if (allocated(ma%mfm%mp)) then
          if (size(ma%mfm%mp) <= 2) call fmmpyi(mb%mfm, 1, mtlvfm)
      endif
   end subroutine fm_epsilon

   subroutine fm_equ(ma, mb, na, nb)

!  Set mb (having nb digits) equal to ma (having na digits).

!  If mb has less precision than ma the result is rounded to nb digits.

!  If mb has more precision the result has zero digits padded on the right, and will have
!  its size increased if needed.

      use fmvals
      implicit none
      integer :: ka, kb, na, nb, ndsave
      intent (in) :: na, nb
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      ka = na
      kb = nb
      ndsave = ndig
      ndig = ka
      call fmequ(ma%mfm, mb%mfm, ka, kb)
      ndig = ndsave
   end subroutine fm_equ

   subroutine fm_equ_r1(ma, na, nb)

!  Change precision of ma from na digits on input to nb digits on output.

!  If mb has less precision than ma the result is rounded to nb digits.

!  If nb is greater than na the result has zero digits padded on the right, and will have
!  its size increased if needed.

      use fmvals
      implicit none
      integer :: ka, kb, na, nb, ndsave
      intent (in) :: na, nb
      type (fm) :: ma
      intent (inout) :: ma
      call fm_undef_inp(ma)
      ka = na
      kb = nb
      ndsave = ndig
      ndig = ka
      call fmequ_r1(ma%mfm, ka, kb)
      ndig = ndsave
   end subroutine fm_equ_r1

   subroutine fm_exp(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmexp(ma%mfm, mb%mfm)
   end subroutine fm_exp

   subroutine fm_flag(k)
      use fmvals
      implicit none
      integer :: k
      intent (inout) :: k
      call fmflag(k)
   end subroutine fm_flag

   subroutine fm_form(form, ma, string)
      use fmvals
      implicit none
      character(*) :: form, string
      intent (in) :: form
      intent (inout) :: string
      type (fm) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmform(form, ma%mfm, string)
   end subroutine fm_form

   subroutine fm_floor(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(multi), save :: mtlvfm, mulvfm
      call fm_undef_inp(ma)
      call fmint(ma%mfm, mtlvfm)
      call fmsub(ma%mfm, mtlvfm, mulvfm)
      if (mulvfm%mp(3) == 0) then
          call fmeq(ma%mfm, mb%mfm)
      else if (ma%mfm%mp(1) < 0) then
          call fmaddi(mtlvfm, -1)
          call fmeq(mtlvfm, mb%mfm)
      else
          call fmeq(mtlvfm, mb%mfm)
      endif
   end subroutine fm_floor

   subroutine fm_fprt(form, ma)
      use fmvals
      implicit none
      character(*) :: form
      intent (in) :: form
      type (fm) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmfprt(form, ma%mfm)
   end subroutine fm_fprt

   subroutine fm_fraction(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmeq(ma%mfm, mtlvfm)
      mtlvfm%mp(2) = 0
      call fmeq(mtlvfm, mb%mfm)
   end subroutine fm_fraction

   subroutine fm_hypot(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmhypot(ma%mfm, mb%mfm, mc%mfm)
   end subroutine fm_hypot

   subroutine fm_i2m(ival, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      integer :: ival
      intent (in) :: ival
      call fmi2m(ival, ma%mfm)
   end subroutine fm_i2m

   subroutine fm_inp(line, ma, la, lb)
      use fmvals
      implicit none
      integer :: la, lb
      intent (in) :: la, lb
      character :: line(lb)
      intent (in) :: line
      type (fm) :: ma
      intent (inout) :: ma
      call fminp(line, ma%mfm, la, lb)
   end subroutine fm_inp

   subroutine fm_int(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmint(ma%mfm, mb%mfm)
   end subroutine fm_int

   subroutine fm_ipwr(ma, ival, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival
      intent (in) :: ival
      call fm_undef_inp(ma)
      call fmipwr(ma%mfm, ival, mb%mfm)
   end subroutine fm_ipwr

   subroutine fm_lg10(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmlg10(ma%mfm, mb%mfm)
   end subroutine fm_lg10

   subroutine fm_ln(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmln(ma%mfm, mb%mfm)
   end subroutine fm_ln

   subroutine fm_lni(ival, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      integer :: ival
      intent (in) :: ival
      call fmlni(ival, ma%mfm)
   end subroutine fm_lni

   subroutine fm_m2dp(ma, x)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (in) :: ma
      double precision :: x
      intent (inout) :: x
      call fm_undef_inp(ma)
      call fmm2dp(ma%mfm, x)
   end subroutine fm_m2dp

   subroutine fm_m2i(ma, ival)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (in) :: ma
      integer :: ival
      intent (inout) :: ival
      call fm_undef_inp(ma)
      call fmm2i(ma%mfm, ival)
   end subroutine fm_m2i

   subroutine fm_m2sp(ma, x)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (in) :: ma
      real :: x
      intent (inout) :: x
      call fm_undef_inp(ma)
      call fmm2sp(ma%mfm, x)
   end subroutine fm_m2sp

   subroutine fm_max(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmmax(ma%mfm, mb%mfm, mc%mfm)
   end subroutine fm_max

   subroutine fm_min(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmmin(ma%mfm, mb%mfm, mc%mfm)
   end subroutine fm_min

   subroutine fm_mod(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmmod(ma%mfm, mb%mfm, mc%mfm)
   end subroutine fm_mod

   subroutine fm_modulo(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmmod(ma%mfm, mb%mfm, mtlvfm)
      if (mtlvfm%mp(3) /= 0) then
          if ((ma%mfm%mp(3) > 0 .and. ma%mfm%mp(1) > 0 .and.  &
               mb%mfm%mp(3) > 0 .and. mb%mfm%mp(1) < 0) .or.  &
              (ma%mfm%mp(3) > 0 .and. ma%mfm%mp(1) < 0 .and.  &
               mb%mfm%mp(3) > 0 .and. mb%mfm%mp(1) > 0)) then
              call fmadd_r1(mtlvfm, mb%mfm)
          endif
      endif
      call fmeq(mtlvfm, mc%mfm)
   end subroutine fm_modulo

   subroutine fm_mpy(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmmpy(ma%mfm, mb%mfm, mc%mfm)
   end subroutine fm_mpy

   subroutine fm_mpy_r1(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: mb
      intent (inout) :: ma
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmmpy_r1(ma%mfm, mb%mfm)
   end subroutine fm_mpy_r1

   subroutine fm_mpy_r2(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmmpy_r2(ma%mfm, mb%mfm)
   end subroutine fm_mpy_r2

   subroutine fm_mpyi(ma, ival, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival
      intent (in) :: ival
      call fm_undef_inp(ma)
      call fmmpyi(ma%mfm, ival, mb%mfm)
   end subroutine fm_mpyi

   subroutine fm_mpyi_r1(ma, ival)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      integer :: ival
      intent (in) :: ival
      call fm_undef_inp(ma)
      call fmmpyi_r1(ma%mfm, ival)
   end subroutine fm_mpyi_r1

   subroutine fm_nearest(ma, mb, mc)
      use fmvals
      use fmzm_8
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_eq(fmnearest_fm(ma, mb), mc)
   end subroutine fm_nearest

   subroutine fm_nint(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmnint(ma%mfm, mb%mfm)
   end subroutine fm_nint

   subroutine fm_out(ma, line, lb)
      use fmvals
      implicit none
      integer :: lb
      intent (in) :: lb
      character :: line(lb)
      intent (inout) :: line
      type (fm) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmout(ma%mfm, line, lb)
   end subroutine fm_out

   subroutine fm_pi(ma)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      call fmpi(ma%mfm)
   end subroutine fm_pi

   subroutine fm_prnt(ma)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmprnt(ma%mfm)
   end subroutine fm_prnt

   subroutine fm_pwr(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmpwr(ma%mfm, mb%mfm, mc%mfm)
   end subroutine fm_pwr

   subroutine fm_read(kread, ma)
      use fmvals
      implicit none
      integer :: kread
      type (fm) :: ma
      intent (in) :: kread
      intent (inout) :: ma
      call fmread(kread, ma%mfm)
   end subroutine fm_read

   subroutine fm_rpwr(ma, ival, jval, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival, jval
      intent (in) :: ival, jval
      call fm_undef_inp(ma)
      call fmrpwr(ma%mfm, ival, jval, mb%mfm)
   end subroutine fm_rpwr

   subroutine fm_rrspacing(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmabs(ma%mfm, mtlvfm)
      mtlvfm%mp(2) = ndig
      call fmeq(mtlvfm, mb%mfm)
   end subroutine fm_rrspacing

   subroutine fm_set(nprec)
      use fmvals
      implicit none
      integer :: nprec
      intent (in) :: nprec
      call fmset(nprec)
   end subroutine fm_set

   subroutine fm_setvar(string)
      use fmvals
      implicit none
      character(*) :: string
      intent (in) :: string
      call fmsetvar(string)
   end subroutine fm_setvar

   subroutine fm_sign(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmsign(ma%mfm, mb%mfm, mc%mfm)
   end subroutine fm_sign

   subroutine fm_sin(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmsin(ma%mfm, mb%mfm)
   end subroutine fm_sin

   subroutine fm_sinh(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmsinh(ma%mfm, mb%mfm)
   end subroutine fm_sinh

   subroutine fm_sp2m(x, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      real :: x
      intent (in) :: x
      call fmsp2m(x, ma%mfm)
   end subroutine fm_sp2m

   subroutine fm_spacing(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      type(multi), save :: mtlvfm
      call fm_undef_inp(ma)
      call fmabs(ma%mfm, mtlvfm)
      call fmulp(mtlvfm, mb%mfm)
   end subroutine fm_spacing

   subroutine fm_sqr(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmsqr(ma%mfm, mb%mfm)
   end subroutine fm_sqr

   subroutine fm_sqr_r1(ma)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      call fm_undef_inp(ma)
      call fmsqr_r1(ma%mfm)
   end subroutine fm_sqr_r1

   subroutine fm_sqrt(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmsqrt(ma%mfm, mb%mfm)
   end subroutine fm_sqrt

   subroutine fm_sqrt_r1(ma)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      call fm_undef_inp(ma)
      call fmsqrt_r1(ma%mfm)
   end subroutine fm_sqrt_r1

   subroutine fm_st2m(string, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      character(*) :: string
      intent (in) :: string
      call fmst2m(string, ma%mfm)
   end subroutine fm_st2m

   subroutine fm_sub(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmsub(ma%mfm, mb%mfm, mc%mfm)
   end subroutine fm_sub

   subroutine fm_sub_r1(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: mb
      intent (inout) :: ma
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmsub_r1(ma%mfm, mb%mfm)
   end subroutine fm_sub_r1

   subroutine fm_sub_r2(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmsub_r2(ma%mfm, mb%mfm)
   end subroutine fm_sub_r2

   subroutine fm_tan(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmtan(ma%mfm, mb%mfm)
   end subroutine fm_tan

   subroutine fm_tanh(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmtanh(ma%mfm, mb%mfm)
   end subroutine fm_tanh

   subroutine fm_tiny(ma)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      call fmtiny(ma%mfm)
   end subroutine fm_tiny

   subroutine fm_ulp(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmulp(ma%mfm, mb%mfm)
   end subroutine fm_ulp

   subroutine fm_vars
      use fmvals
      implicit none
      call fmvars
   end subroutine fm_vars

   subroutine fm_writ(kwrite, ma)
      use fmvals
      implicit none
      integer :: kwrite
      intent (in) :: kwrite
      type (fm) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fmwrit(kwrite, ma%mfm)
   end subroutine fm_writ

   subroutine im_abs(ma, mb)
      use fmvals
      implicit none
      type (im) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call imabs(ma%mim, mb%mim)
   end subroutine im_abs

   subroutine im_add(ma, mb, mc)
      use fmvals
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imadd(ma%mim, mb%mim, mc%mim)
   end subroutine im_add

   subroutine im_big(ma)
      use fmvals
      implicit none
      type (im) :: ma
      intent (inout) :: ma
      call imbig(ma%mim)
   end subroutine im_big

   subroutine im_comb(ma, mb, mc)
      use fmvals
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call imcomb(ma%mim, mb%mim, mc%mim)
   end subroutine im_comb

   function im_comp(ma, lrel, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: imcomp
      type (im) :: ma, mb
      intent (in) :: ma, mb
      character(*) :: lrel
      intent (in) :: lrel
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      return_value = imcomp(ma%mim, lrel, mb%mim)
   end function im_comp

   subroutine im_dim(ma, mb, mc)
      use fmvals
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imdim(ma%mim, mb%mim, mc%mim)
   end subroutine im_dim

   subroutine im_div(ma, mb, mc)
      use fmvals
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imdiv(ma%mim, mb%mim, mc%mim)
   end subroutine im_div

   subroutine im_divi(ma, ival, mb)
      use fmvals
      implicit none
      type (im) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival
      intent (in) :: ival
      call fm_undef_inp(ma)
      call imdivi(ma%mim, ival, mb%mim)
   end subroutine im_divi

   subroutine im_divr(ma, mb, mc, md)
      use fmvals
      implicit none
      type (im) :: ma, mb, mc, md
      intent (in) :: ma, mb
      intent (inout) :: mc, md
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imdivr(ma%mim, mb%mim, mc%mim, md%mim)
   end subroutine im_divr

   subroutine im_dvir(ma, ival, mb, irem)
      use fmvals
      implicit none
      type (im) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival, irem
      intent (in) :: ival
      intent (inout) :: irem
      call fm_undef_inp(ma)
      call imdvir(ma%mim, ival, mb%mim, irem)
   end subroutine im_dvir

   subroutine im_fact(ival, ma)
      use fmvals
      implicit none
      type (im) :: ma
      integer :: ival
      intent (in) :: ival
      intent (inout) :: ma
      call imfact(ival, ma%mim)
   end subroutine im_fact

   subroutine im_fm2i(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (in) :: ma
      type (im) :: mb
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call imfm2i(ma%mfm, mb%mim)
   end subroutine im_fm2i

   subroutine im_form(form, ma, string)
      use fmvals
      implicit none
      character(*) :: form, string
      intent (in) :: form, ma
      type (im) :: ma
      intent (inout) :: string
      call fm_undef_inp(ma)
      call imform(form, ma%mim, string)
   end subroutine im_form

   subroutine im_fprt(form, ma)
      use fmvals
      implicit none
      character(*) :: form
      intent (in) :: form
      type (im) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imfprt(form, ma%mim)
   end subroutine im_fprt

   subroutine im_gcd(ma, mb, mc)
      use fmvals
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imgcd(ma%mim, mb%mim, mc%mim)
   end subroutine im_gcd

   subroutine im_i2fm(ma, mb)
      use fmvals
      implicit none
      type (im) :: ma
      intent (in) :: ma
      type (fm) :: mb
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call imi2fm(ma%mim, mb%mfm)
   end subroutine im_i2fm

   subroutine im_i2m(ival, ma)
      use fmvals
      implicit none
      type (im) :: ma
      intent (inout) :: ma
      integer :: ival
      intent (in) :: ival
      call imi2m(ival, ma%mim)
   end subroutine im_i2m

   subroutine im_inp(line, ma, la, lb)
      use fmvals
      implicit none
      integer :: la, lb
      intent (in) :: la, lb
      character :: line(lb)
      intent (in) :: line
      type (im) :: ma
      intent (inout) :: ma
      call iminp(line, ma%mim, la, lb)
   end subroutine im_inp

   subroutine im_m2dp(ma, x)
      use fmvals
      implicit none
      type (im) :: ma
      intent (in) :: ma
      double precision :: x
      intent (inout) :: x
      call fm_undef_inp(ma)
      call imm2dp(ma%mim, x)
   end subroutine im_m2dp

   subroutine im_m2i(ma, ival)
      use fmvals
      implicit none
      type (im) :: ma
      intent (in) :: ma
      integer :: ival
      intent (inout) :: ival
      call fm_undef_inp(ma)
      call imm2i(ma%mim, ival)
   end subroutine im_m2i

   subroutine im_max(ma, mb, mc)
      use fmvals
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call immax(ma%mim, mb%mim, mc%mim)
   end subroutine im_max

   subroutine im_min(ma, mb, mc)
      use fmvals
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call immin(ma%mim, mb%mim, mc%mim)
   end subroutine im_min

   subroutine im_mod(ma, mb, mc)
      use fmvals
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call immod(ma%mim, mb%mim, mc%mim)
   end subroutine im_mod

   subroutine im_mpy(ma, mb, mc)
      use fmvals
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call immpy(ma%mim, mb%mim, mc%mim)
   end subroutine im_mpy

   subroutine im_mpyi(ma, ival, mb)
      use fmvals
      implicit none
      type (im) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival
      intent (in) :: ival
      call fm_undef_inp(ma)
      call immpyi(ma%mim, ival, mb%mim)
   end subroutine im_mpyi

   subroutine im_mpym(ma, mb, mc, md)
      use fmvals
      implicit none
      type (im) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fm_undef_inp(mc)
      call immpym(ma%mim, mb%mim, mc%mim, md%mim)
   end subroutine im_mpym

   subroutine im_out(ma, line, lb)
      use fmvals
      implicit none
      integer :: lb
      intent (in) :: lb
      character :: line(lb)
      intent (inout) :: line
      type (im) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imout(ma%mim, line, lb)
   end subroutine im_out

   subroutine im_pmod(ma, mb, mc, md)
      use fmvals
      implicit none
      type (im) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fm_undef_inp(mc)
      call impmod(ma%mim, mb%mim, mc%mim, md%mim)
   end subroutine im_pmod

   subroutine im_prnt(ma)
      use fmvals
      implicit none
      type (im) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imprnt(ma%mim)
   end subroutine im_prnt

   subroutine im_pwr(ma, mb, mc)
      use fmvals
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call impwr(ma%mim, mb%mim, mc%mim)
   end subroutine im_pwr

   subroutine im_read(kread, ma)
      use fmvals
      implicit none
      integer :: kread
      intent (in) :: kread
      type (im) :: ma
      intent (inout) :: ma
      call imread(kread, ma%mim)
   end subroutine im_read

   subroutine im_sign(ma, mb, mc)
      use fmvals
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imsign(ma%mim, mb%mim, mc%mim)
   end subroutine im_sign

   subroutine im_sqr(ma, mb)
      use fmvals
      implicit none
      type (im) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call imsqr(ma%mim, mb%mim)
   end subroutine im_sqr

   subroutine im_st2m(string, ma)
      use fmvals
      implicit none
      type (im) :: ma
      intent (inout) :: ma
      character(*) :: string
      intent (in) :: string
      call imst2m(string, ma%mim)
   end subroutine im_st2m

   subroutine im_sub(ma, mb, mc)
      use fmvals
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call imsub(ma%mim, mb%mim, mc%mim)
   end subroutine im_sub

   subroutine im_writ(kwrite, ma)
      use fmvals
      implicit none
      integer :: kwrite
      intent (in) :: kwrite
      type (im) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call imwrit(kwrite, ma%mim)
   end subroutine im_writ

   subroutine zm_abs(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma
      intent (in) :: ma
      type (fm) :: mb
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmabs(ma%mzm, mb%mfm)
   end subroutine zm_abs

   subroutine zm_acos(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmacos(ma%mzm, mb%mzm)
   end subroutine zm_acos

   subroutine zm_acosh(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmacosh(ma%mzm, mb%mzm)
   end subroutine zm_acosh

   subroutine zm_add(ma, mb, mc)
      use fmvals
      implicit none
      type (zm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmadd(ma%mzm, mb%mzm, mc%mzm)
   end subroutine zm_add

   subroutine zm_addi(ma, ival)
      use fmvals
      implicit none
      type (zm) :: ma
      intent (inout) :: ma
      integer :: ival
      intent (in) :: ival
      call fm_undef_inp(ma)
      call zmaddi(ma%mzm, ival)
   end subroutine zm_addi

   subroutine zm_arg(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma
      intent (in) :: ma
      type (fm) :: mb
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmarg(ma%mzm, mb%mfm)
   end subroutine zm_arg

   subroutine zm_asin(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmasin(ma%mzm, mb%mzm)
   end subroutine zm_asin

   subroutine zm_asinh(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmasinh(ma%mzm, mb%mzm)
   end subroutine zm_asinh

   subroutine zm_atan(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmatan(ma%mzm, mb%mzm)
   end subroutine zm_atan

   subroutine zm_atanh(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmatanh(ma%mzm, mb%mzm)
   end subroutine zm_atanh

   subroutine zm_chsh(ma, mb, mc)
      use fmvals
      implicit none
      type (zm) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      call fm_undef_inp(ma)
      call zmchsh(ma%mzm, mb%mzm, mc%mzm)
   end subroutine zm_chsh

   subroutine zm_cmpx(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma, mb
      type (zm) :: mc
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmcmpx(ma%mfm, mb%mfm, mc%mzm)
   end subroutine zm_cmpx

   subroutine zm_conj(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmconj(ma%mzm, mb%mzm)
   end subroutine zm_conj

   subroutine zm_cos(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmcos(ma%mzm, mb%mzm)
   end subroutine zm_cos

   subroutine zm_cosh(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmcosh(ma%mzm, mb%mzm)
   end subroutine zm_cosh

   subroutine zm_cssn(ma, mb, mc)
      use fmvals
      implicit none
      type (zm) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      call fm_undef_inp(ma)
      call zmcssn(ma%mzm, mb%mzm, mc%mzm)
   end subroutine zm_cssn

   subroutine zm_div(ma, mb, mc)
      use fmvals
      implicit none
      type (zm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmdiv(ma%mzm, mb%mzm, mc%mzm)
   end subroutine zm_div

   subroutine zm_divi(ma, ival, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival
      intent (in) :: ival
      call fm_undef_inp(ma)
      call zmdivi(ma%mzm, ival, mb%mzm)
   end subroutine zm_divi

   subroutine zm_equ(ma, mb, na, nb)

!  Set mb (having nb digits) equal to ma (having na digits).

!  If mb has less precision than ma the result is rounded to nb digits.

!  If mb has more precision the result has zero digits padded on the right, and will have
!  its size increased if needed.

      use fmvals
      implicit none
      integer :: na, nb
      intent (in) :: na, nb
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmequ(ma%mzm, mb%mzm, na, nb)
   end subroutine zm_equ

   subroutine zm_equ_r1(ma, na, nb)

!  Set ma (having nb digits) equal to ma (having na digits).

!  If nb is less than na the result is rounded to nb digits.

!  If nb is greater than na the result has zero digits padded on the right.

      use fmvals
      implicit none
      integer :: na, nb
      intent (in) :: na, nb
      type (zm) :: ma
      intent (inout) :: ma
      call fm_undef_inp(ma)
      call zmequ_r1(ma%mzm, na, nb)
   end subroutine zm_equ_r1

   subroutine zm_exp(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmexp(ma%mzm, mb%mzm)
   end subroutine zm_exp

   subroutine zm_form(form1, form2, ma, string)
      use fmvals
      implicit none
      character(*) :: form1, form2, string
      intent (in) :: form1, form2
      intent (inout) :: string
      type (zm) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmform(form1, form2, ma%mzm, string)
   end subroutine zm_form

   subroutine zm_fprt(form1, form2, ma)
      use fmvals
      implicit none
      character(*) :: form1, form2
      intent (in) :: form1, form2
      type (zm) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmfprt(form1, form2, ma%mzm)
   end subroutine zm_fprt

   subroutine zm_i2m(ival, ma)
      use fmvals
      implicit none
      type (zm) :: ma
      intent (inout) :: ma
      integer :: ival
      intent (in) :: ival
      call zmi2m(ival, ma%mzm)
   end subroutine zm_i2m

   subroutine zm_2i2m(ival1, ival2, ma)
      use fmvals
      implicit none
      type (zm) :: ma
      intent (inout) :: ma
      integer :: ival1, ival2
      intent (in) :: ival1, ival2
      call zm2i2m(ival1, ival2, ma%mzm)
   end subroutine zm_2i2m

   subroutine zm_imag(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma
      intent (in) :: ma
      type (fm) :: mb
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmimag(ma%mzm, mb%mfm)
   end subroutine zm_imag

   subroutine zm_inp(line, ma, la, lb)
      use fmvals
      implicit none
      integer :: la, lb
      intent (in) :: la, lb
      character :: line(lb)
      intent (in) :: line
      type (zm) :: ma
      intent (inout) :: ma
      call zminp(line, ma%mzm, la, lb)
   end subroutine zm_inp

   subroutine zm_int(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmint(ma%mzm, mb%mzm)
   end subroutine zm_int

   subroutine zm_ipwr(ma, ival, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival
      intent (in) :: ival
      call fm_undef_inp(ma)
      call zmipwr(ma%mzm, ival, mb%mzm)
   end subroutine zm_ipwr

   subroutine zm_lg10(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmlg10(ma%mzm, mb%mzm)
   end subroutine zm_lg10

   subroutine zm_ln(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmln(ma%mzm, mb%mzm)
   end subroutine zm_ln

   subroutine zm_m2i(ma, ival)
      use fmvals
      implicit none
      type (zm) :: ma
      intent (in) :: ma
      integer :: ival
      intent (inout) :: ival
      call fm_undef_inp(ma)
      call zmm2i(ma%mzm, ival)
   end subroutine zm_m2i

   subroutine zm_m2z(ma, zval)
      use fmvals
      implicit none
      type (zm) :: ma
      intent (in) :: ma
      complex :: zval
      intent (inout) :: zval
      call fm_undef_inp(ma)
      call zmm2z(ma%mzm, zval)
   end subroutine zm_m2z

   subroutine zm_mpy(ma, mb, mc)
      use fmvals
      implicit none
      type (zm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmmpy(ma%mzm, mb%mzm, mc%mzm)
   end subroutine zm_mpy

   subroutine zm_mpyi(ma, ival, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival
      intent (in) :: ival
      call fm_undef_inp(ma)
      call zmmpyi(ma%mzm, ival, mb%mzm)
   end subroutine zm_mpyi

   subroutine zm_nint(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmnint(ma%mzm, mb%mzm)
   end subroutine zm_nint

   subroutine zm_out(ma, line, lb, last1, last2)
      use fmvals
      implicit none
      integer :: lb, last1, last2
      intent (in) :: lb
      character :: line(lb)
      intent (inout) :: line, last1, last2
      type (zm) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmout(ma%mzm, line, lb, last1, last2)
   end subroutine zm_out

   subroutine zm_prnt(ma)
      use fmvals
      implicit none
      type (zm) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmprnt(ma%mzm)
   end subroutine zm_prnt

   subroutine zm_pwr(ma, mb, mc)
      use fmvals
      implicit none
      type (zm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmpwr(ma%mzm, mb%mzm, mc%mzm)
   end subroutine zm_pwr

   subroutine zm_read(kread, ma)
      use fmvals
      implicit none
      integer :: kread
      intent (in) :: kread
      type (zm) :: ma
      intent (inout) :: ma
      call zmread(kread, ma%mzm)
   end subroutine zm_read

   subroutine zm_real(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma
      intent (in) :: ma
      type (fm) :: mb
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmreal(ma%mzm, mb%mfm)
   end subroutine zm_real

   subroutine zm_rpwr(ma, ival, jval, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: ival, jval
      intent (in) :: ival, jval
      call fm_undef_inp(ma)
      call zmrpwr(ma%mzm, ival, jval, mb%mzm)
   end subroutine zm_rpwr

   subroutine zm_set(nprec)
      use fmvals
      implicit none
      integer :: nprec
      intent (in) :: nprec
      call zmset(nprec)
   end subroutine zm_set

   subroutine zm_sin(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmsin(ma%mzm, mb%mzm)
   end subroutine zm_sin

   subroutine zm_sinh(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmsinh(ma%mzm, mb%mzm)
   end subroutine zm_sinh

   subroutine zm_sqr(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmsqr(ma%mzm, mb%mzm)
   end subroutine zm_sqr

   subroutine zm_sqrt(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmsqrt(ma%mzm, mb%mzm)
   end subroutine zm_sqrt

   subroutine zm_st2m(string, ma)
      use fmvals
      implicit none
      type (zm) :: ma
      intent (inout) :: ma
      character(*) :: string
      intent (in) :: string
      call zmst2m(string, ma%mzm)
   end subroutine zm_st2m

   subroutine zm_sub(ma, mb, mc)
      use fmvals
      implicit none
      type (zm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zmsub(ma%mzm, mb%mzm, mc%mzm)
   end subroutine zm_sub

   subroutine zm_tan(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmtan(ma%mzm, mb%mzm)
   end subroutine zm_tan

   subroutine zm_tanh(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmtanh(ma%mzm, mb%mzm)
   end subroutine zm_tanh

   subroutine zm_writ(kwrite, ma)
      use fmvals
      implicit none
      integer :: kwrite
      intent (in) :: kwrite
      type (zm) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zmwrit(kwrite, ma%mzm)
   end subroutine zm_writ

   subroutine zm_z2m(zval, ma)
      use fmvals
      implicit none
      type (zm) :: ma
      intent (inout) :: ma
      complex :: zval
      intent (in) :: zval
      call zmz2m(zval, ma%mzm)
   end subroutine zm_z2m

   subroutine zm_erf(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmerf(ma%mzm, mb%mzm)
   end subroutine zm_erf

   subroutine zm_erfc(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmerfc(ma%mzm, mb%mzm)
   end subroutine zm_erfc

   subroutine zm_erfcs(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmerfcs(ma%mzm, mb%mzm)
   end subroutine zm_erfcs

   subroutine zm_lngm(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmlngm(ma%mzm, mb%mzm)
   end subroutine zm_lngm

   subroutine zm_gam(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmgam(ma%mzm, mb%mzm)
   end subroutine zm_gam

   subroutine zm_fact(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zmfact(ma%mzm, mb%mzm)
   end subroutine zm_fact

   subroutine fm_atan2(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fm_atn2(ma, mb, mc)
   end subroutine fm_atan2

   subroutine fm_cosh_sinh(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      call fm_undef_inp(ma)
      call fm_chsh(ma, mb, mc)
   end subroutine fm_cosh_sinh

   function fm_compare(ma, lrel, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: fmcomp
      character(*) :: lrel
      type (fm) :: ma, mb
      intent (in) :: ma, lrel, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      return_value = fmcomp(ma%mfm, lrel, mb%mfm)
   end function fm_compare

   subroutine fm_cos_sin(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      call fm_undef_inp(ma)
      call fm_cssn(ma, mb, mc)
   end subroutine fm_cos_sin

   subroutine fm_euler(ma)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      call fm_eulr(ma)
   end subroutine fm_euler

   subroutine fm_fprint(form, ma)
      use fmvals
      implicit none
      character(*) :: form
      type (fm) :: ma
      intent (in) :: form, ma
      call fm_undef_inp(ma)
      call fm_fprt(form, ma)
   end subroutine fm_fprint

   subroutine fm_ipower(ma, ival, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fm_ipwr(ma, ival, mb)
   end subroutine fm_ipower

   subroutine fm_log10(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fm_lg10(ma, mb)
   end subroutine fm_log10

   subroutine fm_print(ma)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call fm_prnt(ma)
   end subroutine fm_print

   subroutine fm_power(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fm_pwr(ma, mb, mc)
   end subroutine fm_power

   subroutine fm_rational_power(ma, ival, jval, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      integer :: ival, jval
      intent (in) :: ma, ival, jval
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fm_rpwr(ma, ival, jval, mb)
   end subroutine fm_rational_power

   subroutine fm_write(kwrite, ma)
      use fmvals
      implicit none
      integer :: kwrite
      type (fm) :: ma
      intent (in) :: kwrite, ma
      call fm_undef_inp(ma)
      call fm_writ(kwrite, ma)
   end subroutine fm_write

   function im_compare(ma, lrel, mb)     result (return_value)
      use fmvals
      implicit none
      logical :: return_value
      logical, external :: imcomp
      character(*) :: lrel
      type (im) :: ma, mb
      intent (in) :: ma, lrel, mb
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      return_value = imcomp(ma%mim, lrel, mb%mim)
   end function im_compare

   subroutine im_fprint(form, ma)
      use fmvals
      implicit none
      character(*) :: form
      type (im) :: ma
      intent (in) :: form, ma
      call fm_undef_inp(ma)
      call im_fprt(form, ma)
   end subroutine im_fprint

   subroutine im_mpy_mod(ma, mb, mc, md)
      use fmvals
      implicit none
      type (im) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fm_undef_inp(mc)
      call im_mpym(ma, mb, mc, md)
   end subroutine im_mpy_mod

   subroutine im_power_mod(ma, mb, mc, md)
      use fmvals
      implicit none
      type (im) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fm_undef_inp(mc)
      call im_pmod(ma, mb, mc, md)
   end subroutine im_power_mod

   subroutine im_print(ma)
      use fmvals
      implicit none
      type (im) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call im_prnt(ma)
   end subroutine im_print

   subroutine im_power(ma, mb, mc)
      use fmvals
      implicit none
      type (im) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call im_pwr(ma, mb, mc)
   end subroutine im_power

   subroutine im_write(kwrite, ma)
      use fmvals
      implicit none
      integer :: kwrite
      intent (in) :: kwrite
      type (im) :: ma
      intent (inout) :: ma
      call imwrite(kwrite, ma%mim)
   end subroutine im_write

   subroutine zm_cosh_sinh(ma, mb, mc)
      use fmvals
      implicit none
      type (zm) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      call fm_undef_inp(ma)
      call zm_chsh(ma, mb, mc)
   end subroutine zm_cosh_sinh

   subroutine zm_complex(mafm, mbfm, mc)
      use fmvals
      implicit none
      type (fm) :: mafm, mbfm
      type (zm) :: mc
      intent (in) :: mafm, mbfm
      intent (inout) :: mc
      call fm_undef_inp(mafm)
      call fm_undef_inp(mbfm)
      call zm_cmpx(mafm, mbfm, mc)
   end subroutine zm_complex

   subroutine zm_conjugate(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zm_conj(ma, mb)
   end subroutine zm_conjugate

   subroutine zm_cos_sin(ma, mb, mc)
      use fmvals
      implicit none
      type (zm) :: ma, mb, mc
      intent (in) :: ma
      intent (inout) :: mb, mc
      call fm_undef_inp(ma)
      call zm_cssn(ma, mb, mc)
   end subroutine zm_cos_sin

   subroutine zm_fprint(form1, form2, ma)
      use fmvals
      implicit none
      character(*) :: form1, form2
      type (zm) :: ma
      intent (in) :: form1, form2, ma
      call fm_undef_inp(ma)
      call zm_fprt(form1, form2, ma)
   end subroutine zm_fprint

   subroutine zm_ipower(ma, ival, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      integer :: ival
      intent (in) :: ma, ival
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zm_ipwr(ma, ival, mb)
   end subroutine zm_ipower

   subroutine zm_log10(ma, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zm_lg10(ma, mb)
   end subroutine zm_log10

   subroutine zm_print(ma)
      use fmvals
      implicit none
      type (zm) :: ma
      intent (in) :: ma
      call fm_undef_inp(ma)
      call zm_prnt(ma)
   end subroutine zm_print

   subroutine zm_power(ma, mb, mc)
      use fmvals
      implicit none
      type (zm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call zm_pwr(ma, mb, mc)
   end subroutine zm_power

   subroutine zm_rational_power(ma, ival, jval, mb)
      use fmvals
      implicit none
      type (zm) :: ma, mb
      integer :: ival, jval
      intent (in) :: ma, ival, jval
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call zm_rpwr(ma, ival, jval, mb)
   end subroutine zm_rational_power

   subroutine zm_write(kwrite, ma)
      use fmvals
      implicit none
      integer :: kwrite
      type (zm) :: ma
      intent (in) :: kwrite, ma
      call fm_undef_inp(ma)
      call zm_writ(kwrite, ma)
   end subroutine zm_write

   subroutine fm_bernoulli(n, ma)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      integer :: n
      intent (in) :: n
      call fmbernoulli(n, ma%mfm)
   end subroutine fm_bernoulli

   subroutine fm_bern(n, ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: n
      intent (in) :: n
      call fm_undef_inp(ma)
      call fmbern(n, ma%mfm, mb%mfm)
   end subroutine fm_bern

   subroutine fm_beta(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmbeta(ma%mfm, mb%mfm, mc%mfm)
   end subroutine fm_beta

   subroutine fm_comb(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmcomb(ma%mfm, mb%mfm, mc%mfm)
   end subroutine fm_comb

   subroutine fm_eulr(ma)
      use fmvals
      implicit none
      type (fm) :: ma
      intent (inout) :: ma
      call fmeulr(ma%mfm)
   end subroutine fm_eulr

   subroutine fm_fact(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmfact(ma%mfm, mb%mfm)
   end subroutine fm_fact

   subroutine fm_gam(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmgam(ma%mfm, mb%mfm)
   end subroutine fm_gam

   subroutine fm_ibta(ma, mb, mc, md)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc, md
      intent (in) :: ma, mb, mc
      intent (inout) :: md
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fm_undef_inp(mc)
      call fmibta(ma%mfm, mb%mfm, mc%mfm, md%mfm)
   end subroutine fm_ibta

   subroutine fm_igm1(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmigm1(ma%mfm, mb%mfm, mc%mfm)
   end subroutine fm_igm1

   subroutine fm_igm2(ma, mb, mc)
      use fmvals
      implicit none
      type (fm) :: ma, mb, mc
      intent (in) :: ma, mb
      intent (inout) :: mc
      call fm_undef_inp(ma)
      call fm_undef_inp(mb)
      call fmigm2(ma%mfm, mb%mfm, mc%mfm)
   end subroutine fm_igm2

   subroutine fm_lngm(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmlngm(ma%mfm, mb%mfm)
   end subroutine fm_lngm

   subroutine fm_pgam(n, ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: n
      intent (in) :: n
      call fm_undef_inp(ma)
      call fmpgam(n, ma%mfm, mb%mfm)
   end subroutine fm_pgam

   subroutine fm_poch(ma, n, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: n
      intent (in) :: n
      call fm_undef_inp(ma)
      call fmpoch(ma%mfm, n, mb%mfm)
   end subroutine fm_poch

   subroutine fm_psi(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmpsi(ma%mfm, mb%mfm)
   end subroutine fm_psi

   subroutine fm_besj(n, ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: n
      intent (in) :: n
      call fm_undef_inp(ma)
      call fmbesj(n, ma%mfm, mb%mfm)
   end subroutine fm_besj

   subroutine fm_besy(n, ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: n
      intent (in) :: n
      call fm_undef_inp(ma)
      call fmbesy(n, ma%mfm, mb%mfm)
   end subroutine fm_besy

   subroutine fm_chi(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmchi(ma%mfm, mb%mfm)
   end subroutine fm_chi

   subroutine fm_ci(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmci(ma%mfm, mb%mfm)
   end subroutine fm_ci

   subroutine fm_ei(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmei(ma%mfm, mb%mfm)
   end subroutine fm_ei

   subroutine fm_en(n, ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      integer :: n
      intent (in) :: n
      call fm_undef_inp(ma)
      call fmen(n, ma%mfm, mb%mfm)
   end subroutine fm_en

   subroutine fm_c(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmc(ma%mfm, mb%mfm)
   end subroutine fm_c

   subroutine fm_s(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fms(ma%mfm, mb%mfm)
   end subroutine fm_s

   subroutine fm_erf(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmerf(ma%mfm, mb%mfm)
   end subroutine fm_erf

   subroutine fm_erfc(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmerfc(ma%mfm, mb%mfm)
   end subroutine fm_erfc

   subroutine fm_erfcs(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmerfcs(ma%mfm, mb%mfm)
   end subroutine fm_erfcs

   subroutine fm_erfc_scaled(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmerfcs(ma%mfm, mb%mfm)
   end subroutine fm_erfc_scaled

   subroutine fm_lerc(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmlerc(ma%mfm, mb%mfm)
   end subroutine fm_lerc

   subroutine fm_li(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmli(ma%mfm, mb%mfm)
   end subroutine fm_li

   subroutine fm_shi(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmshi(ma%mfm, mb%mfm)
   end subroutine fm_shi

   subroutine fm_si(ma, mb)
      use fmvals
      implicit none
      type (fm) :: ma, mb
      intent (in) :: ma
      intent (inout) :: mb
      call fm_undef_inp(ma)
      call fmsi(ma%mfm, mb%mfm)
   end subroutine fm_si

 end module fmzm_10

 module fmzm

   use fmzm_1
   use fmzm_2
   use fmzm_3
   use fmzm_4
   use fmzm_5
   use fmzm_6
   use fmzm_7
   use fmzm_8
   use fmzm_9
   use fmzm_10

 end module fmzm
